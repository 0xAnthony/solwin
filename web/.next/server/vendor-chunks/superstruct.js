"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/superstruct";
exports.ids = ["vendor-chunks/superstruct"];
exports.modules = {

/***/ "(ssr)/../anchor/node_modules/superstruct/lib/index.es.js":
/*!**********************************************************!*\
  !*** ../anchor/node_modules/superstruct/lib/index.es.js ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Struct: () => (/* binding */ Struct),\n/* harmony export */   StructError: () => (/* binding */ StructError),\n/* harmony export */   any: () => (/* binding */ any),\n/* harmony export */   array: () => (/* binding */ array),\n/* harmony export */   assert: () => (/* binding */ assert),\n/* harmony export */   assign: () => (/* binding */ assign),\n/* harmony export */   bigint: () => (/* binding */ bigint),\n/* harmony export */   boolean: () => (/* binding */ boolean),\n/* harmony export */   coerce: () => (/* binding */ coerce),\n/* harmony export */   create: () => (/* binding */ create),\n/* harmony export */   date: () => (/* binding */ date),\n/* harmony export */   defaulted: () => (/* binding */ defaulted),\n/* harmony export */   define: () => (/* binding */ define),\n/* harmony export */   deprecated: () => (/* binding */ deprecated),\n/* harmony export */   dynamic: () => (/* binding */ dynamic),\n/* harmony export */   empty: () => (/* binding */ empty),\n/* harmony export */   enums: () => (/* binding */ enums),\n/* harmony export */   func: () => (/* binding */ func),\n/* harmony export */   instance: () => (/* binding */ instance),\n/* harmony export */   integer: () => (/* binding */ integer),\n/* harmony export */   intersection: () => (/* binding */ intersection),\n/* harmony export */   is: () => (/* binding */ is),\n/* harmony export */   lazy: () => (/* binding */ lazy),\n/* harmony export */   literal: () => (/* binding */ literal),\n/* harmony export */   map: () => (/* binding */ map),\n/* harmony export */   mask: () => (/* binding */ mask),\n/* harmony export */   max: () => (/* binding */ max),\n/* harmony export */   min: () => (/* binding */ min),\n/* harmony export */   never: () => (/* binding */ never),\n/* harmony export */   nonempty: () => (/* binding */ nonempty),\n/* harmony export */   nullable: () => (/* binding */ nullable),\n/* harmony export */   number: () => (/* binding */ number),\n/* harmony export */   object: () => (/* binding */ object),\n/* harmony export */   omit: () => (/* binding */ omit),\n/* harmony export */   optional: () => (/* binding */ optional),\n/* harmony export */   partial: () => (/* binding */ partial),\n/* harmony export */   pattern: () => (/* binding */ pattern),\n/* harmony export */   pick: () => (/* binding */ pick),\n/* harmony export */   record: () => (/* binding */ record),\n/* harmony export */   refine: () => (/* binding */ refine),\n/* harmony export */   regexp: () => (/* binding */ regexp),\n/* harmony export */   set: () => (/* binding */ set),\n/* harmony export */   size: () => (/* binding */ size),\n/* harmony export */   string: () => (/* binding */ string),\n/* harmony export */   struct: () => (/* binding */ struct),\n/* harmony export */   trimmed: () => (/* binding */ trimmed),\n/* harmony export */   tuple: () => (/* binding */ tuple),\n/* harmony export */   type: () => (/* binding */ type),\n/* harmony export */   union: () => (/* binding */ union),\n/* harmony export */   unknown: () => (/* binding */ unknown),\n/* harmony export */   validate: () => (/* binding */ validate)\n/* harmony export */ });\n/**\n * A `StructFailure` represents a single specific failure in validation.\n */ /**\n * `StructError` objects are thrown (or returned) when validation fails.\n *\n * Validation logic is design to exit early for maximum performance. The error\n * represents the first error encountered during validation. For more detail,\n * the `error.failures` property is a generator function that can be run to\n * continue validation and receive all the failures in the data.\n */ class StructError extends TypeError {\n    constructor(failure, failures){\n        let cached;\n        const { message, ...rest } = failure;\n        const { path } = failure;\n        const msg = path.length === 0 ? message : \"At path: \" + path.join(\".\") + \" -- \" + message;\n        super(msg);\n        this.value = void 0;\n        this.key = void 0;\n        this.type = void 0;\n        this.refinement = void 0;\n        this.path = void 0;\n        this.branch = void 0;\n        this.failures = void 0;\n        Object.assign(this, rest);\n        this.name = this.constructor.name;\n        this.failures = ()=>{\n            var _cached;\n            return (_cached = cached) != null ? _cached : cached = [\n                failure,\n                ...failures()\n            ];\n        };\n    }\n}\n/**\n * Check if a value is an iterator.\n */ function isIterable(x) {\n    return isObject(x) && typeof x[Symbol.iterator] === \"function\";\n}\n/**\n * Check if a value is a plain object.\n */ function isObject(x) {\n    return typeof x === \"object\" && x != null;\n}\n/**\n * Check if a value is a plain object.\n */ function isPlainObject(x) {\n    if (Object.prototype.toString.call(x) !== \"[object Object]\") {\n        return false;\n    }\n    const prototype = Object.getPrototypeOf(x);\n    return prototype === null || prototype === Object.prototype;\n}\n/**\n * Return a value as a printable string.\n */ function print(value) {\n    return typeof value === \"string\" ? JSON.stringify(value) : \"\" + value;\n}\n/**\n * Shifts (removes and returns) the first value from the `input` iterator.\n * Like `Array.prototype.shift()` but for an `Iterator`.\n */ function shiftIterator(input) {\n    const { done, value } = input.next();\n    return done ? undefined : value;\n}\n/**\n * Convert a single validation result to a failure.\n */ function toFailure(result, context, struct, value) {\n    if (result === true) {\n        return;\n    } else if (result === false) {\n        result = {};\n    } else if (typeof result === \"string\") {\n        result = {\n            message: result\n        };\n    }\n    const { path, branch } = context;\n    const { type } = struct;\n    const { refinement, message = \"Expected a value of type `\" + type + \"`\" + (refinement ? \" with refinement `\" + refinement + \"`\" : \"\") + \", but received: `\" + print(value) + \"`\" } = result;\n    return {\n        value,\n        type,\n        refinement,\n        key: path[path.length - 1],\n        path,\n        branch,\n        ...result,\n        message\n    };\n}\n/**\n * Convert a validation result to an iterable of failures.\n */ function* toFailures(result, context, struct, value) {\n    if (!isIterable(result)) {\n        result = [\n            result\n        ];\n    }\n    for (const r of result){\n        const failure = toFailure(r, context, struct, value);\n        if (failure) {\n            yield failure;\n        }\n    }\n}\n/**\n * Check a value against a struct, traversing deeply into nested values, and\n * returning an iterator of failures or success.\n */ function* run(value, struct, options) {\n    if (options === void 0) {\n        options = {};\n    }\n    const { path = [], branch = [\n        value\n    ], coerce = false, mask = false } = options;\n    const ctx = {\n        path,\n        branch\n    };\n    if (coerce) {\n        value = struct.coercer(value, ctx);\n        if (mask && struct.type !== \"type\" && isObject(struct.schema) && isObject(value) && !Array.isArray(value)) {\n            for(const key in value){\n                if (struct.schema[key] === undefined) {\n                    delete value[key];\n                }\n            }\n        }\n    }\n    let valid = true;\n    for (const failure of struct.validator(value, ctx)){\n        valid = false;\n        yield [\n            failure,\n            undefined\n        ];\n    }\n    for (let [k, v, s] of struct.entries(value, ctx)){\n        const ts = run(v, s, {\n            path: k === undefined ? path : [\n                ...path,\n                k\n            ],\n            branch: k === undefined ? branch : [\n                ...branch,\n                v\n            ],\n            coerce,\n            mask\n        });\n        for (const t of ts){\n            if (t[0]) {\n                valid = false;\n                yield [\n                    t[0],\n                    undefined\n                ];\n            } else if (coerce) {\n                v = t[1];\n                if (k === undefined) {\n                    value = v;\n                } else if (value instanceof Map) {\n                    value.set(k, v);\n                } else if (value instanceof Set) {\n                    value.add(v);\n                } else if (isObject(value)) {\n                    value[k] = v;\n                }\n            }\n        }\n    }\n    if (valid) {\n        for (const failure of struct.refiner(value, ctx)){\n            valid = false;\n            yield [\n                failure,\n                undefined\n            ];\n        }\n    }\n    if (valid) {\n        yield [\n            undefined,\n            value\n        ];\n    }\n}\n/**\n * `Struct` objects encapsulate the validation logic for a specific type of\n * values. Once constructed, you use the `assert`, `is` or `validate` helpers to\n * validate unknown input data against the struct.\n */ class Struct {\n    constructor(props){\n        this.TYPE = void 0;\n        this.type = void 0;\n        this.schema = void 0;\n        this.coercer = void 0;\n        this.validator = void 0;\n        this.refiner = void 0;\n        this.entries = void 0;\n        const { type, schema, validator, refiner, coercer = (value)=>value, entries = function*() {} } = props;\n        this.type = type;\n        this.schema = schema;\n        this.entries = entries;\n        this.coercer = coercer;\n        if (validator) {\n            this.validator = (value, context)=>{\n                const result = validator(value, context);\n                return toFailures(result, context, this, value);\n            };\n        } else {\n            this.validator = ()=>[];\n        }\n        if (refiner) {\n            this.refiner = (value, context)=>{\n                const result = refiner(value, context);\n                return toFailures(result, context, this, value);\n            };\n        } else {\n            this.refiner = ()=>[];\n        }\n    }\n    /**\n   * Assert that a value passes the struct's validation, throwing if it doesn't.\n   */ assert(value) {\n        return assert(value, this);\n    }\n    /**\n   * Create a value with the struct's coercion logic, then validate it.\n   */ create(value) {\n        return create(value, this);\n    }\n    /**\n   * Check if a value passes the struct's validation.\n   */ is(value) {\n        return is(value, this);\n    }\n    /**\n   * Mask a value, coercing and validating it, but returning only the subset of\n   * properties defined by the struct's schema.\n   */ mask(value) {\n        return mask(value, this);\n    }\n    /**\n   * Validate a value with the struct's validation logic, returning a tuple\n   * representing the result.\n   *\n   * You may optionally pass `true` for the `withCoercion` argument to coerce\n   * the value before attempting to validate it. If you do, the result will\n   * contain the coerced result when successful.\n   */ validate(value, options) {\n        if (options === void 0) {\n            options = {};\n        }\n        return validate(value, this, options);\n    }\n}\n/**\n * Assert that a value passes a struct, throwing if it doesn't.\n */ function assert(value, struct) {\n    const result = validate(value, struct);\n    if (result[0]) {\n        throw result[0];\n    }\n}\n/**\n * Create a value with the coercion logic of struct and validate it.\n */ function create(value, struct) {\n    const result = validate(value, struct, {\n        coerce: true\n    });\n    if (result[0]) {\n        throw result[0];\n    } else {\n        return result[1];\n    }\n}\n/**\n * Mask a value, returning only the subset of properties defined by a struct.\n */ function mask(value, struct) {\n    const result = validate(value, struct, {\n        coerce: true,\n        mask: true\n    });\n    if (result[0]) {\n        throw result[0];\n    } else {\n        return result[1];\n    }\n}\n/**\n * Check if a value passes a struct.\n */ function is(value, struct) {\n    const result = validate(value, struct);\n    return !result[0];\n}\n/**\n * Validate a value against a struct, returning an error if invalid, or the\n * value (with potential coercion) if valid.\n */ function validate(value, struct, options) {\n    if (options === void 0) {\n        options = {};\n    }\n    const tuples = run(value, struct, options);\n    const tuple = shiftIterator(tuples);\n    if (tuple[0]) {\n        const error = new StructError(tuple[0], function*() {\n            for (const t of tuples){\n                if (t[0]) {\n                    yield t[0];\n                }\n            }\n        });\n        return [\n            error,\n            undefined\n        ];\n    } else {\n        const v = tuple[1];\n        return [\n            undefined,\n            v\n        ];\n    }\n}\nfunction assign() {\n    for(var _len = arguments.length, Structs = new Array(_len), _key = 0; _key < _len; _key++){\n        Structs[_key] = arguments[_key];\n    }\n    const isType = Structs[0].type === \"type\";\n    const schemas = Structs.map((s)=>s.schema);\n    const schema = Object.assign({}, ...schemas);\n    return isType ? type(schema) : object(schema);\n}\n/**\n * Define a new struct type with a custom validation function.\n */ function define(name, validator) {\n    return new Struct({\n        type: name,\n        schema: null,\n        validator\n    });\n}\n/**\n * Create a new struct based on an existing struct, but the value is allowed to\n * be `undefined`. `log` will be called if the value is not `undefined`.\n */ function deprecated(struct, log) {\n    return new Struct({\n        ...struct,\n        refiner: (value, ctx)=>value === undefined || struct.refiner(value, ctx),\n        validator (value, ctx) {\n            if (value === undefined) {\n                return true;\n            } else {\n                log(value, ctx);\n                return struct.validator(value, ctx);\n            }\n        }\n    });\n}\n/**\n * Create a struct with dynamic validation logic.\n *\n * The callback will receive the value currently being validated, and must\n * return a struct object to validate it with. This can be useful to model\n * validation logic that changes based on its input.\n */ function dynamic(fn) {\n    return new Struct({\n        type: \"dynamic\",\n        schema: null,\n        *entries (value, ctx) {\n            const struct = fn(value, ctx);\n            yield* struct.entries(value, ctx);\n        },\n        validator (value, ctx) {\n            const struct = fn(value, ctx);\n            return struct.validator(value, ctx);\n        },\n        coercer (value, ctx) {\n            const struct = fn(value, ctx);\n            return struct.coercer(value, ctx);\n        },\n        refiner (value, ctx) {\n            const struct = fn(value, ctx);\n            return struct.refiner(value, ctx);\n        }\n    });\n}\n/**\n * Create a struct with lazily evaluated validation logic.\n *\n * The first time validation is run with the struct, the callback will be called\n * and must return a struct object to use. This is useful for cases where you\n * want to have self-referential structs for nested data structures to avoid a\n * circular definition problem.\n */ function lazy(fn) {\n    let struct;\n    return new Struct({\n        type: \"lazy\",\n        schema: null,\n        *entries (value, ctx) {\n            var _struct;\n            (_struct = struct) != null ? _struct : struct = fn();\n            yield* struct.entries(value, ctx);\n        },\n        validator (value, ctx) {\n            var _struct2;\n            (_struct2 = struct) != null ? _struct2 : struct = fn();\n            return struct.validator(value, ctx);\n        },\n        coercer (value, ctx) {\n            var _struct3;\n            (_struct3 = struct) != null ? _struct3 : struct = fn();\n            return struct.coercer(value, ctx);\n        },\n        refiner (value, ctx) {\n            var _struct4;\n            (_struct4 = struct) != null ? _struct4 : struct = fn();\n            return struct.refiner(value, ctx);\n        }\n    });\n}\n/**\n * Create a new struct based on an existing object struct, but excluding\n * specific properties.\n *\n * Like TypeScript's `Omit` utility.\n */ function omit(struct, keys) {\n    const { schema } = struct;\n    const subschema = {\n        ...schema\n    };\n    for (const key of keys){\n        delete subschema[key];\n    }\n    switch(struct.type){\n        case \"type\":\n            return type(subschema);\n        default:\n            return object(subschema);\n    }\n}\n/**\n * Create a new struct based on an existing object struct, but with all of its\n * properties allowed to be `undefined`.\n *\n * Like TypeScript's `Partial` utility.\n */ function partial(struct) {\n    const schema = struct instanceof Struct ? {\n        ...struct.schema\n    } : {\n        ...struct\n    };\n    for(const key in schema){\n        schema[key] = optional(schema[key]);\n    }\n    return object(schema);\n}\n/**\n * Create a new struct based on an existing object struct, but only including\n * specific properties.\n *\n * Like TypeScript's `Pick` utility.\n */ function pick(struct, keys) {\n    const { schema } = struct;\n    const subschema = {};\n    for (const key of keys){\n        subschema[key] = schema[key];\n    }\n    return object(subschema);\n}\n/**\n * Define a new struct type with a custom validation function.\n *\n * @deprecated This function has been renamed to `define`.\n */ function struct(name, validator) {\n    console.warn(\"superstruct@0.11 - The `struct` helper has been renamed to `define`.\");\n    return define(name, validator);\n}\n/**\n * Ensure that any value passes validation.\n */ function any() {\n    return define(\"any\", ()=>true);\n}\nfunction array(Element) {\n    return new Struct({\n        type: \"array\",\n        schema: Element,\n        *entries (value) {\n            if (Element && Array.isArray(value)) {\n                for (const [i, v] of value.entries()){\n                    yield [\n                        i,\n                        v,\n                        Element\n                    ];\n                }\n            }\n        },\n        coercer (value) {\n            return Array.isArray(value) ? value.slice() : value;\n        },\n        validator (value) {\n            return Array.isArray(value) || \"Expected an array value, but received: \" + print(value);\n        }\n    });\n}\n/**\n * Ensure that a value is a bigint.\n */ function bigint() {\n    return define(\"bigint\", (value)=>{\n        return typeof value === \"bigint\";\n    });\n}\n/**\n * Ensure that a value is a boolean.\n */ function boolean() {\n    return define(\"boolean\", (value)=>{\n        return typeof value === \"boolean\";\n    });\n}\n/**\n * Ensure that a value is a valid `Date`.\n *\n * Note: this also ensures that the value is *not* an invalid `Date` object,\n * which can occur when parsing a date fails but still returns a `Date`.\n */ function date() {\n    return define(\"date\", (value)=>{\n        return value instanceof Date && !isNaN(value.getTime()) || \"Expected a valid `Date` object, but received: \" + print(value);\n    });\n}\nfunction enums(values) {\n    const schema = {};\n    const description = values.map((v)=>print(v)).join();\n    for (const key of values){\n        schema[key] = key;\n    }\n    return new Struct({\n        type: \"enums\",\n        schema,\n        validator (value) {\n            return values.includes(value) || \"Expected one of `\" + description + \"`, but received: \" + print(value);\n        }\n    });\n}\n/**\n * Ensure that a value is a function.\n */ function func() {\n    return define(\"func\", (value)=>{\n        return typeof value === \"function\" || \"Expected a function, but received: \" + print(value);\n    });\n}\n/**\n * Ensure that a value is an instance of a specific class.\n */ function instance(Class) {\n    return define(\"instance\", (value)=>{\n        return value instanceof Class || \"Expected a `\" + Class.name + \"` instance, but received: \" + print(value);\n    });\n}\n/**\n * Ensure that a value is an integer.\n */ function integer() {\n    return define(\"integer\", (value)=>{\n        return typeof value === \"number\" && !isNaN(value) && Number.isInteger(value) || \"Expected an integer, but received: \" + print(value);\n    });\n}\n/**\n * Ensure that a value matches all of a set of types.\n */ function intersection(Structs) {\n    return new Struct({\n        type: \"intersection\",\n        schema: null,\n        *entries (value, ctx) {\n            for (const S of Structs){\n                yield* S.entries(value, ctx);\n            }\n        },\n        *validator (value, ctx) {\n            for (const S of Structs){\n                yield* S.validator(value, ctx);\n            }\n        },\n        *refiner (value, ctx) {\n            for (const S of Structs){\n                yield* S.refiner(value, ctx);\n            }\n        }\n    });\n}\nfunction literal(constant) {\n    const description = print(constant);\n    const t = typeof constant;\n    return new Struct({\n        type: \"literal\",\n        schema: t === \"string\" || t === \"number\" || t === \"boolean\" ? constant : null,\n        validator (value) {\n            return value === constant || \"Expected the literal `\" + description + \"`, but received: \" + print(value);\n        }\n    });\n}\nfunction map(Key, Value) {\n    return new Struct({\n        type: \"map\",\n        schema: null,\n        *entries (value) {\n            if (Key && Value && value instanceof Map) {\n                for (const [k, v] of value.entries()){\n                    yield [\n                        k,\n                        k,\n                        Key\n                    ];\n                    yield [\n                        k,\n                        v,\n                        Value\n                    ];\n                }\n            }\n        },\n        coercer (value) {\n            return value instanceof Map ? new Map(value) : value;\n        },\n        validator (value) {\n            return value instanceof Map || \"Expected a `Map` object, but received: \" + print(value);\n        }\n    });\n}\n/**\n * Ensure that no value ever passes validation.\n */ function never() {\n    return define(\"never\", ()=>false);\n}\n/**\n * Augment an existing struct to allow `null` values.\n */ function nullable(struct) {\n    return new Struct({\n        ...struct,\n        validator: (value, ctx)=>value === null || struct.validator(value, ctx),\n        refiner: (value, ctx)=>value === null || struct.refiner(value, ctx)\n    });\n}\n/**\n * Ensure that a value is a number.\n */ function number() {\n    return define(\"number\", (value)=>{\n        return typeof value === \"number\" && !isNaN(value) || \"Expected a number, but received: \" + print(value);\n    });\n}\nfunction object(schema) {\n    const knowns = schema ? Object.keys(schema) : [];\n    const Never = never();\n    return new Struct({\n        type: \"object\",\n        schema: schema ? schema : null,\n        *entries (value) {\n            if (schema && isObject(value)) {\n                const unknowns = new Set(Object.keys(value));\n                for (const key of knowns){\n                    unknowns.delete(key);\n                    yield [\n                        key,\n                        value[key],\n                        schema[key]\n                    ];\n                }\n                for (const key of unknowns){\n                    yield [\n                        key,\n                        value[key],\n                        Never\n                    ];\n                }\n            }\n        },\n        validator (value) {\n            return isObject(value) || \"Expected an object, but received: \" + print(value);\n        },\n        coercer (value) {\n            return isObject(value) ? {\n                ...value\n            } : value;\n        }\n    });\n}\n/**\n * Augment a struct to allow `undefined` values.\n */ function optional(struct) {\n    return new Struct({\n        ...struct,\n        validator: (value, ctx)=>value === undefined || struct.validator(value, ctx),\n        refiner: (value, ctx)=>value === undefined || struct.refiner(value, ctx)\n    });\n}\n/**\n * Ensure that a value is an object with keys and values of specific types, but\n * without ensuring any specific shape of properties.\n *\n * Like TypeScript's `Record` utility.\n */ function record(Key, Value) {\n    return new Struct({\n        type: \"record\",\n        schema: null,\n        *entries (value) {\n            if (isObject(value)) {\n                for(const k in value){\n                    const v = value[k];\n                    yield [\n                        k,\n                        k,\n                        Key\n                    ];\n                    yield [\n                        k,\n                        v,\n                        Value\n                    ];\n                }\n            }\n        },\n        validator (value) {\n            return isObject(value) || \"Expected an object, but received: \" + print(value);\n        }\n    });\n}\n/**\n * Ensure that a value is a `RegExp`.\n *\n * Note: this does not test the value against the regular expression! For that\n * you need to use the `pattern()` refinement.\n */ function regexp() {\n    return define(\"regexp\", (value)=>{\n        return value instanceof RegExp;\n    });\n}\nfunction set(Element) {\n    return new Struct({\n        type: \"set\",\n        schema: null,\n        *entries (value) {\n            if (Element && value instanceof Set) {\n                for (const v of value){\n                    yield [\n                        v,\n                        v,\n                        Element\n                    ];\n                }\n            }\n        },\n        coercer (value) {\n            return value instanceof Set ? new Set(value) : value;\n        },\n        validator (value) {\n            return value instanceof Set || \"Expected a `Set` object, but received: \" + print(value);\n        }\n    });\n}\n/**\n * Ensure that a value is a string.\n */ function string() {\n    return define(\"string\", (value)=>{\n        return typeof value === \"string\" || \"Expected a string, but received: \" + print(value);\n    });\n}\n/**\n * Ensure that a value is a tuple of a specific length, and that each of its\n * elements is of a specific type.\n */ function tuple(Structs) {\n    const Never = never();\n    return new Struct({\n        type: \"tuple\",\n        schema: null,\n        *entries (value) {\n            if (Array.isArray(value)) {\n                const length = Math.max(Structs.length, value.length);\n                for(let i = 0; i < length; i++){\n                    yield [\n                        i,\n                        value[i],\n                        Structs[i] || Never\n                    ];\n                }\n            }\n        },\n        validator (value) {\n            return Array.isArray(value) || \"Expected an array, but received: \" + print(value);\n        }\n    });\n}\n/**\n * Ensure that a value has a set of known properties of specific types.\n *\n * Note: Unrecognized properties are allowed and untouched. This is similar to\n * how TypeScript's structural typing works.\n */ function type(schema) {\n    const keys = Object.keys(schema);\n    return new Struct({\n        type: \"type\",\n        schema,\n        *entries (value) {\n            if (isObject(value)) {\n                for (const k of keys){\n                    yield [\n                        k,\n                        value[k],\n                        schema[k]\n                    ];\n                }\n            }\n        },\n        validator (value) {\n            return isObject(value) || \"Expected an object, but received: \" + print(value);\n        }\n    });\n}\n/**\n * Ensure that a value matches one of a set of types.\n */ function union(Structs) {\n    const description = Structs.map((s)=>s.type).join(\" | \");\n    return new Struct({\n        type: \"union\",\n        schema: null,\n        coercer (value, ctx) {\n            const firstMatch = Structs.find((s)=>{\n                const [e] = s.validate(value, {\n                    coerce: true\n                });\n                return !e;\n            }) || unknown();\n            return firstMatch.coercer(value, ctx);\n        },\n        validator (value, ctx) {\n            const failures = [];\n            for (const S of Structs){\n                const [...tuples] = run(value, S, ctx);\n                const [first] = tuples;\n                if (!first[0]) {\n                    return [];\n                } else {\n                    for (const [failure] of tuples){\n                        if (failure) {\n                            failures.push(failure);\n                        }\n                    }\n                }\n            }\n            return [\n                \"Expected the value to satisfy a union of `\" + description + \"`, but received: \" + print(value),\n                ...failures\n            ];\n        }\n    });\n}\n/**\n * Ensure that any value passes validation, without widening its type to `any`.\n */ function unknown() {\n    return define(\"unknown\", ()=>true);\n}\n/**\n * Augment a `Struct` to add an additional coercion step to its input.\n *\n * This allows you to transform input data before validating it, to increase the\n * likelihood that it passes validationâ€”for example for default values, parsing\n * different formats, etc.\n *\n * Note: You must use `create(value, Struct)` on the value to have the coercion\n * take effect! Using simply `assert()` or `is()` will not use coercion.\n */ function coerce(struct, condition, coercer) {\n    return new Struct({\n        ...struct,\n        coercer: (value, ctx)=>{\n            return is(value, condition) ? struct.coercer(coercer(value, ctx), ctx) : struct.coercer(value, ctx);\n        }\n    });\n}\n/**\n * Augment a struct to replace `undefined` values with a default.\n *\n * Note: You must use `create(value, Struct)` on the value to have the coercion\n * take effect! Using simply `assert()` or `is()` will not use coercion.\n */ function defaulted(struct, fallback, options) {\n    if (options === void 0) {\n        options = {};\n    }\n    return coerce(struct, unknown(), (x)=>{\n        const f = typeof fallback === \"function\" ? fallback() : fallback;\n        if (x === undefined) {\n            return f;\n        }\n        if (!options.strict && isPlainObject(x) && isPlainObject(f)) {\n            const ret = {\n                ...x\n            };\n            let changed = false;\n            for(const key in f){\n                if (ret[key] === undefined) {\n                    ret[key] = f[key];\n                    changed = true;\n                }\n            }\n            if (changed) {\n                return ret;\n            }\n        }\n        return x;\n    });\n}\n/**\n * Augment a struct to trim string inputs.\n *\n * Note: You must use `create(value, Struct)` on the value to have the coercion\n * take effect! Using simply `assert()` or `is()` will not use coercion.\n */ function trimmed(struct) {\n    return coerce(struct, string(), (x)=>x.trim());\n}\n/**\n * Ensure that a string, array, map, or set is empty.\n */ function empty(struct) {\n    return refine(struct, \"empty\", (value)=>{\n        const size = getSize(value);\n        return size === 0 || \"Expected an empty \" + struct.type + \" but received one with a size of `\" + size + \"`\";\n    });\n}\nfunction getSize(value) {\n    if (value instanceof Map || value instanceof Set) {\n        return value.size;\n    } else {\n        return value.length;\n    }\n}\n/**\n * Ensure that a number or date is below a threshold.\n */ function max(struct, threshold, options) {\n    if (options === void 0) {\n        options = {};\n    }\n    const { exclusive } = options;\n    return refine(struct, \"max\", (value)=>{\n        return exclusive ? value < threshold : value <= threshold || \"Expected a \" + struct.type + \" less than \" + (exclusive ? \"\" : \"or equal to \") + threshold + \" but received `\" + value + \"`\";\n    });\n}\n/**\n * Ensure that a number or date is above a threshold.\n */ function min(struct, threshold, options) {\n    if (options === void 0) {\n        options = {};\n    }\n    const { exclusive } = options;\n    return refine(struct, \"min\", (value)=>{\n        return exclusive ? value > threshold : value >= threshold || \"Expected a \" + struct.type + \" greater than \" + (exclusive ? \"\" : \"or equal to \") + threshold + \" but received `\" + value + \"`\";\n    });\n}\n/**\n * Ensure that a string, array, map or set is not empty.\n */ function nonempty(struct) {\n    return refine(struct, \"nonempty\", (value)=>{\n        const size = getSize(value);\n        return size > 0 || \"Expected a nonempty \" + struct.type + \" but received an empty one\";\n    });\n}\n/**\n * Ensure that a string matches a regular expression.\n */ function pattern(struct, regexp) {\n    return refine(struct, \"pattern\", (value)=>{\n        return regexp.test(value) || \"Expected a \" + struct.type + \" matching `/\" + regexp.source + '/` but received \"' + value + '\"';\n    });\n}\n/**\n * Ensure that a string, array, number, date, map, or set has a size (or length, or time) between `min` and `max`.\n */ function size(struct, min, max) {\n    if (max === void 0) {\n        max = min;\n    }\n    const expected = \"Expected a \" + struct.type;\n    const of = min === max ? \"of `\" + min + \"`\" : \"between `\" + min + \"` and `\" + max + \"`\";\n    return refine(struct, \"size\", (value)=>{\n        if (typeof value === \"number\" || value instanceof Date) {\n            return min <= value && value <= max || expected + \" \" + of + \" but received `\" + value + \"`\";\n        } else if (value instanceof Map || value instanceof Set) {\n            const { size } = value;\n            return min <= size && size <= max || expected + \" with a size \" + of + \" but received one with a size of `\" + size + \"`\";\n        } else {\n            const { length } = value;\n            return min <= length && length <= max || expected + \" with a length \" + of + \" but received one with a length of `\" + length + \"`\";\n        }\n    });\n}\n/**\n * Augment a `Struct` to add an additional refinement to the validation.\n *\n * The refiner function is guaranteed to receive a value of the struct's type,\n * because the struct's existing validation will already have passed. This\n * allows you to layer additional validation on top of existing structs.\n */ function refine(struct, name, refiner) {\n    return new Struct({\n        ...struct,\n        *refiner (value, ctx) {\n            yield* struct.refiner(value, ctx);\n            const result = refiner(value, ctx);\n            const failures = toFailures(result, ctx, struct, value);\n            for (const failure of failures){\n                yield {\n                    ...failure,\n                    refinement: name\n                };\n            }\n        }\n    });\n}\n //# sourceMappingURL=index.es.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vYW5jaG9yL25vZGVfbW9kdWxlcy9zdXBlcnN0cnVjdC9saWIvaW5kZXguZXMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7O0NBRUMsR0FFRDs7Ozs7OztDQU9DLEdBQ0QsTUFBTUEsb0JBQW9CQztJQUN4QkMsWUFBWUMsT0FBTyxFQUFFQyxRQUFRLENBQUU7UUFDN0IsSUFBSUM7UUFDSixNQUFNLEVBQ0pDLE9BQU8sRUFDUCxHQUFHQyxNQUNKLEdBQUdKO1FBQ0osTUFBTSxFQUNKSyxJQUFJLEVBQ0wsR0FBR0w7UUFDSixNQUFNTSxNQUFNRCxLQUFLRSxNQUFNLEtBQUssSUFBSUosVUFBVSxjQUFjRSxLQUFLRyxJQUFJLENBQUMsT0FBTyxTQUFTTDtRQUNsRixLQUFLLENBQUNHO1FBQ04sSUFBSSxDQUFDRyxLQUFLLEdBQUcsS0FBSztRQUNsQixJQUFJLENBQUNDLEdBQUcsR0FBRyxLQUFLO1FBQ2hCLElBQUksQ0FBQ0MsSUFBSSxHQUFHLEtBQUs7UUFDakIsSUFBSSxDQUFDQyxVQUFVLEdBQUcsS0FBSztRQUN2QixJQUFJLENBQUNQLElBQUksR0FBRyxLQUFLO1FBQ2pCLElBQUksQ0FBQ1EsTUFBTSxHQUFHLEtBQUs7UUFDbkIsSUFBSSxDQUFDWixRQUFRLEdBQUcsS0FBSztRQUNyQmEsT0FBT0MsTUFBTSxDQUFDLElBQUksRUFBRVg7UUFDcEIsSUFBSSxDQUFDWSxJQUFJLEdBQUcsSUFBSSxDQUFDakIsV0FBVyxDQUFDaUIsSUFBSTtRQUVqQyxJQUFJLENBQUNmLFFBQVEsR0FBRztZQUNkLElBQUlnQjtZQUVKLE9BQU8sQ0FBQ0EsVUFBVWYsTUFBSyxLQUFNLE9BQU9lLFVBQVVmLFNBQVM7Z0JBQUNGO21CQUFZQzthQUFXO1FBQ2pGO0lBQ0Y7QUFFRjtBQUVBOztDQUVDLEdBQ0QsU0FBU2lCLFdBQVdDLENBQUM7SUFDbkIsT0FBT0MsU0FBU0QsTUFBTSxP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QUFJLE9BQU9BLFVBQVUsWUFBWUEsaUJBQWlCbUcsTUFBTTtZQUN0RCxPQUFPc0QsT0FBT3pKLFNBQVNBLFNBQVNrSSxPQUFPNEIsV0FBVyxNQUFNQyxLQUFLLG9CQUFvQi9KLFFBQVE7UUFDM0YsT0FBTyxJQUFJQSxpQkFBaUJrRCxPQUFPbEQsaUJBQWlCb0QsS0FBSztZQUN2RCxNQUFNLEVBQ0ppRyxJQUFJLEVBQ0wsR0FBR3JKO1lBQ0osT0FBT3lKLE9BQU9KLFFBQVFBLFFBQVFuQixPQUFPNEIsV0FBVyxrQkFBa0JDLEtBQUssdUNBQXVDVixPQUFPO1FBQ3ZILE9BQU87WUFDTCxNQUFNLEVBQ0p2SixNQUFNLEVBQ1AsR0FBR0U7WUFDSixPQUFPeUosT0FBTzNKLFVBQVVBLFVBQVVvSSxPQUFPNEIsV0FBVyxvQkFBb0JDLEtBQUsseUNBQXlDakssU0FBUztRQUNqSTtJQUNGO0FBQ0Y7QUFDQTs7Ozs7O0NBTUMsR0FFRCxTQUFTc0osT0FBT3RILE1BQU0sRUFBRXZCLElBQUksRUFBRStDLE9BQU87SUFDbkMsT0FBTyxJQUFJQyxPQUFPO1FBQUUsR0FBR3pCLE1BQU07UUFFM0IsQ0FBQ3dCLFNBQVF0RCxLQUFLLEVBQUVxQyxHQUFHO1lBQ2pCLE9BQU9QLE9BQU93QixPQUFPLENBQUN0RCxPQUFPcUM7WUFDN0IsTUFBTVQsU0FBUzBCLFFBQVF0RCxPQUFPcUM7WUFDOUIsTUFBTTdDLFdBQVd1QyxXQUFXSCxRQUFRUyxLQUFLUCxRQUFROUI7WUFFakQsS0FBSyxNQUFNVCxXQUFXQyxTQUFVO2dCQUM5QixNQUFNO29CQUFFLEdBQUdELE9BQU87b0JBQ2hCWSxZQUFZSTtnQkFDZDtZQUNGO1FBQ0Y7SUFFRjtBQUNGO0FBRTZaLENBQzdaLG9DQUFvQyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uLi9hbmNob3Ivbm9kZV9tb2R1bGVzL3N1cGVyc3RydWN0L2xpYi9pbmRleC5lcy5qcz9kZGFhIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQSBgU3RydWN0RmFpbHVyZWAgcmVwcmVzZW50cyBhIHNpbmdsZSBzcGVjaWZpYyBmYWlsdXJlIGluIHZhbGlkYXRpb24uXG4gKi9cblxuLyoqXG4gKiBgU3RydWN0RXJyb3JgIG9iamVjdHMgYXJlIHRocm93biAob3IgcmV0dXJuZWQpIHdoZW4gdmFsaWRhdGlvbiBmYWlscy5cbiAqXG4gKiBWYWxpZGF0aW9uIGxvZ2ljIGlzIGRlc2lnbiB0byBleGl0IGVhcmx5IGZvciBtYXhpbXVtIHBlcmZvcm1hbmNlLiBUaGUgZXJyb3JcbiAqIHJlcHJlc2VudHMgdGhlIGZpcnN0IGVycm9yIGVuY291bnRlcmVkIGR1cmluZyB2YWxpZGF0aW9uLiBGb3IgbW9yZSBkZXRhaWwsXG4gKiB0aGUgYGVycm9yLmZhaWx1cmVzYCBwcm9wZXJ0eSBpcyBhIGdlbmVyYXRvciBmdW5jdGlvbiB0aGF0IGNhbiBiZSBydW4gdG9cbiAqIGNvbnRpbnVlIHZhbGlkYXRpb24gYW5kIHJlY2VpdmUgYWxsIHRoZSBmYWlsdXJlcyBpbiB0aGUgZGF0YS5cbiAqL1xuY2xhc3MgU3RydWN0RXJyb3IgZXh0ZW5kcyBUeXBlRXJyb3Ige1xuICBjb25zdHJ1Y3RvcihmYWlsdXJlLCBmYWlsdXJlcykge1xuICAgIGxldCBjYWNoZWQ7XG4gICAgY29uc3Qge1xuICAgICAgbWVzc2FnZSxcbiAgICAgIC4uLnJlc3RcbiAgICB9ID0gZmFpbHVyZTtcbiAgICBjb25zdCB7XG4gICAgICBwYXRoXG4gICAgfSA9IGZhaWx1cmU7XG4gICAgY29uc3QgbXNnID0gcGF0aC5sZW5ndGggPT09IDAgPyBtZXNzYWdlIDogXCJBdCBwYXRoOiBcIiArIHBhdGguam9pbignLicpICsgXCIgLS0gXCIgKyBtZXNzYWdlO1xuICAgIHN1cGVyKG1zZyk7XG4gICAgdGhpcy52YWx1ZSA9IHZvaWQgMDtcbiAgICB0aGlzLmtleSA9IHZvaWQgMDtcbiAgICB0aGlzLnR5cGUgPSB2b2lkIDA7XG4gICAgdGhpcy5yZWZpbmVtZW50ID0gdm9pZCAwO1xuICAgIHRoaXMucGF0aCA9IHZvaWQgMDtcbiAgICB0aGlzLmJyYW5jaCA9IHZvaWQgMDtcbiAgICB0aGlzLmZhaWx1cmVzID0gdm9pZCAwO1xuICAgIE9iamVjdC5hc3NpZ24odGhpcywgcmVzdCk7XG4gICAgdGhpcy5uYW1lID0gdGhpcy5jb25zdHJ1Y3Rvci5uYW1lO1xuXG4gICAgdGhpcy5mYWlsdXJlcyA9ICgpID0+IHtcbiAgICAgIHZhciBfY2FjaGVkO1xuXG4gICAgICByZXR1cm4gKF9jYWNoZWQgPSBjYWNoZWQpICE9IG51bGwgPyBfY2FjaGVkIDogY2FjaGVkID0gW2ZhaWx1cmUsIC4uLmZhaWx1cmVzKCldO1xuICAgIH07XG4gIH1cblxufVxuXG4vKipcbiAqIENoZWNrIGlmIGEgdmFsdWUgaXMgYW4gaXRlcmF0b3IuXG4gKi9cbmZ1bmN0aW9uIGlzSXRlcmFibGUoeCkge1xuICByZXR1cm4gaXNPYmplY3QoeCkgJiYgdHlwZW9mIHhbU3ltYm9sLml0ZXJhdG9yXSA9PT0gJ2Z1bmN0aW9uJztcbn1cbi8qKlxuICogQ2hlY2sgaWYgYSB2YWx1ZSBpcyBhIHBsYWluIG9iamVjdC5cbiAqL1xuXG5cbmZ1bmN0aW9uIGlzT2JqZWN0KHgpIHtcbiAgcmV0dXJuIHR5cGVvZiB4ID09PSAnb2JqZWN0JyAmJiB4ICE9IG51bGw7XG59XG4vKipcbiAqIENoZWNrIGlmIGEgdmFsdWUgaXMgYSBwbGFpbiBvYmplY3QuXG4gKi9cblxuZnVuY3Rpb24gaXNQbGFpbk9iamVjdCh4KSB7XG4gIGlmIChPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoeCkgIT09ICdbb2JqZWN0IE9iamVjdF0nKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgY29uc3QgcHJvdG90eXBlID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKHgpO1xuICByZXR1cm4gcHJvdG90eXBlID09PSBudWxsIHx8IHByb3RvdHlwZSA9PT0gT2JqZWN0LnByb3RvdHlwZTtcbn1cbi8qKlxuICogUmV0dXJuIGEgdmFsdWUgYXMgYSBwcmludGFibGUgc3RyaW5nLlxuICovXG5cbmZ1bmN0aW9uIHByaW50KHZhbHVlKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnID8gSlNPTi5zdHJpbmdpZnkodmFsdWUpIDogXCJcIiArIHZhbHVlO1xufVxuLyoqXG4gKiBTaGlmdHMgKHJlbW92ZXMgYW5kIHJldHVybnMpIHRoZSBmaXJzdCB2YWx1ZSBmcm9tIHRoZSBgaW5wdXRgIGl0ZXJhdG9yLlxuICogTGlrZSBgQXJyYXkucHJvdG90eXBlLnNoaWZ0KClgIGJ1dCBmb3IgYW4gYEl0ZXJhdG9yYC5cbiAqL1xuXG5mdW5jdGlvbiBzaGlmdEl0ZXJhdG9yKGlucHV0KSB7XG4gIGNvbnN0IHtcbiAgICBkb25lLFxuICAgIHZhbHVlXG4gIH0gPSBpbnB1dC5uZXh0KCk7XG4gIHJldHVybiBkb25lID8gdW5kZWZpbmVkIDogdmFsdWU7XG59XG4vKipcbiAqIENvbnZlcnQgYSBzaW5nbGUgdmFsaWRhdGlvbiByZXN1bHQgdG8gYSBmYWlsdXJlLlxuICovXG5cbmZ1bmN0aW9uIHRvRmFpbHVyZShyZXN1bHQsIGNvbnRleHQsIHN0cnVjdCwgdmFsdWUpIHtcbiAgaWYgKHJlc3VsdCA9PT0gdHJ1ZSkge1xuICAgIHJldHVybjtcbiAgfSBlbHNlIGlmIChyZXN1bHQgPT09IGZhbHNlKSB7XG4gICAgcmVzdWx0ID0ge307XG4gIH0gZWxzZSBpZiAodHlwZW9mIHJlc3VsdCA9PT0gJ3N0cmluZycpIHtcbiAgICByZXN1bHQgPSB7XG4gICAgICBtZXNzYWdlOiByZXN1bHRcbiAgICB9O1xuICB9XG5cbiAgY29uc3Qge1xuICAgIHBhdGgsXG4gICAgYnJhbmNoXG4gIH0gPSBjb250ZXh0O1xuICBjb25zdCB7XG4gICAgdHlwZVxuICB9ID0gc3RydWN0O1xuICBjb25zdCB7XG4gICAgcmVmaW5lbWVudCxcbiAgICBtZXNzYWdlID0gXCJFeHBlY3RlZCBhIHZhbHVlIG9mIHR5cGUgYFwiICsgdHlwZSArIFwiYFwiICsgKHJlZmluZW1lbnQgPyBcIiB3aXRoIHJlZmluZW1lbnQgYFwiICsgcmVmaW5lbWVudCArIFwiYFwiIDogJycpICsgXCIsIGJ1dCByZWNlaXZlZDogYFwiICsgcHJpbnQodmFsdWUpICsgXCJgXCJcbiAgfSA9IHJlc3VsdDtcbiAgcmV0dXJuIHtcbiAgICB2YWx1ZSxcbiAgICB0eXBlLFxuICAgIHJlZmluZW1lbnQsXG4gICAga2V5OiBwYXRoW3BhdGgubGVuZ3RoIC0gMV0sXG4gICAgcGF0aCxcbiAgICBicmFuY2gsXG4gICAgLi4ucmVzdWx0LFxuICAgIG1lc3NhZ2VcbiAgfTtcbn1cbi8qKlxuICogQ29udmVydCBhIHZhbGlkYXRpb24gcmVzdWx0IHRvIGFuIGl0ZXJhYmxlIG9mIGZhaWx1cmVzLlxuICovXG5cbmZ1bmN0aW9uKiB0b0ZhaWx1cmVzKHJlc3VsdCwgY29udGV4dCwgc3RydWN0LCB2YWx1ZSkge1xuICBpZiAoIWlzSXRlcmFibGUocmVzdWx0KSkge1xuICAgIHJlc3VsdCA9IFtyZXN1bHRdO1xuICB9XG5cbiAgZm9yIChjb25zdCByIG9mIHJlc3VsdCkge1xuICAgIGNvbnN0IGZhaWx1cmUgPSB0b0ZhaWx1cmUociwgY29udGV4dCwgc3RydWN0LCB2YWx1ZSk7XG5cbiAgICBpZiAoZmFpbHVyZSkge1xuICAgICAgeWllbGQgZmFpbHVyZTtcbiAgICB9XG4gIH1cbn1cbi8qKlxuICogQ2hlY2sgYSB2YWx1ZSBhZ2FpbnN0IGEgc3RydWN0LCB0cmF2ZXJzaW5nIGRlZXBseSBpbnRvIG5lc3RlZCB2YWx1ZXMsIGFuZFxuICogcmV0dXJuaW5nIGFuIGl0ZXJhdG9yIG9mIGZhaWx1cmVzIG9yIHN1Y2Nlc3MuXG4gKi9cblxuZnVuY3Rpb24qIHJ1bih2YWx1ZSwgc3RydWN0LCBvcHRpb25zKSB7XG4gIGlmIChvcHRpb25zID09PSB2b2lkIDApIHtcbiAgICBvcHRpb25zID0ge307XG4gIH1cblxuICBjb25zdCB7XG4gICAgcGF0aCA9IFtdLFxuICAgIGJyYW5jaCA9IFt2YWx1ZV0sXG4gICAgY29lcmNlID0gZmFsc2UsXG4gICAgbWFzayA9IGZhbHNlXG4gIH0gPSBvcHRpb25zO1xuICBjb25zdCBjdHggPSB7XG4gICAgcGF0aCxcbiAgICBicmFuY2hcbiAgfTtcblxuICBpZiAoY29lcmNlKSB7XG4gICAgdmFsdWUgPSBzdHJ1Y3QuY29lcmNlcih2YWx1ZSwgY3R4KTtcblxuICAgIGlmIChtYXNrICYmIHN0cnVjdC50eXBlICE9PSAndHlwZScgJiYgaXNPYmplY3Qoc3RydWN0LnNjaGVtYSkgJiYgaXNPYmplY3QodmFsdWUpICYmICFBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgZm9yIChjb25zdCBrZXkgaW4gdmFsdWUpIHtcbiAgICAgICAgaWYgKHN0cnVjdC5zY2hlbWFba2V5XSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgZGVsZXRlIHZhbHVlW2tleV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBsZXQgdmFsaWQgPSB0cnVlO1xuXG4gIGZvciAoY29uc3QgZmFpbHVyZSBvZiBzdHJ1Y3QudmFsaWRhdG9yKHZhbHVlLCBjdHgpKSB7XG4gICAgdmFsaWQgPSBmYWxzZTtcbiAgICB5aWVsZCBbZmFpbHVyZSwgdW5kZWZpbmVkXTtcbiAgfVxuXG4gIGZvciAobGV0IFtrLCB2LCBzXSBvZiBzdHJ1Y3QuZW50cmllcyh2YWx1ZSwgY3R4KSkge1xuICAgIGNvbnN0IHRzID0gcnVuKHYsIHMsIHtcbiAgICAgIHBhdGg6IGsgPT09IHVuZGVmaW5lZCA/IHBhdGggOiBbLi4ucGF0aCwga10sXG4gICAgICBicmFuY2g6IGsgPT09IHVuZGVmaW5lZCA/IGJyYW5jaCA6IFsuLi5icmFuY2gsIHZdLFxuICAgICAgY29lcmNlLFxuICAgICAgbWFza1xuICAgIH0pO1xuXG4gICAgZm9yIChjb25zdCB0IG9mIHRzKSB7XG4gICAgICBpZiAodFswXSkge1xuICAgICAgICB2YWxpZCA9IGZhbHNlO1xuICAgICAgICB5aWVsZCBbdFswXSwgdW5kZWZpbmVkXTtcbiAgICAgIH0gZWxzZSBpZiAoY29lcmNlKSB7XG4gICAgICAgIHYgPSB0WzFdO1xuXG4gICAgICAgIGlmIChrID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICB2YWx1ZSA9IHY7XG4gICAgICAgIH0gZWxzZSBpZiAodmFsdWUgaW5zdGFuY2VvZiBNYXApIHtcbiAgICAgICAgICB2YWx1ZS5zZXQoaywgdik7XG4gICAgICAgIH0gZWxzZSBpZiAodmFsdWUgaW5zdGFuY2VvZiBTZXQpIHtcbiAgICAgICAgICB2YWx1ZS5hZGQodik7XG4gICAgICAgIH0gZWxzZSBpZiAoaXNPYmplY3QodmFsdWUpKSB7XG4gICAgICAgICAgdmFsdWVba10gPSB2O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgaWYgKHZhbGlkKSB7XG4gICAgZm9yIChjb25zdCBmYWlsdXJlIG9mIHN0cnVjdC5yZWZpbmVyKHZhbHVlLCBjdHgpKSB7XG4gICAgICB2YWxpZCA9IGZhbHNlO1xuICAgICAgeWllbGQgW2ZhaWx1cmUsIHVuZGVmaW5lZF07XG4gICAgfVxuICB9XG5cbiAgaWYgKHZhbGlkKSB7XG4gICAgeWllbGQgW3VuZGVmaW5lZCwgdmFsdWVdO1xuICB9XG59XG5cbi8qKlxuICogYFN0cnVjdGAgb2JqZWN0cyBlbmNhcHN1bGF0ZSB0aGUgdmFsaWRhdGlvbiBsb2dpYyBmb3IgYSBzcGVjaWZpYyB0eXBlIG9mXG4gKiB2YWx1ZXMuIE9uY2UgY29uc3RydWN0ZWQsIHlvdSB1c2UgdGhlIGBhc3NlcnRgLCBgaXNgIG9yIGB2YWxpZGF0ZWAgaGVscGVycyB0b1xuICogdmFsaWRhdGUgdW5rbm93biBpbnB1dCBkYXRhIGFnYWluc3QgdGhlIHN0cnVjdC5cbiAqL1xuXG5jbGFzcyBTdHJ1Y3Qge1xuICBjb25zdHJ1Y3Rvcihwcm9wcykge1xuICAgIHRoaXMuVFlQRSA9IHZvaWQgMDtcbiAgICB0aGlzLnR5cGUgPSB2b2lkIDA7XG4gICAgdGhpcy5zY2hlbWEgPSB2b2lkIDA7XG4gICAgdGhpcy5jb2VyY2VyID0gdm9pZCAwO1xuICAgIHRoaXMudmFsaWRhdG9yID0gdm9pZCAwO1xuICAgIHRoaXMucmVmaW5lciA9IHZvaWQgMDtcbiAgICB0aGlzLmVudHJpZXMgPSB2b2lkIDA7XG4gICAgY29uc3Qge1xuICAgICAgdHlwZSxcbiAgICAgIHNjaGVtYSxcbiAgICAgIHZhbGlkYXRvcixcbiAgICAgIHJlZmluZXIsXG4gICAgICBjb2VyY2VyID0gdmFsdWUgPT4gdmFsdWUsXG4gICAgICBlbnRyaWVzID0gZnVuY3Rpb24qICgpIHt9XG4gICAgfSA9IHByb3BzO1xuICAgIHRoaXMudHlwZSA9IHR5cGU7XG4gICAgdGhpcy5zY2hlbWEgPSBzY2hlbWE7XG4gICAgdGhpcy5lbnRyaWVzID0gZW50cmllcztcbiAgICB0aGlzLmNvZXJjZXIgPSBjb2VyY2VyO1xuXG4gICAgaWYgKHZhbGlkYXRvcikge1xuICAgICAgdGhpcy52YWxpZGF0b3IgPSAodmFsdWUsIGNvbnRleHQpID0+IHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gdmFsaWRhdG9yKHZhbHVlLCBjb250ZXh0KTtcbiAgICAgICAgcmV0dXJuIHRvRmFpbHVyZXMocmVzdWx0LCBjb250ZXh0LCB0aGlzLCB2YWx1ZSk7XG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnZhbGlkYXRvciA9ICgpID0+IFtdO1xuICAgIH1cblxuICAgIGlmIChyZWZpbmVyKSB7XG4gICAgICB0aGlzLnJlZmluZXIgPSAodmFsdWUsIGNvbnRleHQpID0+IHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gcmVmaW5lcih2YWx1ZSwgY29udGV4dCk7XG4gICAgICAgIHJldHVybiB0b0ZhaWx1cmVzKHJlc3VsdCwgY29udGV4dCwgdGhpcywgdmFsdWUpO1xuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5yZWZpbmVyID0gKCkgPT4gW107XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBBc3NlcnQgdGhhdCBhIHZhbHVlIHBhc3NlcyB0aGUgc3RydWN0J3MgdmFsaWRhdGlvbiwgdGhyb3dpbmcgaWYgaXQgZG9lc24ndC5cbiAgICovXG5cblxuICBhc3NlcnQodmFsdWUpIHtcbiAgICByZXR1cm4gYXNzZXJ0KHZhbHVlLCB0aGlzKTtcbiAgfVxuICAvKipcbiAgICogQ3JlYXRlIGEgdmFsdWUgd2l0aCB0aGUgc3RydWN0J3MgY29lcmNpb24gbG9naWMsIHRoZW4gdmFsaWRhdGUgaXQuXG4gICAqL1xuXG5cbiAgY3JlYXRlKHZhbHVlKSB7XG4gICAgcmV0dXJuIGNyZWF0ZSh2YWx1ZSwgdGhpcyk7XG4gIH1cbiAgLyoqXG4gICAqIENoZWNrIGlmIGEgdmFsdWUgcGFzc2VzIHRoZSBzdHJ1Y3QncyB2YWxpZGF0aW9uLlxuICAgKi9cblxuXG4gIGlzKHZhbHVlKSB7XG4gICAgcmV0dXJuIGlzKHZhbHVlLCB0aGlzKTtcbiAgfVxuICAvKipcbiAgICogTWFzayBhIHZhbHVlLCBjb2VyY2luZyBhbmQgdmFsaWRhdGluZyBpdCwgYnV0IHJldHVybmluZyBvbmx5IHRoZSBzdWJzZXQgb2ZcbiAgICogcHJvcGVydGllcyBkZWZpbmVkIGJ5IHRoZSBzdHJ1Y3QncyBzY2hlbWEuXG4gICAqL1xuXG5cbiAgbWFzayh2YWx1ZSkge1xuICAgIHJldHVybiBtYXNrKHZhbHVlLCB0aGlzKTtcbiAgfVxuICAvKipcbiAgICogVmFsaWRhdGUgYSB2YWx1ZSB3aXRoIHRoZSBzdHJ1Y3QncyB2YWxpZGF0aW9uIGxvZ2ljLCByZXR1cm5pbmcgYSB0dXBsZVxuICAgKiByZXByZXNlbnRpbmcgdGhlIHJlc3VsdC5cbiAgICpcbiAgICogWW91IG1heSBvcHRpb25hbGx5IHBhc3MgYHRydWVgIGZvciB0aGUgYHdpdGhDb2VyY2lvbmAgYXJndW1lbnQgdG8gY29lcmNlXG4gICAqIHRoZSB2YWx1ZSBiZWZvcmUgYXR0ZW1wdGluZyB0byB2YWxpZGF0ZSBpdC4gSWYgeW91IGRvLCB0aGUgcmVzdWx0IHdpbGxcbiAgICogY29udGFpbiB0aGUgY29lcmNlZCByZXN1bHQgd2hlbiBzdWNjZXNzZnVsLlxuICAgKi9cblxuXG4gIHZhbGlkYXRlKHZhbHVlLCBvcHRpb25zKSB7XG4gICAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkge1xuICAgICAgb3B0aW9ucyA9IHt9O1xuICAgIH1cblxuICAgIHJldHVybiB2YWxpZGF0ZSh2YWx1ZSwgdGhpcywgb3B0aW9ucyk7XG4gIH1cblxufVxuLyoqXG4gKiBBc3NlcnQgdGhhdCBhIHZhbHVlIHBhc3NlcyBhIHN0cnVjdCwgdGhyb3dpbmcgaWYgaXQgZG9lc24ndC5cbiAqL1xuXG5mdW5jdGlvbiBhc3NlcnQodmFsdWUsIHN0cnVjdCkge1xuICBjb25zdCByZXN1bHQgPSB2YWxpZGF0ZSh2YWx1ZSwgc3RydWN0KTtcblxuICBpZiAocmVzdWx0WzBdKSB7XG4gICAgdGhyb3cgcmVzdWx0WzBdO1xuICB9XG59XG4vKipcbiAqIENyZWF0ZSBhIHZhbHVlIHdpdGggdGhlIGNvZXJjaW9uIGxvZ2ljIG9mIHN0cnVjdCBhbmQgdmFsaWRhdGUgaXQuXG4gKi9cblxuZnVuY3Rpb24gY3JlYXRlKHZhbHVlLCBzdHJ1Y3QpIHtcbiAgY29uc3QgcmVzdWx0ID0gdmFsaWRhdGUodmFsdWUsIHN0cnVjdCwge1xuICAgIGNvZXJjZTogdHJ1ZVxuICB9KTtcblxuICBpZiAocmVzdWx0WzBdKSB7XG4gICAgdGhyb3cgcmVzdWx0WzBdO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiByZXN1bHRbMV07XG4gIH1cbn1cbi8qKlxuICogTWFzayBhIHZhbHVlLCByZXR1cm5pbmcgb25seSB0aGUgc3Vic2V0IG9mIHByb3BlcnRpZXMgZGVmaW5lZCBieSBhIHN0cnVjdC5cbiAqL1xuXG5mdW5jdGlvbiBtYXNrKHZhbHVlLCBzdHJ1Y3QpIHtcbiAgY29uc3QgcmVzdWx0ID0gdmFsaWRhdGUodmFsdWUsIHN0cnVjdCwge1xuICAgIGNvZXJjZTogdHJ1ZSxcbiAgICBtYXNrOiB0cnVlXG4gIH0pO1xuXG4gIGlmIChyZXN1bHRbMF0pIHtcbiAgICB0aHJvdyByZXN1bHRbMF07XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHJlc3VsdFsxXTtcbiAgfVxufVxuLyoqXG4gKiBDaGVjayBpZiBhIHZhbHVlIHBhc3NlcyBhIHN0cnVjdC5cbiAqL1xuXG5mdW5jdGlvbiBpcyh2YWx1ZSwgc3RydWN0KSB7XG4gIGNvbnN0IHJlc3VsdCA9IHZhbGlkYXRlKHZhbHVlLCBzdHJ1Y3QpO1xuICByZXR1cm4gIXJlc3VsdFswXTtcbn1cbi8qKlxuICogVmFsaWRhdGUgYSB2YWx1ZSBhZ2FpbnN0IGEgc3RydWN0LCByZXR1cm5pbmcgYW4gZXJyb3IgaWYgaW52YWxpZCwgb3IgdGhlXG4gKiB2YWx1ZSAod2l0aCBwb3RlbnRpYWwgY29lcmNpb24pIGlmIHZhbGlkLlxuICovXG5cbmZ1bmN0aW9uIHZhbGlkYXRlKHZhbHVlLCBzdHJ1Y3QsIG9wdGlvbnMpIHtcbiAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkge1xuICAgIG9wdGlvbnMgPSB7fTtcbiAgfVxuXG4gIGNvbnN0IHR1cGxlcyA9IHJ1bih2YWx1ZSwgc3RydWN0LCBvcHRpb25zKTtcbiAgY29uc3QgdHVwbGUgPSBzaGlmdEl0ZXJhdG9yKHR1cGxlcyk7XG5cbiAgaWYgKHR1cGxlWzBdKSB7XG4gICAgY29uc3QgZXJyb3IgPSBuZXcgU3RydWN0RXJyb3IodHVwbGVbMF0sIGZ1bmN0aW9uKiAoKSB7XG4gICAgICBmb3IgKGNvbnN0IHQgb2YgdHVwbGVzKSB7XG4gICAgICAgIGlmICh0WzBdKSB7XG4gICAgICAgICAgeWllbGQgdFswXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBbZXJyb3IsIHVuZGVmaW5lZF07XG4gIH0gZWxzZSB7XG4gICAgY29uc3QgdiA9IHR1cGxlWzFdO1xuICAgIHJldHVybiBbdW5kZWZpbmVkLCB2XTtcbiAgfVxufVxuXG5mdW5jdGlvbiBhc3NpZ24oKSB7XG4gIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBTdHJ1Y3RzID0gbmV3IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgIFN0cnVjdHNbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gIH1cblxuICBjb25zdCBpc1R5cGUgPSBTdHJ1Y3RzWzBdLnR5cGUgPT09ICd0eXBlJztcbiAgY29uc3Qgc2NoZW1hcyA9IFN0cnVjdHMubWFwKHMgPT4gcy5zY2hlbWEpO1xuICBjb25zdCBzY2hlbWEgPSBPYmplY3QuYXNzaWduKHt9LCAuLi5zY2hlbWFzKTtcbiAgcmV0dXJuIGlzVHlwZSA/IHR5cGUoc2NoZW1hKSA6IG9iamVjdChzY2hlbWEpO1xufVxuLyoqXG4gKiBEZWZpbmUgYSBuZXcgc3RydWN0IHR5cGUgd2l0aCBhIGN1c3RvbSB2YWxpZGF0aW9uIGZ1bmN0aW9uLlxuICovXG5cbmZ1bmN0aW9uIGRlZmluZShuYW1lLCB2YWxpZGF0b3IpIHtcbiAgcmV0dXJuIG5ldyBTdHJ1Y3Qoe1xuICAgIHR5cGU6IG5hbWUsXG4gICAgc2NoZW1hOiBudWxsLFxuICAgIHZhbGlkYXRvclxuICB9KTtcbn1cbi8qKlxuICogQ3JlYXRlIGEgbmV3IHN0cnVjdCBiYXNlZCBvbiBhbiBleGlzdGluZyBzdHJ1Y3QsIGJ1dCB0aGUgdmFsdWUgaXMgYWxsb3dlZCB0b1xuICogYmUgYHVuZGVmaW5lZGAuIGBsb2dgIHdpbGwgYmUgY2FsbGVkIGlmIHRoZSB2YWx1ZSBpcyBub3QgYHVuZGVmaW5lZGAuXG4gKi9cblxuZnVuY3Rpb24gZGVwcmVjYXRlZChzdHJ1Y3QsIGxvZykge1xuICByZXR1cm4gbmV3IFN0cnVjdCh7IC4uLnN0cnVjdCxcbiAgICByZWZpbmVyOiAodmFsdWUsIGN0eCkgPT4gdmFsdWUgPT09IHVuZGVmaW5lZCB8fCBzdHJ1Y3QucmVmaW5lcih2YWx1ZSwgY3R4KSxcblxuICAgIHZhbGlkYXRvcih2YWx1ZSwgY3R4KSB7XG4gICAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxvZyh2YWx1ZSwgY3R4KTtcbiAgICAgICAgcmV0dXJuIHN0cnVjdC52YWxpZGF0b3IodmFsdWUsIGN0eCk7XG4gICAgICB9XG4gICAgfVxuXG4gIH0pO1xufVxuLyoqXG4gKiBDcmVhdGUgYSBzdHJ1Y3Qgd2l0aCBkeW5hbWljIHZhbGlkYXRpb24gbG9naWMuXG4gKlxuICogVGhlIGNhbGxiYWNrIHdpbGwgcmVjZWl2ZSB0aGUgdmFsdWUgY3VycmVudGx5IGJlaW5nIHZhbGlkYXRlZCwgYW5kIG11c3RcbiAqIHJldHVybiBhIHN0cnVjdCBvYmplY3QgdG8gdmFsaWRhdGUgaXQgd2l0aC4gVGhpcyBjYW4gYmUgdXNlZnVsIHRvIG1vZGVsXG4gKiB2YWxpZGF0aW9uIGxvZ2ljIHRoYXQgY2hhbmdlcyBiYXNlZCBvbiBpdHMgaW5wdXQuXG4gKi9cblxuZnVuY3Rpb24gZHluYW1pYyhmbikge1xuICByZXR1cm4gbmV3IFN0cnVjdCh7XG4gICAgdHlwZTogJ2R5bmFtaWMnLFxuICAgIHNjaGVtYTogbnVsbCxcblxuICAgICplbnRyaWVzKHZhbHVlLCBjdHgpIHtcbiAgICAgIGNvbnN0IHN0cnVjdCA9IGZuKHZhbHVlLCBjdHgpO1xuICAgICAgeWllbGQqIHN0cnVjdC5lbnRyaWVzKHZhbHVlLCBjdHgpO1xuICAgIH0sXG5cbiAgICB2YWxpZGF0b3IodmFsdWUsIGN0eCkge1xuICAgICAgY29uc3Qgc3RydWN0ID0gZm4odmFsdWUsIGN0eCk7XG4gICAgICByZXR1cm4gc3RydWN0LnZhbGlkYXRvcih2YWx1ZSwgY3R4KTtcbiAgICB9LFxuXG4gICAgY29lcmNlcih2YWx1ZSwgY3R4KSB7XG4gICAgICBjb25zdCBzdHJ1Y3QgPSBmbih2YWx1ZSwgY3R4KTtcbiAgICAgIHJldHVybiBzdHJ1Y3QuY29lcmNlcih2YWx1ZSwgY3R4KTtcbiAgICB9LFxuXG4gICAgcmVmaW5lcih2YWx1ZSwgY3R4KSB7XG4gICAgICBjb25zdCBzdHJ1Y3QgPSBmbih2YWx1ZSwgY3R4KTtcbiAgICAgIHJldHVybiBzdHJ1Y3QucmVmaW5lcih2YWx1ZSwgY3R4KTtcbiAgICB9XG5cbiAgfSk7XG59XG4vKipcbiAqIENyZWF0ZSBhIHN0cnVjdCB3aXRoIGxhemlseSBldmFsdWF0ZWQgdmFsaWRhdGlvbiBsb2dpYy5cbiAqXG4gKiBUaGUgZmlyc3QgdGltZSB2YWxpZGF0aW9uIGlzIHJ1biB3aXRoIHRoZSBzdHJ1Y3QsIHRoZSBjYWxsYmFjayB3aWxsIGJlIGNhbGxlZFxuICogYW5kIG11c3QgcmV0dXJuIGEgc3RydWN0IG9iamVjdCB0byB1c2UuIFRoaXMgaXMgdXNlZnVsIGZvciBjYXNlcyB3aGVyZSB5b3VcbiAqIHdhbnQgdG8gaGF2ZSBzZWxmLXJlZmVyZW50aWFsIHN0cnVjdHMgZm9yIG5lc3RlZCBkYXRhIHN0cnVjdHVyZXMgdG8gYXZvaWQgYVxuICogY2lyY3VsYXIgZGVmaW5pdGlvbiBwcm9ibGVtLlxuICovXG5cbmZ1bmN0aW9uIGxhenkoZm4pIHtcbiAgbGV0IHN0cnVjdDtcbiAgcmV0dXJuIG5ldyBTdHJ1Y3Qoe1xuICAgIHR5cGU6ICdsYXp5JyxcbiAgICBzY2hlbWE6IG51bGwsXG5cbiAgICAqZW50cmllcyh2YWx1ZSwgY3R4KSB7XG4gICAgICB2YXIgX3N0cnVjdDtcblxuICAgICAgKF9zdHJ1Y3QgPSBzdHJ1Y3QpICE9IG51bGwgPyBfc3RydWN0IDogc3RydWN0ID0gZm4oKTtcbiAgICAgIHlpZWxkKiBzdHJ1Y3QuZW50cmllcyh2YWx1ZSwgY3R4KTtcbiAgICB9LFxuXG4gICAgdmFsaWRhdG9yKHZhbHVlLCBjdHgpIHtcbiAgICAgIHZhciBfc3RydWN0MjtcblxuICAgICAgKF9zdHJ1Y3QyID0gc3RydWN0KSAhPSBudWxsID8gX3N0cnVjdDIgOiBzdHJ1Y3QgPSBmbigpO1xuICAgICAgcmV0dXJuIHN0cnVjdC52YWxpZGF0b3IodmFsdWUsIGN0eCk7XG4gICAgfSxcblxuICAgIGNvZXJjZXIodmFsdWUsIGN0eCkge1xuICAgICAgdmFyIF9zdHJ1Y3QzO1xuXG4gICAgICAoX3N0cnVjdDMgPSBzdHJ1Y3QpICE9IG51bGwgPyBfc3RydWN0MyA6IHN0cnVjdCA9IGZuKCk7XG4gICAgICByZXR1cm4gc3RydWN0LmNvZXJjZXIodmFsdWUsIGN0eCk7XG4gICAgfSxcblxuICAgIHJlZmluZXIodmFsdWUsIGN0eCkge1xuICAgICAgdmFyIF9zdHJ1Y3Q0O1xuXG4gICAgICAoX3N0cnVjdDQgPSBzdHJ1Y3QpICE9IG51bGwgPyBfc3RydWN0NCA6IHN0cnVjdCA9IGZuKCk7XG4gICAgICByZXR1cm4gc3RydWN0LnJlZmluZXIodmFsdWUsIGN0eCk7XG4gICAgfVxuXG4gIH0pO1xufVxuLyoqXG4gKiBDcmVhdGUgYSBuZXcgc3RydWN0IGJhc2VkIG9uIGFuIGV4aXN0aW5nIG9iamVjdCBzdHJ1Y3QsIGJ1dCBleGNsdWRpbmdcbiAqIHNwZWNpZmljIHByb3BlcnRpZXMuXG4gKlxuICogTGlrZSBUeXBlU2NyaXB0J3MgYE9taXRgIHV0aWxpdHkuXG4gKi9cblxuZnVuY3Rpb24gb21pdChzdHJ1Y3QsIGtleXMpIHtcbiAgY29uc3Qge1xuICAgIHNjaGVtYVxuICB9ID0gc3RydWN0O1xuICBjb25zdCBzdWJzY2hlbWEgPSB7IC4uLnNjaGVtYVxuICB9O1xuXG4gIGZvciAoY29uc3Qga2V5IG9mIGtleXMpIHtcbiAgICBkZWxldGUgc3Vic2NoZW1hW2tleV07XG4gIH1cblxuICBzd2l0Y2ggKHN0cnVjdC50eXBlKSB7XG4gICAgY2FzZSAndHlwZSc6XG4gICAgICByZXR1cm4gdHlwZShzdWJzY2hlbWEpO1xuXG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBvYmplY3Qoc3Vic2NoZW1hKTtcbiAgfVxufVxuLyoqXG4gKiBDcmVhdGUgYSBuZXcgc3RydWN0IGJhc2VkIG9uIGFuIGV4aXN0aW5nIG9iamVjdCBzdHJ1Y3QsIGJ1dCB3aXRoIGFsbCBvZiBpdHNcbiAqIHByb3BlcnRpZXMgYWxsb3dlZCB0byBiZSBgdW5kZWZpbmVkYC5cbiAqXG4gKiBMaWtlIFR5cGVTY3JpcHQncyBgUGFydGlhbGAgdXRpbGl0eS5cbiAqL1xuXG5mdW5jdGlvbiBwYXJ0aWFsKHN0cnVjdCkge1xuICBjb25zdCBzY2hlbWEgPSBzdHJ1Y3QgaW5zdGFuY2VvZiBTdHJ1Y3QgPyB7IC4uLnN0cnVjdC5zY2hlbWFcbiAgfSA6IHsgLi4uc3RydWN0XG4gIH07XG5cbiAgZm9yIChjb25zdCBrZXkgaW4gc2NoZW1hKSB7XG4gICAgc2NoZW1hW2tleV0gPSBvcHRpb25hbChzY2hlbWFba2V5XSk7XG4gIH1cblxuICByZXR1cm4gb2JqZWN0KHNjaGVtYSk7XG59XG4vKipcbiAqIENyZWF0ZSBhIG5ldyBzdHJ1Y3QgYmFzZWQgb24gYW4gZXhpc3Rpbmcgb2JqZWN0IHN0cnVjdCwgYnV0IG9ubHkgaW5jbHVkaW5nXG4gKiBzcGVjaWZpYyBwcm9wZXJ0aWVzLlxuICpcbiAqIExpa2UgVHlwZVNjcmlwdCdzIGBQaWNrYCB1dGlsaXR5LlxuICovXG5cbmZ1bmN0aW9uIHBpY2soc3RydWN0LCBrZXlzKSB7XG4gIGNvbnN0IHtcbiAgICBzY2hlbWFcbiAgfSA9IHN0cnVjdDtcbiAgY29uc3Qgc3Vic2NoZW1hID0ge307XG5cbiAgZm9yIChjb25zdCBrZXkgb2Yga2V5cykge1xuICAgIHN1YnNjaGVtYVtrZXldID0gc2NoZW1hW2tleV07XG4gIH1cblxuICByZXR1cm4gb2JqZWN0KHN1YnNjaGVtYSk7XG59XG4vKipcbiAqIERlZmluZSBhIG5ldyBzdHJ1Y3QgdHlwZSB3aXRoIGEgY3VzdG9tIHZhbGlkYXRpb24gZnVuY3Rpb24uXG4gKlxuICogQGRlcHJlY2F0ZWQgVGhpcyBmdW5jdGlvbiBoYXMgYmVlbiByZW5hbWVkIHRvIGBkZWZpbmVgLlxuICovXG5cbmZ1bmN0aW9uIHN0cnVjdChuYW1lLCB2YWxpZGF0b3IpIHtcbiAgY29uc29sZS53YXJuKCdzdXBlcnN0cnVjdEAwLjExIC0gVGhlIGBzdHJ1Y3RgIGhlbHBlciBoYXMgYmVlbiByZW5hbWVkIHRvIGBkZWZpbmVgLicpO1xuICByZXR1cm4gZGVmaW5lKG5hbWUsIHZhbGlkYXRvcik7XG59XG5cbi8qKlxuICogRW5zdXJlIHRoYXQgYW55IHZhbHVlIHBhc3NlcyB2YWxpZGF0aW9uLlxuICovXG5cbmZ1bmN0aW9uIGFueSgpIHtcbiAgcmV0dXJuIGRlZmluZSgnYW55JywgKCkgPT4gdHJ1ZSk7XG59XG5mdW5jdGlvbiBhcnJheShFbGVtZW50KSB7XG4gIHJldHVybiBuZXcgU3RydWN0KHtcbiAgICB0eXBlOiAnYXJyYXknLFxuICAgIHNjaGVtYTogRWxlbWVudCxcblxuICAgICplbnRyaWVzKHZhbHVlKSB7XG4gICAgICBpZiAoRWxlbWVudCAmJiBBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICBmb3IgKGNvbnN0IFtpLCB2XSBvZiB2YWx1ZS5lbnRyaWVzKCkpIHtcbiAgICAgICAgICB5aWVsZCBbaSwgdiwgRWxlbWVudF07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuXG4gICAgY29lcmNlcih2YWx1ZSkge1xuICAgICAgcmV0dXJuIEFycmF5LmlzQXJyYXkodmFsdWUpID8gdmFsdWUuc2xpY2UoKSA6IHZhbHVlO1xuICAgIH0sXG5cbiAgICB2YWxpZGF0b3IodmFsdWUpIHtcbiAgICAgIHJldHVybiBBcnJheS5pc0FycmF5KHZhbHVlKSB8fCBcIkV4cGVjdGVkIGFuIGFycmF5IHZhbHVlLCBidXQgcmVjZWl2ZWQ6IFwiICsgcHJpbnQodmFsdWUpO1xuICAgIH1cblxuICB9KTtcbn1cbi8qKlxuICogRW5zdXJlIHRoYXQgYSB2YWx1ZSBpcyBhIGJpZ2ludC5cbiAqL1xuXG5mdW5jdGlvbiBiaWdpbnQoKSB7XG4gIHJldHVybiBkZWZpbmUoJ2JpZ2ludCcsIHZhbHVlID0+IHtcbiAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAnYmlnaW50JztcbiAgfSk7XG59XG4vKipcbiAqIEVuc3VyZSB0aGF0IGEgdmFsdWUgaXMgYSBib29sZWFuLlxuICovXG5cbmZ1bmN0aW9uIGJvb2xlYW4oKSB7XG4gIHJldHVybiBkZWZpbmUoJ2Jvb2xlYW4nLCB2YWx1ZSA9PiB7XG4gICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ2Jvb2xlYW4nO1xuICB9KTtcbn1cbi8qKlxuICogRW5zdXJlIHRoYXQgYSB2YWx1ZSBpcyBhIHZhbGlkIGBEYXRlYC5cbiAqXG4gKiBOb3RlOiB0aGlzIGFsc28gZW5zdXJlcyB0aGF0IHRoZSB2YWx1ZSBpcyAqbm90KiBhbiBpbnZhbGlkIGBEYXRlYCBvYmplY3QsXG4gKiB3aGljaCBjYW4gb2NjdXIgd2hlbiBwYXJzaW5nIGEgZGF0ZSBmYWlscyBidXQgc3RpbGwgcmV0dXJucyBhIGBEYXRlYC5cbiAqL1xuXG5mdW5jdGlvbiBkYXRlKCkge1xuICByZXR1cm4gZGVmaW5lKCdkYXRlJywgdmFsdWUgPT4ge1xuICAgIHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIERhdGUgJiYgIWlzTmFOKHZhbHVlLmdldFRpbWUoKSkgfHwgXCJFeHBlY3RlZCBhIHZhbGlkIGBEYXRlYCBvYmplY3QsIGJ1dCByZWNlaXZlZDogXCIgKyBwcmludCh2YWx1ZSk7XG4gIH0pO1xufVxuZnVuY3Rpb24gZW51bXModmFsdWVzKSB7XG4gIGNvbnN0IHNjaGVtYSA9IHt9O1xuICBjb25zdCBkZXNjcmlwdGlvbiA9IHZhbHVlcy5tYXAodiA9PiBwcmludCh2KSkuam9pbigpO1xuXG4gIGZvciAoY29uc3Qga2V5IG9mIHZhbHVlcykge1xuICAgIHNjaGVtYVtrZXldID0ga2V5O1xuICB9XG5cbiAgcmV0dXJuIG5ldyBTdHJ1Y3Qoe1xuICAgIHR5cGU6ICdlbnVtcycsXG4gICAgc2NoZW1hLFxuXG4gICAgdmFsaWRhdG9yKHZhbHVlKSB7XG4gICAgICByZXR1cm4gdmFsdWVzLmluY2x1ZGVzKHZhbHVlKSB8fCBcIkV4cGVjdGVkIG9uZSBvZiBgXCIgKyBkZXNjcmlwdGlvbiArIFwiYCwgYnV0IHJlY2VpdmVkOiBcIiArIHByaW50KHZhbHVlKTtcbiAgICB9XG5cbiAgfSk7XG59XG4vKipcbiAqIEVuc3VyZSB0aGF0IGEgdmFsdWUgaXMgYSBmdW5jdGlvbi5cbiAqL1xuXG5mdW5jdGlvbiBmdW5jKCkge1xuICByZXR1cm4gZGVmaW5lKCdmdW5jJywgdmFsdWUgPT4ge1xuICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbicgfHwgXCJFeHBlY3RlZCBhIGZ1bmN0aW9uLCBidXQgcmVjZWl2ZWQ6IFwiICsgcHJpbnQodmFsdWUpO1xuICB9KTtcbn1cbi8qKlxuICogRW5zdXJlIHRoYXQgYSB2YWx1ZSBpcyBhbiBpbnN0YW5jZSBvZiBhIHNwZWNpZmljIGNsYXNzLlxuICovXG5cbmZ1bmN0aW9uIGluc3RhbmNlKENsYXNzKSB7XG4gIHJldHVybiBkZWZpbmUoJ2luc3RhbmNlJywgdmFsdWUgPT4ge1xuICAgIHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIENsYXNzIHx8IFwiRXhwZWN0ZWQgYSBgXCIgKyBDbGFzcy5uYW1lICsgXCJgIGluc3RhbmNlLCBidXQgcmVjZWl2ZWQ6IFwiICsgcHJpbnQodmFsdWUpO1xuICB9KTtcbn1cbi8qKlxuICogRW5zdXJlIHRoYXQgYSB2YWx1ZSBpcyBhbiBpbnRlZ2VyLlxuICovXG5cbmZ1bmN0aW9uIGludGVnZXIoKSB7XG4gIHJldHVybiBkZWZpbmUoJ2ludGVnZXInLCB2YWx1ZSA9PiB7XG4gICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicgJiYgIWlzTmFOKHZhbHVlKSAmJiBOdW1iZXIuaXNJbnRlZ2VyKHZhbHVlKSB8fCBcIkV4cGVjdGVkIGFuIGludGVnZXIsIGJ1dCByZWNlaXZlZDogXCIgKyBwcmludCh2YWx1ZSk7XG4gIH0pO1xufVxuLyoqXG4gKiBFbnN1cmUgdGhhdCBhIHZhbHVlIG1hdGNoZXMgYWxsIG9mIGEgc2V0IG9mIHR5cGVzLlxuICovXG5cbmZ1bmN0aW9uIGludGVyc2VjdGlvbihTdHJ1Y3RzKSB7XG4gIHJldHVybiBuZXcgU3RydWN0KHtcbiAgICB0eXBlOiAnaW50ZXJzZWN0aW9uJyxcbiAgICBzY2hlbWE6IG51bGwsXG5cbiAgICAqZW50cmllcyh2YWx1ZSwgY3R4KSB7XG4gICAgICBmb3IgKGNvbnN0IFMgb2YgU3RydWN0cykge1xuICAgICAgICB5aWVsZCogUy5lbnRyaWVzKHZhbHVlLCBjdHgpO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICAqdmFsaWRhdG9yKHZhbHVlLCBjdHgpIHtcbiAgICAgIGZvciAoY29uc3QgUyBvZiBTdHJ1Y3RzKSB7XG4gICAgICAgIHlpZWxkKiBTLnZhbGlkYXRvcih2YWx1ZSwgY3R4KTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgKnJlZmluZXIodmFsdWUsIGN0eCkge1xuICAgICAgZm9yIChjb25zdCBTIG9mIFN0cnVjdHMpIHtcbiAgICAgICAgeWllbGQqIFMucmVmaW5lcih2YWx1ZSwgY3R4KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgfSk7XG59XG5mdW5jdGlvbiBsaXRlcmFsKGNvbnN0YW50KSB7XG4gIGNvbnN0IGRlc2NyaXB0aW9uID0gcHJpbnQoY29uc3RhbnQpO1xuICBjb25zdCB0ID0gdHlwZW9mIGNvbnN0YW50O1xuICByZXR1cm4gbmV3IFN0cnVjdCh7XG4gICAgdHlwZTogJ2xpdGVyYWwnLFxuICAgIHNjaGVtYTogdCA9PT0gJ3N0cmluZycgfHwgdCA9PT0gJ251bWJlcicgfHwgdCA9PT0gJ2Jvb2xlYW4nID8gY29uc3RhbnQgOiBudWxsLFxuXG4gICAgdmFsaWRhdG9yKHZhbHVlKSB7XG4gICAgICByZXR1cm4gdmFsdWUgPT09IGNvbnN0YW50IHx8IFwiRXhwZWN0ZWQgdGhlIGxpdGVyYWwgYFwiICsgZGVzY3JpcHRpb24gKyBcImAsIGJ1dCByZWNlaXZlZDogXCIgKyBwcmludCh2YWx1ZSk7XG4gICAgfVxuXG4gIH0pO1xufVxuZnVuY3Rpb24gbWFwKEtleSwgVmFsdWUpIHtcbiAgcmV0dXJuIG5ldyBTdHJ1Y3Qoe1xuICAgIHR5cGU6ICdtYXAnLFxuICAgIHNjaGVtYTogbnVsbCxcblxuICAgICplbnRyaWVzKHZhbHVlKSB7XG4gICAgICBpZiAoS2V5ICYmIFZhbHVlICYmIHZhbHVlIGluc3RhbmNlb2YgTWFwKSB7XG4gICAgICAgIGZvciAoY29uc3QgW2ssIHZdIG9mIHZhbHVlLmVudHJpZXMoKSkge1xuICAgICAgICAgIHlpZWxkIFtrLCBrLCBLZXldO1xuICAgICAgICAgIHlpZWxkIFtrLCB2LCBWYWx1ZV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuXG4gICAgY29lcmNlcih2YWx1ZSkge1xuICAgICAgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgTWFwID8gbmV3IE1hcCh2YWx1ZSkgOiB2YWx1ZTtcbiAgICB9LFxuXG4gICAgdmFsaWRhdG9yKHZhbHVlKSB7XG4gICAgICByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBNYXAgfHwgXCJFeHBlY3RlZCBhIGBNYXBgIG9iamVjdCwgYnV0IHJlY2VpdmVkOiBcIiArIHByaW50KHZhbHVlKTtcbiAgICB9XG5cbiAgfSk7XG59XG4vKipcbiAqIEVuc3VyZSB0aGF0IG5vIHZhbHVlIGV2ZXIgcGFzc2VzIHZhbGlkYXRpb24uXG4gKi9cblxuZnVuY3Rpb24gbmV2ZXIoKSB7XG4gIHJldHVybiBkZWZpbmUoJ25ldmVyJywgKCkgPT4gZmFsc2UpO1xufVxuLyoqXG4gKiBBdWdtZW50IGFuIGV4aXN0aW5nIHN0cnVjdCB0byBhbGxvdyBgbnVsbGAgdmFsdWVzLlxuICovXG5cbmZ1bmN0aW9uIG51bGxhYmxlKHN0cnVjdCkge1xuICByZXR1cm4gbmV3IFN0cnVjdCh7IC4uLnN0cnVjdCxcbiAgICB2YWxpZGF0b3I6ICh2YWx1ZSwgY3R4KSA9PiB2YWx1ZSA9PT0gbnVsbCB8fCBzdHJ1Y3QudmFsaWRhdG9yKHZhbHVlLCBjdHgpLFxuICAgIHJlZmluZXI6ICh2YWx1ZSwgY3R4KSA9PiB2YWx1ZSA9PT0gbnVsbCB8fCBzdHJ1Y3QucmVmaW5lcih2YWx1ZSwgY3R4KVxuICB9KTtcbn1cbi8qKlxuICogRW5zdXJlIHRoYXQgYSB2YWx1ZSBpcyBhIG51bWJlci5cbiAqL1xuXG5mdW5jdGlvbiBudW1iZXIoKSB7XG4gIHJldHVybiBkZWZpbmUoJ251bWJlcicsIHZhbHVlID0+IHtcbiAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJyAmJiAhaXNOYU4odmFsdWUpIHx8IFwiRXhwZWN0ZWQgYSBudW1iZXIsIGJ1dCByZWNlaXZlZDogXCIgKyBwcmludCh2YWx1ZSk7XG4gIH0pO1xufVxuZnVuY3Rpb24gb2JqZWN0KHNjaGVtYSkge1xuICBjb25zdCBrbm93bnMgPSBzY2hlbWEgPyBPYmplY3Qua2V5cyhzY2hlbWEpIDogW107XG4gIGNvbnN0IE5ldmVyID0gbmV2ZXIoKTtcbiAgcmV0dXJuIG5ldyBTdHJ1Y3Qoe1xuICAgIHR5cGU6ICdvYmplY3QnLFxuICAgIHNjaGVtYTogc2NoZW1hID8gc2NoZW1hIDogbnVsbCxcblxuICAgICplbnRyaWVzKHZhbHVlKSB7XG4gICAgICBpZiAoc2NoZW1hICYmIGlzT2JqZWN0KHZhbHVlKSkge1xuICAgICAgICBjb25zdCB1bmtub3ducyA9IG5ldyBTZXQoT2JqZWN0LmtleXModmFsdWUpKTtcblxuICAgICAgICBmb3IgKGNvbnN0IGtleSBvZiBrbm93bnMpIHtcbiAgICAgICAgICB1bmtub3ducy5kZWxldGUoa2V5KTtcbiAgICAgICAgICB5aWVsZCBba2V5LCB2YWx1ZVtrZXldLCBzY2hlbWFba2V5XV07XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKGNvbnN0IGtleSBvZiB1bmtub3ducykge1xuICAgICAgICAgIHlpZWxkIFtrZXksIHZhbHVlW2tleV0sIE5ldmVyXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG5cbiAgICB2YWxpZGF0b3IodmFsdWUpIHtcbiAgICAgIHJldHVybiBpc09iamVjdCh2YWx1ZSkgfHwgXCJFeHBlY3RlZCBhbiBvYmplY3QsIGJ1dCByZWNlaXZlZDogXCIgKyBwcmludCh2YWx1ZSk7XG4gICAgfSxcblxuICAgIGNvZXJjZXIodmFsdWUpIHtcbiAgICAgIHJldHVybiBpc09iamVjdCh2YWx1ZSkgPyB7IC4uLnZhbHVlXG4gICAgICB9IDogdmFsdWU7XG4gICAgfVxuXG4gIH0pO1xufVxuLyoqXG4gKiBBdWdtZW50IGEgc3RydWN0IHRvIGFsbG93IGB1bmRlZmluZWRgIHZhbHVlcy5cbiAqL1xuXG5mdW5jdGlvbiBvcHRpb25hbChzdHJ1Y3QpIHtcbiAgcmV0dXJuIG5ldyBTdHJ1Y3QoeyAuLi5zdHJ1Y3QsXG4gICAgdmFsaWRhdG9yOiAodmFsdWUsIGN0eCkgPT4gdmFsdWUgPT09IHVuZGVmaW5lZCB8fCBzdHJ1Y3QudmFsaWRhdG9yKHZhbHVlLCBjdHgpLFxuICAgIHJlZmluZXI6ICh2YWx1ZSwgY3R4KSA9PiB2YWx1ZSA9PT0gdW5kZWZpbmVkIHx8IHN0cnVjdC5yZWZpbmVyKHZhbHVlLCBjdHgpXG4gIH0pO1xufVxuLyoqXG4gKiBFbnN1cmUgdGhhdCBhIHZhbHVlIGlzIGFuIG9iamVjdCB3aXRoIGtleXMgYW5kIHZhbHVlcyBvZiBzcGVjaWZpYyB0eXBlcywgYnV0XG4gKiB3aXRob3V0IGVuc3VyaW5nIGFueSBzcGVjaWZpYyBzaGFwZSBvZiBwcm9wZXJ0aWVzLlxuICpcbiAqIExpa2UgVHlwZVNjcmlwdCdzIGBSZWNvcmRgIHV0aWxpdHkuXG4gKi9cblxuZnVuY3Rpb24gcmVjb3JkKEtleSwgVmFsdWUpIHtcbiAgcmV0dXJuIG5ldyBTdHJ1Y3Qoe1xuICAgIHR5cGU6ICdyZWNvcmQnLFxuICAgIHNjaGVtYTogbnVsbCxcblxuICAgICplbnRyaWVzKHZhbHVlKSB7XG4gICAgICBpZiAoaXNPYmplY3QodmFsdWUpKSB7XG4gICAgICAgIGZvciAoY29uc3QgayBpbiB2YWx1ZSkge1xuICAgICAgICAgIGNvbnN0IHYgPSB2YWx1ZVtrXTtcbiAgICAgICAgICB5aWVsZCBbaywgaywgS2V5XTtcbiAgICAgICAgICB5aWVsZCBbaywgdiwgVmFsdWVdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcblxuICAgIHZhbGlkYXRvcih2YWx1ZSkge1xuICAgICAgcmV0dXJuIGlzT2JqZWN0KHZhbHVlKSB8fCBcIkV4cGVjdGVkIGFuIG9iamVjdCwgYnV0IHJlY2VpdmVkOiBcIiArIHByaW50KHZhbHVlKTtcbiAgICB9XG5cbiAgfSk7XG59XG4vKipcbiAqIEVuc3VyZSB0aGF0IGEgdmFsdWUgaXMgYSBgUmVnRXhwYC5cbiAqXG4gKiBOb3RlOiB0aGlzIGRvZXMgbm90IHRlc3QgdGhlIHZhbHVlIGFnYWluc3QgdGhlIHJlZ3VsYXIgZXhwcmVzc2lvbiEgRm9yIHRoYXRcbiAqIHlvdSBuZWVkIHRvIHVzZSB0aGUgYHBhdHRlcm4oKWAgcmVmaW5lbWVudC5cbiAqL1xuXG5mdW5jdGlvbiByZWdleHAoKSB7XG4gIHJldHVybiBkZWZpbmUoJ3JlZ2V4cCcsIHZhbHVlID0+IHtcbiAgICByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBSZWdFeHA7XG4gIH0pO1xufVxuZnVuY3Rpb24gc2V0KEVsZW1lbnQpIHtcbiAgcmV0dXJuIG5ldyBTdHJ1Y3Qoe1xuICAgIHR5cGU6ICdzZXQnLFxuICAgIHNjaGVtYTogbnVsbCxcblxuICAgICplbnRyaWVzKHZhbHVlKSB7XG4gICAgICBpZiAoRWxlbWVudCAmJiB2YWx1ZSBpbnN0YW5jZW9mIFNldCkge1xuICAgICAgICBmb3IgKGNvbnN0IHYgb2YgdmFsdWUpIHtcbiAgICAgICAgICB5aWVsZCBbdiwgdiwgRWxlbWVudF07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuXG4gICAgY29lcmNlcih2YWx1ZSkge1xuICAgICAgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgU2V0ID8gbmV3IFNldCh2YWx1ZSkgOiB2YWx1ZTtcbiAgICB9LFxuXG4gICAgdmFsaWRhdG9yKHZhbHVlKSB7XG4gICAgICByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBTZXQgfHwgXCJFeHBlY3RlZCBhIGBTZXRgIG9iamVjdCwgYnV0IHJlY2VpdmVkOiBcIiArIHByaW50KHZhbHVlKTtcbiAgICB9XG5cbiAgfSk7XG59XG4vKipcbiAqIEVuc3VyZSB0aGF0IGEgdmFsdWUgaXMgYSBzdHJpbmcuXG4gKi9cblxuZnVuY3Rpb24gc3RyaW5nKCkge1xuICByZXR1cm4gZGVmaW5lKCdzdHJpbmcnLCB2YWx1ZSA9PiB7XG4gICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycgfHwgXCJFeHBlY3RlZCBhIHN0cmluZywgYnV0IHJlY2VpdmVkOiBcIiArIHByaW50KHZhbHVlKTtcbiAgfSk7XG59XG4vKipcbiAqIEVuc3VyZSB0aGF0IGEgdmFsdWUgaXMgYSB0dXBsZSBvZiBhIHNwZWNpZmljIGxlbmd0aCwgYW5kIHRoYXQgZWFjaCBvZiBpdHNcbiAqIGVsZW1lbnRzIGlzIG9mIGEgc3BlY2lmaWMgdHlwZS5cbiAqL1xuXG5mdW5jdGlvbiB0dXBsZShTdHJ1Y3RzKSB7XG4gIGNvbnN0IE5ldmVyID0gbmV2ZXIoKTtcbiAgcmV0dXJuIG5ldyBTdHJ1Y3Qoe1xuICAgIHR5cGU6ICd0dXBsZScsXG4gICAgc2NoZW1hOiBudWxsLFxuXG4gICAgKmVudHJpZXModmFsdWUpIHtcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICBjb25zdCBsZW5ndGggPSBNYXRoLm1heChTdHJ1Y3RzLmxlbmd0aCwgdmFsdWUubGVuZ3RoKTtcblxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgeWllbGQgW2ksIHZhbHVlW2ldLCBTdHJ1Y3RzW2ldIHx8IE5ldmVyXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG5cbiAgICB2YWxpZGF0b3IodmFsdWUpIHtcbiAgICAgIHJldHVybiBBcnJheS5pc0FycmF5KHZhbHVlKSB8fCBcIkV4cGVjdGVkIGFuIGFycmF5LCBidXQgcmVjZWl2ZWQ6IFwiICsgcHJpbnQodmFsdWUpO1xuICAgIH1cblxuICB9KTtcbn1cbi8qKlxuICogRW5zdXJlIHRoYXQgYSB2YWx1ZSBoYXMgYSBzZXQgb2Yga25vd24gcHJvcGVydGllcyBvZiBzcGVjaWZpYyB0eXBlcy5cbiAqXG4gKiBOb3RlOiBVbnJlY29nbml6ZWQgcHJvcGVydGllcyBhcmUgYWxsb3dlZCBhbmQgdW50b3VjaGVkLiBUaGlzIGlzIHNpbWlsYXIgdG9cbiAqIGhvdyBUeXBlU2NyaXB0J3Mgc3RydWN0dXJhbCB0eXBpbmcgd29ya3MuXG4gKi9cblxuZnVuY3Rpb24gdHlwZShzY2hlbWEpIHtcbiAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKHNjaGVtYSk7XG4gIHJldHVybiBuZXcgU3RydWN0KHtcbiAgICB0eXBlOiAndHlwZScsXG4gICAgc2NoZW1hLFxuXG4gICAgKmVudHJpZXModmFsdWUpIHtcbiAgICAgIGlmIChpc09iamVjdCh2YWx1ZSkpIHtcbiAgICAgICAgZm9yIChjb25zdCBrIG9mIGtleXMpIHtcbiAgICAgICAgICB5aWVsZCBbaywgdmFsdWVba10sIHNjaGVtYVtrXV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuXG4gICAgdmFsaWRhdG9yKHZhbHVlKSB7XG4gICAgICByZXR1cm4gaXNPYmplY3QodmFsdWUpIHx8IFwiRXhwZWN0ZWQgYW4gb2JqZWN0LCBidXQgcmVjZWl2ZWQ6IFwiICsgcHJpbnQodmFsdWUpO1xuICAgIH1cblxuICB9KTtcbn1cbi8qKlxuICogRW5zdXJlIHRoYXQgYSB2YWx1ZSBtYXRjaGVzIG9uZSBvZiBhIHNldCBvZiB0eXBlcy5cbiAqL1xuXG5mdW5jdGlvbiB1bmlvbihTdHJ1Y3RzKSB7XG4gIGNvbnN0IGRlc2NyaXB0aW9uID0gU3RydWN0cy5tYXAocyA9PiBzLnR5cGUpLmpvaW4oJyB8ICcpO1xuICByZXR1cm4gbmV3IFN0cnVjdCh7XG4gICAgdHlwZTogJ3VuaW9uJyxcbiAgICBzY2hlbWE6IG51bGwsXG5cbiAgICBjb2VyY2VyKHZhbHVlLCBjdHgpIHtcbiAgICAgIGNvbnN0IGZpcnN0TWF0Y2ggPSBTdHJ1Y3RzLmZpbmQocyA9PiB7XG4gICAgICAgIGNvbnN0IFtlXSA9IHMudmFsaWRhdGUodmFsdWUsIHtcbiAgICAgICAgICBjb2VyY2U6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiAhZTtcbiAgICAgIH0pIHx8IHVua25vd24oKTtcbiAgICAgIHJldHVybiBmaXJzdE1hdGNoLmNvZXJjZXIodmFsdWUsIGN0eCk7XG4gICAgfSxcblxuICAgIHZhbGlkYXRvcih2YWx1ZSwgY3R4KSB7XG4gICAgICBjb25zdCBmYWlsdXJlcyA9IFtdO1xuXG4gICAgICBmb3IgKGNvbnN0IFMgb2YgU3RydWN0cykge1xuICAgICAgICBjb25zdCBbLi4udHVwbGVzXSA9IHJ1bih2YWx1ZSwgUywgY3R4KTtcbiAgICAgICAgY29uc3QgW2ZpcnN0XSA9IHR1cGxlcztcblxuICAgICAgICBpZiAoIWZpcnN0WzBdKSB7XG4gICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGZvciAoY29uc3QgW2ZhaWx1cmVdIG9mIHR1cGxlcykge1xuICAgICAgICAgICAgaWYgKGZhaWx1cmUpIHtcbiAgICAgICAgICAgICAgZmFpbHVyZXMucHVzaChmYWlsdXJlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIFtcIkV4cGVjdGVkIHRoZSB2YWx1ZSB0byBzYXRpc2Z5IGEgdW5pb24gb2YgYFwiICsgZGVzY3JpcHRpb24gKyBcImAsIGJ1dCByZWNlaXZlZDogXCIgKyBwcmludCh2YWx1ZSksIC4uLmZhaWx1cmVzXTtcbiAgICB9XG5cbiAgfSk7XG59XG4vKipcbiAqIEVuc3VyZSB0aGF0IGFueSB2YWx1ZSBwYXNzZXMgdmFsaWRhdGlvbiwgd2l0aG91dCB3aWRlbmluZyBpdHMgdHlwZSB0byBgYW55YC5cbiAqL1xuXG5mdW5jdGlvbiB1bmtub3duKCkge1xuICByZXR1cm4gZGVmaW5lKCd1bmtub3duJywgKCkgPT4gdHJ1ZSk7XG59XG5cbi8qKlxuICogQXVnbWVudCBhIGBTdHJ1Y3RgIHRvIGFkZCBhbiBhZGRpdGlvbmFsIGNvZXJjaW9uIHN0ZXAgdG8gaXRzIGlucHV0LlxuICpcbiAqIFRoaXMgYWxsb3dzIHlvdSB0byB0cmFuc2Zvcm0gaW5wdXQgZGF0YSBiZWZvcmUgdmFsaWRhdGluZyBpdCwgdG8gaW5jcmVhc2UgdGhlXG4gKiBsaWtlbGlob29kIHRoYXQgaXQgcGFzc2VzIHZhbGlkYXRpb27igJRmb3IgZXhhbXBsZSBmb3IgZGVmYXVsdCB2YWx1ZXMsIHBhcnNpbmdcbiAqIGRpZmZlcmVudCBmb3JtYXRzLCBldGMuXG4gKlxuICogTm90ZTogWW91IG11c3QgdXNlIGBjcmVhdGUodmFsdWUsIFN0cnVjdClgIG9uIHRoZSB2YWx1ZSB0byBoYXZlIHRoZSBjb2VyY2lvblxuICogdGFrZSBlZmZlY3QhIFVzaW5nIHNpbXBseSBgYXNzZXJ0KClgIG9yIGBpcygpYCB3aWxsIG5vdCB1c2UgY29lcmNpb24uXG4gKi9cblxuZnVuY3Rpb24gY29lcmNlKHN0cnVjdCwgY29uZGl0aW9uLCBjb2VyY2VyKSB7XG4gIHJldHVybiBuZXcgU3RydWN0KHsgLi4uc3RydWN0LFxuICAgIGNvZXJjZXI6ICh2YWx1ZSwgY3R4KSA9PiB7XG4gICAgICByZXR1cm4gaXModmFsdWUsIGNvbmRpdGlvbikgPyBzdHJ1Y3QuY29lcmNlcihjb2VyY2VyKHZhbHVlLCBjdHgpLCBjdHgpIDogc3RydWN0LmNvZXJjZXIodmFsdWUsIGN0eCk7XG4gICAgfVxuICB9KTtcbn1cbi8qKlxuICogQXVnbWVudCBhIHN0cnVjdCB0byByZXBsYWNlIGB1bmRlZmluZWRgIHZhbHVlcyB3aXRoIGEgZGVmYXVsdC5cbiAqXG4gKiBOb3RlOiBZb3UgbXVzdCB1c2UgYGNyZWF0ZSh2YWx1ZSwgU3RydWN0KWAgb24gdGhlIHZhbHVlIHRvIGhhdmUgdGhlIGNvZXJjaW9uXG4gKiB0YWtlIGVmZmVjdCEgVXNpbmcgc2ltcGx5IGBhc3NlcnQoKWAgb3IgYGlzKClgIHdpbGwgbm90IHVzZSBjb2VyY2lvbi5cbiAqL1xuXG5mdW5jdGlvbiBkZWZhdWx0ZWQoc3RydWN0LCBmYWxsYmFjaywgb3B0aW9ucykge1xuICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7XG4gICAgb3B0aW9ucyA9IHt9O1xuICB9XG5cbiAgcmV0dXJuIGNvZXJjZShzdHJ1Y3QsIHVua25vd24oKSwgeCA9PiB7XG4gICAgY29uc3QgZiA9IHR5cGVvZiBmYWxsYmFjayA9PT0gJ2Z1bmN0aW9uJyA/IGZhbGxiYWNrKCkgOiBmYWxsYmFjaztcblxuICAgIGlmICh4ID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiBmO1xuICAgIH1cblxuICAgIGlmICghb3B0aW9ucy5zdHJpY3QgJiYgaXNQbGFpbk9iamVjdCh4KSAmJiBpc1BsYWluT2JqZWN0KGYpKSB7XG4gICAgICBjb25zdCByZXQgPSB7IC4uLnhcbiAgICAgIH07XG4gICAgICBsZXQgY2hhbmdlZCA9IGZhbHNlO1xuXG4gICAgICBmb3IgKGNvbnN0IGtleSBpbiBmKSB7XG4gICAgICAgIGlmIChyZXRba2V5XSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgcmV0W2tleV0gPSBmW2tleV07XG4gICAgICAgICAgY2hhbmdlZCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKGNoYW5nZWQpIHtcbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4geDtcbiAgfSk7XG59XG4vKipcbiAqIEF1Z21lbnQgYSBzdHJ1Y3QgdG8gdHJpbSBzdHJpbmcgaW5wdXRzLlxuICpcbiAqIE5vdGU6IFlvdSBtdXN0IHVzZSBgY3JlYXRlKHZhbHVlLCBTdHJ1Y3QpYCBvbiB0aGUgdmFsdWUgdG8gaGF2ZSB0aGUgY29lcmNpb25cbiAqIHRha2UgZWZmZWN0ISBVc2luZyBzaW1wbHkgYGFzc2VydCgpYCBvciBgaXMoKWAgd2lsbCBub3QgdXNlIGNvZXJjaW9uLlxuICovXG5cbmZ1bmN0aW9uIHRyaW1tZWQoc3RydWN0KSB7XG4gIHJldHVybiBjb2VyY2Uoc3RydWN0LCBzdHJpbmcoKSwgeCA9PiB4LnRyaW0oKSk7XG59XG5cbi8qKlxuICogRW5zdXJlIHRoYXQgYSBzdHJpbmcsIGFycmF5LCBtYXAsIG9yIHNldCBpcyBlbXB0eS5cbiAqL1xuXG5mdW5jdGlvbiBlbXB0eShzdHJ1Y3QpIHtcbiAgcmV0dXJuIHJlZmluZShzdHJ1Y3QsICdlbXB0eScsIHZhbHVlID0+IHtcbiAgICBjb25zdCBzaXplID0gZ2V0U2l6ZSh2YWx1ZSk7XG4gICAgcmV0dXJuIHNpemUgPT09IDAgfHwgXCJFeHBlY3RlZCBhbiBlbXB0eSBcIiArIHN0cnVjdC50eXBlICsgXCIgYnV0IHJlY2VpdmVkIG9uZSB3aXRoIGEgc2l6ZSBvZiBgXCIgKyBzaXplICsgXCJgXCI7XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBnZXRTaXplKHZhbHVlKSB7XG4gIGlmICh2YWx1ZSBpbnN0YW5jZW9mIE1hcCB8fCB2YWx1ZSBpbnN0YW5jZW9mIFNldCkge1xuICAgIHJldHVybiB2YWx1ZS5zaXplO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiB2YWx1ZS5sZW5ndGg7XG4gIH1cbn1cbi8qKlxuICogRW5zdXJlIHRoYXQgYSBudW1iZXIgb3IgZGF0ZSBpcyBiZWxvdyBhIHRocmVzaG9sZC5cbiAqL1xuXG5cbmZ1bmN0aW9uIG1heChzdHJ1Y3QsIHRocmVzaG9sZCwgb3B0aW9ucykge1xuICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7XG4gICAgb3B0aW9ucyA9IHt9O1xuICB9XG5cbiAgY29uc3Qge1xuICAgIGV4Y2x1c2l2ZVxuICB9ID0gb3B0aW9ucztcbiAgcmV0dXJuIHJlZmluZShzdHJ1Y3QsICdtYXgnLCB2YWx1ZSA9PiB7XG4gICAgcmV0dXJuIGV4Y2x1c2l2ZSA/IHZhbHVlIDwgdGhyZXNob2xkIDogdmFsdWUgPD0gdGhyZXNob2xkIHx8IFwiRXhwZWN0ZWQgYSBcIiArIHN0cnVjdC50eXBlICsgXCIgbGVzcyB0aGFuIFwiICsgKGV4Y2x1c2l2ZSA/ICcnIDogJ29yIGVxdWFsIHRvICcpICsgdGhyZXNob2xkICsgXCIgYnV0IHJlY2VpdmVkIGBcIiArIHZhbHVlICsgXCJgXCI7XG4gIH0pO1xufVxuLyoqXG4gKiBFbnN1cmUgdGhhdCBhIG51bWJlciBvciBkYXRlIGlzIGFib3ZlIGEgdGhyZXNob2xkLlxuICovXG5cbmZ1bmN0aW9uIG1pbihzdHJ1Y3QsIHRocmVzaG9sZCwgb3B0aW9ucykge1xuICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7XG4gICAgb3B0aW9ucyA9IHt9O1xuICB9XG5cbiAgY29uc3Qge1xuICAgIGV4Y2x1c2l2ZVxuICB9ID0gb3B0aW9ucztcbiAgcmV0dXJuIHJlZmluZShzdHJ1Y3QsICdtaW4nLCB2YWx1ZSA9PiB7XG4gICAgcmV0dXJuIGV4Y2x1c2l2ZSA/IHZhbHVlID4gdGhyZXNob2xkIDogdmFsdWUgPj0gdGhyZXNob2xkIHx8IFwiRXhwZWN0ZWQgYSBcIiArIHN0cnVjdC50eXBlICsgXCIgZ3JlYXRlciB0aGFuIFwiICsgKGV4Y2x1c2l2ZSA/ICcnIDogJ29yIGVxdWFsIHRvICcpICsgdGhyZXNob2xkICsgXCIgYnV0IHJlY2VpdmVkIGBcIiArIHZhbHVlICsgXCJgXCI7XG4gIH0pO1xufVxuLyoqXG4gKiBFbnN1cmUgdGhhdCBhIHN0cmluZywgYXJyYXksIG1hcCBvciBzZXQgaXMgbm90IGVtcHR5LlxuICovXG5cbmZ1bmN0aW9uIG5vbmVtcHR5KHN0cnVjdCkge1xuICByZXR1cm4gcmVmaW5lKHN0cnVjdCwgJ25vbmVtcHR5JywgdmFsdWUgPT4ge1xuICAgIGNvbnN0IHNpemUgPSBnZXRTaXplKHZhbHVlKTtcbiAgICByZXR1cm4gc2l6ZSA+IDAgfHwgXCJFeHBlY3RlZCBhIG5vbmVtcHR5IFwiICsgc3RydWN0LnR5cGUgKyBcIiBidXQgcmVjZWl2ZWQgYW4gZW1wdHkgb25lXCI7XG4gIH0pO1xufVxuLyoqXG4gKiBFbnN1cmUgdGhhdCBhIHN0cmluZyBtYXRjaGVzIGEgcmVndWxhciBleHByZXNzaW9uLlxuICovXG5cbmZ1bmN0aW9uIHBhdHRlcm4oc3RydWN0LCByZWdleHApIHtcbiAgcmV0dXJuIHJlZmluZShzdHJ1Y3QsICdwYXR0ZXJuJywgdmFsdWUgPT4ge1xuICAgIHJldHVybiByZWdleHAudGVzdCh2YWx1ZSkgfHwgXCJFeHBlY3RlZCBhIFwiICsgc3RydWN0LnR5cGUgKyBcIiBtYXRjaGluZyBgL1wiICsgcmVnZXhwLnNvdXJjZSArIFwiL2AgYnV0IHJlY2VpdmVkIFxcXCJcIiArIHZhbHVlICsgXCJcXFwiXCI7XG4gIH0pO1xufVxuLyoqXG4gKiBFbnN1cmUgdGhhdCBhIHN0cmluZywgYXJyYXksIG51bWJlciwgZGF0ZSwgbWFwLCBvciBzZXQgaGFzIGEgc2l6ZSAob3IgbGVuZ3RoLCBvciB0aW1lKSBiZXR3ZWVuIGBtaW5gIGFuZCBgbWF4YC5cbiAqL1xuXG5mdW5jdGlvbiBzaXplKHN0cnVjdCwgbWluLCBtYXgpIHtcbiAgaWYgKG1heCA9PT0gdm9pZCAwKSB7XG4gICAgbWF4ID0gbWluO1xuICB9XG5cbiAgY29uc3QgZXhwZWN0ZWQgPSBcIkV4cGVjdGVkIGEgXCIgKyBzdHJ1Y3QudHlwZTtcbiAgY29uc3Qgb2YgPSBtaW4gPT09IG1heCA/IFwib2YgYFwiICsgbWluICsgXCJgXCIgOiBcImJldHdlZW4gYFwiICsgbWluICsgXCJgIGFuZCBgXCIgKyBtYXggKyBcImBcIjtcbiAgcmV0dXJuIHJlZmluZShzdHJ1Y3QsICdzaXplJywgdmFsdWUgPT4ge1xuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInIHx8IHZhbHVlIGluc3RhbmNlb2YgRGF0ZSkge1xuICAgICAgcmV0dXJuIG1pbiA8PSB2YWx1ZSAmJiB2YWx1ZSA8PSBtYXggfHwgZXhwZWN0ZWQgKyBcIiBcIiArIG9mICsgXCIgYnV0IHJlY2VpdmVkIGBcIiArIHZhbHVlICsgXCJgXCI7XG4gICAgfSBlbHNlIGlmICh2YWx1ZSBpbnN0YW5jZW9mIE1hcCB8fCB2YWx1ZSBpbnN0YW5jZW9mIFNldCkge1xuICAgICAgY29uc3Qge1xuICAgICAgICBzaXplXG4gICAgICB9ID0gdmFsdWU7XG4gICAgICByZXR1cm4gbWluIDw9IHNpemUgJiYgc2l6ZSA8PSBtYXggfHwgZXhwZWN0ZWQgKyBcIiB3aXRoIGEgc2l6ZSBcIiArIG9mICsgXCIgYnV0IHJlY2VpdmVkIG9uZSB3aXRoIGEgc2l6ZSBvZiBgXCIgKyBzaXplICsgXCJgXCI7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgbGVuZ3RoXG4gICAgICB9ID0gdmFsdWU7XG4gICAgICByZXR1cm4gbWluIDw9IGxlbmd0aCAmJiBsZW5ndGggPD0gbWF4IHx8IGV4cGVjdGVkICsgXCIgd2l0aCBhIGxlbmd0aCBcIiArIG9mICsgXCIgYnV0IHJlY2VpdmVkIG9uZSB3aXRoIGEgbGVuZ3RoIG9mIGBcIiArIGxlbmd0aCArIFwiYFwiO1xuICAgIH1cbiAgfSk7XG59XG4vKipcbiAqIEF1Z21lbnQgYSBgU3RydWN0YCB0byBhZGQgYW4gYWRkaXRpb25hbCByZWZpbmVtZW50IHRvIHRoZSB2YWxpZGF0aW9uLlxuICpcbiAqIFRoZSByZWZpbmVyIGZ1bmN0aW9uIGlzIGd1YXJhbnRlZWQgdG8gcmVjZWl2ZSBhIHZhbHVlIG9mIHRoZSBzdHJ1Y3QncyB0eXBlLFxuICogYmVjYXVzZSB0aGUgc3RydWN0J3MgZXhpc3RpbmcgdmFsaWRhdGlvbiB3aWxsIGFscmVhZHkgaGF2ZSBwYXNzZWQuIFRoaXNcbiAqIGFsbG93cyB5b3UgdG8gbGF5ZXIgYWRkaXRpb25hbCB2YWxpZGF0aW9uIG9uIHRvcCBvZiBleGlzdGluZyBzdHJ1Y3RzLlxuICovXG5cbmZ1bmN0aW9uIHJlZmluZShzdHJ1Y3QsIG5hbWUsIHJlZmluZXIpIHtcbiAgcmV0dXJuIG5ldyBTdHJ1Y3QoeyAuLi5zdHJ1Y3QsXG5cbiAgICAqcmVmaW5lcih2YWx1ZSwgY3R4KSB7XG4gICAgICB5aWVsZCogc3RydWN0LnJlZmluZXIodmFsdWUsIGN0eCk7XG4gICAgICBjb25zdCByZXN1bHQgPSByZWZpbmVyKHZhbHVlLCBjdHgpO1xuICAgICAgY29uc3QgZmFpbHVyZXMgPSB0b0ZhaWx1cmVzKHJlc3VsdCwgY3R4LCBzdHJ1Y3QsIHZhbHVlKTtcblxuICAgICAgZm9yIChjb25zdCBmYWlsdXJlIG9mIGZhaWx1cmVzKSB7XG4gICAgICAgIHlpZWxkIHsgLi4uZmFpbHVyZSxcbiAgICAgICAgICByZWZpbmVtZW50OiBuYW1lXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfVxuXG4gIH0pO1xufVxuXG5leHBvcnQgeyBTdHJ1Y3QsIFN0cnVjdEVycm9yLCBhbnksIGFycmF5LCBhc3NlcnQsIGFzc2lnbiwgYmlnaW50LCBib29sZWFuLCBjb2VyY2UsIGNyZWF0ZSwgZGF0ZSwgZGVmYXVsdGVkLCBkZWZpbmUsIGRlcHJlY2F0ZWQsIGR5bmFtaWMsIGVtcHR5LCBlbnVtcywgZnVuYywgaW5zdGFuY2UsIGludGVnZXIsIGludGVyc2VjdGlvbiwgaXMsIGxhenksIGxpdGVyYWwsIG1hcCwgbWFzaywgbWF4LCBtaW4sIG5ldmVyLCBub25lbXB0eSwgbnVsbGFibGUsIG51bWJlciwgb2JqZWN0LCBvbWl0LCBvcHRpb25hbCwgcGFydGlhbCwgcGF0dGVybiwgcGljaywgcmVjb3JkLCByZWZpbmUsIHJlZ2V4cCwgc2V0LCBzaXplLCBzdHJpbmcsIHN0cnVjdCwgdHJpbW1lZCwgdHVwbGUsIHR5cGUsIHVuaW9uLCB1bmtub3duLCB2YWxpZGF0ZSB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguZXMuanMubWFwXG4iXSwibmFtZXMiOlsiU3RydWN0RXJyb3IiLCJUeXBlRXJyb3IiLCJjb25zdHJ1Y3RvciIsImZhaWx1cmUiLCJmYWlsdXJlcyIsImNhY2hlZCIsIm1lc3NhZ2UiLCJyZXN0IiwicGF0aCIsIm1zZyIsImxlbmd0aCIsImpvaW4iLCJ2YWx1ZSIsImtleSIsInR5cGUiLCJyZWZpbmVtZW50IiwiYnJhbmNoIiwiT2JqZWN0IiwiYXNzaWduIiwibmFtZSIsIl9jYWNoZWQiLCJpc0l0ZXJhYmxlIiwieCIsImlzT2JqZWN0IiwiU3ltYm9sIiwiaXRlcmF0b3IiLCJpc1BsYWluT2JqZWN0IiwicHJvdG90eXBlIiwidG9TdHJpbmciLCJjYWxsIiwiZ2V0UHJvdG90eXBlT2YiLCJwcmludCIsIkpTT04iLCJzdHJpbmdpZnkiLCJzaGlmdEl0ZXJhdG9yIiwiaW5wdXQiLCJkb25lIiwibmV4dCIsInVuZGVmaW5lZCIsInRvRmFpbHVyZSIsInJlc3VsdCIsImNvbnRleHQiLCJzdHJ1Y3QiLCJ0b0ZhaWx1cmVzIiwiciIsInJ1biIsIm9wdGlvbnMiLCJjb2VyY2UiLCJtYXNrIiwiY3R4IiwiY29lcmNlciIsInNjaGVtYSIsIkFycmF5IiwiaXNBcnJheSIsInZhbGlkIiwidmFsaWRhdG9yIiwiayIsInYiLCJzIiwiZW50cmllcyIsInRzIiwidCIsIk1hcCIsInNldCIsIlNldCIsImFkZCIsInJlZmluZXIiLCJTdHJ1Y3QiLCJwcm9wcyIsIlRZUEUiLCJhc3NlcnQiLCJjcmVhdGUiLCJpcyIsInZhbGlkYXRlIiwidHVwbGVzIiwidHVwbGUiLCJlcnJvciIsIl9sZW4iLCJhcmd1bWVudHMiLCJTdHJ1Y3RzIiwiX2tleSIsImlzVHlwZSIsInNjaGVtYXMiLCJtYXAiLCJvYmplY3QiLCJkZWZpbmUiLCJkZXByZWNhdGVkIiwibG9nIiwiZHluYW1pYyIsImZuIiwibGF6eSIsIl9zdHJ1Y3QiLCJfc3RydWN0MiIsIl9zdHJ1Y3QzIiwiX3N0cnVjdDQiLCJvbWl0Iiwia2V5cyIsInN1YnNjaGVtYSIsInBhcnRpYWwiLCJvcHRpb25hbCIsInBpY2siLCJjb25zb2xlIiwid2FybiIsImFueSIsImFycmF5IiwiRWxlbWVudCIsImkiLCJzbGljZSIsImJpZ2ludCIsImJvb2xlYW4iLCJkYXRlIiwiRGF0ZSIsImlzTmFOIiwiZ2V0VGltZSIsImVudW1zIiwidmFsdWVzIiwiZGVzY3JpcHRpb24iLCJpbmNsdWRlcyIsImZ1bmMiLCJpbnN0YW5jZSIsIkNsYXNzIiwiaW50ZWdlciIsIk51bWJlciIsImlzSW50ZWdlciIsImludGVyc2VjdGlvbiIsIlMiLCJsaXRlcmFsIiwiY29uc3RhbnQiLCJLZXkiLCJWYWx1ZSIsIm5ldmVyIiwibnVsbGFibGUiLCJudW1iZXIiLCJrbm93bnMiLCJOZXZlciIsInVua25vd25zIiwiZGVsZXRlIiwicmVjb3JkIiwicmVnZXhwIiwiUmVnRXhwIiwic3RyaW5nIiwiTWF0aCIsIm1heCIsInVuaW9uIiwiZmlyc3RNYXRjaCIsImZpbmQiLCJlIiwidW5rbm93biIsImZpcnN0IiwicHVzaCIsImNvbmRpdGlvbiIsImRlZmF1bHRlZCIsImZhbGxiYWNrIiwiZiIsInN0cmljdCIsInJldCIsImNoYW5nZWQiLCJ0cmltbWVkIiwidHJpbSIsImVtcHR5IiwicmVmaW5lIiwic2l6ZSIsImdldFNpemUiLCJ0aHJlc2hvbGQiLCJleGNsdXNpdmUiLCJtaW4iLCJub25lbXB0eSIsInBhdHRlcm4iLCJ0ZXN0Iiwic291cmNlIiwiZXhwZWN0ZWQiLCJvZiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/../anchor/node_modules/superstruct/lib/index.es.js\n");

/***/ }),

/***/ "(ssr)/../node_modules/superstruct/dist/index.mjs":
/*!**************************************************!*\
  !*** ../node_modules/superstruct/dist/index.mjs ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Struct: () => (/* binding */ Struct),\n/* harmony export */   StructError: () => (/* binding */ StructError),\n/* harmony export */   any: () => (/* binding */ any),\n/* harmony export */   array: () => (/* binding */ array),\n/* harmony export */   assert: () => (/* binding */ assert),\n/* harmony export */   assign: () => (/* binding */ assign),\n/* harmony export */   bigint: () => (/* binding */ bigint),\n/* harmony export */   boolean: () => (/* binding */ boolean),\n/* harmony export */   coerce: () => (/* binding */ coerce),\n/* harmony export */   create: () => (/* binding */ create),\n/* harmony export */   date: () => (/* binding */ date),\n/* harmony export */   defaulted: () => (/* binding */ defaulted),\n/* harmony export */   define: () => (/* binding */ define),\n/* harmony export */   deprecated: () => (/* binding */ deprecated),\n/* harmony export */   dynamic: () => (/* binding */ dynamic),\n/* harmony export */   empty: () => (/* binding */ empty),\n/* harmony export */   enums: () => (/* binding */ enums),\n/* harmony export */   func: () => (/* binding */ func),\n/* harmony export */   instance: () => (/* binding */ instance),\n/* harmony export */   integer: () => (/* binding */ integer),\n/* harmony export */   intersection: () => (/* binding */ intersection),\n/* harmony export */   is: () => (/* binding */ is),\n/* harmony export */   lazy: () => (/* binding */ lazy),\n/* harmony export */   literal: () => (/* binding */ literal),\n/* harmony export */   map: () => (/* binding */ map),\n/* harmony export */   mask: () => (/* binding */ mask),\n/* harmony export */   max: () => (/* binding */ max),\n/* harmony export */   min: () => (/* binding */ min),\n/* harmony export */   never: () => (/* binding */ never),\n/* harmony export */   nonempty: () => (/* binding */ nonempty),\n/* harmony export */   nullable: () => (/* binding */ nullable),\n/* harmony export */   number: () => (/* binding */ number),\n/* harmony export */   object: () => (/* binding */ object),\n/* harmony export */   omit: () => (/* binding */ omit),\n/* harmony export */   optional: () => (/* binding */ optional),\n/* harmony export */   partial: () => (/* binding */ partial),\n/* harmony export */   pattern: () => (/* binding */ pattern),\n/* harmony export */   pick: () => (/* binding */ pick),\n/* harmony export */   record: () => (/* binding */ record),\n/* harmony export */   refine: () => (/* binding */ refine),\n/* harmony export */   regexp: () => (/* binding */ regexp),\n/* harmony export */   set: () => (/* binding */ set),\n/* harmony export */   size: () => (/* binding */ size),\n/* harmony export */   string: () => (/* binding */ string),\n/* harmony export */   struct: () => (/* binding */ struct),\n/* harmony export */   trimmed: () => (/* binding */ trimmed),\n/* harmony export */   tuple: () => (/* binding */ tuple),\n/* harmony export */   type: () => (/* binding */ type),\n/* harmony export */   union: () => (/* binding */ union),\n/* harmony export */   unknown: () => (/* binding */ unknown),\n/* harmony export */   validate: () => (/* binding */ validate)\n/* harmony export */ });\n/**\n * A `StructFailure` represents a single specific failure in validation.\n */ /**\n * `StructError` objects are thrown (or returned) when validation fails.\n *\n * Validation logic is design to exit early for maximum performance. The error\n * represents the first error encountered during validation. For more detail,\n * the `error.failures` property is a generator function that can be run to\n * continue validation and receive all the failures in the data.\n */ class StructError extends TypeError {\n    constructor(failure, failures){\n        let cached;\n        const { message, explanation, ...rest } = failure;\n        const { path } = failure;\n        const msg = path.length === 0 ? message : `At path: ${path.join(\".\")} -- ${message}`;\n        super(explanation ?? msg);\n        if (explanation != null) this.cause = msg;\n        Object.assign(this, rest);\n        this.name = this.constructor.name;\n        this.failures = ()=>{\n            return cached ?? (cached = [\n                failure,\n                ...failures()\n            ]);\n        };\n    }\n}\n/**\n * Check if a value is an iterator.\n */ function isIterable(x) {\n    return isObject(x) && typeof x[Symbol.iterator] === \"function\";\n}\n/**\n * Check if a value is a plain object.\n */ function isObject(x) {\n    return typeof x === \"object\" && x != null;\n}\n/**\n * Check if a value is a plain object.\n */ function isPlainObject(x) {\n    if (Object.prototype.toString.call(x) !== \"[object Object]\") {\n        return false;\n    }\n    const prototype = Object.getPrototypeOf(x);\n    return prototype === null || prototype === Object.prototype;\n}\n/**\n * Return a value as a printable string.\n */ function print(value) {\n    if (typeof value === \"symbol\") {\n        return value.toString();\n    }\n    return typeof value === \"string\" ? JSON.stringify(value) : `${value}`;\n}\n/**\n * Shifts (removes and returns) the first value from the `input` iterator.\n * Like `Array.prototype.shift()` but for an `Iterator`.\n */ function shiftIterator(input) {\n    const { done, value } = input.next();\n    return done ? undefined : value;\n}\n/**\n * Convert a single validation result to a failure.\n */ function toFailure(result, context, struct, value) {\n    if (result === true) {\n        return;\n    } else if (result === false) {\n        result = {};\n    } else if (typeof result === \"string\") {\n        result = {\n            message: result\n        };\n    }\n    const { path, branch } = context;\n    const { type } = struct;\n    const { refinement, message = `Expected a value of type \\`${type}\\`${refinement ? ` with refinement \\`${refinement}\\`` : \"\"}, but received: \\`${print(value)}\\`` } = result;\n    return {\n        value,\n        type,\n        refinement,\n        key: path[path.length - 1],\n        path,\n        branch,\n        ...result,\n        message\n    };\n}\n/**\n * Convert a validation result to an iterable of failures.\n */ function* toFailures(result, context, struct, value) {\n    if (!isIterable(result)) {\n        result = [\n            result\n        ];\n    }\n    for (const r of result){\n        const failure = toFailure(r, context, struct, value);\n        if (failure) {\n            yield failure;\n        }\n    }\n}\n/**\n * Check a value against a struct, traversing deeply into nested values, and\n * returning an iterator of failures or success.\n */ function* run(value, struct, options = {}) {\n    const { path = [], branch = [\n        value\n    ], coerce = false, mask = false } = options;\n    const ctx = {\n        path,\n        branch\n    };\n    if (coerce) {\n        value = struct.coercer(value, ctx);\n        if (mask && struct.type !== \"type\" && isObject(struct.schema) && isObject(value) && !Array.isArray(value)) {\n            for(const key in value){\n                if (struct.schema[key] === undefined) {\n                    delete value[key];\n                }\n            }\n        }\n    }\n    let status = \"valid\";\n    for (const failure of struct.validator(value, ctx)){\n        failure.explanation = options.message;\n        status = \"not_valid\";\n        yield [\n            failure,\n            undefined\n        ];\n    }\n    for (let [k, v, s] of struct.entries(value, ctx)){\n        const ts = run(v, s, {\n            path: k === undefined ? path : [\n                ...path,\n                k\n            ],\n            branch: k === undefined ? branch : [\n                ...branch,\n                v\n            ],\n            coerce,\n            mask,\n            message: options.message\n        });\n        for (const t of ts){\n            if (t[0]) {\n                status = t[0].refinement != null ? \"not_refined\" : \"not_valid\";\n                yield [\n                    t[0],\n                    undefined\n                ];\n            } else if (coerce) {\n                v = t[1];\n                if (k === undefined) {\n                    value = v;\n                } else if (value instanceof Map) {\n                    value.set(k, v);\n                } else if (value instanceof Set) {\n                    value.add(v);\n                } else if (isObject(value)) {\n                    if (v !== undefined || k in value) value[k] = v;\n                }\n            }\n        }\n    }\n    if (status !== \"not_valid\") {\n        for (const failure of struct.refiner(value, ctx)){\n            failure.explanation = options.message;\n            status = \"not_refined\";\n            yield [\n                failure,\n                undefined\n            ];\n        }\n    }\n    if (status === \"valid\") {\n        yield [\n            undefined,\n            value\n        ];\n    }\n}\n/**\n * `Struct` objects encapsulate the validation logic for a specific type of\n * values. Once constructed, you use the `assert`, `is` or `validate` helpers to\n * validate unknown input data against the struct.\n */ class Struct {\n    constructor(props){\n        const { type, schema, validator, refiner, coercer = (value)=>value, entries = function*() {} } = props;\n        this.type = type;\n        this.schema = schema;\n        this.entries = entries;\n        this.coercer = coercer;\n        if (validator) {\n            this.validator = (value, context)=>{\n                const result = validator(value, context);\n                return toFailures(result, context, this, value);\n            };\n        } else {\n            this.validator = ()=>[];\n        }\n        if (refiner) {\n            this.refiner = (value, context)=>{\n                const result = refiner(value, context);\n                return toFailures(result, context, this, value);\n            };\n        } else {\n            this.refiner = ()=>[];\n        }\n    }\n    /**\n     * Assert that a value passes the struct's validation, throwing if it doesn't.\n     */ assert(value, message) {\n        return assert(value, this, message);\n    }\n    /**\n     * Create a value with the struct's coercion logic, then validate it.\n     */ create(value, message) {\n        return create(value, this, message);\n    }\n    /**\n     * Check if a value passes the struct's validation.\n     */ is(value) {\n        return is(value, this);\n    }\n    /**\n     * Mask a value, coercing and validating it, but returning only the subset of\n     * properties defined by the struct's schema.\n     */ mask(value, message) {\n        return mask(value, this, message);\n    }\n    /**\n     * Validate a value with the struct's validation logic, returning a tuple\n     * representing the result.\n     *\n     * You may optionally pass `true` for the `withCoercion` argument to coerce\n     * the value before attempting to validate it. If you do, the result will\n     * contain the coerced result when successful.\n     */ validate(value, options = {}) {\n        return validate(value, this, options);\n    }\n}\n/**\n * Assert that a value passes a struct, throwing if it doesn't.\n */ function assert(value, struct, message) {\n    const result = validate(value, struct, {\n        message\n    });\n    if (result[0]) {\n        throw result[0];\n    }\n}\n/**\n * Create a value with the coercion logic of struct and validate it.\n */ function create(value, struct, message) {\n    const result = validate(value, struct, {\n        coerce: true,\n        message\n    });\n    if (result[0]) {\n        throw result[0];\n    } else {\n        return result[1];\n    }\n}\n/**\n * Mask a value, returning only the subset of properties defined by a struct.\n */ function mask(value, struct, message) {\n    const result = validate(value, struct, {\n        coerce: true,\n        mask: true,\n        message\n    });\n    if (result[0]) {\n        throw result[0];\n    } else {\n        return result[1];\n    }\n}\n/**\n * Check if a value passes a struct.\n */ function is(value, struct) {\n    const result = validate(value, struct);\n    return !result[0];\n}\n/**\n * Validate a value against a struct, returning an error if invalid, or the\n * value (with potential coercion) if valid.\n */ function validate(value, struct, options = {}) {\n    const tuples = run(value, struct, options);\n    const tuple = shiftIterator(tuples);\n    if (tuple[0]) {\n        const error = new StructError(tuple[0], function*() {\n            for (const t of tuples){\n                if (t[0]) {\n                    yield t[0];\n                }\n            }\n        });\n        return [\n            error,\n            undefined\n        ];\n    } else {\n        const v = tuple[1];\n        return [\n            undefined,\n            v\n        ];\n    }\n}\nfunction assign(...Structs) {\n    const isType = Structs[0].type === \"type\";\n    const schemas = Structs.map((s)=>s.schema);\n    const schema = Object.assign({}, ...schemas);\n    return isType ? type(schema) : object(schema);\n}\n/**\n * Define a new struct type with a custom validation function.\n */ function define(name, validator) {\n    return new Struct({\n        type: name,\n        schema: null,\n        validator\n    });\n}\n/**\n * Create a new struct based on an existing struct, but the value is allowed to\n * be `undefined`. `log` will be called if the value is not `undefined`.\n */ function deprecated(struct, log) {\n    return new Struct({\n        ...struct,\n        refiner: (value, ctx)=>value === undefined || struct.refiner(value, ctx),\n        validator (value, ctx) {\n            if (value === undefined) {\n                return true;\n            } else {\n                log(value, ctx);\n                return struct.validator(value, ctx);\n            }\n        }\n    });\n}\n/**\n * Create a struct with dynamic validation logic.\n *\n * The callback will receive the value currently being validated, and must\n * return a struct object to validate it with. This can be useful to model\n * validation logic that changes based on its input.\n */ function dynamic(fn) {\n    return new Struct({\n        type: \"dynamic\",\n        schema: null,\n        *entries (value, ctx) {\n            const struct = fn(value, ctx);\n            yield* struct.entries(value, ctx);\n        },\n        validator (value, ctx) {\n            const struct = fn(value, ctx);\n            return struct.validator(value, ctx);\n        },\n        coercer (value, ctx) {\n            const struct = fn(value, ctx);\n            return struct.coercer(value, ctx);\n        },\n        refiner (value, ctx) {\n            const struct = fn(value, ctx);\n            return struct.refiner(value, ctx);\n        }\n    });\n}\n/**\n * Create a struct with lazily evaluated validation logic.\n *\n * The first time validation is run with the struct, the callback will be called\n * and must return a struct object to use. This is useful for cases where you\n * want to have self-referential structs for nested data structures to avoid a\n * circular definition problem.\n */ function lazy(fn) {\n    let struct;\n    return new Struct({\n        type: \"lazy\",\n        schema: null,\n        *entries (value, ctx) {\n            struct ?? (struct = fn());\n            yield* struct.entries(value, ctx);\n        },\n        validator (value, ctx) {\n            struct ?? (struct = fn());\n            return struct.validator(value, ctx);\n        },\n        coercer (value, ctx) {\n            struct ?? (struct = fn());\n            return struct.coercer(value, ctx);\n        },\n        refiner (value, ctx) {\n            struct ?? (struct = fn());\n            return struct.refiner(value, ctx);\n        }\n    });\n}\n/**\n * Create a new struct based on an existing object struct, but excluding\n * specific properties.\n *\n * Like TypeScript's `Omit` utility.\n */ function omit(struct, keys) {\n    const { schema } = struct;\n    const subschema = {\n        ...schema\n    };\n    for (const key of keys){\n        delete subschema[key];\n    }\n    switch(struct.type){\n        case \"type\":\n            return type(subschema);\n        default:\n            return object(subschema);\n    }\n}\n/**\n * Create a new struct based on an existing object struct, but with all of its\n * properties allowed to be `undefined`.\n *\n * Like TypeScript's `Partial` utility.\n */ function partial(struct) {\n    const isStruct = struct instanceof Struct;\n    const schema = isStruct ? {\n        ...struct.schema\n    } : {\n        ...struct\n    };\n    for(const key in schema){\n        schema[key] = optional(schema[key]);\n    }\n    if (isStruct && struct.type === \"type\") {\n        return type(schema);\n    }\n    return object(schema);\n}\n/**\n * Create a new struct based on an existing object struct, but only including\n * specific properties.\n *\n * Like TypeScript's `Pick` utility.\n */ function pick(struct, keys) {\n    const { schema } = struct;\n    const subschema = {};\n    for (const key of keys){\n        subschema[key] = schema[key];\n    }\n    switch(struct.type){\n        case \"type\":\n            return type(subschema);\n        default:\n            return object(subschema);\n    }\n}\n/**\n * Define a new struct type with a custom validation function.\n *\n * @deprecated This function has been renamed to `define`.\n */ function struct(name, validator) {\n    console.warn(\"superstruct@0.11 - The `struct` helper has been renamed to `define`.\");\n    return define(name, validator);\n}\n/**\n * Ensure that any value passes validation.\n */ function any() {\n    return define(\"any\", ()=>true);\n}\nfunction array(Element) {\n    return new Struct({\n        type: \"array\",\n        schema: Element,\n        *entries (value) {\n            if (Element && Array.isArray(value)) {\n                for (const [i, v] of value.entries()){\n                    yield [\n                        i,\n                        v,\n                        Element\n                    ];\n                }\n            }\n        },\n        coercer (value) {\n            return Array.isArray(value) ? value.slice() : value;\n        },\n        validator (value) {\n            return Array.isArray(value) || `Expected an array value, but received: ${print(value)}`;\n        }\n    });\n}\n/**\n * Ensure that a value is a bigint.\n */ function bigint() {\n    return define(\"bigint\", (value)=>{\n        return typeof value === \"bigint\";\n    });\n}\n/**\n * Ensure that a value is a boolean.\n */ function boolean() {\n    return define(\"boolean\", (value)=>{\n        return typeof value === \"boolean\";\n    });\n}\n/**\n * Ensure that a value is a valid `Date`.\n *\n * Note: this also ensures that the value is *not* an invalid `Date` object,\n * which can occur when parsing a date fails but still returns a `Date`.\n */ function date() {\n    return define(\"date\", (value)=>{\n        return value instanceof Date && !isNaN(value.getTime()) || `Expected a valid \\`Date\\` object, but received: ${print(value)}`;\n    });\n}\nfunction enums(values) {\n    const schema = {};\n    const description = values.map((v)=>print(v)).join();\n    for (const key of values){\n        schema[key] = key;\n    }\n    return new Struct({\n        type: \"enums\",\n        schema,\n        validator (value) {\n            return values.includes(value) || `Expected one of \\`${description}\\`, but received: ${print(value)}`;\n        }\n    });\n}\n/**\n * Ensure that a value is a function.\n */ function func() {\n    return define(\"func\", (value)=>{\n        return typeof value === \"function\" || `Expected a function, but received: ${print(value)}`;\n    });\n}\n/**\n * Ensure that a value is an instance of a specific class.\n */ function instance(Class) {\n    return define(\"instance\", (value)=>{\n        return value instanceof Class || `Expected a \\`${Class.name}\\` instance, but received: ${print(value)}`;\n    });\n}\n/**\n * Ensure that a value is an integer.\n */ function integer() {\n    return define(\"integer\", (value)=>{\n        return typeof value === \"number\" && !isNaN(value) && Number.isInteger(value) || `Expected an integer, but received: ${print(value)}`;\n    });\n}\n/**\n * Ensure that a value matches all of a set of types.\n */ function intersection(Structs) {\n    return new Struct({\n        type: \"intersection\",\n        schema: null,\n        *entries (value, ctx) {\n            for (const S of Structs){\n                yield* S.entries(value, ctx);\n            }\n        },\n        *validator (value, ctx) {\n            for (const S of Structs){\n                yield* S.validator(value, ctx);\n            }\n        },\n        *refiner (value, ctx) {\n            for (const S of Structs){\n                yield* S.refiner(value, ctx);\n            }\n        }\n    });\n}\nfunction literal(constant) {\n    const description = print(constant);\n    const t = typeof constant;\n    return new Struct({\n        type: \"literal\",\n        schema: t === \"string\" || t === \"number\" || t === \"boolean\" ? constant : null,\n        validator (value) {\n            return value === constant || `Expected the literal \\`${description}\\`, but received: ${print(value)}`;\n        }\n    });\n}\nfunction map(Key, Value) {\n    return new Struct({\n        type: \"map\",\n        schema: null,\n        *entries (value) {\n            if (Key && Value && value instanceof Map) {\n                for (const [k, v] of value.entries()){\n                    yield [\n                        k,\n                        k,\n                        Key\n                    ];\n                    yield [\n                        k,\n                        v,\n                        Value\n                    ];\n                }\n            }\n        },\n        coercer (value) {\n            return value instanceof Map ? new Map(value) : value;\n        },\n        validator (value) {\n            return value instanceof Map || `Expected a \\`Map\\` object, but received: ${print(value)}`;\n        }\n    });\n}\n/**\n * Ensure that no value ever passes validation.\n */ function never() {\n    return define(\"never\", ()=>false);\n}\n/**\n * Augment an existing struct to allow `null` values.\n */ function nullable(struct) {\n    return new Struct({\n        ...struct,\n        validator: (value, ctx)=>value === null || struct.validator(value, ctx),\n        refiner: (value, ctx)=>value === null || struct.refiner(value, ctx)\n    });\n}\n/**\n * Ensure that a value is a number.\n */ function number() {\n    return define(\"number\", (value)=>{\n        return typeof value === \"number\" && !isNaN(value) || `Expected a number, but received: ${print(value)}`;\n    });\n}\nfunction object(schema) {\n    const knowns = schema ? Object.keys(schema) : [];\n    const Never = never();\n    return new Struct({\n        type: \"object\",\n        schema: schema ? schema : null,\n        *entries (value) {\n            if (schema && isObject(value)) {\n                const unknowns = new Set(Object.keys(value));\n                for (const key of knowns){\n                    unknowns.delete(key);\n                    yield [\n                        key,\n                        value[key],\n                        schema[key]\n                    ];\n                }\n                for (const key of unknowns){\n                    yield [\n                        key,\n                        value[key],\n                        Never\n                    ];\n                }\n            }\n        },\n        validator (value) {\n            return isObject(value) || `Expected an object, but received: ${print(value)}`;\n        },\n        coercer (value) {\n            return isObject(value) ? {\n                ...value\n            } : value;\n        }\n    });\n}\n/**\n * Augment a struct to allow `undefined` values.\n */ function optional(struct) {\n    return new Struct({\n        ...struct,\n        validator: (value, ctx)=>value === undefined || struct.validator(value, ctx),\n        refiner: (value, ctx)=>value === undefined || struct.refiner(value, ctx)\n    });\n}\n/**\n * Ensure that a value is an object with keys and values of specific types, but\n * without ensuring any specific shape of properties.\n *\n * Like TypeScript's `Record` utility.\n */ function record(Key, Value) {\n    return new Struct({\n        type: \"record\",\n        schema: null,\n        *entries (value) {\n            if (isObject(value)) {\n                for(const k in value){\n                    const v = value[k];\n                    yield [\n                        k,\n                        k,\n                        Key\n                    ];\n                    yield [\n                        k,\n                        v,\n                        Value\n                    ];\n                }\n            }\n        },\n        validator (value) {\n            return isObject(value) || `Expected an object, but received: ${print(value)}`;\n        }\n    });\n}\n/**\n * Ensure that a value is a `RegExp`.\n *\n * Note: this does not test the value against the regular expression! For that\n * you need to use the `pattern()` refinement.\n */ function regexp() {\n    return define(\"regexp\", (value)=>{\n        return value instanceof RegExp;\n    });\n}\nfunction set(Element) {\n    return new Struct({\n        type: \"set\",\n        schema: null,\n        *entries (value) {\n            if (Element && value instanceof Set) {\n                for (const v of value){\n                    yield [\n                        v,\n                        v,\n                        Element\n                    ];\n                }\n            }\n        },\n        coercer (value) {\n            return value instanceof Set ? new Set(value) : value;\n        },\n        validator (value) {\n            return value instanceof Set || `Expected a \\`Set\\` object, but received: ${print(value)}`;\n        }\n    });\n}\n/**\n * Ensure that a value is a string.\n */ function string() {\n    return define(\"string\", (value)=>{\n        return typeof value === \"string\" || `Expected a string, but received: ${print(value)}`;\n    });\n}\n/**\n * Ensure that a value is a tuple of a specific length, and that each of its\n * elements is of a specific type.\n */ function tuple(Structs) {\n    const Never = never();\n    return new Struct({\n        type: \"tuple\",\n        schema: null,\n        *entries (value) {\n            if (Array.isArray(value)) {\n                const length = Math.max(Structs.length, value.length);\n                for(let i = 0; i < length; i++){\n                    yield [\n                        i,\n                        value[i],\n                        Structs[i] || Never\n                    ];\n                }\n            }\n        },\n        validator (value) {\n            return Array.isArray(value) || `Expected an array, but received: ${print(value)}`;\n        }\n    });\n}\n/**\n * Ensure that a value has a set of known properties of specific types.\n *\n * Note: Unrecognized properties are allowed and untouched. This is similar to\n * how TypeScript's structural typing works.\n */ function type(schema) {\n    const keys = Object.keys(schema);\n    return new Struct({\n        type: \"type\",\n        schema,\n        *entries (value) {\n            if (isObject(value)) {\n                for (const k of keys){\n                    yield [\n                        k,\n                        value[k],\n                        schema[k]\n                    ];\n                }\n            }\n        },\n        validator (value) {\n            return isObject(value) || `Expected an object, but received: ${print(value)}`;\n        },\n        coercer (value) {\n            return isObject(value) ? {\n                ...value\n            } : value;\n        }\n    });\n}\n/**\n * Ensure that a value matches one of a set of types.\n */ function union(Structs) {\n    const description = Structs.map((s)=>s.type).join(\" | \");\n    return new Struct({\n        type: \"union\",\n        schema: null,\n        coercer (value) {\n            for (const S of Structs){\n                const [error, coerced] = S.validate(value, {\n                    coerce: true\n                });\n                if (!error) {\n                    return coerced;\n                }\n            }\n            return value;\n        },\n        validator (value, ctx) {\n            const failures = [];\n            for (const S of Structs){\n                const [...tuples] = run(value, S, ctx);\n                const [first] = tuples;\n                if (!first[0]) {\n                    return [];\n                } else {\n                    for (const [failure] of tuples){\n                        if (failure) {\n                            failures.push(failure);\n                        }\n                    }\n                }\n            }\n            return [\n                `Expected the value to satisfy a union of \\`${description}\\`, but received: ${print(value)}`,\n                ...failures\n            ];\n        }\n    });\n}\n/**\n * Ensure that any value passes validation, without widening its type to `any`.\n */ function unknown() {\n    return define(\"unknown\", ()=>true);\n}\n/**\n * Augment a `Struct` to add an additional coercion step to its input.\n *\n * This allows you to transform input data before validating it, to increase the\n * likelihood that it passes validationâ€”for example for default values, parsing\n * different formats, etc.\n *\n * Note: You must use `create(value, Struct)` on the value to have the coercion\n * take effect! Using simply `assert()` or `is()` will not use coercion.\n */ function coerce(struct, condition, coercer) {\n    return new Struct({\n        ...struct,\n        coercer: (value, ctx)=>{\n            return is(value, condition) ? struct.coercer(coercer(value, ctx), ctx) : struct.coercer(value, ctx);\n        }\n    });\n}\n/**\n * Augment a struct to replace `undefined` values with a default.\n *\n * Note: You must use `create(value, Struct)` on the value to have the coercion\n * take effect! Using simply `assert()` or `is()` will not use coercion.\n */ function defaulted(struct, fallback, options = {}) {\n    return coerce(struct, unknown(), (x)=>{\n        const f = typeof fallback === \"function\" ? fallback() : fallback;\n        if (x === undefined) {\n            return f;\n        }\n        if (!options.strict && isPlainObject(x) && isPlainObject(f)) {\n            const ret = {\n                ...x\n            };\n            let changed = false;\n            for(const key in f){\n                if (ret[key] === undefined) {\n                    ret[key] = f[key];\n                    changed = true;\n                }\n            }\n            if (changed) {\n                return ret;\n            }\n        }\n        return x;\n    });\n}\n/**\n * Augment a struct to trim string inputs.\n *\n * Note: You must use `create(value, Struct)` on the value to have the coercion\n * take effect! Using simply `assert()` or `is()` will not use coercion.\n */ function trimmed(struct) {\n    return coerce(struct, string(), (x)=>x.trim());\n}\n/**\n * Ensure that a string, array, map, or set is empty.\n */ function empty(struct) {\n    return refine(struct, \"empty\", (value)=>{\n        const size = getSize(value);\n        return size === 0 || `Expected an empty ${struct.type} but received one with a size of \\`${size}\\``;\n    });\n}\nfunction getSize(value) {\n    if (value instanceof Map || value instanceof Set) {\n        return value.size;\n    } else {\n        return value.length;\n    }\n}\n/**\n * Ensure that a number or date is below a threshold.\n */ function max(struct, threshold, options = {}) {\n    const { exclusive } = options;\n    return refine(struct, \"max\", (value)=>{\n        return exclusive ? value < threshold : value <= threshold || `Expected a ${struct.type} less than ${exclusive ? \"\" : \"or equal to \"}${threshold} but received \\`${value}\\``;\n    });\n}\n/**\n * Ensure that a number or date is above a threshold.\n */ function min(struct, threshold, options = {}) {\n    const { exclusive } = options;\n    return refine(struct, \"min\", (value)=>{\n        return exclusive ? value > threshold : value >= threshold || `Expected a ${struct.type} greater than ${exclusive ? \"\" : \"or equal to \"}${threshold} but received \\`${value}\\``;\n    });\n}\n/**\n * Ensure that a string, array, map or set is not empty.\n */ function nonempty(struct) {\n    return refine(struct, \"nonempty\", (value)=>{\n        const size = getSize(value);\n        return size > 0 || `Expected a nonempty ${struct.type} but received an empty one`;\n    });\n}\n/**\n * Ensure that a string matches a regular expression.\n */ function pattern(struct, regexp) {\n    return refine(struct, \"pattern\", (value)=>{\n        return regexp.test(value) || `Expected a ${struct.type} matching \\`/${regexp.source}/\\` but received \"${value}\"`;\n    });\n}\n/**\n * Ensure that a string, array, number, date, map, or set has a size (or length, or time) between `min` and `max`.\n */ function size(struct, min, max = min) {\n    const expected = `Expected a ${struct.type}`;\n    const of = min === max ? `of \\`${min}\\`` : `between \\`${min}\\` and \\`${max}\\``;\n    return refine(struct, \"size\", (value)=>{\n        if (typeof value === \"number\" || value instanceof Date) {\n            return min <= value && value <= max || `${expected} ${of} but received \\`${value}\\``;\n        } else if (value instanceof Map || value instanceof Set) {\n            const { size } = value;\n            return min <= size && size <= max || `${expected} with a size ${of} but received one with a size of \\`${size}\\``;\n        } else {\n            const { length } = value;\n            return min <= length && length <= max || `${expected} with a length ${of} but received one with a length of \\`${length}\\``;\n        }\n    });\n}\n/**\n * Augment a `Struct` to add an additional refinement to the validation.\n *\n * The refiner function is guaranteed to receive a value of the struct's type,\n * because the struct's existing validation will already have passed. This\n * allows you to layer additional validation on top of existing structs.\n */ function refine(struct, name, refiner) {\n    return new Struct({\n        ...struct,\n        *refiner (value, ctx) {\n            yield* struct.refiner(value, ctx);\n            const result = refiner(value, ctx);\n            const failures = toFailures(result, ctx, struct, value);\n            for (const failure of failures){\n                yield {\n                    ...failure,\n                    refinement: name\n                };\n            }\n        }\n    });\n}\n //# sourceMappingURL=index.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL3N1cGVyc3RydWN0L2Rpc3QvaW5kZXgubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBOztDQUVDLEdBQ0Q7Ozs7Ozs7Q0FPQyxHQUNELE1BQU1BLG9CQUFvQkM7SUFDdEJDLFlBQVlDLE9BQU8sRUFBRUMsUUFBUSxDQUFFO1FBQzNCLElBQUlDO1FBQ0osTUFBTSxFQUFFQyxPQUFPLEVBQUVDLFdBQVcsRUFBRSxHQUFHQyxNQUFNLEdBQUdMO1FBQzFDLE1BQU0sRUFBRU0sSUFBSSxFQUFFLEdBQUdOO1FBQ2pCLE1BQU1PLE1BQU1ELEtBQUtFLE1BQU0sS0FBSyxJQUFJTCxVQUFVLENBQUMsU0FBUyxFQUFFRyxLQUFLRyxJQUFJLENBQUMsS0FBSyxJQUFJLEVBQUVOLFFBQVEsQ0FBQztRQUNwRixLQUFLLENBQUNDLGVBQWVHO1FBQ3JCLElBQUlILGVBQWUsTUFDZixJQUFJLENBQUNNLEtBQUssR0FBR0g7UUFDakJJLE9BQU9DLE1BQU0sQ0FBQyxJQUFJLEVBQUVQO1FBQ3BCLElBQUksQ0FBQ1EsSUFBSSxHQUFHLElBQUksQ0FBQ2QsV0FBVyxDQUFDYyxJQUFJO1FBQ2pDLElBQUksQ0FBQ1osUUFBUSxHQUFHO1lBQ1osT0FBUUMsVUFBV0EsQ0FBQUEsU0FBUztnQkFBQ0Y7bUJBQVlDO2FBQVc7UUFDeEQ7SUFDSjtBQUNKO0FBRUE7O0NBRUMsR0FDRCxTQUFTYSxXQUFXQyxDQUFDO0lBQ2pCLE9BQU9DLFNBQVNELE1BQU0sT0FBT0EsQ0FBQyxDQUFDRSxPQUFPQyxRQUFRLENBQUMsS0FBSztBQUN4RDtBQUNBOztDQUVDLEdBQ0QsU0FBU0YsU0FBU0QsQ0FBQztJQUNmLE9BQU8sT0FBT0EsTUFBTSxZQUFZQSxLQUFLO0FBQ3pDO0FBQ0E7O0NBRUMsR0FDRCxTQUFTSSxjQUFjSixDQUFDO0lBQ3BCLElBQUlKLE9BQU9TLFNBQVMsQ0FBQ0MsUUFB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QztRQUNKO0lBQ0o7QUFDSjtBQUU2WixDQUM3WixrQ0FBa0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL3N1cGVyc3RydWN0L2Rpc3QvaW5kZXgubWpzPzc2ZmIiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBBIGBTdHJ1Y3RGYWlsdXJlYCByZXByZXNlbnRzIGEgc2luZ2xlIHNwZWNpZmljIGZhaWx1cmUgaW4gdmFsaWRhdGlvbi5cbiAqL1xuLyoqXG4gKiBgU3RydWN0RXJyb3JgIG9iamVjdHMgYXJlIHRocm93biAob3IgcmV0dXJuZWQpIHdoZW4gdmFsaWRhdGlvbiBmYWlscy5cbiAqXG4gKiBWYWxpZGF0aW9uIGxvZ2ljIGlzIGRlc2lnbiB0byBleGl0IGVhcmx5IGZvciBtYXhpbXVtIHBlcmZvcm1hbmNlLiBUaGUgZXJyb3JcbiAqIHJlcHJlc2VudHMgdGhlIGZpcnN0IGVycm9yIGVuY291bnRlcmVkIGR1cmluZyB2YWxpZGF0aW9uLiBGb3IgbW9yZSBkZXRhaWwsXG4gKiB0aGUgYGVycm9yLmZhaWx1cmVzYCBwcm9wZXJ0eSBpcyBhIGdlbmVyYXRvciBmdW5jdGlvbiB0aGF0IGNhbiBiZSBydW4gdG9cbiAqIGNvbnRpbnVlIHZhbGlkYXRpb24gYW5kIHJlY2VpdmUgYWxsIHRoZSBmYWlsdXJlcyBpbiB0aGUgZGF0YS5cbiAqL1xuY2xhc3MgU3RydWN0RXJyb3IgZXh0ZW5kcyBUeXBlRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKGZhaWx1cmUsIGZhaWx1cmVzKSB7XG4gICAgICAgIGxldCBjYWNoZWQ7XG4gICAgICAgIGNvbnN0IHsgbWVzc2FnZSwgZXhwbGFuYXRpb24sIC4uLnJlc3QgfSA9IGZhaWx1cmU7XG4gICAgICAgIGNvbnN0IHsgcGF0aCB9ID0gZmFpbHVyZTtcbiAgICAgICAgY29uc3QgbXNnID0gcGF0aC5sZW5ndGggPT09IDAgPyBtZXNzYWdlIDogYEF0IHBhdGg6ICR7cGF0aC5qb2luKCcuJyl9IC0tICR7bWVzc2FnZX1gO1xuICAgICAgICBzdXBlcihleHBsYW5hdGlvbiA/PyBtc2cpO1xuICAgICAgICBpZiAoZXhwbGFuYXRpb24gIT0gbnVsbClcbiAgICAgICAgICAgIHRoaXMuY2F1c2UgPSBtc2c7XG4gICAgICAgIE9iamVjdC5hc3NpZ24odGhpcywgcmVzdCk7XG4gICAgICAgIHRoaXMubmFtZSA9IHRoaXMuY29uc3RydWN0b3IubmFtZTtcbiAgICAgICAgdGhpcy5mYWlsdXJlcyA9ICgpID0+IHtcbiAgICAgICAgICAgIHJldHVybiAoY2FjaGVkID8/IChjYWNoZWQgPSBbZmFpbHVyZSwgLi4uZmFpbHVyZXMoKV0pKTtcbiAgICAgICAgfTtcbiAgICB9XG59XG5cbi8qKlxuICogQ2hlY2sgaWYgYSB2YWx1ZSBpcyBhbiBpdGVyYXRvci5cbiAqL1xuZnVuY3Rpb24gaXNJdGVyYWJsZSh4KSB7XG4gICAgcmV0dXJuIGlzT2JqZWN0KHgpICYmIHR5cGVvZiB4W1N5bWJvbC5pdGVyYXRvcl0gPT09ICdmdW5jdGlvbic7XG59XG4vKipcbiAqIENoZWNrIGlmIGEgdmFsdWUgaXMgYSBwbGFpbiBvYmplY3QuXG4gKi9cbmZ1bmN0aW9uIGlzT2JqZWN0KHgpIHtcbiAgICByZXR1cm4gdHlwZW9mIHggPT09ICdvYmplY3QnICYmIHggIT0gbnVsbDtcbn1cbi8qKlxuICogQ2hlY2sgaWYgYSB2YWx1ZSBpcyBhIHBsYWluIG9iamVjdC5cbiAqL1xuZnVuY3Rpb24gaXNQbGFpbk9iamVjdCh4KSB7XG4gICAgaWYgKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh4KSAhPT0gJ1tvYmplY3QgT2JqZWN0XScpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBjb25zdCBwcm90b3R5cGUgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YoeCk7XG4gICAgcmV0dXJuIHByb3RvdHlwZSA9PT0gbnVsbCB8fCBwcm90b3R5cGUgPT09IE9iamVjdC5wcm90b3R5cGU7XG59XG4vKipcbiAqIFJldHVybiBhIHZhbHVlIGFzIGEgcHJpbnRhYmxlIHN0cmluZy5cbiAqL1xuZnVuY3Rpb24gcHJpbnQodmFsdWUpIHtcbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3ltYm9sJykge1xuICAgICAgICByZXR1cm4gdmFsdWUudG9TdHJpbmcoKTtcbiAgICB9XG4gICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycgPyBKU09OLnN0cmluZ2lmeSh2YWx1ZSkgOiBgJHt2YWx1ZX1gO1xufVxuLyoqXG4gKiBTaGlmdHMgKHJlbW92ZXMgYW5kIHJldHVybnMpIHRoZSBmaXJzdCB2YWx1ZSBmcm9tIHRoZSBgaW5wdXRgIGl0ZXJhdG9yLlxuICogTGlrZSBgQXJyYXkucHJvdG90eXBlLnNoaWZ0KClgIGJ1dCBmb3IgYW4gYEl0ZXJhdG9yYC5cbiAqL1xuZnVuY3Rpb24gc2hpZnRJdGVyYXRvcihpbnB1dCkge1xuICAgIGNvbnN0IHsgZG9uZSwgdmFsdWUgfSA9IGlucHV0Lm5leHQoKTtcbiAgICByZXR1cm4gZG9uZSA/IHVuZGVmaW5lZCA6IHZhbHVlO1xufVxuLyoqXG4gKiBDb252ZXJ0IGEgc2luZ2xlIHZhbGlkYXRpb24gcmVzdWx0IHRvIGEgZmFpbHVyZS5cbiAqL1xuZnVuY3Rpb24gdG9GYWlsdXJlKHJlc3VsdCwgY29udGV4dCwgc3RydWN0LCB2YWx1ZSkge1xuICAgIGlmIChyZXN1bHQgPT09IHRydWUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBlbHNlIGlmIChyZXN1bHQgPT09IGZhbHNlKSB7XG4gICAgICAgIHJlc3VsdCA9IHt9O1xuICAgIH1cbiAgICBlbHNlIGlmICh0eXBlb2YgcmVzdWx0ID09PSAnc3RyaW5nJykge1xuICAgICAgICByZXN1bHQgPSB7IG1lc3NhZ2U6IHJlc3VsdCB9O1xuICAgIH1cbiAgICBjb25zdCB7IHBhdGgsIGJyYW5jaCB9ID0gY29udGV4dDtcbiAgICBjb25zdCB7IHR5cGUgfSA9IHN0cnVjdDtcbiAgICBjb25zdCB7IHJlZmluZW1lbnQsIG1lc3NhZ2UgPSBgRXhwZWN0ZWQgYSB2YWx1ZSBvZiB0eXBlIFxcYCR7dHlwZX1cXGAke3JlZmluZW1lbnQgPyBgIHdpdGggcmVmaW5lbWVudCBcXGAke3JlZmluZW1lbnR9XFxgYCA6ICcnfSwgYnV0IHJlY2VpdmVkOiBcXGAke3ByaW50KHZhbHVlKX1cXGBgLCB9ID0gcmVzdWx0O1xuICAgIHJldHVybiB7XG4gICAgICAgIHZhbHVlLFxuICAgICAgICB0eXBlLFxuICAgICAgICByZWZpbmVtZW50LFxuICAgICAgICBrZXk6IHBhdGhbcGF0aC5sZW5ndGggLSAxXSxcbiAgICAgICAgcGF0aCxcbiAgICAgICAgYnJhbmNoLFxuICAgICAgICAuLi5yZXN1bHQsXG4gICAgICAgIG1lc3NhZ2UsXG4gICAgfTtcbn1cbi8qKlxuICogQ29udmVydCBhIHZhbGlkYXRpb24gcmVzdWx0IHRvIGFuIGl0ZXJhYmxlIG9mIGZhaWx1cmVzLlxuICovXG5mdW5jdGlvbiogdG9GYWlsdXJlcyhyZXN1bHQsIGNvbnRleHQsIHN0cnVjdCwgdmFsdWUpIHtcbiAgICBpZiAoIWlzSXRlcmFibGUocmVzdWx0KSkge1xuICAgICAgICByZXN1bHQgPSBbcmVzdWx0XTtcbiAgICB9XG4gICAgZm9yIChjb25zdCByIG9mIHJlc3VsdCkge1xuICAgICAgICBjb25zdCBmYWlsdXJlID0gdG9GYWlsdXJlKHIsIGNvbnRleHQsIHN0cnVjdCwgdmFsdWUpO1xuICAgICAgICBpZiAoZmFpbHVyZSkge1xuICAgICAgICAgICAgeWllbGQgZmFpbHVyZTtcbiAgICAgICAgfVxuICAgIH1cbn1cbi8qKlxuICogQ2hlY2sgYSB2YWx1ZSBhZ2FpbnN0IGEgc3RydWN0LCB0cmF2ZXJzaW5nIGRlZXBseSBpbnRvIG5lc3RlZCB2YWx1ZXMsIGFuZFxuICogcmV0dXJuaW5nIGFuIGl0ZXJhdG9yIG9mIGZhaWx1cmVzIG9yIHN1Y2Nlc3MuXG4gKi9cbmZ1bmN0aW9uKiBydW4odmFsdWUsIHN0cnVjdCwgb3B0aW9ucyA9IHt9KSB7XG4gICAgY29uc3QgeyBwYXRoID0gW10sIGJyYW5jaCA9IFt2YWx1ZV0sIGNvZXJjZSA9IGZhbHNlLCBtYXNrID0gZmFsc2UgfSA9IG9wdGlvbnM7XG4gICAgY29uc3QgY3R4ID0geyBwYXRoLCBicmFuY2ggfTtcbiAgICBpZiAoY29lcmNlKSB7XG4gICAgICAgIHZhbHVlID0gc3RydWN0LmNvZXJjZXIodmFsdWUsIGN0eCk7XG4gICAgICAgIGlmIChtYXNrICYmXG4gICAgICAgICAgICBzdHJ1Y3QudHlwZSAhPT0gJ3R5cGUnICYmXG4gICAgICAgICAgICBpc09iamVjdChzdHJ1Y3Quc2NoZW1hKSAmJlxuICAgICAgICAgICAgaXNPYmplY3QodmFsdWUpICYmXG4gICAgICAgICAgICAhQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgICAgIGZvciAoY29uc3Qga2V5IGluIHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgaWYgKHN0cnVjdC5zY2hlbWFba2V5XSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSB2YWx1ZVtrZXldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBsZXQgc3RhdHVzID0gJ3ZhbGlkJztcbiAgICBmb3IgKGNvbnN0IGZhaWx1cmUgb2Ygc3RydWN0LnZhbGlkYXRvcih2YWx1ZSwgY3R4KSkge1xuICAgICAgICBmYWlsdXJlLmV4cGxhbmF0aW9uID0gb3B0aW9ucy5tZXNzYWdlO1xuICAgICAgICBzdGF0dXMgPSAnbm90X3ZhbGlkJztcbiAgICAgICAgeWllbGQgW2ZhaWx1cmUsIHVuZGVmaW5lZF07XG4gICAgfVxuICAgIGZvciAobGV0IFtrLCB2LCBzXSBvZiBzdHJ1Y3QuZW50cmllcyh2YWx1ZSwgY3R4KSkge1xuICAgICAgICBjb25zdCB0cyA9IHJ1bih2LCBzLCB7XG4gICAgICAgICAgICBwYXRoOiBrID09PSB1bmRlZmluZWQgPyBwYXRoIDogWy4uLnBhdGgsIGtdLFxuICAgICAgICAgICAgYnJhbmNoOiBrID09PSB1bmRlZmluZWQgPyBicmFuY2ggOiBbLi4uYnJhbmNoLCB2XSxcbiAgICAgICAgICAgIGNvZXJjZSxcbiAgICAgICAgICAgIG1hc2ssXG4gICAgICAgICAgICBtZXNzYWdlOiBvcHRpb25zLm1lc3NhZ2UsXG4gICAgICAgIH0pO1xuICAgICAgICBmb3IgKGNvbnN0IHQgb2YgdHMpIHtcbiAgICAgICAgICAgIGlmICh0WzBdKSB7XG4gICAgICAgICAgICAgICAgc3RhdHVzID0gdFswXS5yZWZpbmVtZW50ICE9IG51bGwgPyAnbm90X3JlZmluZWQnIDogJ25vdF92YWxpZCc7XG4gICAgICAgICAgICAgICAgeWllbGQgW3RbMF0sIHVuZGVmaW5lZF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjb2VyY2UpIHtcbiAgICAgICAgICAgICAgICB2ID0gdFsxXTtcbiAgICAgICAgICAgICAgICBpZiAoayA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gdjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAodmFsdWUgaW5zdGFuY2VvZiBNYXApIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUuc2V0KGssIHYpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICh2YWx1ZSBpbnN0YW5jZW9mIFNldCkge1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZS5hZGQodik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGlzT2JqZWN0KHZhbHVlKSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAodiAhPT0gdW5kZWZpbmVkIHx8IGsgaW4gdmFsdWUpXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZVtrXSA9IHY7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChzdGF0dXMgIT09ICdub3RfdmFsaWQnKSB7XG4gICAgICAgIGZvciAoY29uc3QgZmFpbHVyZSBvZiBzdHJ1Y3QucmVmaW5lcih2YWx1ZSwgY3R4KSkge1xuICAgICAgICAgICAgZmFpbHVyZS5leHBsYW5hdGlvbiA9IG9wdGlvbnMubWVzc2FnZTtcbiAgICAgICAgICAgIHN0YXR1cyA9ICdub3RfcmVmaW5lZCc7XG4gICAgICAgICAgICB5aWVsZCBbZmFpbHVyZSwgdW5kZWZpbmVkXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoc3RhdHVzID09PSAndmFsaWQnKSB7XG4gICAgICAgIHlpZWxkIFt1bmRlZmluZWQsIHZhbHVlXTtcbiAgICB9XG59XG5cbi8qKlxuICogYFN0cnVjdGAgb2JqZWN0cyBlbmNhcHN1bGF0ZSB0aGUgdmFsaWRhdGlvbiBsb2dpYyBmb3IgYSBzcGVjaWZpYyB0eXBlIG9mXG4gKiB2YWx1ZXMuIE9uY2UgY29uc3RydWN0ZWQsIHlvdSB1c2UgdGhlIGBhc3NlcnRgLCBgaXNgIG9yIGB2YWxpZGF0ZWAgaGVscGVycyB0b1xuICogdmFsaWRhdGUgdW5rbm93biBpbnB1dCBkYXRhIGFnYWluc3QgdGhlIHN0cnVjdC5cbiAqL1xuY2xhc3MgU3RydWN0IHtcbiAgICBjb25zdHJ1Y3Rvcihwcm9wcykge1xuICAgICAgICBjb25zdCB7IHR5cGUsIHNjaGVtYSwgdmFsaWRhdG9yLCByZWZpbmVyLCBjb2VyY2VyID0gKHZhbHVlKSA9PiB2YWx1ZSwgZW50cmllcyA9IGZ1bmN0aW9uKiAoKSB7IH0sIH0gPSBwcm9wcztcbiAgICAgICAgdGhpcy50eXBlID0gdHlwZTtcbiAgICAgICAgdGhpcy5zY2hlbWEgPSBzY2hlbWE7XG4gICAgICAgIHRoaXMuZW50cmllcyA9IGVudHJpZXM7XG4gICAgICAgIHRoaXMuY29lcmNlciA9IGNvZXJjZXI7XG4gICAgICAgIGlmICh2YWxpZGF0b3IpIHtcbiAgICAgICAgICAgIHRoaXMudmFsaWRhdG9yID0gKHZhbHVlLCBjb250ZXh0KSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gdmFsaWRhdG9yKHZhbHVlLCBjb250ZXh0KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdG9GYWlsdXJlcyhyZXN1bHQsIGNvbnRleHQsIHRoaXMsIHZhbHVlKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnZhbGlkYXRvciA9ICgpID0+IFtdO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyZWZpbmVyKSB7XG4gICAgICAgICAgICB0aGlzLnJlZmluZXIgPSAodmFsdWUsIGNvbnRleHQpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCByZXN1bHQgPSByZWZpbmVyKHZhbHVlLCBjb250ZXh0KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdG9GYWlsdXJlcyhyZXN1bHQsIGNvbnRleHQsIHRoaXMsIHZhbHVlKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnJlZmluZXIgPSAoKSA9PiBbXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBBc3NlcnQgdGhhdCBhIHZhbHVlIHBhc3NlcyB0aGUgc3RydWN0J3MgdmFsaWRhdGlvbiwgdGhyb3dpbmcgaWYgaXQgZG9lc24ndC5cbiAgICAgKi9cbiAgICBhc3NlcnQodmFsdWUsIG1lc3NhZ2UpIHtcbiAgICAgICAgcmV0dXJuIGFzc2VydCh2YWx1ZSwgdGhpcywgbWVzc2FnZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhIHZhbHVlIHdpdGggdGhlIHN0cnVjdCdzIGNvZXJjaW9uIGxvZ2ljLCB0aGVuIHZhbGlkYXRlIGl0LlxuICAgICAqL1xuICAgIGNyZWF0ZSh2YWx1ZSwgbWVzc2FnZSkge1xuICAgICAgICByZXR1cm4gY3JlYXRlKHZhbHVlLCB0aGlzLCBtZXNzYWdlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2hlY2sgaWYgYSB2YWx1ZSBwYXNzZXMgdGhlIHN0cnVjdCdzIHZhbGlkYXRpb24uXG4gICAgICovXG4gICAgaXModmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIGlzKHZhbHVlLCB0aGlzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTWFzayBhIHZhbHVlLCBjb2VyY2luZyBhbmQgdmFsaWRhdGluZyBpdCwgYnV0IHJldHVybmluZyBvbmx5IHRoZSBzdWJzZXQgb2ZcbiAgICAgKiBwcm9wZXJ0aWVzIGRlZmluZWQgYnkgdGhlIHN0cnVjdCdzIHNjaGVtYS5cbiAgICAgKi9cbiAgICBtYXNrKHZhbHVlLCBtZXNzYWdlKSB7XG4gICAgICAgIHJldHVybiBtYXNrKHZhbHVlLCB0aGlzLCBtZXNzYWdlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVmFsaWRhdGUgYSB2YWx1ZSB3aXRoIHRoZSBzdHJ1Y3QncyB2YWxpZGF0aW9uIGxvZ2ljLCByZXR1cm5pbmcgYSB0dXBsZVxuICAgICAqIHJlcHJlc2VudGluZyB0aGUgcmVzdWx0LlxuICAgICAqXG4gICAgICogWW91IG1heSBvcHRpb25hbGx5IHBhc3MgYHRydWVgIGZvciB0aGUgYHdpdGhDb2VyY2lvbmAgYXJndW1lbnQgdG8gY29lcmNlXG4gICAgICogdGhlIHZhbHVlIGJlZm9yZSBhdHRlbXB0aW5nIHRvIHZhbGlkYXRlIGl0LiBJZiB5b3UgZG8sIHRoZSByZXN1bHQgd2lsbFxuICAgICAqIGNvbnRhaW4gdGhlIGNvZXJjZWQgcmVzdWx0IHdoZW4gc3VjY2Vzc2Z1bC5cbiAgICAgKi9cbiAgICB2YWxpZGF0ZSh2YWx1ZSwgb3B0aW9ucyA9IHt9KSB7XG4gICAgICAgIHJldHVybiB2YWxpZGF0ZSh2YWx1ZSwgdGhpcywgb3B0aW9ucyk7XG4gICAgfVxufVxuLyoqXG4gKiBBc3NlcnQgdGhhdCBhIHZhbHVlIHBhc3NlcyBhIHN0cnVjdCwgdGhyb3dpbmcgaWYgaXQgZG9lc24ndC5cbiAqL1xuZnVuY3Rpb24gYXNzZXJ0KHZhbHVlLCBzdHJ1Y3QsIG1lc3NhZ2UpIHtcbiAgICBjb25zdCByZXN1bHQgPSB2YWxpZGF0ZSh2YWx1ZSwgc3RydWN0LCB7IG1lc3NhZ2UgfSk7XG4gICAgaWYgKHJlc3VsdFswXSkge1xuICAgICAgICB0aHJvdyByZXN1bHRbMF07XG4gICAgfVxufVxuLyoqXG4gKiBDcmVhdGUgYSB2YWx1ZSB3aXRoIHRoZSBjb2VyY2lvbiBsb2dpYyBvZiBzdHJ1Y3QgYW5kIHZhbGlkYXRlIGl0LlxuICovXG5mdW5jdGlvbiBjcmVhdGUodmFsdWUsIHN0cnVjdCwgbWVzc2FnZSkge1xuICAgIGNvbnN0IHJlc3VsdCA9IHZhbGlkYXRlKHZhbHVlLCBzdHJ1Y3QsIHsgY29lcmNlOiB0cnVlLCBtZXNzYWdlIH0pO1xuICAgIGlmIChyZXN1bHRbMF0pIHtcbiAgICAgICAgdGhyb3cgcmVzdWx0WzBdO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHJlc3VsdFsxXTtcbiAgICB9XG59XG4vKipcbiAqIE1hc2sgYSB2YWx1ZSwgcmV0dXJuaW5nIG9ubHkgdGhlIHN1YnNldCBvZiBwcm9wZXJ0aWVzIGRlZmluZWQgYnkgYSBzdHJ1Y3QuXG4gKi9cbmZ1bmN0aW9uIG1hc2sodmFsdWUsIHN0cnVjdCwgbWVzc2FnZSkge1xuICAgIGNvbnN0IHJlc3VsdCA9IHZhbGlkYXRlKHZhbHVlLCBzdHJ1Y3QsIHsgY29lcmNlOiB0cnVlLCBtYXNrOiB0cnVlLCBtZXNzYWdlIH0pO1xuICAgIGlmIChyZXN1bHRbMF0pIHtcbiAgICAgICAgdGhyb3cgcmVzdWx0WzBdO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHJlc3VsdFsxXTtcbiAgICB9XG59XG4vKipcbiAqIENoZWNrIGlmIGEgdmFsdWUgcGFzc2VzIGEgc3RydWN0LlxuICovXG5mdW5jdGlvbiBpcyh2YWx1ZSwgc3RydWN0KSB7XG4gICAgY29uc3QgcmVzdWx0ID0gdmFsaWRhdGUodmFsdWUsIHN0cnVjdCk7XG4gICAgcmV0dXJuICFyZXN1bHRbMF07XG59XG4vKipcbiAqIFZhbGlkYXRlIGEgdmFsdWUgYWdhaW5zdCBhIHN0cnVjdCwgcmV0dXJuaW5nIGFuIGVycm9yIGlmIGludmFsaWQsIG9yIHRoZVxuICogdmFsdWUgKHdpdGggcG90ZW50aWFsIGNvZXJjaW9uKSBpZiB2YWxpZC5cbiAqL1xuZnVuY3Rpb24gdmFsaWRhdGUodmFsdWUsIHN0cnVjdCwgb3B0aW9ucyA9IHt9KSB7XG4gICAgY29uc3QgdHVwbGVzID0gcnVuKHZhbHVlLCBzdHJ1Y3QsIG9wdGlvbnMpO1xuICAgIGNvbnN0IHR1cGxlID0gc2hpZnRJdGVyYXRvcih0dXBsZXMpO1xuICAgIGlmICh0dXBsZVswXSkge1xuICAgICAgICBjb25zdCBlcnJvciA9IG5ldyBTdHJ1Y3RFcnJvcih0dXBsZVswXSwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgdCBvZiB0dXBsZXMpIHtcbiAgICAgICAgICAgICAgICBpZiAodFswXSkge1xuICAgICAgICAgICAgICAgICAgICB5aWVsZCB0WzBdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBbZXJyb3IsIHVuZGVmaW5lZF07XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBjb25zdCB2ID0gdHVwbGVbMV07XG4gICAgICAgIHJldHVybiBbdW5kZWZpbmVkLCB2XTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGFzc2lnbiguLi5TdHJ1Y3RzKSB7XG4gICAgY29uc3QgaXNUeXBlID0gU3RydWN0c1swXS50eXBlID09PSAndHlwZSc7XG4gICAgY29uc3Qgc2NoZW1hcyA9IFN0cnVjdHMubWFwKChzKSA9PiBzLnNjaGVtYSk7XG4gICAgY29uc3Qgc2NoZW1hID0gT2JqZWN0LmFzc2lnbih7fSwgLi4uc2NoZW1hcyk7XG4gICAgcmV0dXJuIGlzVHlwZSA/IHR5cGUoc2NoZW1hKSA6IG9iamVjdChzY2hlbWEpO1xufVxuLyoqXG4gKiBEZWZpbmUgYSBuZXcgc3RydWN0IHR5cGUgd2l0aCBhIGN1c3RvbSB2YWxpZGF0aW9uIGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBkZWZpbmUobmFtZSwgdmFsaWRhdG9yKSB7XG4gICAgcmV0dXJuIG5ldyBTdHJ1Y3QoeyB0eXBlOiBuYW1lLCBzY2hlbWE6IG51bGwsIHZhbGlkYXRvciB9KTtcbn1cbi8qKlxuICogQ3JlYXRlIGEgbmV3IHN0cnVjdCBiYXNlZCBvbiBhbiBleGlzdGluZyBzdHJ1Y3QsIGJ1dCB0aGUgdmFsdWUgaXMgYWxsb3dlZCB0b1xuICogYmUgYHVuZGVmaW5lZGAuIGBsb2dgIHdpbGwgYmUgY2FsbGVkIGlmIHRoZSB2YWx1ZSBpcyBub3QgYHVuZGVmaW5lZGAuXG4gKi9cbmZ1bmN0aW9uIGRlcHJlY2F0ZWQoc3RydWN0LCBsb2cpIHtcbiAgICByZXR1cm4gbmV3IFN0cnVjdCh7XG4gICAgICAgIC4uLnN0cnVjdCxcbiAgICAgICAgcmVmaW5lcjogKHZhbHVlLCBjdHgpID0+IHZhbHVlID09PSB1bmRlZmluZWQgfHwgc3RydWN0LnJlZmluZXIodmFsdWUsIGN0eCksXG4gICAgICAgIHZhbGlkYXRvcih2YWx1ZSwgY3R4KSB7XG4gICAgICAgICAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbG9nKHZhbHVlLCBjdHgpO1xuICAgICAgICAgICAgICAgIHJldHVybiBzdHJ1Y3QudmFsaWRhdG9yKHZhbHVlLCBjdHgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgIH0pO1xufVxuLyoqXG4gKiBDcmVhdGUgYSBzdHJ1Y3Qgd2l0aCBkeW5hbWljIHZhbGlkYXRpb24gbG9naWMuXG4gKlxuICogVGhlIGNhbGxiYWNrIHdpbGwgcmVjZWl2ZSB0aGUgdmFsdWUgY3VycmVudGx5IGJlaW5nIHZhbGlkYXRlZCwgYW5kIG11c3RcbiAqIHJldHVybiBhIHN0cnVjdCBvYmplY3QgdG8gdmFsaWRhdGUgaXQgd2l0aC4gVGhpcyBjYW4gYmUgdXNlZnVsIHRvIG1vZGVsXG4gKiB2YWxpZGF0aW9uIGxvZ2ljIHRoYXQgY2hhbmdlcyBiYXNlZCBvbiBpdHMgaW5wdXQuXG4gKi9cbmZ1bmN0aW9uIGR5bmFtaWMoZm4pIHtcbiAgICByZXR1cm4gbmV3IFN0cnVjdCh7XG4gICAgICAgIHR5cGU6ICdkeW5hbWljJyxcbiAgICAgICAgc2NoZW1hOiBudWxsLFxuICAgICAgICAqZW50cmllcyh2YWx1ZSwgY3R4KSB7XG4gICAgICAgICAgICBjb25zdCBzdHJ1Y3QgPSBmbih2YWx1ZSwgY3R4KTtcbiAgICAgICAgICAgIHlpZWxkKiBzdHJ1Y3QuZW50cmllcyh2YWx1ZSwgY3R4KTtcbiAgICAgICAgfSxcbiAgICAgICAgdmFsaWRhdG9yKHZhbHVlLCBjdHgpIHtcbiAgICAgICAgICAgIGNvbnN0IHN0cnVjdCA9IGZuKHZhbHVlLCBjdHgpO1xuICAgICAgICAgICAgcmV0dXJuIHN0cnVjdC52YWxpZGF0b3IodmFsdWUsIGN0eCk7XG4gICAgICAgIH0sXG4gICAgICAgIGNvZXJjZXIodmFsdWUsIGN0eCkge1xuICAgICAgICAgICAgY29uc3Qgc3RydWN0ID0gZm4odmFsdWUsIGN0eCk7XG4gICAgICAgICAgICByZXR1cm4gc3RydWN0LmNvZXJjZXIodmFsdWUsIGN0eCk7XG4gICAgICAgIH0sXG4gICAgICAgIHJlZmluZXIodmFsdWUsIGN0eCkge1xuICAgICAgICAgICAgY29uc3Qgc3RydWN0ID0gZm4odmFsdWUsIGN0eCk7XG4gICAgICAgICAgICByZXR1cm4gc3RydWN0LnJlZmluZXIodmFsdWUsIGN0eCk7XG4gICAgICAgIH0sXG4gICAgfSk7XG59XG4vKipcbiAqIENyZWF0ZSBhIHN0cnVjdCB3aXRoIGxhemlseSBldmFsdWF0ZWQgdmFsaWRhdGlvbiBsb2dpYy5cbiAqXG4gKiBUaGUgZmlyc3QgdGltZSB2YWxpZGF0aW9uIGlzIHJ1biB3aXRoIHRoZSBzdHJ1Y3QsIHRoZSBjYWxsYmFjayB3aWxsIGJlIGNhbGxlZFxuICogYW5kIG11c3QgcmV0dXJuIGEgc3RydWN0IG9iamVjdCB0byB1c2UuIFRoaXMgaXMgdXNlZnVsIGZvciBjYXNlcyB3aGVyZSB5b3VcbiAqIHdhbnQgdG8gaGF2ZSBzZWxmLXJlZmVyZW50aWFsIHN0cnVjdHMgZm9yIG5lc3RlZCBkYXRhIHN0cnVjdHVyZXMgdG8gYXZvaWQgYVxuICogY2lyY3VsYXIgZGVmaW5pdGlvbiBwcm9ibGVtLlxuICovXG5mdW5jdGlvbiBsYXp5KGZuKSB7XG4gICAgbGV0IHN0cnVjdDtcbiAgICByZXR1cm4gbmV3IFN0cnVjdCh7XG4gICAgICAgIHR5cGU6ICdsYXp5JyxcbiAgICAgICAgc2NoZW1hOiBudWxsLFxuICAgICAgICAqZW50cmllcyh2YWx1ZSwgY3R4KSB7XG4gICAgICAgICAgICBzdHJ1Y3QgPz8gKHN0cnVjdCA9IGZuKCkpO1xuICAgICAgICAgICAgeWllbGQqIHN0cnVjdC5lbnRyaWVzKHZhbHVlLCBjdHgpO1xuICAgICAgICB9LFxuICAgICAgICB2YWxpZGF0b3IodmFsdWUsIGN0eCkge1xuICAgICAgICAgICAgc3RydWN0ID8/IChzdHJ1Y3QgPSBmbigpKTtcbiAgICAgICAgICAgIHJldHVybiBzdHJ1Y3QudmFsaWRhdG9yKHZhbHVlLCBjdHgpO1xuICAgICAgICB9LFxuICAgICAgICBjb2VyY2VyKHZhbHVlLCBjdHgpIHtcbiAgICAgICAgICAgIHN0cnVjdCA/PyAoc3RydWN0ID0gZm4oKSk7XG4gICAgICAgICAgICByZXR1cm4gc3RydWN0LmNvZXJjZXIodmFsdWUsIGN0eCk7XG4gICAgICAgIH0sXG4gICAgICAgIHJlZmluZXIodmFsdWUsIGN0eCkge1xuICAgICAgICAgICAgc3RydWN0ID8/IChzdHJ1Y3QgPSBmbigpKTtcbiAgICAgICAgICAgIHJldHVybiBzdHJ1Y3QucmVmaW5lcih2YWx1ZSwgY3R4KTtcbiAgICAgICAgfSxcbiAgICB9KTtcbn1cbi8qKlxuICogQ3JlYXRlIGEgbmV3IHN0cnVjdCBiYXNlZCBvbiBhbiBleGlzdGluZyBvYmplY3Qgc3RydWN0LCBidXQgZXhjbHVkaW5nXG4gKiBzcGVjaWZpYyBwcm9wZXJ0aWVzLlxuICpcbiAqIExpa2UgVHlwZVNjcmlwdCdzIGBPbWl0YCB1dGlsaXR5LlxuICovXG5mdW5jdGlvbiBvbWl0KHN0cnVjdCwga2V5cykge1xuICAgIGNvbnN0IHsgc2NoZW1hIH0gPSBzdHJ1Y3Q7XG4gICAgY29uc3Qgc3Vic2NoZW1hID0geyAuLi5zY2hlbWEgfTtcbiAgICBmb3IgKGNvbnN0IGtleSBvZiBrZXlzKSB7XG4gICAgICAgIGRlbGV0ZSBzdWJzY2hlbWFba2V5XTtcbiAgICB9XG4gICAgc3dpdGNoIChzdHJ1Y3QudHlwZSkge1xuICAgICAgICBjYXNlICd0eXBlJzpcbiAgICAgICAgICAgIHJldHVybiB0eXBlKHN1YnNjaGVtYSk7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZXR1cm4gb2JqZWN0KHN1YnNjaGVtYSk7XG4gICAgfVxufVxuLyoqXG4gKiBDcmVhdGUgYSBuZXcgc3RydWN0IGJhc2VkIG9uIGFuIGV4aXN0aW5nIG9iamVjdCBzdHJ1Y3QsIGJ1dCB3aXRoIGFsbCBvZiBpdHNcbiAqIHByb3BlcnRpZXMgYWxsb3dlZCB0byBiZSBgdW5kZWZpbmVkYC5cbiAqXG4gKiBMaWtlIFR5cGVTY3JpcHQncyBgUGFydGlhbGAgdXRpbGl0eS5cbiAqL1xuZnVuY3Rpb24gcGFydGlhbChzdHJ1Y3QpIHtcbiAgICBjb25zdCBpc1N0cnVjdCA9IHN0cnVjdCBpbnN0YW5jZW9mIFN0cnVjdDtcbiAgICBjb25zdCBzY2hlbWEgPSBpc1N0cnVjdCA/IHsgLi4uc3RydWN0LnNjaGVtYSB9IDogeyAuLi5zdHJ1Y3QgfTtcbiAgICBmb3IgKGNvbnN0IGtleSBpbiBzY2hlbWEpIHtcbiAgICAgICAgc2NoZW1hW2tleV0gPSBvcHRpb25hbChzY2hlbWFba2V5XSk7XG4gICAgfVxuICAgIGlmIChpc1N0cnVjdCAmJiBzdHJ1Y3QudHlwZSA9PT0gJ3R5cGUnKSB7XG4gICAgICAgIHJldHVybiB0eXBlKHNjaGVtYSk7XG4gICAgfVxuICAgIHJldHVybiBvYmplY3Qoc2NoZW1hKTtcbn1cbi8qKlxuICogQ3JlYXRlIGEgbmV3IHN0cnVjdCBiYXNlZCBvbiBhbiBleGlzdGluZyBvYmplY3Qgc3RydWN0LCBidXQgb25seSBpbmNsdWRpbmdcbiAqIHNwZWNpZmljIHByb3BlcnRpZXMuXG4gKlxuICogTGlrZSBUeXBlU2NyaXB0J3MgYFBpY2tgIHV0aWxpdHkuXG4gKi9cbmZ1bmN0aW9uIHBpY2soc3RydWN0LCBrZXlzKSB7XG4gICAgY29uc3QgeyBzY2hlbWEgfSA9IHN0cnVjdDtcbiAgICBjb25zdCBzdWJzY2hlbWEgPSB7fTtcbiAgICBmb3IgKGNvbnN0IGtleSBvZiBrZXlzKSB7XG4gICAgICAgIHN1YnNjaGVtYVtrZXldID0gc2NoZW1hW2tleV07XG4gICAgfVxuICAgIHN3aXRjaCAoc3RydWN0LnR5cGUpIHtcbiAgICAgICAgY2FzZSAndHlwZSc6XG4gICAgICAgICAgICByZXR1cm4gdHlwZShzdWJzY2hlbWEpO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgcmV0dXJuIG9iamVjdChzdWJzY2hlbWEpO1xuICAgIH1cbn1cbi8qKlxuICogRGVmaW5lIGEgbmV3IHN0cnVjdCB0eXBlIHdpdGggYSBjdXN0b20gdmFsaWRhdGlvbiBmdW5jdGlvbi5cbiAqXG4gKiBAZGVwcmVjYXRlZCBUaGlzIGZ1bmN0aW9uIGhhcyBiZWVuIHJlbmFtZWQgdG8gYGRlZmluZWAuXG4gKi9cbmZ1bmN0aW9uIHN0cnVjdChuYW1lLCB2YWxpZGF0b3IpIHtcbiAgICBjb25zb2xlLndhcm4oJ3N1cGVyc3RydWN0QDAuMTEgLSBUaGUgYHN0cnVjdGAgaGVscGVyIGhhcyBiZWVuIHJlbmFtZWQgdG8gYGRlZmluZWAuJyk7XG4gICAgcmV0dXJuIGRlZmluZShuYW1lLCB2YWxpZGF0b3IpO1xufVxuXG4vKipcbiAqIEVuc3VyZSB0aGF0IGFueSB2YWx1ZSBwYXNzZXMgdmFsaWRhdGlvbi5cbiAqL1xuZnVuY3Rpb24gYW55KCkge1xuICAgIHJldHVybiBkZWZpbmUoJ2FueScsICgpID0+IHRydWUpO1xufVxuZnVuY3Rpb24gYXJyYXkoRWxlbWVudCkge1xuICAgIHJldHVybiBuZXcgU3RydWN0KHtcbiAgICAgICAgdHlwZTogJ2FycmF5JyxcbiAgICAgICAgc2NoZW1hOiBFbGVtZW50LFxuICAgICAgICAqZW50cmllcyh2YWx1ZSkge1xuICAgICAgICAgICAgaWYgKEVsZW1lbnQgJiYgQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IFtpLCB2XSBvZiB2YWx1ZS5lbnRyaWVzKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgeWllbGQgW2ksIHYsIEVsZW1lbnRdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgY29lcmNlcih2YWx1ZSkge1xuICAgICAgICAgICAgcmV0dXJuIEFycmF5LmlzQXJyYXkodmFsdWUpID8gdmFsdWUuc2xpY2UoKSA6IHZhbHVlO1xuICAgICAgICB9LFxuICAgICAgICB2YWxpZGF0b3IodmFsdWUpIHtcbiAgICAgICAgICAgIHJldHVybiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkgfHxcbiAgICAgICAgICAgICAgICBgRXhwZWN0ZWQgYW4gYXJyYXkgdmFsdWUsIGJ1dCByZWNlaXZlZDogJHtwcmludCh2YWx1ZSl9YCk7XG4gICAgICAgIH0sXG4gICAgfSk7XG59XG4vKipcbiAqIEVuc3VyZSB0aGF0IGEgdmFsdWUgaXMgYSBiaWdpbnQuXG4gKi9cbmZ1bmN0aW9uIGJpZ2ludCgpIHtcbiAgICByZXR1cm4gZGVmaW5lKCdiaWdpbnQnLCAodmFsdWUpID0+IHtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ2JpZ2ludCc7XG4gICAgfSk7XG59XG4vKipcbiAqIEVuc3VyZSB0aGF0IGEgdmFsdWUgaXMgYSBib29sZWFuLlxuICovXG5mdW5jdGlvbiBib29sZWFuKCkge1xuICAgIHJldHVybiBkZWZpbmUoJ2Jvb2xlYW4nLCAodmFsdWUpID0+IHtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ2Jvb2xlYW4nO1xuICAgIH0pO1xufVxuLyoqXG4gKiBFbnN1cmUgdGhhdCBhIHZhbHVlIGlzIGEgdmFsaWQgYERhdGVgLlxuICpcbiAqIE5vdGU6IHRoaXMgYWxzbyBlbnN1cmVzIHRoYXQgdGhlIHZhbHVlIGlzICpub3QqIGFuIGludmFsaWQgYERhdGVgIG9iamVjdCxcbiAqIHdoaWNoIGNhbiBvY2N1ciB3aGVuIHBhcnNpbmcgYSBkYXRlIGZhaWxzIGJ1dCBzdGlsbCByZXR1cm5zIGEgYERhdGVgLlxuICovXG5mdW5jdGlvbiBkYXRlKCkge1xuICAgIHJldHVybiBkZWZpbmUoJ2RhdGUnLCAodmFsdWUpID0+IHtcbiAgICAgICAgcmV0dXJuICgodmFsdWUgaW5zdGFuY2VvZiBEYXRlICYmICFpc05hTih2YWx1ZS5nZXRUaW1lKCkpKSB8fFxuICAgICAgICAgICAgYEV4cGVjdGVkIGEgdmFsaWQgXFxgRGF0ZVxcYCBvYmplY3QsIGJ1dCByZWNlaXZlZDogJHtwcmludCh2YWx1ZSl9YCk7XG4gICAgfSk7XG59XG5mdW5jdGlvbiBlbnVtcyh2YWx1ZXMpIHtcbiAgICBjb25zdCBzY2hlbWEgPSB7fTtcbiAgICBjb25zdCBkZXNjcmlwdGlvbiA9IHZhbHVlcy5tYXAoKHYpID0+IHByaW50KHYpKS5qb2luKCk7XG4gICAgZm9yIChjb25zdCBrZXkgb2YgdmFsdWVzKSB7XG4gICAgICAgIHNjaGVtYVtrZXldID0ga2V5O1xuICAgIH1cbiAgICByZXR1cm4gbmV3IFN0cnVjdCh7XG4gICAgICAgIHR5cGU6ICdlbnVtcycsXG4gICAgICAgIHNjaGVtYSxcbiAgICAgICAgdmFsaWRhdG9yKHZhbHVlKSB7XG4gICAgICAgICAgICByZXR1cm4gKHZhbHVlcy5pbmNsdWRlcyh2YWx1ZSkgfHxcbiAgICAgICAgICAgICAgICBgRXhwZWN0ZWQgb25lIG9mIFxcYCR7ZGVzY3JpcHRpb259XFxgLCBidXQgcmVjZWl2ZWQ6ICR7cHJpbnQodmFsdWUpfWApO1xuICAgICAgICB9LFxuICAgIH0pO1xufVxuLyoqXG4gKiBFbnN1cmUgdGhhdCBhIHZhbHVlIGlzIGEgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIGZ1bmMoKSB7XG4gICAgcmV0dXJuIGRlZmluZSgnZnVuYycsICh2YWx1ZSkgPT4ge1xuICAgICAgICByZXR1cm4gKHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJyB8fFxuICAgICAgICAgICAgYEV4cGVjdGVkIGEgZnVuY3Rpb24sIGJ1dCByZWNlaXZlZDogJHtwcmludCh2YWx1ZSl9YCk7XG4gICAgfSk7XG59XG4vKipcbiAqIEVuc3VyZSB0aGF0IGEgdmFsdWUgaXMgYW4gaW5zdGFuY2Ugb2YgYSBzcGVjaWZpYyBjbGFzcy5cbiAqL1xuZnVuY3Rpb24gaW5zdGFuY2UoQ2xhc3MpIHtcbiAgICByZXR1cm4gZGVmaW5lKCdpbnN0YW5jZScsICh2YWx1ZSkgPT4ge1xuICAgICAgICByZXR1cm4gKHZhbHVlIGluc3RhbmNlb2YgQ2xhc3MgfHxcbiAgICAgICAgICAgIGBFeHBlY3RlZCBhIFxcYCR7Q2xhc3MubmFtZX1cXGAgaW5zdGFuY2UsIGJ1dCByZWNlaXZlZDogJHtwcmludCh2YWx1ZSl9YCk7XG4gICAgfSk7XG59XG4vKipcbiAqIEVuc3VyZSB0aGF0IGEgdmFsdWUgaXMgYW4gaW50ZWdlci5cbiAqL1xuZnVuY3Rpb24gaW50ZWdlcigpIHtcbiAgICByZXR1cm4gZGVmaW5lKCdpbnRlZ2VyJywgKHZhbHVlKSA9PiB7XG4gICAgICAgIHJldHVybiAoKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicgJiYgIWlzTmFOKHZhbHVlKSAmJiBOdW1iZXIuaXNJbnRlZ2VyKHZhbHVlKSkgfHxcbiAgICAgICAgICAgIGBFeHBlY3RlZCBhbiBpbnRlZ2VyLCBidXQgcmVjZWl2ZWQ6ICR7cHJpbnQodmFsdWUpfWApO1xuICAgIH0pO1xufVxuLyoqXG4gKiBFbnN1cmUgdGhhdCBhIHZhbHVlIG1hdGNoZXMgYWxsIG9mIGEgc2V0IG9mIHR5cGVzLlxuICovXG5mdW5jdGlvbiBpbnRlcnNlY3Rpb24oU3RydWN0cykge1xuICAgIHJldHVybiBuZXcgU3RydWN0KHtcbiAgICAgICAgdHlwZTogJ2ludGVyc2VjdGlvbicsXG4gICAgICAgIHNjaGVtYTogbnVsbCxcbiAgICAgICAgKmVudHJpZXModmFsdWUsIGN0eCkge1xuICAgICAgICAgICAgZm9yIChjb25zdCBTIG9mIFN0cnVjdHMpIHtcbiAgICAgICAgICAgICAgICB5aWVsZCogUy5lbnRyaWVzKHZhbHVlLCBjdHgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICAqdmFsaWRhdG9yKHZhbHVlLCBjdHgpIHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgUyBvZiBTdHJ1Y3RzKSB7XG4gICAgICAgICAgICAgICAgeWllbGQqIFMudmFsaWRhdG9yKHZhbHVlLCBjdHgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICAqcmVmaW5lcih2YWx1ZSwgY3R4KSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IFMgb2YgU3RydWN0cykge1xuICAgICAgICAgICAgICAgIHlpZWxkKiBTLnJlZmluZXIodmFsdWUsIGN0eCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgfSk7XG59XG5mdW5jdGlvbiBsaXRlcmFsKGNvbnN0YW50KSB7XG4gICAgY29uc3QgZGVzY3JpcHRpb24gPSBwcmludChjb25zdGFudCk7XG4gICAgY29uc3QgdCA9IHR5cGVvZiBjb25zdGFudDtcbiAgICByZXR1cm4gbmV3IFN0cnVjdCh7XG4gICAgICAgIHR5cGU6ICdsaXRlcmFsJyxcbiAgICAgICAgc2NoZW1hOiB0ID09PSAnc3RyaW5nJyB8fCB0ID09PSAnbnVtYmVyJyB8fCB0ID09PSAnYm9vbGVhbicgPyBjb25zdGFudCA6IG51bGwsXG4gICAgICAgIHZhbGlkYXRvcih2YWx1ZSkge1xuICAgICAgICAgICAgcmV0dXJuICh2YWx1ZSA9PT0gY29uc3RhbnQgfHxcbiAgICAgICAgICAgICAgICBgRXhwZWN0ZWQgdGhlIGxpdGVyYWwgXFxgJHtkZXNjcmlwdGlvbn1cXGAsIGJ1dCByZWNlaXZlZDogJHtwcmludCh2YWx1ZSl9YCk7XG4gICAgICAgIH0sXG4gICAgfSk7XG59XG5mdW5jdGlvbiBtYXAoS2V5LCBWYWx1ZSkge1xuICAgIHJldHVybiBuZXcgU3RydWN0KHtcbiAgICAgICAgdHlwZTogJ21hcCcsXG4gICAgICAgIHNjaGVtYTogbnVsbCxcbiAgICAgICAgKmVudHJpZXModmFsdWUpIHtcbiAgICAgICAgICAgIGlmIChLZXkgJiYgVmFsdWUgJiYgdmFsdWUgaW5zdGFuY2VvZiBNYXApIHtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IFtrLCB2XSBvZiB2YWx1ZS5lbnRyaWVzKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgeWllbGQgW2ssIGssIEtleV07XG4gICAgICAgICAgICAgICAgICAgIHlpZWxkIFtrLCB2LCBWYWx1ZV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBjb2VyY2VyKHZhbHVlKSB7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBNYXAgPyBuZXcgTWFwKHZhbHVlKSA6IHZhbHVlO1xuICAgICAgICB9LFxuICAgICAgICB2YWxpZGF0b3IodmFsdWUpIHtcbiAgICAgICAgICAgIHJldHVybiAodmFsdWUgaW5zdGFuY2VvZiBNYXAgfHxcbiAgICAgICAgICAgICAgICBgRXhwZWN0ZWQgYSBcXGBNYXBcXGAgb2JqZWN0LCBidXQgcmVjZWl2ZWQ6ICR7cHJpbnQodmFsdWUpfWApO1xuICAgICAgICB9LFxuICAgIH0pO1xufVxuLyoqXG4gKiBFbnN1cmUgdGhhdCBubyB2YWx1ZSBldmVyIHBhc3NlcyB2YWxpZGF0aW9uLlxuICovXG5mdW5jdGlvbiBuZXZlcigpIHtcbiAgICByZXR1cm4gZGVmaW5lKCduZXZlcicsICgpID0+IGZhbHNlKTtcbn1cbi8qKlxuICogQXVnbWVudCBhbiBleGlzdGluZyBzdHJ1Y3QgdG8gYWxsb3cgYG51bGxgIHZhbHVlcy5cbiAqL1xuZnVuY3Rpb24gbnVsbGFibGUoc3RydWN0KSB7XG4gICAgcmV0dXJuIG5ldyBTdHJ1Y3Qoe1xuICAgICAgICAuLi5zdHJ1Y3QsXG4gICAgICAgIHZhbGlkYXRvcjogKHZhbHVlLCBjdHgpID0+IHZhbHVlID09PSBudWxsIHx8IHN0cnVjdC52YWxpZGF0b3IodmFsdWUsIGN0eCksXG4gICAgICAgIHJlZmluZXI6ICh2YWx1ZSwgY3R4KSA9PiB2YWx1ZSA9PT0gbnVsbCB8fCBzdHJ1Y3QucmVmaW5lcih2YWx1ZSwgY3R4KSxcbiAgICB9KTtcbn1cbi8qKlxuICogRW5zdXJlIHRoYXQgYSB2YWx1ZSBpcyBhIG51bWJlci5cbiAqL1xuZnVuY3Rpb24gbnVtYmVyKCkge1xuICAgIHJldHVybiBkZWZpbmUoJ251bWJlcicsICh2YWx1ZSkgPT4ge1xuICAgICAgICByZXR1cm4gKCh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInICYmICFpc05hTih2YWx1ZSkpIHx8XG4gICAgICAgICAgICBgRXhwZWN0ZWQgYSBudW1iZXIsIGJ1dCByZWNlaXZlZDogJHtwcmludCh2YWx1ZSl9YCk7XG4gICAgfSk7XG59XG5mdW5jdGlvbiBvYmplY3Qoc2NoZW1hKSB7XG4gICAgY29uc3Qga25vd25zID0gc2NoZW1hID8gT2JqZWN0LmtleXMoc2NoZW1hKSA6IFtdO1xuICAgIGNvbnN0IE5ldmVyID0gbmV2ZXIoKTtcbiAgICByZXR1cm4gbmV3IFN0cnVjdCh7XG4gICAgICAgIHR5cGU6ICdvYmplY3QnLFxuICAgICAgICBzY2hlbWE6IHNjaGVtYSA/IHNjaGVtYSA6IG51bGwsXG4gICAgICAgICplbnRyaWVzKHZhbHVlKSB7XG4gICAgICAgICAgICBpZiAoc2NoZW1hICYmIGlzT2JqZWN0KHZhbHVlKSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHVua25vd25zID0gbmV3IFNldChPYmplY3Qua2V5cyh2YWx1ZSkpO1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3Qga2V5IG9mIGtub3ducykge1xuICAgICAgICAgICAgICAgICAgICB1bmtub3ducy5kZWxldGUoa2V5KTtcbiAgICAgICAgICAgICAgICAgICAgeWllbGQgW2tleSwgdmFsdWVba2V5XSwgc2NoZW1hW2tleV1dO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGtleSBvZiB1bmtub3ducykge1xuICAgICAgICAgICAgICAgICAgICB5aWVsZCBba2V5LCB2YWx1ZVtrZXldLCBOZXZlcl07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB2YWxpZGF0b3IodmFsdWUpIHtcbiAgICAgICAgICAgIHJldHVybiAoaXNPYmplY3QodmFsdWUpIHx8IGBFeHBlY3RlZCBhbiBvYmplY3QsIGJ1dCByZWNlaXZlZDogJHtwcmludCh2YWx1ZSl9YCk7XG4gICAgICAgIH0sXG4gICAgICAgIGNvZXJjZXIodmFsdWUpIHtcbiAgICAgICAgICAgIHJldHVybiBpc09iamVjdCh2YWx1ZSkgPyB7IC4uLnZhbHVlIH0gOiB2YWx1ZTtcbiAgICAgICAgfSxcbiAgICB9KTtcbn1cbi8qKlxuICogQXVnbWVudCBhIHN0cnVjdCB0byBhbGxvdyBgdW5kZWZpbmVkYCB2YWx1ZXMuXG4gKi9cbmZ1bmN0aW9uIG9wdGlvbmFsKHN0cnVjdCkge1xuICAgIHJldHVybiBuZXcgU3RydWN0KHtcbiAgICAgICAgLi4uc3RydWN0LFxuICAgICAgICB2YWxpZGF0b3I6ICh2YWx1ZSwgY3R4KSA9PiB2YWx1ZSA9PT0gdW5kZWZpbmVkIHx8IHN0cnVjdC52YWxpZGF0b3IodmFsdWUsIGN0eCksXG4gICAgICAgIHJlZmluZXI6ICh2YWx1ZSwgY3R4KSA9PiB2YWx1ZSA9PT0gdW5kZWZpbmVkIHx8IHN0cnVjdC5yZWZpbmVyKHZhbHVlLCBjdHgpLFxuICAgIH0pO1xufVxuLyoqXG4gKiBFbnN1cmUgdGhhdCBhIHZhbHVlIGlzIGFuIG9iamVjdCB3aXRoIGtleXMgYW5kIHZhbHVlcyBvZiBzcGVjaWZpYyB0eXBlcywgYnV0XG4gKiB3aXRob3V0IGVuc3VyaW5nIGFueSBzcGVjaWZpYyBzaGFwZSBvZiBwcm9wZXJ0aWVzLlxuICpcbiAqIExpa2UgVHlwZVNjcmlwdCdzIGBSZWNvcmRgIHV0aWxpdHkuXG4gKi9cbmZ1bmN0aW9uIHJlY29yZChLZXksIFZhbHVlKSB7XG4gICAgcmV0dXJuIG5ldyBTdHJ1Y3Qoe1xuICAgICAgICB0eXBlOiAncmVjb3JkJyxcbiAgICAgICAgc2NoZW1hOiBudWxsLFxuICAgICAgICAqZW50cmllcyh2YWx1ZSkge1xuICAgICAgICAgICAgaWYgKGlzT2JqZWN0KHZhbHVlKSkge1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgayBpbiB2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB2ID0gdmFsdWVba107XG4gICAgICAgICAgICAgICAgICAgIHlpZWxkIFtrLCBrLCBLZXldO1xuICAgICAgICAgICAgICAgICAgICB5aWVsZCBbaywgdiwgVmFsdWVdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgdmFsaWRhdG9yKHZhbHVlKSB7XG4gICAgICAgICAgICByZXR1cm4gKGlzT2JqZWN0KHZhbHVlKSB8fCBgRXhwZWN0ZWQgYW4gb2JqZWN0LCBidXQgcmVjZWl2ZWQ6ICR7cHJpbnQodmFsdWUpfWApO1xuICAgICAgICB9LFxuICAgIH0pO1xufVxuLyoqXG4gKiBFbnN1cmUgdGhhdCBhIHZhbHVlIGlzIGEgYFJlZ0V4cGAuXG4gKlxuICogTm90ZTogdGhpcyBkb2VzIG5vdCB0ZXN0IHRoZSB2YWx1ZSBhZ2FpbnN0IHRoZSByZWd1bGFyIGV4cHJlc3Npb24hIEZvciB0aGF0XG4gKiB5b3UgbmVlZCB0byB1c2UgdGhlIGBwYXR0ZXJuKClgIHJlZmluZW1lbnQuXG4gKi9cbmZ1bmN0aW9uIHJlZ2V4cCgpIHtcbiAgICByZXR1cm4gZGVmaW5lKCdyZWdleHAnLCAodmFsdWUpID0+IHtcbiAgICAgICAgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgUmVnRXhwO1xuICAgIH0pO1xufVxuZnVuY3Rpb24gc2V0KEVsZW1lbnQpIHtcbiAgICByZXR1cm4gbmV3IFN0cnVjdCh7XG4gICAgICAgIHR5cGU6ICdzZXQnLFxuICAgICAgICBzY2hlbWE6IG51bGwsXG4gICAgICAgICplbnRyaWVzKHZhbHVlKSB7XG4gICAgICAgICAgICBpZiAoRWxlbWVudCAmJiB2YWx1ZSBpbnN0YW5jZW9mIFNldCkge1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgdiBvZiB2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICB5aWVsZCBbdiwgdiwgRWxlbWVudF07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBjb2VyY2VyKHZhbHVlKSB7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBTZXQgPyBuZXcgU2V0KHZhbHVlKSA6IHZhbHVlO1xuICAgICAgICB9LFxuICAgICAgICB2YWxpZGF0b3IodmFsdWUpIHtcbiAgICAgICAgICAgIHJldHVybiAodmFsdWUgaW5zdGFuY2VvZiBTZXQgfHxcbiAgICAgICAgICAgICAgICBgRXhwZWN0ZWQgYSBcXGBTZXRcXGAgb2JqZWN0LCBidXQgcmVjZWl2ZWQ6ICR7cHJpbnQodmFsdWUpfWApO1xuICAgICAgICB9LFxuICAgIH0pO1xufVxuLyoqXG4gKiBFbnN1cmUgdGhhdCBhIHZhbHVlIGlzIGEgc3RyaW5nLlxuICovXG5mdW5jdGlvbiBzdHJpbmcoKSB7XG4gICAgcmV0dXJuIGRlZmluZSgnc3RyaW5nJywgKHZhbHVlKSA9PiB7XG4gICAgICAgIHJldHVybiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJyB8fFxuICAgICAgICAgICAgYEV4cGVjdGVkIGEgc3RyaW5nLCBidXQgcmVjZWl2ZWQ6ICR7cHJpbnQodmFsdWUpfWApO1xuICAgIH0pO1xufVxuLyoqXG4gKiBFbnN1cmUgdGhhdCBhIHZhbHVlIGlzIGEgdHVwbGUgb2YgYSBzcGVjaWZpYyBsZW5ndGgsIGFuZCB0aGF0IGVhY2ggb2YgaXRzXG4gKiBlbGVtZW50cyBpcyBvZiBhIHNwZWNpZmljIHR5cGUuXG4gKi9cbmZ1bmN0aW9uIHR1cGxlKFN0cnVjdHMpIHtcbiAgICBjb25zdCBOZXZlciA9IG5ldmVyKCk7XG4gICAgcmV0dXJuIG5ldyBTdHJ1Y3Qoe1xuICAgICAgICB0eXBlOiAndHVwbGUnLFxuICAgICAgICBzY2hlbWE6IG51bGwsXG4gICAgICAgICplbnRyaWVzKHZhbHVlKSB7XG4gICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBsZW5ndGggPSBNYXRoLm1heChTdHJ1Y3RzLmxlbmd0aCwgdmFsdWUubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIHlpZWxkIFtpLCB2YWx1ZVtpXSwgU3RydWN0c1tpXSB8fCBOZXZlcl07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB2YWxpZGF0b3IodmFsdWUpIHtcbiAgICAgICAgICAgIHJldHVybiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkgfHxcbiAgICAgICAgICAgICAgICBgRXhwZWN0ZWQgYW4gYXJyYXksIGJ1dCByZWNlaXZlZDogJHtwcmludCh2YWx1ZSl9YCk7XG4gICAgICAgIH0sXG4gICAgfSk7XG59XG4vKipcbiAqIEVuc3VyZSB0aGF0IGEgdmFsdWUgaGFzIGEgc2V0IG9mIGtub3duIHByb3BlcnRpZXMgb2Ygc3BlY2lmaWMgdHlwZXMuXG4gKlxuICogTm90ZTogVW5yZWNvZ25pemVkIHByb3BlcnRpZXMgYXJlIGFsbG93ZWQgYW5kIHVudG91Y2hlZC4gVGhpcyBpcyBzaW1pbGFyIHRvXG4gKiBob3cgVHlwZVNjcmlwdCdzIHN0cnVjdHVyYWwgdHlwaW5nIHdvcmtzLlxuICovXG5mdW5jdGlvbiB0eXBlKHNjaGVtYSkge1xuICAgIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyhzY2hlbWEpO1xuICAgIHJldHVybiBuZXcgU3RydWN0KHtcbiAgICAgICAgdHlwZTogJ3R5cGUnLFxuICAgICAgICBzY2hlbWEsXG4gICAgICAgICplbnRyaWVzKHZhbHVlKSB7XG4gICAgICAgICAgICBpZiAoaXNPYmplY3QodmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBrIG9mIGtleXMpIHtcbiAgICAgICAgICAgICAgICAgICAgeWllbGQgW2ssIHZhbHVlW2tdLCBzY2hlbWFba11dO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgdmFsaWRhdG9yKHZhbHVlKSB7XG4gICAgICAgICAgICByZXR1cm4gKGlzT2JqZWN0KHZhbHVlKSB8fCBgRXhwZWN0ZWQgYW4gb2JqZWN0LCBidXQgcmVjZWl2ZWQ6ICR7cHJpbnQodmFsdWUpfWApO1xuICAgICAgICB9LFxuICAgICAgICBjb2VyY2VyKHZhbHVlKSB7XG4gICAgICAgICAgICByZXR1cm4gaXNPYmplY3QodmFsdWUpID8geyAuLi52YWx1ZSB9IDogdmFsdWU7XG4gICAgICAgIH0sXG4gICAgfSk7XG59XG4vKipcbiAqIEVuc3VyZSB0aGF0IGEgdmFsdWUgbWF0Y2hlcyBvbmUgb2YgYSBzZXQgb2YgdHlwZXMuXG4gKi9cbmZ1bmN0aW9uIHVuaW9uKFN0cnVjdHMpIHtcbiAgICBjb25zdCBkZXNjcmlwdGlvbiA9IFN0cnVjdHMubWFwKChzKSA9PiBzLnR5cGUpLmpvaW4oJyB8ICcpO1xuICAgIHJldHVybiBuZXcgU3RydWN0KHtcbiAgICAgICAgdHlwZTogJ3VuaW9uJyxcbiAgICAgICAgc2NoZW1hOiBudWxsLFxuICAgICAgICBjb2VyY2VyKHZhbHVlKSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IFMgb2YgU3RydWN0cykge1xuICAgICAgICAgICAgICAgIGNvbnN0IFtlcnJvciwgY29lcmNlZF0gPSBTLnZhbGlkYXRlKHZhbHVlLCB7IGNvZXJjZTogdHJ1ZSB9KTtcbiAgICAgICAgICAgICAgICBpZiAoIWVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjb2VyY2VkO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgfSxcbiAgICAgICAgdmFsaWRhdG9yKHZhbHVlLCBjdHgpIHtcbiAgICAgICAgICAgIGNvbnN0IGZhaWx1cmVzID0gW107XG4gICAgICAgICAgICBmb3IgKGNvbnN0IFMgb2YgU3RydWN0cykge1xuICAgICAgICAgICAgICAgIGNvbnN0IFsuLi50dXBsZXNdID0gcnVuKHZhbHVlLCBTLCBjdHgpO1xuICAgICAgICAgICAgICAgIGNvbnN0IFtmaXJzdF0gPSB0dXBsZXM7XG4gICAgICAgICAgICAgICAgaWYgKCFmaXJzdFswXSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IFtmYWlsdXJlXSBvZiB0dXBsZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChmYWlsdXJlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZmFpbHVyZXMucHVzaChmYWlsdXJlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgICAgYEV4cGVjdGVkIHRoZSB2YWx1ZSB0byBzYXRpc2Z5IGEgdW5pb24gb2YgXFxgJHtkZXNjcmlwdGlvbn1cXGAsIGJ1dCByZWNlaXZlZDogJHtwcmludCh2YWx1ZSl9YCxcbiAgICAgICAgICAgICAgICAuLi5mYWlsdXJlcyxcbiAgICAgICAgICAgIF07XG4gICAgICAgIH0sXG4gICAgfSk7XG59XG4vKipcbiAqIEVuc3VyZSB0aGF0IGFueSB2YWx1ZSBwYXNzZXMgdmFsaWRhdGlvbiwgd2l0aG91dCB3aWRlbmluZyBpdHMgdHlwZSB0byBgYW55YC5cbiAqL1xuZnVuY3Rpb24gdW5rbm93bigpIHtcbiAgICByZXR1cm4gZGVmaW5lKCd1bmtub3duJywgKCkgPT4gdHJ1ZSk7XG59XG5cbi8qKlxuICogQXVnbWVudCBhIGBTdHJ1Y3RgIHRvIGFkZCBhbiBhZGRpdGlvbmFsIGNvZXJjaW9uIHN0ZXAgdG8gaXRzIGlucHV0LlxuICpcbiAqIFRoaXMgYWxsb3dzIHlvdSB0byB0cmFuc2Zvcm0gaW5wdXQgZGF0YSBiZWZvcmUgdmFsaWRhdGluZyBpdCwgdG8gaW5jcmVhc2UgdGhlXG4gKiBsaWtlbGlob29kIHRoYXQgaXQgcGFzc2VzIHZhbGlkYXRpb27igJRmb3IgZXhhbXBsZSBmb3IgZGVmYXVsdCB2YWx1ZXMsIHBhcnNpbmdcbiAqIGRpZmZlcmVudCBmb3JtYXRzLCBldGMuXG4gKlxuICogTm90ZTogWW91IG11c3QgdXNlIGBjcmVhdGUodmFsdWUsIFN0cnVjdClgIG9uIHRoZSB2YWx1ZSB0byBoYXZlIHRoZSBjb2VyY2lvblxuICogdGFrZSBlZmZlY3QhIFVzaW5nIHNpbXBseSBgYXNzZXJ0KClgIG9yIGBpcygpYCB3aWxsIG5vdCB1c2UgY29lcmNpb24uXG4gKi9cbmZ1bmN0aW9uIGNvZXJjZShzdHJ1Y3QsIGNvbmRpdGlvbiwgY29lcmNlcikge1xuICAgIHJldHVybiBuZXcgU3RydWN0KHtcbiAgICAgICAgLi4uc3RydWN0LFxuICAgICAgICBjb2VyY2VyOiAodmFsdWUsIGN0eCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIGlzKHZhbHVlLCBjb25kaXRpb24pXG4gICAgICAgICAgICAgICAgPyBzdHJ1Y3QuY29lcmNlcihjb2VyY2VyKHZhbHVlLCBjdHgpLCBjdHgpXG4gICAgICAgICAgICAgICAgOiBzdHJ1Y3QuY29lcmNlcih2YWx1ZSwgY3R4KTtcbiAgICAgICAgfSxcbiAgICB9KTtcbn1cbi8qKlxuICogQXVnbWVudCBhIHN0cnVjdCB0byByZXBsYWNlIGB1bmRlZmluZWRgIHZhbHVlcyB3aXRoIGEgZGVmYXVsdC5cbiAqXG4gKiBOb3RlOiBZb3UgbXVzdCB1c2UgYGNyZWF0ZSh2YWx1ZSwgU3RydWN0KWAgb24gdGhlIHZhbHVlIHRvIGhhdmUgdGhlIGNvZXJjaW9uXG4gKiB0YWtlIGVmZmVjdCEgVXNpbmcgc2ltcGx5IGBhc3NlcnQoKWAgb3IgYGlzKClgIHdpbGwgbm90IHVzZSBjb2VyY2lvbi5cbiAqL1xuZnVuY3Rpb24gZGVmYXVsdGVkKHN0cnVjdCwgZmFsbGJhY2ssIG9wdGlvbnMgPSB7fSkge1xuICAgIHJldHVybiBjb2VyY2Uoc3RydWN0LCB1bmtub3duKCksICh4KSA9PiB7XG4gICAgICAgIGNvbnN0IGYgPSB0eXBlb2YgZmFsbGJhY2sgPT09ICdmdW5jdGlvbicgPyBmYWxsYmFjaygpIDogZmFsbGJhY2s7XG4gICAgICAgIGlmICh4ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBmO1xuICAgICAgICB9XG4gICAgICAgIGlmICghb3B0aW9ucy5zdHJpY3QgJiYgaXNQbGFpbk9iamVjdCh4KSAmJiBpc1BsYWluT2JqZWN0KGYpKSB7XG4gICAgICAgICAgICBjb25zdCByZXQgPSB7IC4uLnggfTtcbiAgICAgICAgICAgIGxldCBjaGFuZ2VkID0gZmFsc2U7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBmKSB7XG4gICAgICAgICAgICAgICAgaWYgKHJldFtrZXldID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0W2tleV0gPSBmW2tleV07XG4gICAgICAgICAgICAgICAgICAgIGNoYW5nZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjaGFuZ2VkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJldDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geDtcbiAgICB9KTtcbn1cbi8qKlxuICogQXVnbWVudCBhIHN0cnVjdCB0byB0cmltIHN0cmluZyBpbnB1dHMuXG4gKlxuICogTm90ZTogWW91IG11c3QgdXNlIGBjcmVhdGUodmFsdWUsIFN0cnVjdClgIG9uIHRoZSB2YWx1ZSB0byBoYXZlIHRoZSBjb2VyY2lvblxuICogdGFrZSBlZmZlY3QhIFVzaW5nIHNpbXBseSBgYXNzZXJ0KClgIG9yIGBpcygpYCB3aWxsIG5vdCB1c2UgY29lcmNpb24uXG4gKi9cbmZ1bmN0aW9uIHRyaW1tZWQoc3RydWN0KSB7XG4gICAgcmV0dXJuIGNvZXJjZShzdHJ1Y3QsIHN0cmluZygpLCAoeCkgPT4geC50cmltKCkpO1xufVxuXG4vKipcbiAqIEVuc3VyZSB0aGF0IGEgc3RyaW5nLCBhcnJheSwgbWFwLCBvciBzZXQgaXMgZW1wdHkuXG4gKi9cbmZ1bmN0aW9uIGVtcHR5KHN0cnVjdCkge1xuICAgIHJldHVybiByZWZpbmUoc3RydWN0LCAnZW1wdHknLCAodmFsdWUpID0+IHtcbiAgICAgICAgY29uc3Qgc2l6ZSA9IGdldFNpemUodmFsdWUpO1xuICAgICAgICByZXR1cm4gKHNpemUgPT09IDAgfHxcbiAgICAgICAgICAgIGBFeHBlY3RlZCBhbiBlbXB0eSAke3N0cnVjdC50eXBlfSBidXQgcmVjZWl2ZWQgb25lIHdpdGggYSBzaXplIG9mIFxcYCR7c2l6ZX1cXGBgKTtcbiAgICB9KTtcbn1cbmZ1bmN0aW9uIGdldFNpemUodmFsdWUpIHtcbiAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBNYXAgfHwgdmFsdWUgaW5zdGFuY2VvZiBTZXQpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlLnNpemU7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gdmFsdWUubGVuZ3RoO1xuICAgIH1cbn1cbi8qKlxuICogRW5zdXJlIHRoYXQgYSBudW1iZXIgb3IgZGF0ZSBpcyBiZWxvdyBhIHRocmVzaG9sZC5cbiAqL1xuZnVuY3Rpb24gbWF4KHN0cnVjdCwgdGhyZXNob2xkLCBvcHRpb25zID0ge30pIHtcbiAgICBjb25zdCB7IGV4Y2x1c2l2ZSB9ID0gb3B0aW9ucztcbiAgICByZXR1cm4gcmVmaW5lKHN0cnVjdCwgJ21heCcsICh2YWx1ZSkgPT4ge1xuICAgICAgICByZXR1cm4gZXhjbHVzaXZlXG4gICAgICAgICAgICA/IHZhbHVlIDwgdGhyZXNob2xkXG4gICAgICAgICAgICA6IHZhbHVlIDw9IHRocmVzaG9sZCB8fFxuICAgICAgICAgICAgICAgIGBFeHBlY3RlZCBhICR7c3RydWN0LnR5cGV9IGxlc3MgdGhhbiAke2V4Y2x1c2l2ZSA/ICcnIDogJ29yIGVxdWFsIHRvICd9JHt0aHJlc2hvbGR9IGJ1dCByZWNlaXZlZCBcXGAke3ZhbHVlfVxcYGA7XG4gICAgfSk7XG59XG4vKipcbiAqIEVuc3VyZSB0aGF0IGEgbnVtYmVyIG9yIGRhdGUgaXMgYWJvdmUgYSB0aHJlc2hvbGQuXG4gKi9cbmZ1bmN0aW9uIG1pbihzdHJ1Y3QsIHRocmVzaG9sZCwgb3B0aW9ucyA9IHt9KSB7XG4gICAgY29uc3QgeyBleGNsdXNpdmUgfSA9IG9wdGlvbnM7XG4gICAgcmV0dXJuIHJlZmluZShzdHJ1Y3QsICdtaW4nLCAodmFsdWUpID0+IHtcbiAgICAgICAgcmV0dXJuIGV4Y2x1c2l2ZVxuICAgICAgICAgICAgPyB2YWx1ZSA+IHRocmVzaG9sZFxuICAgICAgICAgICAgOiB2YWx1ZSA+PSB0aHJlc2hvbGQgfHxcbiAgICAgICAgICAgICAgICBgRXhwZWN0ZWQgYSAke3N0cnVjdC50eXBlfSBncmVhdGVyIHRoYW4gJHtleGNsdXNpdmUgPyAnJyA6ICdvciBlcXVhbCB0byAnfSR7dGhyZXNob2xkfSBidXQgcmVjZWl2ZWQgXFxgJHt2YWx1ZX1cXGBgO1xuICAgIH0pO1xufVxuLyoqXG4gKiBFbnN1cmUgdGhhdCBhIHN0cmluZywgYXJyYXksIG1hcCBvciBzZXQgaXMgbm90IGVtcHR5LlxuICovXG5mdW5jdGlvbiBub25lbXB0eShzdHJ1Y3QpIHtcbiAgICByZXR1cm4gcmVmaW5lKHN0cnVjdCwgJ25vbmVtcHR5JywgKHZhbHVlKSA9PiB7XG4gICAgICAgIGNvbnN0IHNpemUgPSBnZXRTaXplKHZhbHVlKTtcbiAgICAgICAgcmV0dXJuIChzaXplID4gMCB8fCBgRXhwZWN0ZWQgYSBub25lbXB0eSAke3N0cnVjdC50eXBlfSBidXQgcmVjZWl2ZWQgYW4gZW1wdHkgb25lYCk7XG4gICAgfSk7XG59XG4vKipcbiAqIEVuc3VyZSB0aGF0IGEgc3RyaW5nIG1hdGNoZXMgYSByZWd1bGFyIGV4cHJlc3Npb24uXG4gKi9cbmZ1bmN0aW9uIHBhdHRlcm4oc3RydWN0LCByZWdleHApIHtcbiAgICByZXR1cm4gcmVmaW5lKHN0cnVjdCwgJ3BhdHRlcm4nLCAodmFsdWUpID0+IHtcbiAgICAgICAgcmV0dXJuIChyZWdleHAudGVzdCh2YWx1ZSkgfHxcbiAgICAgICAgICAgIGBFeHBlY3RlZCBhICR7c3RydWN0LnR5cGV9IG1hdGNoaW5nIFxcYC8ke3JlZ2V4cC5zb3VyY2V9L1xcYCBidXQgcmVjZWl2ZWQgXCIke3ZhbHVlfVwiYCk7XG4gICAgfSk7XG59XG4vKipcbiAqIEVuc3VyZSB0aGF0IGEgc3RyaW5nLCBhcnJheSwgbnVtYmVyLCBkYXRlLCBtYXAsIG9yIHNldCBoYXMgYSBzaXplIChvciBsZW5ndGgsIG9yIHRpbWUpIGJldHdlZW4gYG1pbmAgYW5kIGBtYXhgLlxuICovXG5mdW5jdGlvbiBzaXplKHN0cnVjdCwgbWluLCBtYXggPSBtaW4pIHtcbiAgICBjb25zdCBleHBlY3RlZCA9IGBFeHBlY3RlZCBhICR7c3RydWN0LnR5cGV9YDtcbiAgICBjb25zdCBvZiA9IG1pbiA9PT0gbWF4ID8gYG9mIFxcYCR7bWlufVxcYGAgOiBgYmV0d2VlbiBcXGAke21pbn1cXGAgYW5kIFxcYCR7bWF4fVxcYGA7XG4gICAgcmV0dXJuIHJlZmluZShzdHJ1Y3QsICdzaXplJywgKHZhbHVlKSA9PiB7XG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInIHx8IHZhbHVlIGluc3RhbmNlb2YgRGF0ZSkge1xuICAgICAgICAgICAgcmV0dXJuICgobWluIDw9IHZhbHVlICYmIHZhbHVlIDw9IG1heCkgfHxcbiAgICAgICAgICAgICAgICBgJHtleHBlY3RlZH0gJHtvZn0gYnV0IHJlY2VpdmVkIFxcYCR7dmFsdWV9XFxgYCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodmFsdWUgaW5zdGFuY2VvZiBNYXAgfHwgdmFsdWUgaW5zdGFuY2VvZiBTZXQpIHtcbiAgICAgICAgICAgIGNvbnN0IHsgc2l6ZSB9ID0gdmFsdWU7XG4gICAgICAgICAgICByZXR1cm4gKChtaW4gPD0gc2l6ZSAmJiBzaXplIDw9IG1heCkgfHxcbiAgICAgICAgICAgICAgICBgJHtleHBlY3RlZH0gd2l0aCBhIHNpemUgJHtvZn0gYnV0IHJlY2VpdmVkIG9uZSB3aXRoIGEgc2l6ZSBvZiBcXGAke3NpemV9XFxgYCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCB7IGxlbmd0aCB9ID0gdmFsdWU7XG4gICAgICAgICAgICByZXR1cm4gKChtaW4gPD0gbGVuZ3RoICYmIGxlbmd0aCA8PSBtYXgpIHx8XG4gICAgICAgICAgICAgICAgYCR7ZXhwZWN0ZWR9IHdpdGggYSBsZW5ndGggJHtvZn0gYnV0IHJlY2VpdmVkIG9uZSB3aXRoIGEgbGVuZ3RoIG9mIFxcYCR7bGVuZ3RofVxcYGApO1xuICAgICAgICB9XG4gICAgfSk7XG59XG4vKipcbiAqIEF1Z21lbnQgYSBgU3RydWN0YCB0byBhZGQgYW4gYWRkaXRpb25hbCByZWZpbmVtZW50IHRvIHRoZSB2YWxpZGF0aW9uLlxuICpcbiAqIFRoZSByZWZpbmVyIGZ1bmN0aW9uIGlzIGd1YXJhbnRlZWQgdG8gcmVjZWl2ZSBhIHZhbHVlIG9mIHRoZSBzdHJ1Y3QncyB0eXBlLFxuICogYmVjYXVzZSB0aGUgc3RydWN0J3MgZXhpc3RpbmcgdmFsaWRhdGlvbiB3aWxsIGFscmVhZHkgaGF2ZSBwYXNzZWQuIFRoaXNcbiAqIGFsbG93cyB5b3UgdG8gbGF5ZXIgYWRkaXRpb25hbCB2YWxpZGF0aW9uIG9uIHRvcCBvZiBleGlzdGluZyBzdHJ1Y3RzLlxuICovXG5mdW5jdGlvbiByZWZpbmUoc3RydWN0LCBuYW1lLCByZWZpbmVyKSB7XG4gICAgcmV0dXJuIG5ldyBTdHJ1Y3Qoe1xuICAgICAgICAuLi5zdHJ1Y3QsXG4gICAgICAgICpyZWZpbmVyKHZhbHVlLCBjdHgpIHtcbiAgICAgICAgICAgIHlpZWxkKiBzdHJ1Y3QucmVmaW5lcih2YWx1ZSwgY3R4KTtcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IHJlZmluZXIodmFsdWUsIGN0eCk7XG4gICAgICAgICAgICBjb25zdCBmYWlsdXJlcyA9IHRvRmFpbHVyZXMocmVzdWx0LCBjdHgsIHN0cnVjdCwgdmFsdWUpO1xuICAgICAgICAgICAgZm9yIChjb25zdCBmYWlsdXJlIG9mIGZhaWx1cmVzKSB7XG4gICAgICAgICAgICAgICAgeWllbGQgeyAuLi5mYWlsdXJlLCByZWZpbmVtZW50OiBuYW1lIH07XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgfSk7XG59XG5cbmV4cG9ydCB7IFN0cnVjdCwgU3RydWN0RXJyb3IsIGFueSwgYXJyYXksIGFzc2VydCwgYXNzaWduLCBiaWdpbnQsIGJvb2xlYW4sIGNvZXJjZSwgY3JlYXRlLCBkYXRlLCBkZWZhdWx0ZWQsIGRlZmluZSwgZGVwcmVjYXRlZCwgZHluYW1pYywgZW1wdHksIGVudW1zLCBmdW5jLCBpbnN0YW5jZSwgaW50ZWdlciwgaW50ZXJzZWN0aW9uLCBpcywgbGF6eSwgbGl0ZXJhbCwgbWFwLCBtYXNrLCBtYXgsIG1pbiwgbmV2ZXIsIG5vbmVtcHR5LCBudWxsYWJsZSwgbnVtYmVyLCBvYmplY3QsIG9taXQsIG9wdGlvbmFsLCBwYXJ0aWFsLCBwYXR0ZXJuLCBwaWNrLCByZWNvcmQsIHJlZmluZSwgcmVnZXhwLCBzZXQsIHNpemUsIHN0cmluZywgc3RydWN0LCB0cmltbWVkLCB0dXBsZSwgdHlwZSwgdW5pb24sIHVua25vd24sIHZhbGlkYXRlIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5tanMubWFwXG4iXSwibmFtZXMiOlsiU3RydWN0RXJyb3IiLCJUeXBlRXJyb3IiLCJjb25zdHJ1Y3RvciIsImZhaWx1cmUiLCJmYWlsdXJlcyIsImNhY2hlZCIsIm1lc3NhZ2UiLCJleHBsYW5hdGlvbiIsInJlc3QiLCJwYXRoIiwibXNnIiwibGVuZ3RoIiwiam9pbiIsImNhdXNlIiwiT2JqZWN0IiwiYXNzaWduIiwibmFtZSIsImlzSXRlcmFibGUiLCJ4IiwiaXNPYmplY3QiLCJTeW1ib2wiLCJpdGVyYXRvciIsImlzUGxhaW5PYmplY3QiLCJwcm90b3R5cGUiLCJ0b1N0cmluZyIsImNhbGwiLCJnZXRQcm90b3R5cGVPZiIsInByaW50IiwidmFsdWUiLCJKU09OIiwic3RyaW5naWZ5Iiwic2hpZnRJdGVyYXRvciIsImlucHV0IiwiZG9uZSIsIm5leHQiLCJ1bmRlZmluZWQiLCJ0b0ZhaWx1cmUiLCJyZXN1bHQiLCJjb250ZXh0Iiwic3RydWN0IiwiYnJhbmNoIiwidHlwZSIsInJlZmluZW1lbnQiLCJrZXkiLCJ0b0ZhaWx1cmVzIiwiciIsInJ1biIsIm9wdGlvbnMiLCJjb2VyY2UiLCJtYXNrIiwiY3R4IiwiY29lcmNlciIsInNjaGVtYSIsIkFycmF5IiwiaXNBcnJheSIsInN0YXR1cyIsInZhbGlkYXRvciIsImsiLCJ2IiwicyIsImVudHJpZXMiLCJ0cyIsInQiLCJNYXAiLCJzZXQiLCJTZXQiLCJhZGQiLCJyZWZpbmVyIiwiU3RydWN0IiwicHJvcHMiLCJhc3NlcnQiLCJjcmVhdGUiLCJpcyIsInZhbGlkYXRlIiwidHVwbGVzIiwidHVwbGUiLCJlcnJvciIsIlN0cnVjdHMiLCJpc1R5cGUiLCJzY2hlbWFzIiwibWFwIiwib2JqZWN0IiwiZGVmaW5lIiwiZGVwcmVjYXRlZCIsImxvZyIsImR5bmFtaWMiLCJmbiIsImxhenkiLCJvbWl0Iiwia2V5cyIsInN1YnNjaGVtYSIsInBhcnRpYWwiLCJpc1N0cnVjdCIsIm9wdGlvbmFsIiwicGljayIsImNvbnNvbGUiLCJ3YXJuIiwiYW55IiwiYXJyYXkiLCJFbGVtZW50IiwiaSIsInNsaWNlIiwiYmlnaW50IiwiYm9vbGVhbiIsImRhdGUiLCJEYXRlIiwiaXNOYU4iLCJnZXRUaW1lIiwiZW51bXMiLCJ2YWx1ZXMiLCJkZXNjcmlwdGlvbiIsImluY2x1ZGVzIiwiZnVuYyIsImluc3RhbmNlIiwiQ2xhc3MiLCJpbnRlZ2VyIiwiTnVtYmVyIiwiaXNJbnRlZ2VyIiwiaW50ZXJzZWN0aW9uIiwiUyIsImxpdGVyYWwiLCJjb25zdGFudCIsIktleSIsIlZhbHVlIiwibmV2ZXIiLCJudWxsYWJsZSIsIm51bWJlciIsImtub3ducyIsIk5ldmVyIiwidW5rbm93bnMiLCJkZWxldGUiLCJyZWNvcmQiLCJyZWdleHAiLCJSZWdFeHAiLCJzdHJpbmciLCJNYXRoIiwibWF4IiwidW5pb24iLCJjb2VyY2VkIiwiZmlyc3QiLCJwdXNoIiwidW5rbm93biIsImNvbmRpdGlvbiIsImRlZmF1bHRlZCIsImZhbGxiYWNrIiwiZiIsInN0cmljdCIsInJldCIsImNoYW5nZWQiLCJ0cmltbWVkIiwidHJpbSIsImVtcHR5IiwicmVmaW5lIiwic2l6ZSIsImdldFNpemUiLCJ0aHJlc2hvbGQiLCJleGNsdXNpdmUiLCJtaW4iLCJub25lbXB0eSIsInBhdHRlcm4iLCJ0ZXN0Iiwic291cmNlIiwiZXhwZWN0ZWQiLCJvZiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/superstruct/dist/index.mjs\n");

/***/ })

};
;