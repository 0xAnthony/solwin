/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@solana";
exports.ids = ["vendor-chunks/@solana"];
exports.modules = {

/***/ "(ssr)/../anchor/node_modules/@solana/buffer-layout/lib/Layout.js":
/*!******************************************************************!*\
  !*** ../anchor/node_modules/@solana/buffer-layout/lib/Layout.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("/* The MIT License (MIT)\n *\n * Copyright 2015-2018 Peter A. Bigot\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n */ /**\n * Support for translating between Uint8Array instances and JavaScript\n * native types.\n *\n * {@link module:Layout~Layout|Layout} is the basis of a class\n * hierarchy that associates property names with sequences of encoded\n * bytes.\n *\n * Layouts are supported for these scalar (numeric) types:\n * * {@link module:Layout~UInt|Unsigned integers in little-endian\n *   format} with {@link module:Layout.u8|8-bit}, {@link\n *   module:Layout.u16|16-bit}, {@link module:Layout.u24|24-bit},\n *   {@link module:Layout.u32|32-bit}, {@link\n *   module:Layout.u40|40-bit}, and {@link module:Layout.u48|48-bit}\n *   representation ranges;\n * * {@link module:Layout~UIntBE|Unsigned integers in big-endian\n *   format} with {@link module:Layout.u16be|16-bit}, {@link\n *   module:Layout.u24be|24-bit}, {@link module:Layout.u32be|32-bit},\n *   {@link module:Layout.u40be|40-bit}, and {@link\n *   module:Layout.u48be|48-bit} representation ranges;\n * * {@link module:Layout~Int|Signed integers in little-endian\n *   format} with {@link module:Layout.s8|8-bit}, {@link\n *   module:Layout.s16|16-bit}, {@link module:Layout.s24|24-bit},\n *   {@link module:Layout.s32|32-bit}, {@link\n *   module:Layout.s40|40-bit}, and {@link module:Layout.s48|48-bit}\n *   representation ranges;\n * * {@link module:Layout~IntBE|Signed integers in big-endian format}\n *   with {@link module:Layout.s16be|16-bit}, {@link\n *   module:Layout.s24be|24-bit}, {@link module:Layout.s32be|32-bit},\n *   {@link module:Layout.s40be|40-bit}, and {@link\n *   module:Layout.s48be|48-bit} representation ranges;\n * * 64-bit integral values that decode to an exact (if magnitude is\n *   less than 2^53) or nearby integral Number in {@link\n *   module:Layout.nu64|unsigned little-endian}, {@link\n *   module:Layout.nu64be|unsigned big-endian}, {@link\n *   module:Layout.ns64|signed little-endian}, and {@link\n *   module:Layout.ns64be|unsigned big-endian} encodings;\n * * 32-bit floating point values with {@link\n *   module:Layout.f32|little-endian} and {@link\n *   module:Layout.f32be|big-endian} representations;\n * * 64-bit floating point values with {@link\n *   module:Layout.f64|little-endian} and {@link\n *   module:Layout.f64be|big-endian} representations;\n * * {@link module:Layout.const|Constants} that take no space in the\n *   encoded expression.\n *\n * and for these aggregate types:\n * * {@link module:Layout.seq|Sequence}s of instances of a {@link\n *   module:Layout~Layout|Layout}, with JavaScript representation as\n *   an Array and constant or data-dependent {@link\n *   module:Layout~Sequence#count|length};\n * * {@link module:Layout.struct|Structure}s that aggregate a\n *   heterogeneous sequence of {@link module:Layout~Layout|Layout}\n *   instances, with JavaScript representation as an Object;\n * * {@link module:Layout.union|Union}s that support multiple {@link\n *   module:Layout~VariantLayout|variant layouts} over a fixed\n *   (padded) or variable (not padded) span of bytes, using an\n *   unsigned integer at the start of the data or a separate {@link\n *   module:Layout.unionLayoutDiscriminator|layout element} to\n *   determine which layout to use when interpreting the buffer\n *   contents;\n * * {@link module:Layout.bits|BitStructure}s that contain a sequence\n *   of individual {@link\n *   module:Layout~BitStructure#addField|BitField}s packed into an 8,\n *   16, 24, or 32-bit unsigned integer starting at the least- or\n *   most-significant bit;\n * * {@link module:Layout.cstr|C strings} of varying length;\n * * {@link module:Layout.blob|Blobs} of fixed- or variable-{@link\n *   module:Layout~Blob#length|length} raw data.\n *\n * All {@link module:Layout~Layout|Layout} instances are immutable\n * after construction, to prevent internal state from becoming\n * inconsistent.\n *\n * @local Layout\n * @local ExternalLayout\n * @local GreedyCount\n * @local OffsetLayout\n * @local UInt\n * @local UIntBE\n * @local Int\n * @local IntBE\n * @local NearUInt64\n * @local NearUInt64BE\n * @local NearInt64\n * @local NearInt64BE\n * @local Float\n * @local FloatBE\n * @local Double\n * @local DoubleBE\n * @local Sequence\n * @local Structure\n * @local UnionDiscriminator\n * @local UnionLayoutDiscriminator\n * @local Union\n * @local VariantLayout\n * @local BitStructure\n * @local BitField\n * @local Boolean\n * @local Blob\n * @local CString\n * @local Constant\n * @local bindConstructorLayout\n * @module Layout\n * @license MIT\n * @author Peter A. Bigot\n * @see {@link https://github.com/pabigot/buffer-layout|buffer-layout on GitHub}\n */ \nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.s16 = exports.s8 = exports.nu64be = exports.u48be = exports.u40be = exports.u32be = exports.u24be = exports.u16be = exports.nu64 = exports.u48 = exports.u40 = exports.u32 = exports.u24 = exports.u16 = exports.u8 = exports.offset = exports.greedy = exports.Constant = exports.UTF8 = exports.CString = exports.Blob = exports.Boolean = exports.BitField = exports.BitStructure = exports.VariantLayout = exports.Union = exports.UnionLayoutDiscriminator = exports.UnionDiscriminator = exports.Structure = exports.Sequence = exports.DoubleBE = exports.Double = exports.FloatBE = exports.Float = exports.NearInt64BE = exports.NearInt64 = exports.NearUInt64BE = exports.NearUInt64 = exports.IntBE = exports.Int = exports.UIntBE = exports.UInt = exports.OffsetLayout = exports.GreedyCount = exports.ExternalLayout = exports.bindConstructorLayout = exports.nameWithProperty = exports.Layout = exports.uint8ArrayToBuffer = exports.checkUint8Array = void 0;\nexports.constant = exports.utf8 = exports.cstr = exports.blob = exports.unionLayoutDiscriminator = exports.union = exports.seq = exports.bits = exports.struct = exports.f64be = exports.f64 = exports.f32be = exports.f32 = exports.ns64be = exports.s48be = exports.s40be = exports.s32be = exports.s24be = exports.s16be = exports.ns64 = exports.s48 = exports.s40 = exports.s32 = exports.s24 = void 0;\nconst buffer_1 = __webpack_require__(/*! buffer */ \"buffer\");\n/* Check if a value is a Uint8Array.\n *\n * @ignore */ function checkUint8Array(b) {\n    if (!(b instanceof Uint8Array)) {\n        throw new TypeError(\"b must be a Uint8Array\");\n    }\n}\nexports.checkUint8Array = checkUint8Array;\n/* Create a Buffer instance from a Uint8Array.\n *\n * @ignore */ function uint8ArrayToBuffer(b) {\n    checkUint8Array(b);\n    return buffer_1.Buffer.from(b.buffer, b.byteOffset, b.length);\n}\nexports.uint8ArrayToBuffer = uint8ArrayToBuffer;\n/**\n * Base class for layout objects.\n *\n * **NOTE** This is an abstract base class; you can create instances\n * if it amuses you, but they won't support the {@link\n * Layout#encode|encode} or {@link Layout#decode|decode} functions.\n *\n * @param {Number} span - Initializer for {@link Layout#span|span}.  The\n * parameter must be an integer; a negative value signifies that the\n * span is {@link Layout#getSpan|value-specific}.\n *\n * @param {string} [property] - Initializer for {@link\n * Layout#property|property}.\n *\n * @abstract\n */ class Layout {\n    constructor(span, property){\n        if (!Number.isInteger(span)) {\n            throw new TypeError(\"span must be an integer\");\n        }\n        /** The span of the layout in bytes.\n         *\n         * Positive values are generally expected.\n         *\n         * Zero will only appear in {@link Constant}s and in {@link\n         * Sequence}s where the {@link Sequence#count|count} is zero.\n         *\n         * A negative value indicates that the span is value-specific, and\n         * must be obtained using {@link Layout#getSpan|getSpan}. */ this.span = span;\n        /** The property name used when this layout is represented in an\n         * Object.\n         *\n         * Used only for layouts that {@link Layout#decode|decode} to Object\n         * instances.  If left undefined the span of the unnamed layout will\n         * be treated as padding: it will not be mutated by {@link\n         * Layout#encode|encode} nor represented as a property in the\n         * decoded Object. */ this.property = property;\n    }\n    /** Function to create an Object into which decoded properties will\n     * be written.\n     *\n     * Used only for layouts that {@link Layout#decode|decode} to Object\n     * instances, which means:\n     * * {@link Structure}\n     * * {@link Union}\n     * * {@link VariantLayout}\n     * * {@link BitStructure}\n     *\n     * If left undefined the JavaScript representation of these layouts\n     * will be Object instances.\n     *\n     * See {@link bindConstructorLayout}.\n     */ makeDestinationObject() {\n        return {};\n    }\n    /**\n     * Calculate the span of a specific instance of a layout.\n     *\n     * @param {Uint8Array} b - the buffer that contains an encoded instance.\n     *\n     * @param {Number} [offset] - the offset at which the encoded instance\n     * starts.  If absent a zero offset is inferred.\n     *\n     * @return {Number} - the number of bytes covered by the layout\n     * instance.  If this method is not overridden in a subclass the\n     * definition-time constant {@link Layout#span|span} will be\n     * returned.\n     *\n     * @throws {RangeError} - if the length of the value cannot be\n     * determined.\n     */ getSpan(b, offset) {\n        if (0 > this.span) {\n            throw new RangeError(\"indeterminate span\");\n        }\n        return this.span;\n    }\n    /**\n     * Replicate the layout using a new property.\n     *\n     * This function must be used to get a structurally-equivalent layout\n     * with a different name since all {@link Layout} instances are\n     * immutable.\n     *\n     * **NOTE** This is a shallow copy.  All fields except {@link\n     * Layout#property|property} are strictly equal to the origin layout.\n     *\n     * @param {String} property - the value for {@link\n     * Layout#property|property} in the replica.\n     *\n     * @returns {Layout} - the copy with {@link Layout#property|property}\n     * set to `property`.\n     */ replicate(property) {\n        const rv = Object.create(this.constructor.prototype);\n        Object.assign(rv, this);\n        rv.property = property;\n        return rv;\n    }\n    /**\n     * Create an object from layout properties and an array of values.\n     *\n     * **NOTE** This function returns `undefined` if invoked on a layout\n     * that does not return its value as an Object.  Objects are\n     * returned for things that are a {@link Structure}, which includes\n     * {@link VariantLayout|variant layouts} if they are structures, and\n     * excludes {@link Union}s.  If you want this feature for a union\n     * you must use {@link Union.getVariant|getVariant} to select the\n     * desired layout.\n     *\n     * @param {Array} values - an array of values that correspond to the\n     * default order for properties.  As with {@link Layout#decode|decode}\n     * layout elements that have no property name are skipped when\n     * iterating over the array values.  Only the top-level properties are\n     * assigned; arguments are not assigned to properties of contained\n     * layouts.  Any unused values are ignored.\n     *\n     * @return {(Object|undefined)}\n     */ fromArray(values) {\n        return undefined;\n    }\n}\nexports.Layout = Layout;\n/* Provide text that carries a name (such as for a function that will\n * be throwing an error) annotated with the property of a given layout\n * (such as one for which the value was unacceptable).\n *\n * @ignore */ function nameWithProperty(name, lo) {\n    if (lo.property) {\n        return name + \"[\" + lo.property + \"]\";\n    }\n    return name;\n}\nexports.nameWithProperty = nameWithProperty;\n/**\n * Augment a class so that instances can be encoded/decoded using a\n * given layout.\n *\n * Calling this function couples `Class` with `layout` in several ways:\n *\n * * `Class.layout_` becomes a static member property equal to `layout`;\n * * `layout.boundConstructor_` becomes a static member property equal\n *    to `Class`;\n * * The {@link Layout#makeDestinationObject|makeDestinationObject()}\n *   property of `layout` is set to a function that returns a `new\n *   Class()`;\n * * `Class.decode(b, offset)` becomes a static member function that\n *   delegates to {@link Layout#decode|layout.decode}.  The\n *   synthesized function may be captured and extended.\n * * `Class.prototype.encode(b, offset)` provides an instance member\n *   function that delegates to {@link Layout#encode|layout.encode}\n *   with `src` set to `this`.  The synthesized function may be\n *   captured and extended, but when the extension is invoked `this`\n *   must be explicitly bound to the instance.\n *\n * @param {class} Class - a JavaScript class with a nullary\n * constructor.\n *\n * @param {Layout} layout - the {@link Layout} instance used to encode\n * instances of `Class`.\n */ // `Class` must be a constructor Function, but the assignment of a `layout_` property to it makes it difficult to type\n// eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types\nfunction bindConstructorLayout(Class, layout) {\n    if (\"function\" !== typeof Class) {\n        throw new TypeError(\"Class must be constructor\");\n    }\n    if (Object.prototype.hasOwnProperty.call(Class, \"layout_\")) {\n        throw new Error(\"Class is already bound to a layout\");\n    }\n    if (!(layout && layout instanceof Layout)) {\n        throw new TypeError(\"layout must be a Layout\");\n    }\n    if (Object.prototype.hasOwnProperty.call(layout, \"boundConstructor_\")) {\n        throw new Error(\"layout is already bound to a constructor\");\n    }\n    Class.layout_ = layout;\n    layout.boundConstructor_ = Class;\n    layout.makeDestinationObject = ()=>new Class();\n    Object.defineProperty(Class.prototype, \"encode\", {\n        value (b, offset) {\n            return layout.encode(this, b, offset);\n        },\n        writable: true\n    });\n    Object.defineProperty(Class, \"decode\", {\n        value (b, offset) {\n            return layout.decode(b, offset);\n        },\n        writable: true\n    });\n}\nexports.bindConstructorLayout = bindConstructorLayout;\n/**\n * An object that behaves like a layout but does not consume space\n * within its containing layout.\n *\n * This is primarily used to obtain metadata about a member, such as a\n * {@link OffsetLayout} that can provide data about a {@link\n * Layout#getSpan|value-specific span}.\n *\n * **NOTE** This is an abstract base class; you can create instances\n * if it amuses you, but they won't support {@link\n * ExternalLayout#isCount|isCount} or other {@link Layout} functions.\n *\n * @param {Number} span - initializer for {@link Layout#span|span}.\n * The parameter can range from 1 through 6.\n *\n * @param {string} [property] - initializer for {@link\n * Layout#property|property}.\n *\n * @abstract\n * @augments {Layout}\n */ class ExternalLayout extends Layout {\n    /**\n     * Return `true` iff the external layout decodes to an unsigned\n     * integer layout.\n     *\n     * In that case it can be used as the source of {@link\n     * Sequence#count|Sequence counts}, {@link Blob#length|Blob lengths},\n     * or as {@link UnionLayoutDiscriminator#layout|external union\n     * discriminators}.\n     *\n     * @abstract\n     */ isCount() {\n        throw new Error(\"ExternalLayout is abstract\");\n    }\n}\nexports.ExternalLayout = ExternalLayout;\n/**\n * An {@link ExternalLayout} that determines its {@link\n * Layout#decode|value} based on offset into and length of the buffer\n * on which it is invoked.\n *\n * *Factory*: {@link module:Layout.greedy|greedy}\n *\n * @param {Number} [elementSpan] - initializer for {@link\n * GreedyCount#elementSpan|elementSpan}.\n *\n * @param {string} [property] - initializer for {@link\n * Layout#property|property}.\n *\n * @augments {ExternalLayout}\n */ class GreedyCount extends ExternalLayout {\n    constructor(elementSpan = 1, property){\n        if (!Number.isInteger(elementSpan) || 0 >= elementSpan) {\n            throw new TypeError(\"elementSpan must be a (positive) integer\");\n        }\n        super(-1, property);\n        /** The layout for individual elements of the sequence.  The value\n         * must be a positive integer.  If not provided, the value will be\n         * 1. */ this.elementSpan = elementSpan;\n    }\n    /** @override */ isCount() {\n        return true;\n    }\n    /** @override */ decode(b, offset = 0) {\n        checkUint8Array(b);\n        const rem = b.length - offset;\n        return Math.floor(rem / this.elementSpan);\n    }\n    /** @override */ encode(src, b, offset) {\n        return 0;\n    }\n}\nexports.GreedyCount = GreedyCount;\n/**\n * An {@link ExternalLayout} that supports accessing a {@link Layout}\n * at a fixed offset from the start of another Layout.  The offset may\n * be before, within, or after the base layout.\n *\n * *Factory*: {@link module:Layout.offset|offset}\n *\n * @param {Layout} layout - initializer for {@link\n * OffsetLayout#layout|layout}, modulo `property`.\n *\n * @param {Number} [offset] - Initializes {@link\n * OffsetLayout#offset|offset}.  Defaults to zero.\n *\n * @param {string} [property] - Optional new property name for a\n * {@link Layout#replicate| replica} of `layout` to be used as {@link\n * OffsetLayout#layout|layout}.  If not provided the `layout` is used\n * unchanged.\n *\n * @augments {Layout}\n */ class OffsetLayout extends ExternalLayout {\n    constructor(layout, offset = 0, property){\n        if (!(layout instanceof Layout)) {\n            throw new TypeError(\"layout must be a Layout\");\n        }\n        if (!Number.isInteger(offset)) {\n            throw new TypeError(\"offset must be integer or undefined\");\n        }\n        super(layout.span, property || layout.property);\n        /** The subordinated layout. */ this.layout = layout;\n        /** The location of {@link OffsetLayout#layout} relative to the\n         * start of another layout.\n         *\n         * The value may be positive or negative, but an error will thrown\n         * if at the point of use it goes outside the span of the Uint8Array\n         * being accessed.  */ this.offset = offset;\n    }\n    /** @override */ isCount() {\n        return this.layout instanceof UInt || this.layout instanceof UIntBE;\n    }\n    /** @override */ decode(b, offset = 0) {\n        return this.layout.decode(b, offset + this.offset);\n    }\n    /** @override */ encode(src, b, offset = 0) {\n        return this.layout.encode(src, b, offset + this.offset);\n    }\n}\nexports.OffsetLayout = OffsetLayout;\n/**\n * Represent an unsigned integer in little-endian format.\n *\n * *Factory*: {@link module:Layout.u8|u8}, {@link\n *  module:Layout.u16|u16}, {@link module:Layout.u24|u24}, {@link\n *  module:Layout.u32|u32}, {@link module:Layout.u40|u40}, {@link\n *  module:Layout.u48|u48}\n *\n * @param {Number} span - initializer for {@link Layout#span|span}.\n * The parameter can range from 1 through 6.\n *\n * @param {string} [property] - initializer for {@link\n * Layout#property|property}.\n *\n * @augments {Layout}\n */ class UInt extends Layout {\n    constructor(span, property){\n        super(span, property);\n        if (6 < this.span) {\n            throw new RangeError(\"span must not exceed 6 bytes\");\n        }\n    }\n    /** @override */ decode(b, offset = 0) {\n        return uint8ArrayToBuffer(b).readUIntLE(offset, this.span);\n    }\n    /** @override */ encode(src, b, offset = 0) {\n        uint8ArrayToBuffer(b).writeUIntLE(src, offset, this.span);\n        return this.span;\n    }\n}\nexports.UInt = UInt;\n/**\n * Represent an unsigned integer in big-endian format.\n *\n * *Factory*: {@link module:Layout.u8be|u8be}, {@link\n * module:Layout.u16be|u16be}, {@link module:Layout.u24be|u24be},\n * {@link module:Layout.u32be|u32be}, {@link\n * module:Layout.u40be|u40be}, {@link module:Layout.u48be|u48be}\n *\n * @param {Number} span - initializer for {@link Layout#span|span}.\n * The parameter can range from 1 through 6.\n *\n * @param {string} [property] - initializer for {@link\n * Layout#property|property}.\n *\n * @augments {Layout}\n */ class UIntBE extends Layout {\n    constructor(span, property){\n        super(span, property);\n        if (6 < this.span) {\n            throw new RangeError(\"span must not exceed 6 bytes\");\n        }\n    }\n    /** @override */ decode(b, offset = 0) {\n        return uint8ArrayToBuffer(b).readUIntBE(offset, this.span);\n    }\n    /** @override */ encode(src, b, offset = 0) {\n        uint8ArrayToBuffer(b).writeUIntBE(src, offset, this.span);\n        return this.span;\n    }\n}\nexports.UIntBE = UIntBE;\n/**\n * Represent a signed integer in little-endian format.\n *\n * *Factory*: {@link module:Layout.s8|s8}, {@link\n *  module:Layout.s16|s16}, {@link module:Layout.s24|s24}, {@link\n *  module:Layout.s32|s32}, {@link module:Layout.s40|s40}, {@link\n *  module:Layout.s48|s48}\n *\n * @param {Number} span - initializer for {@link Layout#span|span}.\n * The parameter can range from 1 through 6.\n *\n * @param {string} [property] - initializer for {@link\n * Layout#property|property}.\n *\n * @augments {Layout}\n */ class Int extends Layout {\n    constructor(span, property){\n        super(span, property);\n        if (6 < this.span) {\n            throw new RangeError(\"span must not exceed 6 bytes\");\n        }\n    }\n    /** @override */ decode(b, offset = 0) {\n        return uint8ArrayToBuffer(b).readIntLE(offset, this.span);\n    }\n    /** @override */ encode(src, b, offset = 0) {\n        uint8ArrayToBuffer(b).writeIntLE(src, offset, this.span);\n        return this.span;\n    }\n}\nexports.Int = Int;\n/**\n * Represent a signed integer in big-endian format.\n *\n * *Factory*: {@link module:Layout.s8be|s8be}, {@link\n * module:Layout.s16be|s16be}, {@link module:Layout.s24be|s24be},\n * {@link module:Layout.s32be|s32be}, {@link\n * module:Layout.s40be|s40be}, {@link module:Layout.s48be|s48be}\n *\n * @param {Number} span - initializer for {@link Layout#span|span}.\n * The parameter can range from 1 through 6.\n *\n * @param {string} [property] - initializer for {@link\n * Layout#property|property}.\n *\n * @augments {Layout}\n */ class IntBE extends Layout {\n    constructor(span, property){\n        super(span, property);\n        if (6 < this.span) {\n            throw new RangeError(\"span must not exceed 6 bytes\");\n        }\n    }\n    /** @override */ decode(b, offset = 0) {\n        return uint8ArrayToBuffer(b).readIntBE(offset, this.span);\n    }\n    /** @override */ encode(src, b, offset = 0) {\n        uint8ArrayToBuffer(b).writeIntBE(src, offset, this.span);\n        return this.span;\n    }\n}\nexports.IntBE = IntBE;\nconst V2E32 = Math.pow(2, 32);\n/* True modulus high and low 32-bit words, where low word is always\n * non-negative. */ function divmodInt64(src) {\n    const hi32 = Math.floor(src / V2E32);\n    const lo32 = src - hi32 * V2E32;\n    return {\n        hi32,\n        lo32\n    };\n}\n/* Reconstruct Number from quotient and non-negative remainder */ function roundedInt64(hi32, lo32) {\n    return hi32 * V2E32 + lo32;\n}\n/**\n * Represent an unsigned 64-bit integer in little-endian format when\n * encoded and as a near integral JavaScript Number when decoded.\n *\n * *Factory*: {@link module:Layout.nu64|nu64}\n *\n * **NOTE** Values with magnitude greater than 2^52 may not decode to\n * the exact value of the encoded representation.\n *\n * @augments {Layout}\n */ class NearUInt64 extends Layout {\n    constructor(property){\n        super(8, property);\n    }\n    /** @override */ decode(b, offset = 0) {\n        const buffer = uint8ArrayToBuffer(b);\n        const lo32 = buffer.readUInt32LE(offset);\n        const hi32 = buffer.readUInt32LE(offset + 4);\n        return roundedInt64(hi32, lo32);\n    }\n    /** @override */ encode(src, b, offset = 0) {\n        const split = divmodInt64(src);\n        const buffer = uint8ArrayToBuffer(b);\n        buffer.writeUInt32LE(split.lo32, offset);\n        buffer.writeUInt32LE(split.hi32, offset + 4);\n        return 8;\n    }\n}\nexports.NearUInt64 = NearUInt64;\n/**\n * Represent an unsigned 64-bit integer in big-endian format when\n * encoded and as a near integral JavaScript Number when decoded.\n *\n * *Factory*: {@link module:Layout.nu64be|nu64be}\n *\n * **NOTE** Values with magnitude greater than 2^52 may not decode to\n * the exact value of the encoded representation.\n *\n * @augments {Layout}\n */ class NearUInt64BE extends Layout {\n    constructor(property){\n        super(8, property);\n    }\n    /** @override */ decode(b, offset = 0) {\n        const buffer = uint8ArrayToBuffer(b);\n        const hi32 = buffer.readUInt32BE(offset);\n        const lo32 = buffer.readUInt32BE(offset + 4);\n        return roundedInt64(hi32, lo32);\n    }\n    /** @override */ encode(src, b, offset = 0) {\n        const split = divmodInt64(src);\n        const buffer = uint8ArrayToBuffer(b);\n        buffer.writeUInt32BE(split.hi32, offset);\n        buffer.writeUInt32BE(split.lo32, offset + 4);\n        return 8;\n    }\n}\nexports.NearUInt64BE = NearUInt64BE;\n/**\n * Represent a signed 64-bit integer in little-endian format when\n * encoded and as a near integral JavaScript Number when decoded.\n *\n * *Factory*: {@link module:Layout.ns64|ns64}\n *\n * **NOTE** Values with magnitude greater than 2^52 may not decode to\n * the exact value of the encoded representation.\n *\n * @augments {Layout}\n */ class NearInt64 extends Layout {\n    constructor(property){\n        super(8, property);\n    }\n    /** @override */ decode(b, offset = 0) {\n        const buffer = uint8ArrayToBuffer(b);\n        const lo32 = buffer.readUInt32LE(offset);\n        const hi32 = buffer.readInt32LE(offset + 4);\n        return roundedInt64(hi32, lo32);\n    }\n    /** @override */ encode(src, b, offset = 0) {\n        const split = divmodInt64(src);\n        const buffer = uint8ArrayToBuffer(b);\n        buffer.writeUInt32LE(split.lo32, offset);\n        buffer.writeInt32LE(split.hi32, offset + 4);\n        return 8;\n    }\n}\nexports.NearInt64 = NearInt64;\n/**\n * Represent a signed 64-bit integer in big-endian format when\n * encoded and as a near integral JavaScript Number when decoded.\n *\n * *Factory*: {@link module:Layout.ns64be|ns64be}\n *\n * **NOTE** Values with magnitude greater than 2^52 may not decode to\n * the exact value of the encoded representation.\n *\n * @augments {Layout}\n */ class NearInt64BE extends Layout {\n    constructor(property){\n        super(8, property);\n    }\n    /** @override */ decode(b, offset = 0) {\n        const buffer = uint8ArrayToBuffer(b);\n        const hi32 = buffer.readInt32BE(offset);\n        const lo32 = buffer.readUInt32BE(offset + 4);\n        return roundedInt64(hi32, lo32);\n    }\n    /** @override */ encode(src, b, offset = 0) {\n        const split = divmodInt64(src);\n        const buffer = uint8ArrayToBuffer(b);\n        buffer.writeInt32BE(split.hi32, offset);\n        buffer.writeUInt32BE(split.lo32, offset + 4);\n        return 8;\n    }\n}\nexports.NearInt64BE = NearInt64BE;\n/**\n * Represent a 32-bit floating point number in little-endian format.\n *\n * *Factory*: {@link module:Layout.f32|f32}\n *\n * @param {string} [property] - initializer for {@link\n * Layout#property|property}.\n *\n * @augments {Layout}\n */ class Float extends Layout {\n    constructor(property){\n        super(4, property);\n    }\n    /** @override */ decode(b, offset = 0) {\n        return uint8ArrayToBuffer(b).readFloatLE(offset);\n    }\n    /** @override */ encode(src, b, offset = 0) {\n        uint8ArrayToBuffer(b).writeFloatLE(src, offset);\n        return 4;\n    }\n}\nexports.Float = Float;\n/**\n * Represent a 32-bit floating point number in big-endian format.\n *\n * *Factory*: {@link module:Layout.f32be|f32be}\n *\n * @param {string} [property] - initializer for {@link\n * Layout#property|property}.\n *\n * @augments {Layout}\n */ class FloatBE extends Layout {\n    constructor(property){\n        super(4, property);\n    }\n    /** @override */ decode(b, offset = 0) {\n        return uint8ArrayToBuffer(b).readFloatBE(offset);\n    }\n    /** @override */ encode(src, b, offset = 0) {\n        uint8ArrayToBuffer(b).writeFloatBE(src, offset);\n        return 4;\n    }\n}\nexports.FloatBE = FloatBE;\n/**\n * Represent a 64-bit floating point number in little-endian format.\n *\n * *Factory*: {@link module:Layout.f64|f64}\n *\n * @param {string} [property] - initializer for {@link\n * Layout#property|property}.\n *\n * @augments {Layout}\n */ class Double extends Layout {\n    constructor(property){\n        super(8, property);\n    }\n    /** @override */ decode(b, offset = 0) {\n        return uint8ArrayToBuffer(b).readDoubleLE(offset);\n    }\n    /** @override */ encode(src, b, offset = 0) {\n        uint8ArrayToBuffer(b).writeDoubleLE(src, offset);\n        return 8;\n    }\n}\nexports.Double = Double;\n/**\n * Represent a 64-bit floating point number in big-endian format.\n *\n * *Factory*: {@link module:Layout.f64be|f64be}\n *\n * @param {string} [property] - initializer for {@link\n * Layout#property|property}.\n *\n * @augments {Layout}\n */ class DoubleBE extends Layout {\n    constructor(property){\n        super(8, property);\n    }\n    /** @override */ decode(b, offset = 0) {\n        return uint8ArrayToBuffer(b).readDoubleBE(offset);\n    }\n    /** @override */ encode(src, b, offset = 0) {\n        uint8ArrayToBuffer(b).writeDoubleBE(src, offset);\n        return 8;\n    }\n}\nexports.DoubleBE = DoubleBE;\n/**\n * Represent a contiguous sequence of a specific layout as an Array.\n *\n * *Factory*: {@link module:Layout.seq|seq}\n *\n * @param {Layout} elementLayout - initializer for {@link\n * Sequence#elementLayout|elementLayout}.\n *\n * @param {(Number|ExternalLayout)} count - initializer for {@link\n * Sequence#count|count}.  The parameter must be either a positive\n * integer or an instance of {@link ExternalLayout}.\n *\n * @param {string} [property] - initializer for {@link\n * Layout#property|property}.\n *\n * @augments {Layout}\n */ class Sequence extends Layout {\n    constructor(elementLayout, count, property){\n        if (!(elementLayout instanceof Layout)) {\n            throw new TypeError(\"elementLayout must be a Layout\");\n        }\n        if (!(count instanceof ExternalLayout && count.isCount() || Number.isInteger(count) && 0 <= count)) {\n            throw new TypeError(\"count must be non-negative integer \" + \"or an unsigned integer ExternalLayout\");\n        }\n        let span = -1;\n        if (!(count instanceof ExternalLayout) && 0 < elementLayout.span) {\n            span = count * elementLayout.span;\n        }\n        super(span, property);\n        /** The layout for individual elements of the sequence. */ this.elementLayout = elementLayout;\n        /** The number of elements in the sequence.\n         *\n         * This will be either a non-negative integer or an instance of\n         * {@link ExternalLayout} for which {@link\n         * ExternalLayout#isCount|isCount()} is `true`. */ this.count = count;\n    }\n    /** @override */ getSpan(b, offset = 0) {\n        if (0 <= this.span) {\n            return this.span;\n        }\n        let span = 0;\n        let count = this.count;\n        if (count instanceof ExternalLayout) {\n            count = count.decode(b, offset);\n        }\n        if (0 < this.elementLayout.span) {\n            span = count * this.elementLayout.span;\n        } else {\n            let idx = 0;\n            while(idx < count){\n                span += this.elementLayout.getSpan(b, offset + span);\n                ++idx;\n            }\n        }\n        return span;\n    }\n    /** @override */ decode(b, offset = 0) {\n        const rv = [];\n        let i = 0;\n        let count = this.count;\n        if (count instanceof ExternalLayout) {\n            count = count.decode(b, offset);\n        }\n        while(i < count){\n            rv.push(this.elementLayout.decode(b, offset));\n            offset += this.elementLayout.getSpan(b, offset);\n            i += 1;\n        }\n        return rv;\n    }\n    /** Implement {@link Layout#encode|encode} for {@link Sequence}.\n     *\n     * **NOTE** If `src` is shorter than {@link Sequence#count|count} then\n     * the unused space in the buffer is left unchanged.  If `src` is\n     * longer than {@link Sequence#count|count} the unneeded elements are\n     * ignored.\n     *\n     * **NOTE** If {@link Layout#count|count} is an instance of {@link\n     * ExternalLayout} then the length of `src` will be encoded as the\n     * count after `src` is encoded. */ encode(src, b, offset = 0) {\n        const elo = this.elementLayout;\n        const span = src.reduce((span, v)=>{\n            return span + elo.encode(v, b, offset + span);\n        }, 0);\n        if (this.count instanceof ExternalLayout) {\n            this.count.encode(src.length, b, offset);\n        }\n        return span;\n    }\n}\nexports.Sequence = Sequence;\n/**\n * Represent a contiguous sequence of arbitrary layout elements as an\n * Object.\n *\n * *Factory*: {@link module:Layout.struct|struct}\n *\n * **NOTE** The {@link Layout#span|span} of the structure is variable\n * if any layout in {@link Structure#fields|fields} has a variable\n * span.  When {@link Layout#encode|encoding} we must have a value for\n * all variable-length fields, or we wouldn't be able to figure out\n * how much space to use for storage.  We can only identify the value\n * for a field when it has a {@link Layout#property|property}.  As\n * such, although a structure may contain both unnamed fields and\n * variable-length fields, it cannot contain an unnamed\n * variable-length field.\n *\n * @param {Layout[]} fields - initializer for {@link\n * Structure#fields|fields}.  An error is raised if this contains a\n * variable-length field for which a {@link Layout#property|property}\n * is not defined.\n *\n * @param {string} [property] - initializer for {@link\n * Layout#property|property}.\n *\n * @param {Boolean} [decodePrefixes] - initializer for {@link\n * Structure#decodePrefixes|property}.\n *\n * @throws {Error} - if `fields` contains an unnamed variable-length\n * layout.\n *\n * @augments {Layout}\n */ class Structure extends Layout {\n    constructor(fields, property, decodePrefixes){\n        if (!(Array.isArray(fields) && fields.reduce((acc, v)=>acc && v instanceof Layout, true))) {\n            throw new TypeError(\"fields must be array of Layout instances\");\n        }\n        if (\"boolean\" === typeof property && undefined === decodePrefixes) {\n            decodePrefixes = property;\n            property = undefined;\n        }\n        /* Verify absence of unnamed variable-length fields. */ for (const fd of fields){\n            if (0 > fd.span && undefined === fd.property) {\n                throw new Error(\"fields cannot contain unnamed variable-length layout\");\n            }\n        }\n        let span = -1;\n        try {\n            span = fields.reduce((span, fd)=>span + fd.getSpan(), 0);\n        } catch (e) {\n        // ignore error\n        }\n        super(span, property);\n        /** The sequence of {@link Layout} values that comprise the\n         * structure.\n         *\n         * The individual elements need not be the same type, and may be\n         * either scalar or aggregate layouts.  If a member layout leaves\n         * its {@link Layout#property|property} undefined the\n         * corresponding region of the buffer associated with the element\n         * will not be mutated.\n         *\n         * @type {Layout[]} */ this.fields = fields;\n        /** Control behavior of {@link Layout#decode|decode()} given short\n         * buffers.\n         *\n         * In some situations a structure many be extended with additional\n         * fields over time, with older installations providing only a\n         * prefix of the full structure.  If this property is `true`\n         * decoding will accept those buffers and leave subsequent fields\n         * undefined, as long as the buffer ends at a field boundary.\n         * Defaults to `false`. */ this.decodePrefixes = !!decodePrefixes;\n    }\n    /** @override */ getSpan(b, offset = 0) {\n        if (0 <= this.span) {\n            return this.span;\n        }\n        let span = 0;\n        try {\n            span = this.fields.reduce((span, fd)=>{\n                const fsp = fd.getSpan(b, offset);\n                offset += fsp;\n                return span + fsp;\n            }, 0);\n        } catch (e) {\n            throw new RangeError(\"indeterminate span\");\n        }\n        return span;\n    }\n    /** @override */ decode(b, offset = 0) {\n        checkUint8Array(b);\n        const dest = this.makeDestinationObject();\n        for (const fd of this.fields){\n            if (undefined !== fd.property) {\n                dest[fd.property] = fd.decode(b, offset);\n            }\n            offset += fd.getSpan(b, offset);\n            if (this.decodePrefixes && b.length === offset) {\n                break;\n            }\n        }\n        return dest;\n    }\n    /** Implement {@link Layout#encode|encode} for {@link Structure}.\n     *\n     * If `src` is missing a property for a member with a defined {@link\n     * Layout#property|property} the corresponding region of the buffer is\n     * left unmodified. */ encode(src, b, offset = 0) {\n        const firstOffset = offset;\n        let lastOffset = 0;\n        let lastWrote = 0;\n        for (const fd of this.fields){\n            let span = fd.span;\n            lastWrote = 0 < span ? span : 0;\n            if (undefined !== fd.property) {\n                const fv = src[fd.property];\n                if (undefined !== fv) {\n                    lastWrote = fd.encode(fv, b, offset);\n                    if (0 > span) {\n                        /* Read the as-encoded span, which is not necessarily the\n                         * same as what we wrote. */ span = fd.getSpan(b, offset);\n                    }\n                }\n            }\n            lastOffset = offset;\n            offset += span;\n        }\n        /* Use (lastOffset + lastWrote) instead of offset because the last\n         * item may have had a dynamic length and we don't want to include\n         * the padding between it and the end of the space reserved for\n         * it. */ return lastOffset + lastWrote - firstOffset;\n    }\n    /** @override */ fromArray(values) {\n        const dest = this.makeDestinationObject();\n        for (const fd of this.fields){\n            if (undefined !== fd.property && 0 < values.length) {\n                dest[fd.property] = values.shift();\n            }\n        }\n        return dest;\n    }\n    /**\n     * Get access to the layout of a given property.\n     *\n     * @param {String} property - the structure member of interest.\n     *\n     * @return {Layout} - the layout associated with `property`, or\n     * undefined if there is no such property.\n     */ layoutFor(property) {\n        if (\"string\" !== typeof property) {\n            throw new TypeError(\"property must be string\");\n        }\n        for (const fd of this.fields){\n            if (fd.property === property) {\n                return fd;\n            }\n        }\n        return undefined;\n    }\n    /**\n     * Get the offset of a structure member.\n     *\n     * @param {String} property - the structure member of interest.\n     *\n     * @return {Number} - the offset in bytes to the start of `property`\n     * within the structure, or undefined if `property` is not a field\n     * within the structure.  If the property is a member but follows a\n     * variable-length structure member a negative number will be\n     * returned.\n     */ offsetOf(property) {\n        if (\"string\" !== typeof property) {\n            throw new TypeError(\"property must be string\");\n        }\n        let offset = 0;\n        for (const fd of this.fields){\n            if (fd.property === property) {\n                return offset;\n            }\n            if (0 > fd.span) {\n                offset = -1;\n            } else if (0 <= offset) {\n                offset += fd.span;\n            }\n        }\n        return undefined;\n    }\n}\nexports.Structure = Structure;\n/**\n * An object that can provide a {@link\n * Union#discriminator|discriminator} API for {@link Union}.\n *\n * **NOTE** This is an abstract base class; you can create instances\n * if it amuses you, but they won't support the {@link\n * UnionDiscriminator#encode|encode} or {@link\n * UnionDiscriminator#decode|decode} functions.\n *\n * @param {string} [property] - Default for {@link\n * UnionDiscriminator#property|property}.\n *\n * @abstract\n */ class UnionDiscriminator {\n    constructor(property){\n        /** The {@link Layout#property|property} to be used when the\n         * discriminator is referenced in isolation (generally when {@link\n         * Union#decode|Union decode} cannot delegate to a specific\n         * variant). */ this.property = property;\n    }\n    /** Analog to {@link Layout#decode|Layout decode} for union discriminators.\n     *\n     * The implementation of this method need not reference the buffer if\n     * variant information is available through other means. */ decode(b, offset) {\n        throw new Error(\"UnionDiscriminator is abstract\");\n    }\n    /** Analog to {@link Layout#decode|Layout encode} for union discriminators.\n     *\n     * The implementation of this method need not store the value if\n     * variant information is maintained through other means. */ encode(src, b, offset) {\n        throw new Error(\"UnionDiscriminator is abstract\");\n    }\n}\nexports.UnionDiscriminator = UnionDiscriminator;\n/**\n * An object that can provide a {@link\n * UnionDiscriminator|discriminator API} for {@link Union} using an\n * unsigned integral {@link Layout} instance located either inside or\n * outside the union.\n *\n * @param {ExternalLayout} layout - initializes {@link\n * UnionLayoutDiscriminator#layout|layout}.  Must satisfy {@link\n * ExternalLayout#isCount|isCount()}.\n *\n * @param {string} [property] - Default for {@link\n * UnionDiscriminator#property|property}, superseding the property\n * from `layout`, but defaulting to `variant` if neither `property`\n * nor layout provide a property name.\n *\n * @augments {UnionDiscriminator}\n */ class UnionLayoutDiscriminator extends UnionDiscriminator {\n    constructor(layout, property){\n        if (!(layout instanceof ExternalLayout && layout.isCount())) {\n            throw new TypeError(\"layout must be an unsigned integer ExternalLayout\");\n        }\n        super(property || layout.property || \"variant\");\n        /** The {@link ExternalLayout} used to access the discriminator\n         * value. */ this.layout = layout;\n    }\n    /** Delegate decoding to {@link UnionLayoutDiscriminator#layout|layout}. */ decode(b, offset) {\n        return this.layout.decode(b, offset);\n    }\n    /** Delegate encoding to {@link UnionLayoutDiscriminator#layout|layout}. */ encode(src, b, offset) {\n        return this.layout.encode(src, b, offset);\n    }\n}\nexports.UnionLayoutDiscriminator = UnionLayoutDiscriminator;\n/**\n * Represent any number of span-compatible layouts.\n *\n * *Factory*: {@link module:Layout.union|union}\n *\n * If the union has a {@link Union#defaultLayout|default layout} that\n * layout must have a non-negative {@link Layout#span|span}.  The span\n * of a fixed-span union includes its {@link\n * Union#discriminator|discriminator} if the variant is a {@link\n * Union#usesPrefixDiscriminator|prefix of the union}, plus the span\n * of its {@link Union#defaultLayout|default layout}.\n *\n * If the union does not have a default layout then the encoded span\n * of the union depends on the encoded span of its variant (which may\n * be fixed or variable).\n *\n * {@link VariantLayout#layout|Variant layout}s are added through\n * {@link Union#addVariant|addVariant}.  If the union has a default\n * layout, the span of the {@link VariantLayout#layout|layout\n * contained by the variant} must not exceed the span of the {@link\n * Union#defaultLayout|default layout} (minus the span of a {@link\n * Union#usesPrefixDiscriminator|prefix disriminator}, if used).  The\n * span of the variant will equal the span of the union itself.\n *\n * The variant for a buffer can only be identified from the {@link\n * Union#discriminator|discriminator} {@link\n * UnionDiscriminator#property|property} (in the case of the {@link\n * Union#defaultLayout|default layout}), or by using {@link\n * Union#getVariant|getVariant} and examining the resulting {@link\n * VariantLayout} instance.\n *\n * A variant compatible with a JavaScript object can be identified\n * using {@link Union#getSourceVariant|getSourceVariant}.\n *\n * @param {(UnionDiscriminator|ExternalLayout|Layout)} discr - How to\n * identify the layout used to interpret the union contents.  The\n * parameter must be an instance of {@link UnionDiscriminator}, an\n * {@link ExternalLayout} that satisfies {@link\n * ExternalLayout#isCount|isCount()}, or {@link UInt} (or {@link\n * UIntBE}).  When a non-external layout element is passed the layout\n * appears at the start of the union.  In all cases the (synthesized)\n * {@link UnionDiscriminator} instance is recorded as {@link\n * Union#discriminator|discriminator}.\n *\n * @param {(Layout|null)} defaultLayout - initializer for {@link\n * Union#defaultLayout|defaultLayout}.  If absent defaults to `null`.\n * If `null` there is no default layout: the union has data-dependent\n * length and attempts to decode or encode unrecognized variants will\n * throw an exception.  A {@link Layout} instance must have a\n * non-negative {@link Layout#span|span}, and if it lacks a {@link\n * Layout#property|property} the {@link\n * Union#defaultLayout|defaultLayout} will be a {@link\n * Layout#replicate|replica} with property `content`.\n *\n * @param {string} [property] - initializer for {@link\n * Layout#property|property}.\n *\n * @augments {Layout}\n */ class Union extends Layout {\n    constructor(discr, defaultLayout, property){\n        let discriminator;\n        if (discr instanceof UInt || discr instanceof UIntBE) {\n            discriminator = new UnionLayoutDiscriminator(new OffsetLayout(discr));\n        } else if (discr instanceof ExternalLayout && discr.isCount()) {\n            discriminator = new UnionLayoutDiscriminator(discr);\n        } else if (!(discr instanceof UnionDiscriminator)) {\n            throw new TypeError(\"discr must be a UnionDiscriminator \" + \"or an unsigned integer layout\");\n        } else {\n            discriminator = discr;\n        }\n        if (undefined === defaultLayout) {\n            defaultLayout = null;\n        }\n        if (!(null === defaultLayout || defaultLayout instanceof Layout)) {\n            throw new TypeError(\"defaultLayout must be null or a Layout\");\n        }\n        if (null !== defaultLayout) {\n            if (0 > defaultLayout.span) {\n                throw new Error(\"defaultLayout must have constant span\");\n            }\n            if (undefined === defaultLayout.property) {\n                defaultLayout = defaultLayout.replicate(\"content\");\n            }\n        }\n        /* The union span can be estimated only if there's a default\n         * layout.  The union spans its default layout, plus any prefix\n         * variant layout.  By construction both layouts, if present, have\n         * non-negative span. */ let span = -1;\n        if (defaultLayout) {\n            span = defaultLayout.span;\n            if (0 <= span && (discr instanceof UInt || discr instanceof UIntBE)) {\n                span += discriminator.layout.span;\n            }\n        }\n        super(span, property);\n        /** The interface for the discriminator value in isolation.\n         *\n         * This a {@link UnionDiscriminator} either passed to the\n         * constructor or synthesized from the `discr` constructor\n         * argument.  {@link\n         * Union#usesPrefixDiscriminator|usesPrefixDiscriminator} will be\n         * `true` iff the `discr` parameter was a non-offset {@link\n         * Layout} instance. */ this.discriminator = discriminator;\n        /** `true` if the {@link Union#discriminator|discriminator} is the\n         * first field in the union.\n         *\n         * If `false` the discriminator is obtained from somewhere\n         * else. */ this.usesPrefixDiscriminator = discr instanceof UInt || discr instanceof UIntBE;\n        /** The layout for non-discriminator content when the value of the\n         * discriminator is not recognized.\n         *\n         * This is the value passed to the constructor.  It is\n         * structurally equivalent to the second component of {@link\n         * Union#layout|layout} but may have a different property\n         * name. */ this.defaultLayout = defaultLayout;\n        /** A registry of allowed variants.\n         *\n         * The keys are unsigned integers which should be compatible with\n         * {@link Union.discriminator|discriminator}.  The property value\n         * is the corresponding {@link VariantLayout} instances assigned\n         * to this union by {@link Union#addVariant|addVariant}.\n         *\n         * **NOTE** The registry remains mutable so that variants can be\n         * {@link Union#addVariant|added} at any time.  Users should not\n         * manipulate the content of this property. */ this.registry = {};\n        /* Private variable used when invoking getSourceVariant */ let boundGetSourceVariant = this.defaultGetSourceVariant.bind(this);\n        /** Function to infer the variant selected by a source object.\n         *\n         * Defaults to {@link\n         * Union#defaultGetSourceVariant|defaultGetSourceVariant} but may\n         * be overridden using {@link\n         * Union#configGetSourceVariant|configGetSourceVariant}.\n         *\n         * @param {Object} src - as with {@link\n         * Union#defaultGetSourceVariant|defaultGetSourceVariant}.\n         *\n         * @returns {(undefined|VariantLayout)} The default variant\n         * (`undefined`) or first registered variant that uses a property\n         * available in `src`. */ this.getSourceVariant = function(src) {\n            return boundGetSourceVariant(src);\n        };\n        /** Function to override the implementation of {@link\n         * Union#getSourceVariant|getSourceVariant}.\n         *\n         * Use this if the desired variant cannot be identified using the\n         * algorithm of {@link\n         * Union#defaultGetSourceVariant|defaultGetSourceVariant}.\n         *\n         * **NOTE** The provided function will be invoked bound to this\n         * Union instance, providing local access to {@link\n         * Union#registry|registry}.\n         *\n         * @param {Function} gsv - a function that follows the API of\n         * {@link Union#defaultGetSourceVariant|defaultGetSourceVariant}. */ this.configGetSourceVariant = function(gsv) {\n            boundGetSourceVariant = gsv.bind(this);\n        };\n    }\n    /** @override */ getSpan(b, offset = 0) {\n        if (0 <= this.span) {\n            return this.span;\n        }\n        /* Default layouts always have non-negative span, so we don't have\n         * one and we have to recognize the variant which will in turn\n         * determine the span. */ const vlo = this.getVariant(b, offset);\n        if (!vlo) {\n            throw new Error(\"unable to determine span for unrecognized variant\");\n        }\n        return vlo.getSpan(b, offset);\n    }\n    /**\n     * Method to infer a registered Union variant compatible with `src`.\n     *\n     * The first satisfied rule in the following sequence defines the\n     * return value:\n     * * If `src` has properties matching the Union discriminator and\n     *   the default layout, `undefined` is returned regardless of the\n     *   value of the discriminator property (this ensures the default\n     *   layout will be used);\n     * * If `src` has a property matching the Union discriminator, the\n     *   value of the discriminator identifies a registered variant, and\n     *   either (a) the variant has no layout, or (b) `src` has the\n     *   variant's property, then the variant is returned (because the\n     *   source satisfies the constraints of the variant it identifies);\n     * * If `src` does not have a property matching the Union\n     *   discriminator, but does have a property matching a registered\n     *   variant, then the variant is returned (because the source\n     *   matches a variant without an explicit conflict);\n     * * An error is thrown (because we either can't identify a variant,\n     *   or we were explicitly told the variant but can't satisfy it).\n     *\n     * @param {Object} src - an object presumed to be compatible with\n     * the content of the Union.\n     *\n     * @return {(undefined|VariantLayout)} - as described above.\n     *\n     * @throws {Error} - if `src` cannot be associated with a default or\n     * registered variant.\n     */ defaultGetSourceVariant(src) {\n        if (Object.prototype.hasOwnProperty.call(src, this.discriminator.property)) {\n            if (this.defaultLayout && this.defaultLayout.property && Object.prototype.hasOwnProperty.call(src, this.defaultLayout.property)) {\n                return undefined;\n            }\n            const vlo = this.registry[src[this.discriminator.property]];\n            if (vlo && (!vlo.layout || vlo.property && Object.prototype.hasOwnProperty.call(src, vlo.property))) {\n                return vlo;\n            }\n        } else {\n            for(const tag in this.registry){\n                const vlo = this.registry[tag];\n                if (vlo.property && Object.prototype.hasOwnProperty.call(src, vlo.property)) {\n                    return vlo;\n                }\n            }\n        }\n        throw new Error(\"unable to infer src variant\");\n    }\n    /** Implement {@link Layout#decode|decode} for {@link Union}.\n     *\n     * If the variant is {@link Union#addVariant|registered} the return\n     * value is an instance of that variant, with no explicit\n     * discriminator.  Otherwise the {@link Union#defaultLayout|default\n     * layout} is used to decode the content. */ decode(b, offset = 0) {\n        let dest;\n        const dlo = this.discriminator;\n        const discr = dlo.decode(b, offset);\n        const clo = this.registry[discr];\n        if (undefined === clo) {\n            const defaultLayout = this.defaultLayout;\n            let contentOffset = 0;\n            if (this.usesPrefixDiscriminator) {\n                contentOffset = dlo.layout.span;\n            }\n            dest = this.makeDestinationObject();\n            dest[dlo.property] = discr;\n            // defaultLayout.property can be undefined, but this is allowed by buffer-layout\n            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n            dest[defaultLayout.property] = defaultLayout.decode(b, offset + contentOffset);\n        } else {\n            dest = clo.decode(b, offset);\n        }\n        return dest;\n    }\n    /** Implement {@link Layout#encode|encode} for {@link Union}.\n     *\n     * This API assumes the `src` object is consistent with the union's\n     * {@link Union#defaultLayout|default layout}.  To encode variants\n     * use the appropriate variant-specific {@link VariantLayout#encode}\n     * method. */ encode(src, b, offset = 0) {\n        const vlo = this.getSourceVariant(src);\n        if (undefined === vlo) {\n            const dlo = this.discriminator;\n            // this.defaultLayout is not undefined when vlo is undefined\n            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n            const clo = this.defaultLayout;\n            let contentOffset = 0;\n            if (this.usesPrefixDiscriminator) {\n                contentOffset = dlo.layout.span;\n            }\n            dlo.encode(src[dlo.property], b, offset);\n            // clo.property is not undefined when vlo is undefined\n            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n            return contentOffset + clo.encode(src[clo.property], b, offset + contentOffset);\n        }\n        return vlo.encode(src, b, offset);\n    }\n    /** Register a new variant structure within a union.  The newly\n     * created variant is returned.\n     *\n     * @param {Number} variant - initializer for {@link\n     * VariantLayout#variant|variant}.\n     *\n     * @param {Layout} layout - initializer for {@link\n     * VariantLayout#layout|layout}.\n     *\n     * @param {String} property - initializer for {@link\n     * Layout#property|property}.\n     *\n     * @return {VariantLayout} */ addVariant(variant, layout, property) {\n        const rv = new VariantLayout(this, variant, layout, property);\n        this.registry[variant] = rv;\n        return rv;\n    }\n    /**\n     * Get the layout associated with a registered variant.\n     *\n     * If `vb` does not produce a registered variant the function returns\n     * `undefined`.\n     *\n     * @param {(Number|Uint8Array)} vb - either the variant number, or a\n     * buffer from which the discriminator is to be read.\n     *\n     * @param {Number} offset - offset into `vb` for the start of the\n     * union.  Used only when `vb` is an instance of {Uint8Array}.\n     *\n     * @return {({VariantLayout}|undefined)}\n     */ getVariant(vb, offset = 0) {\n        let variant;\n        if (vb instanceof Uint8Array) {\n            variant = this.discriminator.decode(vb, offset);\n        } else {\n            variant = vb;\n        }\n        return this.registry[variant];\n    }\n}\nexports.Union = Union;\n/**\n * Represent a specific variant within a containing union.\n *\n * **NOTE** The {@link Layout#span|span} of the variant may include\n * the span of the {@link Union#discriminator|discriminator} used to\n * identify it, but values read and written using the variant strictly\n * conform to the content of {@link VariantLayout#layout|layout}.\n *\n * **NOTE** User code should not invoke this constructor directly.  Use\n * the union {@link Union#addVariant|addVariant} helper method.\n *\n * @param {Union} union - initializer for {@link\n * VariantLayout#union|union}.\n *\n * @param {Number} variant - initializer for {@link\n * VariantLayout#variant|variant}.\n *\n * @param {Layout} [layout] - initializer for {@link\n * VariantLayout#layout|layout}.  If absent the variant carries no\n * data.\n *\n * @param {String} [property] - initializer for {@link\n * Layout#property|property}.  Unlike many other layouts, variant\n * layouts normally include a property name so they can be identified\n * within their containing {@link Union}.  The property identifier may\n * be absent only if `layout` is is absent.\n *\n * @augments {Layout}\n */ class VariantLayout extends Layout {\n    constructor(union, variant, layout, property){\n        if (!(union instanceof Union)) {\n            throw new TypeError(\"union must be a Union\");\n        }\n        if (!Number.isInteger(variant) || 0 > variant) {\n            throw new TypeError(\"variant must be a (non-negative) integer\");\n        }\n        if (\"string\" === typeof layout && undefined === property) {\n            property = layout;\n            layout = null;\n        }\n        if (layout) {\n            if (!(layout instanceof Layout)) {\n                throw new TypeError(\"layout must be a Layout\");\n            }\n            if (null !== union.defaultLayout && 0 <= layout.span && layout.span > union.defaultLayout.span) {\n                throw new Error(\"variant span exceeds span of containing union\");\n            }\n            if (\"string\" !== typeof property) {\n                throw new TypeError(\"variant must have a String property\");\n            }\n        }\n        let span = union.span;\n        if (0 > union.span) {\n            span = layout ? layout.span : 0;\n            if (0 <= span && union.usesPrefixDiscriminator) {\n                span += union.discriminator.layout.span;\n            }\n        }\n        super(span, property);\n        /** The {@link Union} to which this variant belongs. */ this.union = union;\n        /** The unsigned integral value identifying this variant within\n         * the {@link Union#discriminator|discriminator} of the containing\n         * union. */ this.variant = variant;\n        /** The {@link Layout} to be used when reading/writing the\n         * non-discriminator part of the {@link\n         * VariantLayout#union|union}.  If `null` the variant carries no\n         * data. */ this.layout = layout || null;\n    }\n    /** @override */ getSpan(b, offset = 0) {\n        if (0 <= this.span) {\n            /* Will be equal to the containing union span if that is not\n             * variable. */ return this.span;\n        }\n        let contentOffset = 0;\n        if (this.union.usesPrefixDiscriminator) {\n            contentOffset = this.union.discriminator.layout.span;\n        }\n        /* Span is defined solely by the variant (and prefix discriminator) */ let span = 0;\n        if (this.layout) {\n            span = this.layout.getSpan(b, offset + contentOffset);\n        }\n        return contentOffset + span;\n    }\n    /** @override */ decode(b, offset = 0) {\n        const dest = this.makeDestinationObject();\n        if (this !== this.union.getVariant(b, offset)) {\n            throw new Error(\"variant mismatch\");\n        }\n        let contentOffset = 0;\n        if (this.union.usesPrefixDiscriminator) {\n            contentOffset = this.union.discriminator.layout.span;\n        }\n        if (this.layout) {\n            dest[this.property] = this.layout.decode(b, offset + contentOffset);\n        } else if (this.property) {\n            dest[this.property] = true;\n        } else if (this.union.usesPrefixDiscriminator) {\n            dest[this.union.discriminator.property] = this.variant;\n        }\n        return dest;\n    }\n    /** @override */ encode(src, b, offset = 0) {\n        let contentOffset = 0;\n        if (this.union.usesPrefixDiscriminator) {\n            contentOffset = this.union.discriminator.layout.span;\n        }\n        if (this.layout && !Object.prototype.hasOwnProperty.call(src, this.property)) {\n            throw new TypeError(\"variant lacks property \" + this.property);\n        }\n        this.union.discriminator.encode(this.variant, b, offset);\n        let span = contentOffset;\n        if (this.layout) {\n            this.layout.encode(src[this.property], b, offset + contentOffset);\n            span += this.layout.getSpan(b, offset + contentOffset);\n            if (0 <= this.union.span && span > this.union.span) {\n                throw new Error(\"encoded variant overruns containing union\");\n            }\n        }\n        return span;\n    }\n    /** Delegate {@link Layout#fromArray|fromArray} to {@link\n     * VariantLayout#layout|layout}. */ fromArray(values) {\n        if (this.layout) {\n            return this.layout.fromArray(values);\n        }\n        return undefined;\n    }\n}\nexports.VariantLayout = VariantLayout;\n/** JavaScript chose to define bitwise operations as operating on\n * signed 32-bit values in 2's complement form, meaning any integer\n * with bit 31 set is going to look negative.  For right shifts that's\n * not a problem, because `>>>` is a logical shift, but for every\n * other bitwise operator we have to compensate for possible negative\n * results. */ function fixBitwiseResult(v) {\n    if (0 > v) {\n        v += 0x100000000;\n    }\n    return v;\n}\n/**\n * Contain a sequence of bit fields as an unsigned integer.\n *\n * *Factory*: {@link module:Layout.bits|bits}\n *\n * This is a container element; within it there are {@link BitField}\n * instances that provide the extracted properties.  The container\n * simply defines the aggregate representation and its bit ordering.\n * The representation is an object containing properties with numeric\n * or {@link Boolean} values.\n *\n * {@link BitField}s are added with the {@link\n * BitStructure#addField|addField} and {@link\n * BitStructure#addBoolean|addBoolean} methods.\n\n * @param {Layout} word - initializer for {@link\n * BitStructure#word|word}.  The parameter must be an instance of\n * {@link UInt} (or {@link UIntBE}) that is no more than 4 bytes wide.\n *\n * @param {bool} [msb] - `true` if the bit numbering starts at the\n * most significant bit of the containing word; `false` (default) if\n * it starts at the least significant bit of the containing word.  If\n * the parameter at this position is a string and `property` is\n * `undefined` the value of this argument will instead be used as the\n * value of `property`.\n *\n * @param {string} [property] - initializer for {@link\n * Layout#property|property}.\n *\n * @augments {Layout}\n */ class BitStructure extends Layout {\n    constructor(word, msb, property){\n        if (!(word instanceof UInt || word instanceof UIntBE)) {\n            throw new TypeError(\"word must be a UInt or UIntBE layout\");\n        }\n        if (\"string\" === typeof msb && undefined === property) {\n            property = msb;\n            msb = false;\n        }\n        if (4 < word.span) {\n            throw new RangeError(\"word cannot exceed 32 bits\");\n        }\n        super(word.span, property);\n        /** The layout used for the packed value.  {@link BitField}\n         * instances are packed sequentially depending on {@link\n         * BitStructure#msb|msb}. */ this.word = word;\n        /** Whether the bit sequences are packed starting at the most\n         * significant bit growing down (`true`), or the least significant\n         * bit growing up (`false`).\n         *\n         * **NOTE** Regardless of this value, the least significant bit of\n         * any {@link BitField} value is the least significant bit of the\n         * corresponding section of the packed value. */ this.msb = !!msb;\n        /** The sequence of {@link BitField} layouts that comprise the\n         * packed structure.\n         *\n         * **NOTE** The array remains mutable to allow fields to be {@link\n         * BitStructure#addField|added} after construction.  Users should\n         * not manipulate the content of this property.*/ this.fields = [];\n        /* Storage for the value.  Capture a variable instead of using an\n         * instance property because we don't want anything to change the\n         * value without going through the mutator. */ let value = 0;\n        this._packedSetValue = function(v) {\n            value = fixBitwiseResult(v);\n            return this;\n        };\n        this._packedGetValue = function() {\n            return value;\n        };\n    }\n    /** @override */ decode(b, offset = 0) {\n        const dest = this.makeDestinationObject();\n        const value = this.word.decode(b, offset);\n        this._packedSetValue(value);\n        for (const fd of this.fields){\n            if (undefined !== fd.property) {\n                dest[fd.property] = fd.decode(b);\n            }\n        }\n        return dest;\n    }\n    /** Implement {@link Layout#encode|encode} for {@link BitStructure}.\n     *\n     * If `src` is missing a property for a member with a defined {@link\n     * Layout#property|property} the corresponding region of the packed\n     * value is left unmodified.  Unused bits are also left unmodified. */ encode(src, b, offset = 0) {\n        const value = this.word.decode(b, offset);\n        this._packedSetValue(value);\n        for (const fd of this.fields){\n            if (undefined !== fd.property) {\n                const fv = src[fd.property];\n                if (undefined !== fv) {\n                    fd.encode(fv);\n                }\n            }\n        }\n        return this.word.encode(this._packedGetValue(), b, offset);\n    }\n    /** Register a new bitfield with a containing bit structure.  The\n     * resulting bitfield is returned.\n     *\n     * @param {Number} bits - initializer for {@link BitField#bits|bits}.\n     *\n     * @param {string} property - initializer for {@link\n     * Layout#property|property}.\n     *\n     * @return {BitField} */ addField(bits, property) {\n        const bf = new BitField(this, bits, property);\n        this.fields.push(bf);\n        return bf;\n    }\n    /** As with {@link BitStructure#addField|addField} for single-bit\n     * fields with `boolean` value representation.\n     *\n     * @param {string} property - initializer for {@link\n     * Layout#property|property}.\n     *\n     * @return {Boolean} */ // `Boolean` conflicts with the native primitive type\n    // eslint-disable-next-line @typescript-eslint/ban-types\n    addBoolean(property) {\n        // This is my Boolean, not the Javascript one.\n        const bf = new Boolean(this, property);\n        this.fields.push(bf);\n        return bf;\n    }\n    /**\n     * Get access to the bit field for a given property.\n     *\n     * @param {String} property - the bit field of interest.\n     *\n     * @return {BitField} - the field associated with `property`, or\n     * undefined if there is no such property.\n     */ fieldFor(property) {\n        if (\"string\" !== typeof property) {\n            throw new TypeError(\"property must be string\");\n        }\n        for (const fd of this.fields){\n            if (fd.property === property) {\n                return fd;\n            }\n        }\n        return undefined;\n    }\n}\nexports.BitStructure = BitStructure;\n/**\n * Represent a sequence of bits within a {@link BitStructure}.\n *\n * All bit field values are represented as unsigned integers.\n *\n * **NOTE** User code should not invoke this constructor directly.\n * Use the container {@link BitStructure#addField|addField} helper\n * method.\n *\n * **NOTE** BitField instances are not instances of {@link Layout}\n * since {@link Layout#span|span} measures 8-bit units.\n *\n * @param {BitStructure} container - initializer for {@link\n * BitField#container|container}.\n *\n * @param {Number} bits - initializer for {@link BitField#bits|bits}.\n *\n * @param {string} [property] - initializer for {@link\n * Layout#property|property}.\n */ class BitField {\n    constructor(container, bits, property){\n        if (!(container instanceof BitStructure)) {\n            throw new TypeError(\"container must be a BitStructure\");\n        }\n        if (!Number.isInteger(bits) || 0 >= bits) {\n            throw new TypeError(\"bits must be positive integer\");\n        }\n        const totalBits = 8 * container.span;\n        const usedBits = container.fields.reduce((sum, fd)=>sum + fd.bits, 0);\n        if (bits + usedBits > totalBits) {\n            throw new Error(\"bits too long for span remainder (\" + (totalBits - usedBits) + \" of \" + totalBits + \" remain)\");\n        }\n        /** The {@link BitStructure} instance to which this bit field\n         * belongs. */ this.container = container;\n        /** The span of this value in bits. */ this.bits = bits;\n        /** A mask of {@link BitField#bits|bits} bits isolating value bits\n         * that fit within the field.\n         *\n         * That is, it masks a value that has not yet been shifted into\n         * position within its containing packed integer. */ this.valueMask = (1 << bits) - 1;\n        if (32 === bits) {\n            this.valueMask = 0xFFFFFFFF;\n        }\n        /** The offset of the value within the containing packed unsigned\n         * integer.  The least significant bit of the packed value is at\n         * offset zero, regardless of bit ordering used. */ this.start = usedBits;\n        if (this.container.msb) {\n            this.start = totalBits - usedBits - bits;\n        }\n        /** A mask of {@link BitField#bits|bits} isolating the field value\n         * within the containing packed unsigned integer. */ this.wordMask = fixBitwiseResult(this.valueMask << this.start);\n        /** The property name used when this bitfield is represented in an\n         * Object.\n         *\n         * Intended to be functionally equivalent to {@link\n         * Layout#property}.\n         *\n         * If left undefined the corresponding span of bits will be\n         * treated as padding: it will not be mutated by {@link\n         * Layout#encode|encode} nor represented as a property in the\n         * decoded Object. */ this.property = property;\n    }\n    /** Store a value into the corresponding subsequence of the containing\n     * bit field. */ decode(b, offset) {\n        const word = this.container._packedGetValue();\n        const wordValue = fixBitwiseResult(word & this.wordMask);\n        const value = wordValue >>> this.start;\n        return value;\n    }\n    /** Store a value into the corresponding subsequence of the containing\n     * bit field.\n     *\n     * **NOTE** This is not a specialization of {@link\n     * Layout#encode|Layout.encode} and there is no return value. */ encode(value) {\n        if (\"number\" !== typeof value || !Number.isInteger(value) || value !== fixBitwiseResult(value & this.valueMask)) {\n            throw new TypeError(nameWithProperty(\"BitField.encode\", this) + \" value must be integer not exceeding \" + this.valueMask);\n        }\n        const word = this.container._packedGetValue();\n        const wordValue = fixBitwiseResult(value << this.start);\n        this.container._packedSetValue(fixBitwiseResult(word & ~this.wordMask) | wordValue);\n    }\n}\nexports.BitField = BitField;\n/**\n * Represent a single bit within a {@link BitStructure} as a\n * JavaScript boolean.\n *\n * **NOTE** User code should not invoke this constructor directly.\n * Use the container {@link BitStructure#addBoolean|addBoolean} helper\n * method.\n *\n * @param {BitStructure} container - initializer for {@link\n * BitField#container|container}.\n *\n * @param {string} [property] - initializer for {@link\n * Layout#property|property}.\n *\n * @augments {BitField}\n */ /* eslint-disable no-extend-native */ class Boolean extends BitField {\n    constructor(container, property){\n        super(container, 1, property);\n    }\n    /** Override {@link BitField#decode|decode} for {@link Boolean|Boolean}.\n     *\n     * @returns {boolean} */ decode(b, offset) {\n        return !!super.decode(b, offset);\n    }\n    /** @override */ encode(value) {\n        if (\"boolean\" === typeof value) {\n            // BitField requires integer values\n            value = +value;\n        }\n        super.encode(value);\n    }\n}\nexports.Boolean = Boolean;\n/* eslint-enable no-extend-native */ /**\n * Contain a fixed-length block of arbitrary data, represented as a\n * Uint8Array.\n *\n * *Factory*: {@link module:Layout.blob|blob}\n *\n * @param {(Number|ExternalLayout)} length - initializes {@link\n * Blob#length|length}.\n *\n * @param {String} [property] - initializer for {@link\n * Layout#property|property}.\n *\n * @augments {Layout}\n */ class Blob extends Layout {\n    constructor(length, property){\n        if (!(length instanceof ExternalLayout && length.isCount() || Number.isInteger(length) && 0 <= length)) {\n            throw new TypeError(\"length must be positive integer \" + \"or an unsigned integer ExternalLayout\");\n        }\n        let span = -1;\n        if (!(length instanceof ExternalLayout)) {\n            span = length;\n        }\n        super(span, property);\n        /** The number of bytes in the blob.\n         *\n         * This may be a non-negative integer, or an instance of {@link\n         * ExternalLayout} that satisfies {@link\n         * ExternalLayout#isCount|isCount()}. */ this.length = length;\n    }\n    /** @override */ getSpan(b, offset) {\n        let span = this.span;\n        if (0 > span) {\n            span = this.length.decode(b, offset);\n        }\n        return span;\n    }\n    /** @override */ decode(b, offset = 0) {\n        let span = this.span;\n        if (0 > span) {\n            span = this.length.decode(b, offset);\n        }\n        return uint8ArrayToBuffer(b).slice(offset, offset + span);\n    }\n    /** Implement {@link Layout#encode|encode} for {@link Blob}.\n     *\n     * **NOTE** If {@link Layout#count|count} is an instance of {@link\n     * ExternalLayout} then the length of `src` will be encoded as the\n     * count after `src` is encoded. */ encode(src, b, offset) {\n        let span = this.length;\n        if (this.length instanceof ExternalLayout) {\n            span = src.length;\n        }\n        if (!(src instanceof Uint8Array && span === src.length)) {\n            throw new TypeError(nameWithProperty(\"Blob.encode\", this) + \" requires (length \" + span + \") Uint8Array as src\");\n        }\n        if (offset + span > b.length) {\n            throw new RangeError(\"encoding overruns Uint8Array\");\n        }\n        const srcBuffer = uint8ArrayToBuffer(src);\n        uint8ArrayToBuffer(b).write(srcBuffer.toString(\"hex\"), offset, span, \"hex\");\n        if (this.length instanceof ExternalLayout) {\n            this.length.encode(span, b, offset);\n        }\n        return span;\n    }\n}\nexports.Blob = Blob;\n/**\n * Contain a `NUL`-terminated UTF8 string.\n *\n * *Factory*: {@link module:Layout.cstr|cstr}\n *\n * **NOTE** Any UTF8 string that incorporates a zero-valued byte will\n * not be correctly decoded by this layout.\n *\n * @param {String} [property] - initializer for {@link\n * Layout#property|property}.\n *\n * @augments {Layout}\n */ class CString extends Layout {\n    constructor(property){\n        super(-1, property);\n    }\n    /** @override */ getSpan(b, offset = 0) {\n        checkUint8Array(b);\n        let idx = offset;\n        while(idx < b.length && 0 !== b[idx]){\n            idx += 1;\n        }\n        return 1 + idx - offset;\n    }\n    /** @override */ decode(b, offset = 0) {\n        const span = this.getSpan(b, offset);\n        return uint8ArrayToBuffer(b).slice(offset, offset + span - 1).toString(\"utf-8\");\n    }\n    /** @override */ encode(src, b, offset = 0) {\n        /* Must force this to a string, lest it be a number and the\n         * \"utf8-encoding\" below actually allocate a buffer of length\n         * src */ if (\"string\" !== typeof src) {\n            src = String(src);\n        }\n        const srcb = buffer_1.Buffer.from(src, \"utf8\");\n        const span = srcb.length;\n        if (offset + span > b.length) {\n            throw new RangeError(\"encoding overruns Buffer\");\n        }\n        const buffer = uint8ArrayToBuffer(b);\n        srcb.copy(buffer, offset);\n        buffer[offset + span] = 0;\n        return span + 1;\n    }\n}\nexports.CString = CString;\n/**\n * Contain a UTF8 string with implicit length.\n *\n * *Factory*: {@link module:Layout.utf8|utf8}\n *\n * **NOTE** Because the length is implicit in the size of the buffer\n * this layout should be used only in isolation, or in a situation\n * where the length can be expressed by operating on a slice of the\n * containing buffer.\n *\n * @param {Number} [maxSpan] - the maximum length allowed for encoded\n * string content.  If not provided there is no bound on the allowed\n * content.\n *\n * @param {String} [property] - initializer for {@link\n * Layout#property|property}.\n *\n * @augments {Layout}\n */ class UTF8 extends Layout {\n    constructor(maxSpan, property){\n        if (\"string\" === typeof maxSpan && undefined === property) {\n            property = maxSpan;\n            maxSpan = undefined;\n        }\n        if (undefined === maxSpan) {\n            maxSpan = -1;\n        } else if (!Number.isInteger(maxSpan)) {\n            throw new TypeError(\"maxSpan must be an integer\");\n        }\n        super(-1, property);\n        /** The maximum span of the layout in bytes.\n         *\n         * Positive values are generally expected.  Zero is abnormal.\n         * Attempts to encode or decode a value that exceeds this length\n         * will throw a `RangeError`.\n         *\n         * A negative value indicates that there is no bound on the length\n         * of the content. */ this.maxSpan = maxSpan;\n    }\n    /** @override */ getSpan(b, offset = 0) {\n        checkUint8Array(b);\n        return b.length - offset;\n    }\n    /** @override */ decode(b, offset = 0) {\n        const span = this.getSpan(b, offset);\n        if (0 <= this.maxSpan && this.maxSpan < span) {\n            throw new RangeError(\"text length exceeds maxSpan\");\n        }\n        return uint8ArrayToBuffer(b).slice(offset, offset + span).toString(\"utf-8\");\n    }\n    /** @override */ encode(src, b, offset = 0) {\n        /* Must force this to a string, lest it be a number and the\n         * \"utf8-encoding\" below actually allocate a buffer of length\n         * src */ if (\"string\" !== typeof src) {\n            src = String(src);\n        }\n        const srcb = buffer_1.Buffer.from(src, \"utf8\");\n        const span = srcb.length;\n        if (0 <= this.maxSpan && this.maxSpan < span) {\n            throw new RangeError(\"text length exceeds maxSpan\");\n        }\n        if (offset + span > b.length) {\n            throw new RangeError(\"encoding overruns Buffer\");\n        }\n        srcb.copy(uint8ArrayToBuffer(b), offset);\n        return span;\n    }\n}\nexports.UTF8 = UTF8;\n/**\n * Contain a constant value.\n *\n * This layout may be used in cases where a JavaScript value can be\n * inferred without an expression in the binary encoding.  An example\n * would be a {@link VariantLayout|variant layout} where the content\n * is implied by the union {@link Union#discriminator|discriminator}.\n *\n * @param {Object|Number|String} value - initializer for {@link\n * Constant#value|value}.  If the value is an object (or array) and\n * the application intends the object to remain unchanged regardless\n * of what is done to values decoded by this layout, the value should\n * be frozen prior passing it to this constructor.\n *\n * @param {String} [property] - initializer for {@link\n * Layout#property|property}.\n *\n * @augments {Layout}\n */ class Constant extends Layout {\n    constructor(value, property){\n        super(0, property);\n        /** The value produced by this constant when the layout is {@link\n         * Constant#decode|decoded}.\n         *\n         * Any JavaScript value including `null` and `undefined` is\n         * permitted.\n         *\n         * **WARNING** If `value` passed in the constructor was not\n         * frozen, it is possible for users of decoded values to change\n         * the content of the value. */ this.value = value;\n    }\n    /** @override */ decode(b, offset) {\n        return this.value;\n    }\n    /** @override */ encode(src, b, offset) {\n        /* Constants take no space */ return 0;\n    }\n}\nexports.Constant = Constant;\n/** Factory for {@link GreedyCount}. */ exports.greedy = (elementSpan, property)=>new GreedyCount(elementSpan, property);\n/** Factory for {@link OffsetLayout}. */ exports.offset = (layout, offset, property)=>new OffsetLayout(layout, offset, property);\n/** Factory for {@link UInt|unsigned int layouts} spanning one\n * byte. */ exports.u8 = (property)=>new UInt(1, property);\n/** Factory for {@link UInt|little-endian unsigned int layouts}\n * spanning two bytes. */ exports.u16 = (property)=>new UInt(2, property);\n/** Factory for {@link UInt|little-endian unsigned int layouts}\n * spanning three bytes. */ exports.u24 = (property)=>new UInt(3, property);\n/** Factory for {@link UInt|little-endian unsigned int layouts}\n * spanning four bytes. */ exports.u32 = (property)=>new UInt(4, property);\n/** Factory for {@link UInt|little-endian unsigned int layouts}\n * spanning five bytes. */ exports.u40 = (property)=>new UInt(5, property);\n/** Factory for {@link UInt|little-endian unsigned int layouts}\n * spanning six bytes. */ exports.u48 = (property)=>new UInt(6, property);\n/** Factory for {@link NearUInt64|little-endian unsigned int\n * layouts} interpreted as Numbers. */ exports.nu64 = (property)=>new NearUInt64(property);\n/** Factory for {@link UInt|big-endian unsigned int layouts}\n * spanning two bytes. */ exports.u16be = (property)=>new UIntBE(2, property);\n/** Factory for {@link UInt|big-endian unsigned int layouts}\n * spanning three bytes. */ exports.u24be = (property)=>new UIntBE(3, property);\n/** Factory for {@link UInt|big-endian unsigned int layouts}\n * spanning four bytes. */ exports.u32be = (property)=>new UIntBE(4, property);\n/** Factory for {@link UInt|big-endian unsigned int layouts}\n * spanning five bytes. */ exports.u40be = (property)=>new UIntBE(5, property);\n/** Factory for {@link UInt|big-endian unsigned int layouts}\n * spanning six bytes. */ exports.u48be = (property)=>new UIntBE(6, property);\n/** Factory for {@link NearUInt64BE|big-endian unsigned int\n * layouts} interpreted as Numbers. */ exports.nu64be = (property)=>new NearUInt64BE(property);\n/** Factory for {@link Int|signed int layouts} spanning one\n * byte. */ exports.s8 = (property)=>new Int(1, property);\n/** Factory for {@link Int|little-endian signed int layouts}\n * spanning two bytes. */ exports.s16 = (property)=>new Int(2, property);\n/** Factory for {@link Int|little-endian signed int layouts}\n * spanning three bytes. */ exports.s24 = (property)=>new Int(3, property);\n/** Factory for {@link Int|little-endian signed int layouts}\n * spanning four bytes. */ exports.s32 = (property)=>new Int(4, property);\n/** Factory for {@link Int|little-endian signed int layouts}\n * spanning five bytes. */ exports.s40 = (property)=>new Int(5, property);\n/** Factory for {@link Int|little-endian signed int layouts}\n * spanning six bytes. */ exports.s48 = (property)=>new Int(6, property);\n/** Factory for {@link NearInt64|little-endian signed int layouts}\n * interpreted as Numbers. */ exports.ns64 = (property)=>new NearInt64(property);\n/** Factory for {@link Int|big-endian signed int layouts}\n * spanning two bytes. */ exports.s16be = (property)=>new IntBE(2, property);\n/** Factory for {@link Int|big-endian signed int layouts}\n * spanning three bytes. */ exports.s24be = (property)=>new IntBE(3, property);\n/** Factory for {@link Int|big-endian signed int layouts}\n * spanning four bytes. */ exports.s32be = (property)=>new IntBE(4, property);\n/** Factory for {@link Int|big-endian signed int layouts}\n * spanning five bytes. */ exports.s40be = (property)=>new IntBE(5, property);\n/** Factory for {@link Int|big-endian signed int layouts}\n * spanning six bytes. */ exports.s48be = (property)=>new IntBE(6, property);\n/** Factory for {@link NearInt64BE|big-endian signed int layouts}\n * interpreted as Numbers. */ exports.ns64be = (property)=>new NearInt64BE(property);\n/** Factory for {@link Float|little-endian 32-bit floating point} values. */ exports.f32 = (property)=>new Float(property);\n/** Factory for {@link FloatBE|big-endian 32-bit floating point} values. */ exports.f32be = (property)=>new FloatBE(property);\n/** Factory for {@link Double|little-endian 64-bit floating point} values. */ exports.f64 = (property)=>new Double(property);\n/** Factory for {@link DoubleBE|big-endian 64-bit floating point} values. */ exports.f64be = (property)=>new DoubleBE(property);\n/** Factory for {@link Structure} values. */ exports.struct = (fields, property, decodePrefixes)=>new Structure(fields, property, decodePrefixes);\n/** Factory for {@link BitStructure} values. */ exports.bits = (word, msb, property)=>new BitStructure(word, msb, property);\n/** Factory for {@link Sequence} values. */ exports.seq = (elementLayout, count, property)=>new Sequence(elementLayout, count, property);\n/** Factory for {@link Union} values. */ exports.union = (discr, defaultLayout, property)=>new Union(discr, defaultLayout, property);\n/** Factory for {@link UnionLayoutDiscriminator} values. */ exports.unionLayoutDiscriminator = (layout, property)=>new UnionLayoutDiscriminator(layout, property);\n/** Factory for {@link Blob} values. */ exports.blob = (length, property)=>new Blob(length, property);\n/** Factory for {@link CString} values. */ exports.cstr = (property)=>new CString(property);\n/** Factory for {@link UTF8} values. */ exports.utf8 = (maxSpan, property)=>new UTF8(maxSpan, property);\n/** Factory for {@link Constant} values. */ exports.constant = (value, property)=>new Constant(value, property); //# sourceMappingURL=Layout.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vYW5jaG9yL25vZGVfbW9kdWxlcy9Ac29sYW5hL2J1ZmZlci1sYXlvdXQvbGliL0xheW91dC5qcyIsIm1hcHBpbmdzIjoiQUFBQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0NBcUJDLEdBQ0Q7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0NBMkdDLEdBQ0Q7QUFDQUEsOENBQTZDO0lBQUVHLE9BQU87QUFBSyxDQUFDLEVBQUM7QUFDN0RELFdBQVcsR0FBR0EsVUFBVSxHQUFHQSxjQUFjLEdBQUdBLGFBQWEsR0FBR0EsYUFBYSxHQUFHQSxhQUFhLEdBQUdBLGFBQWEsR0FBR0EsYUFBYSxHQUFHQSxZQUFZLEdBQUdBLFdBQVcsR0FBR0EsV0FBVyxHQUFHQSxXQUFXLEdBQUdBLFdBQVcsR0FBR0EsV0FBVyxHQUFHQSxVQUFVLEdBQUdBLGNBQWMsR0FBR0EsY0FBYyxHQUFHQSxnQkFBZ0IsR0FBR0EsWUFBWSxHQUFHQSxlQUFlLEdBQUdBLFlBQVksR0FBR0EsZUFBZSxHQUFHQSxnQkFBZ0IsR0FBR0Esb0JBQW9CLEdBQUdBLHFCQUFxQixHQUFHQSxhQUFhLEdBQUdBLGdDQUFnQyxHQUFHQSwwQkFBMEIsR0FBR0EsaUJBQWlCLEdBQUdBLGdCQUFnQixHQUFHQSxnQkFBZ0IsR0FBR0EsY0FBYyxHQUFHQSxlQUFlLEdBQUdBLGFBQWEsR0FBR0EsbUJBQW1CLEdBQUdBLGlCQUFpQixHQUFHQSxvQkFBb0IsR0FBR0Esa0JBQWtCLEdBQUdBLGFBQWEsR0FBR0EsV0FBVyxHQUFHQSxjQUFjLEdBQUdBLFlBQVksR0FBR0Esb0JBQW9CLEdBQUdBLG1CQUFtQixHQUFHQSxzQkFBc0IsR0FBR0EsNkJBQTZCLEdBQUdBLHdCQUF3QixHQUFHQSxjQUFjLEdBQUdBLDBCQUEwQixHQUFHQSx1QkFBdUIsR0FBRyxLQUFLO0FBQ3Q3QkEs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LFNBQVNuSTtBQUN6RCx5Q0FBeUMsR0FDekN4RixnQkFBZ0IsR0FBSSxDQUFDQyxPQUFPdUYsV0FBYSxJQUFJckUsU0FBU2xCLE9BQU91RixXQUM3RCxrQ0FBa0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vYW5jaG9yL25vZGVfbW9kdWxlcy9Ac29sYW5hL2J1ZmZlci1sYXlvdXQvbGliL0xheW91dC5qcz9mODdmIl0sInNvdXJjZXNDb250ZW50IjpbIi8qIFRoZSBNSVQgTGljZW5zZSAoTUlUKVxuICpcbiAqIENvcHlyaWdodCAyMDE1LTIwMTggUGV0ZXIgQS4gQmlnb3RcbiAqXG4gKiBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG4gKiBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG4gKiBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG4gKiB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG4gKiBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbiAqIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4gKlxuICogVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cbiAqIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuICpcbiAqIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcbiAqIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuICogRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4gKiBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG4gKiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuICogT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTlxuICogVEhFIFNPRlRXQVJFLlxuICovXG4vKipcbiAqIFN1cHBvcnQgZm9yIHRyYW5zbGF0aW5nIGJldHdlZW4gVWludDhBcnJheSBpbnN0YW5jZXMgYW5kIEphdmFTY3JpcHRcbiAqIG5hdGl2ZSB0eXBlcy5cbiAqXG4gKiB7QGxpbmsgbW9kdWxlOkxheW91dH5MYXlvdXR8TGF5b3V0fSBpcyB0aGUgYmFzaXMgb2YgYSBjbGFzc1xuICogaGllcmFyY2h5IHRoYXQgYXNzb2NpYXRlcyBwcm9wZXJ0eSBuYW1lcyB3aXRoIHNlcXVlbmNlcyBvZiBlbmNvZGVkXG4gKiBieXRlcy5cbiAqXG4gKiBMYXlvdXRzIGFyZSBzdXBwb3J0ZWQgZm9yIHRoZXNlIHNjYWxhciAobnVtZXJpYykgdHlwZXM6XG4gKiAqIHtAbGluayBtb2R1bGU6TGF5b3V0flVJbnR8VW5zaWduZWQgaW50ZWdlcnMgaW4gbGl0dGxlLWVuZGlhblxuICogICBmb3JtYXR9IHdpdGgge0BsaW5rIG1vZHVsZTpMYXlvdXQudTh8OC1iaXR9LCB7QGxpbmtcbiAqICAgbW9kdWxlOkxheW91dC51MTZ8MTYtYml0fSwge0BsaW5rIG1vZHVsZTpMYXlvdXQudTI0fDI0LWJpdH0sXG4gKiAgIHtAbGluayBtb2R1bGU6TGF5b3V0LnUzMnwzMi1iaXR9LCB7QGxpbmtcbiAqICAgbW9kdWxlOkxheW91dC51NDB8NDAtYml0fSwgYW5kIHtAbGluayBtb2R1bGU6TGF5b3V0LnU0OHw0OC1iaXR9XG4gKiAgIHJlcHJlc2VudGF0aW9uIHJhbmdlcztcbiAqICoge0BsaW5rIG1vZHVsZTpMYXlvdXR+VUludEJFfFVuc2lnbmVkIGludGVnZXJzIGluIGJpZy1lbmRpYW5cbiAqICAgZm9ybWF0fSB3aXRoIHtAbGluayBtb2R1bGU6TGF5b3V0LnUxNmJlfDE2LWJpdH0sIHtAbGlua1xuICogICBtb2R1bGU6TGF5b3V0LnUyNGJlfDI0LWJpdH0sIHtAbGluayBtb2R1bGU6TGF5b3V0LnUzMmJlfDMyLWJpdH0sXG4gKiAgIHtAbGluayBtb2R1bGU6TGF5b3V0LnU0MGJlfDQwLWJpdH0sIGFuZCB7QGxpbmtcbiAqICAgbW9kdWxlOkxheW91dC51NDhiZXw0OC1iaXR9IHJlcHJlc2VudGF0aW9uIHJhbmdlcztcbiAqICoge0BsaW5rIG1vZHVsZTpMYXlvdXR+SW50fFNpZ25lZCBpbnRlZ2VycyBpbiBsaXR0bGUtZW5kaWFuXG4gKiAgIGZvcm1hdH0gd2l0aCB7QGxpbmsgbW9kdWxlOkxheW91dC5zOHw4LWJpdH0sIHtAbGlua1xuICogICBtb2R1bGU6TGF5b3V0LnMxNnwxNi1iaXR9LCB7QGxpbmsgbW9kdWxlOkxheW91dC5zMjR8MjQtYml0fSxcbiAqICAge0BsaW5rIG1vZHVsZTpMYXlvdXQuczMyfDMyLWJpdH0sIHtAbGlua1xuICogICBtb2R1bGU6TGF5b3V0LnM0MHw0MC1iaXR9LCBhbmQge0BsaW5rIG1vZHVsZTpMYXlvdXQuczQ4fDQ4LWJpdH1cbiAqICAgcmVwcmVzZW50YXRpb24gcmFuZ2VzO1xuICogKiB7QGxpbmsgbW9kdWxlOkxheW91dH5JbnRCRXxTaWduZWQgaW50ZWdlcnMgaW4gYmlnLWVuZGlhbiBmb3JtYXR9XG4gKiAgIHdpdGgge0BsaW5rIG1vZHVsZTpMYXlvdXQuczE2YmV8MTYtYml0fSwge0BsaW5rXG4gKiAgIG1vZHVsZTpMYXlvdXQuczI0YmV8MjQtYml0fSwge0BsaW5rIG1vZHVsZTpMYXlvdXQuczMyYmV8MzItYml0fSxcbiAqICAge0BsaW5rIG1vZHVsZTpMYXlvdXQuczQwYmV8NDAtYml0fSwgYW5kIHtAbGlua1xuICogICBtb2R1bGU6TGF5b3V0LnM0OGJlfDQ4LWJpdH0gcmVwcmVzZW50YXRpb24gcmFuZ2VzO1xuICogKiA2NC1iaXQgaW50ZWdyYWwgdmFsdWVzIHRoYXQgZGVjb2RlIHRvIGFuIGV4YWN0IChpZiBtYWduaXR1ZGUgaXNcbiAqICAgbGVzcyB0aGFuIDJeNTMpIG9yIG5lYXJieSBpbnRlZ3JhbCBOdW1iZXIgaW4ge0BsaW5rXG4gKiAgIG1vZHVsZTpMYXlvdXQubnU2NHx1bnNpZ25lZCBsaXR0bGUtZW5kaWFufSwge0BsaW5rXG4gKiAgIG1vZHVsZTpMYXlvdXQubnU2NGJlfHVuc2lnbmVkIGJpZy1lbmRpYW59LCB7QGxpbmtcbiAqICAgbW9kdWxlOkxheW91dC5uczY0fHNpZ25lZCBsaXR0bGUtZW5kaWFufSwgYW5kIHtAbGlua1xuICogICBtb2R1bGU6TGF5b3V0Lm5zNjRiZXx1bnNpZ25lZCBiaWctZW5kaWFufSBlbmNvZGluZ3M7XG4gKiAqIDMyLWJpdCBmbG9hdGluZyBwb2ludCB2YWx1ZXMgd2l0aCB7QGxpbmtcbiAqICAgbW9kdWxlOkxheW91dC5mMzJ8bGl0dGxlLWVuZGlhbn0gYW5kIHtAbGlua1xuICogICBtb2R1bGU6TGF5b3V0LmYzMmJlfGJpZy1lbmRpYW59IHJlcHJlc2VudGF0aW9ucztcbiAqICogNjQtYml0IGZsb2F0aW5nIHBvaW50IHZhbHVlcyB3aXRoIHtAbGlua1xuICogICBtb2R1bGU6TGF5b3V0LmY2NHxsaXR0bGUtZW5kaWFufSBhbmQge0BsaW5rXG4gKiAgIG1vZHVsZTpMYXlvdXQuZjY0YmV8YmlnLWVuZGlhbn0gcmVwcmVzZW50YXRpb25zO1xuICogKiB7QGxpbmsgbW9kdWxlOkxheW91dC5jb25zdHxDb25zdGFudHN9IHRoYXQgdGFrZSBubyBzcGFjZSBpbiB0aGVcbiAqICAgZW5jb2RlZCBleHByZXNzaW9uLlxuICpcbiAqIGFuZCBmb3IgdGhlc2UgYWdncmVnYXRlIHR5cGVzOlxuICogKiB7QGxpbmsgbW9kdWxlOkxheW91dC5zZXF8U2VxdWVuY2V9cyBvZiBpbnN0YW5jZXMgb2YgYSB7QGxpbmtcbiAqICAgbW9kdWxlOkxheW91dH5MYXlvdXR8TGF5b3V0fSwgd2l0aCBKYXZhU2NyaXB0IHJlcHJlc2VudGF0aW9uIGFzXG4gKiAgIGFuIEFycmF5IGFuZCBjb25zdGFudCBvciBkYXRhLWRlcGVuZGVudCB7QGxpbmtcbiAqICAgbW9kdWxlOkxheW91dH5TZXF1ZW5jZSNjb3VudHxsZW5ndGh9O1xuICogKiB7QGxpbmsgbW9kdWxlOkxheW91dC5zdHJ1Y3R8U3RydWN0dXJlfXMgdGhhdCBhZ2dyZWdhdGUgYVxuICogICBoZXRlcm9nZW5lb3VzIHNlcXVlbmNlIG9mIHtAbGluayBtb2R1bGU6TGF5b3V0fkxheW91dHxMYXlvdXR9XG4gKiAgIGluc3RhbmNlcywgd2l0aCBKYXZhU2NyaXB0IHJlcHJlc2VudGF0aW9uIGFzIGFuIE9iamVjdDtcbiAqICoge0BsaW5rIG1vZHVsZTpMYXlvdXQudW5pb258VW5pb259cyB0aGF0IHN1cHBvcnQgbXVsdGlwbGUge0BsaW5rXG4gKiAgIG1vZHVsZTpMYXlvdXR+VmFyaWFudExheW91dHx2YXJpYW50IGxheW91dHN9IG92ZXIgYSBmaXhlZFxuICogICAocGFkZGVkKSBvciB2YXJpYWJsZSAobm90IHBhZGRlZCkgc3BhbiBvZiBieXRlcywgdXNpbmcgYW5cbiAqICAgdW5zaWduZWQgaW50ZWdlciBhdCB0aGUgc3RhcnQgb2YgdGhlIGRhdGEgb3IgYSBzZXBhcmF0ZSB7QGxpbmtcbiAqICAgbW9kdWxlOkxheW91dC51bmlvbkxheW91dERpc2NyaW1pbmF0b3J8bGF5b3V0IGVsZW1lbnR9IHRvXG4gKiAgIGRldGVybWluZSB3aGljaCBsYXlvdXQgdG8gdXNlIHdoZW4gaW50ZXJwcmV0aW5nIHRoZSBidWZmZXJcbiAqICAgY29udGVudHM7XG4gKiAqIHtAbGluayBtb2R1bGU6TGF5b3V0LmJpdHN8Qml0U3RydWN0dXJlfXMgdGhhdCBjb250YWluIGEgc2VxdWVuY2VcbiAqICAgb2YgaW5kaXZpZHVhbCB7QGxpbmtcbiAqICAgbW9kdWxlOkxheW91dH5CaXRTdHJ1Y3R1cmUjYWRkRmllbGR8Qml0RmllbGR9cyBwYWNrZWQgaW50byBhbiA4LFxuICogICAxNiwgMjQsIG9yIDMyLWJpdCB1bnNpZ25lZCBpbnRlZ2VyIHN0YXJ0aW5nIGF0IHRoZSBsZWFzdC0gb3JcbiAqICAgbW9zdC1zaWduaWZpY2FudCBiaXQ7XG4gKiAqIHtAbGluayBtb2R1bGU6TGF5b3V0LmNzdHJ8QyBzdHJpbmdzfSBvZiB2YXJ5aW5nIGxlbmd0aDtcbiAqICoge0BsaW5rIG1vZHVsZTpMYXlvdXQuYmxvYnxCbG9ic30gb2YgZml4ZWQtIG9yIHZhcmlhYmxlLXtAbGlua1xuICogICBtb2R1bGU6TGF5b3V0fkJsb2IjbGVuZ3RofGxlbmd0aH0gcmF3IGRhdGEuXG4gKlxuICogQWxsIHtAbGluayBtb2R1bGU6TGF5b3V0fkxheW91dHxMYXlvdXR9IGluc3RhbmNlcyBhcmUgaW1tdXRhYmxlXG4gKiBhZnRlciBjb25zdHJ1Y3Rpb24sIHRvIHByZXZlbnQgaW50ZXJuYWwgc3RhdGUgZnJvbSBiZWNvbWluZ1xuICogaW5jb25zaXN0ZW50LlxuICpcbiAqIEBsb2NhbCBMYXlvdXRcbiAqIEBsb2NhbCBFeHRlcm5hbExheW91dFxuICogQGxvY2FsIEdyZWVkeUNvdW50XG4gKiBAbG9jYWwgT2Zmc2V0TGF5b3V0XG4gKiBAbG9jYWwgVUludFxuICogQGxvY2FsIFVJbnRCRVxuICogQGxvY2FsIEludFxuICogQGxvY2FsIEludEJFXG4gKiBAbG9jYWwgTmVhclVJbnQ2NFxuICogQGxvY2FsIE5lYXJVSW50NjRCRVxuICogQGxvY2FsIE5lYXJJbnQ2NFxuICogQGxvY2FsIE5lYXJJbnQ2NEJFXG4gKiBAbG9jYWwgRmxvYXRcbiAqIEBsb2NhbCBGbG9hdEJFXG4gKiBAbG9jYWwgRG91YmxlXG4gKiBAbG9jYWwgRG91YmxlQkVcbiAqIEBsb2NhbCBTZXF1ZW5jZVxuICogQGxvY2FsIFN0cnVjdHVyZVxuICogQGxvY2FsIFVuaW9uRGlzY3JpbWluYXRvclxuICogQGxvY2FsIFVuaW9uTGF5b3V0RGlzY3JpbWluYXRvclxuICogQGxvY2FsIFVuaW9uXG4gKiBAbG9jYWwgVmFyaWFudExheW91dFxuICogQGxvY2FsIEJpdFN0cnVjdHVyZVxuICogQGxvY2FsIEJpdEZpZWxkXG4gKiBAbG9jYWwgQm9vbGVhblxuICogQGxvY2FsIEJsb2JcbiAqIEBsb2NhbCBDU3RyaW5nXG4gKiBAbG9jYWwgQ29uc3RhbnRcbiAqIEBsb2NhbCBiaW5kQ29uc3RydWN0b3JMYXlvdXRcbiAqIEBtb2R1bGUgTGF5b3V0XG4gKiBAbGljZW5zZSBNSVRcbiAqIEBhdXRob3IgUGV0ZXIgQS4gQmlnb3RcbiAqIEBzZWUge0BsaW5rIGh0dHBzOi8vZ2l0aHViLmNvbS9wYWJpZ290L2J1ZmZlci1sYXlvdXR8YnVmZmVyLWxheW91dCBvbiBHaXRIdWJ9XG4gKi9cbid1c2Ugc3RyaWN0Jztcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuczE2ID0gZXhwb3J0cy5zOCA9IGV4cG9ydHMubnU2NGJlID0gZXhwb3J0cy51NDhiZSA9IGV4cG9ydHMudTQwYmUgPSBleHBvcnRzLnUzMmJlID0gZXhwb3J0cy51MjRiZSA9IGV4cG9ydHMudTE2YmUgPSBleHBvcnRzLm51NjQgPSBleHBvcnRzLnU0OCA9IGV4cG9ydHMudTQwID0gZXhwb3J0cy51MzIgPSBleHBvcnRzLnUyNCA9IGV4cG9ydHMudTE2ID0gZXhwb3J0cy51OCA9IGV4cG9ydHMub2Zmc2V0ID0gZXhwb3J0cy5ncmVlZHkgPSBleHBvcnRzLkNvbnN0YW50ID0gZXhwb3J0cy5VVEY4ID0gZXhwb3J0cy5DU3RyaW5nID0gZXhwb3J0cy5CbG9iID0gZXhwb3J0cy5Cb29sZWFuID0gZXhwb3J0cy5CaXRGaWVsZCA9IGV4cG9ydHMuQml0U3RydWN0dXJlID0gZXhwb3J0cy5WYXJpYW50TGF5b3V0ID0gZXhwb3J0cy5VbmlvbiA9IGV4cG9ydHMuVW5pb25MYXlvdXREaXNjcmltaW5hdG9yID0gZXhwb3J0cy5VbmlvbkRpc2NyaW1pbmF0b3IgPSBleHBvcnRzLlN0cnVjdHVyZSA9IGV4cG9ydHMuU2VxdWVuY2UgPSBleHBvcnRzLkRvdWJsZUJFID0gZXhwb3J0cy5Eb3VibGUgPSBleHBvcnRzLkZsb2F0QkUgPSBleHBvcnRzLkZsb2F0ID0gZXhwb3J0cy5OZWFySW50NjRCRSA9IGV4cG9ydHMuTmVhckludDY0ID0gZXhwb3J0cy5OZWFyVUludDY0QkUgPSBleHBvcnRzLk5lYXJVSW50NjQgPSBleHBvcnRzLkludEJFID0gZXhwb3J0cy5JbnQgPSBleHBvcnRzLlVJbnRCRSA9IGV4cG9ydHMuVUludCA9IGV4cG9ydHMuT2Zmc2V0TGF5b3V0ID0gZXhwb3J0cy5HcmVlZHlDb3VudCA9IGV4cG9ydHMuRXh0ZXJuYWxMYXlvdXQgPSBleHBvcnRzLmJpbmRDb25zdHJ1Y3RvckxheW91dCA9IGV4cG9ydHMubmFtZVdpdGhQcm9wZXJ0eSA9IGV4cG9ydHMuTGF5b3V0ID0gZXhwb3J0cy51aW50OEFycmF5VG9CdWZmZXIgPSBleHBvcnRzLmNoZWNrVWludDhBcnJheSA9IHZvaWQgMDtcbmV4cG9ydHMuY29uc3RhbnQgPSBleHBvcnRzLnV0ZjggPSBleHBvcnRzLmNzdHIgPSBleHBvcnRzLmJsb2IgPSBleHBvcnRzLnVuaW9uTGF5b3V0RGlzY3JpbWluYXRvciA9IGV4cG9ydHMudW5pb24gPSBleHBvcnRzLnNlcSA9IGV4cG9ydHMuYml0cyA9IGV4cG9ydHMuc3RydWN0ID0gZXhwb3J0cy5mNjRiZSA9IGV4cG9ydHMuZjY0ID0gZXhwb3J0cy5mMzJiZSA9IGV4cG9ydHMuZjMyID0gZXhwb3J0cy5uczY0YmUgPSBleHBvcnRzLnM0OGJlID0gZXhwb3J0cy5zNDBiZSA9IGV4cG9ydHMuczMyYmUgPSBleHBvcnRzLnMyNGJlID0gZXhwb3J0cy5zMTZiZSA9IGV4cG9ydHMubnM2NCA9IGV4cG9ydHMuczQ4ID0gZXhwb3J0cy5zNDAgPSBleHBvcnRzLnMzMiA9IGV4cG9ydHMuczI0ID0gdm9pZCAwO1xuY29uc3QgYnVmZmVyXzEgPSByZXF1aXJlKFwiYnVmZmVyXCIpO1xuLyogQ2hlY2sgaWYgYSB2YWx1ZSBpcyBhIFVpbnQ4QXJyYXkuXG4gKlxuICogQGlnbm9yZSAqL1xuZnVuY3Rpb24gY2hlY2tVaW50OEFycmF5KGIpIHtcbiAgICBpZiAoIShiIGluc3RhbmNlb2YgVWludDhBcnJheSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignYiBtdXN0IGJlIGEgVWludDhBcnJheScpO1xuICAgIH1cbn1cbmV4cG9ydHMuY2hlY2tVaW50OEFycmF5ID0gY2hlY2tVaW50OEFycmF5O1xuLyogQ3JlYXRlIGEgQnVmZmVyIGluc3RhbmNlIGZyb20gYSBVaW50OEFycmF5LlxuICpcbiAqIEBpZ25vcmUgKi9cbmZ1bmN0aW9uIHVpbnQ4QXJyYXlUb0J1ZmZlcihiKSB7XG4gICAgY2hlY2tVaW50OEFycmF5KGIpO1xuICAgIHJldHVybiBidWZmZXJfMS5CdWZmZXIuZnJvbShiLmJ1ZmZlciwgYi5ieXRlT2Zmc2V0LCBiLmxlbmd0aCk7XG59XG5leHBvcnRzLnVpbnQ4QXJyYXlUb0J1ZmZlciA9IHVpbnQ4QXJyYXlUb0J1ZmZlcjtcbi8qKlxuICogQmFzZSBjbGFzcyBmb3IgbGF5b3V0IG9iamVjdHMuXG4gKlxuICogKipOT1RFKiogVGhpcyBpcyBhbiBhYnN0cmFjdCBiYXNlIGNsYXNzOyB5b3UgY2FuIGNyZWF0ZSBpbnN0YW5jZXNcbiAqIGlmIGl0IGFtdXNlcyB5b3UsIGJ1dCB0aGV5IHdvbid0IHN1cHBvcnQgdGhlIHtAbGlua1xuICogTGF5b3V0I2VuY29kZXxlbmNvZGV9IG9yIHtAbGluayBMYXlvdXQjZGVjb2RlfGRlY29kZX0gZnVuY3Rpb25zLlxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSBzcGFuIC0gSW5pdGlhbGl6ZXIgZm9yIHtAbGluayBMYXlvdXQjc3BhbnxzcGFufS4gIFRoZVxuICogcGFyYW1ldGVyIG11c3QgYmUgYW4gaW50ZWdlcjsgYSBuZWdhdGl2ZSB2YWx1ZSBzaWduaWZpZXMgdGhhdCB0aGVcbiAqIHNwYW4gaXMge0BsaW5rIExheW91dCNnZXRTcGFufHZhbHVlLXNwZWNpZmljfS5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gW3Byb3BlcnR5XSAtIEluaXRpYWxpemVyIGZvciB7QGxpbmtcbiAqIExheW91dCNwcm9wZXJ0eXxwcm9wZXJ0eX0uXG4gKlxuICogQGFic3RyYWN0XG4gKi9cbmNsYXNzIExheW91dCB7XG4gICAgY29uc3RydWN0b3Ioc3BhbiwgcHJvcGVydHkpIHtcbiAgICAgICAgaWYgKCFOdW1iZXIuaXNJbnRlZ2VyKHNwYW4pKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdzcGFuIG11c3QgYmUgYW4gaW50ZWdlcicpO1xuICAgICAgICB9XG4gICAgICAgIC8qKiBUaGUgc3BhbiBvZiB0aGUgbGF5b3V0IGluIGJ5dGVzLlxuICAgICAgICAgKlxuICAgICAgICAgKiBQb3NpdGl2ZSB2YWx1ZXMgYXJlIGdlbmVyYWxseSBleHBlY3RlZC5cbiAgICAgICAgICpcbiAgICAgICAgICogWmVybyB3aWxsIG9ubHkgYXBwZWFyIGluIHtAbGluayBDb25zdGFudH1zIGFuZCBpbiB7QGxpbmtcbiAgICAgICAgICogU2VxdWVuY2V9cyB3aGVyZSB0aGUge0BsaW5rIFNlcXVlbmNlI2NvdW50fGNvdW50fSBpcyB6ZXJvLlxuICAgICAgICAgKlxuICAgICAgICAgKiBBIG5lZ2F0aXZlIHZhbHVlIGluZGljYXRlcyB0aGF0IHRoZSBzcGFuIGlzIHZhbHVlLXNwZWNpZmljLCBhbmRcbiAgICAgICAgICogbXVzdCBiZSBvYnRhaW5lZCB1c2luZyB7QGxpbmsgTGF5b3V0I2dldFNwYW58Z2V0U3Bhbn0uICovXG4gICAgICAgIHRoaXMuc3BhbiA9IHNwYW47XG4gICAgICAgIC8qKiBUaGUgcHJvcGVydHkgbmFtZSB1c2VkIHdoZW4gdGhpcyBsYXlvdXQgaXMgcmVwcmVzZW50ZWQgaW4gYW5cbiAgICAgICAgICogT2JqZWN0LlxuICAgICAgICAgKlxuICAgICAgICAgKiBVc2VkIG9ubHkgZm9yIGxheW91dHMgdGhhdCB7QGxpbmsgTGF5b3V0I2RlY29kZXxkZWNvZGV9IHRvIE9iamVjdFxuICAgICAgICAgKiBpbnN0YW5jZXMuICBJZiBsZWZ0IHVuZGVmaW5lZCB0aGUgc3BhbiBvZiB0aGUgdW5uYW1lZCBsYXlvdXQgd2lsbFxuICAgICAgICAgKiBiZSB0cmVhdGVkIGFzIHBhZGRpbmc6IGl0IHdpbGwgbm90IGJlIG11dGF0ZWQgYnkge0BsaW5rXG4gICAgICAgICAqIExheW91dCNlbmNvZGV8ZW5jb2RlfSBub3IgcmVwcmVzZW50ZWQgYXMgYSBwcm9wZXJ0eSBpbiB0aGVcbiAgICAgICAgICogZGVjb2RlZCBPYmplY3QuICovXG4gICAgICAgIHRoaXMucHJvcGVydHkgPSBwcm9wZXJ0eTtcbiAgICB9XG4gICAgLyoqIEZ1bmN0aW9uIHRvIGNyZWF0ZSBhbiBPYmplY3QgaW50byB3aGljaCBkZWNvZGVkIHByb3BlcnRpZXMgd2lsbFxuICAgICAqIGJlIHdyaXR0ZW4uXG4gICAgICpcbiAgICAgKiBVc2VkIG9ubHkgZm9yIGxheW91dHMgdGhhdCB7QGxpbmsgTGF5b3V0I2RlY29kZXxkZWNvZGV9IHRvIE9iamVjdFxuICAgICAqIGluc3RhbmNlcywgd2hpY2ggbWVhbnM6XG4gICAgICogKiB7QGxpbmsgU3RydWN0dXJlfVxuICAgICAqICoge0BsaW5rIFVuaW9ufVxuICAgICAqICoge0BsaW5rIFZhcmlhbnRMYXlvdXR9XG4gICAgICogKiB7QGxpbmsgQml0U3RydWN0dXJlfVxuICAgICAqXG4gICAgICogSWYgbGVmdCB1bmRlZmluZWQgdGhlIEphdmFTY3JpcHQgcmVwcmVzZW50YXRpb24gb2YgdGhlc2UgbGF5b3V0c1xuICAgICAqIHdpbGwgYmUgT2JqZWN0IGluc3RhbmNlcy5cbiAgICAgKlxuICAgICAqIFNlZSB7QGxpbmsgYmluZENvbnN0cnVjdG9yTGF5b3V0fS5cbiAgICAgKi9cbiAgICBtYWtlRGVzdGluYXRpb25PYmplY3QoKSB7XG4gICAgICAgIHJldHVybiB7fTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2FsY3VsYXRlIHRoZSBzcGFuIG9mIGEgc3BlY2lmaWMgaW5zdGFuY2Ugb2YgYSBsYXlvdXQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IGIgLSB0aGUgYnVmZmVyIHRoYXQgY29udGFpbnMgYW4gZW5jb2RlZCBpbnN0YW5jZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbb2Zmc2V0XSAtIHRoZSBvZmZzZXQgYXQgd2hpY2ggdGhlIGVuY29kZWQgaW5zdGFuY2VcbiAgICAgKiBzdGFydHMuICBJZiBhYnNlbnQgYSB6ZXJvIG9mZnNldCBpcyBpbmZlcnJlZC5cbiAgICAgKlxuICAgICAqIEByZXR1cm4ge051bWJlcn0gLSB0aGUgbnVtYmVyIG9mIGJ5dGVzIGNvdmVyZWQgYnkgdGhlIGxheW91dFxuICAgICAqIGluc3RhbmNlLiAgSWYgdGhpcyBtZXRob2QgaXMgbm90IG92ZXJyaWRkZW4gaW4gYSBzdWJjbGFzcyB0aGVcbiAgICAgKiBkZWZpbml0aW9uLXRpbWUgY29uc3RhbnQge0BsaW5rIExheW91dCNzcGFufHNwYW59IHdpbGwgYmVcbiAgICAgKiByZXR1cm5lZC5cbiAgICAgKlxuICAgICAqIEB0aHJvd3Mge1JhbmdlRXJyb3J9IC0gaWYgdGhlIGxlbmd0aCBvZiB0aGUgdmFsdWUgY2Fubm90IGJlXG4gICAgICogZGV0ZXJtaW5lZC5cbiAgICAgKi9cbiAgICBnZXRTcGFuKGIsIG9mZnNldCkge1xuICAgICAgICBpZiAoMCA+IHRoaXMuc3Bhbikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ2luZGV0ZXJtaW5hdGUgc3BhbicpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLnNwYW47XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlcGxpY2F0ZSB0aGUgbGF5b3V0IHVzaW5nIGEgbmV3IHByb3BlcnR5LlxuICAgICAqXG4gICAgICogVGhpcyBmdW5jdGlvbiBtdXN0IGJlIHVzZWQgdG8gZ2V0IGEgc3RydWN0dXJhbGx5LWVxdWl2YWxlbnQgbGF5b3V0XG4gICAgICogd2l0aCBhIGRpZmZlcmVudCBuYW1lIHNpbmNlIGFsbCB7QGxpbmsgTGF5b3V0fSBpbnN0YW5jZXMgYXJlXG4gICAgICogaW1tdXRhYmxlLlxuICAgICAqXG4gICAgICogKipOT1RFKiogVGhpcyBpcyBhIHNoYWxsb3cgY29weS4gIEFsbCBmaWVsZHMgZXhjZXB0IHtAbGlua1xuICAgICAqIExheW91dCNwcm9wZXJ0eXxwcm9wZXJ0eX0gYXJlIHN0cmljdGx5IGVxdWFsIHRvIHRoZSBvcmlnaW4gbGF5b3V0LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHByb3BlcnR5IC0gdGhlIHZhbHVlIGZvciB7QGxpbmtcbiAgICAgKiBMYXlvdXQjcHJvcGVydHl8cHJvcGVydHl9IGluIHRoZSByZXBsaWNhLlxuICAgICAqXG4gICAgICogQHJldHVybnMge0xheW91dH0gLSB0aGUgY29weSB3aXRoIHtAbGluayBMYXlvdXQjcHJvcGVydHl8cHJvcGVydHl9XG4gICAgICogc2V0IHRvIGBwcm9wZXJ0eWAuXG4gICAgICovXG4gICAgcmVwbGljYXRlKHByb3BlcnR5KSB7XG4gICAgICAgIGNvbnN0IHJ2ID0gT2JqZWN0LmNyZWF0ZSh0aGlzLmNvbnN0cnVjdG9yLnByb3RvdHlwZSk7XG4gICAgICAgIE9iamVjdC5hc3NpZ24ocnYsIHRoaXMpO1xuICAgICAgICBydi5wcm9wZXJ0eSA9IHByb3BlcnR5O1xuICAgICAgICByZXR1cm4gcnY7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhbiBvYmplY3QgZnJvbSBsYXlvdXQgcHJvcGVydGllcyBhbmQgYW4gYXJyYXkgb2YgdmFsdWVzLlxuICAgICAqXG4gICAgICogKipOT1RFKiogVGhpcyBmdW5jdGlvbiByZXR1cm5zIGB1bmRlZmluZWRgIGlmIGludm9rZWQgb24gYSBsYXlvdXRcbiAgICAgKiB0aGF0IGRvZXMgbm90IHJldHVybiBpdHMgdmFsdWUgYXMgYW4gT2JqZWN0LiAgT2JqZWN0cyBhcmVcbiAgICAgKiByZXR1cm5lZCBmb3IgdGhpbmdzIHRoYXQgYXJlIGEge0BsaW5rIFN0cnVjdHVyZX0sIHdoaWNoIGluY2x1ZGVzXG4gICAgICoge0BsaW5rIFZhcmlhbnRMYXlvdXR8dmFyaWFudCBsYXlvdXRzfSBpZiB0aGV5IGFyZSBzdHJ1Y3R1cmVzLCBhbmRcbiAgICAgKiBleGNsdWRlcyB7QGxpbmsgVW5pb259cy4gIElmIHlvdSB3YW50IHRoaXMgZmVhdHVyZSBmb3IgYSB1bmlvblxuICAgICAqIHlvdSBtdXN0IHVzZSB7QGxpbmsgVW5pb24uZ2V0VmFyaWFudHxnZXRWYXJpYW50fSB0byBzZWxlY3QgdGhlXG4gICAgICogZGVzaXJlZCBsYXlvdXQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0FycmF5fSB2YWx1ZXMgLSBhbiBhcnJheSBvZiB2YWx1ZXMgdGhhdCBjb3JyZXNwb25kIHRvIHRoZVxuICAgICAqIGRlZmF1bHQgb3JkZXIgZm9yIHByb3BlcnRpZXMuICBBcyB3aXRoIHtAbGluayBMYXlvdXQjZGVjb2RlfGRlY29kZX1cbiAgICAgKiBsYXlvdXQgZWxlbWVudHMgdGhhdCBoYXZlIG5vIHByb3BlcnR5IG5hbWUgYXJlIHNraXBwZWQgd2hlblxuICAgICAqIGl0ZXJhdGluZyBvdmVyIHRoZSBhcnJheSB2YWx1ZXMuICBPbmx5IHRoZSB0b3AtbGV2ZWwgcHJvcGVydGllcyBhcmVcbiAgICAgKiBhc3NpZ25lZDsgYXJndW1lbnRzIGFyZSBub3QgYXNzaWduZWQgdG8gcHJvcGVydGllcyBvZiBjb250YWluZWRcbiAgICAgKiBsYXlvdXRzLiAgQW55IHVudXNlZCB2YWx1ZXMgYXJlIGlnbm9yZWQuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHsoT2JqZWN0fHVuZGVmaW5lZCl9XG4gICAgICovXG4gICAgZnJvbUFycmF5KHZhbHVlcykge1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbn1cbmV4cG9ydHMuTGF5b3V0ID0gTGF5b3V0O1xuLyogUHJvdmlkZSB0ZXh0IHRoYXQgY2FycmllcyBhIG5hbWUgKHN1Y2ggYXMgZm9yIGEgZnVuY3Rpb24gdGhhdCB3aWxsXG4gKiBiZSB0aHJvd2luZyBhbiBlcnJvcikgYW5ub3RhdGVkIHdpdGggdGhlIHByb3BlcnR5IG9mIGEgZ2l2ZW4gbGF5b3V0XG4gKiAoc3VjaCBhcyBvbmUgZm9yIHdoaWNoIHRoZSB2YWx1ZSB3YXMgdW5hY2NlcHRhYmxlKS5cbiAqXG4gKiBAaWdub3JlICovXG5mdW5jdGlvbiBuYW1lV2l0aFByb3BlcnR5KG5hbWUsIGxvKSB7XG4gICAgaWYgKGxvLnByb3BlcnR5KSB7XG4gICAgICAgIHJldHVybiBuYW1lICsgJ1snICsgbG8ucHJvcGVydHkgKyAnXSc7XG4gICAgfVxuICAgIHJldHVybiBuYW1lO1xufVxuZXhwb3J0cy5uYW1lV2l0aFByb3BlcnR5ID0gbmFtZVdpdGhQcm9wZXJ0eTtcbi8qKlxuICogQXVnbWVudCBhIGNsYXNzIHNvIHRoYXQgaW5zdGFuY2VzIGNhbiBiZSBlbmNvZGVkL2RlY29kZWQgdXNpbmcgYVxuICogZ2l2ZW4gbGF5b3V0LlxuICpcbiAqIENhbGxpbmcgdGhpcyBmdW5jdGlvbiBjb3VwbGVzIGBDbGFzc2Agd2l0aCBgbGF5b3V0YCBpbiBzZXZlcmFsIHdheXM6XG4gKlxuICogKiBgQ2xhc3MubGF5b3V0X2AgYmVjb21lcyBhIHN0YXRpYyBtZW1iZXIgcHJvcGVydHkgZXF1YWwgdG8gYGxheW91dGA7XG4gKiAqIGBsYXlvdXQuYm91bmRDb25zdHJ1Y3Rvcl9gIGJlY29tZXMgYSBzdGF0aWMgbWVtYmVyIHByb3BlcnR5IGVxdWFsXG4gKiAgICB0byBgQ2xhc3NgO1xuICogKiBUaGUge0BsaW5rIExheW91dCNtYWtlRGVzdGluYXRpb25PYmplY3R8bWFrZURlc3RpbmF0aW9uT2JqZWN0KCl9XG4gKiAgIHByb3BlcnR5IG9mIGBsYXlvdXRgIGlzIHNldCB0byBhIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyBhIGBuZXdcbiAqICAgQ2xhc3MoKWA7XG4gKiAqIGBDbGFzcy5kZWNvZGUoYiwgb2Zmc2V0KWAgYmVjb21lcyBhIHN0YXRpYyBtZW1iZXIgZnVuY3Rpb24gdGhhdFxuICogICBkZWxlZ2F0ZXMgdG8ge0BsaW5rIExheW91dCNkZWNvZGV8bGF5b3V0LmRlY29kZX0uICBUaGVcbiAqICAgc3ludGhlc2l6ZWQgZnVuY3Rpb24gbWF5IGJlIGNhcHR1cmVkIGFuZCBleHRlbmRlZC5cbiAqICogYENsYXNzLnByb3RvdHlwZS5lbmNvZGUoYiwgb2Zmc2V0KWAgcHJvdmlkZXMgYW4gaW5zdGFuY2UgbWVtYmVyXG4gKiAgIGZ1bmN0aW9uIHRoYXQgZGVsZWdhdGVzIHRvIHtAbGluayBMYXlvdXQjZW5jb2RlfGxheW91dC5lbmNvZGV9XG4gKiAgIHdpdGggYHNyY2Agc2V0IHRvIGB0aGlzYC4gIFRoZSBzeW50aGVzaXplZCBmdW5jdGlvbiBtYXkgYmVcbiAqICAgY2FwdHVyZWQgYW5kIGV4dGVuZGVkLCBidXQgd2hlbiB0aGUgZXh0ZW5zaW9uIGlzIGludm9rZWQgYHRoaXNgXG4gKiAgIG11c3QgYmUgZXhwbGljaXRseSBib3VuZCB0byB0aGUgaW5zdGFuY2UuXG4gKlxuICogQHBhcmFtIHtjbGFzc30gQ2xhc3MgLSBhIEphdmFTY3JpcHQgY2xhc3Mgd2l0aCBhIG51bGxhcnlcbiAqIGNvbnN0cnVjdG9yLlxuICpcbiAqIEBwYXJhbSB7TGF5b3V0fSBsYXlvdXQgLSB0aGUge0BsaW5rIExheW91dH0gaW5zdGFuY2UgdXNlZCB0byBlbmNvZGVcbiAqIGluc3RhbmNlcyBvZiBgQ2xhc3NgLlxuICovXG4vLyBgQ2xhc3NgIG11c3QgYmUgYSBjb25zdHJ1Y3RvciBGdW5jdGlvbiwgYnV0IHRoZSBhc3NpZ25tZW50IG9mIGEgYGxheW91dF9gIHByb3BlcnR5IHRvIGl0IG1ha2VzIGl0IGRpZmZpY3VsdCB0byB0eXBlXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L2V4cGxpY2l0LW1vZHVsZS1ib3VuZGFyeS10eXBlc1xuZnVuY3Rpb24gYmluZENvbnN0cnVjdG9yTGF5b3V0KENsYXNzLCBsYXlvdXQpIHtcbiAgICBpZiAoJ2Z1bmN0aW9uJyAhPT0gdHlwZW9mIENsYXNzKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0NsYXNzIG11c3QgYmUgY29uc3RydWN0b3InKTtcbiAgICB9XG4gICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChDbGFzcywgJ2xheW91dF8nKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NsYXNzIGlzIGFscmVhZHkgYm91bmQgdG8gYSBsYXlvdXQnKTtcbiAgICB9XG4gICAgaWYgKCEobGF5b3V0ICYmIChsYXlvdXQgaW5zdGFuY2VvZiBMYXlvdXQpKSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdsYXlvdXQgbXVzdCBiZSBhIExheW91dCcpO1xuICAgIH1cbiAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGxheW91dCwgJ2JvdW5kQ29uc3RydWN0b3JfJykpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdsYXlvdXQgaXMgYWxyZWFkeSBib3VuZCB0byBhIGNvbnN0cnVjdG9yJyk7XG4gICAgfVxuICAgIENsYXNzLmxheW91dF8gPSBsYXlvdXQ7XG4gICAgbGF5b3V0LmJvdW5kQ29uc3RydWN0b3JfID0gQ2xhc3M7XG4gICAgbGF5b3V0Lm1ha2VEZXN0aW5hdGlvbk9iamVjdCA9ICgoKSA9PiBuZXcgQ2xhc3MoKSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KENsYXNzLnByb3RvdHlwZSwgJ2VuY29kZScsIHtcbiAgICAgICAgdmFsdWUoYiwgb2Zmc2V0KSB7XG4gICAgICAgICAgICByZXR1cm4gbGF5b3V0LmVuY29kZSh0aGlzLCBiLCBvZmZzZXQpO1xuICAgICAgICB9LFxuICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQ2xhc3MsICdkZWNvZGUnLCB7XG4gICAgICAgIHZhbHVlKGIsIG9mZnNldCkge1xuICAgICAgICAgICAgcmV0dXJuIGxheW91dC5kZWNvZGUoYiwgb2Zmc2V0KTtcbiAgICAgICAgfSxcbiAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgfSk7XG59XG5leHBvcnRzLmJpbmRDb25zdHJ1Y3RvckxheW91dCA9IGJpbmRDb25zdHJ1Y3RvckxheW91dDtcbi8qKlxuICogQW4gb2JqZWN0IHRoYXQgYmVoYXZlcyBsaWtlIGEgbGF5b3V0IGJ1dCBkb2VzIG5vdCBjb25zdW1lIHNwYWNlXG4gKiB3aXRoaW4gaXRzIGNvbnRhaW5pbmcgbGF5b3V0LlxuICpcbiAqIFRoaXMgaXMgcHJpbWFyaWx5IHVzZWQgdG8gb2J0YWluIG1ldGFkYXRhIGFib3V0IGEgbWVtYmVyLCBzdWNoIGFzIGFcbiAqIHtAbGluayBPZmZzZXRMYXlvdXR9IHRoYXQgY2FuIHByb3ZpZGUgZGF0YSBhYm91dCBhIHtAbGlua1xuICogTGF5b3V0I2dldFNwYW58dmFsdWUtc3BlY2lmaWMgc3Bhbn0uXG4gKlxuICogKipOT1RFKiogVGhpcyBpcyBhbiBhYnN0cmFjdCBiYXNlIGNsYXNzOyB5b3UgY2FuIGNyZWF0ZSBpbnN0YW5jZXNcbiAqIGlmIGl0IGFtdXNlcyB5b3UsIGJ1dCB0aGV5IHdvbid0IHN1cHBvcnQge0BsaW5rXG4gKiBFeHRlcm5hbExheW91dCNpc0NvdW50fGlzQ291bnR9IG9yIG90aGVyIHtAbGluayBMYXlvdXR9IGZ1bmN0aW9ucy5cbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gc3BhbiAtIGluaXRpYWxpemVyIGZvciB7QGxpbmsgTGF5b3V0I3NwYW58c3Bhbn0uXG4gKiBUaGUgcGFyYW1ldGVyIGNhbiByYW5nZSBmcm9tIDEgdGhyb3VnaCA2LlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBbcHJvcGVydHldIC0gaW5pdGlhbGl6ZXIgZm9yIHtAbGlua1xuICogTGF5b3V0I3Byb3BlcnR5fHByb3BlcnR5fS5cbiAqXG4gKiBAYWJzdHJhY3RcbiAqIEBhdWdtZW50cyB7TGF5b3V0fVxuICovXG5jbGFzcyBFeHRlcm5hbExheW91dCBleHRlbmRzIExheW91dCB7XG4gICAgLyoqXG4gICAgICogUmV0dXJuIGB0cnVlYCBpZmYgdGhlIGV4dGVybmFsIGxheW91dCBkZWNvZGVzIHRvIGFuIHVuc2lnbmVkXG4gICAgICogaW50ZWdlciBsYXlvdXQuXG4gICAgICpcbiAgICAgKiBJbiB0aGF0IGNhc2UgaXQgY2FuIGJlIHVzZWQgYXMgdGhlIHNvdXJjZSBvZiB7QGxpbmtcbiAgICAgKiBTZXF1ZW5jZSNjb3VudHxTZXF1ZW5jZSBjb3VudHN9LCB7QGxpbmsgQmxvYiNsZW5ndGh8QmxvYiBsZW5ndGhzfSxcbiAgICAgKiBvciBhcyB7QGxpbmsgVW5pb25MYXlvdXREaXNjcmltaW5hdG9yI2xheW91dHxleHRlcm5hbCB1bmlvblxuICAgICAqIGRpc2NyaW1pbmF0b3JzfS5cbiAgICAgKlxuICAgICAqIEBhYnN0cmFjdFxuICAgICAqL1xuICAgIGlzQ291bnQoKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignRXh0ZXJuYWxMYXlvdXQgaXMgYWJzdHJhY3QnKTtcbiAgICB9XG59XG5leHBvcnRzLkV4dGVybmFsTGF5b3V0ID0gRXh0ZXJuYWxMYXlvdXQ7XG4vKipcbiAqIEFuIHtAbGluayBFeHRlcm5hbExheW91dH0gdGhhdCBkZXRlcm1pbmVzIGl0cyB7QGxpbmtcbiAqIExheW91dCNkZWNvZGV8dmFsdWV9IGJhc2VkIG9uIG9mZnNldCBpbnRvIGFuZCBsZW5ndGggb2YgdGhlIGJ1ZmZlclxuICogb24gd2hpY2ggaXQgaXMgaW52b2tlZC5cbiAqXG4gKiAqRmFjdG9yeSo6IHtAbGluayBtb2R1bGU6TGF5b3V0LmdyZWVkeXxncmVlZHl9XG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IFtlbGVtZW50U3Bhbl0gLSBpbml0aWFsaXplciBmb3Ige0BsaW5rXG4gKiBHcmVlZHlDb3VudCNlbGVtZW50U3BhbnxlbGVtZW50U3Bhbn0uXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IFtwcm9wZXJ0eV0gLSBpbml0aWFsaXplciBmb3Ige0BsaW5rXG4gKiBMYXlvdXQjcHJvcGVydHl8cHJvcGVydHl9LlxuICpcbiAqIEBhdWdtZW50cyB7RXh0ZXJuYWxMYXlvdXR9XG4gKi9cbmNsYXNzIEdyZWVkeUNvdW50IGV4dGVuZHMgRXh0ZXJuYWxMYXlvdXQge1xuICAgIGNvbnN0cnVjdG9yKGVsZW1lbnRTcGFuID0gMSwgcHJvcGVydHkpIHtcbiAgICAgICAgaWYgKCghTnVtYmVyLmlzSW50ZWdlcihlbGVtZW50U3BhbikpIHx8ICgwID49IGVsZW1lbnRTcGFuKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignZWxlbWVudFNwYW4gbXVzdCBiZSBhIChwb3NpdGl2ZSkgaW50ZWdlcicpO1xuICAgICAgICB9XG4gICAgICAgIHN1cGVyKC0xLCBwcm9wZXJ0eSk7XG4gICAgICAgIC8qKiBUaGUgbGF5b3V0IGZvciBpbmRpdmlkdWFsIGVsZW1lbnRzIG9mIHRoZSBzZXF1ZW5jZS4gIFRoZSB2YWx1ZVxuICAgICAgICAgKiBtdXN0IGJlIGEgcG9zaXRpdmUgaW50ZWdlci4gIElmIG5vdCBwcm92aWRlZCwgdGhlIHZhbHVlIHdpbGwgYmVcbiAgICAgICAgICogMS4gKi9cbiAgICAgICAgdGhpcy5lbGVtZW50U3BhbiA9IGVsZW1lbnRTcGFuO1xuICAgIH1cbiAgICAvKiogQG92ZXJyaWRlICovXG4gICAgaXNDb3VudCgpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIC8qKiBAb3ZlcnJpZGUgKi9cbiAgICBkZWNvZGUoYiwgb2Zmc2V0ID0gMCkge1xuICAgICAgICBjaGVja1VpbnQ4QXJyYXkoYik7XG4gICAgICAgIGNvbnN0IHJlbSA9IGIubGVuZ3RoIC0gb2Zmc2V0O1xuICAgICAgICByZXR1cm4gTWF0aC5mbG9vcihyZW0gLyB0aGlzLmVsZW1lbnRTcGFuKTtcbiAgICB9XG4gICAgLyoqIEBvdmVycmlkZSAqL1xuICAgIGVuY29kZShzcmMsIGIsIG9mZnNldCkge1xuICAgICAgICByZXR1cm4gMDtcbiAgICB9XG59XG5leHBvcnRzLkdyZWVkeUNvdW50ID0gR3JlZWR5Q291bnQ7XG4vKipcbiAqIEFuIHtAbGluayBFeHRlcm5hbExheW91dH0gdGhhdCBzdXBwb3J0cyBhY2Nlc3NpbmcgYSB7QGxpbmsgTGF5b3V0fVxuICogYXQgYSBmaXhlZCBvZmZzZXQgZnJvbSB0aGUgc3RhcnQgb2YgYW5vdGhlciBMYXlvdXQuICBUaGUgb2Zmc2V0IG1heVxuICogYmUgYmVmb3JlLCB3aXRoaW4sIG9yIGFmdGVyIHRoZSBiYXNlIGxheW91dC5cbiAqXG4gKiAqRmFjdG9yeSo6IHtAbGluayBtb2R1bGU6TGF5b3V0Lm9mZnNldHxvZmZzZXR9XG4gKlxuICogQHBhcmFtIHtMYXlvdXR9IGxheW91dCAtIGluaXRpYWxpemVyIGZvciB7QGxpbmtcbiAqIE9mZnNldExheW91dCNsYXlvdXR8bGF5b3V0fSwgbW9kdWxvIGBwcm9wZXJ0eWAuXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IFtvZmZzZXRdIC0gSW5pdGlhbGl6ZXMge0BsaW5rXG4gKiBPZmZzZXRMYXlvdXQjb2Zmc2V0fG9mZnNldH0uICBEZWZhdWx0cyB0byB6ZXJvLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBbcHJvcGVydHldIC0gT3B0aW9uYWwgbmV3IHByb3BlcnR5IG5hbWUgZm9yIGFcbiAqIHtAbGluayBMYXlvdXQjcmVwbGljYXRlfCByZXBsaWNhfSBvZiBgbGF5b3V0YCB0byBiZSB1c2VkIGFzIHtAbGlua1xuICogT2Zmc2V0TGF5b3V0I2xheW91dHxsYXlvdXR9LiAgSWYgbm90IHByb3ZpZGVkIHRoZSBgbGF5b3V0YCBpcyB1c2VkXG4gKiB1bmNoYW5nZWQuXG4gKlxuICogQGF1Z21lbnRzIHtMYXlvdXR9XG4gKi9cbmNsYXNzIE9mZnNldExheW91dCBleHRlbmRzIEV4dGVybmFsTGF5b3V0IHtcbiAgICBjb25zdHJ1Y3RvcihsYXlvdXQsIG9mZnNldCA9IDAsIHByb3BlcnR5KSB7XG4gICAgICAgIGlmICghKGxheW91dCBpbnN0YW5jZW9mIExheW91dCkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2xheW91dCBtdXN0IGJlIGEgTGF5b3V0Jyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFOdW1iZXIuaXNJbnRlZ2VyKG9mZnNldCkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ29mZnNldCBtdXN0IGJlIGludGVnZXIgb3IgdW5kZWZpbmVkJyk7XG4gICAgICAgIH1cbiAgICAgICAgc3VwZXIobGF5b3V0LnNwYW4sIHByb3BlcnR5IHx8IGxheW91dC5wcm9wZXJ0eSk7XG4gICAgICAgIC8qKiBUaGUgc3Vib3JkaW5hdGVkIGxheW91dC4gKi9cbiAgICAgICAgdGhpcy5sYXlvdXQgPSBsYXlvdXQ7XG4gICAgICAgIC8qKiBUaGUgbG9jYXRpb24gb2Yge0BsaW5rIE9mZnNldExheW91dCNsYXlvdXR9IHJlbGF0aXZlIHRvIHRoZVxuICAgICAgICAgKiBzdGFydCBvZiBhbm90aGVyIGxheW91dC5cbiAgICAgICAgICpcbiAgICAgICAgICogVGhlIHZhbHVlIG1heSBiZSBwb3NpdGl2ZSBvciBuZWdhdGl2ZSwgYnV0IGFuIGVycm9yIHdpbGwgdGhyb3duXG4gICAgICAgICAqIGlmIGF0IHRoZSBwb2ludCBvZiB1c2UgaXQgZ29lcyBvdXRzaWRlIHRoZSBzcGFuIG9mIHRoZSBVaW50OEFycmF5XG4gICAgICAgICAqIGJlaW5nIGFjY2Vzc2VkLiAgKi9cbiAgICAgICAgdGhpcy5vZmZzZXQgPSBvZmZzZXQ7XG4gICAgfVxuICAgIC8qKiBAb3ZlcnJpZGUgKi9cbiAgICBpc0NvdW50KCkge1xuICAgICAgICByZXR1cm4gKCh0aGlzLmxheW91dCBpbnN0YW5jZW9mIFVJbnQpXG4gICAgICAgICAgICB8fCAodGhpcy5sYXlvdXQgaW5zdGFuY2VvZiBVSW50QkUpKTtcbiAgICB9XG4gICAgLyoqIEBvdmVycmlkZSAqL1xuICAgIGRlY29kZShiLCBvZmZzZXQgPSAwKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmxheW91dC5kZWNvZGUoYiwgb2Zmc2V0ICsgdGhpcy5vZmZzZXQpO1xuICAgIH1cbiAgICAvKiogQG92ZXJyaWRlICovXG4gICAgZW5jb2RlKHNyYywgYiwgb2Zmc2V0ID0gMCkge1xuICAgICAgICByZXR1cm4gdGhpcy5sYXlvdXQuZW5jb2RlKHNyYywgYiwgb2Zmc2V0ICsgdGhpcy5vZmZzZXQpO1xuICAgIH1cbn1cbmV4cG9ydHMuT2Zmc2V0TGF5b3V0ID0gT2Zmc2V0TGF5b3V0O1xuLyoqXG4gKiBSZXByZXNlbnQgYW4gdW5zaWduZWQgaW50ZWdlciBpbiBsaXR0bGUtZW5kaWFuIGZvcm1hdC5cbiAqXG4gKiAqRmFjdG9yeSo6IHtAbGluayBtb2R1bGU6TGF5b3V0LnU4fHU4fSwge0BsaW5rXG4gKiAgbW9kdWxlOkxheW91dC51MTZ8dTE2fSwge0BsaW5rIG1vZHVsZTpMYXlvdXQudTI0fHUyNH0sIHtAbGlua1xuICogIG1vZHVsZTpMYXlvdXQudTMyfHUzMn0sIHtAbGluayBtb2R1bGU6TGF5b3V0LnU0MHx1NDB9LCB7QGxpbmtcbiAqICBtb2R1bGU6TGF5b3V0LnU0OHx1NDh9XG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IHNwYW4gLSBpbml0aWFsaXplciBmb3Ige0BsaW5rIExheW91dCNzcGFufHNwYW59LlxuICogVGhlIHBhcmFtZXRlciBjYW4gcmFuZ2UgZnJvbSAxIHRocm91Z2ggNi5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gW3Byb3BlcnR5XSAtIGluaXRpYWxpemVyIGZvciB7QGxpbmtcbiAqIExheW91dCNwcm9wZXJ0eXxwcm9wZXJ0eX0uXG4gKlxuICogQGF1Z21lbnRzIHtMYXlvdXR9XG4gKi9cbmNsYXNzIFVJbnQgZXh0ZW5kcyBMYXlvdXQge1xuICAgIGNvbnN0cnVjdG9yKHNwYW4sIHByb3BlcnR5KSB7XG4gICAgICAgIHN1cGVyKHNwYW4sIHByb3BlcnR5KTtcbiAgICAgICAgaWYgKDYgPCB0aGlzLnNwYW4pIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdzcGFuIG11c3Qgbm90IGV4Y2VlZCA2IGJ5dGVzJyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqIEBvdmVycmlkZSAqL1xuICAgIGRlY29kZShiLCBvZmZzZXQgPSAwKSB7XG4gICAgICAgIHJldHVybiB1aW50OEFycmF5VG9CdWZmZXIoYikucmVhZFVJbnRMRShvZmZzZXQsIHRoaXMuc3Bhbik7XG4gICAgfVxuICAgIC8qKiBAb3ZlcnJpZGUgKi9cbiAgICBlbmNvZGUoc3JjLCBiLCBvZmZzZXQgPSAwKSB7XG4gICAgICAgIHVpbnQ4QXJyYXlUb0J1ZmZlcihiKS53cml0ZVVJbnRMRShzcmMsIG9mZnNldCwgdGhpcy5zcGFuKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3BhbjtcbiAgICB9XG59XG5leHBvcnRzLlVJbnQgPSBVSW50O1xuLyoqXG4gKiBSZXByZXNlbnQgYW4gdW5zaWduZWQgaW50ZWdlciBpbiBiaWctZW5kaWFuIGZvcm1hdC5cbiAqXG4gKiAqRmFjdG9yeSo6IHtAbGluayBtb2R1bGU6TGF5b3V0LnU4YmV8dThiZX0sIHtAbGlua1xuICogbW9kdWxlOkxheW91dC51MTZiZXx1MTZiZX0sIHtAbGluayBtb2R1bGU6TGF5b3V0LnUyNGJlfHUyNGJlfSxcbiAqIHtAbGluayBtb2R1bGU6TGF5b3V0LnUzMmJlfHUzMmJlfSwge0BsaW5rXG4gKiBtb2R1bGU6TGF5b3V0LnU0MGJlfHU0MGJlfSwge0BsaW5rIG1vZHVsZTpMYXlvdXQudTQ4YmV8dTQ4YmV9XG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IHNwYW4gLSBpbml0aWFsaXplciBmb3Ige0BsaW5rIExheW91dCNzcGFufHNwYW59LlxuICogVGhlIHBhcmFtZXRlciBjYW4gcmFuZ2UgZnJvbSAxIHRocm91Z2ggNi5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gW3Byb3BlcnR5XSAtIGluaXRpYWxpemVyIGZvciB7QGxpbmtcbiAqIExheW91dCNwcm9wZXJ0eXxwcm9wZXJ0eX0uXG4gKlxuICogQGF1Z21lbnRzIHtMYXlvdXR9XG4gKi9cbmNsYXNzIFVJbnRCRSBleHRlbmRzIExheW91dCB7XG4gICAgY29uc3RydWN0b3Ioc3BhbiwgcHJvcGVydHkpIHtcbiAgICAgICAgc3VwZXIoc3BhbiwgcHJvcGVydHkpO1xuICAgICAgICBpZiAoNiA8IHRoaXMuc3Bhbikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ3NwYW4gbXVzdCBub3QgZXhjZWVkIDYgYnl0ZXMnKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKiogQG92ZXJyaWRlICovXG4gICAgZGVjb2RlKGIsIG9mZnNldCA9IDApIHtcbiAgICAgICAgcmV0dXJuIHVpbnQ4QXJyYXlUb0J1ZmZlcihiKS5yZWFkVUludEJFKG9mZnNldCwgdGhpcy5zcGFuKTtcbiAgICB9XG4gICAgLyoqIEBvdmVycmlkZSAqL1xuICAgIGVuY29kZShzcmMsIGIsIG9mZnNldCA9IDApIHtcbiAgICAgICAgdWludDhBcnJheVRvQnVmZmVyKGIpLndyaXRlVUludEJFKHNyYywgb2Zmc2V0LCB0aGlzLnNwYW4pO1xuICAgICAgICByZXR1cm4gdGhpcy5zcGFuO1xuICAgIH1cbn1cbmV4cG9ydHMuVUludEJFID0gVUludEJFO1xuLyoqXG4gKiBSZXByZXNlbnQgYSBzaWduZWQgaW50ZWdlciBpbiBsaXR0bGUtZW5kaWFuIGZvcm1hdC5cbiAqXG4gKiAqRmFjdG9yeSo6IHtAbGluayBtb2R1bGU6TGF5b3V0LnM4fHM4fSwge0BsaW5rXG4gKiAgbW9kdWxlOkxheW91dC5zMTZ8czE2fSwge0BsaW5rIG1vZHVsZTpMYXlvdXQuczI0fHMyNH0sIHtAbGlua1xuICogIG1vZHVsZTpMYXlvdXQuczMyfHMzMn0sIHtAbGluayBtb2R1bGU6TGF5b3V0LnM0MHxzNDB9LCB7QGxpbmtcbiAqICBtb2R1bGU6TGF5b3V0LnM0OHxzNDh9XG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IHNwYW4gLSBpbml0aWFsaXplciBmb3Ige0BsaW5rIExheW91dCNzcGFufHNwYW59LlxuICogVGhlIHBhcmFtZXRlciBjYW4gcmFuZ2UgZnJvbSAxIHRocm91Z2ggNi5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gW3Byb3BlcnR5XSAtIGluaXRpYWxpemVyIGZvciB7QGxpbmtcbiAqIExheW91dCNwcm9wZXJ0eXxwcm9wZXJ0eX0uXG4gKlxuICogQGF1Z21lbnRzIHtMYXlvdXR9XG4gKi9cbmNsYXNzIEludCBleHRlbmRzIExheW91dCB7XG4gICAgY29uc3RydWN0b3Ioc3BhbiwgcHJvcGVydHkpIHtcbiAgICAgICAgc3VwZXIoc3BhbiwgcHJvcGVydHkpO1xuICAgICAgICBpZiAoNiA8IHRoaXMuc3Bhbikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ3NwYW4gbXVzdCBub3QgZXhjZWVkIDYgYnl0ZXMnKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKiogQG92ZXJyaWRlICovXG4gICAgZGVjb2RlKGIsIG9mZnNldCA9IDApIHtcbiAgICAgICAgcmV0dXJuIHVpbnQ4QXJyYXlUb0J1ZmZlcihiKS5yZWFkSW50TEUob2Zmc2V0LCB0aGlzLnNwYW4pO1xuICAgIH1cbiAgICAvKiogQG92ZXJyaWRlICovXG4gICAgZW5jb2RlKHNyYywgYiwgb2Zmc2V0ID0gMCkge1xuICAgICAgICB1aW50OEFycmF5VG9CdWZmZXIoYikud3JpdGVJbnRMRShzcmMsIG9mZnNldCwgdGhpcy5zcGFuKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3BhbjtcbiAgICB9XG59XG5leHBvcnRzLkludCA9IEludDtcbi8qKlxuICogUmVwcmVzZW50IGEgc2lnbmVkIGludGVnZXIgaW4gYmlnLWVuZGlhbiBmb3JtYXQuXG4gKlxuICogKkZhY3RvcnkqOiB7QGxpbmsgbW9kdWxlOkxheW91dC5zOGJlfHM4YmV9LCB7QGxpbmtcbiAqIG1vZHVsZTpMYXlvdXQuczE2YmV8czE2YmV9LCB7QGxpbmsgbW9kdWxlOkxheW91dC5zMjRiZXxzMjRiZX0sXG4gKiB7QGxpbmsgbW9kdWxlOkxheW91dC5zMzJiZXxzMzJiZX0sIHtAbGlua1xuICogbW9kdWxlOkxheW91dC5zNDBiZXxzNDBiZX0sIHtAbGluayBtb2R1bGU6TGF5b3V0LnM0OGJlfHM0OGJlfVxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSBzcGFuIC0gaW5pdGlhbGl6ZXIgZm9yIHtAbGluayBMYXlvdXQjc3BhbnxzcGFufS5cbiAqIFRoZSBwYXJhbWV0ZXIgY2FuIHJhbmdlIGZyb20gMSB0aHJvdWdoIDYuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IFtwcm9wZXJ0eV0gLSBpbml0aWFsaXplciBmb3Ige0BsaW5rXG4gKiBMYXlvdXQjcHJvcGVydHl8cHJvcGVydHl9LlxuICpcbiAqIEBhdWdtZW50cyB7TGF5b3V0fVxuICovXG5jbGFzcyBJbnRCRSBleHRlbmRzIExheW91dCB7XG4gICAgY29uc3RydWN0b3Ioc3BhbiwgcHJvcGVydHkpIHtcbiAgICAgICAgc3VwZXIoc3BhbiwgcHJvcGVydHkpO1xuICAgICAgICBpZiAoNiA8IHRoaXMuc3Bhbikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ3NwYW4gbXVzdCBub3QgZXhjZWVkIDYgYnl0ZXMnKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKiogQG92ZXJyaWRlICovXG4gICAgZGVjb2RlKGIsIG9mZnNldCA9IDApIHtcbiAgICAgICAgcmV0dXJuIHVpbnQ4QXJyYXlUb0J1ZmZlcihiKS5yZWFkSW50QkUob2Zmc2V0LCB0aGlzLnNwYW4pO1xuICAgIH1cbiAgICAvKiogQG92ZXJyaWRlICovXG4gICAgZW5jb2RlKHNyYywgYiwgb2Zmc2V0ID0gMCkge1xuICAgICAgICB1aW50OEFycmF5VG9CdWZmZXIoYikud3JpdGVJbnRCRShzcmMsIG9mZnNldCwgdGhpcy5zcGFuKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3BhbjtcbiAgICB9XG59XG5leHBvcnRzLkludEJFID0gSW50QkU7XG5jb25zdCBWMkUzMiA9IE1hdGgucG93KDIsIDMyKTtcbi8qIFRydWUgbW9kdWx1cyBoaWdoIGFuZCBsb3cgMzItYml0IHdvcmRzLCB3aGVyZSBsb3cgd29yZCBpcyBhbHdheXNcbiAqIG5vbi1uZWdhdGl2ZS4gKi9cbmZ1bmN0aW9uIGRpdm1vZEludDY0KHNyYykge1xuICAgIGNvbnN0IGhpMzIgPSBNYXRoLmZsb29yKHNyYyAvIFYyRTMyKTtcbiAgICBjb25zdCBsbzMyID0gc3JjIC0gKGhpMzIgKiBWMkUzMik7XG4gICAgcmV0dXJuIHsgaGkzMiwgbG8zMiB9O1xufVxuLyogUmVjb25zdHJ1Y3QgTnVtYmVyIGZyb20gcXVvdGllbnQgYW5kIG5vbi1uZWdhdGl2ZSByZW1haW5kZXIgKi9cbmZ1bmN0aW9uIHJvdW5kZWRJbnQ2NChoaTMyLCBsbzMyKSB7XG4gICAgcmV0dXJuIGhpMzIgKiBWMkUzMiArIGxvMzI7XG59XG4vKipcbiAqIFJlcHJlc2VudCBhbiB1bnNpZ25lZCA2NC1iaXQgaW50ZWdlciBpbiBsaXR0bGUtZW5kaWFuIGZvcm1hdCB3aGVuXG4gKiBlbmNvZGVkIGFuZCBhcyBhIG5lYXIgaW50ZWdyYWwgSmF2YVNjcmlwdCBOdW1iZXIgd2hlbiBkZWNvZGVkLlxuICpcbiAqICpGYWN0b3J5Kjoge0BsaW5rIG1vZHVsZTpMYXlvdXQubnU2NHxudTY0fVxuICpcbiAqICoqTk9URSoqIFZhbHVlcyB3aXRoIG1hZ25pdHVkZSBncmVhdGVyIHRoYW4gMl41MiBtYXkgbm90IGRlY29kZSB0b1xuICogdGhlIGV4YWN0IHZhbHVlIG9mIHRoZSBlbmNvZGVkIHJlcHJlc2VudGF0aW9uLlxuICpcbiAqIEBhdWdtZW50cyB7TGF5b3V0fVxuICovXG5jbGFzcyBOZWFyVUludDY0IGV4dGVuZHMgTGF5b3V0IHtcbiAgICBjb25zdHJ1Y3Rvcihwcm9wZXJ0eSkge1xuICAgICAgICBzdXBlcig4LCBwcm9wZXJ0eSk7XG4gICAgfVxuICAgIC8qKiBAb3ZlcnJpZGUgKi9cbiAgICBkZWNvZGUoYiwgb2Zmc2V0ID0gMCkge1xuICAgICAgICBjb25zdCBidWZmZXIgPSB1aW50OEFycmF5VG9CdWZmZXIoYik7XG4gICAgICAgIGNvbnN0IGxvMzIgPSBidWZmZXIucmVhZFVJbnQzMkxFKG9mZnNldCk7XG4gICAgICAgIGNvbnN0IGhpMzIgPSBidWZmZXIucmVhZFVJbnQzMkxFKG9mZnNldCArIDQpO1xuICAgICAgICByZXR1cm4gcm91bmRlZEludDY0KGhpMzIsIGxvMzIpO1xuICAgIH1cbiAgICAvKiogQG92ZXJyaWRlICovXG4gICAgZW5jb2RlKHNyYywgYiwgb2Zmc2V0ID0gMCkge1xuICAgICAgICBjb25zdCBzcGxpdCA9IGRpdm1vZEludDY0KHNyYyk7XG4gICAgICAgIGNvbnN0IGJ1ZmZlciA9IHVpbnQ4QXJyYXlUb0J1ZmZlcihiKTtcbiAgICAgICAgYnVmZmVyLndyaXRlVUludDMyTEUoc3BsaXQubG8zMiwgb2Zmc2V0KTtcbiAgICAgICAgYnVmZmVyLndyaXRlVUludDMyTEUoc3BsaXQuaGkzMiwgb2Zmc2V0ICsgNCk7XG4gICAgICAgIHJldHVybiA4O1xuICAgIH1cbn1cbmV4cG9ydHMuTmVhclVJbnQ2NCA9IE5lYXJVSW50NjQ7XG4vKipcbiAqIFJlcHJlc2VudCBhbiB1bnNpZ25lZCA2NC1iaXQgaW50ZWdlciBpbiBiaWctZW5kaWFuIGZvcm1hdCB3aGVuXG4gKiBlbmNvZGVkIGFuZCBhcyBhIG5lYXIgaW50ZWdyYWwgSmF2YVNjcmlwdCBOdW1iZXIgd2hlbiBkZWNvZGVkLlxuICpcbiAqICpGYWN0b3J5Kjoge0BsaW5rIG1vZHVsZTpMYXlvdXQubnU2NGJlfG51NjRiZX1cbiAqXG4gKiAqKk5PVEUqKiBWYWx1ZXMgd2l0aCBtYWduaXR1ZGUgZ3JlYXRlciB0aGFuIDJeNTIgbWF5IG5vdCBkZWNvZGUgdG9cbiAqIHRoZSBleGFjdCB2YWx1ZSBvZiB0aGUgZW5jb2RlZCByZXByZXNlbnRhdGlvbi5cbiAqXG4gKiBAYXVnbWVudHMge0xheW91dH1cbiAqL1xuY2xhc3MgTmVhclVJbnQ2NEJFIGV4dGVuZHMgTGF5b3V0IHtcbiAgICBjb25zdHJ1Y3Rvcihwcm9wZXJ0eSkge1xuICAgICAgICBzdXBlcig4LCBwcm9wZXJ0eSk7XG4gICAgfVxuICAgIC8qKiBAb3ZlcnJpZGUgKi9cbiAgICBkZWNvZGUoYiwgb2Zmc2V0ID0gMCkge1xuICAgICAgICBjb25zdCBidWZmZXIgPSB1aW50OEFycmF5VG9CdWZmZXIoYik7XG4gICAgICAgIGNvbnN0IGhpMzIgPSBidWZmZXIucmVhZFVJbnQzMkJFKG9mZnNldCk7XG4gICAgICAgIGNvbnN0IGxvMzIgPSBidWZmZXIucmVhZFVJbnQzMkJFKG9mZnNldCArIDQpO1xuICAgICAgICByZXR1cm4gcm91bmRlZEludDY0KGhpMzIsIGxvMzIpO1xuICAgIH1cbiAgICAvKiogQG92ZXJyaWRlICovXG4gICAgZW5jb2RlKHNyYywgYiwgb2Zmc2V0ID0gMCkge1xuICAgICAgICBjb25zdCBzcGxpdCA9IGRpdm1vZEludDY0KHNyYyk7XG4gICAgICAgIGNvbnN0IGJ1ZmZlciA9IHVpbnQ4QXJyYXlUb0J1ZmZlcihiKTtcbiAgICAgICAgYnVmZmVyLndyaXRlVUludDMyQkUoc3BsaXQuaGkzMiwgb2Zmc2V0KTtcbiAgICAgICAgYnVmZmVyLndyaXRlVUludDMyQkUoc3BsaXQubG8zMiwgb2Zmc2V0ICsgNCk7XG4gICAgICAgIHJldHVybiA4O1xuICAgIH1cbn1cbmV4cG9ydHMuTmVhclVJbnQ2NEJFID0gTmVhclVJbnQ2NEJFO1xuLyoqXG4gKiBSZXByZXNlbnQgYSBzaWduZWQgNjQtYml0IGludGVnZXIgaW4gbGl0dGxlLWVuZGlhbiBmb3JtYXQgd2hlblxuICogZW5jb2RlZCBhbmQgYXMgYSBuZWFyIGludGVncmFsIEphdmFTY3JpcHQgTnVtYmVyIHdoZW4gZGVjb2RlZC5cbiAqXG4gKiAqRmFjdG9yeSo6IHtAbGluayBtb2R1bGU6TGF5b3V0Lm5zNjR8bnM2NH1cbiAqXG4gKiAqKk5PVEUqKiBWYWx1ZXMgd2l0aCBtYWduaXR1ZGUgZ3JlYXRlciB0aGFuIDJeNTIgbWF5IG5vdCBkZWNvZGUgdG9cbiAqIHRoZSBleGFjdCB2YWx1ZSBvZiB0aGUgZW5jb2RlZCByZXByZXNlbnRhdGlvbi5cbiAqXG4gKiBAYXVnbWVudHMge0xheW91dH1cbiAqL1xuY2xhc3MgTmVhckludDY0IGV4dGVuZHMgTGF5b3V0IHtcbiAgICBjb25zdHJ1Y3Rvcihwcm9wZXJ0eSkge1xuICAgICAgICBzdXBlcig4LCBwcm9wZXJ0eSk7XG4gICAgfVxuICAgIC8qKiBAb3ZlcnJpZGUgKi9cbiAgICBkZWNvZGUoYiwgb2Zmc2V0ID0gMCkge1xuICAgICAgICBjb25zdCBidWZmZXIgPSB1aW50OEFycmF5VG9CdWZmZXIoYik7XG4gICAgICAgIGNvbnN0IGxvMzIgPSBidWZmZXIucmVhZFVJbnQzMkxFKG9mZnNldCk7XG4gICAgICAgIGNvbnN0IGhpMzIgPSBidWZmZXIucmVhZEludDMyTEUob2Zmc2V0ICsgNCk7XG4gICAgICAgIHJldHVybiByb3VuZGVkSW50NjQoaGkzMiwgbG8zMik7XG4gICAgfVxuICAgIC8qKiBAb3ZlcnJpZGUgKi9cbiAgICBlbmNvZGUoc3JjLCBiLCBvZmZzZXQgPSAwKSB7XG4gICAgICAgIGNvbnN0IHNwbGl0ID0gZGl2bW9kSW50NjQoc3JjKTtcbiAgICAgICAgY29uc3QgYnVmZmVyID0gdWludDhBcnJheVRvQnVmZmVyKGIpO1xuICAgICAgICBidWZmZXIud3JpdGVVSW50MzJMRShzcGxpdC5sbzMyLCBvZmZzZXQpO1xuICAgICAgICBidWZmZXIud3JpdGVJbnQzMkxFKHNwbGl0LmhpMzIsIG9mZnNldCArIDQpO1xuICAgICAgICByZXR1cm4gODtcbiAgICB9XG59XG5leHBvcnRzLk5lYXJJbnQ2NCA9IE5lYXJJbnQ2NDtcbi8qKlxuICogUmVwcmVzZW50IGEgc2lnbmVkIDY0LWJpdCBpbnRlZ2VyIGluIGJpZy1lbmRpYW4gZm9ybWF0IHdoZW5cbiAqIGVuY29kZWQgYW5kIGFzIGEgbmVhciBpbnRlZ3JhbCBKYXZhU2NyaXB0IE51bWJlciB3aGVuIGRlY29kZWQuXG4gKlxuICogKkZhY3RvcnkqOiB7QGxpbmsgbW9kdWxlOkxheW91dC5uczY0YmV8bnM2NGJlfVxuICpcbiAqICoqTk9URSoqIFZhbHVlcyB3aXRoIG1hZ25pdHVkZSBncmVhdGVyIHRoYW4gMl41MiBtYXkgbm90IGRlY29kZSB0b1xuICogdGhlIGV4YWN0IHZhbHVlIG9mIHRoZSBlbmNvZGVkIHJlcHJlc2VudGF0aW9uLlxuICpcbiAqIEBhdWdtZW50cyB7TGF5b3V0fVxuICovXG5jbGFzcyBOZWFySW50NjRCRSBleHRlbmRzIExheW91dCB7XG4gICAgY29uc3RydWN0b3IocHJvcGVydHkpIHtcbiAgICAgICAgc3VwZXIoOCwgcHJvcGVydHkpO1xuICAgIH1cbiAgICAvKiogQG92ZXJyaWRlICovXG4gICAgZGVjb2RlKGIsIG9mZnNldCA9IDApIHtcbiAgICAgICAgY29uc3QgYnVmZmVyID0gdWludDhBcnJheVRvQnVmZmVyKGIpO1xuICAgICAgICBjb25zdCBoaTMyID0gYnVmZmVyLnJlYWRJbnQzMkJFKG9mZnNldCk7XG4gICAgICAgIGNvbnN0IGxvMzIgPSBidWZmZXIucmVhZFVJbnQzMkJFKG9mZnNldCArIDQpO1xuICAgICAgICByZXR1cm4gcm91bmRlZEludDY0KGhpMzIsIGxvMzIpO1xuICAgIH1cbiAgICAvKiogQG92ZXJyaWRlICovXG4gICAgZW5jb2RlKHNyYywgYiwgb2Zmc2V0ID0gMCkge1xuICAgICAgICBjb25zdCBzcGxpdCA9IGRpdm1vZEludDY0KHNyYyk7XG4gICAgICAgIGNvbnN0IGJ1ZmZlciA9IHVpbnQ4QXJyYXlUb0J1ZmZlcihiKTtcbiAgICAgICAgYnVmZmVyLndyaXRlSW50MzJCRShzcGxpdC5oaTMyLCBvZmZzZXQpO1xuICAgICAgICBidWZmZXIud3JpdGVVSW50MzJCRShzcGxpdC5sbzMyLCBvZmZzZXQgKyA0KTtcbiAgICAgICAgcmV0dXJuIDg7XG4gICAgfVxufVxuZXhwb3J0cy5OZWFySW50NjRCRSA9IE5lYXJJbnQ2NEJFO1xuLyoqXG4gKiBSZXByZXNlbnQgYSAzMi1iaXQgZmxvYXRpbmcgcG9pbnQgbnVtYmVyIGluIGxpdHRsZS1lbmRpYW4gZm9ybWF0LlxuICpcbiAqICpGYWN0b3J5Kjoge0BsaW5rIG1vZHVsZTpMYXlvdXQuZjMyfGYzMn1cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gW3Byb3BlcnR5XSAtIGluaXRpYWxpemVyIGZvciB7QGxpbmtcbiAqIExheW91dCNwcm9wZXJ0eXxwcm9wZXJ0eX0uXG4gKlxuICogQGF1Z21lbnRzIHtMYXlvdXR9XG4gKi9cbmNsYXNzIEZsb2F0IGV4dGVuZHMgTGF5b3V0IHtcbiAgICBjb25zdHJ1Y3Rvcihwcm9wZXJ0eSkge1xuICAgICAgICBzdXBlcig0LCBwcm9wZXJ0eSk7XG4gICAgfVxuICAgIC8qKiBAb3ZlcnJpZGUgKi9cbiAgICBkZWNvZGUoYiwgb2Zmc2V0ID0gMCkge1xuICAgICAgICByZXR1cm4gdWludDhBcnJheVRvQnVmZmVyKGIpLnJlYWRGbG9hdExFKG9mZnNldCk7XG4gICAgfVxuICAgIC8qKiBAb3ZlcnJpZGUgKi9cbiAgICBlbmNvZGUoc3JjLCBiLCBvZmZzZXQgPSAwKSB7XG4gICAgICAgIHVpbnQ4QXJyYXlUb0J1ZmZlcihiKS53cml0ZUZsb2F0TEUoc3JjLCBvZmZzZXQpO1xuICAgICAgICByZXR1cm4gNDtcbiAgICB9XG59XG5leHBvcnRzLkZsb2F0ID0gRmxvYXQ7XG4vKipcbiAqIFJlcHJlc2VudCBhIDMyLWJpdCBmbG9hdGluZyBwb2ludCBudW1iZXIgaW4gYmlnLWVuZGlhbiBmb3JtYXQuXG4gKlxuICogKkZhY3RvcnkqOiB7QGxpbmsgbW9kdWxlOkxheW91dC5mMzJiZXxmMzJiZX1cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gW3Byb3BlcnR5XSAtIGluaXRpYWxpemVyIGZvciB7QGxpbmtcbiAqIExheW91dCNwcm9wZXJ0eXxwcm9wZXJ0eX0uXG4gKlxuICogQGF1Z21lbnRzIHtMYXlvdXR9XG4gKi9cbmNsYXNzIEZsb2F0QkUgZXh0ZW5kcyBMYXlvdXQge1xuICAgIGNvbnN0cnVjdG9yKHByb3BlcnR5KSB7XG4gICAgICAgIHN1cGVyKDQsIHByb3BlcnR5KTtcbiAgICB9XG4gICAgLyoqIEBvdmVycmlkZSAqL1xuICAgIGRlY29kZShiLCBvZmZzZXQgPSAwKSB7XG4gICAgICAgIHJldHVybiB1aW50OEFycmF5VG9CdWZmZXIoYikucmVhZEZsb2F0QkUob2Zmc2V0KTtcbiAgICB9XG4gICAgLyoqIEBvdmVycmlkZSAqL1xuICAgIGVuY29kZShzcmMsIGIsIG9mZnNldCA9IDApIHtcbiAgICAgICAgdWludDhBcnJheVRvQnVmZmVyKGIpLndyaXRlRmxvYXRCRShzcmMsIG9mZnNldCk7XG4gICAgICAgIHJldHVybiA0O1xuICAgIH1cbn1cbmV4cG9ydHMuRmxvYXRCRSA9IEZsb2F0QkU7XG4vKipcbiAqIFJlcHJlc2VudCBhIDY0LWJpdCBmbG9hdGluZyBwb2ludCBudW1iZXIgaW4gbGl0dGxlLWVuZGlhbiBmb3JtYXQuXG4gKlxuICogKkZhY3RvcnkqOiB7QGxpbmsgbW9kdWxlOkxheW91dC5mNjR8ZjY0fVxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBbcHJvcGVydHldIC0gaW5pdGlhbGl6ZXIgZm9yIHtAbGlua1xuICogTGF5b3V0I3Byb3BlcnR5fHByb3BlcnR5fS5cbiAqXG4gKiBAYXVnbWVudHMge0xheW91dH1cbiAqL1xuY2xhc3MgRG91YmxlIGV4dGVuZHMgTGF5b3V0IHtcbiAgICBjb25zdHJ1Y3Rvcihwcm9wZXJ0eSkge1xuICAgICAgICBzdXBlcig4LCBwcm9wZXJ0eSk7XG4gICAgfVxuICAgIC8qKiBAb3ZlcnJpZGUgKi9cbiAgICBkZWNvZGUoYiwgb2Zmc2V0ID0gMCkge1xuICAgICAgICByZXR1cm4gdWludDhBcnJheVRvQnVmZmVyKGIpLnJlYWREb3VibGVMRShvZmZzZXQpO1xuICAgIH1cbiAgICAvKiogQG92ZXJyaWRlICovXG4gICAgZW5jb2RlKHNyYywgYiwgb2Zmc2V0ID0gMCkge1xuICAgICAgICB1aW50OEFycmF5VG9CdWZmZXIoYikud3JpdGVEb3VibGVMRShzcmMsIG9mZnNldCk7XG4gICAgICAgIHJldHVybiA4O1xuICAgIH1cbn1cbmV4cG9ydHMuRG91YmxlID0gRG91YmxlO1xuLyoqXG4gKiBSZXByZXNlbnQgYSA2NC1iaXQgZmxvYXRpbmcgcG9pbnQgbnVtYmVyIGluIGJpZy1lbmRpYW4gZm9ybWF0LlxuICpcbiAqICpGYWN0b3J5Kjoge0BsaW5rIG1vZHVsZTpMYXlvdXQuZjY0YmV8ZjY0YmV9XG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IFtwcm9wZXJ0eV0gLSBpbml0aWFsaXplciBmb3Ige0BsaW5rXG4gKiBMYXlvdXQjcHJvcGVydHl8cHJvcGVydHl9LlxuICpcbiAqIEBhdWdtZW50cyB7TGF5b3V0fVxuICovXG5jbGFzcyBEb3VibGVCRSBleHRlbmRzIExheW91dCB7XG4gICAgY29uc3RydWN0b3IocHJvcGVydHkpIHtcbiAgICAgICAgc3VwZXIoOCwgcHJvcGVydHkpO1xuICAgIH1cbiAgICAvKiogQG92ZXJyaWRlICovXG4gICAgZGVjb2RlKGIsIG9mZnNldCA9IDApIHtcbiAgICAgICAgcmV0dXJuIHVpbnQ4QXJyYXlUb0J1ZmZlcihiKS5yZWFkRG91YmxlQkUob2Zmc2V0KTtcbiAgICB9XG4gICAgLyoqIEBvdmVycmlkZSAqL1xuICAgIGVuY29kZShzcmMsIGIsIG9mZnNldCA9IDApIHtcbiAgICAgICAgdWludDhBcnJheVRvQnVmZmVyKGIpLndyaXRlRG91YmxlQkUoc3JjLCBvZmZzZXQpO1xuICAgICAgICByZXR1cm4gODtcbiAgICB9XG59XG5leHBvcnRzLkRvdWJsZUJFID0gRG91YmxlQkU7XG4vKipcbiAqIFJlcHJlc2VudCBhIGNvbnRpZ3VvdXMgc2VxdWVuY2Ugb2YgYSBzcGVjaWZpYyBsYXlvdXQgYXMgYW4gQXJyYXkuXG4gKlxuICogKkZhY3RvcnkqOiB7QGxpbmsgbW9kdWxlOkxheW91dC5zZXF8c2VxfVxuICpcbiAqIEBwYXJhbSB7TGF5b3V0fSBlbGVtZW50TGF5b3V0IC0gaW5pdGlhbGl6ZXIgZm9yIHtAbGlua1xuICogU2VxdWVuY2UjZWxlbWVudExheW91dHxlbGVtZW50TGF5b3V0fS5cbiAqXG4gKiBAcGFyYW0geyhOdW1iZXJ8RXh0ZXJuYWxMYXlvdXQpfSBjb3VudCAtIGluaXRpYWxpemVyIGZvciB7QGxpbmtcbiAqIFNlcXVlbmNlI2NvdW50fGNvdW50fS4gIFRoZSBwYXJhbWV0ZXIgbXVzdCBiZSBlaXRoZXIgYSBwb3NpdGl2ZVxuICogaW50ZWdlciBvciBhbiBpbnN0YW5jZSBvZiB7QGxpbmsgRXh0ZXJuYWxMYXlvdXR9LlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBbcHJvcGVydHldIC0gaW5pdGlhbGl6ZXIgZm9yIHtAbGlua1xuICogTGF5b3V0I3Byb3BlcnR5fHByb3BlcnR5fS5cbiAqXG4gKiBAYXVnbWVudHMge0xheW91dH1cbiAqL1xuY2xhc3MgU2VxdWVuY2UgZXh0ZW5kcyBMYXlvdXQge1xuICAgIGNvbnN0cnVjdG9yKGVsZW1lbnRMYXlvdXQsIGNvdW50LCBwcm9wZXJ0eSkge1xuICAgICAgICBpZiAoIShlbGVtZW50TGF5b3V0IGluc3RhbmNlb2YgTGF5b3V0KSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignZWxlbWVudExheW91dCBtdXN0IGJlIGEgTGF5b3V0Jyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCEoKChjb3VudCBpbnN0YW5jZW9mIEV4dGVybmFsTGF5b3V0KSAmJiBjb3VudC5pc0NvdW50KCkpXG4gICAgICAgICAgICB8fCAoTnVtYmVyLmlzSW50ZWdlcihjb3VudCkgJiYgKDAgPD0gY291bnQpKSkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2NvdW50IG11c3QgYmUgbm9uLW5lZ2F0aXZlIGludGVnZXIgJ1xuICAgICAgICAgICAgICAgICsgJ29yIGFuIHVuc2lnbmVkIGludGVnZXIgRXh0ZXJuYWxMYXlvdXQnKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgc3BhbiA9IC0xO1xuICAgICAgICBpZiAoKCEoY291bnQgaW5zdGFuY2VvZiBFeHRlcm5hbExheW91dCkpXG4gICAgICAgICAgICAmJiAoMCA8IGVsZW1lbnRMYXlvdXQuc3BhbikpIHtcbiAgICAgICAgICAgIHNwYW4gPSBjb3VudCAqIGVsZW1lbnRMYXlvdXQuc3BhbjtcbiAgICAgICAgfVxuICAgICAgICBzdXBlcihzcGFuLCBwcm9wZXJ0eSk7XG4gICAgICAgIC8qKiBUaGUgbGF5b3V0IGZvciBpbmRpdmlkdWFsIGVsZW1lbnRzIG9mIHRoZSBzZXF1ZW5jZS4gKi9cbiAgICAgICAgdGhpcy5lbGVtZW50TGF5b3V0ID0gZWxlbWVudExheW91dDtcbiAgICAgICAgLyoqIFRoZSBudW1iZXIgb2YgZWxlbWVudHMgaW4gdGhlIHNlcXVlbmNlLlxuICAgICAgICAgKlxuICAgICAgICAgKiBUaGlzIHdpbGwgYmUgZWl0aGVyIGEgbm9uLW5lZ2F0aXZlIGludGVnZXIgb3IgYW4gaW5zdGFuY2Ugb2ZcbiAgICAgICAgICoge0BsaW5rIEV4dGVybmFsTGF5b3V0fSBmb3Igd2hpY2gge0BsaW5rXG4gICAgICAgICAqIEV4dGVybmFsTGF5b3V0I2lzQ291bnR8aXNDb3VudCgpfSBpcyBgdHJ1ZWAuICovXG4gICAgICAgIHRoaXMuY291bnQgPSBjb3VudDtcbiAgICB9XG4gICAgLyoqIEBvdmVycmlkZSAqL1xuICAgIGdldFNwYW4oYiwgb2Zmc2V0ID0gMCkge1xuICAgICAgICBpZiAoMCA8PSB0aGlzLnNwYW4pIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnNwYW47XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHNwYW4gPSAwO1xuICAgICAgICBsZXQgY291bnQgPSB0aGlzLmNvdW50O1xuICAgICAgICBpZiAoY291bnQgaW5zdGFuY2VvZiBFeHRlcm5hbExheW91dCkge1xuICAgICAgICAgICAgY291bnQgPSBjb3VudC5kZWNvZGUoYiwgb2Zmc2V0KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoMCA8IHRoaXMuZWxlbWVudExheW91dC5zcGFuKSB7XG4gICAgICAgICAgICBzcGFuID0gY291bnQgKiB0aGlzLmVsZW1lbnRMYXlvdXQuc3BhbjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGxldCBpZHggPSAwO1xuICAgICAgICAgICAgd2hpbGUgKGlkeCA8IGNvdW50KSB7XG4gICAgICAgICAgICAgICAgc3BhbiArPSB0aGlzLmVsZW1lbnRMYXlvdXQuZ2V0U3BhbihiLCBvZmZzZXQgKyBzcGFuKTtcbiAgICAgICAgICAgICAgICArK2lkeDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3BhbjtcbiAgICB9XG4gICAgLyoqIEBvdmVycmlkZSAqL1xuICAgIGRlY29kZShiLCBvZmZzZXQgPSAwKSB7XG4gICAgICAgIGNvbnN0IHJ2ID0gW107XG4gICAgICAgIGxldCBpID0gMDtcbiAgICAgICAgbGV0IGNvdW50ID0gdGhpcy5jb3VudDtcbiAgICAgICAgaWYgKGNvdW50IGluc3RhbmNlb2YgRXh0ZXJuYWxMYXlvdXQpIHtcbiAgICAgICAgICAgIGNvdW50ID0gY291bnQuZGVjb2RlKGIsIG9mZnNldCk7XG4gICAgICAgIH1cbiAgICAgICAgd2hpbGUgKGkgPCBjb3VudCkge1xuICAgICAgICAgICAgcnYucHVzaCh0aGlzLmVsZW1lbnRMYXlvdXQuZGVjb2RlKGIsIG9mZnNldCkpO1xuICAgICAgICAgICAgb2Zmc2V0ICs9IHRoaXMuZWxlbWVudExheW91dC5nZXRTcGFuKGIsIG9mZnNldCk7XG4gICAgICAgICAgICBpICs9IDE7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJ2O1xuICAgIH1cbiAgICAvKiogSW1wbGVtZW50IHtAbGluayBMYXlvdXQjZW5jb2RlfGVuY29kZX0gZm9yIHtAbGluayBTZXF1ZW5jZX0uXG4gICAgICpcbiAgICAgKiAqKk5PVEUqKiBJZiBgc3JjYCBpcyBzaG9ydGVyIHRoYW4ge0BsaW5rIFNlcXVlbmNlI2NvdW50fGNvdW50fSB0aGVuXG4gICAgICogdGhlIHVudXNlZCBzcGFjZSBpbiB0aGUgYnVmZmVyIGlzIGxlZnQgdW5jaGFuZ2VkLiAgSWYgYHNyY2AgaXNcbiAgICAgKiBsb25nZXIgdGhhbiB7QGxpbmsgU2VxdWVuY2UjY291bnR8Y291bnR9IHRoZSB1bm5lZWRlZCBlbGVtZW50cyBhcmVcbiAgICAgKiBpZ25vcmVkLlxuICAgICAqXG4gICAgICogKipOT1RFKiogSWYge0BsaW5rIExheW91dCNjb3VudHxjb3VudH0gaXMgYW4gaW5zdGFuY2Ugb2Yge0BsaW5rXG4gICAgICogRXh0ZXJuYWxMYXlvdXR9IHRoZW4gdGhlIGxlbmd0aCBvZiBgc3JjYCB3aWxsIGJlIGVuY29kZWQgYXMgdGhlXG4gICAgICogY291bnQgYWZ0ZXIgYHNyY2AgaXMgZW5jb2RlZC4gKi9cbiAgICBlbmNvZGUoc3JjLCBiLCBvZmZzZXQgPSAwKSB7XG4gICAgICAgIGNvbnN0IGVsbyA9IHRoaXMuZWxlbWVudExheW91dDtcbiAgICAgICAgY29uc3Qgc3BhbiA9IHNyYy5yZWR1Y2UoKHNwYW4sIHYpID0+IHtcbiAgICAgICAgICAgIHJldHVybiBzcGFuICsgZWxvLmVuY29kZSh2LCBiLCBvZmZzZXQgKyBzcGFuKTtcbiAgICAgICAgfSwgMCk7XG4gICAgICAgIGlmICh0aGlzLmNvdW50IGluc3RhbmNlb2YgRXh0ZXJuYWxMYXlvdXQpIHtcbiAgICAgICAgICAgIHRoaXMuY291bnQuZW5jb2RlKHNyYy5sZW5ndGgsIGIsIG9mZnNldCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHNwYW47XG4gICAgfVxufVxuZXhwb3J0cy5TZXF1ZW5jZSA9IFNlcXVlbmNlO1xuLyoqXG4gKiBSZXByZXNlbnQgYSBjb250aWd1b3VzIHNlcXVlbmNlIG9mIGFyYml0cmFyeSBsYXlvdXQgZWxlbWVudHMgYXMgYW5cbiAqIE9iamVjdC5cbiAqXG4gKiAqRmFjdG9yeSo6IHtAbGluayBtb2R1bGU6TGF5b3V0LnN0cnVjdHxzdHJ1Y3R9XG4gKlxuICogKipOT1RFKiogVGhlIHtAbGluayBMYXlvdXQjc3BhbnxzcGFufSBvZiB0aGUgc3RydWN0dXJlIGlzIHZhcmlhYmxlXG4gKiBpZiBhbnkgbGF5b3V0IGluIHtAbGluayBTdHJ1Y3R1cmUjZmllbGRzfGZpZWxkc30gaGFzIGEgdmFyaWFibGVcbiAqIHNwYW4uICBXaGVuIHtAbGluayBMYXlvdXQjZW5jb2RlfGVuY29kaW5nfSB3ZSBtdXN0IGhhdmUgYSB2YWx1ZSBmb3JcbiAqIGFsbCB2YXJpYWJsZS1sZW5ndGggZmllbGRzLCBvciB3ZSB3b3VsZG4ndCBiZSBhYmxlIHRvIGZpZ3VyZSBvdXRcbiAqIGhvdyBtdWNoIHNwYWNlIHRvIHVzZSBmb3Igc3RvcmFnZS4gIFdlIGNhbiBvbmx5IGlkZW50aWZ5IHRoZSB2YWx1ZVxuICogZm9yIGEgZmllbGQgd2hlbiBpdCBoYXMgYSB7QGxpbmsgTGF5b3V0I3Byb3BlcnR5fHByb3BlcnR5fS4gIEFzXG4gKiBzdWNoLCBhbHRob3VnaCBhIHN0cnVjdHVyZSBtYXkgY29udGFpbiBib3RoIHVubmFtZWQgZmllbGRzIGFuZFxuICogdmFyaWFibGUtbGVuZ3RoIGZpZWxkcywgaXQgY2Fubm90IGNvbnRhaW4gYW4gdW5uYW1lZFxuICogdmFyaWFibGUtbGVuZ3RoIGZpZWxkLlxuICpcbiAqIEBwYXJhbSB7TGF5b3V0W119IGZpZWxkcyAtIGluaXRpYWxpemVyIGZvciB7QGxpbmtcbiAqIFN0cnVjdHVyZSNmaWVsZHN8ZmllbGRzfS4gIEFuIGVycm9yIGlzIHJhaXNlZCBpZiB0aGlzIGNvbnRhaW5zIGFcbiAqIHZhcmlhYmxlLWxlbmd0aCBmaWVsZCBmb3Igd2hpY2ggYSB7QGxpbmsgTGF5b3V0I3Byb3BlcnR5fHByb3BlcnR5fVxuICogaXMgbm90IGRlZmluZWQuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IFtwcm9wZXJ0eV0gLSBpbml0aWFsaXplciBmb3Ige0BsaW5rXG4gKiBMYXlvdXQjcHJvcGVydHl8cHJvcGVydHl9LlxuICpcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW2RlY29kZVByZWZpeGVzXSAtIGluaXRpYWxpemVyIGZvciB7QGxpbmtcbiAqIFN0cnVjdHVyZSNkZWNvZGVQcmVmaXhlc3xwcm9wZXJ0eX0uXG4gKlxuICogQHRocm93cyB7RXJyb3J9IC0gaWYgYGZpZWxkc2AgY29udGFpbnMgYW4gdW5uYW1lZCB2YXJpYWJsZS1sZW5ndGhcbiAqIGxheW91dC5cbiAqXG4gKiBAYXVnbWVudHMge0xheW91dH1cbiAqL1xuY2xhc3MgU3RydWN0dXJlIGV4dGVuZHMgTGF5b3V0IHtcbiAgICBjb25zdHJ1Y3RvcihmaWVsZHMsIHByb3BlcnR5LCBkZWNvZGVQcmVmaXhlcykge1xuICAgICAgICBpZiAoIShBcnJheS5pc0FycmF5KGZpZWxkcylcbiAgICAgICAgICAgICYmIGZpZWxkcy5yZWR1Y2UoKGFjYywgdikgPT4gYWNjICYmICh2IGluc3RhbmNlb2YgTGF5b3V0KSwgdHJ1ZSkpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdmaWVsZHMgbXVzdCBiZSBhcnJheSBvZiBMYXlvdXQgaW5zdGFuY2VzJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCgnYm9vbGVhbicgPT09IHR5cGVvZiBwcm9wZXJ0eSlcbiAgICAgICAgICAgICYmICh1bmRlZmluZWQgPT09IGRlY29kZVByZWZpeGVzKSkge1xuICAgICAgICAgICAgZGVjb2RlUHJlZml4ZXMgPSBwcm9wZXJ0eTtcbiAgICAgICAgICAgIHByb3BlcnR5ID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIC8qIFZlcmlmeSBhYnNlbmNlIG9mIHVubmFtZWQgdmFyaWFibGUtbGVuZ3RoIGZpZWxkcy4gKi9cbiAgICAgICAgZm9yIChjb25zdCBmZCBvZiBmaWVsZHMpIHtcbiAgICAgICAgICAgIGlmICgoMCA+IGZkLnNwYW4pXG4gICAgICAgICAgICAgICAgJiYgKHVuZGVmaW5lZCA9PT0gZmQucHJvcGVydHkpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdmaWVsZHMgY2Fubm90IGNvbnRhaW4gdW5uYW1lZCB2YXJpYWJsZS1sZW5ndGggbGF5b3V0Jyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHNwYW4gPSAtMTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHNwYW4gPSBmaWVsZHMucmVkdWNlKChzcGFuLCBmZCkgPT4gc3BhbiArIGZkLmdldFNwYW4oKSwgMCk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIC8vIGlnbm9yZSBlcnJvclxuICAgICAgICB9XG4gICAgICAgIHN1cGVyKHNwYW4sIHByb3BlcnR5KTtcbiAgICAgICAgLyoqIFRoZSBzZXF1ZW5jZSBvZiB7QGxpbmsgTGF5b3V0fSB2YWx1ZXMgdGhhdCBjb21wcmlzZSB0aGVcbiAgICAgICAgICogc3RydWN0dXJlLlxuICAgICAgICAgKlxuICAgICAgICAgKiBUaGUgaW5kaXZpZHVhbCBlbGVtZW50cyBuZWVkIG5vdCBiZSB0aGUgc2FtZSB0eXBlLCBhbmQgbWF5IGJlXG4gICAgICAgICAqIGVpdGhlciBzY2FsYXIgb3IgYWdncmVnYXRlIGxheW91dHMuICBJZiBhIG1lbWJlciBsYXlvdXQgbGVhdmVzXG4gICAgICAgICAqIGl0cyB7QGxpbmsgTGF5b3V0I3Byb3BlcnR5fHByb3BlcnR5fSB1bmRlZmluZWQgdGhlXG4gICAgICAgICAqIGNvcnJlc3BvbmRpbmcgcmVnaW9uIG9mIHRoZSBidWZmZXIgYXNzb2NpYXRlZCB3aXRoIHRoZSBlbGVtZW50XG4gICAgICAgICAqIHdpbGwgbm90IGJlIG11dGF0ZWQuXG4gICAgICAgICAqXG4gICAgICAgICAqIEB0eXBlIHtMYXlvdXRbXX0gKi9cbiAgICAgICAgdGhpcy5maWVsZHMgPSBmaWVsZHM7XG4gICAgICAgIC8qKiBDb250cm9sIGJlaGF2aW9yIG9mIHtAbGluayBMYXlvdXQjZGVjb2RlfGRlY29kZSgpfSBnaXZlbiBzaG9ydFxuICAgICAgICAgKiBidWZmZXJzLlxuICAgICAgICAgKlxuICAgICAgICAgKiBJbiBzb21lIHNpdHVhdGlvbnMgYSBzdHJ1Y3R1cmUgbWFueSBiZSBleHRlbmRlZCB3aXRoIGFkZGl0aW9uYWxcbiAgICAgICAgICogZmllbGRzIG92ZXIgdGltZSwgd2l0aCBvbGRlciBpbnN0YWxsYXRpb25zIHByb3ZpZGluZyBvbmx5IGFcbiAgICAgICAgICogcHJlZml4IG9mIHRoZSBmdWxsIHN0cnVjdHVyZS4gIElmIHRoaXMgcHJvcGVydHkgaXMgYHRydWVgXG4gICAgICAgICAqIGRlY29kaW5nIHdpbGwgYWNjZXB0IHRob3NlIGJ1ZmZlcnMgYW5kIGxlYXZlIHN1YnNlcXVlbnQgZmllbGRzXG4gICAgICAgICAqIHVuZGVmaW5lZCwgYXMgbG9uZyBhcyB0aGUgYnVmZmVyIGVuZHMgYXQgYSBmaWVsZCBib3VuZGFyeS5cbiAgICAgICAgICogRGVmYXVsdHMgdG8gYGZhbHNlYC4gKi9cbiAgICAgICAgdGhpcy5kZWNvZGVQcmVmaXhlcyA9ICEhZGVjb2RlUHJlZml4ZXM7XG4gICAgfVxuICAgIC8qKiBAb3ZlcnJpZGUgKi9cbiAgICBnZXRTcGFuKGIsIG9mZnNldCA9IDApIHtcbiAgICAgICAgaWYgKDAgPD0gdGhpcy5zcGFuKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zcGFuO1xuICAgICAgICB9XG4gICAgICAgIGxldCBzcGFuID0gMDtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHNwYW4gPSB0aGlzLmZpZWxkcy5yZWR1Y2UoKHNwYW4sIGZkKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgZnNwID0gZmQuZ2V0U3BhbihiLCBvZmZzZXQpO1xuICAgICAgICAgICAgICAgIG9mZnNldCArPSBmc3A7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHNwYW4gKyBmc3A7XG4gICAgICAgICAgICB9LCAwKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ2luZGV0ZXJtaW5hdGUgc3BhbicpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzcGFuO1xuICAgIH1cbiAgICAvKiogQG92ZXJyaWRlICovXG4gICAgZGVjb2RlKGIsIG9mZnNldCA9IDApIHtcbiAgICAgICAgY2hlY2tVaW50OEFycmF5KGIpO1xuICAgICAgICBjb25zdCBkZXN0ID0gdGhpcy5tYWtlRGVzdGluYXRpb25PYmplY3QoKTtcbiAgICAgICAgZm9yIChjb25zdCBmZCBvZiB0aGlzLmZpZWxkcykge1xuICAgICAgICAgICAgaWYgKHVuZGVmaW5lZCAhPT0gZmQucHJvcGVydHkpIHtcbiAgICAgICAgICAgICAgICBkZXN0W2ZkLnByb3BlcnR5XSA9IGZkLmRlY29kZShiLCBvZmZzZXQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgb2Zmc2V0ICs9IGZkLmdldFNwYW4oYiwgb2Zmc2V0KTtcbiAgICAgICAgICAgIGlmICh0aGlzLmRlY29kZVByZWZpeGVzXG4gICAgICAgICAgICAgICAgJiYgKGIubGVuZ3RoID09PSBvZmZzZXQpKSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGRlc3Q7XG4gICAgfVxuICAgIC8qKiBJbXBsZW1lbnQge0BsaW5rIExheW91dCNlbmNvZGV8ZW5jb2RlfSBmb3Ige0BsaW5rIFN0cnVjdHVyZX0uXG4gICAgICpcbiAgICAgKiBJZiBgc3JjYCBpcyBtaXNzaW5nIGEgcHJvcGVydHkgZm9yIGEgbWVtYmVyIHdpdGggYSBkZWZpbmVkIHtAbGlua1xuICAgICAqIExheW91dCNwcm9wZXJ0eXxwcm9wZXJ0eX0gdGhlIGNvcnJlc3BvbmRpbmcgcmVnaW9uIG9mIHRoZSBidWZmZXIgaXNcbiAgICAgKiBsZWZ0IHVubW9kaWZpZWQuICovXG4gICAgZW5jb2RlKHNyYywgYiwgb2Zmc2V0ID0gMCkge1xuICAgICAgICBjb25zdCBmaXJzdE9mZnNldCA9IG9mZnNldDtcbiAgICAgICAgbGV0IGxhc3RPZmZzZXQgPSAwO1xuICAgICAgICBsZXQgbGFzdFdyb3RlID0gMDtcbiAgICAgICAgZm9yIChjb25zdCBmZCBvZiB0aGlzLmZpZWxkcykge1xuICAgICAgICAgICAgbGV0IHNwYW4gPSBmZC5zcGFuO1xuICAgICAgICAgICAgbGFzdFdyb3RlID0gKDAgPCBzcGFuKSA/IHNwYW4gOiAwO1xuICAgICAgICAgICAgaWYgKHVuZGVmaW5lZCAhPT0gZmQucHJvcGVydHkpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBmdiA9IHNyY1tmZC5wcm9wZXJ0eV07XG4gICAgICAgICAgICAgICAgaWYgKHVuZGVmaW5lZCAhPT0gZnYpIHtcbiAgICAgICAgICAgICAgICAgICAgbGFzdFdyb3RlID0gZmQuZW5jb2RlKGZ2LCBiLCBvZmZzZXQpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoMCA+IHNwYW4pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8qIFJlYWQgdGhlIGFzLWVuY29kZWQgc3Bhbiwgd2hpY2ggaXMgbm90IG5lY2Vzc2FyaWx5IHRoZVxuICAgICAgICAgICAgICAgICAgICAgICAgICogc2FtZSBhcyB3aGF0IHdlIHdyb3RlLiAqL1xuICAgICAgICAgICAgICAgICAgICAgICAgc3BhbiA9IGZkLmdldFNwYW4oYiwgb2Zmc2V0KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxhc3RPZmZzZXQgPSBvZmZzZXQ7XG4gICAgICAgICAgICBvZmZzZXQgKz0gc3BhbjtcbiAgICAgICAgfVxuICAgICAgICAvKiBVc2UgKGxhc3RPZmZzZXQgKyBsYXN0V3JvdGUpIGluc3RlYWQgb2Ygb2Zmc2V0IGJlY2F1c2UgdGhlIGxhc3RcbiAgICAgICAgICogaXRlbSBtYXkgaGF2ZSBoYWQgYSBkeW5hbWljIGxlbmd0aCBhbmQgd2UgZG9uJ3Qgd2FudCB0byBpbmNsdWRlXG4gICAgICAgICAqIHRoZSBwYWRkaW5nIGJldHdlZW4gaXQgYW5kIHRoZSBlbmQgb2YgdGhlIHNwYWNlIHJlc2VydmVkIGZvclxuICAgICAgICAgKiBpdC4gKi9cbiAgICAgICAgcmV0dXJuIChsYXN0T2Zmc2V0ICsgbGFzdFdyb3RlKSAtIGZpcnN0T2Zmc2V0O1xuICAgIH1cbiAgICAvKiogQG92ZXJyaWRlICovXG4gICAgZnJvbUFycmF5KHZhbHVlcykge1xuICAgICAgICBjb25zdCBkZXN0ID0gdGhpcy5tYWtlRGVzdGluYXRpb25PYmplY3QoKTtcbiAgICAgICAgZm9yIChjb25zdCBmZCBvZiB0aGlzLmZpZWxkcykge1xuICAgICAgICAgICAgaWYgKCh1bmRlZmluZWQgIT09IGZkLnByb3BlcnR5KVxuICAgICAgICAgICAgICAgICYmICgwIDwgdmFsdWVzLmxlbmd0aCkpIHtcbiAgICAgICAgICAgICAgICBkZXN0W2ZkLnByb3BlcnR5XSA9IHZhbHVlcy5zaGlmdCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkZXN0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgYWNjZXNzIHRvIHRoZSBsYXlvdXQgb2YgYSBnaXZlbiBwcm9wZXJ0eS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBwcm9wZXJ0eSAtIHRoZSBzdHJ1Y3R1cmUgbWVtYmVyIG9mIGludGVyZXN0LlxuICAgICAqXG4gICAgICogQHJldHVybiB7TGF5b3V0fSAtIHRoZSBsYXlvdXQgYXNzb2NpYXRlZCB3aXRoIGBwcm9wZXJ0eWAsIG9yXG4gICAgICogdW5kZWZpbmVkIGlmIHRoZXJlIGlzIG5vIHN1Y2ggcHJvcGVydHkuXG4gICAgICovXG4gICAgbGF5b3V0Rm9yKHByb3BlcnR5KSB7XG4gICAgICAgIGlmICgnc3RyaW5nJyAhPT0gdHlwZW9mIHByb3BlcnR5KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdwcm9wZXJ0eSBtdXN0IGJlIHN0cmluZycpO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoY29uc3QgZmQgb2YgdGhpcy5maWVsZHMpIHtcbiAgICAgICAgICAgIGlmIChmZC5wcm9wZXJ0eSA9PT0gcHJvcGVydHkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBvZmZzZXQgb2YgYSBzdHJ1Y3R1cmUgbWVtYmVyLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHByb3BlcnR5IC0gdGhlIHN0cnVjdHVyZSBtZW1iZXIgb2YgaW50ZXJlc3QuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHtOdW1iZXJ9IC0gdGhlIG9mZnNldCBpbiBieXRlcyB0byB0aGUgc3RhcnQgb2YgYHByb3BlcnR5YFxuICAgICAqIHdpdGhpbiB0aGUgc3RydWN0dXJlLCBvciB1bmRlZmluZWQgaWYgYHByb3BlcnR5YCBpcyBub3QgYSBmaWVsZFxuICAgICAqIHdpdGhpbiB0aGUgc3RydWN0dXJlLiAgSWYgdGhlIHByb3BlcnR5IGlzIGEgbWVtYmVyIGJ1dCBmb2xsb3dzIGFcbiAgICAgKiB2YXJpYWJsZS1sZW5ndGggc3RydWN0dXJlIG1lbWJlciBhIG5lZ2F0aXZlIG51bWJlciB3aWxsIGJlXG4gICAgICogcmV0dXJuZWQuXG4gICAgICovXG4gICAgb2Zmc2V0T2YocHJvcGVydHkpIHtcbiAgICAgICAgaWYgKCdzdHJpbmcnICE9PSB0eXBlb2YgcHJvcGVydHkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ3Byb3BlcnR5IG11c3QgYmUgc3RyaW5nJyk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IG9mZnNldCA9IDA7XG4gICAgICAgIGZvciAoY29uc3QgZmQgb2YgdGhpcy5maWVsZHMpIHtcbiAgICAgICAgICAgIGlmIChmZC5wcm9wZXJ0eSA9PT0gcHJvcGVydHkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gb2Zmc2V0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKDAgPiBmZC5zcGFuKSB7XG4gICAgICAgICAgICAgICAgb2Zmc2V0ID0gLTE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICgwIDw9IG9mZnNldCkge1xuICAgICAgICAgICAgICAgIG9mZnNldCArPSBmZC5zcGFuO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxufVxuZXhwb3J0cy5TdHJ1Y3R1cmUgPSBTdHJ1Y3R1cmU7XG4vKipcbiAqIEFuIG9iamVjdCB0aGF0IGNhbiBwcm92aWRlIGEge0BsaW5rXG4gKiBVbmlvbiNkaXNjcmltaW5hdG9yfGRpc2NyaW1pbmF0b3J9IEFQSSBmb3Ige0BsaW5rIFVuaW9ufS5cbiAqXG4gKiAqKk5PVEUqKiBUaGlzIGlzIGFuIGFic3RyYWN0IGJhc2UgY2xhc3M7IHlvdSBjYW4gY3JlYXRlIGluc3RhbmNlc1xuICogaWYgaXQgYW11c2VzIHlvdSwgYnV0IHRoZXkgd29uJ3Qgc3VwcG9ydCB0aGUge0BsaW5rXG4gKiBVbmlvbkRpc2NyaW1pbmF0b3IjZW5jb2RlfGVuY29kZX0gb3Ige0BsaW5rXG4gKiBVbmlvbkRpc2NyaW1pbmF0b3IjZGVjb2RlfGRlY29kZX0gZnVuY3Rpb25zLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBbcHJvcGVydHldIC0gRGVmYXVsdCBmb3Ige0BsaW5rXG4gKiBVbmlvbkRpc2NyaW1pbmF0b3IjcHJvcGVydHl8cHJvcGVydHl9LlxuICpcbiAqIEBhYnN0cmFjdFxuICovXG5jbGFzcyBVbmlvbkRpc2NyaW1pbmF0b3Ige1xuICAgIGNvbnN0cnVjdG9yKHByb3BlcnR5KSB7XG4gICAgICAgIC8qKiBUaGUge0BsaW5rIExheW91dCNwcm9wZXJ0eXxwcm9wZXJ0eX0gdG8gYmUgdXNlZCB3aGVuIHRoZVxuICAgICAgICAgKiBkaXNjcmltaW5hdG9yIGlzIHJlZmVyZW5jZWQgaW4gaXNvbGF0aW9uIChnZW5lcmFsbHkgd2hlbiB7QGxpbmtcbiAgICAgICAgICogVW5pb24jZGVjb2RlfFVuaW9uIGRlY29kZX0gY2Fubm90IGRlbGVnYXRlIHRvIGEgc3BlY2lmaWNcbiAgICAgICAgICogdmFyaWFudCkuICovXG4gICAgICAgIHRoaXMucHJvcGVydHkgPSBwcm9wZXJ0eTtcbiAgICB9XG4gICAgLyoqIEFuYWxvZyB0byB7QGxpbmsgTGF5b3V0I2RlY29kZXxMYXlvdXQgZGVjb2RlfSBmb3IgdW5pb24gZGlzY3JpbWluYXRvcnMuXG4gICAgICpcbiAgICAgKiBUaGUgaW1wbGVtZW50YXRpb24gb2YgdGhpcyBtZXRob2QgbmVlZCBub3QgcmVmZXJlbmNlIHRoZSBidWZmZXIgaWZcbiAgICAgKiB2YXJpYW50IGluZm9ybWF0aW9uIGlzIGF2YWlsYWJsZSB0aHJvdWdoIG90aGVyIG1lYW5zLiAqL1xuICAgIGRlY29kZShiLCBvZmZzZXQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmlvbkRpc2NyaW1pbmF0b3IgaXMgYWJzdHJhY3QnKTtcbiAgICB9XG4gICAgLyoqIEFuYWxvZyB0byB7QGxpbmsgTGF5b3V0I2RlY29kZXxMYXlvdXQgZW5jb2RlfSBmb3IgdW5pb24gZGlzY3JpbWluYXRvcnMuXG4gICAgICpcbiAgICAgKiBUaGUgaW1wbGVtZW50YXRpb24gb2YgdGhpcyBtZXRob2QgbmVlZCBub3Qgc3RvcmUgdGhlIHZhbHVlIGlmXG4gICAgICogdmFyaWFudCBpbmZvcm1hdGlvbiBpcyBtYWludGFpbmVkIHRocm91Z2ggb3RoZXIgbWVhbnMuICovXG4gICAgZW5jb2RlKHNyYywgYiwgb2Zmc2V0KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignVW5pb25EaXNjcmltaW5hdG9yIGlzIGFic3RyYWN0Jyk7XG4gICAgfVxufVxuZXhwb3J0cy5VbmlvbkRpc2NyaW1pbmF0b3IgPSBVbmlvbkRpc2NyaW1pbmF0b3I7XG4vKipcbiAqIEFuIG9iamVjdCB0aGF0IGNhbiBwcm92aWRlIGEge0BsaW5rXG4gKiBVbmlvbkRpc2NyaW1pbmF0b3J8ZGlzY3JpbWluYXRvciBBUEl9IGZvciB7QGxpbmsgVW5pb259IHVzaW5nIGFuXG4gKiB1bnNpZ25lZCBpbnRlZ3JhbCB7QGxpbmsgTGF5b3V0fSBpbnN0YW5jZSBsb2NhdGVkIGVpdGhlciBpbnNpZGUgb3JcbiAqIG91dHNpZGUgdGhlIHVuaW9uLlxuICpcbiAqIEBwYXJhbSB7RXh0ZXJuYWxMYXlvdXR9IGxheW91dCAtIGluaXRpYWxpemVzIHtAbGlua1xuICogVW5pb25MYXlvdXREaXNjcmltaW5hdG9yI2xheW91dHxsYXlvdXR9LiAgTXVzdCBzYXRpc2Z5IHtAbGlua1xuICogRXh0ZXJuYWxMYXlvdXQjaXNDb3VudHxpc0NvdW50KCl9LlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBbcHJvcGVydHldIC0gRGVmYXVsdCBmb3Ige0BsaW5rXG4gKiBVbmlvbkRpc2NyaW1pbmF0b3IjcHJvcGVydHl8cHJvcGVydHl9LCBzdXBlcnNlZGluZyB0aGUgcHJvcGVydHlcbiAqIGZyb20gYGxheW91dGAsIGJ1dCBkZWZhdWx0aW5nIHRvIGB2YXJpYW50YCBpZiBuZWl0aGVyIGBwcm9wZXJ0eWBcbiAqIG5vciBsYXlvdXQgcHJvdmlkZSBhIHByb3BlcnR5IG5hbWUuXG4gKlxuICogQGF1Z21lbnRzIHtVbmlvbkRpc2NyaW1pbmF0b3J9XG4gKi9cbmNsYXNzIFVuaW9uTGF5b3V0RGlzY3JpbWluYXRvciBleHRlbmRzIFVuaW9uRGlzY3JpbWluYXRvciB7XG4gICAgY29uc3RydWN0b3IobGF5b3V0LCBwcm9wZXJ0eSkge1xuICAgICAgICBpZiAoISgobGF5b3V0IGluc3RhbmNlb2YgRXh0ZXJuYWxMYXlvdXQpXG4gICAgICAgICAgICAmJiBsYXlvdXQuaXNDb3VudCgpKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignbGF5b3V0IG11c3QgYmUgYW4gdW5zaWduZWQgaW50ZWdlciBFeHRlcm5hbExheW91dCcpO1xuICAgICAgICB9XG4gICAgICAgIHN1cGVyKHByb3BlcnR5IHx8IGxheW91dC5wcm9wZXJ0eSB8fCAndmFyaWFudCcpO1xuICAgICAgICAvKiogVGhlIHtAbGluayBFeHRlcm5hbExheW91dH0gdXNlZCB0byBhY2Nlc3MgdGhlIGRpc2NyaW1pbmF0b3JcbiAgICAgICAgICogdmFsdWUuICovXG4gICAgICAgIHRoaXMubGF5b3V0ID0gbGF5b3V0O1xuICAgIH1cbiAgICAvKiogRGVsZWdhdGUgZGVjb2RpbmcgdG8ge0BsaW5rIFVuaW9uTGF5b3V0RGlzY3JpbWluYXRvciNsYXlvdXR8bGF5b3V0fS4gKi9cbiAgICBkZWNvZGUoYiwgb2Zmc2V0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmxheW91dC5kZWNvZGUoYiwgb2Zmc2V0KTtcbiAgICB9XG4gICAgLyoqIERlbGVnYXRlIGVuY29kaW5nIHRvIHtAbGluayBVbmlvbkxheW91dERpc2NyaW1pbmF0b3IjbGF5b3V0fGxheW91dH0uICovXG4gICAgZW5jb2RlKHNyYywgYiwgb2Zmc2V0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmxheW91dC5lbmNvZGUoc3JjLCBiLCBvZmZzZXQpO1xuICAgIH1cbn1cbmV4cG9ydHMuVW5pb25MYXlvdXREaXNjcmltaW5hdG9yID0gVW5pb25MYXlvdXREaXNjcmltaW5hdG9yO1xuLyoqXG4gKiBSZXByZXNlbnQgYW55IG51bWJlciBvZiBzcGFuLWNvbXBhdGlibGUgbGF5b3V0cy5cbiAqXG4gKiAqRmFjdG9yeSo6IHtAbGluayBtb2R1bGU6TGF5b3V0LnVuaW9ufHVuaW9ufVxuICpcbiAqIElmIHRoZSB1bmlvbiBoYXMgYSB7QGxpbmsgVW5pb24jZGVmYXVsdExheW91dHxkZWZhdWx0IGxheW91dH0gdGhhdFxuICogbGF5b3V0IG11c3QgaGF2ZSBhIG5vbi1uZWdhdGl2ZSB7QGxpbmsgTGF5b3V0I3NwYW58c3Bhbn0uICBUaGUgc3BhblxuICogb2YgYSBmaXhlZC1zcGFuIHVuaW9uIGluY2x1ZGVzIGl0cyB7QGxpbmtcbiAqIFVuaW9uI2Rpc2NyaW1pbmF0b3J8ZGlzY3JpbWluYXRvcn0gaWYgdGhlIHZhcmlhbnQgaXMgYSB7QGxpbmtcbiAqIFVuaW9uI3VzZXNQcmVmaXhEaXNjcmltaW5hdG9yfHByZWZpeCBvZiB0aGUgdW5pb259LCBwbHVzIHRoZSBzcGFuXG4gKiBvZiBpdHMge0BsaW5rIFVuaW9uI2RlZmF1bHRMYXlvdXR8ZGVmYXVsdCBsYXlvdXR9LlxuICpcbiAqIElmIHRoZSB1bmlvbiBkb2VzIG5vdCBoYXZlIGEgZGVmYXVsdCBsYXlvdXQgdGhlbiB0aGUgZW5jb2RlZCBzcGFuXG4gKiBvZiB0aGUgdW5pb24gZGVwZW5kcyBvbiB0aGUgZW5jb2RlZCBzcGFuIG9mIGl0cyB2YXJpYW50ICh3aGljaCBtYXlcbiAqIGJlIGZpeGVkIG9yIHZhcmlhYmxlKS5cbiAqXG4gKiB7QGxpbmsgVmFyaWFudExheW91dCNsYXlvdXR8VmFyaWFudCBsYXlvdXR9cyBhcmUgYWRkZWQgdGhyb3VnaFxuICoge0BsaW5rIFVuaW9uI2FkZFZhcmlhbnR8YWRkVmFyaWFudH0uICBJZiB0aGUgdW5pb24gaGFzIGEgZGVmYXVsdFxuICogbGF5b3V0LCB0aGUgc3BhbiBvZiB0aGUge0BsaW5rIFZhcmlhbnRMYXlvdXQjbGF5b3V0fGxheW91dFxuICogY29udGFpbmVkIGJ5IHRoZSB2YXJpYW50fSBtdXN0IG5vdCBleGNlZWQgdGhlIHNwYW4gb2YgdGhlIHtAbGlua1xuICogVW5pb24jZGVmYXVsdExheW91dHxkZWZhdWx0IGxheW91dH0gKG1pbnVzIHRoZSBzcGFuIG9mIGEge0BsaW5rXG4gKiBVbmlvbiN1c2VzUHJlZml4RGlzY3JpbWluYXRvcnxwcmVmaXggZGlzcmltaW5hdG9yfSwgaWYgdXNlZCkuICBUaGVcbiAqIHNwYW4gb2YgdGhlIHZhcmlhbnQgd2lsbCBlcXVhbCB0aGUgc3BhbiBvZiB0aGUgdW5pb24gaXRzZWxmLlxuICpcbiAqIFRoZSB2YXJpYW50IGZvciBhIGJ1ZmZlciBjYW4gb25seSBiZSBpZGVudGlmaWVkIGZyb20gdGhlIHtAbGlua1xuICogVW5pb24jZGlzY3JpbWluYXRvcnxkaXNjcmltaW5hdG9yfSB7QGxpbmtcbiAqIFVuaW9uRGlzY3JpbWluYXRvciNwcm9wZXJ0eXxwcm9wZXJ0eX0gKGluIHRoZSBjYXNlIG9mIHRoZSB7QGxpbmtcbiAqIFVuaW9uI2RlZmF1bHRMYXlvdXR8ZGVmYXVsdCBsYXlvdXR9KSwgb3IgYnkgdXNpbmcge0BsaW5rXG4gKiBVbmlvbiNnZXRWYXJpYW50fGdldFZhcmlhbnR9IGFuZCBleGFtaW5pbmcgdGhlIHJlc3VsdGluZyB7QGxpbmtcbiAqIFZhcmlhbnRMYXlvdXR9IGluc3RhbmNlLlxuICpcbiAqIEEgdmFyaWFudCBjb21wYXRpYmxlIHdpdGggYSBKYXZhU2NyaXB0IG9iamVjdCBjYW4gYmUgaWRlbnRpZmllZFxuICogdXNpbmcge0BsaW5rIFVuaW9uI2dldFNvdXJjZVZhcmlhbnR8Z2V0U291cmNlVmFyaWFudH0uXG4gKlxuICogQHBhcmFtIHsoVW5pb25EaXNjcmltaW5hdG9yfEV4dGVybmFsTGF5b3V0fExheW91dCl9IGRpc2NyIC0gSG93IHRvXG4gKiBpZGVudGlmeSB0aGUgbGF5b3V0IHVzZWQgdG8gaW50ZXJwcmV0IHRoZSB1bmlvbiBjb250ZW50cy4gIFRoZVxuICogcGFyYW1ldGVyIG11c3QgYmUgYW4gaW5zdGFuY2Ugb2Yge0BsaW5rIFVuaW9uRGlzY3JpbWluYXRvcn0sIGFuXG4gKiB7QGxpbmsgRXh0ZXJuYWxMYXlvdXR9IHRoYXQgc2F0aXNmaWVzIHtAbGlua1xuICogRXh0ZXJuYWxMYXlvdXQjaXNDb3VudHxpc0NvdW50KCl9LCBvciB7QGxpbmsgVUludH0gKG9yIHtAbGlua1xuICogVUludEJFfSkuICBXaGVuIGEgbm9uLWV4dGVybmFsIGxheW91dCBlbGVtZW50IGlzIHBhc3NlZCB0aGUgbGF5b3V0XG4gKiBhcHBlYXJzIGF0IHRoZSBzdGFydCBvZiB0aGUgdW5pb24uICBJbiBhbGwgY2FzZXMgdGhlIChzeW50aGVzaXplZClcbiAqIHtAbGluayBVbmlvbkRpc2NyaW1pbmF0b3J9IGluc3RhbmNlIGlzIHJlY29yZGVkIGFzIHtAbGlua1xuICogVW5pb24jZGlzY3JpbWluYXRvcnxkaXNjcmltaW5hdG9yfS5cbiAqXG4gKiBAcGFyYW0geyhMYXlvdXR8bnVsbCl9IGRlZmF1bHRMYXlvdXQgLSBpbml0aWFsaXplciBmb3Ige0BsaW5rXG4gKiBVbmlvbiNkZWZhdWx0TGF5b3V0fGRlZmF1bHRMYXlvdXR9LiAgSWYgYWJzZW50IGRlZmF1bHRzIHRvIGBudWxsYC5cbiAqIElmIGBudWxsYCB0aGVyZSBpcyBubyBkZWZhdWx0IGxheW91dDogdGhlIHVuaW9uIGhhcyBkYXRhLWRlcGVuZGVudFxuICogbGVuZ3RoIGFuZCBhdHRlbXB0cyB0byBkZWNvZGUgb3IgZW5jb2RlIHVucmVjb2duaXplZCB2YXJpYW50cyB3aWxsXG4gKiB0aHJvdyBhbiBleGNlcHRpb24uICBBIHtAbGluayBMYXlvdXR9IGluc3RhbmNlIG11c3QgaGF2ZSBhXG4gKiBub24tbmVnYXRpdmUge0BsaW5rIExheW91dCNzcGFufHNwYW59LCBhbmQgaWYgaXQgbGFja3MgYSB7QGxpbmtcbiAqIExheW91dCNwcm9wZXJ0eXxwcm9wZXJ0eX0gdGhlIHtAbGlua1xuICogVW5pb24jZGVmYXVsdExheW91dHxkZWZhdWx0TGF5b3V0fSB3aWxsIGJlIGEge0BsaW5rXG4gKiBMYXlvdXQjcmVwbGljYXRlfHJlcGxpY2F9IHdpdGggcHJvcGVydHkgYGNvbnRlbnRgLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBbcHJvcGVydHldIC0gaW5pdGlhbGl6ZXIgZm9yIHtAbGlua1xuICogTGF5b3V0I3Byb3BlcnR5fHByb3BlcnR5fS5cbiAqXG4gKiBAYXVnbWVudHMge0xheW91dH1cbiAqL1xuY2xhc3MgVW5pb24gZXh0ZW5kcyBMYXlvdXQge1xuICAgIGNvbnN0cnVjdG9yKGRpc2NyLCBkZWZhdWx0TGF5b3V0LCBwcm9wZXJ0eSkge1xuICAgICAgICBsZXQgZGlzY3JpbWluYXRvcjtcbiAgICAgICAgaWYgKChkaXNjciBpbnN0YW5jZW9mIFVJbnQpXG4gICAgICAgICAgICB8fCAoZGlzY3IgaW5zdGFuY2VvZiBVSW50QkUpKSB7XG4gICAgICAgICAgICBkaXNjcmltaW5hdG9yID0gbmV3IFVuaW9uTGF5b3V0RGlzY3JpbWluYXRvcihuZXcgT2Zmc2V0TGF5b3V0KGRpc2NyKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoKGRpc2NyIGluc3RhbmNlb2YgRXh0ZXJuYWxMYXlvdXQpXG4gICAgICAgICAgICAmJiBkaXNjci5pc0NvdW50KCkpIHtcbiAgICAgICAgICAgIGRpc2NyaW1pbmF0b3IgPSBuZXcgVW5pb25MYXlvdXREaXNjcmltaW5hdG9yKGRpc2NyKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICghKGRpc2NyIGluc3RhbmNlb2YgVW5pb25EaXNjcmltaW5hdG9yKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignZGlzY3IgbXVzdCBiZSBhIFVuaW9uRGlzY3JpbWluYXRvciAnXG4gICAgICAgICAgICAgICAgKyAnb3IgYW4gdW5zaWduZWQgaW50ZWdlciBsYXlvdXQnKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGRpc2NyaW1pbmF0b3IgPSBkaXNjcjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodW5kZWZpbmVkID09PSBkZWZhdWx0TGF5b3V0KSB7XG4gICAgICAgICAgICBkZWZhdWx0TGF5b3V0ID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoISgobnVsbCA9PT0gZGVmYXVsdExheW91dClcbiAgICAgICAgICAgIHx8IChkZWZhdWx0TGF5b3V0IGluc3RhbmNlb2YgTGF5b3V0KSkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2RlZmF1bHRMYXlvdXQgbXVzdCBiZSBudWxsIG9yIGEgTGF5b3V0Jyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG51bGwgIT09IGRlZmF1bHRMYXlvdXQpIHtcbiAgICAgICAgICAgIGlmICgwID4gZGVmYXVsdExheW91dC5zcGFuKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdkZWZhdWx0TGF5b3V0IG11c3QgaGF2ZSBjb25zdGFudCBzcGFuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodW5kZWZpbmVkID09PSBkZWZhdWx0TGF5b3V0LnByb3BlcnR5KSB7XG4gICAgICAgICAgICAgICAgZGVmYXVsdExheW91dCA9IGRlZmF1bHRMYXlvdXQucmVwbGljYXRlKCdjb250ZW50Jyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLyogVGhlIHVuaW9uIHNwYW4gY2FuIGJlIGVzdGltYXRlZCBvbmx5IGlmIHRoZXJlJ3MgYSBkZWZhdWx0XG4gICAgICAgICAqIGxheW91dC4gIFRoZSB1bmlvbiBzcGFucyBpdHMgZGVmYXVsdCBsYXlvdXQsIHBsdXMgYW55IHByZWZpeFxuICAgICAgICAgKiB2YXJpYW50IGxheW91dC4gIEJ5IGNvbnN0cnVjdGlvbiBib3RoIGxheW91dHMsIGlmIHByZXNlbnQsIGhhdmVcbiAgICAgICAgICogbm9uLW5lZ2F0aXZlIHNwYW4uICovXG4gICAgICAgIGxldCBzcGFuID0gLTE7XG4gICAgICAgIGlmIChkZWZhdWx0TGF5b3V0KSB7XG4gICAgICAgICAgICBzcGFuID0gZGVmYXVsdExheW91dC5zcGFuO1xuICAgICAgICAgICAgaWYgKCgwIDw9IHNwYW4pICYmICgoZGlzY3IgaW5zdGFuY2VvZiBVSW50KVxuICAgICAgICAgICAgICAgIHx8IChkaXNjciBpbnN0YW5jZW9mIFVJbnRCRSkpKSB7XG4gICAgICAgICAgICAgICAgc3BhbiArPSBkaXNjcmltaW5hdG9yLmxheW91dC5zcGFuO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHN1cGVyKHNwYW4sIHByb3BlcnR5KTtcbiAgICAgICAgLyoqIFRoZSBpbnRlcmZhY2UgZm9yIHRoZSBkaXNjcmltaW5hdG9yIHZhbHVlIGluIGlzb2xhdGlvbi5cbiAgICAgICAgICpcbiAgICAgICAgICogVGhpcyBhIHtAbGluayBVbmlvbkRpc2NyaW1pbmF0b3J9IGVpdGhlciBwYXNzZWQgdG8gdGhlXG4gICAgICAgICAqIGNvbnN0cnVjdG9yIG9yIHN5bnRoZXNpemVkIGZyb20gdGhlIGBkaXNjcmAgY29uc3RydWN0b3JcbiAgICAgICAgICogYXJndW1lbnQuICB7QGxpbmtcbiAgICAgICAgICogVW5pb24jdXNlc1ByZWZpeERpc2NyaW1pbmF0b3J8dXNlc1ByZWZpeERpc2NyaW1pbmF0b3J9IHdpbGwgYmVcbiAgICAgICAgICogYHRydWVgIGlmZiB0aGUgYGRpc2NyYCBwYXJhbWV0ZXIgd2FzIGEgbm9uLW9mZnNldCB7QGxpbmtcbiAgICAgICAgICogTGF5b3V0fSBpbnN0YW5jZS4gKi9cbiAgICAgICAgdGhpcy5kaXNjcmltaW5hdG9yID0gZGlzY3JpbWluYXRvcjtcbiAgICAgICAgLyoqIGB0cnVlYCBpZiB0aGUge0BsaW5rIFVuaW9uI2Rpc2NyaW1pbmF0b3J8ZGlzY3JpbWluYXRvcn0gaXMgdGhlXG4gICAgICAgICAqIGZpcnN0IGZpZWxkIGluIHRoZSB1bmlvbi5cbiAgICAgICAgICpcbiAgICAgICAgICogSWYgYGZhbHNlYCB0aGUgZGlzY3JpbWluYXRvciBpcyBvYnRhaW5lZCBmcm9tIHNvbWV3aGVyZVxuICAgICAgICAgKiBlbHNlLiAqL1xuICAgICAgICB0aGlzLnVzZXNQcmVmaXhEaXNjcmltaW5hdG9yID0gKGRpc2NyIGluc3RhbmNlb2YgVUludClcbiAgICAgICAgICAgIHx8IChkaXNjciBpbnN0YW5jZW9mIFVJbnRCRSk7XG4gICAgICAgIC8qKiBUaGUgbGF5b3V0IGZvciBub24tZGlzY3JpbWluYXRvciBjb250ZW50IHdoZW4gdGhlIHZhbHVlIG9mIHRoZVxuICAgICAgICAgKiBkaXNjcmltaW5hdG9yIGlzIG5vdCByZWNvZ25pemVkLlxuICAgICAgICAgKlxuICAgICAgICAgKiBUaGlzIGlzIHRoZSB2YWx1ZSBwYXNzZWQgdG8gdGhlIGNvbnN0cnVjdG9yLiAgSXQgaXNcbiAgICAgICAgICogc3RydWN0dXJhbGx5IGVxdWl2YWxlbnQgdG8gdGhlIHNlY29uZCBjb21wb25lbnQgb2Yge0BsaW5rXG4gICAgICAgICAqIFVuaW9uI2xheW91dHxsYXlvdXR9IGJ1dCBtYXkgaGF2ZSBhIGRpZmZlcmVudCBwcm9wZXJ0eVxuICAgICAgICAgKiBuYW1lLiAqL1xuICAgICAgICB0aGlzLmRlZmF1bHRMYXlvdXQgPSBkZWZhdWx0TGF5b3V0O1xuICAgICAgICAvKiogQSByZWdpc3RyeSBvZiBhbGxvd2VkIHZhcmlhbnRzLlxuICAgICAgICAgKlxuICAgICAgICAgKiBUaGUga2V5cyBhcmUgdW5zaWduZWQgaW50ZWdlcnMgd2hpY2ggc2hvdWxkIGJlIGNvbXBhdGlibGUgd2l0aFxuICAgICAgICAgKiB7QGxpbmsgVW5pb24uZGlzY3JpbWluYXRvcnxkaXNjcmltaW5hdG9yfS4gIFRoZSBwcm9wZXJ0eSB2YWx1ZVxuICAgICAgICAgKiBpcyB0aGUgY29ycmVzcG9uZGluZyB7QGxpbmsgVmFyaWFudExheW91dH0gaW5zdGFuY2VzIGFzc2lnbmVkXG4gICAgICAgICAqIHRvIHRoaXMgdW5pb24gYnkge0BsaW5rIFVuaW9uI2FkZFZhcmlhbnR8YWRkVmFyaWFudH0uXG4gICAgICAgICAqXG4gICAgICAgICAqICoqTk9URSoqIFRoZSByZWdpc3RyeSByZW1haW5zIG11dGFibGUgc28gdGhhdCB2YXJpYW50cyBjYW4gYmVcbiAgICAgICAgICoge0BsaW5rIFVuaW9uI2FkZFZhcmlhbnR8YWRkZWR9IGF0IGFueSB0aW1lLiAgVXNlcnMgc2hvdWxkIG5vdFxuICAgICAgICAgKiBtYW5pcHVsYXRlIHRoZSBjb250ZW50IG9mIHRoaXMgcHJvcGVydHkuICovXG4gICAgICAgIHRoaXMucmVnaXN0cnkgPSB7fTtcbiAgICAgICAgLyogUHJpdmF0ZSB2YXJpYWJsZSB1c2VkIHdoZW4gaW52b2tpbmcgZ2V0U291cmNlVmFyaWFudCAqL1xuICAgICAgICBsZXQgYm91bmRHZXRTb3VyY2VWYXJpYW50ID0gdGhpcy5kZWZhdWx0R2V0U291cmNlVmFyaWFudC5iaW5kKHRoaXMpO1xuICAgICAgICAvKiogRnVuY3Rpb24gdG8gaW5mZXIgdGhlIHZhcmlhbnQgc2VsZWN0ZWQgYnkgYSBzb3VyY2Ugb2JqZWN0LlxuICAgICAgICAgKlxuICAgICAgICAgKiBEZWZhdWx0cyB0byB7QGxpbmtcbiAgICAgICAgICogVW5pb24jZGVmYXVsdEdldFNvdXJjZVZhcmlhbnR8ZGVmYXVsdEdldFNvdXJjZVZhcmlhbnR9IGJ1dCBtYXlcbiAgICAgICAgICogYmUgb3ZlcnJpZGRlbiB1c2luZyB7QGxpbmtcbiAgICAgICAgICogVW5pb24jY29uZmlnR2V0U291cmNlVmFyaWFudHxjb25maWdHZXRTb3VyY2VWYXJpYW50fS5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IHNyYyAtIGFzIHdpdGgge0BsaW5rXG4gICAgICAgICAqIFVuaW9uI2RlZmF1bHRHZXRTb3VyY2VWYXJpYW50fGRlZmF1bHRHZXRTb3VyY2VWYXJpYW50fS5cbiAgICAgICAgICpcbiAgICAgICAgICogQHJldHVybnMgeyh1bmRlZmluZWR8VmFyaWFudExheW91dCl9IFRoZSBkZWZhdWx0IHZhcmlhbnRcbiAgICAgICAgICogKGB1bmRlZmluZWRgKSBvciBmaXJzdCByZWdpc3RlcmVkIHZhcmlhbnQgdGhhdCB1c2VzIGEgcHJvcGVydHlcbiAgICAgICAgICogYXZhaWxhYmxlIGluIGBzcmNgLiAqL1xuICAgICAgICB0aGlzLmdldFNvdXJjZVZhcmlhbnQgPSBmdW5jdGlvbiAoc3JjKSB7XG4gICAgICAgICAgICByZXR1cm4gYm91bmRHZXRTb3VyY2VWYXJpYW50KHNyYyk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKiBGdW5jdGlvbiB0byBvdmVycmlkZSB0aGUgaW1wbGVtZW50YXRpb24gb2Yge0BsaW5rXG4gICAgICAgICAqIFVuaW9uI2dldFNvdXJjZVZhcmlhbnR8Z2V0U291cmNlVmFyaWFudH0uXG4gICAgICAgICAqXG4gICAgICAgICAqIFVzZSB0aGlzIGlmIHRoZSBkZXNpcmVkIHZhcmlhbnQgY2Fubm90IGJlIGlkZW50aWZpZWQgdXNpbmcgdGhlXG4gICAgICAgICAqIGFsZ29yaXRobSBvZiB7QGxpbmtcbiAgICAgICAgICogVW5pb24jZGVmYXVsdEdldFNvdXJjZVZhcmlhbnR8ZGVmYXVsdEdldFNvdXJjZVZhcmlhbnR9LlxuICAgICAgICAgKlxuICAgICAgICAgKiAqKk5PVEUqKiBUaGUgcHJvdmlkZWQgZnVuY3Rpb24gd2lsbCBiZSBpbnZva2VkIGJvdW5kIHRvIHRoaXNcbiAgICAgICAgICogVW5pb24gaW5zdGFuY2UsIHByb3ZpZGluZyBsb2NhbCBhY2Nlc3MgdG8ge0BsaW5rXG4gICAgICAgICAqIFVuaW9uI3JlZ2lzdHJ5fHJlZ2lzdHJ5fS5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZ3N2IC0gYSBmdW5jdGlvbiB0aGF0IGZvbGxvd3MgdGhlIEFQSSBvZlxuICAgICAgICAgKiB7QGxpbmsgVW5pb24jZGVmYXVsdEdldFNvdXJjZVZhcmlhbnR8ZGVmYXVsdEdldFNvdXJjZVZhcmlhbnR9LiAqL1xuICAgICAgICB0aGlzLmNvbmZpZ0dldFNvdXJjZVZhcmlhbnQgPSBmdW5jdGlvbiAoZ3N2KSB7XG4gICAgICAgICAgICBib3VuZEdldFNvdXJjZVZhcmlhbnQgPSBnc3YuYmluZCh0aGlzKTtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgLyoqIEBvdmVycmlkZSAqL1xuICAgIGdldFNwYW4oYiwgb2Zmc2V0ID0gMCkge1xuICAgICAgICBpZiAoMCA8PSB0aGlzLnNwYW4pIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnNwYW47XG4gICAgICAgIH1cbiAgICAgICAgLyogRGVmYXVsdCBsYXlvdXRzIGFsd2F5cyBoYXZlIG5vbi1uZWdhdGl2ZSBzcGFuLCBzbyB3ZSBkb24ndCBoYXZlXG4gICAgICAgICAqIG9uZSBhbmQgd2UgaGF2ZSB0byByZWNvZ25pemUgdGhlIHZhcmlhbnQgd2hpY2ggd2lsbCBpbiB0dXJuXG4gICAgICAgICAqIGRldGVybWluZSB0aGUgc3Bhbi4gKi9cbiAgICAgICAgY29uc3QgdmxvID0gdGhpcy5nZXRWYXJpYW50KGIsIG9mZnNldCk7XG4gICAgICAgIGlmICghdmxvKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3VuYWJsZSB0byBkZXRlcm1pbmUgc3BhbiBmb3IgdW5yZWNvZ25pemVkIHZhcmlhbnQnKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdmxvLmdldFNwYW4oYiwgb2Zmc2V0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTWV0aG9kIHRvIGluZmVyIGEgcmVnaXN0ZXJlZCBVbmlvbiB2YXJpYW50IGNvbXBhdGlibGUgd2l0aCBgc3JjYC5cbiAgICAgKlxuICAgICAqIFRoZSBmaXJzdCBzYXRpc2ZpZWQgcnVsZSBpbiB0aGUgZm9sbG93aW5nIHNlcXVlbmNlIGRlZmluZXMgdGhlXG4gICAgICogcmV0dXJuIHZhbHVlOlxuICAgICAqICogSWYgYHNyY2AgaGFzIHByb3BlcnRpZXMgbWF0Y2hpbmcgdGhlIFVuaW9uIGRpc2NyaW1pbmF0b3IgYW5kXG4gICAgICogICB0aGUgZGVmYXVsdCBsYXlvdXQsIGB1bmRlZmluZWRgIGlzIHJldHVybmVkIHJlZ2FyZGxlc3Mgb2YgdGhlXG4gICAgICogICB2YWx1ZSBvZiB0aGUgZGlzY3JpbWluYXRvciBwcm9wZXJ0eSAodGhpcyBlbnN1cmVzIHRoZSBkZWZhdWx0XG4gICAgICogICBsYXlvdXQgd2lsbCBiZSB1c2VkKTtcbiAgICAgKiAqIElmIGBzcmNgIGhhcyBhIHByb3BlcnR5IG1hdGNoaW5nIHRoZSBVbmlvbiBkaXNjcmltaW5hdG9yLCB0aGVcbiAgICAgKiAgIHZhbHVlIG9mIHRoZSBkaXNjcmltaW5hdG9yIGlkZW50aWZpZXMgYSByZWdpc3RlcmVkIHZhcmlhbnQsIGFuZFxuICAgICAqICAgZWl0aGVyIChhKSB0aGUgdmFyaWFudCBoYXMgbm8gbGF5b3V0LCBvciAoYikgYHNyY2AgaGFzIHRoZVxuICAgICAqICAgdmFyaWFudCdzIHByb3BlcnR5LCB0aGVuIHRoZSB2YXJpYW50IGlzIHJldHVybmVkIChiZWNhdXNlIHRoZVxuICAgICAqICAgc291cmNlIHNhdGlzZmllcyB0aGUgY29uc3RyYWludHMgb2YgdGhlIHZhcmlhbnQgaXQgaWRlbnRpZmllcyk7XG4gICAgICogKiBJZiBgc3JjYCBkb2VzIG5vdCBoYXZlIGEgcHJvcGVydHkgbWF0Y2hpbmcgdGhlIFVuaW9uXG4gICAgICogICBkaXNjcmltaW5hdG9yLCBidXQgZG9lcyBoYXZlIGEgcHJvcGVydHkgbWF0Y2hpbmcgYSByZWdpc3RlcmVkXG4gICAgICogICB2YXJpYW50LCB0aGVuIHRoZSB2YXJpYW50IGlzIHJldHVybmVkIChiZWNhdXNlIHRoZSBzb3VyY2VcbiAgICAgKiAgIG1hdGNoZXMgYSB2YXJpYW50IHdpdGhvdXQgYW4gZXhwbGljaXQgY29uZmxpY3QpO1xuICAgICAqICogQW4gZXJyb3IgaXMgdGhyb3duIChiZWNhdXNlIHdlIGVpdGhlciBjYW4ndCBpZGVudGlmeSBhIHZhcmlhbnQsXG4gICAgICogICBvciB3ZSB3ZXJlIGV4cGxpY2l0bHkgdG9sZCB0aGUgdmFyaWFudCBidXQgY2FuJ3Qgc2F0aXNmeSBpdCkuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gc3JjIC0gYW4gb2JqZWN0IHByZXN1bWVkIHRvIGJlIGNvbXBhdGlibGUgd2l0aFxuICAgICAqIHRoZSBjb250ZW50IG9mIHRoZSBVbmlvbi5cbiAgICAgKlxuICAgICAqIEByZXR1cm4geyh1bmRlZmluZWR8VmFyaWFudExheW91dCl9IC0gYXMgZGVzY3JpYmVkIGFib3ZlLlxuICAgICAqXG4gICAgICogQHRocm93cyB7RXJyb3J9IC0gaWYgYHNyY2AgY2Fubm90IGJlIGFzc29jaWF0ZWQgd2l0aCBhIGRlZmF1bHQgb3JcbiAgICAgKiByZWdpc3RlcmVkIHZhcmlhbnQuXG4gICAgICovXG4gICAgZGVmYXVsdEdldFNvdXJjZVZhcmlhbnQoc3JjKSB7XG4gICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc3JjLCB0aGlzLmRpc2NyaW1pbmF0b3IucHJvcGVydHkpKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5kZWZhdWx0TGF5b3V0ICYmIHRoaXMuZGVmYXVsdExheW91dC5wcm9wZXJ0eVxuICAgICAgICAgICAgICAgICYmIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzcmMsIHRoaXMuZGVmYXVsdExheW91dC5wcm9wZXJ0eSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgdmxvID0gdGhpcy5yZWdpc3RyeVtzcmNbdGhpcy5kaXNjcmltaW5hdG9yLnByb3BlcnR5XV07XG4gICAgICAgICAgICBpZiAodmxvXG4gICAgICAgICAgICAgICAgJiYgKCghdmxvLmxheW91dClcbiAgICAgICAgICAgICAgICAgICAgfHwgKHZsby5wcm9wZXJ0eSAmJiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc3JjLCB2bG8ucHJvcGVydHkpKSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdmxvO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZm9yIChjb25zdCB0YWcgaW4gdGhpcy5yZWdpc3RyeSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHZsbyA9IHRoaXMucmVnaXN0cnlbdGFnXTtcbiAgICAgICAgICAgICAgICBpZiAodmxvLnByb3BlcnR5ICYmIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzcmMsIHZsby5wcm9wZXJ0eSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZsbztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd1bmFibGUgdG8gaW5mZXIgc3JjIHZhcmlhbnQnKTtcbiAgICB9XG4gICAgLyoqIEltcGxlbWVudCB7QGxpbmsgTGF5b3V0I2RlY29kZXxkZWNvZGV9IGZvciB7QGxpbmsgVW5pb259LlxuICAgICAqXG4gICAgICogSWYgdGhlIHZhcmlhbnQgaXMge0BsaW5rIFVuaW9uI2FkZFZhcmlhbnR8cmVnaXN0ZXJlZH0gdGhlIHJldHVyblxuICAgICAqIHZhbHVlIGlzIGFuIGluc3RhbmNlIG9mIHRoYXQgdmFyaWFudCwgd2l0aCBubyBleHBsaWNpdFxuICAgICAqIGRpc2NyaW1pbmF0b3IuICBPdGhlcndpc2UgdGhlIHtAbGluayBVbmlvbiNkZWZhdWx0TGF5b3V0fGRlZmF1bHRcbiAgICAgKiBsYXlvdXR9IGlzIHVzZWQgdG8gZGVjb2RlIHRoZSBjb250ZW50LiAqL1xuICAgIGRlY29kZShiLCBvZmZzZXQgPSAwKSB7XG4gICAgICAgIGxldCBkZXN0O1xuICAgICAgICBjb25zdCBkbG8gPSB0aGlzLmRpc2NyaW1pbmF0b3I7XG4gICAgICAgIGNvbnN0IGRpc2NyID0gZGxvLmRlY29kZShiLCBvZmZzZXQpO1xuICAgICAgICBjb25zdCBjbG8gPSB0aGlzLnJlZ2lzdHJ5W2Rpc2NyXTtcbiAgICAgICAgaWYgKHVuZGVmaW5lZCA9PT0gY2xvKSB7XG4gICAgICAgICAgICBjb25zdCBkZWZhdWx0TGF5b3V0ID0gdGhpcy5kZWZhdWx0TGF5b3V0O1xuICAgICAgICAgICAgbGV0IGNvbnRlbnRPZmZzZXQgPSAwO1xuICAgICAgICAgICAgaWYgKHRoaXMudXNlc1ByZWZpeERpc2NyaW1pbmF0b3IpIHtcbiAgICAgICAgICAgICAgICBjb250ZW50T2Zmc2V0ID0gZGxvLmxheW91dC5zcGFuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZGVzdCA9IHRoaXMubWFrZURlc3RpbmF0aW9uT2JqZWN0KCk7XG4gICAgICAgICAgICBkZXN0W2Rsby5wcm9wZXJ0eV0gPSBkaXNjcjtcbiAgICAgICAgICAgIC8vIGRlZmF1bHRMYXlvdXQucHJvcGVydHkgY2FuIGJlIHVuZGVmaW5lZCwgYnV0IHRoaXMgaXMgYWxsb3dlZCBieSBidWZmZXItbGF5b3V0XG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLW5vbi1udWxsLWFzc2VydGlvblxuICAgICAgICAgICAgZGVzdFtkZWZhdWx0TGF5b3V0LnByb3BlcnR5XSA9IGRlZmF1bHRMYXlvdXQuZGVjb2RlKGIsIG9mZnNldCArIGNvbnRlbnRPZmZzZXQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZGVzdCA9IGNsby5kZWNvZGUoYiwgb2Zmc2V0KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZGVzdDtcbiAgICB9XG4gICAgLyoqIEltcGxlbWVudCB7QGxpbmsgTGF5b3V0I2VuY29kZXxlbmNvZGV9IGZvciB7QGxpbmsgVW5pb259LlxuICAgICAqXG4gICAgICogVGhpcyBBUEkgYXNzdW1lcyB0aGUgYHNyY2Agb2JqZWN0IGlzIGNvbnNpc3RlbnQgd2l0aCB0aGUgdW5pb24nc1xuICAgICAqIHtAbGluayBVbmlvbiNkZWZhdWx0TGF5b3V0fGRlZmF1bHQgbGF5b3V0fS4gIFRvIGVuY29kZSB2YXJpYW50c1xuICAgICAqIHVzZSB0aGUgYXBwcm9wcmlhdGUgdmFyaWFudC1zcGVjaWZpYyB7QGxpbmsgVmFyaWFudExheW91dCNlbmNvZGV9XG4gICAgICogbWV0aG9kLiAqL1xuICAgIGVuY29kZShzcmMsIGIsIG9mZnNldCA9IDApIHtcbiAgICAgICAgY29uc3QgdmxvID0gdGhpcy5nZXRTb3VyY2VWYXJpYW50KHNyYyk7XG4gICAgICAgIGlmICh1bmRlZmluZWQgPT09IHZsbykge1xuICAgICAgICAgICAgY29uc3QgZGxvID0gdGhpcy5kaXNjcmltaW5hdG9yO1xuICAgICAgICAgICAgLy8gdGhpcy5kZWZhdWx0TGF5b3V0IGlzIG5vdCB1bmRlZmluZWQgd2hlbiB2bG8gaXMgdW5kZWZpbmVkXG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLW5vbi1udWxsLWFzc2VydGlvblxuICAgICAgICAgICAgY29uc3QgY2xvID0gdGhpcy5kZWZhdWx0TGF5b3V0O1xuICAgICAgICAgICAgbGV0IGNvbnRlbnRPZmZzZXQgPSAwO1xuICAgICAgICAgICAgaWYgKHRoaXMudXNlc1ByZWZpeERpc2NyaW1pbmF0b3IpIHtcbiAgICAgICAgICAgICAgICBjb250ZW50T2Zmc2V0ID0gZGxvLmxheW91dC5zcGFuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZGxvLmVuY29kZShzcmNbZGxvLnByb3BlcnR5XSwgYiwgb2Zmc2V0KTtcbiAgICAgICAgICAgIC8vIGNsby5wcm9wZXJ0eSBpcyBub3QgdW5kZWZpbmVkIHdoZW4gdmxvIGlzIHVuZGVmaW5lZFxuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1ub24tbnVsbC1hc3NlcnRpb25cbiAgICAgICAgICAgIHJldHVybiBjb250ZW50T2Zmc2V0ICsgY2xvLmVuY29kZShzcmNbY2xvLnByb3BlcnR5XSwgYiwgb2Zmc2V0ICsgY29udGVudE9mZnNldCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHZsby5lbmNvZGUoc3JjLCBiLCBvZmZzZXQpO1xuICAgIH1cbiAgICAvKiogUmVnaXN0ZXIgYSBuZXcgdmFyaWFudCBzdHJ1Y3R1cmUgd2l0aGluIGEgdW5pb24uICBUaGUgbmV3bHlcbiAgICAgKiBjcmVhdGVkIHZhcmlhbnQgaXMgcmV0dXJuZWQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gdmFyaWFudCAtIGluaXRpYWxpemVyIGZvciB7QGxpbmtcbiAgICAgKiBWYXJpYW50TGF5b3V0I3ZhcmlhbnR8dmFyaWFudH0uXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0xheW91dH0gbGF5b3V0IC0gaW5pdGlhbGl6ZXIgZm9yIHtAbGlua1xuICAgICAqIFZhcmlhbnRMYXlvdXQjbGF5b3V0fGxheW91dH0uXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gcHJvcGVydHkgLSBpbml0aWFsaXplciBmb3Ige0BsaW5rXG4gICAgICogTGF5b3V0I3Byb3BlcnR5fHByb3BlcnR5fS5cbiAgICAgKlxuICAgICAqIEByZXR1cm4ge1ZhcmlhbnRMYXlvdXR9ICovXG4gICAgYWRkVmFyaWFudCh2YXJpYW50LCBsYXlvdXQsIHByb3BlcnR5KSB7XG4gICAgICAgIGNvbnN0IHJ2ID0gbmV3IFZhcmlhbnRMYXlvdXQodGhpcywgdmFyaWFudCwgbGF5b3V0LCBwcm9wZXJ0eSk7XG4gICAgICAgIHRoaXMucmVnaXN0cnlbdmFyaWFudF0gPSBydjtcbiAgICAgICAgcmV0dXJuIHJ2O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIGxheW91dCBhc3NvY2lhdGVkIHdpdGggYSByZWdpc3RlcmVkIHZhcmlhbnQuXG4gICAgICpcbiAgICAgKiBJZiBgdmJgIGRvZXMgbm90IHByb2R1Y2UgYSByZWdpc3RlcmVkIHZhcmlhbnQgdGhlIGZ1bmN0aW9uIHJldHVybnNcbiAgICAgKiBgdW5kZWZpbmVkYC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7KE51bWJlcnxVaW50OEFycmF5KX0gdmIgLSBlaXRoZXIgdGhlIHZhcmlhbnQgbnVtYmVyLCBvciBhXG4gICAgICogYnVmZmVyIGZyb20gd2hpY2ggdGhlIGRpc2NyaW1pbmF0b3IgaXMgdG8gYmUgcmVhZC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBvZmZzZXQgLSBvZmZzZXQgaW50byBgdmJgIGZvciB0aGUgc3RhcnQgb2YgdGhlXG4gICAgICogdW5pb24uICBVc2VkIG9ubHkgd2hlbiBgdmJgIGlzIGFuIGluc3RhbmNlIG9mIHtVaW50OEFycmF5fS5cbiAgICAgKlxuICAgICAqIEByZXR1cm4geyh7VmFyaWFudExheW91dH18dW5kZWZpbmVkKX1cbiAgICAgKi9cbiAgICBnZXRWYXJpYW50KHZiLCBvZmZzZXQgPSAwKSB7XG4gICAgICAgIGxldCB2YXJpYW50O1xuICAgICAgICBpZiAodmIgaW5zdGFuY2VvZiBVaW50OEFycmF5KSB7XG4gICAgICAgICAgICB2YXJpYW50ID0gdGhpcy5kaXNjcmltaW5hdG9yLmRlY29kZSh2Yiwgb2Zmc2V0KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHZhcmlhbnQgPSB2YjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5yZWdpc3RyeVt2YXJpYW50XTtcbiAgICB9XG59XG5leHBvcnRzLlVuaW9uID0gVW5pb247XG4vKipcbiAqIFJlcHJlc2VudCBhIHNwZWNpZmljIHZhcmlhbnQgd2l0aGluIGEgY29udGFpbmluZyB1bmlvbi5cbiAqXG4gKiAqKk5PVEUqKiBUaGUge0BsaW5rIExheW91dCNzcGFufHNwYW59IG9mIHRoZSB2YXJpYW50IG1heSBpbmNsdWRlXG4gKiB0aGUgc3BhbiBvZiB0aGUge0BsaW5rIFVuaW9uI2Rpc2NyaW1pbmF0b3J8ZGlzY3JpbWluYXRvcn0gdXNlZCB0b1xuICogaWRlbnRpZnkgaXQsIGJ1dCB2YWx1ZXMgcmVhZCBhbmQgd3JpdHRlbiB1c2luZyB0aGUgdmFyaWFudCBzdHJpY3RseVxuICogY29uZm9ybSB0byB0aGUgY29udGVudCBvZiB7QGxpbmsgVmFyaWFudExheW91dCNsYXlvdXR8bGF5b3V0fS5cbiAqXG4gKiAqKk5PVEUqKiBVc2VyIGNvZGUgc2hvdWxkIG5vdCBpbnZva2UgdGhpcyBjb25zdHJ1Y3RvciBkaXJlY3RseS4gIFVzZVxuICogdGhlIHVuaW9uIHtAbGluayBVbmlvbiNhZGRWYXJpYW50fGFkZFZhcmlhbnR9IGhlbHBlciBtZXRob2QuXG4gKlxuICogQHBhcmFtIHtVbmlvbn0gdW5pb24gLSBpbml0aWFsaXplciBmb3Ige0BsaW5rXG4gKiBWYXJpYW50TGF5b3V0I3VuaW9ufHVuaW9ufS5cbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gdmFyaWFudCAtIGluaXRpYWxpemVyIGZvciB7QGxpbmtcbiAqIFZhcmlhbnRMYXlvdXQjdmFyaWFudHx2YXJpYW50fS5cbiAqXG4gKiBAcGFyYW0ge0xheW91dH0gW2xheW91dF0gLSBpbml0aWFsaXplciBmb3Ige0BsaW5rXG4gKiBWYXJpYW50TGF5b3V0I2xheW91dHxsYXlvdXR9LiAgSWYgYWJzZW50IHRoZSB2YXJpYW50IGNhcnJpZXMgbm9cbiAqIGRhdGEuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IFtwcm9wZXJ0eV0gLSBpbml0aWFsaXplciBmb3Ige0BsaW5rXG4gKiBMYXlvdXQjcHJvcGVydHl8cHJvcGVydHl9LiAgVW5saWtlIG1hbnkgb3RoZXIgbGF5b3V0cywgdmFyaWFudFxuICogbGF5b3V0cyBub3JtYWxseSBpbmNsdWRlIGEgcHJvcGVydHkgbmFtZSBzbyB0aGV5IGNhbiBiZSBpZGVudGlmaWVkXG4gKiB3aXRoaW4gdGhlaXIgY29udGFpbmluZyB7QGxpbmsgVW5pb259LiAgVGhlIHByb3BlcnR5IGlkZW50aWZpZXIgbWF5XG4gKiBiZSBhYnNlbnQgb25seSBpZiBgbGF5b3V0YCBpcyBpcyBhYnNlbnQuXG4gKlxuICogQGF1Z21lbnRzIHtMYXlvdXR9XG4gKi9cbmNsYXNzIFZhcmlhbnRMYXlvdXQgZXh0ZW5kcyBMYXlvdXQge1xuICAgIGNvbnN0cnVjdG9yKHVuaW9uLCB2YXJpYW50LCBsYXlvdXQsIHByb3BlcnR5KSB7XG4gICAgICAgIGlmICghKHVuaW9uIGluc3RhbmNlb2YgVW5pb24pKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCd1bmlvbiBtdXN0IGJlIGEgVW5pb24nKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoKCFOdW1iZXIuaXNJbnRlZ2VyKHZhcmlhbnQpKSB8fCAoMCA+IHZhcmlhbnQpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCd2YXJpYW50IG11c3QgYmUgYSAobm9uLW5lZ2F0aXZlKSBpbnRlZ2VyJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCgnc3RyaW5nJyA9PT0gdHlwZW9mIGxheW91dClcbiAgICAgICAgICAgICYmICh1bmRlZmluZWQgPT09IHByb3BlcnR5KSkge1xuICAgICAgICAgICAgcHJvcGVydHkgPSBsYXlvdXQ7XG4gICAgICAgICAgICBsYXlvdXQgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGlmIChsYXlvdXQpIHtcbiAgICAgICAgICAgIGlmICghKGxheW91dCBpbnN0YW5jZW9mIExheW91dCkpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdsYXlvdXQgbXVzdCBiZSBhIExheW91dCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKChudWxsICE9PSB1bmlvbi5kZWZhdWx0TGF5b3V0KVxuICAgICAgICAgICAgICAgICYmICgwIDw9IGxheW91dC5zcGFuKVxuICAgICAgICAgICAgICAgICYmIChsYXlvdXQuc3BhbiA+IHVuaW9uLmRlZmF1bHRMYXlvdXQuc3BhbikpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3ZhcmlhbnQgc3BhbiBleGNlZWRzIHNwYW4gb2YgY29udGFpbmluZyB1bmlvbicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCdzdHJpbmcnICE9PSB0eXBlb2YgcHJvcGVydHkpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCd2YXJpYW50IG11c3QgaGF2ZSBhIFN0cmluZyBwcm9wZXJ0eScpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGxldCBzcGFuID0gdW5pb24uc3BhbjtcbiAgICAgICAgaWYgKDAgPiB1bmlvbi5zcGFuKSB7XG4gICAgICAgICAgICBzcGFuID0gbGF5b3V0ID8gbGF5b3V0LnNwYW4gOiAwO1xuICAgICAgICAgICAgaWYgKCgwIDw9IHNwYW4pICYmIHVuaW9uLnVzZXNQcmVmaXhEaXNjcmltaW5hdG9yKSB7XG4gICAgICAgICAgICAgICAgc3BhbiArPSB1bmlvbi5kaXNjcmltaW5hdG9yLmxheW91dC5zcGFuO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHN1cGVyKHNwYW4sIHByb3BlcnR5KTtcbiAgICAgICAgLyoqIFRoZSB7QGxpbmsgVW5pb259IHRvIHdoaWNoIHRoaXMgdmFyaWFudCBiZWxvbmdzLiAqL1xuICAgICAgICB0aGlzLnVuaW9uID0gdW5pb247XG4gICAgICAgIC8qKiBUaGUgdW5zaWduZWQgaW50ZWdyYWwgdmFsdWUgaWRlbnRpZnlpbmcgdGhpcyB2YXJpYW50IHdpdGhpblxuICAgICAgICAgKiB0aGUge0BsaW5rIFVuaW9uI2Rpc2NyaW1pbmF0b3J8ZGlzY3JpbWluYXRvcn0gb2YgdGhlIGNvbnRhaW5pbmdcbiAgICAgICAgICogdW5pb24uICovXG4gICAgICAgIHRoaXMudmFyaWFudCA9IHZhcmlhbnQ7XG4gICAgICAgIC8qKiBUaGUge0BsaW5rIExheW91dH0gdG8gYmUgdXNlZCB3aGVuIHJlYWRpbmcvd3JpdGluZyB0aGVcbiAgICAgICAgICogbm9uLWRpc2NyaW1pbmF0b3IgcGFydCBvZiB0aGUge0BsaW5rXG4gICAgICAgICAqIFZhcmlhbnRMYXlvdXQjdW5pb258dW5pb259LiAgSWYgYG51bGxgIHRoZSB2YXJpYW50IGNhcnJpZXMgbm9cbiAgICAgICAgICogZGF0YS4gKi9cbiAgICAgICAgdGhpcy5sYXlvdXQgPSBsYXlvdXQgfHwgbnVsbDtcbiAgICB9XG4gICAgLyoqIEBvdmVycmlkZSAqL1xuICAgIGdldFNwYW4oYiwgb2Zmc2V0ID0gMCkge1xuICAgICAgICBpZiAoMCA8PSB0aGlzLnNwYW4pIHtcbiAgICAgICAgICAgIC8qIFdpbGwgYmUgZXF1YWwgdG8gdGhlIGNvbnRhaW5pbmcgdW5pb24gc3BhbiBpZiB0aGF0IGlzIG5vdFxuICAgICAgICAgICAgICogdmFyaWFibGUuICovXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zcGFuO1xuICAgICAgICB9XG4gICAgICAgIGxldCBjb250ZW50T2Zmc2V0ID0gMDtcbiAgICAgICAgaWYgKHRoaXMudW5pb24udXNlc1ByZWZpeERpc2NyaW1pbmF0b3IpIHtcbiAgICAgICAgICAgIGNvbnRlbnRPZmZzZXQgPSB0aGlzLnVuaW9uLmRpc2NyaW1pbmF0b3IubGF5b3V0LnNwYW47XG4gICAgICAgIH1cbiAgICAgICAgLyogU3BhbiBpcyBkZWZpbmVkIHNvbGVseSBieSB0aGUgdmFyaWFudCAoYW5kIHByZWZpeCBkaXNjcmltaW5hdG9yKSAqL1xuICAgICAgICBsZXQgc3BhbiA9IDA7XG4gICAgICAgIGlmICh0aGlzLmxheW91dCkge1xuICAgICAgICAgICAgc3BhbiA9IHRoaXMubGF5b3V0LmdldFNwYW4oYiwgb2Zmc2V0ICsgY29udGVudE9mZnNldCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNvbnRlbnRPZmZzZXQgKyBzcGFuO1xuICAgIH1cbiAgICAvKiogQG92ZXJyaWRlICovXG4gICAgZGVjb2RlKGIsIG9mZnNldCA9IDApIHtcbiAgICAgICAgY29uc3QgZGVzdCA9IHRoaXMubWFrZURlc3RpbmF0aW9uT2JqZWN0KCk7XG4gICAgICAgIGlmICh0aGlzICE9PSB0aGlzLnVuaW9uLmdldFZhcmlhbnQoYiwgb2Zmc2V0KSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd2YXJpYW50IG1pc21hdGNoJyk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGNvbnRlbnRPZmZzZXQgPSAwO1xuICAgICAgICBpZiAodGhpcy51bmlvbi51c2VzUHJlZml4RGlzY3JpbWluYXRvcikge1xuICAgICAgICAgICAgY29udGVudE9mZnNldCA9IHRoaXMudW5pb24uZGlzY3JpbWluYXRvci5sYXlvdXQuc3BhbjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5sYXlvdXQpIHtcbiAgICAgICAgICAgIGRlc3RbdGhpcy5wcm9wZXJ0eV0gPSB0aGlzLmxheW91dC5kZWNvZGUoYiwgb2Zmc2V0ICsgY29udGVudE9mZnNldCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5wcm9wZXJ0eSkge1xuICAgICAgICAgICAgZGVzdFt0aGlzLnByb3BlcnR5XSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy51bmlvbi51c2VzUHJlZml4RGlzY3JpbWluYXRvcikge1xuICAgICAgICAgICAgZGVzdFt0aGlzLnVuaW9uLmRpc2NyaW1pbmF0b3IucHJvcGVydHldID0gdGhpcy52YXJpYW50O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkZXN0O1xuICAgIH1cbiAgICAvKiogQG92ZXJyaWRlICovXG4gICAgZW5jb2RlKHNyYywgYiwgb2Zmc2V0ID0gMCkge1xuICAgICAgICBsZXQgY29udGVudE9mZnNldCA9IDA7XG4gICAgICAgIGlmICh0aGlzLnVuaW9uLnVzZXNQcmVmaXhEaXNjcmltaW5hdG9yKSB7XG4gICAgICAgICAgICBjb250ZW50T2Zmc2V0ID0gdGhpcy51bmlvbi5kaXNjcmltaW5hdG9yLmxheW91dC5zcGFuO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmxheW91dFxuICAgICAgICAgICAgJiYgKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc3JjLCB0aGlzLnByb3BlcnR5KSkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ3ZhcmlhbnQgbGFja3MgcHJvcGVydHkgJyArIHRoaXMucHJvcGVydHkpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudW5pb24uZGlzY3JpbWluYXRvci5lbmNvZGUodGhpcy52YXJpYW50LCBiLCBvZmZzZXQpO1xuICAgICAgICBsZXQgc3BhbiA9IGNvbnRlbnRPZmZzZXQ7XG4gICAgICAgIGlmICh0aGlzLmxheW91dCkge1xuICAgICAgICAgICAgdGhpcy5sYXlvdXQuZW5jb2RlKHNyY1t0aGlzLnByb3BlcnR5XSwgYiwgb2Zmc2V0ICsgY29udGVudE9mZnNldCk7XG4gICAgICAgICAgICBzcGFuICs9IHRoaXMubGF5b3V0LmdldFNwYW4oYiwgb2Zmc2V0ICsgY29udGVudE9mZnNldCk7XG4gICAgICAgICAgICBpZiAoKDAgPD0gdGhpcy51bmlvbi5zcGFuKVxuICAgICAgICAgICAgICAgICYmIChzcGFuID4gdGhpcy51bmlvbi5zcGFuKSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignZW5jb2RlZCB2YXJpYW50IG92ZXJydW5zIGNvbnRhaW5pbmcgdW5pb24nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3BhbjtcbiAgICB9XG4gICAgLyoqIERlbGVnYXRlIHtAbGluayBMYXlvdXQjZnJvbUFycmF5fGZyb21BcnJheX0gdG8ge0BsaW5rXG4gICAgICogVmFyaWFudExheW91dCNsYXlvdXR8bGF5b3V0fS4gKi9cbiAgICBmcm9tQXJyYXkodmFsdWVzKSB7XG4gICAgICAgIGlmICh0aGlzLmxheW91dCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubGF5b3V0LmZyb21BcnJheSh2YWx1ZXMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxufVxuZXhwb3J0cy5WYXJpYW50TGF5b3V0ID0gVmFyaWFudExheW91dDtcbi8qKiBKYXZhU2NyaXB0IGNob3NlIHRvIGRlZmluZSBiaXR3aXNlIG9wZXJhdGlvbnMgYXMgb3BlcmF0aW5nIG9uXG4gKiBzaWduZWQgMzItYml0IHZhbHVlcyBpbiAyJ3MgY29tcGxlbWVudCBmb3JtLCBtZWFuaW5nIGFueSBpbnRlZ2VyXG4gKiB3aXRoIGJpdCAzMSBzZXQgaXMgZ29pbmcgdG8gbG9vayBuZWdhdGl2ZS4gIEZvciByaWdodCBzaGlmdHMgdGhhdCdzXG4gKiBub3QgYSBwcm9ibGVtLCBiZWNhdXNlIGA+Pj5gIGlzIGEgbG9naWNhbCBzaGlmdCwgYnV0IGZvciBldmVyeVxuICogb3RoZXIgYml0d2lzZSBvcGVyYXRvciB3ZSBoYXZlIHRvIGNvbXBlbnNhdGUgZm9yIHBvc3NpYmxlIG5lZ2F0aXZlXG4gKiByZXN1bHRzLiAqL1xuZnVuY3Rpb24gZml4Qml0d2lzZVJlc3VsdCh2KSB7XG4gICAgaWYgKDAgPiB2KSB7XG4gICAgICAgIHYgKz0gMHgxMDAwMDAwMDA7XG4gICAgfVxuICAgIHJldHVybiB2O1xufVxuLyoqXG4gKiBDb250YWluIGEgc2VxdWVuY2Ugb2YgYml0IGZpZWxkcyBhcyBhbiB1bnNpZ25lZCBpbnRlZ2VyLlxuICpcbiAqICpGYWN0b3J5Kjoge0BsaW5rIG1vZHVsZTpMYXlvdXQuYml0c3xiaXRzfVxuICpcbiAqIFRoaXMgaXMgYSBjb250YWluZXIgZWxlbWVudDsgd2l0aGluIGl0IHRoZXJlIGFyZSB7QGxpbmsgQml0RmllbGR9XG4gKiBpbnN0YW5jZXMgdGhhdCBwcm92aWRlIHRoZSBleHRyYWN0ZWQgcHJvcGVydGllcy4gIFRoZSBjb250YWluZXJcbiAqIHNpbXBseSBkZWZpbmVzIHRoZSBhZ2dyZWdhdGUgcmVwcmVzZW50YXRpb24gYW5kIGl0cyBiaXQgb3JkZXJpbmcuXG4gKiBUaGUgcmVwcmVzZW50YXRpb24gaXMgYW4gb2JqZWN0IGNvbnRhaW5pbmcgcHJvcGVydGllcyB3aXRoIG51bWVyaWNcbiAqIG9yIHtAbGluayBCb29sZWFufSB2YWx1ZXMuXG4gKlxuICoge0BsaW5rIEJpdEZpZWxkfXMgYXJlIGFkZGVkIHdpdGggdGhlIHtAbGlua1xuICogQml0U3RydWN0dXJlI2FkZEZpZWxkfGFkZEZpZWxkfSBhbmQge0BsaW5rXG4gKiBCaXRTdHJ1Y3R1cmUjYWRkQm9vbGVhbnxhZGRCb29sZWFufSBtZXRob2RzLlxuXG4gKiBAcGFyYW0ge0xheW91dH0gd29yZCAtIGluaXRpYWxpemVyIGZvciB7QGxpbmtcbiAqIEJpdFN0cnVjdHVyZSN3b3JkfHdvcmR9LiAgVGhlIHBhcmFtZXRlciBtdXN0IGJlIGFuIGluc3RhbmNlIG9mXG4gKiB7QGxpbmsgVUludH0gKG9yIHtAbGluayBVSW50QkV9KSB0aGF0IGlzIG5vIG1vcmUgdGhhbiA0IGJ5dGVzIHdpZGUuXG4gKlxuICogQHBhcmFtIHtib29sfSBbbXNiXSAtIGB0cnVlYCBpZiB0aGUgYml0IG51bWJlcmluZyBzdGFydHMgYXQgdGhlXG4gKiBtb3N0IHNpZ25pZmljYW50IGJpdCBvZiB0aGUgY29udGFpbmluZyB3b3JkOyBgZmFsc2VgIChkZWZhdWx0KSBpZlxuICogaXQgc3RhcnRzIGF0IHRoZSBsZWFzdCBzaWduaWZpY2FudCBiaXQgb2YgdGhlIGNvbnRhaW5pbmcgd29yZC4gIElmXG4gKiB0aGUgcGFyYW1ldGVyIGF0IHRoaXMgcG9zaXRpb24gaXMgYSBzdHJpbmcgYW5kIGBwcm9wZXJ0eWAgaXNcbiAqIGB1bmRlZmluZWRgIHRoZSB2YWx1ZSBvZiB0aGlzIGFyZ3VtZW50IHdpbGwgaW5zdGVhZCBiZSB1c2VkIGFzIHRoZVxuICogdmFsdWUgb2YgYHByb3BlcnR5YC5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gW3Byb3BlcnR5XSAtIGluaXRpYWxpemVyIGZvciB7QGxpbmtcbiAqIExheW91dCNwcm9wZXJ0eXxwcm9wZXJ0eX0uXG4gKlxuICogQGF1Z21lbnRzIHtMYXlvdXR9XG4gKi9cbmNsYXNzIEJpdFN0cnVjdHVyZSBleHRlbmRzIExheW91dCB7XG4gICAgY29uc3RydWN0b3Iod29yZCwgbXNiLCBwcm9wZXJ0eSkge1xuICAgICAgICBpZiAoISgod29yZCBpbnN0YW5jZW9mIFVJbnQpXG4gICAgICAgICAgICB8fCAod29yZCBpbnN0YW5jZW9mIFVJbnRCRSkpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCd3b3JkIG11c3QgYmUgYSBVSW50IG9yIFVJbnRCRSBsYXlvdXQnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoKCdzdHJpbmcnID09PSB0eXBlb2YgbXNiKVxuICAgICAgICAgICAgJiYgKHVuZGVmaW5lZCA9PT0gcHJvcGVydHkpKSB7XG4gICAgICAgICAgICBwcm9wZXJ0eSA9IG1zYjtcbiAgICAgICAgICAgIG1zYiA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmICg0IDwgd29yZC5zcGFuKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignd29yZCBjYW5ub3QgZXhjZWVkIDMyIGJpdHMnKTtcbiAgICAgICAgfVxuICAgICAgICBzdXBlcih3b3JkLnNwYW4sIHByb3BlcnR5KTtcbiAgICAgICAgLyoqIFRoZSBsYXlvdXQgdXNlZCBmb3IgdGhlIHBhY2tlZCB2YWx1ZS4gIHtAbGluayBCaXRGaWVsZH1cbiAgICAgICAgICogaW5zdGFuY2VzIGFyZSBwYWNrZWQgc2VxdWVudGlhbGx5IGRlcGVuZGluZyBvbiB7QGxpbmtcbiAgICAgICAgICogQml0U3RydWN0dXJlI21zYnxtc2J9LiAqL1xuICAgICAgICB0aGlzLndvcmQgPSB3b3JkO1xuICAgICAgICAvKiogV2hldGhlciB0aGUgYml0IHNlcXVlbmNlcyBhcmUgcGFja2VkIHN0YXJ0aW5nIGF0IHRoZSBtb3N0XG4gICAgICAgICAqIHNpZ25pZmljYW50IGJpdCBncm93aW5nIGRvd24gKGB0cnVlYCksIG9yIHRoZSBsZWFzdCBzaWduaWZpY2FudFxuICAgICAgICAgKiBiaXQgZ3Jvd2luZyB1cCAoYGZhbHNlYCkuXG4gICAgICAgICAqXG4gICAgICAgICAqICoqTk9URSoqIFJlZ2FyZGxlc3Mgb2YgdGhpcyB2YWx1ZSwgdGhlIGxlYXN0IHNpZ25pZmljYW50IGJpdCBvZlxuICAgICAgICAgKiBhbnkge0BsaW5rIEJpdEZpZWxkfSB2YWx1ZSBpcyB0aGUgbGVhc3Qgc2lnbmlmaWNhbnQgYml0IG9mIHRoZVxuICAgICAgICAgKiBjb3JyZXNwb25kaW5nIHNlY3Rpb24gb2YgdGhlIHBhY2tlZCB2YWx1ZS4gKi9cbiAgICAgICAgdGhpcy5tc2IgPSAhIW1zYjtcbiAgICAgICAgLyoqIFRoZSBzZXF1ZW5jZSBvZiB7QGxpbmsgQml0RmllbGR9IGxheW91dHMgdGhhdCBjb21wcmlzZSB0aGVcbiAgICAgICAgICogcGFja2VkIHN0cnVjdHVyZS5cbiAgICAgICAgICpcbiAgICAgICAgICogKipOT1RFKiogVGhlIGFycmF5IHJlbWFpbnMgbXV0YWJsZSB0byBhbGxvdyBmaWVsZHMgdG8gYmUge0BsaW5rXG4gICAgICAgICAqIEJpdFN0cnVjdHVyZSNhZGRGaWVsZHxhZGRlZH0gYWZ0ZXIgY29uc3RydWN0aW9uLiAgVXNlcnMgc2hvdWxkXG4gICAgICAgICAqIG5vdCBtYW5pcHVsYXRlIHRoZSBjb250ZW50IG9mIHRoaXMgcHJvcGVydHkuKi9cbiAgICAgICAgdGhpcy5maWVsZHMgPSBbXTtcbiAgICAgICAgLyogU3RvcmFnZSBmb3IgdGhlIHZhbHVlLiAgQ2FwdHVyZSBhIHZhcmlhYmxlIGluc3RlYWQgb2YgdXNpbmcgYW5cbiAgICAgICAgICogaW5zdGFuY2UgcHJvcGVydHkgYmVjYXVzZSB3ZSBkb24ndCB3YW50IGFueXRoaW5nIHRvIGNoYW5nZSB0aGVcbiAgICAgICAgICogdmFsdWUgd2l0aG91dCBnb2luZyB0aHJvdWdoIHRoZSBtdXRhdG9yLiAqL1xuICAgICAgICBsZXQgdmFsdWUgPSAwO1xuICAgICAgICB0aGlzLl9wYWNrZWRTZXRWYWx1ZSA9IGZ1bmN0aW9uICh2KSB7XG4gICAgICAgICAgICB2YWx1ZSA9IGZpeEJpdHdpc2VSZXN1bHQodik7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5fcGFja2VkR2V0VmFsdWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIH07XG4gICAgfVxuICAgIC8qKiBAb3ZlcnJpZGUgKi9cbiAgICBkZWNvZGUoYiwgb2Zmc2V0ID0gMCkge1xuICAgICAgICBjb25zdCBkZXN0ID0gdGhpcy5tYWtlRGVzdGluYXRpb25PYmplY3QoKTtcbiAgICAgICAgY29uc3QgdmFsdWUgPSB0aGlzLndvcmQuZGVjb2RlKGIsIG9mZnNldCk7XG4gICAgICAgIHRoaXMuX3BhY2tlZFNldFZhbHVlKHZhbHVlKTtcbiAgICAgICAgZm9yIChjb25zdCBmZCBvZiB0aGlzLmZpZWxkcykge1xuICAgICAgICAgICAgaWYgKHVuZGVmaW5lZCAhPT0gZmQucHJvcGVydHkpIHtcbiAgICAgICAgICAgICAgICBkZXN0W2ZkLnByb3BlcnR5XSA9IGZkLmRlY29kZShiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZGVzdDtcbiAgICB9XG4gICAgLyoqIEltcGxlbWVudCB7QGxpbmsgTGF5b3V0I2VuY29kZXxlbmNvZGV9IGZvciB7QGxpbmsgQml0U3RydWN0dXJlfS5cbiAgICAgKlxuICAgICAqIElmIGBzcmNgIGlzIG1pc3NpbmcgYSBwcm9wZXJ0eSBmb3IgYSBtZW1iZXIgd2l0aCBhIGRlZmluZWQge0BsaW5rXG4gICAgICogTGF5b3V0I3Byb3BlcnR5fHByb3BlcnR5fSB0aGUgY29ycmVzcG9uZGluZyByZWdpb24gb2YgdGhlIHBhY2tlZFxuICAgICAqIHZhbHVlIGlzIGxlZnQgdW5tb2RpZmllZC4gIFVudXNlZCBiaXRzIGFyZSBhbHNvIGxlZnQgdW5tb2RpZmllZC4gKi9cbiAgICBlbmNvZGUoc3JjLCBiLCBvZmZzZXQgPSAwKSB7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gdGhpcy53b3JkLmRlY29kZShiLCBvZmZzZXQpO1xuICAgICAgICB0aGlzLl9wYWNrZWRTZXRWYWx1ZSh2YWx1ZSk7XG4gICAgICAgIGZvciAoY29uc3QgZmQgb2YgdGhpcy5maWVsZHMpIHtcbiAgICAgICAgICAgIGlmICh1bmRlZmluZWQgIT09IGZkLnByb3BlcnR5KSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZnYgPSBzcmNbZmQucHJvcGVydHldO1xuICAgICAgICAgICAgICAgIGlmICh1bmRlZmluZWQgIT09IGZ2KSB7XG4gICAgICAgICAgICAgICAgICAgIGZkLmVuY29kZShmdik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLndvcmQuZW5jb2RlKHRoaXMuX3BhY2tlZEdldFZhbHVlKCksIGIsIG9mZnNldCk7XG4gICAgfVxuICAgIC8qKiBSZWdpc3RlciBhIG5ldyBiaXRmaWVsZCB3aXRoIGEgY29udGFpbmluZyBiaXQgc3RydWN0dXJlLiAgVGhlXG4gICAgICogcmVzdWx0aW5nIGJpdGZpZWxkIGlzIHJldHVybmVkLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGJpdHMgLSBpbml0aWFsaXplciBmb3Ige0BsaW5rIEJpdEZpZWxkI2JpdHN8Yml0c30uXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcHJvcGVydHkgLSBpbml0aWFsaXplciBmb3Ige0BsaW5rXG4gICAgICogTGF5b3V0I3Byb3BlcnR5fHByb3BlcnR5fS5cbiAgICAgKlxuICAgICAqIEByZXR1cm4ge0JpdEZpZWxkfSAqL1xuICAgIGFkZEZpZWxkKGJpdHMsIHByb3BlcnR5KSB7XG4gICAgICAgIGNvbnN0IGJmID0gbmV3IEJpdEZpZWxkKHRoaXMsIGJpdHMsIHByb3BlcnR5KTtcbiAgICAgICAgdGhpcy5maWVsZHMucHVzaChiZik7XG4gICAgICAgIHJldHVybiBiZjtcbiAgICB9XG4gICAgLyoqIEFzIHdpdGgge0BsaW5rIEJpdFN0cnVjdHVyZSNhZGRGaWVsZHxhZGRGaWVsZH0gZm9yIHNpbmdsZS1iaXRcbiAgICAgKiBmaWVsZHMgd2l0aCBgYm9vbGVhbmAgdmFsdWUgcmVwcmVzZW50YXRpb24uXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcHJvcGVydHkgLSBpbml0aWFsaXplciBmb3Ige0BsaW5rXG4gICAgICogTGF5b3V0I3Byb3BlcnR5fHByb3BlcnR5fS5cbiAgICAgKlxuICAgICAqIEByZXR1cm4ge0Jvb2xlYW59ICovXG4gICAgLy8gYEJvb2xlYW5gIGNvbmZsaWN0cyB3aXRoIHRoZSBuYXRpdmUgcHJpbWl0aXZlIHR5cGVcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L2Jhbi10eXBlc1xuICAgIGFkZEJvb2xlYW4ocHJvcGVydHkpIHtcbiAgICAgICAgLy8gVGhpcyBpcyBteSBCb29sZWFuLCBub3QgdGhlIEphdmFzY3JpcHQgb25lLlxuICAgICAgICBjb25zdCBiZiA9IG5ldyBCb29sZWFuKHRoaXMsIHByb3BlcnR5KTtcbiAgICAgICAgdGhpcy5maWVsZHMucHVzaChiZik7XG4gICAgICAgIHJldHVybiBiZjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IGFjY2VzcyB0byB0aGUgYml0IGZpZWxkIGZvciBhIGdpdmVuIHByb3BlcnR5LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHByb3BlcnR5IC0gdGhlIGJpdCBmaWVsZCBvZiBpbnRlcmVzdC5cbiAgICAgKlxuICAgICAqIEByZXR1cm4ge0JpdEZpZWxkfSAtIHRoZSBmaWVsZCBhc3NvY2lhdGVkIHdpdGggYHByb3BlcnR5YCwgb3JcbiAgICAgKiB1bmRlZmluZWQgaWYgdGhlcmUgaXMgbm8gc3VjaCBwcm9wZXJ0eS5cbiAgICAgKi9cbiAgICBmaWVsZEZvcihwcm9wZXJ0eSkge1xuICAgICAgICBpZiAoJ3N0cmluZycgIT09IHR5cGVvZiBwcm9wZXJ0eSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcigncHJvcGVydHkgbXVzdCBiZSBzdHJpbmcnKTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGNvbnN0IGZkIG9mIHRoaXMuZmllbGRzKSB7XG4gICAgICAgICAgICBpZiAoZmQucHJvcGVydHkgPT09IHByb3BlcnR5KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZkO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxufVxuZXhwb3J0cy5CaXRTdHJ1Y3R1cmUgPSBCaXRTdHJ1Y3R1cmU7XG4vKipcbiAqIFJlcHJlc2VudCBhIHNlcXVlbmNlIG9mIGJpdHMgd2l0aGluIGEge0BsaW5rIEJpdFN0cnVjdHVyZX0uXG4gKlxuICogQWxsIGJpdCBmaWVsZCB2YWx1ZXMgYXJlIHJlcHJlc2VudGVkIGFzIHVuc2lnbmVkIGludGVnZXJzLlxuICpcbiAqICoqTk9URSoqIFVzZXIgY29kZSBzaG91bGQgbm90IGludm9rZSB0aGlzIGNvbnN0cnVjdG9yIGRpcmVjdGx5LlxuICogVXNlIHRoZSBjb250YWluZXIge0BsaW5rIEJpdFN0cnVjdHVyZSNhZGRGaWVsZHxhZGRGaWVsZH0gaGVscGVyXG4gKiBtZXRob2QuXG4gKlxuICogKipOT1RFKiogQml0RmllbGQgaW5zdGFuY2VzIGFyZSBub3QgaW5zdGFuY2VzIG9mIHtAbGluayBMYXlvdXR9XG4gKiBzaW5jZSB7QGxpbmsgTGF5b3V0I3NwYW58c3Bhbn0gbWVhc3VyZXMgOC1iaXQgdW5pdHMuXG4gKlxuICogQHBhcmFtIHtCaXRTdHJ1Y3R1cmV9IGNvbnRhaW5lciAtIGluaXRpYWxpemVyIGZvciB7QGxpbmtcbiAqIEJpdEZpZWxkI2NvbnRhaW5lcnxjb250YWluZXJ9LlxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSBiaXRzIC0gaW5pdGlhbGl6ZXIgZm9yIHtAbGluayBCaXRGaWVsZCNiaXRzfGJpdHN9LlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBbcHJvcGVydHldIC0gaW5pdGlhbGl6ZXIgZm9yIHtAbGlua1xuICogTGF5b3V0I3Byb3BlcnR5fHByb3BlcnR5fS5cbiAqL1xuY2xhc3MgQml0RmllbGQge1xuICAgIGNvbnN0cnVjdG9yKGNvbnRhaW5lciwgYml0cywgcHJvcGVydHkpIHtcbiAgICAgICAgaWYgKCEoY29udGFpbmVyIGluc3RhbmNlb2YgQml0U3RydWN0dXJlKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignY29udGFpbmVyIG11c3QgYmUgYSBCaXRTdHJ1Y3R1cmUnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoKCFOdW1iZXIuaXNJbnRlZ2VyKGJpdHMpKSB8fCAoMCA+PSBiaXRzKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignYml0cyBtdXN0IGJlIHBvc2l0aXZlIGludGVnZXInKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB0b3RhbEJpdHMgPSA4ICogY29udGFpbmVyLnNwYW47XG4gICAgICAgIGNvbnN0IHVzZWRCaXRzID0gY29udGFpbmVyLmZpZWxkcy5yZWR1Y2UoKHN1bSwgZmQpID0+IHN1bSArIGZkLmJpdHMsIDApO1xuICAgICAgICBpZiAoKGJpdHMgKyB1c2VkQml0cykgPiB0b3RhbEJpdHMpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignYml0cyB0b28gbG9uZyBmb3Igc3BhbiByZW1haW5kZXIgKCdcbiAgICAgICAgICAgICAgICArICh0b3RhbEJpdHMgLSB1c2VkQml0cykgKyAnIG9mICdcbiAgICAgICAgICAgICAgICArIHRvdGFsQml0cyArICcgcmVtYWluKScpO1xuICAgICAgICB9XG4gICAgICAgIC8qKiBUaGUge0BsaW5rIEJpdFN0cnVjdHVyZX0gaW5zdGFuY2UgdG8gd2hpY2ggdGhpcyBiaXQgZmllbGRcbiAgICAgICAgICogYmVsb25ncy4gKi9cbiAgICAgICAgdGhpcy5jb250YWluZXIgPSBjb250YWluZXI7XG4gICAgICAgIC8qKiBUaGUgc3BhbiBvZiB0aGlzIHZhbHVlIGluIGJpdHMuICovXG4gICAgICAgIHRoaXMuYml0cyA9IGJpdHM7XG4gICAgICAgIC8qKiBBIG1hc2sgb2Yge0BsaW5rIEJpdEZpZWxkI2JpdHN8Yml0c30gYml0cyBpc29sYXRpbmcgdmFsdWUgYml0c1xuICAgICAgICAgKiB0aGF0IGZpdCB3aXRoaW4gdGhlIGZpZWxkLlxuICAgICAgICAgKlxuICAgICAgICAgKiBUaGF0IGlzLCBpdCBtYXNrcyBhIHZhbHVlIHRoYXQgaGFzIG5vdCB5ZXQgYmVlbiBzaGlmdGVkIGludG9cbiAgICAgICAgICogcG9zaXRpb24gd2l0aGluIGl0cyBjb250YWluaW5nIHBhY2tlZCBpbnRlZ2VyLiAqL1xuICAgICAgICB0aGlzLnZhbHVlTWFzayA9ICgxIDw8IGJpdHMpIC0gMTtcbiAgICAgICAgaWYgKDMyID09PSBiaXRzKSB7IC8vIHNoaWZ0ZWQgdmFsdWUgb3V0IG9mIHJhbmdlXG4gICAgICAgICAgICB0aGlzLnZhbHVlTWFzayA9IDB4RkZGRkZGRkY7XG4gICAgICAgIH1cbiAgICAgICAgLyoqIFRoZSBvZmZzZXQgb2YgdGhlIHZhbHVlIHdpdGhpbiB0aGUgY29udGFpbmluZyBwYWNrZWQgdW5zaWduZWRcbiAgICAgICAgICogaW50ZWdlci4gIFRoZSBsZWFzdCBzaWduaWZpY2FudCBiaXQgb2YgdGhlIHBhY2tlZCB2YWx1ZSBpcyBhdFxuICAgICAgICAgKiBvZmZzZXQgemVybywgcmVnYXJkbGVzcyBvZiBiaXQgb3JkZXJpbmcgdXNlZC4gKi9cbiAgICAgICAgdGhpcy5zdGFydCA9IHVzZWRCaXRzO1xuICAgICAgICBpZiAodGhpcy5jb250YWluZXIubXNiKSB7XG4gICAgICAgICAgICB0aGlzLnN0YXJ0ID0gdG90YWxCaXRzIC0gdXNlZEJpdHMgLSBiaXRzO1xuICAgICAgICB9XG4gICAgICAgIC8qKiBBIG1hc2sgb2Yge0BsaW5rIEJpdEZpZWxkI2JpdHN8Yml0c30gaXNvbGF0aW5nIHRoZSBmaWVsZCB2YWx1ZVxuICAgICAgICAgKiB3aXRoaW4gdGhlIGNvbnRhaW5pbmcgcGFja2VkIHVuc2lnbmVkIGludGVnZXIuICovXG4gICAgICAgIHRoaXMud29yZE1hc2sgPSBmaXhCaXR3aXNlUmVzdWx0KHRoaXMudmFsdWVNYXNrIDw8IHRoaXMuc3RhcnQpO1xuICAgICAgICAvKiogVGhlIHByb3BlcnR5IG5hbWUgdXNlZCB3aGVuIHRoaXMgYml0ZmllbGQgaXMgcmVwcmVzZW50ZWQgaW4gYW5cbiAgICAgICAgICogT2JqZWN0LlxuICAgICAgICAgKlxuICAgICAgICAgKiBJbnRlbmRlZCB0byBiZSBmdW5jdGlvbmFsbHkgZXF1aXZhbGVudCB0byB7QGxpbmtcbiAgICAgICAgICogTGF5b3V0I3Byb3BlcnR5fS5cbiAgICAgICAgICpcbiAgICAgICAgICogSWYgbGVmdCB1bmRlZmluZWQgdGhlIGNvcnJlc3BvbmRpbmcgc3BhbiBvZiBiaXRzIHdpbGwgYmVcbiAgICAgICAgICogdHJlYXRlZCBhcyBwYWRkaW5nOiBpdCB3aWxsIG5vdCBiZSBtdXRhdGVkIGJ5IHtAbGlua1xuICAgICAgICAgKiBMYXlvdXQjZW5jb2RlfGVuY29kZX0gbm9yIHJlcHJlc2VudGVkIGFzIGEgcHJvcGVydHkgaW4gdGhlXG4gICAgICAgICAqIGRlY29kZWQgT2JqZWN0LiAqL1xuICAgICAgICB0aGlzLnByb3BlcnR5ID0gcHJvcGVydHk7XG4gICAgfVxuICAgIC8qKiBTdG9yZSBhIHZhbHVlIGludG8gdGhlIGNvcnJlc3BvbmRpbmcgc3Vic2VxdWVuY2Ugb2YgdGhlIGNvbnRhaW5pbmdcbiAgICAgKiBiaXQgZmllbGQuICovXG4gICAgZGVjb2RlKGIsIG9mZnNldCkge1xuICAgICAgICBjb25zdCB3b3JkID0gdGhpcy5jb250YWluZXIuX3BhY2tlZEdldFZhbHVlKCk7XG4gICAgICAgIGNvbnN0IHdvcmRWYWx1ZSA9IGZpeEJpdHdpc2VSZXN1bHQod29yZCAmIHRoaXMud29yZE1hc2spO1xuICAgICAgICBjb25zdCB2YWx1ZSA9IHdvcmRWYWx1ZSA+Pj4gdGhpcy5zdGFydDtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbiAgICAvKiogU3RvcmUgYSB2YWx1ZSBpbnRvIHRoZSBjb3JyZXNwb25kaW5nIHN1YnNlcXVlbmNlIG9mIHRoZSBjb250YWluaW5nXG4gICAgICogYml0IGZpZWxkLlxuICAgICAqXG4gICAgICogKipOT1RFKiogVGhpcyBpcyBub3QgYSBzcGVjaWFsaXphdGlvbiBvZiB7QGxpbmtcbiAgICAgKiBMYXlvdXQjZW5jb2RlfExheW91dC5lbmNvZGV9IGFuZCB0aGVyZSBpcyBubyByZXR1cm4gdmFsdWUuICovXG4gICAgZW5jb2RlKHZhbHVlKSB7XG4gICAgICAgIGlmICgnbnVtYmVyJyAhPT0gdHlwZW9mIHZhbHVlXG4gICAgICAgICAgICB8fCAhTnVtYmVyLmlzSW50ZWdlcih2YWx1ZSlcbiAgICAgICAgICAgIHx8ICh2YWx1ZSAhPT0gZml4Qml0d2lzZVJlc3VsdCh2YWx1ZSAmIHRoaXMudmFsdWVNYXNrKSkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IobmFtZVdpdGhQcm9wZXJ0eSgnQml0RmllbGQuZW5jb2RlJywgdGhpcylcbiAgICAgICAgICAgICAgICArICcgdmFsdWUgbXVzdCBiZSBpbnRlZ2VyIG5vdCBleGNlZWRpbmcgJyArIHRoaXMudmFsdWVNYXNrKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB3b3JkID0gdGhpcy5jb250YWluZXIuX3BhY2tlZEdldFZhbHVlKCk7XG4gICAgICAgIGNvbnN0IHdvcmRWYWx1ZSA9IGZpeEJpdHdpc2VSZXN1bHQodmFsdWUgPDwgdGhpcy5zdGFydCk7XG4gICAgICAgIHRoaXMuY29udGFpbmVyLl9wYWNrZWRTZXRWYWx1ZShmaXhCaXR3aXNlUmVzdWx0KHdvcmQgJiB+dGhpcy53b3JkTWFzaylcbiAgICAgICAgICAgIHwgd29yZFZhbHVlKTtcbiAgICB9XG59XG5leHBvcnRzLkJpdEZpZWxkID0gQml0RmllbGQ7XG4vKipcbiAqIFJlcHJlc2VudCBhIHNpbmdsZSBiaXQgd2l0aGluIGEge0BsaW5rIEJpdFN0cnVjdHVyZX0gYXMgYVxuICogSmF2YVNjcmlwdCBib29sZWFuLlxuICpcbiAqICoqTk9URSoqIFVzZXIgY29kZSBzaG91bGQgbm90IGludm9rZSB0aGlzIGNvbnN0cnVjdG9yIGRpcmVjdGx5LlxuICogVXNlIHRoZSBjb250YWluZXIge0BsaW5rIEJpdFN0cnVjdHVyZSNhZGRCb29sZWFufGFkZEJvb2xlYW59IGhlbHBlclxuICogbWV0aG9kLlxuICpcbiAqIEBwYXJhbSB7Qml0U3RydWN0dXJlfSBjb250YWluZXIgLSBpbml0aWFsaXplciBmb3Ige0BsaW5rXG4gKiBCaXRGaWVsZCNjb250YWluZXJ8Y29udGFpbmVyfS5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gW3Byb3BlcnR5XSAtIGluaXRpYWxpemVyIGZvciB7QGxpbmtcbiAqIExheW91dCNwcm9wZXJ0eXxwcm9wZXJ0eX0uXG4gKlxuICogQGF1Z21lbnRzIHtCaXRGaWVsZH1cbiAqL1xuLyogZXNsaW50LWRpc2FibGUgbm8tZXh0ZW5kLW5hdGl2ZSAqL1xuY2xhc3MgQm9vbGVhbiBleHRlbmRzIEJpdEZpZWxkIHtcbiAgICBjb25zdHJ1Y3Rvcihjb250YWluZXIsIHByb3BlcnR5KSB7XG4gICAgICAgIHN1cGVyKGNvbnRhaW5lciwgMSwgcHJvcGVydHkpO1xuICAgIH1cbiAgICAvKiogT3ZlcnJpZGUge0BsaW5rIEJpdEZpZWxkI2RlY29kZXxkZWNvZGV9IGZvciB7QGxpbmsgQm9vbGVhbnxCb29sZWFufS5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSAqL1xuICAgIGRlY29kZShiLCBvZmZzZXQpIHtcbiAgICAgICAgcmV0dXJuICEhc3VwZXIuZGVjb2RlKGIsIG9mZnNldCk7XG4gICAgfVxuICAgIC8qKiBAb3ZlcnJpZGUgKi9cbiAgICBlbmNvZGUodmFsdWUpIHtcbiAgICAgICAgaWYgKCdib29sZWFuJyA9PT0gdHlwZW9mIHZhbHVlKSB7XG4gICAgICAgICAgICAvLyBCaXRGaWVsZCByZXF1aXJlcyBpbnRlZ2VyIHZhbHVlc1xuICAgICAgICAgICAgdmFsdWUgPSArdmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgc3VwZXIuZW5jb2RlKHZhbHVlKTtcbiAgICB9XG59XG5leHBvcnRzLkJvb2xlYW4gPSBCb29sZWFuO1xuLyogZXNsaW50LWVuYWJsZSBuby1leHRlbmQtbmF0aXZlICovXG4vKipcbiAqIENvbnRhaW4gYSBmaXhlZC1sZW5ndGggYmxvY2sgb2YgYXJiaXRyYXJ5IGRhdGEsIHJlcHJlc2VudGVkIGFzIGFcbiAqIFVpbnQ4QXJyYXkuXG4gKlxuICogKkZhY3RvcnkqOiB7QGxpbmsgbW9kdWxlOkxheW91dC5ibG9ifGJsb2J9XG4gKlxuICogQHBhcmFtIHsoTnVtYmVyfEV4dGVybmFsTGF5b3V0KX0gbGVuZ3RoIC0gaW5pdGlhbGl6ZXMge0BsaW5rXG4gKiBCbG9iI2xlbmd0aHxsZW5ndGh9LlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBbcHJvcGVydHldIC0gaW5pdGlhbGl6ZXIgZm9yIHtAbGlua1xuICogTGF5b3V0I3Byb3BlcnR5fHByb3BlcnR5fS5cbiAqXG4gKiBAYXVnbWVudHMge0xheW91dH1cbiAqL1xuY2xhc3MgQmxvYiBleHRlbmRzIExheW91dCB7XG4gICAgY29uc3RydWN0b3IobGVuZ3RoLCBwcm9wZXJ0eSkge1xuICAgICAgICBpZiAoISgoKGxlbmd0aCBpbnN0YW5jZW9mIEV4dGVybmFsTGF5b3V0KSAmJiBsZW5ndGguaXNDb3VudCgpKVxuICAgICAgICAgICAgfHwgKE51bWJlci5pc0ludGVnZXIobGVuZ3RoKSAmJiAoMCA8PSBsZW5ndGgpKSkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2xlbmd0aCBtdXN0IGJlIHBvc2l0aXZlIGludGVnZXIgJ1xuICAgICAgICAgICAgICAgICsgJ29yIGFuIHVuc2lnbmVkIGludGVnZXIgRXh0ZXJuYWxMYXlvdXQnKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgc3BhbiA9IC0xO1xuICAgICAgICBpZiAoIShsZW5ndGggaW5zdGFuY2VvZiBFeHRlcm5hbExheW91dCkpIHtcbiAgICAgICAgICAgIHNwYW4gPSBsZW5ndGg7XG4gICAgICAgIH1cbiAgICAgICAgc3VwZXIoc3BhbiwgcHJvcGVydHkpO1xuICAgICAgICAvKiogVGhlIG51bWJlciBvZiBieXRlcyBpbiB0aGUgYmxvYi5cbiAgICAgICAgICpcbiAgICAgICAgICogVGhpcyBtYXkgYmUgYSBub24tbmVnYXRpdmUgaW50ZWdlciwgb3IgYW4gaW5zdGFuY2Ugb2Yge0BsaW5rXG4gICAgICAgICAqIEV4dGVybmFsTGF5b3V0fSB0aGF0IHNhdGlzZmllcyB7QGxpbmtcbiAgICAgICAgICogRXh0ZXJuYWxMYXlvdXQjaXNDb3VudHxpc0NvdW50KCl9LiAqL1xuICAgICAgICB0aGlzLmxlbmd0aCA9IGxlbmd0aDtcbiAgICB9XG4gICAgLyoqIEBvdmVycmlkZSAqL1xuICAgIGdldFNwYW4oYiwgb2Zmc2V0KSB7XG4gICAgICAgIGxldCBzcGFuID0gdGhpcy5zcGFuO1xuICAgICAgICBpZiAoMCA+IHNwYW4pIHtcbiAgICAgICAgICAgIHNwYW4gPSB0aGlzLmxlbmd0aC5kZWNvZGUoYiwgb2Zmc2V0KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3BhbjtcbiAgICB9XG4gICAgLyoqIEBvdmVycmlkZSAqL1xuICAgIGRlY29kZShiLCBvZmZzZXQgPSAwKSB7XG4gICAgICAgIGxldCBzcGFuID0gdGhpcy5zcGFuO1xuICAgICAgICBpZiAoMCA+IHNwYW4pIHtcbiAgICAgICAgICAgIHNwYW4gPSB0aGlzLmxlbmd0aC5kZWNvZGUoYiwgb2Zmc2V0KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdWludDhBcnJheVRvQnVmZmVyKGIpLnNsaWNlKG9mZnNldCwgb2Zmc2V0ICsgc3Bhbik7XG4gICAgfVxuICAgIC8qKiBJbXBsZW1lbnQge0BsaW5rIExheW91dCNlbmNvZGV8ZW5jb2RlfSBmb3Ige0BsaW5rIEJsb2J9LlxuICAgICAqXG4gICAgICogKipOT1RFKiogSWYge0BsaW5rIExheW91dCNjb3VudHxjb3VudH0gaXMgYW4gaW5zdGFuY2Ugb2Yge0BsaW5rXG4gICAgICogRXh0ZXJuYWxMYXlvdXR9IHRoZW4gdGhlIGxlbmd0aCBvZiBgc3JjYCB3aWxsIGJlIGVuY29kZWQgYXMgdGhlXG4gICAgICogY291bnQgYWZ0ZXIgYHNyY2AgaXMgZW5jb2RlZC4gKi9cbiAgICBlbmNvZGUoc3JjLCBiLCBvZmZzZXQpIHtcbiAgICAgICAgbGV0IHNwYW4gPSB0aGlzLmxlbmd0aDtcbiAgICAgICAgaWYgKHRoaXMubGVuZ3RoIGluc3RhbmNlb2YgRXh0ZXJuYWxMYXlvdXQpIHtcbiAgICAgICAgICAgIHNwYW4gPSBzcmMubGVuZ3RoO1xuICAgICAgICB9XG4gICAgICAgIGlmICghKHNyYyBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkgJiYgc3BhbiA9PT0gc3JjLmxlbmd0aCkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IobmFtZVdpdGhQcm9wZXJ0eSgnQmxvYi5lbmNvZGUnLCB0aGlzKVxuICAgICAgICAgICAgICAgICsgJyByZXF1aXJlcyAobGVuZ3RoICcgKyBzcGFuICsgJykgVWludDhBcnJheSBhcyBzcmMnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoKG9mZnNldCArIHNwYW4pID4gYi5sZW5ndGgpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdlbmNvZGluZyBvdmVycnVucyBVaW50OEFycmF5Jyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc3JjQnVmZmVyID0gdWludDhBcnJheVRvQnVmZmVyKHNyYyk7XG4gICAgICAgIHVpbnQ4QXJyYXlUb0J1ZmZlcihiKS53cml0ZShzcmNCdWZmZXIudG9TdHJpbmcoJ2hleCcpLCBvZmZzZXQsIHNwYW4sICdoZXgnKTtcbiAgICAgICAgaWYgKHRoaXMubGVuZ3RoIGluc3RhbmNlb2YgRXh0ZXJuYWxMYXlvdXQpIHtcbiAgICAgICAgICAgIHRoaXMubGVuZ3RoLmVuY29kZShzcGFuLCBiLCBvZmZzZXQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzcGFuO1xuICAgIH1cbn1cbmV4cG9ydHMuQmxvYiA9IEJsb2I7XG4vKipcbiAqIENvbnRhaW4gYSBgTlVMYC10ZXJtaW5hdGVkIFVURjggc3RyaW5nLlxuICpcbiAqICpGYWN0b3J5Kjoge0BsaW5rIG1vZHVsZTpMYXlvdXQuY3N0cnxjc3RyfVxuICpcbiAqICoqTk9URSoqIEFueSBVVEY4IHN0cmluZyB0aGF0IGluY29ycG9yYXRlcyBhIHplcm8tdmFsdWVkIGJ5dGUgd2lsbFxuICogbm90IGJlIGNvcnJlY3RseSBkZWNvZGVkIGJ5IHRoaXMgbGF5b3V0LlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBbcHJvcGVydHldIC0gaW5pdGlhbGl6ZXIgZm9yIHtAbGlua1xuICogTGF5b3V0I3Byb3BlcnR5fHByb3BlcnR5fS5cbiAqXG4gKiBAYXVnbWVudHMge0xheW91dH1cbiAqL1xuY2xhc3MgQ1N0cmluZyBleHRlbmRzIExheW91dCB7XG4gICAgY29uc3RydWN0b3IocHJvcGVydHkpIHtcbiAgICAgICAgc3VwZXIoLTEsIHByb3BlcnR5KTtcbiAgICB9XG4gICAgLyoqIEBvdmVycmlkZSAqL1xuICAgIGdldFNwYW4oYiwgb2Zmc2V0ID0gMCkge1xuICAgICAgICBjaGVja1VpbnQ4QXJyYXkoYik7XG4gICAgICAgIGxldCBpZHggPSBvZmZzZXQ7XG4gICAgICAgIHdoaWxlICgoaWR4IDwgYi5sZW5ndGgpICYmICgwICE9PSBiW2lkeF0pKSB7XG4gICAgICAgICAgICBpZHggKz0gMTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gMSArIGlkeCAtIG9mZnNldDtcbiAgICB9XG4gICAgLyoqIEBvdmVycmlkZSAqL1xuICAgIGRlY29kZShiLCBvZmZzZXQgPSAwKSB7XG4gICAgICAgIGNvbnN0IHNwYW4gPSB0aGlzLmdldFNwYW4oYiwgb2Zmc2V0KTtcbiAgICAgICAgcmV0dXJuIHVpbnQ4QXJyYXlUb0J1ZmZlcihiKS5zbGljZShvZmZzZXQsIG9mZnNldCArIHNwYW4gLSAxKS50b1N0cmluZygndXRmLTgnKTtcbiAgICB9XG4gICAgLyoqIEBvdmVycmlkZSAqL1xuICAgIGVuY29kZShzcmMsIGIsIG9mZnNldCA9IDApIHtcbiAgICAgICAgLyogTXVzdCBmb3JjZSB0aGlzIHRvIGEgc3RyaW5nLCBsZXN0IGl0IGJlIGEgbnVtYmVyIGFuZCB0aGVcbiAgICAgICAgICogXCJ1dGY4LWVuY29kaW5nXCIgYmVsb3cgYWN0dWFsbHkgYWxsb2NhdGUgYSBidWZmZXIgb2YgbGVuZ3RoXG4gICAgICAgICAqIHNyYyAqL1xuICAgICAgICBpZiAoJ3N0cmluZycgIT09IHR5cGVvZiBzcmMpIHtcbiAgICAgICAgICAgIHNyYyA9IFN0cmluZyhzcmMpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHNyY2IgPSBidWZmZXJfMS5CdWZmZXIuZnJvbShzcmMsICd1dGY4Jyk7XG4gICAgICAgIGNvbnN0IHNwYW4gPSBzcmNiLmxlbmd0aDtcbiAgICAgICAgaWYgKChvZmZzZXQgKyBzcGFuKSA+IGIubGVuZ3RoKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignZW5jb2Rpbmcgb3ZlcnJ1bnMgQnVmZmVyJyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYnVmZmVyID0gdWludDhBcnJheVRvQnVmZmVyKGIpO1xuICAgICAgICBzcmNiLmNvcHkoYnVmZmVyLCBvZmZzZXQpO1xuICAgICAgICBidWZmZXJbb2Zmc2V0ICsgc3Bhbl0gPSAwO1xuICAgICAgICByZXR1cm4gc3BhbiArIDE7XG4gICAgfVxufVxuZXhwb3J0cy5DU3RyaW5nID0gQ1N0cmluZztcbi8qKlxuICogQ29udGFpbiBhIFVURjggc3RyaW5nIHdpdGggaW1wbGljaXQgbGVuZ3RoLlxuICpcbiAqICpGYWN0b3J5Kjoge0BsaW5rIG1vZHVsZTpMYXlvdXQudXRmOHx1dGY4fVxuICpcbiAqICoqTk9URSoqIEJlY2F1c2UgdGhlIGxlbmd0aCBpcyBpbXBsaWNpdCBpbiB0aGUgc2l6ZSBvZiB0aGUgYnVmZmVyXG4gKiB0aGlzIGxheW91dCBzaG91bGQgYmUgdXNlZCBvbmx5IGluIGlzb2xhdGlvbiwgb3IgaW4gYSBzaXR1YXRpb25cbiAqIHdoZXJlIHRoZSBsZW5ndGggY2FuIGJlIGV4cHJlc3NlZCBieSBvcGVyYXRpbmcgb24gYSBzbGljZSBvZiB0aGVcbiAqIGNvbnRhaW5pbmcgYnVmZmVyLlxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSBbbWF4U3Bhbl0gLSB0aGUgbWF4aW11bSBsZW5ndGggYWxsb3dlZCBmb3IgZW5jb2RlZFxuICogc3RyaW5nIGNvbnRlbnQuICBJZiBub3QgcHJvdmlkZWQgdGhlcmUgaXMgbm8gYm91bmQgb24gdGhlIGFsbG93ZWRcbiAqIGNvbnRlbnQuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IFtwcm9wZXJ0eV0gLSBpbml0aWFsaXplciBmb3Ige0BsaW5rXG4gKiBMYXlvdXQjcHJvcGVydHl8cHJvcGVydHl9LlxuICpcbiAqIEBhdWdtZW50cyB7TGF5b3V0fVxuICovXG5jbGFzcyBVVEY4IGV4dGVuZHMgTGF5b3V0IHtcbiAgICBjb25zdHJ1Y3RvcihtYXhTcGFuLCBwcm9wZXJ0eSkge1xuICAgICAgICBpZiAoKCdzdHJpbmcnID09PSB0eXBlb2YgbWF4U3BhbikgJiYgKHVuZGVmaW5lZCA9PT0gcHJvcGVydHkpKSB7XG4gICAgICAgICAgICBwcm9wZXJ0eSA9IG1heFNwYW47XG4gICAgICAgICAgICBtYXhTcGFuID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIGlmICh1bmRlZmluZWQgPT09IG1heFNwYW4pIHtcbiAgICAgICAgICAgIG1heFNwYW4gPSAtMTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICghTnVtYmVyLmlzSW50ZWdlcihtYXhTcGFuKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignbWF4U3BhbiBtdXN0IGJlIGFuIGludGVnZXInKTtcbiAgICAgICAgfVxuICAgICAgICBzdXBlcigtMSwgcHJvcGVydHkpO1xuICAgICAgICAvKiogVGhlIG1heGltdW0gc3BhbiBvZiB0aGUgbGF5b3V0IGluIGJ5dGVzLlxuICAgICAgICAgKlxuICAgICAgICAgKiBQb3NpdGl2ZSB2YWx1ZXMgYXJlIGdlbmVyYWxseSBleHBlY3RlZC4gIFplcm8gaXMgYWJub3JtYWwuXG4gICAgICAgICAqIEF0dGVtcHRzIHRvIGVuY29kZSBvciBkZWNvZGUgYSB2YWx1ZSB0aGF0IGV4Y2VlZHMgdGhpcyBsZW5ndGhcbiAgICAgICAgICogd2lsbCB0aHJvdyBhIGBSYW5nZUVycm9yYC5cbiAgICAgICAgICpcbiAgICAgICAgICogQSBuZWdhdGl2ZSB2YWx1ZSBpbmRpY2F0ZXMgdGhhdCB0aGVyZSBpcyBubyBib3VuZCBvbiB0aGUgbGVuZ3RoXG4gICAgICAgICAqIG9mIHRoZSBjb250ZW50LiAqL1xuICAgICAgICB0aGlzLm1heFNwYW4gPSBtYXhTcGFuO1xuICAgIH1cbiAgICAvKiogQG92ZXJyaWRlICovXG4gICAgZ2V0U3BhbihiLCBvZmZzZXQgPSAwKSB7XG4gICAgICAgIGNoZWNrVWludDhBcnJheShiKTtcbiAgICAgICAgcmV0dXJuIGIubGVuZ3RoIC0gb2Zmc2V0O1xuICAgIH1cbiAgICAvKiogQG92ZXJyaWRlICovXG4gICAgZGVjb2RlKGIsIG9mZnNldCA9IDApIHtcbiAgICAgICAgY29uc3Qgc3BhbiA9IHRoaXMuZ2V0U3BhbihiLCBvZmZzZXQpO1xuICAgICAgICBpZiAoKDAgPD0gdGhpcy5tYXhTcGFuKVxuICAgICAgICAgICAgJiYgKHRoaXMubWF4U3BhbiA8IHNwYW4pKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcigndGV4dCBsZW5ndGggZXhjZWVkcyBtYXhTcGFuJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHVpbnQ4QXJyYXlUb0J1ZmZlcihiKS5zbGljZShvZmZzZXQsIG9mZnNldCArIHNwYW4pLnRvU3RyaW5nKCd1dGYtOCcpO1xuICAgIH1cbiAgICAvKiogQG92ZXJyaWRlICovXG4gICAgZW5jb2RlKHNyYywgYiwgb2Zmc2V0ID0gMCkge1xuICAgICAgICAvKiBNdXN0IGZvcmNlIHRoaXMgdG8gYSBzdHJpbmcsIGxlc3QgaXQgYmUgYSBudW1iZXIgYW5kIHRoZVxuICAgICAgICAgKiBcInV0ZjgtZW5jb2RpbmdcIiBiZWxvdyBhY3R1YWxseSBhbGxvY2F0ZSBhIGJ1ZmZlciBvZiBsZW5ndGhcbiAgICAgICAgICogc3JjICovXG4gICAgICAgIGlmICgnc3RyaW5nJyAhPT0gdHlwZW9mIHNyYykge1xuICAgICAgICAgICAgc3JjID0gU3RyaW5nKHNyYyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc3JjYiA9IGJ1ZmZlcl8xLkJ1ZmZlci5mcm9tKHNyYywgJ3V0ZjgnKTtcbiAgICAgICAgY29uc3Qgc3BhbiA9IHNyY2IubGVuZ3RoO1xuICAgICAgICBpZiAoKDAgPD0gdGhpcy5tYXhTcGFuKVxuICAgICAgICAgICAgJiYgKHRoaXMubWF4U3BhbiA8IHNwYW4pKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcigndGV4dCBsZW5ndGggZXhjZWVkcyBtYXhTcGFuJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKChvZmZzZXQgKyBzcGFuKSA+IGIubGVuZ3RoKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignZW5jb2Rpbmcgb3ZlcnJ1bnMgQnVmZmVyJyk7XG4gICAgICAgIH1cbiAgICAgICAgc3JjYi5jb3B5KHVpbnQ4QXJyYXlUb0J1ZmZlcihiKSwgb2Zmc2V0KTtcbiAgICAgICAgcmV0dXJuIHNwYW47XG4gICAgfVxufVxuZXhwb3J0cy5VVEY4ID0gVVRGODtcbi8qKlxuICogQ29udGFpbiBhIGNvbnN0YW50IHZhbHVlLlxuICpcbiAqIFRoaXMgbGF5b3V0IG1heSBiZSB1c2VkIGluIGNhc2VzIHdoZXJlIGEgSmF2YVNjcmlwdCB2YWx1ZSBjYW4gYmVcbiAqIGluZmVycmVkIHdpdGhvdXQgYW4gZXhwcmVzc2lvbiBpbiB0aGUgYmluYXJ5IGVuY29kaW5nLiAgQW4gZXhhbXBsZVxuICogd291bGQgYmUgYSB7QGxpbmsgVmFyaWFudExheW91dHx2YXJpYW50IGxheW91dH0gd2hlcmUgdGhlIGNvbnRlbnRcbiAqIGlzIGltcGxpZWQgYnkgdGhlIHVuaW9uIHtAbGluayBVbmlvbiNkaXNjcmltaW5hdG9yfGRpc2NyaW1pbmF0b3J9LlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fE51bWJlcnxTdHJpbmd9IHZhbHVlIC0gaW5pdGlhbGl6ZXIgZm9yIHtAbGlua1xuICogQ29uc3RhbnQjdmFsdWV8dmFsdWV9LiAgSWYgdGhlIHZhbHVlIGlzIGFuIG9iamVjdCAob3IgYXJyYXkpIGFuZFxuICogdGhlIGFwcGxpY2F0aW9uIGludGVuZHMgdGhlIG9iamVjdCB0byByZW1haW4gdW5jaGFuZ2VkIHJlZ2FyZGxlc3NcbiAqIG9mIHdoYXQgaXMgZG9uZSB0byB2YWx1ZXMgZGVjb2RlZCBieSB0aGlzIGxheW91dCwgdGhlIHZhbHVlIHNob3VsZFxuICogYmUgZnJvemVuIHByaW9yIHBhc3NpbmcgaXQgdG8gdGhpcyBjb25zdHJ1Y3Rvci5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gW3Byb3BlcnR5XSAtIGluaXRpYWxpemVyIGZvciB7QGxpbmtcbiAqIExheW91dCNwcm9wZXJ0eXxwcm9wZXJ0eX0uXG4gKlxuICogQGF1Z21lbnRzIHtMYXlvdXR9XG4gKi9cbmNsYXNzIENvbnN0YW50IGV4dGVuZHMgTGF5b3V0IHtcbiAgICBjb25zdHJ1Y3Rvcih2YWx1ZSwgcHJvcGVydHkpIHtcbiAgICAgICAgc3VwZXIoMCwgcHJvcGVydHkpO1xuICAgICAgICAvKiogVGhlIHZhbHVlIHByb2R1Y2VkIGJ5IHRoaXMgY29uc3RhbnQgd2hlbiB0aGUgbGF5b3V0IGlzIHtAbGlua1xuICAgICAgICAgKiBDb25zdGFudCNkZWNvZGV8ZGVjb2RlZH0uXG4gICAgICAgICAqXG4gICAgICAgICAqIEFueSBKYXZhU2NyaXB0IHZhbHVlIGluY2x1ZGluZyBgbnVsbGAgYW5kIGB1bmRlZmluZWRgIGlzXG4gICAgICAgICAqIHBlcm1pdHRlZC5cbiAgICAgICAgICpcbiAgICAgICAgICogKipXQVJOSU5HKiogSWYgYHZhbHVlYCBwYXNzZWQgaW4gdGhlIGNvbnN0cnVjdG9yIHdhcyBub3RcbiAgICAgICAgICogZnJvemVuLCBpdCBpcyBwb3NzaWJsZSBmb3IgdXNlcnMgb2YgZGVjb2RlZCB2YWx1ZXMgdG8gY2hhbmdlXG4gICAgICAgICAqIHRoZSBjb250ZW50IG9mIHRoZSB2YWx1ZS4gKi9cbiAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgIH1cbiAgICAvKiogQG92ZXJyaWRlICovXG4gICAgZGVjb2RlKGIsIG9mZnNldCkge1xuICAgICAgICByZXR1cm4gdGhpcy52YWx1ZTtcbiAgICB9XG4gICAgLyoqIEBvdmVycmlkZSAqL1xuICAgIGVuY29kZShzcmMsIGIsIG9mZnNldCkge1xuICAgICAgICAvKiBDb25zdGFudHMgdGFrZSBubyBzcGFjZSAqL1xuICAgICAgICByZXR1cm4gMDtcbiAgICB9XG59XG5leHBvcnRzLkNvbnN0YW50ID0gQ29uc3RhbnQ7XG4vKiogRmFjdG9yeSBmb3Ige0BsaW5rIEdyZWVkeUNvdW50fS4gKi9cbmV4cG9ydHMuZ3JlZWR5ID0gKChlbGVtZW50U3BhbiwgcHJvcGVydHkpID0+IG5ldyBHcmVlZHlDb3VudChlbGVtZW50U3BhbiwgcHJvcGVydHkpKTtcbi8qKiBGYWN0b3J5IGZvciB7QGxpbmsgT2Zmc2V0TGF5b3V0fS4gKi9cbmV4cG9ydHMub2Zmc2V0ID0gKChsYXlvdXQsIG9mZnNldCwgcHJvcGVydHkpID0+IG5ldyBPZmZzZXRMYXlvdXQobGF5b3V0LCBvZmZzZXQsIHByb3BlcnR5KSk7XG4vKiogRmFjdG9yeSBmb3Ige0BsaW5rIFVJbnR8dW5zaWduZWQgaW50IGxheW91dHN9IHNwYW5uaW5nIG9uZVxuICogYnl0ZS4gKi9cbmV4cG9ydHMudTggPSAoKHByb3BlcnR5KSA9PiBuZXcgVUludCgxLCBwcm9wZXJ0eSkpO1xuLyoqIEZhY3RvcnkgZm9yIHtAbGluayBVSW50fGxpdHRsZS1lbmRpYW4gdW5zaWduZWQgaW50IGxheW91dHN9XG4gKiBzcGFubmluZyB0d28gYnl0ZXMuICovXG5leHBvcnRzLnUxNiA9ICgocHJvcGVydHkpID0+IG5ldyBVSW50KDIsIHByb3BlcnR5KSk7XG4vKiogRmFjdG9yeSBmb3Ige0BsaW5rIFVJbnR8bGl0dGxlLWVuZGlhbiB1bnNpZ25lZCBpbnQgbGF5b3V0c31cbiAqIHNwYW5uaW5nIHRocmVlIGJ5dGVzLiAqL1xuZXhwb3J0cy51MjQgPSAoKHByb3BlcnR5KSA9PiBuZXcgVUludCgzLCBwcm9wZXJ0eSkpO1xuLyoqIEZhY3RvcnkgZm9yIHtAbGluayBVSW50fGxpdHRsZS1lbmRpYW4gdW5zaWduZWQgaW50IGxheW91dHN9XG4gKiBzcGFubmluZyBmb3VyIGJ5dGVzLiAqL1xuZXhwb3J0cy51MzIgPSAoKHByb3BlcnR5KSA9PiBuZXcgVUludCg0LCBwcm9wZXJ0eSkpO1xuLyoqIEZhY3RvcnkgZm9yIHtAbGluayBVSW50fGxpdHRsZS1lbmRpYW4gdW5zaWduZWQgaW50IGxheW91dHN9XG4gKiBzcGFubmluZyBmaXZlIGJ5dGVzLiAqL1xuZXhwb3J0cy51NDAgPSAoKHByb3BlcnR5KSA9PiBuZXcgVUludCg1LCBwcm9wZXJ0eSkpO1xuLyoqIEZhY3RvcnkgZm9yIHtAbGluayBVSW50fGxpdHRsZS1lbmRpYW4gdW5zaWduZWQgaW50IGxheW91dHN9XG4gKiBzcGFubmluZyBzaXggYnl0ZXMuICovXG5leHBvcnRzLnU0OCA9ICgocHJvcGVydHkpID0+IG5ldyBVSW50KDYsIHByb3BlcnR5KSk7XG4vKiogRmFjdG9yeSBmb3Ige0BsaW5rIE5lYXJVSW50NjR8bGl0dGxlLWVuZGlhbiB1bnNpZ25lZCBpbnRcbiAqIGxheW91dHN9IGludGVycHJldGVkIGFzIE51bWJlcnMuICovXG5leHBvcnRzLm51NjQgPSAoKHByb3BlcnR5KSA9PiBuZXcgTmVhclVJbnQ2NChwcm9wZXJ0eSkpO1xuLyoqIEZhY3RvcnkgZm9yIHtAbGluayBVSW50fGJpZy1lbmRpYW4gdW5zaWduZWQgaW50IGxheW91dHN9XG4gKiBzcGFubmluZyB0d28gYnl0ZXMuICovXG5leHBvcnRzLnUxNmJlID0gKChwcm9wZXJ0eSkgPT4gbmV3IFVJbnRCRSgyLCBwcm9wZXJ0eSkpO1xuLyoqIEZhY3RvcnkgZm9yIHtAbGluayBVSW50fGJpZy1lbmRpYW4gdW5zaWduZWQgaW50IGxheW91dHN9XG4gKiBzcGFubmluZyB0aHJlZSBieXRlcy4gKi9cbmV4cG9ydHMudTI0YmUgPSAoKHByb3BlcnR5KSA9PiBuZXcgVUludEJFKDMsIHByb3BlcnR5KSk7XG4vKiogRmFjdG9yeSBmb3Ige0BsaW5rIFVJbnR8YmlnLWVuZGlhbiB1bnNpZ25lZCBpbnQgbGF5b3V0c31cbiAqIHNwYW5uaW5nIGZvdXIgYnl0ZXMuICovXG5leHBvcnRzLnUzMmJlID0gKChwcm9wZXJ0eSkgPT4gbmV3IFVJbnRCRSg0LCBwcm9wZXJ0eSkpO1xuLyoqIEZhY3RvcnkgZm9yIHtAbGluayBVSW50fGJpZy1lbmRpYW4gdW5zaWduZWQgaW50IGxheW91dHN9XG4gKiBzcGFubmluZyBmaXZlIGJ5dGVzLiAqL1xuZXhwb3J0cy51NDBiZSA9ICgocHJvcGVydHkpID0+IG5ldyBVSW50QkUoNSwgcHJvcGVydHkpKTtcbi8qKiBGYWN0b3J5IGZvciB7QGxpbmsgVUludHxiaWctZW5kaWFuIHVuc2lnbmVkIGludCBsYXlvdXRzfVxuICogc3Bhbm5pbmcgc2l4IGJ5dGVzLiAqL1xuZXhwb3J0cy51NDhiZSA9ICgocHJvcGVydHkpID0+IG5ldyBVSW50QkUoNiwgcHJvcGVydHkpKTtcbi8qKiBGYWN0b3J5IGZvciB7QGxpbmsgTmVhclVJbnQ2NEJFfGJpZy1lbmRpYW4gdW5zaWduZWQgaW50XG4gKiBsYXlvdXRzfSBpbnRlcnByZXRlZCBhcyBOdW1iZXJzLiAqL1xuZXhwb3J0cy5udTY0YmUgPSAoKHByb3BlcnR5KSA9PiBuZXcgTmVhclVJbnQ2NEJFKHByb3BlcnR5KSk7XG4vKiogRmFjdG9yeSBmb3Ige0BsaW5rIEludHxzaWduZWQgaW50IGxheW91dHN9IHNwYW5uaW5nIG9uZVxuICogYnl0ZS4gKi9cbmV4cG9ydHMuczggPSAoKHByb3BlcnR5KSA9PiBuZXcgSW50KDEsIHByb3BlcnR5KSk7XG4vKiogRmFjdG9yeSBmb3Ige0BsaW5rIEludHxsaXR0bGUtZW5kaWFuIHNpZ25lZCBpbnQgbGF5b3V0c31cbiAqIHNwYW5uaW5nIHR3byBieXRlcy4gKi9cbmV4cG9ydHMuczE2ID0gKChwcm9wZXJ0eSkgPT4gbmV3IEludCgyLCBwcm9wZXJ0eSkpO1xuLyoqIEZhY3RvcnkgZm9yIHtAbGluayBJbnR8bGl0dGxlLWVuZGlhbiBzaWduZWQgaW50IGxheW91dHN9XG4gKiBzcGFubmluZyB0aHJlZSBieXRlcy4gKi9cbmV4cG9ydHMuczI0ID0gKChwcm9wZXJ0eSkgPT4gbmV3IEludCgzLCBwcm9wZXJ0eSkpO1xuLyoqIEZhY3RvcnkgZm9yIHtAbGluayBJbnR8bGl0dGxlLWVuZGlhbiBzaWduZWQgaW50IGxheW91dHN9XG4gKiBzcGFubmluZyBmb3VyIGJ5dGVzLiAqL1xuZXhwb3J0cy5zMzIgPSAoKHByb3BlcnR5KSA9PiBuZXcgSW50KDQsIHByb3BlcnR5KSk7XG4vKiogRmFjdG9yeSBmb3Ige0BsaW5rIEludHxsaXR0bGUtZW5kaWFuIHNpZ25lZCBpbnQgbGF5b3V0c31cbiAqIHNwYW5uaW5nIGZpdmUgYnl0ZXMuICovXG5leHBvcnRzLnM0MCA9ICgocHJvcGVydHkpID0+IG5ldyBJbnQoNSwgcHJvcGVydHkpKTtcbi8qKiBGYWN0b3J5IGZvciB7QGxpbmsgSW50fGxpdHRsZS1lbmRpYW4gc2lnbmVkIGludCBsYXlvdXRzfVxuICogc3Bhbm5pbmcgc2l4IGJ5dGVzLiAqL1xuZXhwb3J0cy5zNDggPSAoKHByb3BlcnR5KSA9PiBuZXcgSW50KDYsIHByb3BlcnR5KSk7XG4vKiogRmFjdG9yeSBmb3Ige0BsaW5rIE5lYXJJbnQ2NHxsaXR0bGUtZW5kaWFuIHNpZ25lZCBpbnQgbGF5b3V0c31cbiAqIGludGVycHJldGVkIGFzIE51bWJlcnMuICovXG5leHBvcnRzLm5zNjQgPSAoKHByb3BlcnR5KSA9PiBuZXcgTmVhckludDY0KHByb3BlcnR5KSk7XG4vKiogRmFjdG9yeSBmb3Ige0BsaW5rIEludHxiaWctZW5kaWFuIHNpZ25lZCBpbnQgbGF5b3V0c31cbiAqIHNwYW5uaW5nIHR3byBieXRlcy4gKi9cbmV4cG9ydHMuczE2YmUgPSAoKHByb3BlcnR5KSA9PiBuZXcgSW50QkUoMiwgcHJvcGVydHkpKTtcbi8qKiBGYWN0b3J5IGZvciB7QGxpbmsgSW50fGJpZy1lbmRpYW4gc2lnbmVkIGludCBsYXlvdXRzfVxuICogc3Bhbm5pbmcgdGhyZWUgYnl0ZXMuICovXG5leHBvcnRzLnMyNGJlID0gKChwcm9wZXJ0eSkgPT4gbmV3IEludEJFKDMsIHByb3BlcnR5KSk7XG4vKiogRmFjdG9yeSBmb3Ige0BsaW5rIEludHxiaWctZW5kaWFuIHNpZ25lZCBpbnQgbGF5b3V0c31cbiAqIHNwYW5uaW5nIGZvdXIgYnl0ZXMuICovXG5leHBvcnRzLnMzMmJlID0gKChwcm9wZXJ0eSkgPT4gbmV3IEludEJFKDQsIHByb3BlcnR5KSk7XG4vKiogRmFjdG9yeSBmb3Ige0BsaW5rIEludHxiaWctZW5kaWFuIHNpZ25lZCBpbnQgbGF5b3V0c31cbiAqIHNwYW5uaW5nIGZpdmUgYnl0ZXMuICovXG5leHBvcnRzLnM0MGJlID0gKChwcm9wZXJ0eSkgPT4gbmV3IEludEJFKDUsIHByb3BlcnR5KSk7XG4vKiogRmFjdG9yeSBmb3Ige0BsaW5rIEludHxiaWctZW5kaWFuIHNpZ25lZCBpbnQgbGF5b3V0c31cbiAqIHNwYW5uaW5nIHNpeCBieXRlcy4gKi9cbmV4cG9ydHMuczQ4YmUgPSAoKHByb3BlcnR5KSA9PiBuZXcgSW50QkUoNiwgcHJvcGVydHkpKTtcbi8qKiBGYWN0b3J5IGZvciB7QGxpbmsgTmVhckludDY0QkV8YmlnLWVuZGlhbiBzaWduZWQgaW50IGxheW91dHN9XG4gKiBpbnRlcnByZXRlZCBhcyBOdW1iZXJzLiAqL1xuZXhwb3J0cy5uczY0YmUgPSAoKHByb3BlcnR5KSA9PiBuZXcgTmVhckludDY0QkUocHJvcGVydHkpKTtcbi8qKiBGYWN0b3J5IGZvciB7QGxpbmsgRmxvYXR8bGl0dGxlLWVuZGlhbiAzMi1iaXQgZmxvYXRpbmcgcG9pbnR9IHZhbHVlcy4gKi9cbmV4cG9ydHMuZjMyID0gKChwcm9wZXJ0eSkgPT4gbmV3IEZsb2F0KHByb3BlcnR5KSk7XG4vKiogRmFjdG9yeSBmb3Ige0BsaW5rIEZsb2F0QkV8YmlnLWVuZGlhbiAzMi1iaXQgZmxvYXRpbmcgcG9pbnR9IHZhbHVlcy4gKi9cbmV4cG9ydHMuZjMyYmUgPSAoKHByb3BlcnR5KSA9PiBuZXcgRmxvYXRCRShwcm9wZXJ0eSkpO1xuLyoqIEZhY3RvcnkgZm9yIHtAbGluayBEb3VibGV8bGl0dGxlLWVuZGlhbiA2NC1iaXQgZmxvYXRpbmcgcG9pbnR9IHZhbHVlcy4gKi9cbmV4cG9ydHMuZjY0ID0gKChwcm9wZXJ0eSkgPT4gbmV3IERvdWJsZShwcm9wZXJ0eSkpO1xuLyoqIEZhY3RvcnkgZm9yIHtAbGluayBEb3VibGVCRXxiaWctZW5kaWFuIDY0LWJpdCBmbG9hdGluZyBwb2ludH0gdmFsdWVzLiAqL1xuZXhwb3J0cy5mNjRiZSA9ICgocHJvcGVydHkpID0+IG5ldyBEb3VibGVCRShwcm9wZXJ0eSkpO1xuLyoqIEZhY3RvcnkgZm9yIHtAbGluayBTdHJ1Y3R1cmV9IHZhbHVlcy4gKi9cbmV4cG9ydHMuc3RydWN0ID0gKChmaWVsZHMsIHByb3BlcnR5LCBkZWNvZGVQcmVmaXhlcykgPT4gbmV3IFN0cnVjdHVyZShmaWVsZHMsIHByb3BlcnR5LCBkZWNvZGVQcmVmaXhlcykpO1xuLyoqIEZhY3RvcnkgZm9yIHtAbGluayBCaXRTdHJ1Y3R1cmV9IHZhbHVlcy4gKi9cbmV4cG9ydHMuYml0cyA9ICgod29yZCwgbXNiLCBwcm9wZXJ0eSkgPT4gbmV3IEJpdFN0cnVjdHVyZSh3b3JkLCBtc2IsIHByb3BlcnR5KSk7XG4vKiogRmFjdG9yeSBmb3Ige0BsaW5rIFNlcXVlbmNlfSB2YWx1ZXMuICovXG5leHBvcnRzLnNlcSA9ICgoZWxlbWVudExheW91dCwgY291bnQsIHByb3BlcnR5KSA9PiBuZXcgU2VxdWVuY2UoZWxlbWVudExheW91dCwgY291bnQsIHByb3BlcnR5KSk7XG4vKiogRmFjdG9yeSBmb3Ige0BsaW5rIFVuaW9ufSB2YWx1ZXMuICovXG5leHBvcnRzLnVuaW9uID0gKChkaXNjciwgZGVmYXVsdExheW91dCwgcHJvcGVydHkpID0+IG5ldyBVbmlvbihkaXNjciwgZGVmYXVsdExheW91dCwgcHJvcGVydHkpKTtcbi8qKiBGYWN0b3J5IGZvciB7QGxpbmsgVW5pb25MYXlvdXREaXNjcmltaW5hdG9yfSB2YWx1ZXMuICovXG5leHBvcnRzLnVuaW9uTGF5b3V0RGlzY3JpbWluYXRvciA9ICgobGF5b3V0LCBwcm9wZXJ0eSkgPT4gbmV3IFVuaW9uTGF5b3V0RGlzY3JpbWluYXRvcihsYXlvdXQsIHByb3BlcnR5KSk7XG4vKiogRmFjdG9yeSBmb3Ige0BsaW5rIEJsb2J9IHZhbHVlcy4gKi9cbmV4cG9ydHMuYmxvYiA9ICgobGVuZ3RoLCBwcm9wZXJ0eSkgPT4gbmV3IEJsb2IobGVuZ3RoLCBwcm9wZXJ0eSkpO1xuLyoqIEZhY3RvcnkgZm9yIHtAbGluayBDU3RyaW5nfSB2YWx1ZXMuICovXG5leHBvcnRzLmNzdHIgPSAoKHByb3BlcnR5KSA9PiBuZXcgQ1N0cmluZyhwcm9wZXJ0eSkpO1xuLyoqIEZhY3RvcnkgZm9yIHtAbGluayBVVEY4fSB2YWx1ZXMuICovXG5leHBvcnRzLnV0ZjggPSAoKG1heFNwYW4sIHByb3BlcnR5KSA9PiBuZXcgVVRGOChtYXhTcGFuLCBwcm9wZXJ0eSkpO1xuLyoqIEZhY3RvcnkgZm9yIHtAbGluayBDb25zdGFudH0gdmFsdWVzLiAqL1xuZXhwb3J0cy5jb25zdGFudCA9ICgodmFsdWUsIHByb3BlcnR5KSA9PiBuZXcgQ29uc3RhbnQodmFsdWUsIHByb3BlcnR5KSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1MYXlvdXQuanMubWFwIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiczE2IiwiczgiLCJudTY0YmUiLCJ1NDhiZSIsInU0MGJlIiwidTMyYmUiLCJ1MjRiZSIsInUxNmJlIiwibnU2NCIsInU0OCIsInU0MCIsInUzMiIsInUyNCIsInUxNiIsInU4Iiwib2Zmc2V0IiwiZ3JlZWR5IiwiQ29uc3RhbnQiLCJVVEY4IiwiQ1N0cmluZyIsIkJsb2IiLCJCb29sZWFuIiwiQml0RmllbGQiLCJCaXRTdHJ1Y3R1cmUiLCJWYXJpYW50TGF5b3V0IiwiVW5pb24iLCJVbmlvbkxheW91dERpc2NyaW1pbmF0b3IiLCJVbmlvbkRpc2NyaW1pbmF0b3IiLCJTdHJ1Y3R1cmUiLCJTZXF1ZW5jZSIsIkRvdWJsZUJFIiwiRG91YmxlIiwiRmxvYXRCRSIsIkZsb2F0IiwiTmVhckludDY0QkUiLCJOZWFySW50NjQiLCJOZWFyVUludDY0QkUiLCJOZWFyVUludDY0IiwiSW50QkUiLCJJbnQiLCJVSW50QkUiLCJVSW50IiwiT2Zmc2V0TGF5b3V0IiwiR3JlZWR5Q291bnQiLCJFeHRlcm5hbExheW91dCIsImJpbmRDb25zdHJ1Y3RvckxheW91dCIsIm5hbWVXaXRoUHJvcGVydHkiLCJMYXlvdXQiLCJ1aW50OEFycmF5VG9CdWZmZXIiLCJjaGVja1VpbnQ4QXJyYXkiLCJjb25zdGFudCIsInV0ZjgiLCJjc3RyIiwiYmxvYiIsInVuaW9uTGF5b3V0RGlzY3JpbWluYXRvciIsInVuaW9uIiwic2VxIiwiYml0cyIsInN0cnVjdCIsImY2NGJlIiwiZjY0IiwiZjMyYmUiLCJmMzIiLCJuczY0YmUiLCJzNDhiZSIsInM0MGJlIiwiczMyYmUiLCJzMjRiZSIsInMxNmJlIiwibnM2NCIsInM0OCIsInM0MCIsInMzMiIsInMyNCIsImJ1ZmZlcl8xIiwicmVxdWlyZSIsImIiLCJVaW50OEFycmF5IiwiVHlwZUVycm9yIiwiQnVmZmVyIiwiZnJvbSIsImJ1ZmZlciIsImJ5dGVPZmZzZXQiLCJsZW5ndGgiLCJjb25zdHJ1Y3RvciIsInNwYW4iLCJwcm9wZXJ0eSIsIk51bWJlciIsImlzSW50ZWdlciIsIm1ha2VEZXN0aW5hdGlvbk9iamVjdCIsImdldFNwYW4iLCJSYW5nZUVycm9yIiwicmVwbGljYXRlIiwicnYiLCJjcmVhdGUiLCJwcm90b3R5cGUiLCJhc3NpZ24iLCJmcm9tQXJyYXkiLCJ2YWx1ZXMiLCJ1bmRlZmluZWQiLCJuYW1lIiwibG8iLCJDbGFzcyIsImxheW91dCIsImhhc093blByb3BlcnR5IiwiY2FsbCIsIkVycm9yIiwibGF5b3V0XyIsImJvdW5kQ29uc3RydWN0b3JfIiwiZW5jb2RlIiwid3JpdGFibGUiLCJkZWNvZGUiLCJpc0NvdW50IiwiZWxlbWVudFNwYW4iLCJyZW0iLCJNYXRoIiwiZmxvb3IiLCJzcmMiLCJyZWFkVUludExFIiwid3JpdGVVSW50TEUiLCJyZWFkVUludEJFIiwid3JpdGVVSW50QkUiLCJyZWFkSW50TEUiLCJ3cml0ZUludExFIiwicmVhZEludEJFIiwid3JpdGVJbnRCRSIsIlYyRTMyIiwicG93IiwiZGl2bW9kSW50NjQiLCJoaTMyIiwibG8zMiIsInJvdW5kZWRJbnQ2NCIsInJlYWRVSW50MzJMRSIsInNwbGl0Iiwid3JpdGVVSW50MzJMRSIsInJlYWRVSW50MzJCRSIsIndyaXRlVUludDMyQkUiLCJyZWFkSW50MzJMRSIsIndyaXRlSW50MzJMRSIsInJlYWRJbnQzMkJFIiwid3JpdGVJbnQzMkJFIiwicmVhZEZsb2F0TEUiLCJ3cml0ZUZsb2F0TEUiLCJyZWFkRmxvYXRCRSIsIndyaXRlRmxvYXRCRSIsInJlYWREb3VibGVMRSIsIndyaXRlRG91YmxlTEUiLCJyZWFkRG91YmxlQkUiLCJ3cml0ZURvdWJsZUJFIiwiZWxlbWVudExheW91dCIsImNvdW50IiwiaWR4IiwiaSIsInB1c2giLCJlbG8iLCJyZWR1Y2UiLCJ2IiwiZmllbGRzIiwiZGVjb2RlUHJlZml4ZXMiLCJBcnJheSIsImlzQXJyYXkiLCJhY2MiLCJmZCIsImUiLCJmc3AiLCJkZXN0IiwiZmlyc3RPZmZzZXQiLCJsYXN0T2Zmc2V0IiwibGFzdFdyb3RlIiwiZnYiLCJzaGlmdCIsImxheW91dEZvciIsIm9mZnNldE9mIiwiZGlzY3IiLCJkZWZhdWx0TGF5b3V0IiwiZGlzY3JpbWluYXRvciIsInVzZXNQcmVmaXhEaXNjcmltaW5hdG9yIiwicmVnaXN0cnkiLCJib3VuZEdldFNvdXJjZVZhcmlhbnQiLCJkZWZhdWx0R2V0U291cmNlVmFyaWFudCIsImJpbmQiLCJnZXRTb3VyY2VWYXJpYW50IiwiY29uZmlnR2V0U291cmNlVmFyaWFudCIsImdzdiIsInZsbyIsImdldFZhcmlhbnQiLCJ0YWciLCJkbG8iLCJjbG8iLCJjb250ZW50T2Zmc2V0IiwiYWRkVmFyaWFudCIsInZhcmlhbnQiLCJ2YiIsImZpeEJpdHdpc2VSZXN1bHQiLCJ3b3JkIiwibXNiIiwiX3BhY2tlZFNldFZhbHVlIiwiX3BhY2tlZEdldFZhbHVlIiwiYWRkRmllbGQiLCJiZiIsImFkZEJvb2xlYW4iLCJmaWVsZEZvciIsImNvbnRhaW5lciIsInRvdGFsQml0cyIsInVzZWRCaXRzIiwic3VtIiwidmFsdWVNYXNrIiwic3RhcnQiLCJ3b3JkTWFzayIsIndvcmRWYWx1ZSIsInNsaWNlIiwic3JjQnVmZmVyIiwid3JpdGUiLCJ0b1N0cmluZyIsIlN0cmluZyIsInNyY2IiLCJjb3B5IiwibWF4U3BhbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/../anchor/node_modules/@solana/buffer-layout/lib/Layout.js\n");

/***/ }),

/***/ "(ssr)/../anchor/node_modules/@solana/web3.js/lib/index.esm.js":
/*!***************************************************************!*\
  !*** ../anchor/node_modules/@solana/web3.js/lib/index.esm.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Account: () => (/* binding */ Account),\n/* harmony export */   AddressLookupTableAccount: () => (/* binding */ AddressLookupTableAccount),\n/* harmony export */   AddressLookupTableInstruction: () => (/* binding */ AddressLookupTableInstruction),\n/* harmony export */   AddressLookupTableProgram: () => (/* binding */ AddressLookupTableProgram),\n/* harmony export */   Authorized: () => (/* binding */ Authorized),\n/* harmony export */   BLOCKHASH_CACHE_TIMEOUT_MS: () => (/* binding */ BLOCKHASH_CACHE_TIMEOUT_MS),\n/* harmony export */   BPF_LOADER_DEPRECATED_PROGRAM_ID: () => (/* binding */ BPF_LOADER_DEPRECATED_PROGRAM_ID),\n/* harmony export */   BPF_LOADER_PROGRAM_ID: () => (/* binding */ BPF_LOADER_PROGRAM_ID),\n/* harmony export */   BpfLoader: () => (/* binding */ BpfLoader),\n/* harmony export */   COMPUTE_BUDGET_INSTRUCTION_LAYOUTS: () => (/* binding */ COMPUTE_BUDGET_INSTRUCTION_LAYOUTS),\n/* harmony export */   ComputeBudgetInstruction: () => (/* binding */ ComputeBudgetInstruction),\n/* harmony export */   ComputeBudgetProgram: () => (/* binding */ ComputeBudgetProgram),\n/* harmony export */   Connection: () => (/* binding */ Connection),\n/* harmony export */   Ed25519Program: () => (/* binding */ Ed25519Program),\n/* harmony export */   Enum: () => (/* binding */ Enum),\n/* harmony export */   EpochSchedule: () => (/* binding */ EpochSchedule),\n/* harmony export */   FeeCalculatorLayout: () => (/* binding */ FeeCalculatorLayout),\n/* harmony export */   Keypair: () => (/* binding */ Keypair),\n/* harmony export */   LAMPORTS_PER_SOL: () => (/* binding */ LAMPORTS_PER_SOL),\n/* harmony export */   LOOKUP_TABLE_INSTRUCTION_LAYOUTS: () => (/* binding */ LOOKUP_TABLE_INSTRUCTION_LAYOUTS),\n/* harmony export */   Loader: () => (/* binding */ Loader),\n/* harmony export */   Lockup: () => (/* binding */ Lockup),\n/* harmony export */   MAX_SEED_LENGTH: () => (/* binding */ MAX_SEED_LENGTH),\n/* harmony export */   Message: () => (/* binding */ Message),\n/* harmony export */   MessageAccountKeys: () => (/* binding */ MessageAccountKeys),\n/* harmony export */   MessageV0: () => (/* binding */ MessageV0),\n/* harmony export */   NONCE_ACCOUNT_LENGTH: () => (/* binding */ NONCE_ACCOUNT_LENGTH),\n/* harmony export */   NonceAccount: () => (/* binding */ NonceAccount),\n/* harmony export */   PACKET_DATA_SIZE: () => (/* binding */ PACKET_DATA_SIZE),\n/* harmony export */   PUBLIC_KEY_LENGTH: () => (/* binding */ PUBLIC_KEY_LENGTH),\n/* harmony export */   PublicKey: () => (/* binding */ PublicKey),\n/* harmony export */   SIGNATURE_LENGTH_IN_BYTES: () => (/* binding */ SIGNATURE_LENGTH_IN_BYTES),\n/* harmony export */   SOLANA_SCHEMA: () => (/* binding */ SOLANA_SCHEMA),\n/* harmony export */   STAKE_CONFIG_ID: () => (/* binding */ STAKE_CONFIG_ID),\n/* harmony export */   STAKE_INSTRUCTION_LAYOUTS: () => (/* binding */ STAKE_INSTRUCTION_LAYOUTS),\n/* harmony export */   SYSTEM_INSTRUCTION_LAYOUTS: () => (/* binding */ SYSTEM_INSTRUCTION_LAYOUTS),\n/* harmony export */   SYSVAR_CLOCK_PUBKEY: () => (/* binding */ SYSVAR_CLOCK_PUBKEY),\n/* harmony export */   SYSVAR_EPOCH_SCHEDULE_PUBKEY: () => (/* binding */ SYSVAR_EPOCH_SCHEDULE_PUBKEY),\n/* harmony export */   SYSVAR_INSTRUCTIONS_PUBKEY: () => (/* binding */ SYSVAR_INSTRUCTIONS_PUBKEY),\n/* harmony export */   SYSVAR_RECENT_BLOCKHASHES_PUBKEY: () => (/* binding */ SYSVAR_RECENT_BLOCKHASHES_PUBKEY),\n/* harmony export */   SYSVAR_RENT_PUBKEY: () => (/* binding */ SYSVAR_RENT_PUBKEY),\n/* harmony export */   SYSVAR_REWARDS_PUBKEY: () => (/* binding */ SYSVAR_REWARDS_PUBKEY),\n/* harmony export */   SYSVAR_SLOT_HASHES_PUBKEY: () => (/* binding */ SYSVAR_SLOT_HASHES_PUBKEY),\n/* harmony export */   SYSVAR_SLOT_HISTORY_PUBKEY: () => (/* binding */ SYSVAR_SLOT_HISTORY_PUBKEY),\n/* harmony export */   SYSVAR_STAKE_HISTORY_PUBKEY: () => (/* binding */ SYSVAR_STAKE_HISTORY_PUBKEY),\n/* harmony export */   Secp256k1Program: () => (/* binding */ Secp256k1Program),\n/* harmony export */   SendTransactionError: () => (/* binding */ SendTransactionError),\n/* harmony export */   SolanaJSONRPCError: () => (/* binding */ SolanaJSONRPCError),\n/* harmony export */   SolanaJSONRPCErrorCode: () => (/* binding */ SolanaJSONRPCErrorCode),\n/* harmony export */   StakeAuthorizationLayout: () => (/* binding */ StakeAuthorizationLayout),\n/* harmony export */   StakeInstruction: () => (/* binding */ StakeInstruction),\n/* harmony export */   StakeProgram: () => (/* binding */ StakeProgram),\n/* harmony export */   Struct: () => (/* binding */ Struct),\n/* harmony export */   SystemInstruction: () => (/* binding */ SystemInstruction),\n/* harmony export */   SystemProgram: () => (/* binding */ SystemProgram),\n/* harmony export */   Transaction: () => (/* binding */ Transaction),\n/* harmony export */   TransactionExpiredBlockheightExceededError: () => (/* binding */ TransactionExpiredBlockheightExceededError),\n/* harmony export */   TransactionExpiredNonceInvalidError: () => (/* binding */ TransactionExpiredNonceInvalidError),\n/* harmony export */   TransactionExpiredTimeoutError: () => (/* binding */ TransactionExpiredTimeoutError),\n/* harmony export */   TransactionInstruction: () => (/* binding */ TransactionInstruction),\n/* harmony export */   TransactionMessage: () => (/* binding */ TransactionMessage),\n/* harmony export */   TransactionStatus: () => (/* binding */ TransactionStatus),\n/* harmony export */   VALIDATOR_INFO_KEY: () => (/* binding */ VALIDATOR_INFO_KEY),\n/* harmony export */   VERSION_PREFIX_MASK: () => (/* binding */ VERSION_PREFIX_MASK),\n/* harmony export */   VOTE_PROGRAM_ID: () => (/* binding */ VOTE_PROGRAM_ID),\n/* harmony export */   ValidatorInfo: () => (/* binding */ ValidatorInfo),\n/* harmony export */   VersionedMessage: () => (/* binding */ VersionedMessage),\n/* harmony export */   VersionedTransaction: () => (/* binding */ VersionedTransaction),\n/* harmony export */   VoteAccount: () => (/* binding */ VoteAccount),\n/* harmony export */   VoteAuthorizationLayout: () => (/* binding */ VoteAuthorizationLayout),\n/* harmony export */   VoteInit: () => (/* binding */ VoteInit),\n/* harmony export */   VoteInstruction: () => (/* binding */ VoteInstruction),\n/* harmony export */   VoteProgram: () => (/* binding */ VoteProgram),\n/* harmony export */   clusterApiUrl: () => (/* binding */ clusterApiUrl),\n/* harmony export */   sendAndConfirmRawTransaction: () => (/* binding */ sendAndConfirmRawTransaction),\n/* harmony export */   sendAndConfirmTransaction: () => (/* binding */ sendAndConfirmTransaction)\n/* harmony export */ });\n/* harmony import */ var buffer__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! buffer */ \"buffer\");\n/* harmony import */ var buffer__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(buffer__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _noble_curves_ed25519__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! @noble/curves/ed25519 */ \"(ssr)/../anchor/node_modules/@noble/curves/esm/ed25519.js\");\n/* harmony import */ var bn_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! bn.js */ \"(ssr)/../anchor/node_modules/bn.js/lib/bn.js\");\n/* harmony import */ var bn_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(bn_js__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var bs58__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! bs58 */ \"(ssr)/../anchor/node_modules/bs58/index.js\");\n/* harmony import */ var bs58__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(bs58__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var _noble_hashes_sha256__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! @noble/hashes/sha256 */ \"(ssr)/../anchor/node_modules/@noble/hashes/esm/sha256.js\");\n/* harmony import */ var borsh__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! borsh */ \"(ssr)/../anchor/node_modules/borsh/lib/index.js\");\n/* harmony import */ var borsh__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(borsh__WEBPACK_IMPORTED_MODULE_3__);\n/* harmony import */ var _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @solana/buffer-layout */ \"(ssr)/../anchor/node_modules/@solana/buffer-layout/lib/Layout.js\");\n/* harmony import */ var bigint_buffer__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! bigint-buffer */ \"(ssr)/../anchor/node_modules/bigint-buffer/dist/node.js\");\n/* harmony import */ var util__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! util */ \"util\");\n/* harmony import */ var util__WEBPACK_IMPORTED_MODULE_6___default = /*#__PURE__*/__webpack_require__.n(util__WEBPACK_IMPORTED_MODULE_6__);\n/* harmony import */ var http__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! http */ \"http\");\n/* harmony import */ var http__WEBPACK_IMPORTED_MODULE_7___default = /*#__PURE__*/__webpack_require__.n(http__WEBPACK_IMPORTED_MODULE_7__);\n/* harmony import */ var https__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! https */ \"https\");\n/* harmony import */ var https__WEBPACK_IMPORTED_MODULE_8___default = /*#__PURE__*/__webpack_require__.n(https__WEBPACK_IMPORTED_MODULE_8__);\n/* harmony import */ var superstruct__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! superstruct */ \"(ssr)/../anchor/node_modules/@solana/web3.js/node_modules/superstruct/dist/index.mjs\");\n/* harmony import */ var jayson_lib_client_browser__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! jayson/lib/client/browser */ \"(ssr)/../anchor/node_modules/jayson/lib/client/browser/index.js\");\n/* harmony import */ var jayson_lib_client_browser__WEBPACK_IMPORTED_MODULE_9___default = /*#__PURE__*/__webpack_require__.n(jayson_lib_client_browser__WEBPACK_IMPORTED_MODULE_9__);\n/* harmony import */ var node_fetch__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! node-fetch */ \"(ssr)/../anchor/node_modules/node-fetch/lib/index.mjs\");\n/* harmony import */ var rpc_websockets_dist_lib_client_cjs__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! rpc-websockets/dist/lib/client.cjs */ \"(ssr)/../anchor/node_modules/rpc-websockets/dist/lib/client.cjs\");\n/* harmony import */ var rpc_websockets_dist_lib_client_websocket_cjs__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! rpc-websockets/dist/lib/client/websocket.cjs */ \"(ssr)/../anchor/node_modules/rpc-websockets/dist/lib/client/websocket.cjs\");\n/* harmony import */ var rpc_websockets_dist_lib_client_websocket_cjs__WEBPACK_IMPORTED_MODULE_12___default = /*#__PURE__*/__webpack_require__.n(rpc_websockets_dist_lib_client_websocket_cjs__WEBPACK_IMPORTED_MODULE_12__);\n/* harmony import */ var _noble_hashes_sha3__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! @noble/hashes/sha3 */ \"(ssr)/../anchor/node_modules/@noble/hashes/esm/sha3.js\");\n/* harmony import */ var _noble_curves_secp256k1__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! @noble/curves/secp256k1 */ \"(ssr)/../anchor/node_modules/@noble/curves/esm/secp256k1.js\");\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n/**\n * A 64 byte secret key, the first 32 bytes of which is the\n * private scalar and the last 32 bytes is the public key.\n * Read more: https://blog.mozilla.org/warner/2011/11/29/ed25519-keys/\n */ /**\n * Ed25519 Keypair\n */ const generatePrivateKey = _noble_curves_ed25519__WEBPACK_IMPORTED_MODULE_13__.ed25519.utils.randomPrivateKey;\nconst generateKeypair = ()=>{\n    const privateScalar = _noble_curves_ed25519__WEBPACK_IMPORTED_MODULE_13__.ed25519.utils.randomPrivateKey();\n    const publicKey = getPublicKey(privateScalar);\n    const secretKey = new Uint8Array(64);\n    secretKey.set(privateScalar);\n    secretKey.set(publicKey, 32);\n    return {\n        publicKey,\n        secretKey\n    };\n};\nconst getPublicKey = _noble_curves_ed25519__WEBPACK_IMPORTED_MODULE_13__.ed25519.getPublicKey;\nfunction isOnCurve(publicKey) {\n    try {\n        _noble_curves_ed25519__WEBPACK_IMPORTED_MODULE_13__.ed25519.ExtendedPoint.fromHex(publicKey);\n        return true;\n    } catch  {\n        return false;\n    }\n}\nconst sign = (message, secretKey)=>_noble_curves_ed25519__WEBPACK_IMPORTED_MODULE_13__.ed25519.sign(message, secretKey.slice(0, 32));\nconst verify = _noble_curves_ed25519__WEBPACK_IMPORTED_MODULE_13__.ed25519.verify;\nconst toBuffer = (arr)=>{\n    if (buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.isBuffer(arr)) {\n        return arr;\n    } else if (arr instanceof Uint8Array) {\n        return buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.from(arr.buffer, arr.byteOffset, arr.byteLength);\n    } else {\n        return buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.from(arr);\n    }\n};\n// Class wrapping a plain object\nclass Struct {\n    constructor(properties){\n        Object.assign(this, properties);\n    }\n    encode() {\n        return buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.from((0,borsh__WEBPACK_IMPORTED_MODULE_3__.serialize)(SOLANA_SCHEMA, this));\n    }\n    static decode(data) {\n        return (0,borsh__WEBPACK_IMPORTED_MODULE_3__.deserialize)(SOLANA_SCHEMA, this, data);\n    }\n    static decodeUnchecked(data) {\n        return (0,borsh__WEBPACK_IMPORTED_MODULE_3__.deserializeUnchecked)(SOLANA_SCHEMA, this, data);\n    }\n}\n// Class representing a Rust-compatible enum, since enums are only strings or\n// numbers in pure JS\nclass Enum extends Struct {\n    constructor(properties){\n        super(properties);\n        this.enum = \"\";\n        if (Object.keys(properties).length !== 1) {\n            throw new Error(\"Enum can only take single value\");\n        }\n        Object.keys(properties).map((key)=>{\n            this.enum = key;\n        });\n    }\n}\nconst SOLANA_SCHEMA = new Map();\nvar _PublicKey;\n/**\n * Maximum length of derived pubkey seed\n */ const MAX_SEED_LENGTH = 32;\n/**\n * Size of public key in bytes\n */ const PUBLIC_KEY_LENGTH = 32;\n/**\n * Value to be converted into public key\n */ /**\n * JSON object representation of PublicKey class\n */ function isPublicKeyData(value) {\n    return value._bn !== undefined;\n}\n// local counter used by PublicKey.unique()\nlet uniquePublicKeyCounter = 1;\n/**\n * A public key\n */ class PublicKey extends Struct {\n    /**\n   * Create a new PublicKey object\n   * @param value ed25519 public key as buffer or base-58 encoded string\n   */ constructor(value){\n        super({});\n        /** @internal */ this._bn = void 0;\n        if (isPublicKeyData(value)) {\n            this._bn = value._bn;\n        } else {\n            if (typeof value === \"string\") {\n                // assume base 58 encoding by default\n                const decoded = bs58__WEBPACK_IMPORTED_MODULE_2___default().decode(value);\n                if (decoded.length != PUBLIC_KEY_LENGTH) {\n                    throw new Error(`Invalid public key input`);\n                }\n                this._bn = new (bn_js__WEBPACK_IMPORTED_MODULE_1___default())(decoded);\n            } else {\n                this._bn = new (bn_js__WEBPACK_IMPORTED_MODULE_1___default())(value);\n            }\n            if (this._bn.byteLength() > PUBLIC_KEY_LENGTH) {\n                throw new Error(`Invalid public key input`);\n            }\n        }\n    }\n    /**\n   * Returns a unique PublicKey for tests and benchmarks using a counter\n   */ static unique() {\n        const key = new PublicKey(uniquePublicKeyCounter);\n        uniquePublicKeyCounter += 1;\n        return new PublicKey(key.toBuffer());\n    }\n    /**\n   * Default public key value. The base58-encoded string representation is all ones (as seen below)\n   * The underlying BN number is 32 bytes that are all zeros\n   */ /**\n   * Checks if two publicKeys are equal\n   */ equals(publicKey) {\n        return this._bn.eq(publicKey._bn);\n    }\n    /**\n   * Return the base-58 representation of the public key\n   */ toBase58() {\n        return bs58__WEBPACK_IMPORTED_MODULE_2___default().encode(this.toBytes());\n    }\n    toJSON() {\n        return this.toBase58();\n    }\n    /**\n   * Return the byte array representation of the public key in big endian\n   */ toBytes() {\n        const buf = this.toBuffer();\n        return new Uint8Array(buf.buffer, buf.byteOffset, buf.byteLength);\n    }\n    /**\n   * Return the Buffer representation of the public key in big endian\n   */ toBuffer() {\n        const b = this._bn.toArrayLike(buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer);\n        if (b.length === PUBLIC_KEY_LENGTH) {\n            return b;\n        }\n        const zeroPad = buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.alloc(32);\n        b.copy(zeroPad, 32 - b.length);\n        return zeroPad;\n    }\n    get [Symbol.toStringTag]() {\n        return `PublicKey(${this.toString()})`;\n    }\n    /**\n   * Return the base-58 representation of the public key\n   */ toString() {\n        return this.toBase58();\n    }\n    /**\n   * Derive a public key from another key, a seed, and a program ID.\n   * The program ID will also serve as the owner of the public key, giving\n   * it permission to write data to the account.\n   */ /* eslint-disable require-await */ static async createWithSeed(fromPublicKey, seed, programId) {\n        const buffer = buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.concat([\n            fromPublicKey.toBuffer(),\n            buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.from(seed),\n            programId.toBuffer()\n        ]);\n        const publicKeyBytes = (0,_noble_hashes_sha256__WEBPACK_IMPORTED_MODULE_14__.sha256)(buffer);\n        return new PublicKey(publicKeyBytes);\n    }\n    /**\n   * Derive a program address from seeds and a program ID.\n   */ /* eslint-disable require-await */ static createProgramAddressSync(seeds, programId) {\n        let buffer = buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.alloc(0);\n        seeds.forEach(function(seed) {\n            if (seed.length > MAX_SEED_LENGTH) {\n                throw new TypeError(`Max seed length exceeded`);\n            }\n            buffer = buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.concat([\n                buffer,\n                toBuffer(seed)\n            ]);\n        });\n        buffer = buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.concat([\n            buffer,\n            programId.toBuffer(),\n            buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.from(\"ProgramDerivedAddress\")\n        ]);\n        const publicKeyBytes = (0,_noble_hashes_sha256__WEBPACK_IMPORTED_MODULE_14__.sha256)(buffer);\n        if (isOnCurve(publicKeyBytes)) {\n            throw new Error(`Invalid seeds, address must fall off the curve`);\n        }\n        return new PublicKey(publicKeyBytes);\n    }\n    /**\n   * Async version of createProgramAddressSync\n   * For backwards compatibility\n   *\n   * @deprecated Use {@link createProgramAddressSync} instead\n   */ /* eslint-disable require-await */ static async createProgramAddress(seeds, programId) {\n        return this.createProgramAddressSync(seeds, programId);\n    }\n    /**\n   * Find a valid program address\n   *\n   * Valid program addresses must fall off the ed25519 curve.  This function\n   * iterates a nonce until it finds one that when combined with the seeds\n   * results in a valid program address.\n   */ static findProgramAddressSync(seeds, programId) {\n        let nonce = 255;\n        let address;\n        while(nonce != 0){\n            try {\n                const seedsWithNonce = seeds.concat(buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.from([\n                    nonce\n                ]));\n                address = this.createProgramAddressSync(seedsWithNonce, programId);\n            } catch (err) {\n                if (err instanceof TypeError) {\n                    throw err;\n                }\n                nonce--;\n                continue;\n            }\n            return [\n                address,\n                nonce\n            ];\n        }\n        throw new Error(`Unable to find a viable program address nonce`);\n    }\n    /**\n   * Async version of findProgramAddressSync\n   * For backwards compatibility\n   *\n   * @deprecated Use {@link findProgramAddressSync} instead\n   */ static async findProgramAddress(seeds, programId) {\n        return this.findProgramAddressSync(seeds, programId);\n    }\n    /**\n   * Check that a pubkey is on the ed25519 curve.\n   */ static isOnCurve(pubkeyData) {\n        const pubkey = new PublicKey(pubkeyData);\n        return isOnCurve(pubkey.toBytes());\n    }\n}\n_PublicKey = PublicKey;\nPublicKey.default = new _PublicKey(\"11111111111111111111111111111111\");\nSOLANA_SCHEMA.set(PublicKey, {\n    kind: \"struct\",\n    fields: [\n        [\n            \"_bn\",\n            \"u256\"\n        ]\n    ]\n});\n/**\n * An account key pair (public and secret keys).\n *\n * @deprecated since v1.10.0, please use {@link Keypair} instead.\n */ class Account {\n    /**\n   * Create a new Account object\n   *\n   * If the secretKey parameter is not provided a new key pair is randomly\n   * created for the account\n   *\n   * @param secretKey Secret key for the account\n   */ constructor(secretKey){\n        /** @internal */ this._publicKey = void 0;\n        /** @internal */ this._secretKey = void 0;\n        if (secretKey) {\n            const secretKeyBuffer = toBuffer(secretKey);\n            if (secretKey.length !== 64) {\n                throw new Error(\"bad secret key size\");\n            }\n            this._publicKey = secretKeyBuffer.slice(32, 64);\n            this._secretKey = secretKeyBuffer.slice(0, 32);\n        } else {\n            this._secretKey = toBuffer(generatePrivateKey());\n            this._publicKey = toBuffer(getPublicKey(this._secretKey));\n        }\n    }\n    /**\n   * The public key for this account\n   */ get publicKey() {\n        return new PublicKey(this._publicKey);\n    }\n    /**\n   * The **unencrypted** secret key for this account. The first 32 bytes\n   * is the private scalar and the last 32 bytes is the public key.\n   * Read more: https://blog.mozilla.org/warner/2011/11/29/ed25519-keys/\n   */ get secretKey() {\n        return buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.concat([\n            this._secretKey,\n            this._publicKey\n        ], 64);\n    }\n}\nconst BPF_LOADER_DEPRECATED_PROGRAM_ID = new PublicKey(\"BPFLoader1111111111111111111111111111111111\");\n/**\n * Maximum over-the-wire size of a Transaction\n *\n * 1280 is IPv6 minimum MTU\n * 40 bytes is the size of the IPv6 header\n * 8 bytes is the size of the fragment header\n */ const PACKET_DATA_SIZE = 1280 - 40 - 8;\nconst VERSION_PREFIX_MASK = 0x7f;\nconst SIGNATURE_LENGTH_IN_BYTES = 64;\nclass TransactionExpiredBlockheightExceededError extends Error {\n    constructor(signature){\n        super(`Signature ${signature} has expired: block height exceeded.`);\n        this.signature = void 0;\n        this.signature = signature;\n    }\n}\nObject.defineProperty(TransactionExpiredBlockheightExceededError.prototype, \"name\", {\n    value: \"TransactionExpiredBlockheightExceededError\"\n});\nclass TransactionExpiredTimeoutError extends Error {\n    constructor(signature, timeoutSeconds){\n        super(`Transaction was not confirmed in ${timeoutSeconds.toFixed(2)} seconds. It is ` + \"unknown if it succeeded or failed. Check signature \" + `${signature} using the Solana Explorer or CLI tools.`);\n        this.signature = void 0;\n        this.signature = signature;\n    }\n}\nObject.defineProperty(TransactionExpiredTimeoutError.prototype, \"name\", {\n    value: \"TransactionExpiredTimeoutError\"\n});\nclass TransactionExpiredNonceInvalidError extends Error {\n    constructor(signature){\n        super(`Signature ${signature} has expired: the nonce is no longer valid.`);\n        this.signature = void 0;\n        this.signature = signature;\n    }\n}\nObject.defineProperty(TransactionExpiredNonceInvalidError.prototype, \"name\", {\n    value: \"TransactionExpiredNonceInvalidError\"\n});\nclass MessageAccountKeys {\n    constructor(staticAccountKeys, accountKeysFromLookups){\n        this.staticAccountKeys = void 0;\n        this.accountKeysFromLookups = void 0;\n        this.staticAccountKeys = staticAccountKeys;\n        this.accountKeysFromLookups = accountKeysFromLookups;\n    }\n    keySegments() {\n        const keySegments = [\n            this.staticAccountKeys\n        ];\n        if (this.accountKeysFromLookups) {\n            keySegments.push(this.accountKeysFromLookups.writable);\n            keySegments.push(this.accountKeysFromLookups.readonly);\n        }\n        return keySegments;\n    }\n    get(index) {\n        for (const keySegment of this.keySegments()){\n            if (index < keySegment.length) {\n                return keySegment[index];\n            } else {\n                index -= keySegment.length;\n            }\n        }\n        return;\n    }\n    get length() {\n        return this.keySegments().flat().length;\n    }\n    compileInstructions(instructions) {\n        // Bail early if any account indexes would overflow a u8\n        const U8_MAX = 255;\n        if (this.length > U8_MAX + 1) {\n            throw new Error(\"Account index overflow encountered during compilation\");\n        }\n        const keyIndexMap = new Map();\n        this.keySegments().flat().forEach((key, index)=>{\n            keyIndexMap.set(key.toBase58(), index);\n        });\n        const findKeyIndex = (key)=>{\n            const keyIndex = keyIndexMap.get(key.toBase58());\n            if (keyIndex === undefined) throw new Error(\"Encountered an unknown instruction account key during compilation\");\n            return keyIndex;\n        };\n        return instructions.map((instruction)=>{\n            return {\n                programIdIndex: findKeyIndex(instruction.programId),\n                accountKeyIndexes: instruction.keys.map((meta)=>findKeyIndex(meta.pubkey)),\n                data: instruction.data\n            };\n        });\n    }\n}\n/**\n * Layout for a public key\n */ const publicKey = (property = \"publicKey\")=>{\n    return _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.blob(32, property);\n};\n/**\n * Layout for a signature\n */ const signature = (property = \"signature\")=>{\n    return _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.blob(64, property);\n};\n/**\n * Layout for a Rust String type\n */ const rustString = (property = \"string\")=>{\n    const rsl = _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.struct([\n        _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u32(\"length\"),\n        _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u32(\"lengthPadding\"),\n        _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.blob(_solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.offset(_solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u32(), -8), \"chars\")\n    ], property);\n    const _decode = rsl.decode.bind(rsl);\n    const _encode = rsl.encode.bind(rsl);\n    const rslShim = rsl;\n    rslShim.decode = (b, offset)=>{\n        const data = _decode(b, offset);\n        return data[\"chars\"].toString();\n    };\n    rslShim.encode = (str, b, offset)=>{\n        const data = {\n            chars: buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.from(str, \"utf8\")\n        };\n        return _encode(data, b, offset);\n    };\n    rslShim.alloc = (str)=>{\n        return _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u32().span + _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u32().span + buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.from(str, \"utf8\").length;\n    };\n    return rslShim;\n};\n/**\n * Layout for an Authorized object\n */ const authorized = (property = \"authorized\")=>{\n    return _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.struct([\n        publicKey(\"staker\"),\n        publicKey(\"withdrawer\")\n    ], property);\n};\n/**\n * Layout for a Lockup object\n */ const lockup = (property = \"lockup\")=>{\n    return _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.struct([\n        _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.ns64(\"unixTimestamp\"),\n        _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.ns64(\"epoch\"),\n        publicKey(\"custodian\")\n    ], property);\n};\n/**\n *  Layout for a VoteInit object\n */ const voteInit = (property = \"voteInit\")=>{\n    return _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.struct([\n        publicKey(\"nodePubkey\"),\n        publicKey(\"authorizedVoter\"),\n        publicKey(\"authorizedWithdrawer\"),\n        _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u8(\"commission\")\n    ], property);\n};\n/**\n *  Layout for a VoteAuthorizeWithSeedArgs object\n */ const voteAuthorizeWithSeedArgs = (property = \"voteAuthorizeWithSeedArgs\")=>{\n    return _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.struct([\n        _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u32(\"voteAuthorizationType\"),\n        publicKey(\"currentAuthorityDerivedKeyOwnerPubkey\"),\n        rustString(\"currentAuthorityDerivedKeySeed\"),\n        publicKey(\"newAuthorized\")\n    ], property);\n};\nfunction getAlloc(type, fields) {\n    const getItemAlloc = (item)=>{\n        if (item.span >= 0) {\n            return item.span;\n        } else if (typeof item.alloc === \"function\") {\n            return item.alloc(fields[item.property]);\n        } else if (\"count\" in item && \"elementLayout\" in item) {\n            const field = fields[item.property];\n            if (Array.isArray(field)) {\n                return field.length * getItemAlloc(item.elementLayout);\n            }\n        } else if (\"fields\" in item) {\n            // This is a `Structure` whose size needs to be recursively measured.\n            return getAlloc({\n                layout: item\n            }, fields[item.property]);\n        }\n        // Couldn't determine allocated size of layout\n        return 0;\n    };\n    let alloc = 0;\n    type.layout.fields.forEach((item)=>{\n        alloc += getItemAlloc(item);\n    });\n    return alloc;\n}\nfunction decodeLength(bytes) {\n    let len = 0;\n    let size = 0;\n    for(;;){\n        let elem = bytes.shift();\n        len |= (elem & 0x7f) << size * 7;\n        size += 1;\n        if ((elem & 0x80) === 0) {\n            break;\n        }\n    }\n    return len;\n}\nfunction encodeLength(bytes, len) {\n    let rem_len = len;\n    for(;;){\n        let elem = rem_len & 0x7f;\n        rem_len >>= 7;\n        if (rem_len == 0) {\n            bytes.push(elem);\n            break;\n        } else {\n            elem |= 0x80;\n            bytes.push(elem);\n        }\n    }\n}\nfunction assert(condition, message) {\n    if (!condition) {\n        throw new Error(message || \"Assertion failed\");\n    }\n}\nclass CompiledKeys {\n    constructor(payer, keyMetaMap){\n        this.payer = void 0;\n        this.keyMetaMap = void 0;\n        this.payer = payer;\n        this.keyMetaMap = keyMetaMap;\n    }\n    static compile(instructions, payer) {\n        const keyMetaMap = new Map();\n        const getOrInsertDefault = (pubkey)=>{\n            const address = pubkey.toBase58();\n            let keyMeta = keyMetaMap.get(address);\n            if (keyMeta === undefined) {\n                keyMeta = {\n                    isSigner: false,\n                    isWritable: false,\n                    isInvoked: false\n                };\n                keyMetaMap.set(address, keyMeta);\n            }\n            return keyMeta;\n        };\n        const payerKeyMeta = getOrInsertDefault(payer);\n        payerKeyMeta.isSigner = true;\n        payerKeyMeta.isWritable = true;\n        for (const ix of instructions){\n            getOrInsertDefault(ix.programId).isInvoked = true;\n            for (const accountMeta of ix.keys){\n                const keyMeta = getOrInsertDefault(accountMeta.pubkey);\n                keyMeta.isSigner ||= accountMeta.isSigner;\n                keyMeta.isWritable ||= accountMeta.isWritable;\n            }\n        }\n        return new CompiledKeys(payer, keyMetaMap);\n    }\n    getMessageComponents() {\n        const mapEntries = [\n            ...this.keyMetaMap.entries()\n        ];\n        assert(mapEntries.length <= 256, \"Max static account keys length exceeded\");\n        const writableSigners = mapEntries.filter(([, meta])=>meta.isSigner && meta.isWritable);\n        const readonlySigners = mapEntries.filter(([, meta])=>meta.isSigner && !meta.isWritable);\n        const writableNonSigners = mapEntries.filter(([, meta])=>!meta.isSigner && meta.isWritable);\n        const readonlyNonSigners = mapEntries.filter(([, meta])=>!meta.isSigner && !meta.isWritable);\n        const header = {\n            numRequiredSignatures: writableSigners.length + readonlySigners.length,\n            numReadonlySignedAccounts: readonlySigners.length,\n            numReadonlyUnsignedAccounts: readonlyNonSigners.length\n        };\n        // sanity checks\n        {\n            assert(writableSigners.length > 0, \"Expected at least one writable signer key\");\n            const [payerAddress] = writableSigners[0];\n            assert(payerAddress === this.payer.toBase58(), \"Expected first writable signer key to be the fee payer\");\n        }\n        const staticAccountKeys = [\n            ...writableSigners.map(([address])=>new PublicKey(address)),\n            ...readonlySigners.map(([address])=>new PublicKey(address)),\n            ...writableNonSigners.map(([address])=>new PublicKey(address)),\n            ...readonlyNonSigners.map(([address])=>new PublicKey(address))\n        ];\n        return [\n            header,\n            staticAccountKeys\n        ];\n    }\n    extractTableLookup(lookupTable) {\n        const [writableIndexes, drainedWritableKeys] = this.drainKeysFoundInLookupTable(lookupTable.state.addresses, (keyMeta)=>!keyMeta.isSigner && !keyMeta.isInvoked && keyMeta.isWritable);\n        const [readonlyIndexes, drainedReadonlyKeys] = this.drainKeysFoundInLookupTable(lookupTable.state.addresses, (keyMeta)=>!keyMeta.isSigner && !keyMeta.isInvoked && !keyMeta.isWritable);\n        // Don't extract lookup if no keys were found\n        if (writableIndexes.length === 0 && readonlyIndexes.length === 0) {\n            return;\n        }\n        return [\n            {\n                accountKey: lookupTable.key,\n                writableIndexes,\n                readonlyIndexes\n            },\n            {\n                writable: drainedWritableKeys,\n                readonly: drainedReadonlyKeys\n            }\n        ];\n    }\n    /** @internal */ drainKeysFoundInLookupTable(lookupTableEntries, keyMetaFilter) {\n        const lookupTableIndexes = new Array();\n        const drainedKeys = new Array();\n        for (const [address, keyMeta] of this.keyMetaMap.entries()){\n            if (keyMetaFilter(keyMeta)) {\n                const key = new PublicKey(address);\n                const lookupTableIndex = lookupTableEntries.findIndex((entry)=>entry.equals(key));\n                if (lookupTableIndex >= 0) {\n                    assert(lookupTableIndex < 256, \"Max lookup table index exceeded\");\n                    lookupTableIndexes.push(lookupTableIndex);\n                    drainedKeys.push(key);\n                    this.keyMetaMap.delete(address);\n                }\n            }\n        }\n        return [\n            lookupTableIndexes,\n            drainedKeys\n        ];\n    }\n}\nconst END_OF_BUFFER_ERROR_MESSAGE = \"Reached end of buffer unexpectedly\";\n/**\n * Delegates to `Array#shift`, but throws if the array is zero-length.\n */ function guardedShift(byteArray) {\n    if (byteArray.length === 0) {\n        throw new Error(END_OF_BUFFER_ERROR_MESSAGE);\n    }\n    return byteArray.shift();\n}\n/**\n * Delegates to `Array#splice`, but throws if the section being spliced out extends past the end of\n * the array.\n */ function guardedSplice(byteArray, ...args) {\n    const [start] = args;\n    if (args.length === 2 // Implies that `deleteCount` was supplied\n     ? start + (args[1] ?? 0) > byteArray.length : start >= byteArray.length) {\n        throw new Error(END_OF_BUFFER_ERROR_MESSAGE);\n    }\n    return byteArray.splice(...args);\n}\n/**\n * An instruction to execute by a program\n *\n * @property {number} programIdIndex\n * @property {number[]} accounts\n * @property {string} data\n */ /**\n * Message constructor arguments\n */ /**\n * List of instructions to be processed atomically\n */ class Message {\n    constructor(args){\n        this.header = void 0;\n        this.accountKeys = void 0;\n        this.recentBlockhash = void 0;\n        this.instructions = void 0;\n        this.indexToProgramIds = new Map();\n        this.header = args.header;\n        this.accountKeys = args.accountKeys.map((account)=>new PublicKey(account));\n        this.recentBlockhash = args.recentBlockhash;\n        this.instructions = args.instructions;\n        this.instructions.forEach((ix)=>this.indexToProgramIds.set(ix.programIdIndex, this.accountKeys[ix.programIdIndex]));\n    }\n    get version() {\n        return \"legacy\";\n    }\n    get staticAccountKeys() {\n        return this.accountKeys;\n    }\n    get compiledInstructions() {\n        return this.instructions.map((ix)=>({\n                programIdIndex: ix.programIdIndex,\n                accountKeyIndexes: ix.accounts,\n                data: bs58__WEBPACK_IMPORTED_MODULE_2___default().decode(ix.data)\n            }));\n    }\n    get addressTableLookups() {\n        return [];\n    }\n    getAccountKeys() {\n        return new MessageAccountKeys(this.staticAccountKeys);\n    }\n    static compile(args) {\n        const compiledKeys = CompiledKeys.compile(args.instructions, args.payerKey);\n        const [header, staticAccountKeys] = compiledKeys.getMessageComponents();\n        const accountKeys = new MessageAccountKeys(staticAccountKeys);\n        const instructions = accountKeys.compileInstructions(args.instructions).map((ix)=>({\n                programIdIndex: ix.programIdIndex,\n                accounts: ix.accountKeyIndexes,\n                data: bs58__WEBPACK_IMPORTED_MODULE_2___default().encode(ix.data)\n            }));\n        return new Message({\n            header,\n            accountKeys: staticAccountKeys,\n            recentBlockhash: args.recentBlockhash,\n            instructions\n        });\n    }\n    isAccountSigner(index) {\n        return index < this.header.numRequiredSignatures;\n    }\n    isAccountWritable(index) {\n        const numSignedAccounts = this.header.numRequiredSignatures;\n        if (index >= this.header.numRequiredSignatures) {\n            const unsignedAccountIndex = index - numSignedAccounts;\n            const numUnsignedAccounts = this.accountKeys.length - numSignedAccounts;\n            const numWritableUnsignedAccounts = numUnsignedAccounts - this.header.numReadonlyUnsignedAccounts;\n            return unsignedAccountIndex < numWritableUnsignedAccounts;\n        } else {\n            const numWritableSignedAccounts = numSignedAccounts - this.header.numReadonlySignedAccounts;\n            return index < numWritableSignedAccounts;\n        }\n    }\n    isProgramId(index) {\n        return this.indexToProgramIds.has(index);\n    }\n    programIds() {\n        return [\n            ...this.indexToProgramIds.values()\n        ];\n    }\n    nonProgramIds() {\n        return this.accountKeys.filter((_, index)=>!this.isProgramId(index));\n    }\n    serialize() {\n        const numKeys = this.accountKeys.length;\n        let keyCount = [];\n        encodeLength(keyCount, numKeys);\n        const instructions = this.instructions.map((instruction)=>{\n            const { accounts, programIdIndex } = instruction;\n            const data = Array.from(bs58__WEBPACK_IMPORTED_MODULE_2___default().decode(instruction.data));\n            let keyIndicesCount = [];\n            encodeLength(keyIndicesCount, accounts.length);\n            let dataCount = [];\n            encodeLength(dataCount, data.length);\n            return {\n                programIdIndex,\n                keyIndicesCount: buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.from(keyIndicesCount),\n                keyIndices: accounts,\n                dataLength: buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.from(dataCount),\n                data\n            };\n        });\n        let instructionCount = [];\n        encodeLength(instructionCount, instructions.length);\n        let instructionBuffer = buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.alloc(PACKET_DATA_SIZE);\n        buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.from(instructionCount).copy(instructionBuffer);\n        let instructionBufferLength = instructionCount.length;\n        instructions.forEach((instruction)=>{\n            const instructionLayout = _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.struct([\n                _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u8(\"programIdIndex\"),\n                _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.blob(instruction.keyIndicesCount.length, \"keyIndicesCount\"),\n                _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.seq(_solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u8(\"keyIndex\"), instruction.keyIndices.length, \"keyIndices\"),\n                _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.blob(instruction.dataLength.length, \"dataLength\"),\n                _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.seq(_solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u8(\"userdatum\"), instruction.data.length, \"data\")\n            ]);\n            const length = instructionLayout.encode(instruction, instructionBuffer, instructionBufferLength);\n            instructionBufferLength += length;\n        });\n        instructionBuffer = instructionBuffer.slice(0, instructionBufferLength);\n        const signDataLayout = _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.struct([\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.blob(1, \"numRequiredSignatures\"),\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.blob(1, \"numReadonlySignedAccounts\"),\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.blob(1, \"numReadonlyUnsignedAccounts\"),\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.blob(keyCount.length, \"keyCount\"),\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.seq(publicKey(\"key\"), numKeys, \"keys\"),\n            publicKey(\"recentBlockhash\")\n        ]);\n        const transaction = {\n            numRequiredSignatures: buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.from([\n                this.header.numRequiredSignatures\n            ]),\n            numReadonlySignedAccounts: buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.from([\n                this.header.numReadonlySignedAccounts\n            ]),\n            numReadonlyUnsignedAccounts: buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.from([\n                this.header.numReadonlyUnsignedAccounts\n            ]),\n            keyCount: buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.from(keyCount),\n            keys: this.accountKeys.map((key)=>toBuffer(key.toBytes())),\n            recentBlockhash: bs58__WEBPACK_IMPORTED_MODULE_2___default().decode(this.recentBlockhash)\n        };\n        let signData = buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.alloc(2048);\n        const length = signDataLayout.encode(transaction, signData);\n        instructionBuffer.copy(signData, length);\n        return signData.slice(0, length + instructionBuffer.length);\n    }\n    /**\n   * Decode a compiled message into a Message object.\n   */ static from(buffer) {\n        // Slice up wire data\n        let byteArray = [\n            ...buffer\n        ];\n        const numRequiredSignatures = guardedShift(byteArray);\n        if (numRequiredSignatures !== (numRequiredSignatures & VERSION_PREFIX_MASK)) {\n            throw new Error(\"Versioned messages must be deserialized with VersionedMessage.deserialize()\");\n        }\n        const numReadonlySignedAccounts = guardedShift(byteArray);\n        const numReadonlyUnsignedAccounts = guardedShift(byteArray);\n        const accountCount = decodeLength(byteArray);\n        let accountKeys = [];\n        for(let i = 0; i < accountCount; i++){\n            const account = guardedSplice(byteArray, 0, PUBLIC_KEY_LENGTH);\n            accountKeys.push(new PublicKey(buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.from(account)));\n        }\n        const recentBlockhash = guardedSplice(byteArray, 0, PUBLIC_KEY_LENGTH);\n        const instructionCount = decodeLength(byteArray);\n        let instructions = [];\n        for(let i = 0; i < instructionCount; i++){\n            const programIdIndex = guardedShift(byteArray);\n            const accountCount = decodeLength(byteArray);\n            const accounts = guardedSplice(byteArray, 0, accountCount);\n            const dataLength = decodeLength(byteArray);\n            const dataSlice = guardedSplice(byteArray, 0, dataLength);\n            const data = bs58__WEBPACK_IMPORTED_MODULE_2___default().encode(buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.from(dataSlice));\n            instructions.push({\n                programIdIndex,\n                accounts,\n                data\n            });\n        }\n        const messageArgs = {\n            header: {\n                numRequiredSignatures,\n                numReadonlySignedAccounts,\n                numReadonlyUnsignedAccounts\n            },\n            recentBlockhash: bs58__WEBPACK_IMPORTED_MODULE_2___default().encode(buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.from(recentBlockhash)),\n            accountKeys,\n            instructions\n        };\n        return new Message(messageArgs);\n    }\n}\n/**\n * Message constructor arguments\n */ class MessageV0 {\n    constructor(args){\n        this.header = void 0;\n        this.staticAccountKeys = void 0;\n        this.recentBlockhash = void 0;\n        this.compiledInstructions = void 0;\n        this.addressTableLookups = void 0;\n        this.header = args.header;\n        this.staticAccountKeys = args.staticAccountKeys;\n        this.recentBlockhash = args.recentBlockhash;\n        this.compiledInstructions = args.compiledInstructions;\n        this.addressTableLookups = args.addressTableLookups;\n    }\n    get version() {\n        return 0;\n    }\n    get numAccountKeysFromLookups() {\n        let count = 0;\n        for (const lookup of this.addressTableLookups){\n            count += lookup.readonlyIndexes.length + lookup.writableIndexes.length;\n        }\n        return count;\n    }\n    getAccountKeys(args) {\n        let accountKeysFromLookups;\n        if (args && \"accountKeysFromLookups\" in args && args.accountKeysFromLookups) {\n            if (this.numAccountKeysFromLookups != args.accountKeysFromLookups.writable.length + args.accountKeysFromLookups.readonly.length) {\n                throw new Error(\"Failed to get account keys because of a mismatch in the number of account keys from lookups\");\n            }\n            accountKeysFromLookups = args.accountKeysFromLookups;\n        } else if (args && \"addressLookupTableAccounts\" in args && args.addressLookupTableAccounts) {\n            accountKeysFromLookups = this.resolveAddressTableLookups(args.addressLookupTableAccounts);\n        } else if (this.addressTableLookups.length > 0) {\n            throw new Error(\"Failed to get account keys because address table lookups were not resolved\");\n        }\n        return new MessageAccountKeys(this.staticAccountKeys, accountKeysFromLookups);\n    }\n    isAccountSigner(index) {\n        return index < this.header.numRequiredSignatures;\n    }\n    isAccountWritable(index) {\n        const numSignedAccounts = this.header.numRequiredSignatures;\n        const numStaticAccountKeys = this.staticAccountKeys.length;\n        if (index >= numStaticAccountKeys) {\n            const lookupAccountKeysIndex = index - numStaticAccountKeys;\n            const numWritableLookupAccountKeys = this.addressTableLookups.reduce((count, lookup)=>count + lookup.writableIndexes.length, 0);\n            return lookupAccountKeysIndex < numWritableLookupAccountKeys;\n        } else if (index >= this.header.numRequiredSignatures) {\n            const unsignedAccountIndex = index - numSignedAccounts;\n            const numUnsignedAccounts = numStaticAccountKeys - numSignedAccounts;\n            const numWritableUnsignedAccounts = numUnsignedAccounts - this.header.numReadonlyUnsignedAccounts;\n            return unsignedAccountIndex < numWritableUnsignedAccounts;\n        } else {\n            const numWritableSignedAccounts = numSignedAccounts - this.header.numReadonlySignedAccounts;\n            return index < numWritableSignedAccounts;\n        }\n    }\n    resolveAddressTableLookups(addressLookupTableAccounts) {\n        const accountKeysFromLookups = {\n            writable: [],\n            readonly: []\n        };\n        for (const tableLookup of this.addressTableLookups){\n            const tableAccount = addressLookupTableAccounts.find((account)=>account.key.equals(tableLookup.accountKey));\n            if (!tableAccount) {\n                throw new Error(`Failed to find address lookup table account for table key ${tableLookup.accountKey.toBase58()}`);\n            }\n            for (const index of tableLookup.writableIndexes){\n                if (index < tableAccount.state.addresses.length) {\n                    accountKeysFromLookups.writable.push(tableAccount.state.addresses[index]);\n                } else {\n                    throw new Error(`Failed to find address for index ${index} in address lookup table ${tableLookup.accountKey.toBase58()}`);\n                }\n            }\n            for (const index of tableLookup.readonlyIndexes){\n                if (index < tableAccount.state.addresses.length) {\n                    accountKeysFromLookups.readonly.push(tableAccount.state.addresses[index]);\n                } else {\n                    throw new Error(`Failed to find address for index ${index} in address lookup table ${tableLookup.accountKey.toBase58()}`);\n                }\n            }\n        }\n        return accountKeysFromLookups;\n    }\n    static compile(args) {\n        const compiledKeys = CompiledKeys.compile(args.instructions, args.payerKey);\n        const addressTableLookups = new Array();\n        const accountKeysFromLookups = {\n            writable: new Array(),\n            readonly: new Array()\n        };\n        const lookupTableAccounts = args.addressLookupTableAccounts || [];\n        for (const lookupTable of lookupTableAccounts){\n            const extractResult = compiledKeys.extractTableLookup(lookupTable);\n            if (extractResult !== undefined) {\n                const [addressTableLookup, { writable, readonly }] = extractResult;\n                addressTableLookups.push(addressTableLookup);\n                accountKeysFromLookups.writable.push(...writable);\n                accountKeysFromLookups.readonly.push(...readonly);\n            }\n        }\n        const [header, staticAccountKeys] = compiledKeys.getMessageComponents();\n        const accountKeys = new MessageAccountKeys(staticAccountKeys, accountKeysFromLookups);\n        const compiledInstructions = accountKeys.compileInstructions(args.instructions);\n        return new MessageV0({\n            header,\n            staticAccountKeys,\n            recentBlockhash: args.recentBlockhash,\n            compiledInstructions,\n            addressTableLookups\n        });\n    }\n    serialize() {\n        const encodedStaticAccountKeysLength = Array();\n        encodeLength(encodedStaticAccountKeysLength, this.staticAccountKeys.length);\n        const serializedInstructions = this.serializeInstructions();\n        const encodedInstructionsLength = Array();\n        encodeLength(encodedInstructionsLength, this.compiledInstructions.length);\n        const serializedAddressTableLookups = this.serializeAddressTableLookups();\n        const encodedAddressTableLookupsLength = Array();\n        encodeLength(encodedAddressTableLookupsLength, this.addressTableLookups.length);\n        const messageLayout = _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.struct([\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u8(\"prefix\"),\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.struct([\n                _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u8(\"numRequiredSignatures\"),\n                _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u8(\"numReadonlySignedAccounts\"),\n                _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u8(\"numReadonlyUnsignedAccounts\")\n            ], \"header\"),\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.blob(encodedStaticAccountKeysLength.length, \"staticAccountKeysLength\"),\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.seq(publicKey(), this.staticAccountKeys.length, \"staticAccountKeys\"),\n            publicKey(\"recentBlockhash\"),\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.blob(encodedInstructionsLength.length, \"instructionsLength\"),\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.blob(serializedInstructions.length, \"serializedInstructions\"),\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.blob(encodedAddressTableLookupsLength.length, \"addressTableLookupsLength\"),\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.blob(serializedAddressTableLookups.length, \"serializedAddressTableLookups\")\n        ]);\n        const serializedMessage = new Uint8Array(PACKET_DATA_SIZE);\n        const MESSAGE_VERSION_0_PREFIX = 1 << 7;\n        const serializedMessageLength = messageLayout.encode({\n            prefix: MESSAGE_VERSION_0_PREFIX,\n            header: this.header,\n            staticAccountKeysLength: new Uint8Array(encodedStaticAccountKeysLength),\n            staticAccountKeys: this.staticAccountKeys.map((key)=>key.toBytes()),\n            recentBlockhash: bs58__WEBPACK_IMPORTED_MODULE_2___default().decode(this.recentBlockhash),\n            instructionsLength: new Uint8Array(encodedInstructionsLength),\n            serializedInstructions,\n            addressTableLookupsLength: new Uint8Array(encodedAddressTableLookupsLength),\n            serializedAddressTableLookups\n        }, serializedMessage);\n        return serializedMessage.slice(0, serializedMessageLength);\n    }\n    serializeInstructions() {\n        let serializedLength = 0;\n        const serializedInstructions = new Uint8Array(PACKET_DATA_SIZE);\n        for (const instruction of this.compiledInstructions){\n            const encodedAccountKeyIndexesLength = Array();\n            encodeLength(encodedAccountKeyIndexesLength, instruction.accountKeyIndexes.length);\n            const encodedDataLength = Array();\n            encodeLength(encodedDataLength, instruction.data.length);\n            const instructionLayout = _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.struct([\n                _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u8(\"programIdIndex\"),\n                _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.blob(encodedAccountKeyIndexesLength.length, \"encodedAccountKeyIndexesLength\"),\n                _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.seq(_solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u8(), instruction.accountKeyIndexes.length, \"accountKeyIndexes\"),\n                _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.blob(encodedDataLength.length, \"encodedDataLength\"),\n                _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.blob(instruction.data.length, \"data\")\n            ]);\n            serializedLength += instructionLayout.encode({\n                programIdIndex: instruction.programIdIndex,\n                encodedAccountKeyIndexesLength: new Uint8Array(encodedAccountKeyIndexesLength),\n                accountKeyIndexes: instruction.accountKeyIndexes,\n                encodedDataLength: new Uint8Array(encodedDataLength),\n                data: instruction.data\n            }, serializedInstructions, serializedLength);\n        }\n        return serializedInstructions.slice(0, serializedLength);\n    }\n    serializeAddressTableLookups() {\n        let serializedLength = 0;\n        const serializedAddressTableLookups = new Uint8Array(PACKET_DATA_SIZE);\n        for (const lookup of this.addressTableLookups){\n            const encodedWritableIndexesLength = Array();\n            encodeLength(encodedWritableIndexesLength, lookup.writableIndexes.length);\n            const encodedReadonlyIndexesLength = Array();\n            encodeLength(encodedReadonlyIndexesLength, lookup.readonlyIndexes.length);\n            const addressTableLookupLayout = _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.struct([\n                publicKey(\"accountKey\"),\n                _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.blob(encodedWritableIndexesLength.length, \"encodedWritableIndexesLength\"),\n                _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.seq(_solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u8(), lookup.writableIndexes.length, \"writableIndexes\"),\n                _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.blob(encodedReadonlyIndexesLength.length, \"encodedReadonlyIndexesLength\"),\n                _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.seq(_solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u8(), lookup.readonlyIndexes.length, \"readonlyIndexes\")\n            ]);\n            serializedLength += addressTableLookupLayout.encode({\n                accountKey: lookup.accountKey.toBytes(),\n                encodedWritableIndexesLength: new Uint8Array(encodedWritableIndexesLength),\n                writableIndexes: lookup.writableIndexes,\n                encodedReadonlyIndexesLength: new Uint8Array(encodedReadonlyIndexesLength),\n                readonlyIndexes: lookup.readonlyIndexes\n            }, serializedAddressTableLookups, serializedLength);\n        }\n        return serializedAddressTableLookups.slice(0, serializedLength);\n    }\n    static deserialize(serializedMessage) {\n        let byteArray = [\n            ...serializedMessage\n        ];\n        const prefix = guardedShift(byteArray);\n        const maskedPrefix = prefix & VERSION_PREFIX_MASK;\n        assert(prefix !== maskedPrefix, `Expected versioned message but received legacy message`);\n        const version = maskedPrefix;\n        assert(version === 0, `Expected versioned message with version 0 but found version ${version}`);\n        const header = {\n            numRequiredSignatures: guardedShift(byteArray),\n            numReadonlySignedAccounts: guardedShift(byteArray),\n            numReadonlyUnsignedAccounts: guardedShift(byteArray)\n        };\n        const staticAccountKeys = [];\n        const staticAccountKeysLength = decodeLength(byteArray);\n        for(let i = 0; i < staticAccountKeysLength; i++){\n            staticAccountKeys.push(new PublicKey(guardedSplice(byteArray, 0, PUBLIC_KEY_LENGTH)));\n        }\n        const recentBlockhash = bs58__WEBPACK_IMPORTED_MODULE_2___default().encode(guardedSplice(byteArray, 0, PUBLIC_KEY_LENGTH));\n        const instructionCount = decodeLength(byteArray);\n        const compiledInstructions = [];\n        for(let i = 0; i < instructionCount; i++){\n            const programIdIndex = guardedShift(byteArray);\n            const accountKeyIndexesLength = decodeLength(byteArray);\n            const accountKeyIndexes = guardedSplice(byteArray, 0, accountKeyIndexesLength);\n            const dataLength = decodeLength(byteArray);\n            const data = new Uint8Array(guardedSplice(byteArray, 0, dataLength));\n            compiledInstructions.push({\n                programIdIndex,\n                accountKeyIndexes,\n                data\n            });\n        }\n        const addressTableLookupsCount = decodeLength(byteArray);\n        const addressTableLookups = [];\n        for(let i = 0; i < addressTableLookupsCount; i++){\n            const accountKey = new PublicKey(guardedSplice(byteArray, 0, PUBLIC_KEY_LENGTH));\n            const writableIndexesLength = decodeLength(byteArray);\n            const writableIndexes = guardedSplice(byteArray, 0, writableIndexesLength);\n            const readonlyIndexesLength = decodeLength(byteArray);\n            const readonlyIndexes = guardedSplice(byteArray, 0, readonlyIndexesLength);\n            addressTableLookups.push({\n                accountKey,\n                writableIndexes,\n                readonlyIndexes\n            });\n        }\n        return new MessageV0({\n            header,\n            staticAccountKeys,\n            recentBlockhash,\n            compiledInstructions,\n            addressTableLookups\n        });\n    }\n}\n// eslint-disable-next-line no-redeclare\nconst VersionedMessage = {\n    deserializeMessageVersion (serializedMessage) {\n        const prefix = serializedMessage[0];\n        const maskedPrefix = prefix & VERSION_PREFIX_MASK;\n        // if the highest bit of the prefix is not set, the message is not versioned\n        if (maskedPrefix === prefix) {\n            return \"legacy\";\n        }\n        // the lower 7 bits of the prefix indicate the message version\n        return maskedPrefix;\n    },\n    deserialize: (serializedMessage)=>{\n        const version = VersionedMessage.deserializeMessageVersion(serializedMessage);\n        if (version === \"legacy\") {\n            return Message.from(serializedMessage);\n        }\n        if (version === 0) {\n            return MessageV0.deserialize(serializedMessage);\n        } else {\n            throw new Error(`Transaction message version ${version} deserialization is not supported`);\n        }\n    }\n};\n/** @internal */ /**\n * Transaction signature as base-58 encoded string\n */ let TransactionStatus = /*#__PURE__*/ function(TransactionStatus) {\n    TransactionStatus[TransactionStatus[\"BLOCKHEIGHT_EXCEEDED\"] = 0] = \"BLOCKHEIGHT_EXCEEDED\";\n    TransactionStatus[TransactionStatus[\"PROCESSED\"] = 1] = \"PROCESSED\";\n    TransactionStatus[TransactionStatus[\"TIMED_OUT\"] = 2] = \"TIMED_OUT\";\n    TransactionStatus[TransactionStatus[\"NONCE_INVALID\"] = 3] = \"NONCE_INVALID\";\n    return TransactionStatus;\n}({});\n/**\n * Default (empty) signature\n */ const DEFAULT_SIGNATURE = buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.alloc(SIGNATURE_LENGTH_IN_BYTES).fill(0);\n/**\n * Account metadata used to define instructions\n */ /**\n * List of TransactionInstruction object fields that may be initialized at construction\n */ /**\n * Configuration object for Transaction.serialize()\n */ /**\n * @internal\n */ /**\n * Transaction Instruction class\n */ class TransactionInstruction {\n    constructor(opts){\n        /**\n     * Public keys to include in this transaction\n     * Boolean represents whether this pubkey needs to sign the transaction\n     */ this.keys = void 0;\n        /**\n     * Program Id to execute\n     */ this.programId = void 0;\n        /**\n     * Program input\n     */ this.data = buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.alloc(0);\n        this.programId = opts.programId;\n        this.keys = opts.keys;\n        if (opts.data) {\n            this.data = opts.data;\n        }\n    }\n    /**\n   * @internal\n   */ toJSON() {\n        return {\n            keys: this.keys.map(({ pubkey, isSigner, isWritable })=>({\n                    pubkey: pubkey.toJSON(),\n                    isSigner,\n                    isWritable\n                })),\n            programId: this.programId.toJSON(),\n            data: [\n                ...this.data\n            ]\n        };\n    }\n}\n/**\n * Pair of signature and corresponding public key\n */ /**\n * List of Transaction object fields that may be initialized at construction\n */ // For backward compatibility; an unfortunate consequence of being\n// forced to over-export types by the documentation generator.\n// See https://github.com/solana-labs/solana/pull/25820\n/**\n * Blockhash-based transactions have a lifetime that are defined by\n * the blockhash they include. Any transaction whose blockhash is\n * too old will be rejected.\n */ /**\n * Use these options to construct a durable nonce transaction.\n */ /**\n * Nonce information to be used to build an offline Transaction.\n */ /**\n * @internal\n */ /**\n * Transaction class\n */ class Transaction {\n    /**\n   * The first (payer) Transaction signature\n   *\n   * @returns {Buffer | null} Buffer of payer's signature\n   */ get signature() {\n        if (this.signatures.length > 0) {\n            return this.signatures[0].signature;\n        }\n        return null;\n    }\n    /**\n   * The transaction fee payer\n   */ // Construct a transaction with a blockhash and lastValidBlockHeight\n    // Construct a transaction using a durable nonce\n    /**\n   * @deprecated `TransactionCtorFields` has been deprecated and will be removed in a future version.\n   * Please supply a `TransactionBlockhashCtor` instead.\n   */ /**\n   * Construct an empty Transaction\n   */ constructor(opts){\n        /**\n     * Signatures for the transaction.  Typically created by invoking the\n     * `sign()` method\n     */ this.signatures = [];\n        this.feePayer = void 0;\n        /**\n     * The instructions to atomically execute\n     */ this.instructions = [];\n        /**\n     * A recent transaction id. Must be populated by the caller\n     */ this.recentBlockhash = void 0;\n        /**\n     * the last block chain can advance to before tx is declared expired\n     * */ this.lastValidBlockHeight = void 0;\n        /**\n     * Optional Nonce information. If populated, transaction will use a durable\n     * Nonce hash instead of a recentBlockhash. Must be populated by the caller\n     */ this.nonceInfo = void 0;\n        /**\n     * If this is a nonce transaction this represents the minimum slot from which\n     * to evaluate if the nonce has advanced when attempting to confirm the\n     * transaction. This protects against a case where the transaction confirmation\n     * logic loads the nonce account from an old slot and assumes the mismatch in\n     * nonce value implies that the nonce has been advanced.\n     */ this.minNonceContextSlot = void 0;\n        /**\n     * @internal\n     */ this._message = void 0;\n        /**\n     * @internal\n     */ this._json = void 0;\n        if (!opts) {\n            return;\n        }\n        if (opts.feePayer) {\n            this.feePayer = opts.feePayer;\n        }\n        if (opts.signatures) {\n            this.signatures = opts.signatures;\n        }\n        if (Object.prototype.hasOwnProperty.call(opts, \"nonceInfo\")) {\n            const { minContextSlot, nonceInfo } = opts;\n            this.minNonceContextSlot = minContextSlot;\n            this.nonceInfo = nonceInfo;\n        } else if (Object.prototype.hasOwnProperty.call(opts, \"lastValidBlockHeight\")) {\n            const { blockhash, lastValidBlockHeight } = opts;\n            this.recentBlockhash = blockhash;\n            this.lastValidBlockHeight = lastValidBlockHeight;\n        } else {\n            const { recentBlockhash, nonceInfo } = opts;\n            if (nonceInfo) {\n                this.nonceInfo = nonceInfo;\n            }\n            this.recentBlockhash = recentBlockhash;\n        }\n    }\n    /**\n   * @internal\n   */ toJSON() {\n        return {\n            recentBlockhash: this.recentBlockhash || null,\n            feePayer: this.feePayer ? this.feePayer.toJSON() : null,\n            nonceInfo: this.nonceInfo ? {\n                nonce: this.nonceInfo.nonce,\n                nonceInstruction: this.nonceInfo.nonceInstruction.toJSON()\n            } : null,\n            instructions: this.instructions.map((instruction)=>instruction.toJSON()),\n            signers: this.signatures.map(({ publicKey })=>{\n                return publicKey.toJSON();\n            })\n        };\n    }\n    /**\n   * Add one or more instructions to this Transaction\n   *\n   * @param {Array< Transaction | TransactionInstruction | TransactionInstructionCtorFields >} items - Instructions to add to the Transaction\n   */ add(...items) {\n        if (items.length === 0) {\n            throw new Error(\"No instructions\");\n        }\n        items.forEach((item)=>{\n            if (\"instructions\" in item) {\n                this.instructions = this.instructions.concat(item.instructions);\n            } else if (\"data\" in item && \"programId\" in item && \"keys\" in item) {\n                this.instructions.push(item);\n            } else {\n                this.instructions.push(new TransactionInstruction(item));\n            }\n        });\n        return this;\n    }\n    /**\n   * Compile transaction data\n   */ compileMessage() {\n        if (this._message && JSON.stringify(this.toJSON()) === JSON.stringify(this._json)) {\n            return this._message;\n        }\n        let recentBlockhash;\n        let instructions;\n        if (this.nonceInfo) {\n            recentBlockhash = this.nonceInfo.nonce;\n            if (this.instructions[0] != this.nonceInfo.nonceInstruction) {\n                instructions = [\n                    this.nonceInfo.nonceInstruction,\n                    ...this.instructions\n                ];\n            } else {\n                instructions = this.instructions;\n            }\n        } else {\n            recentBlockhash = this.recentBlockhash;\n            instructions = this.instructions;\n        }\n        if (!recentBlockhash) {\n            throw new Error(\"Transaction recentBlockhash required\");\n        }\n        if (instructions.length < 1) {\n            console.warn(\"No instructions provided\");\n        }\n        let feePayer;\n        if (this.feePayer) {\n            feePayer = this.feePayer;\n        } else if (this.signatures.length > 0 && this.signatures[0].publicKey) {\n            // Use implicit fee payer\n            feePayer = this.signatures[0].publicKey;\n        } else {\n            throw new Error(\"Transaction fee payer required\");\n        }\n        for(let i = 0; i < instructions.length; i++){\n            if (instructions[i].programId === undefined) {\n                throw new Error(`Transaction instruction index ${i} has undefined program id`);\n            }\n        }\n        const programIds = [];\n        const accountMetas = [];\n        instructions.forEach((instruction)=>{\n            instruction.keys.forEach((accountMeta)=>{\n                accountMetas.push({\n                    ...accountMeta\n                });\n            });\n            const programId = instruction.programId.toString();\n            if (!programIds.includes(programId)) {\n                programIds.push(programId);\n            }\n        });\n        // Append programID account metas\n        programIds.forEach((programId)=>{\n            accountMetas.push({\n                pubkey: new PublicKey(programId),\n                isSigner: false,\n                isWritable: false\n            });\n        });\n        // Cull duplicate account metas\n        const uniqueMetas = [];\n        accountMetas.forEach((accountMeta)=>{\n            const pubkeyString = accountMeta.pubkey.toString();\n            const uniqueIndex = uniqueMetas.findIndex((x)=>{\n                return x.pubkey.toString() === pubkeyString;\n            });\n            if (uniqueIndex > -1) {\n                uniqueMetas[uniqueIndex].isWritable = uniqueMetas[uniqueIndex].isWritable || accountMeta.isWritable;\n                uniqueMetas[uniqueIndex].isSigner = uniqueMetas[uniqueIndex].isSigner || accountMeta.isSigner;\n            } else {\n                uniqueMetas.push(accountMeta);\n            }\n        });\n        // Sort. Prioritizing first by signer, then by writable\n        uniqueMetas.sort(function(x, y) {\n            if (x.isSigner !== y.isSigner) {\n                // Signers always come before non-signers\n                return x.isSigner ? -1 : 1;\n            }\n            if (x.isWritable !== y.isWritable) {\n                // Writable accounts always come before read-only accounts\n                return x.isWritable ? -1 : 1;\n            }\n            // Otherwise, sort by pubkey, stringwise.\n            const options = {\n                localeMatcher: \"best fit\",\n                usage: \"sort\",\n                sensitivity: \"variant\",\n                ignorePunctuation: false,\n                numeric: false,\n                caseFirst: \"lower\"\n            };\n            return x.pubkey.toBase58().localeCompare(y.pubkey.toBase58(), \"en\", options);\n        });\n        // Move fee payer to the front\n        const feePayerIndex = uniqueMetas.findIndex((x)=>{\n            return x.pubkey.equals(feePayer);\n        });\n        if (feePayerIndex > -1) {\n            const [payerMeta] = uniqueMetas.splice(feePayerIndex, 1);\n            payerMeta.isSigner = true;\n            payerMeta.isWritable = true;\n            uniqueMetas.unshift(payerMeta);\n        } else {\n            uniqueMetas.unshift({\n                pubkey: feePayer,\n                isSigner: true,\n                isWritable: true\n            });\n        }\n        // Disallow unknown signers\n        for (const signature of this.signatures){\n            const uniqueIndex = uniqueMetas.findIndex((x)=>{\n                return x.pubkey.equals(signature.publicKey);\n            });\n            if (uniqueIndex > -1) {\n                if (!uniqueMetas[uniqueIndex].isSigner) {\n                    uniqueMetas[uniqueIndex].isSigner = true;\n                    console.warn(\"Transaction references a signature that is unnecessary, \" + \"only the fee payer and instruction signer accounts should sign a transaction. \" + \"This behavior is deprecated and will throw an error in the next major version release.\");\n                }\n            } else {\n                throw new Error(`unknown signer: ${signature.publicKey.toString()}`);\n            }\n        }\n        let numRequiredSignatures = 0;\n        let numReadonlySignedAccounts = 0;\n        let numReadonlyUnsignedAccounts = 0;\n        // Split out signing from non-signing keys and count header values\n        const signedKeys = [];\n        const unsignedKeys = [];\n        uniqueMetas.forEach(({ pubkey, isSigner, isWritable })=>{\n            if (isSigner) {\n                signedKeys.push(pubkey.toString());\n                numRequiredSignatures += 1;\n                if (!isWritable) {\n                    numReadonlySignedAccounts += 1;\n                }\n            } else {\n                unsignedKeys.push(pubkey.toString());\n                if (!isWritable) {\n                    numReadonlyUnsignedAccounts += 1;\n                }\n            }\n        });\n        const accountKeys = signedKeys.concat(unsignedKeys);\n        const compiledInstructions = instructions.map((instruction)=>{\n            const { data, programId } = instruction;\n            return {\n                programIdIndex: accountKeys.indexOf(programId.toString()),\n                accounts: instruction.keys.map((meta)=>accountKeys.indexOf(meta.pubkey.toString())),\n                data: bs58__WEBPACK_IMPORTED_MODULE_2___default().encode(data)\n            };\n        });\n        compiledInstructions.forEach((instruction)=>{\n            assert(instruction.programIdIndex >= 0);\n            instruction.accounts.forEach((keyIndex)=>assert(keyIndex >= 0));\n        });\n        return new Message({\n            header: {\n                numRequiredSignatures,\n                numReadonlySignedAccounts,\n                numReadonlyUnsignedAccounts\n            },\n            accountKeys,\n            recentBlockhash,\n            instructions: compiledInstructions\n        });\n    }\n    /**\n   * @internal\n   */ _compile() {\n        const message = this.compileMessage();\n        const signedKeys = message.accountKeys.slice(0, message.header.numRequiredSignatures);\n        if (this.signatures.length === signedKeys.length) {\n            const valid = this.signatures.every((pair, index)=>{\n                return signedKeys[index].equals(pair.publicKey);\n            });\n            if (valid) return message;\n        }\n        this.signatures = signedKeys.map((publicKey)=>({\n                signature: null,\n                publicKey\n            }));\n        return message;\n    }\n    /**\n   * Get a buffer of the Transaction data that need to be covered by signatures\n   */ serializeMessage() {\n        return this._compile().serialize();\n    }\n    /**\n   * Get the estimated fee associated with a transaction\n   *\n   * @param {Connection} connection Connection to RPC Endpoint.\n   *\n   * @returns {Promise<number | null>} The estimated fee for the transaction\n   */ async getEstimatedFee(connection) {\n        return (await connection.getFeeForMessage(this.compileMessage())).value;\n    }\n    /**\n   * Specify the public keys which will be used to sign the Transaction.\n   * The first signer will be used as the transaction fee payer account.\n   *\n   * Signatures can be added with either `partialSign` or `addSignature`\n   *\n   * @deprecated Deprecated since v0.84.0. Only the fee payer needs to be\n   * specified and it can be set in the Transaction constructor or with the\n   * `feePayer` property.\n   */ setSigners(...signers) {\n        if (signers.length === 0) {\n            throw new Error(\"No signers\");\n        }\n        const seen = new Set();\n        this.signatures = signers.filter((publicKey)=>{\n            const key = publicKey.toString();\n            if (seen.has(key)) {\n                return false;\n            } else {\n                seen.add(key);\n                return true;\n            }\n        }).map((publicKey)=>({\n                signature: null,\n                publicKey\n            }));\n    }\n    /**\n   * Sign the Transaction with the specified signers. Multiple signatures may\n   * be applied to a Transaction. The first signature is considered \"primary\"\n   * and is used identify and confirm transactions.\n   *\n   * If the Transaction `feePayer` is not set, the first signer will be used\n   * as the transaction fee payer account.\n   *\n   * Transaction fields should not be modified after the first call to `sign`,\n   * as doing so may invalidate the signature and cause the Transaction to be\n   * rejected.\n   *\n   * The Transaction must be assigned a valid `recentBlockhash` before invoking this method\n   *\n   * @param {Array<Signer>} signers Array of signers that will sign the transaction\n   */ sign(...signers) {\n        if (signers.length === 0) {\n            throw new Error(\"No signers\");\n        }\n        // Dedupe signers\n        const seen = new Set();\n        const uniqueSigners = [];\n        for (const signer of signers){\n            const key = signer.publicKey.toString();\n            if (seen.has(key)) {\n                continue;\n            } else {\n                seen.add(key);\n                uniqueSigners.push(signer);\n            }\n        }\n        this.signatures = uniqueSigners.map((signer)=>({\n                signature: null,\n                publicKey: signer.publicKey\n            }));\n        const message = this._compile();\n        this._partialSign(message, ...uniqueSigners);\n    }\n    /**\n   * Partially sign a transaction with the specified accounts. All accounts must\n   * correspond to either the fee payer or a signer account in the transaction\n   * instructions.\n   *\n   * All the caveats from the `sign` method apply to `partialSign`\n   *\n   * @param {Array<Signer>} signers Array of signers that will sign the transaction\n   */ partialSign(...signers) {\n        if (signers.length === 0) {\n            throw new Error(\"No signers\");\n        }\n        // Dedupe signers\n        const seen = new Set();\n        const uniqueSigners = [];\n        for (const signer of signers){\n            const key = signer.publicKey.toString();\n            if (seen.has(key)) {\n                continue;\n            } else {\n                seen.add(key);\n                uniqueSigners.push(signer);\n            }\n        }\n        const message = this._compile();\n        this._partialSign(message, ...uniqueSigners);\n    }\n    /**\n   * @internal\n   */ _partialSign(message, ...signers) {\n        const signData = message.serialize();\n        signers.forEach((signer)=>{\n            const signature = sign(signData, signer.secretKey);\n            this._addSignature(signer.publicKey, toBuffer(signature));\n        });\n    }\n    /**\n   * Add an externally created signature to a transaction. The public key\n   * must correspond to either the fee payer or a signer account in the transaction\n   * instructions.\n   *\n   * @param {PublicKey} pubkey Public key that will be added to the transaction.\n   * @param {Buffer} signature An externally created signature to add to the transaction.\n   */ addSignature(pubkey, signature) {\n        this._compile(); // Ensure signatures array is populated\n        this._addSignature(pubkey, signature);\n    }\n    /**\n   * @internal\n   */ _addSignature(pubkey, signature) {\n        assert(signature.length === 64);\n        const index = this.signatures.findIndex((sigpair)=>pubkey.equals(sigpair.publicKey));\n        if (index < 0) {\n            throw new Error(`unknown signer: ${pubkey.toString()}`);\n        }\n        this.signatures[index].signature = buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.from(signature);\n    }\n    /**\n   * Verify signatures of a Transaction\n   * Optional parameter specifies if we're expecting a fully signed Transaction or a partially signed one.\n   * If no boolean is provided, we expect a fully signed Transaction by default.\n   *\n   * @param {boolean} [requireAllSignatures=true] Require a fully signed Transaction\n   */ verifySignatures(requireAllSignatures = true) {\n        const signatureErrors = this._getMessageSignednessErrors(this.serializeMessage(), requireAllSignatures);\n        return !signatureErrors;\n    }\n    /**\n   * @internal\n   */ _getMessageSignednessErrors(message, requireAllSignatures) {\n        const errors = {};\n        for (const { signature, publicKey } of this.signatures){\n            if (signature === null) {\n                if (requireAllSignatures) {\n                    (errors.missing ||= []).push(publicKey);\n                }\n            } else {\n                if (!verify(signature, message, publicKey.toBytes())) {\n                    (errors.invalid ||= []).push(publicKey);\n                }\n            }\n        }\n        return errors.invalid || errors.missing ? errors : undefined;\n    }\n    /**\n   * Serialize the Transaction in the wire format.\n   *\n   * @param {Buffer} [config] Config of transaction.\n   *\n   * @returns {Buffer} Signature of transaction in wire format.\n   */ serialize(config) {\n        const { requireAllSignatures, verifySignatures } = Object.assign({\n            requireAllSignatures: true,\n            verifySignatures: true\n        }, config);\n        const signData = this.serializeMessage();\n        if (verifySignatures) {\n            const sigErrors = this._getMessageSignednessErrors(signData, requireAllSignatures);\n            if (sigErrors) {\n                let errorMessage = \"Signature verification failed.\";\n                if (sigErrors.invalid) {\n                    errorMessage += `\\nInvalid signature for public key${sigErrors.invalid.length === 1 ? \"\" : \"(s)\"} [\\`${sigErrors.invalid.map((p)=>p.toBase58()).join(\"`, `\")}\\`].`;\n                }\n                if (sigErrors.missing) {\n                    errorMessage += `\\nMissing signature for public key${sigErrors.missing.length === 1 ? \"\" : \"(s)\"} [\\`${sigErrors.missing.map((p)=>p.toBase58()).join(\"`, `\")}\\`].`;\n                }\n                throw new Error(errorMessage);\n            }\n        }\n        return this._serialize(signData);\n    }\n    /**\n   * @internal\n   */ _serialize(signData) {\n        const { signatures } = this;\n        const signatureCount = [];\n        encodeLength(signatureCount, signatures.length);\n        const transactionLength = signatureCount.length + signatures.length * 64 + signData.length;\n        const wireTransaction = buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.alloc(transactionLength);\n        assert(signatures.length < 256);\n        buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.from(signatureCount).copy(wireTransaction, 0);\n        signatures.forEach(({ signature }, index)=>{\n            if (signature !== null) {\n                assert(signature.length === 64, `signature has invalid length`);\n                buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.from(signature).copy(wireTransaction, signatureCount.length + index * 64);\n            }\n        });\n        signData.copy(wireTransaction, signatureCount.length + signatures.length * 64);\n        assert(wireTransaction.length <= PACKET_DATA_SIZE, `Transaction too large: ${wireTransaction.length} > ${PACKET_DATA_SIZE}`);\n        return wireTransaction;\n    }\n    /**\n   * Deprecated method\n   * @internal\n   */ get keys() {\n        assert(this.instructions.length === 1);\n        return this.instructions[0].keys.map((keyObj)=>keyObj.pubkey);\n    }\n    /**\n   * Deprecated method\n   * @internal\n   */ get programId() {\n        assert(this.instructions.length === 1);\n        return this.instructions[0].programId;\n    }\n    /**\n   * Deprecated method\n   * @internal\n   */ get data() {\n        assert(this.instructions.length === 1);\n        return this.instructions[0].data;\n    }\n    /**\n   * Parse a wire transaction into a Transaction object.\n   *\n   * @param {Buffer | Uint8Array | Array<number>} buffer Signature of wire Transaction\n   *\n   * @returns {Transaction} Transaction associated with the signature\n   */ static from(buffer) {\n        // Slice up wire data\n        let byteArray = [\n            ...buffer\n        ];\n        const signatureCount = decodeLength(byteArray);\n        let signatures = [];\n        for(let i = 0; i < signatureCount; i++){\n            const signature = guardedSplice(byteArray, 0, SIGNATURE_LENGTH_IN_BYTES);\n            signatures.push(bs58__WEBPACK_IMPORTED_MODULE_2___default().encode(buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.from(signature)));\n        }\n        return Transaction.populate(Message.from(byteArray), signatures);\n    }\n    /**\n   * Populate Transaction object from message and signatures\n   *\n   * @param {Message} message Message of transaction\n   * @param {Array<string>} signatures List of signatures to assign to the transaction\n   *\n   * @returns {Transaction} The populated Transaction\n   */ static populate(message, signatures = []) {\n        const transaction = new Transaction();\n        transaction.recentBlockhash = message.recentBlockhash;\n        if (message.header.numRequiredSignatures > 0) {\n            transaction.feePayer = message.accountKeys[0];\n        }\n        signatures.forEach((signature, index)=>{\n            const sigPubkeyPair = {\n                signature: signature == bs58__WEBPACK_IMPORTED_MODULE_2___default().encode(DEFAULT_SIGNATURE) ? null : bs58__WEBPACK_IMPORTED_MODULE_2___default().decode(signature),\n                publicKey: message.accountKeys[index]\n            };\n            transaction.signatures.push(sigPubkeyPair);\n        });\n        message.instructions.forEach((instruction)=>{\n            const keys = instruction.accounts.map((account)=>{\n                const pubkey = message.accountKeys[account];\n                return {\n                    pubkey,\n                    isSigner: transaction.signatures.some((keyObj)=>keyObj.publicKey.toString() === pubkey.toString()) || message.isAccountSigner(account),\n                    isWritable: message.isAccountWritable(account)\n                };\n            });\n            transaction.instructions.push(new TransactionInstruction({\n                keys,\n                programId: message.accountKeys[instruction.programIdIndex],\n                data: bs58__WEBPACK_IMPORTED_MODULE_2___default().decode(instruction.data)\n            }));\n        });\n        transaction._message = message;\n        transaction._json = transaction.toJSON();\n        return transaction;\n    }\n}\nclass TransactionMessage {\n    constructor(args){\n        this.payerKey = void 0;\n        this.instructions = void 0;\n        this.recentBlockhash = void 0;\n        this.payerKey = args.payerKey;\n        this.instructions = args.instructions;\n        this.recentBlockhash = args.recentBlockhash;\n    }\n    static decompile(message, args) {\n        const { header, compiledInstructions, recentBlockhash } = message;\n        const { numRequiredSignatures, numReadonlySignedAccounts, numReadonlyUnsignedAccounts } = header;\n        const numWritableSignedAccounts = numRequiredSignatures - numReadonlySignedAccounts;\n        assert(numWritableSignedAccounts > 0, \"Message header is invalid\");\n        const numWritableUnsignedAccounts = message.staticAccountKeys.length - numRequiredSignatures - numReadonlyUnsignedAccounts;\n        assert(numWritableUnsignedAccounts >= 0, \"Message header is invalid\");\n        const accountKeys = message.getAccountKeys(args);\n        const payerKey = accountKeys.get(0);\n        if (payerKey === undefined) {\n            throw new Error(\"Failed to decompile message because no account keys were found\");\n        }\n        const instructions = [];\n        for (const compiledIx of compiledInstructions){\n            const keys = [];\n            for (const keyIndex of compiledIx.accountKeyIndexes){\n                const pubkey = accountKeys.get(keyIndex);\n                if (pubkey === undefined) {\n                    throw new Error(`Failed to find key for account key index ${keyIndex}`);\n                }\n                const isSigner = keyIndex < numRequiredSignatures;\n                let isWritable;\n                if (isSigner) {\n                    isWritable = keyIndex < numWritableSignedAccounts;\n                } else if (keyIndex < accountKeys.staticAccountKeys.length) {\n                    isWritable = keyIndex - numRequiredSignatures < numWritableUnsignedAccounts;\n                } else {\n                    isWritable = keyIndex - accountKeys.staticAccountKeys.length < // accountKeysFromLookups cannot be undefined because we already found a pubkey for this index above\n                    accountKeys.accountKeysFromLookups.writable.length;\n                }\n                keys.push({\n                    pubkey,\n                    isSigner: keyIndex < header.numRequiredSignatures,\n                    isWritable\n                });\n            }\n            const programId = accountKeys.get(compiledIx.programIdIndex);\n            if (programId === undefined) {\n                throw new Error(`Failed to find program id for program id index ${compiledIx.programIdIndex}`);\n            }\n            instructions.push(new TransactionInstruction({\n                programId,\n                data: toBuffer(compiledIx.data),\n                keys\n            }));\n        }\n        return new TransactionMessage({\n            payerKey,\n            instructions,\n            recentBlockhash\n        });\n    }\n    compileToLegacyMessage() {\n        return Message.compile({\n            payerKey: this.payerKey,\n            recentBlockhash: this.recentBlockhash,\n            instructions: this.instructions\n        });\n    }\n    compileToV0Message(addressLookupTableAccounts) {\n        return MessageV0.compile({\n            payerKey: this.payerKey,\n            recentBlockhash: this.recentBlockhash,\n            instructions: this.instructions,\n            addressLookupTableAccounts\n        });\n    }\n}\n/**\n * Versioned transaction class\n */ class VersionedTransaction {\n    get version() {\n        return this.message.version;\n    }\n    constructor(message, signatures){\n        this.signatures = void 0;\n        this.message = void 0;\n        if (signatures !== undefined) {\n            assert(signatures.length === message.header.numRequiredSignatures, \"Expected signatures length to be equal to the number of required signatures\");\n            this.signatures = signatures;\n        } else {\n            const defaultSignatures = [];\n            for(let i = 0; i < message.header.numRequiredSignatures; i++){\n                defaultSignatures.push(new Uint8Array(SIGNATURE_LENGTH_IN_BYTES));\n            }\n            this.signatures = defaultSignatures;\n        }\n        this.message = message;\n    }\n    serialize() {\n        const serializedMessage = this.message.serialize();\n        const encodedSignaturesLength = Array();\n        encodeLength(encodedSignaturesLength, this.signatures.length);\n        const transactionLayout = _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.struct([\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.blob(encodedSignaturesLength.length, \"encodedSignaturesLength\"),\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.seq(signature(), this.signatures.length, \"signatures\"),\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.blob(serializedMessage.length, \"serializedMessage\")\n        ]);\n        const serializedTransaction = new Uint8Array(2048);\n        const serializedTransactionLength = transactionLayout.encode({\n            encodedSignaturesLength: new Uint8Array(encodedSignaturesLength),\n            signatures: this.signatures,\n            serializedMessage\n        }, serializedTransaction);\n        return serializedTransaction.slice(0, serializedTransactionLength);\n    }\n    static deserialize(serializedTransaction) {\n        let byteArray = [\n            ...serializedTransaction\n        ];\n        const signatures = [];\n        const signaturesLength = decodeLength(byteArray);\n        for(let i = 0; i < signaturesLength; i++){\n            signatures.push(new Uint8Array(guardedSplice(byteArray, 0, SIGNATURE_LENGTH_IN_BYTES)));\n        }\n        const message = VersionedMessage.deserialize(new Uint8Array(byteArray));\n        return new VersionedTransaction(message, signatures);\n    }\n    sign(signers) {\n        const messageData = this.message.serialize();\n        const signerPubkeys = this.message.staticAccountKeys.slice(0, this.message.header.numRequiredSignatures);\n        for (const signer of signers){\n            const signerIndex = signerPubkeys.findIndex((pubkey)=>pubkey.equals(signer.publicKey));\n            assert(signerIndex >= 0, `Cannot sign with non signer key ${signer.publicKey.toBase58()}`);\n            this.signatures[signerIndex] = sign(messageData, signer.secretKey);\n        }\n    }\n    addSignature(publicKey, signature) {\n        assert(signature.byteLength === 64, \"Signature must be 64 bytes long\");\n        const signerPubkeys = this.message.staticAccountKeys.slice(0, this.message.header.numRequiredSignatures);\n        const signerIndex = signerPubkeys.findIndex((pubkey)=>pubkey.equals(publicKey));\n        assert(signerIndex >= 0, `Can not add signature; \\`${publicKey.toBase58()}\\` is not required to sign this transaction`);\n        this.signatures[signerIndex] = signature;\n    }\n}\n// TODO: These constants should be removed in favor of reading them out of a\n// Syscall account\n/**\n * @internal\n */ const NUM_TICKS_PER_SECOND = 160;\n/**\n * @internal\n */ const DEFAULT_TICKS_PER_SLOT = 64;\n/**\n * @internal\n */ const NUM_SLOTS_PER_SECOND = NUM_TICKS_PER_SECOND / DEFAULT_TICKS_PER_SLOT;\n/**\n * @internal\n */ const MS_PER_SLOT = 1000 / NUM_SLOTS_PER_SECOND;\nconst SYSVAR_CLOCK_PUBKEY = new PublicKey(\"SysvarC1ock11111111111111111111111111111111\");\nconst SYSVAR_EPOCH_SCHEDULE_PUBKEY = new PublicKey(\"SysvarEpochSchedu1e111111111111111111111111\");\nconst SYSVAR_INSTRUCTIONS_PUBKEY = new PublicKey(\"Sysvar1nstructions1111111111111111111111111\");\nconst SYSVAR_RECENT_BLOCKHASHES_PUBKEY = new PublicKey(\"SysvarRecentB1ockHashes11111111111111111111\");\nconst SYSVAR_RENT_PUBKEY = new PublicKey(\"SysvarRent111111111111111111111111111111111\");\nconst SYSVAR_REWARDS_PUBKEY = new PublicKey(\"SysvarRewards111111111111111111111111111111\");\nconst SYSVAR_SLOT_HASHES_PUBKEY = new PublicKey(\"SysvarS1otHashes111111111111111111111111111\");\nconst SYSVAR_SLOT_HISTORY_PUBKEY = new PublicKey(\"SysvarS1otHistory11111111111111111111111111\");\nconst SYSVAR_STAKE_HISTORY_PUBKEY = new PublicKey(\"SysvarStakeHistory1111111111111111111111111\");\n/**\n * Sign, send and confirm a transaction.\n *\n * If `commitment` option is not specified, defaults to 'max' commitment.\n *\n * @param {Connection} connection\n * @param {Transaction} transaction\n * @param {Array<Signer>} signers\n * @param {ConfirmOptions} [options]\n * @returns {Promise<TransactionSignature>}\n */ async function sendAndConfirmTransaction(connection, transaction, signers, options) {\n    const sendOptions = options && {\n        skipPreflight: options.skipPreflight,\n        preflightCommitment: options.preflightCommitment || options.commitment,\n        maxRetries: options.maxRetries,\n        minContextSlot: options.minContextSlot\n    };\n    const signature = await connection.sendTransaction(transaction, signers, sendOptions);\n    let status;\n    if (transaction.recentBlockhash != null && transaction.lastValidBlockHeight != null) {\n        status = (await connection.confirmTransaction({\n            abortSignal: options?.abortSignal,\n            signature: signature,\n            blockhash: transaction.recentBlockhash,\n            lastValidBlockHeight: transaction.lastValidBlockHeight\n        }, options && options.commitment)).value;\n    } else if (transaction.minNonceContextSlot != null && transaction.nonceInfo != null) {\n        const { nonceInstruction } = transaction.nonceInfo;\n        const nonceAccountPubkey = nonceInstruction.keys[0].pubkey;\n        status = (await connection.confirmTransaction({\n            abortSignal: options?.abortSignal,\n            minContextSlot: transaction.minNonceContextSlot,\n            nonceAccountPubkey,\n            nonceValue: transaction.nonceInfo.nonce,\n            signature\n        }, options && options.commitment)).value;\n    } else {\n        if (options?.abortSignal != null) {\n            console.warn(\"sendAndConfirmTransaction(): A transaction with a deprecated confirmation strategy was \" + \"supplied along with an `abortSignal`. Only transactions having `lastValidBlockHeight` \" + \"or a combination of `nonceInfo` and `minNonceContextSlot` are abortable.\");\n        }\n        status = (await connection.confirmTransaction(signature, options && options.commitment)).value;\n    }\n    if (status.err) {\n        throw new Error(`Transaction ${signature} failed (${JSON.stringify(status)})`);\n    }\n    return signature;\n}\n// zzz\nfunction sleep(ms) {\n    return new Promise((resolve)=>setTimeout(resolve, ms));\n}\n/**\n * @internal\n */ /**\n * Populate a buffer of instruction data using an InstructionType\n * @internal\n */ function encodeData(type, fields) {\n    const allocLength = type.layout.span >= 0 ? type.layout.span : getAlloc(type, fields);\n    const data = buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.alloc(allocLength);\n    const layoutFields = Object.assign({\n        instruction: type.index\n    }, fields);\n    type.layout.encode(layoutFields, data);\n    return data;\n}\n/**\n * Decode instruction data buffer using an InstructionType\n * @internal\n */ function decodeData$1(type, buffer) {\n    let data;\n    try {\n        data = type.layout.decode(buffer);\n    } catch (err) {\n        throw new Error(\"invalid instruction; \" + err);\n    }\n    if (data.instruction !== type.index) {\n        throw new Error(`invalid instruction; instruction index mismatch ${data.instruction} != ${type.index}`);\n    }\n    return data;\n}\n/**\n * https://github.com/solana-labs/solana/blob/90bedd7e067b5b8f3ddbb45da00a4e9cabb22c62/sdk/src/fee_calculator.rs#L7-L11\n *\n * @internal\n */ const FeeCalculatorLayout = _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.nu64(\"lamportsPerSignature\");\n/**\n * Calculator for transaction fees.\n *\n * @deprecated Deprecated since Solana v1.8.0.\n */ /**\n * See https://github.com/solana-labs/solana/blob/0ea2843ec9cdc517572b8e62c959f41b55cf4453/sdk/src/nonce_state.rs#L29-L32\n *\n * @internal\n */ const NonceAccountLayout = _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.struct([\n    _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u32(\"version\"),\n    _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u32(\"state\"),\n    publicKey(\"authorizedPubkey\"),\n    publicKey(\"nonce\"),\n    _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.struct([\n        FeeCalculatorLayout\n    ], \"feeCalculator\")\n]);\nconst NONCE_ACCOUNT_LENGTH = NonceAccountLayout.span;\n/**\n * A durable nonce is a 32 byte value encoded as a base58 string.\n */ /**\n * NonceAccount class\n */ class NonceAccount {\n    /**\n   * @internal\n   */ constructor(args){\n        this.authorizedPubkey = void 0;\n        this.nonce = void 0;\n        this.feeCalculator = void 0;\n        this.authorizedPubkey = args.authorizedPubkey;\n        this.nonce = args.nonce;\n        this.feeCalculator = args.feeCalculator;\n    }\n    /**\n   * Deserialize NonceAccount from the account data.\n   *\n   * @param buffer account data\n   * @return NonceAccount\n   */ static fromAccountData(buffer) {\n        const nonceAccount = NonceAccountLayout.decode(toBuffer(buffer), 0);\n        return new NonceAccount({\n            authorizedPubkey: new PublicKey(nonceAccount.authorizedPubkey),\n            nonce: new PublicKey(nonceAccount.nonce).toString(),\n            feeCalculator: nonceAccount.feeCalculator\n        });\n    }\n}\nconst encodeDecode = (layout)=>{\n    const decode = layout.decode.bind(layout);\n    const encode = layout.encode.bind(layout);\n    return {\n        decode,\n        encode\n    };\n};\nconst bigInt = (length)=>(property)=>{\n        const layout = (0,_solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.blob)(length, property);\n        const { encode, decode } = encodeDecode(layout);\n        const bigIntLayout = layout;\n        bigIntLayout.decode = (buffer, offset)=>{\n            const src = decode(buffer, offset);\n            return (0,bigint_buffer__WEBPACK_IMPORTED_MODULE_5__.toBigIntLE)(buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.from(src));\n        };\n        bigIntLayout.encode = (bigInt, buffer, offset)=>{\n            const src = (0,bigint_buffer__WEBPACK_IMPORTED_MODULE_5__.toBufferLE)(bigInt, length);\n            return encode(src, buffer, offset);\n        };\n        return bigIntLayout;\n    };\nconst u64 = bigInt(8);\n/**\n * Create account system transaction params\n */ /**\n * Transfer system transaction params\n */ /**\n * Assign system transaction params\n */ /**\n * Create account with seed system transaction params\n */ /**\n * Create nonce account system transaction params\n */ /**\n * Create nonce account with seed system transaction params\n */ /**\n * Initialize nonce account system instruction params\n */ /**\n * Advance nonce account system instruction params\n */ /**\n * Withdraw nonce account system transaction params\n */ /**\n * Authorize nonce account system transaction params\n */ /**\n * Allocate account system transaction params\n */ /**\n * Allocate account with seed system transaction params\n */ /**\n * Assign account with seed system transaction params\n */ /**\n * Transfer with seed system transaction params\n */ /** Decoded transfer system transaction instruction */ /** Decoded transferWithSeed system transaction instruction */ /**\n * System Instruction class\n */ class SystemInstruction {\n    /**\n   * @internal\n   */ constructor(){}\n    /**\n   * Decode a system instruction and retrieve the instruction type.\n   */ static decodeInstructionType(instruction) {\n        this.checkProgramId(instruction.programId);\n        const instructionTypeLayout = _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u32(\"instruction\");\n        const typeIndex = instructionTypeLayout.decode(instruction.data);\n        let type;\n        for (const [ixType, layout] of Object.entries(SYSTEM_INSTRUCTION_LAYOUTS)){\n            if (layout.index == typeIndex) {\n                type = ixType;\n                break;\n            }\n        }\n        if (!type) {\n            throw new Error(\"Instruction type incorrect; not a SystemInstruction\");\n        }\n        return type;\n    }\n    /**\n   * Decode a create account system instruction and retrieve the instruction params.\n   */ static decodeCreateAccount(instruction) {\n        this.checkProgramId(instruction.programId);\n        this.checkKeyLength(instruction.keys, 2);\n        const { lamports, space, programId } = decodeData$1(SYSTEM_INSTRUCTION_LAYOUTS.Create, instruction.data);\n        return {\n            fromPubkey: instruction.keys[0].pubkey,\n            newAccountPubkey: instruction.keys[1].pubkey,\n            lamports,\n            space,\n            programId: new PublicKey(programId)\n        };\n    }\n    /**\n   * Decode a transfer system instruction and retrieve the instruction params.\n   */ static decodeTransfer(instruction) {\n        this.checkProgramId(instruction.programId);\n        this.checkKeyLength(instruction.keys, 2);\n        const { lamports } = decodeData$1(SYSTEM_INSTRUCTION_LAYOUTS.Transfer, instruction.data);\n        return {\n            fromPubkey: instruction.keys[0].pubkey,\n            toPubkey: instruction.keys[1].pubkey,\n            lamports\n        };\n    }\n    /**\n   * Decode a transfer with seed system instruction and retrieve the instruction params.\n   */ static decodeTransferWithSeed(instruction) {\n        this.checkProgramId(instruction.programId);\n        this.checkKeyLength(instruction.keys, 3);\n        const { lamports, seed, programId } = decodeData$1(SYSTEM_INSTRUCTION_LAYOUTS.TransferWithSeed, instruction.data);\n        return {\n            fromPubkey: instruction.keys[0].pubkey,\n            basePubkey: instruction.keys[1].pubkey,\n            toPubkey: instruction.keys[2].pubkey,\n            lamports,\n            seed,\n            programId: new PublicKey(programId)\n        };\n    }\n    /**\n   * Decode an allocate system instruction and retrieve the instruction params.\n   */ static decodeAllocate(instruction) {\n        this.checkProgramId(instruction.programId);\n        this.checkKeyLength(instruction.keys, 1);\n        const { space } = decodeData$1(SYSTEM_INSTRUCTION_LAYOUTS.Allocate, instruction.data);\n        return {\n            accountPubkey: instruction.keys[0].pubkey,\n            space\n        };\n    }\n    /**\n   * Decode an allocate with seed system instruction and retrieve the instruction params.\n   */ static decodeAllocateWithSeed(instruction) {\n        this.checkProgramId(instruction.programId);\n        this.checkKeyLength(instruction.keys, 1);\n        const { base, seed, space, programId } = decodeData$1(SYSTEM_INSTRUCTION_LAYOUTS.AllocateWithSeed, instruction.data);\n        return {\n            accountPubkey: instruction.keys[0].pubkey,\n            basePubkey: new PublicKey(base),\n            seed,\n            space,\n            programId: new PublicKey(programId)\n        };\n    }\n    /**\n   * Decode an assign system instruction and retrieve the instruction params.\n   */ static decodeAssign(instruction) {\n        this.checkProgramId(instruction.programId);\n        this.checkKeyLength(instruction.keys, 1);\n        const { programId } = decodeData$1(SYSTEM_INSTRUCTION_LAYOUTS.Assign, instruction.data);\n        return {\n            accountPubkey: instruction.keys[0].pubkey,\n            programId: new PublicKey(programId)\n        };\n    }\n    /**\n   * Decode an assign with seed system instruction and retrieve the instruction params.\n   */ static decodeAssignWithSeed(instruction) {\n        this.checkProgramId(instruction.programId);\n        this.checkKeyLength(instruction.keys, 1);\n        const { base, seed, programId } = decodeData$1(SYSTEM_INSTRUCTION_LAYOUTS.AssignWithSeed, instruction.data);\n        return {\n            accountPubkey: instruction.keys[0].pubkey,\n            basePubkey: new PublicKey(base),\n            seed,\n            programId: new PublicKey(programId)\n        };\n    }\n    /**\n   * Decode a create account with seed system instruction and retrieve the instruction params.\n   */ static decodeCreateWithSeed(instruction) {\n        this.checkProgramId(instruction.programId);\n        this.checkKeyLength(instruction.keys, 2);\n        const { base, seed, lamports, space, programId } = decodeData$1(SYSTEM_INSTRUCTION_LAYOUTS.CreateWithSeed, instruction.data);\n        return {\n            fromPubkey: instruction.keys[0].pubkey,\n            newAccountPubkey: instruction.keys[1].pubkey,\n            basePubkey: new PublicKey(base),\n            seed,\n            lamports,\n            space,\n            programId: new PublicKey(programId)\n        };\n    }\n    /**\n   * Decode a nonce initialize system instruction and retrieve the instruction params.\n   */ static decodeNonceInitialize(instruction) {\n        this.checkProgramId(instruction.programId);\n        this.checkKeyLength(instruction.keys, 3);\n        const { authorized } = decodeData$1(SYSTEM_INSTRUCTION_LAYOUTS.InitializeNonceAccount, instruction.data);\n        return {\n            noncePubkey: instruction.keys[0].pubkey,\n            authorizedPubkey: new PublicKey(authorized)\n        };\n    }\n    /**\n   * Decode a nonce advance system instruction and retrieve the instruction params.\n   */ static decodeNonceAdvance(instruction) {\n        this.checkProgramId(instruction.programId);\n        this.checkKeyLength(instruction.keys, 3);\n        decodeData$1(SYSTEM_INSTRUCTION_LAYOUTS.AdvanceNonceAccount, instruction.data);\n        return {\n            noncePubkey: instruction.keys[0].pubkey,\n            authorizedPubkey: instruction.keys[2].pubkey\n        };\n    }\n    /**\n   * Decode a nonce withdraw system instruction and retrieve the instruction params.\n   */ static decodeNonceWithdraw(instruction) {\n        this.checkProgramId(instruction.programId);\n        this.checkKeyLength(instruction.keys, 5);\n        const { lamports } = decodeData$1(SYSTEM_INSTRUCTION_LAYOUTS.WithdrawNonceAccount, instruction.data);\n        return {\n            noncePubkey: instruction.keys[0].pubkey,\n            toPubkey: instruction.keys[1].pubkey,\n            authorizedPubkey: instruction.keys[4].pubkey,\n            lamports\n        };\n    }\n    /**\n   * Decode a nonce authorize system instruction and retrieve the instruction params.\n   */ static decodeNonceAuthorize(instruction) {\n        this.checkProgramId(instruction.programId);\n        this.checkKeyLength(instruction.keys, 2);\n        const { authorized } = decodeData$1(SYSTEM_INSTRUCTION_LAYOUTS.AuthorizeNonceAccount, instruction.data);\n        return {\n            noncePubkey: instruction.keys[0].pubkey,\n            authorizedPubkey: instruction.keys[1].pubkey,\n            newAuthorizedPubkey: new PublicKey(authorized)\n        };\n    }\n    /**\n   * @internal\n   */ static checkProgramId(programId) {\n        if (!programId.equals(SystemProgram.programId)) {\n            throw new Error(\"invalid instruction; programId is not SystemProgram\");\n        }\n    }\n    /**\n   * @internal\n   */ static checkKeyLength(keys, expectedLength) {\n        if (keys.length < expectedLength) {\n            throw new Error(`invalid instruction; found ${keys.length} keys, expected at least ${expectedLength}`);\n        }\n    }\n}\n/**\n * An enumeration of valid SystemInstructionType's\n */ /**\n * An enumeration of valid system InstructionType's\n * @internal\n */ const SYSTEM_INSTRUCTION_LAYOUTS = Object.freeze({\n    Create: {\n        index: 0,\n        layout: _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.struct([\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u32(\"instruction\"),\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.ns64(\"lamports\"),\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.ns64(\"space\"),\n            publicKey(\"programId\")\n        ])\n    },\n    Assign: {\n        index: 1,\n        layout: _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.struct([\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u32(\"instruction\"),\n            publicKey(\"programId\")\n        ])\n    },\n    Transfer: {\n        index: 2,\n        layout: _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.struct([\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u32(\"instruction\"),\n            u64(\"lamports\")\n        ])\n    },\n    CreateWithSeed: {\n        index: 3,\n        layout: _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.struct([\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u32(\"instruction\"),\n            publicKey(\"base\"),\n            rustString(\"seed\"),\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.ns64(\"lamports\"),\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.ns64(\"space\"),\n            publicKey(\"programId\")\n        ])\n    },\n    AdvanceNonceAccount: {\n        index: 4,\n        layout: _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.struct([\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u32(\"instruction\")\n        ])\n    },\n    WithdrawNonceAccount: {\n        index: 5,\n        layout: _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.struct([\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u32(\"instruction\"),\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.ns64(\"lamports\")\n        ])\n    },\n    InitializeNonceAccount: {\n        index: 6,\n        layout: _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.struct([\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u32(\"instruction\"),\n            publicKey(\"authorized\")\n        ])\n    },\n    AuthorizeNonceAccount: {\n        index: 7,\n        layout: _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.struct([\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u32(\"instruction\"),\n            publicKey(\"authorized\")\n        ])\n    },\n    Allocate: {\n        index: 8,\n        layout: _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.struct([\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u32(\"instruction\"),\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.ns64(\"space\")\n        ])\n    },\n    AllocateWithSeed: {\n        index: 9,\n        layout: _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.struct([\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u32(\"instruction\"),\n            publicKey(\"base\"),\n            rustString(\"seed\"),\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.ns64(\"space\"),\n            publicKey(\"programId\")\n        ])\n    },\n    AssignWithSeed: {\n        index: 10,\n        layout: _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.struct([\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u32(\"instruction\"),\n            publicKey(\"base\"),\n            rustString(\"seed\"),\n            publicKey(\"programId\")\n        ])\n    },\n    TransferWithSeed: {\n        index: 11,\n        layout: _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.struct([\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u32(\"instruction\"),\n            u64(\"lamports\"),\n            rustString(\"seed\"),\n            publicKey(\"programId\")\n        ])\n    },\n    UpgradeNonceAccount: {\n        index: 12,\n        layout: _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.struct([\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u32(\"instruction\")\n        ])\n    }\n});\n/**\n * Factory class for transactions to interact with the System program\n */ class SystemProgram {\n    /**\n   * @internal\n   */ constructor(){}\n    /**\n   * Public key that identifies the System program\n   */ /**\n   * Generate a transaction instruction that creates a new account\n   */ static createAccount(params) {\n        const type = SYSTEM_INSTRUCTION_LAYOUTS.Create;\n        const data = encodeData(type, {\n            lamports: params.lamports,\n            space: params.space,\n            programId: toBuffer(params.programId.toBuffer())\n        });\n        return new TransactionInstruction({\n            keys: [\n                {\n                    pubkey: params.fromPubkey,\n                    isSigner: true,\n                    isWritable: true\n                },\n                {\n                    pubkey: params.newAccountPubkey,\n                    isSigner: true,\n                    isWritable: true\n                }\n            ],\n            programId: this.programId,\n            data\n        });\n    }\n    /**\n   * Generate a transaction instruction that transfers lamports from one account to another\n   */ static transfer(params) {\n        let data;\n        let keys;\n        if (\"basePubkey\" in params) {\n            const type = SYSTEM_INSTRUCTION_LAYOUTS.TransferWithSeed;\n            data = encodeData(type, {\n                lamports: BigInt(params.lamports),\n                seed: params.seed,\n                programId: toBuffer(params.programId.toBuffer())\n            });\n            keys = [\n                {\n                    pubkey: params.fromPubkey,\n                    isSigner: false,\n                    isWritable: true\n                },\n                {\n                    pubkey: params.basePubkey,\n                    isSigner: true,\n                    isWritable: false\n                },\n                {\n                    pubkey: params.toPubkey,\n                    isSigner: false,\n                    isWritable: true\n                }\n            ];\n        } else {\n            const type = SYSTEM_INSTRUCTION_LAYOUTS.Transfer;\n            data = encodeData(type, {\n                lamports: BigInt(params.lamports)\n            });\n            keys = [\n                {\n                    pubkey: params.fromPubkey,\n                    isSigner: true,\n                    isWritable: true\n                },\n                {\n                    pubkey: params.toPubkey,\n                    isSigner: false,\n                    isWritable: true\n                }\n            ];\n        }\n        return new TransactionInstruction({\n            keys,\n            programId: this.programId,\n            data\n        });\n    }\n    /**\n   * Generate a transaction instruction that assigns an account to a program\n   */ static assign(params) {\n        let data;\n        let keys;\n        if (\"basePubkey\" in params) {\n            const type = SYSTEM_INSTRUCTION_LAYOUTS.AssignWithSeed;\n            data = encodeData(type, {\n                base: toBuffer(params.basePubkey.toBuffer()),\n                seed: params.seed,\n                programId: toBuffer(params.programId.toBuffer())\n            });\n            keys = [\n                {\n                    pubkey: params.accountPubkey,\n                    isSigner: false,\n                    isWritable: true\n                },\n                {\n                    pubkey: params.basePubkey,\n                    isSigner: true,\n                    isWritable: false\n                }\n            ];\n        } else {\n            const type = SYSTEM_INSTRUCTION_LAYOUTS.Assign;\n            data = encodeData(type, {\n                programId: toBuffer(params.programId.toBuffer())\n            });\n            keys = [\n                {\n                    pubkey: params.accountPubkey,\n                    isSigner: true,\n                    isWritable: true\n                }\n            ];\n        }\n        return new TransactionInstruction({\n            keys,\n            programId: this.programId,\n            data\n        });\n    }\n    /**\n   * Generate a transaction instruction that creates a new account at\n   *   an address generated with `from`, a seed, and programId\n   */ static createAccountWithSeed(params) {\n        const type = SYSTEM_INSTRUCTION_LAYOUTS.CreateWithSeed;\n        const data = encodeData(type, {\n            base: toBuffer(params.basePubkey.toBuffer()),\n            seed: params.seed,\n            lamports: params.lamports,\n            space: params.space,\n            programId: toBuffer(params.programId.toBuffer())\n        });\n        let keys = [\n            {\n                pubkey: params.fromPubkey,\n                isSigner: true,\n                isWritable: true\n            },\n            {\n                pubkey: params.newAccountPubkey,\n                isSigner: false,\n                isWritable: true\n            }\n        ];\n        if (params.basePubkey != params.fromPubkey) {\n            keys.push({\n                pubkey: params.basePubkey,\n                isSigner: true,\n                isWritable: false\n            });\n        }\n        return new TransactionInstruction({\n            keys,\n            programId: this.programId,\n            data\n        });\n    }\n    /**\n   * Generate a transaction that creates a new Nonce account\n   */ static createNonceAccount(params) {\n        const transaction = new Transaction();\n        if (\"basePubkey\" in params && \"seed\" in params) {\n            transaction.add(SystemProgram.createAccountWithSeed({\n                fromPubkey: params.fromPubkey,\n                newAccountPubkey: params.noncePubkey,\n                basePubkey: params.basePubkey,\n                seed: params.seed,\n                lamports: params.lamports,\n                space: NONCE_ACCOUNT_LENGTH,\n                programId: this.programId\n            }));\n        } else {\n            transaction.add(SystemProgram.createAccount({\n                fromPubkey: params.fromPubkey,\n                newAccountPubkey: params.noncePubkey,\n                lamports: params.lamports,\n                space: NONCE_ACCOUNT_LENGTH,\n                programId: this.programId\n            }));\n        }\n        const initParams = {\n            noncePubkey: params.noncePubkey,\n            authorizedPubkey: params.authorizedPubkey\n        };\n        transaction.add(this.nonceInitialize(initParams));\n        return transaction;\n    }\n    /**\n   * Generate an instruction to initialize a Nonce account\n   */ static nonceInitialize(params) {\n        const type = SYSTEM_INSTRUCTION_LAYOUTS.InitializeNonceAccount;\n        const data = encodeData(type, {\n            authorized: toBuffer(params.authorizedPubkey.toBuffer())\n        });\n        const instructionData = {\n            keys: [\n                {\n                    pubkey: params.noncePubkey,\n                    isSigner: false,\n                    isWritable: true\n                },\n                {\n                    pubkey: SYSVAR_RECENT_BLOCKHASHES_PUBKEY,\n                    isSigner: false,\n                    isWritable: false\n                },\n                {\n                    pubkey: SYSVAR_RENT_PUBKEY,\n                    isSigner: false,\n                    isWritable: false\n                }\n            ],\n            programId: this.programId,\n            data\n        };\n        return new TransactionInstruction(instructionData);\n    }\n    /**\n   * Generate an instruction to advance the nonce in a Nonce account\n   */ static nonceAdvance(params) {\n        const type = SYSTEM_INSTRUCTION_LAYOUTS.AdvanceNonceAccount;\n        const data = encodeData(type);\n        const instructionData = {\n            keys: [\n                {\n                    pubkey: params.noncePubkey,\n                    isSigner: false,\n                    isWritable: true\n                },\n                {\n                    pubkey: SYSVAR_RECENT_BLOCKHASHES_PUBKEY,\n                    isSigner: false,\n                    isWritable: false\n                },\n                {\n                    pubkey: params.authorizedPubkey,\n                    isSigner: true,\n                    isWritable: false\n                }\n            ],\n            programId: this.programId,\n            data\n        };\n        return new TransactionInstruction(instructionData);\n    }\n    /**\n   * Generate a transaction instruction that withdraws lamports from a Nonce account\n   */ static nonceWithdraw(params) {\n        const type = SYSTEM_INSTRUCTION_LAYOUTS.WithdrawNonceAccount;\n        const data = encodeData(type, {\n            lamports: params.lamports\n        });\n        return new TransactionInstruction({\n            keys: [\n                {\n                    pubkey: params.noncePubkey,\n                    isSigner: false,\n                    isWritable: true\n                },\n                {\n                    pubkey: params.toPubkey,\n                    isSigner: false,\n                    isWritable: true\n                },\n                {\n                    pubkey: SYSVAR_RECENT_BLOCKHASHES_PUBKEY,\n                    isSigner: false,\n                    isWritable: false\n                },\n                {\n                    pubkey: SYSVAR_RENT_PUBKEY,\n                    isSigner: false,\n                    isWritable: false\n                },\n                {\n                    pubkey: params.authorizedPubkey,\n                    isSigner: true,\n                    isWritable: false\n                }\n            ],\n            programId: this.programId,\n            data\n        });\n    }\n    /**\n   * Generate a transaction instruction that authorizes a new PublicKey as the authority\n   * on a Nonce account.\n   */ static nonceAuthorize(params) {\n        const type = SYSTEM_INSTRUCTION_LAYOUTS.AuthorizeNonceAccount;\n        const data = encodeData(type, {\n            authorized: toBuffer(params.newAuthorizedPubkey.toBuffer())\n        });\n        return new TransactionInstruction({\n            keys: [\n                {\n                    pubkey: params.noncePubkey,\n                    isSigner: false,\n                    isWritable: true\n                },\n                {\n                    pubkey: params.authorizedPubkey,\n                    isSigner: true,\n                    isWritable: false\n                }\n            ],\n            programId: this.programId,\n            data\n        });\n    }\n    /**\n   * Generate a transaction instruction that allocates space in an account without funding\n   */ static allocate(params) {\n        let data;\n        let keys;\n        if (\"basePubkey\" in params) {\n            const type = SYSTEM_INSTRUCTION_LAYOUTS.AllocateWithSeed;\n            data = encodeData(type, {\n                base: toBuffer(params.basePubkey.toBuffer()),\n                seed: params.seed,\n                space: params.space,\n                programId: toBuffer(params.programId.toBuffer())\n            });\n            keys = [\n                {\n                    pubkey: params.accountPubkey,\n                    isSigner: false,\n                    isWritable: true\n                },\n                {\n                    pubkey: params.basePubkey,\n                    isSigner: true,\n                    isWritable: false\n                }\n            ];\n        } else {\n            const type = SYSTEM_INSTRUCTION_LAYOUTS.Allocate;\n            data = encodeData(type, {\n                space: params.space\n            });\n            keys = [\n                {\n                    pubkey: params.accountPubkey,\n                    isSigner: true,\n                    isWritable: true\n                }\n            ];\n        }\n        return new TransactionInstruction({\n            keys,\n            programId: this.programId,\n            data\n        });\n    }\n}\nSystemProgram.programId = new PublicKey(\"11111111111111111111111111111111\");\n// Keep program chunks under PACKET_DATA_SIZE, leaving enough room for the\n// rest of the Transaction fields\n//\n// TODO: replace 300 with a proper constant for the size of the other\n// Transaction fields\nconst CHUNK_SIZE = PACKET_DATA_SIZE - 300;\n/**\n * Program loader interface\n */ class Loader {\n    /**\n   * @internal\n   */ constructor(){}\n    /**\n   * Amount of program data placed in each load Transaction\n   */ /**\n   * Minimum number of signatures required to load a program not including\n   * retries\n   *\n   * Can be used to calculate transaction fees\n   */ static getMinNumSignatures(dataLength) {\n        return 2 * // Every transaction requires two signatures (payer + program)\n        (Math.ceil(dataLength / Loader.chunkSize) + 1 + // Add one for Create transaction\n        1 // Add one for Finalize transaction\n        );\n    }\n    /**\n   * Loads a generic program\n   *\n   * @param connection The connection to use\n   * @param payer System account that pays to load the program\n   * @param program Account to load the program into\n   * @param programId Public key that identifies the loader\n   * @param data Program octets\n   * @return true if program was loaded successfully, false if program was already loaded\n   */ static async load(connection, payer, program, programId, data) {\n        {\n            const balanceNeeded = await connection.getMinimumBalanceForRentExemption(data.length);\n            // Fetch program account info to check if it has already been created\n            const programInfo = await connection.getAccountInfo(program.publicKey, \"confirmed\");\n            let transaction = null;\n            if (programInfo !== null) {\n                if (programInfo.executable) {\n                    console.error(\"Program load failed, account is already executable\");\n                    return false;\n                }\n                if (programInfo.data.length !== data.length) {\n                    transaction = transaction || new Transaction();\n                    transaction.add(SystemProgram.allocate({\n                        accountPubkey: program.publicKey,\n                        space: data.length\n                    }));\n                }\n                if (!programInfo.owner.equals(programId)) {\n                    transaction = transaction || new Transaction();\n                    transaction.add(SystemProgram.assign({\n                        accountPubkey: program.publicKey,\n                        programId\n                    }));\n                }\n                if (programInfo.lamports < balanceNeeded) {\n                    transaction = transaction || new Transaction();\n                    transaction.add(SystemProgram.transfer({\n                        fromPubkey: payer.publicKey,\n                        toPubkey: program.publicKey,\n                        lamports: balanceNeeded - programInfo.lamports\n                    }));\n                }\n            } else {\n                transaction = new Transaction().add(SystemProgram.createAccount({\n                    fromPubkey: payer.publicKey,\n                    newAccountPubkey: program.publicKey,\n                    lamports: balanceNeeded > 0 ? balanceNeeded : 1,\n                    space: data.length,\n                    programId\n                }));\n            }\n            // If the account is already created correctly, skip this step\n            // and proceed directly to loading instructions\n            if (transaction !== null) {\n                await sendAndConfirmTransaction(connection, transaction, [\n                    payer,\n                    program\n                ], {\n                    commitment: \"confirmed\"\n                });\n            }\n        }\n        const dataLayout = _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.struct([\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u32(\"instruction\"),\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u32(\"offset\"),\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u32(\"bytesLength\"),\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u32(\"bytesLengthPadding\"),\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.seq(_solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u8(\"byte\"), _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.offset(_solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u32(), -8), \"bytes\")\n        ]);\n        const chunkSize = Loader.chunkSize;\n        let offset = 0;\n        let array = data;\n        let transactions = [];\n        while(array.length > 0){\n            const bytes = array.slice(0, chunkSize);\n            const data = buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.alloc(chunkSize + 16);\n            dataLayout.encode({\n                instruction: 0,\n                // Load instruction\n                offset,\n                bytes: bytes,\n                bytesLength: 0,\n                bytesLengthPadding: 0\n            }, data);\n            const transaction = new Transaction().add({\n                keys: [\n                    {\n                        pubkey: program.publicKey,\n                        isSigner: true,\n                        isWritable: true\n                    }\n                ],\n                programId,\n                data\n            });\n            transactions.push(sendAndConfirmTransaction(connection, transaction, [\n                payer,\n                program\n            ], {\n                commitment: \"confirmed\"\n            }));\n            // Delay between sends in an attempt to reduce rate limit errors\n            if (connection._rpcEndpoint.includes(\"solana.com\")) {\n                const REQUESTS_PER_SECOND = 4;\n                await sleep(1000 / REQUESTS_PER_SECOND);\n            }\n            offset += chunkSize;\n            array = array.slice(chunkSize);\n        }\n        await Promise.all(transactions);\n        // Finalize the account loaded with program data for execution\n        {\n            const dataLayout = _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.struct([\n                _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u32(\"instruction\")\n            ]);\n            const data = buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.alloc(dataLayout.span);\n            dataLayout.encode({\n                instruction: 1 // Finalize instruction\n            }, data);\n            const transaction = new Transaction().add({\n                keys: [\n                    {\n                        pubkey: program.publicKey,\n                        isSigner: true,\n                        isWritable: true\n                    },\n                    {\n                        pubkey: SYSVAR_RENT_PUBKEY,\n                        isSigner: false,\n                        isWritable: false\n                    }\n                ],\n                programId,\n                data\n            });\n            const deployCommitment = \"processed\";\n            const finalizeSignature = await connection.sendTransaction(transaction, [\n                payer,\n                program\n            ], {\n                preflightCommitment: deployCommitment\n            });\n            const { context, value } = await connection.confirmTransaction({\n                signature: finalizeSignature,\n                lastValidBlockHeight: transaction.lastValidBlockHeight,\n                blockhash: transaction.recentBlockhash\n            }, deployCommitment);\n            if (value.err) {\n                throw new Error(`Transaction ${finalizeSignature} failed (${JSON.stringify(value)})`);\n            }\n            // We prevent programs from being usable until the slot after their deployment.\n            // See https://github.com/solana-labs/solana/pull/29654\n            while(true // eslint-disable-line no-constant-condition\n            ){\n                try {\n                    const currentSlot = await connection.getSlot({\n                        commitment: deployCommitment\n                    });\n                    if (currentSlot > context.slot) {\n                        break;\n                    }\n                } catch  {\n                /* empty */ }\n                await new Promise((resolve)=>setTimeout(resolve, Math.round(MS_PER_SLOT / 2)));\n            }\n        }\n        // success\n        return true;\n    }\n}\nLoader.chunkSize = CHUNK_SIZE;\n/**\n * @deprecated Deprecated since Solana v1.17.20.\n */ const BPF_LOADER_PROGRAM_ID = new PublicKey(\"BPFLoader2111111111111111111111111111111111\");\n/**\n * Factory class for transactions to interact with a program loader\n *\n * @deprecated Deprecated since Solana v1.17.20.\n */ class BpfLoader {\n    /**\n   * Minimum number of signatures required to load a program not including\n   * retries\n   *\n   * Can be used to calculate transaction fees\n   */ static getMinNumSignatures(dataLength) {\n        return Loader.getMinNumSignatures(dataLength);\n    }\n    /**\n   * Load a SBF program\n   *\n   * @param connection The connection to use\n   * @param payer Account that will pay program loading fees\n   * @param program Account to load the program into\n   * @param elf The entire ELF containing the SBF program\n   * @param loaderProgramId The program id of the BPF loader to use\n   * @return true if program was loaded successfully, false if program was already loaded\n   */ static load(connection, payer, program, elf, loaderProgramId) {\n        return Loader.load(connection, payer, program, loaderProgramId, elf);\n    }\n}\nfunction getDefaultExportFromCjs(x) {\n    return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, \"default\") ? x[\"default\"] : x;\n}\nvar agentkeepalive = {\n    exports: {}\n};\n/**\n * Helpers.\n */ var s = 1000;\nvar m = s * 60;\nvar h = m * 60;\nvar d = h * 24;\nvar w = d * 7;\nvar y = d * 365.25;\n/**\n * Parse or format the given `val`.\n *\n * Options:\n *\n *  - `long` verbose formatting [false]\n *\n * @param {String|Number} val\n * @param {Object} [options]\n * @throws {Error} throw an error if val is not a non-empty string or a number\n * @return {String|Number}\n * @api public\n */ var ms$2 = function(val, options) {\n    options = options || {};\n    var type = typeof val;\n    if (type === \"string\" && val.length > 0) {\n        return parse(val);\n    } else if (type === \"number\" && isFinite(val)) {\n        return options.long ? fmtLong(val) : fmtShort(val);\n    }\n    throw new Error(\"val is not a non-empty string or a valid number. val=\" + JSON.stringify(val));\n};\n/**\n * Parse the given `str` and return milliseconds.\n *\n * @param {String} str\n * @return {Number}\n * @api private\n */ function parse(str) {\n    str = String(str);\n    if (str.length > 100) {\n        return;\n    }\n    var match = /^(-?(?:\\d+)?\\.?\\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(str);\n    if (!match) {\n        return;\n    }\n    var n = parseFloat(match[1]);\n    var type = (match[2] || \"ms\").toLowerCase();\n    switch(type){\n        case \"years\":\n        case \"year\":\n        case \"yrs\":\n        case \"yr\":\n        case \"y\":\n            return n * y;\n        case \"weeks\":\n        case \"week\":\n        case \"w\":\n            return n * w;\n        case \"days\":\n        case \"day\":\n        case \"d\":\n            return n * d;\n        case \"hours\":\n        case \"hour\":\n        case \"hrs\":\n        case \"hr\":\n        case \"h\":\n            return n * h;\n        case \"minutes\":\n        case \"minute\":\n        case \"mins\":\n        case \"min\":\n        case \"m\":\n            return n * m;\n        case \"seconds\":\n        case \"second\":\n        case \"secs\":\n        case \"sec\":\n        case \"s\":\n            return n * s;\n        case \"milliseconds\":\n        case \"millisecond\":\n        case \"msecs\":\n        case \"msec\":\n        case \"ms\":\n            return n;\n        default:\n            return undefined;\n    }\n}\n/**\n * Short format for `ms`.\n *\n * @param {Number} ms\n * @return {String}\n * @api private\n */ function fmtShort(ms) {\n    var msAbs = Math.abs(ms);\n    if (msAbs >= d) {\n        return Math.round(ms / d) + \"d\";\n    }\n    if (msAbs >= h) {\n        return Math.round(ms / h) + \"h\";\n    }\n    if (msAbs >= m) {\n        return Math.round(ms / m) + \"m\";\n    }\n    if (msAbs >= s) {\n        return Math.round(ms / s) + \"s\";\n    }\n    return ms + \"ms\";\n}\n/**\n * Long format for `ms`.\n *\n * @param {Number} ms\n * @return {String}\n * @api private\n */ function fmtLong(ms) {\n    var msAbs = Math.abs(ms);\n    if (msAbs >= d) {\n        return plural(ms, msAbs, d, \"day\");\n    }\n    if (msAbs >= h) {\n        return plural(ms, msAbs, h, \"hour\");\n    }\n    if (msAbs >= m) {\n        return plural(ms, msAbs, m, \"minute\");\n    }\n    if (msAbs >= s) {\n        return plural(ms, msAbs, s, \"second\");\n    }\n    return ms + \" ms\";\n}\n/**\n * Pluralization helper.\n */ function plural(ms, msAbs, n, name) {\n    var isPlural = msAbs >= n * 1.5;\n    return Math.round(ms / n) + \" \" + name + (isPlural ? \"s\" : \"\");\n}\n/*!\n * humanize-ms - index.js\n * Copyright(c) 2014 dead_horse <dead_horse@qq.com>\n * MIT Licensed\n */ /**\n * Module dependencies.\n */ var util = (util__WEBPACK_IMPORTED_MODULE_6___default());\nvar ms$1 = ms$2;\nvar humanizeMs = function(t) {\n    if (typeof t === \"number\") return t;\n    var r = ms$1(t);\n    if (r === undefined) {\n        var err = new Error(util.format(\"humanize-ms(%j) result undefined\", t));\n        console.warn(err.stack);\n    }\n    return r;\n};\nvar constants = {\n    // agent\n    CURRENT_ID: Symbol(\"agentkeepalive#currentId\"),\n    CREATE_ID: Symbol(\"agentkeepalive#createId\"),\n    INIT_SOCKET: Symbol(\"agentkeepalive#initSocket\"),\n    CREATE_HTTPS_CONNECTION: Symbol(\"agentkeepalive#createHttpsConnection\"),\n    // socket\n    SOCKET_CREATED_TIME: Symbol(\"agentkeepalive#socketCreatedTime\"),\n    SOCKET_NAME: Symbol(\"agentkeepalive#socketName\"),\n    SOCKET_REQUEST_COUNT: Symbol(\"agentkeepalive#socketRequestCount\"),\n    SOCKET_REQUEST_FINISHED_COUNT: Symbol(\"agentkeepalive#socketRequestFinishedCount\")\n};\nconst OriginalAgent = (http__WEBPACK_IMPORTED_MODULE_7___default().Agent);\nconst ms = humanizeMs;\nconst debug = util__WEBPACK_IMPORTED_MODULE_6___default().debuglog(\"agentkeepalive\");\nconst { INIT_SOCKET: INIT_SOCKET$1, CURRENT_ID, CREATE_ID, SOCKET_CREATED_TIME, SOCKET_NAME, SOCKET_REQUEST_COUNT, SOCKET_REQUEST_FINISHED_COUNT } = constants;\n// OriginalAgent come from\n// - https://github.com/nodejs/node/blob/v8.12.0/lib/_http_agent.js\n// - https://github.com/nodejs/node/blob/v10.12.0/lib/_http_agent.js\n// node <= 10\nlet defaultTimeoutListenerCount = 1;\nconst majorVersion = parseInt(process.version.split(\".\", 1)[0].substring(1));\nif (majorVersion >= 11 && majorVersion <= 12) {\n    defaultTimeoutListenerCount = 2;\n} else if (majorVersion >= 13) {\n    defaultTimeoutListenerCount = 3;\n}\nfunction deprecate(message) {\n    console.log(\"[agentkeepalive:deprecated] %s\", message);\n}\nclass Agent extends OriginalAgent {\n    constructor(options){\n        options = options || {};\n        options.keepAlive = options.keepAlive !== false;\n        // default is keep-alive and 4s free socket timeout\n        // see https://medium.com/ssense-tech/reduce-networking-errors-in-nodejs-23b4eb9f2d83\n        if (options.freeSocketTimeout === undefined) {\n            options.freeSocketTimeout = 4000;\n        }\n        // Legacy API: keepAliveTimeout should be rename to `freeSocketTimeout`\n        if (options.keepAliveTimeout) {\n            deprecate(\"options.keepAliveTimeout is deprecated, please use options.freeSocketTimeout instead\");\n            options.freeSocketTimeout = options.keepAliveTimeout;\n            delete options.keepAliveTimeout;\n        }\n        // Legacy API: freeSocketKeepAliveTimeout should be rename to `freeSocketTimeout`\n        if (options.freeSocketKeepAliveTimeout) {\n            deprecate(\"options.freeSocketKeepAliveTimeout is deprecated, please use options.freeSocketTimeout instead\");\n            options.freeSocketTimeout = options.freeSocketKeepAliveTimeout;\n            delete options.freeSocketKeepAliveTimeout;\n        }\n        // Sets the socket to timeout after timeout milliseconds of inactivity on the socket.\n        // By default is double free socket timeout.\n        if (options.timeout === undefined) {\n            // make sure socket default inactivity timeout >= 8s\n            options.timeout = Math.max(options.freeSocketTimeout * 2, 8000);\n        }\n        // support humanize format\n        options.timeout = ms(options.timeout);\n        options.freeSocketTimeout = ms(options.freeSocketTimeout);\n        options.socketActiveTTL = options.socketActiveTTL ? ms(options.socketActiveTTL) : 0;\n        super(options);\n        this[CURRENT_ID] = 0;\n        // create socket success counter\n        this.createSocketCount = 0;\n        this.createSocketCountLastCheck = 0;\n        this.createSocketErrorCount = 0;\n        this.createSocketErrorCountLastCheck = 0;\n        this.closeSocketCount = 0;\n        this.closeSocketCountLastCheck = 0;\n        // socket error event count\n        this.errorSocketCount = 0;\n        this.errorSocketCountLastCheck = 0;\n        // request finished counter\n        this.requestCount = 0;\n        this.requestCountLastCheck = 0;\n        // including free socket timeout counter\n        this.timeoutSocketCount = 0;\n        this.timeoutSocketCountLastCheck = 0;\n        this.on(\"free\", (socket)=>{\n            // https://github.com/nodejs/node/pull/32000\n            // Node.js native agent will check socket timeout eqs agent.options.timeout.\n            // Use the ttl or freeSocketTimeout to overwrite.\n            const timeout = this.calcSocketTimeout(socket);\n            if (timeout > 0 && socket.timeout !== timeout) {\n                socket.setTimeout(timeout);\n            }\n        });\n    }\n    get freeSocketKeepAliveTimeout() {\n        deprecate(\"agent.freeSocketKeepAliveTimeout is deprecated, please use agent.options.freeSocketTimeout instead\");\n        return this.options.freeSocketTimeout;\n    }\n    get timeout() {\n        deprecate(\"agent.timeout is deprecated, please use agent.options.timeout instead\");\n        return this.options.timeout;\n    }\n    get socketActiveTTL() {\n        deprecate(\"agent.socketActiveTTL is deprecated, please use agent.options.socketActiveTTL instead\");\n        return this.options.socketActiveTTL;\n    }\n    calcSocketTimeout(socket) {\n        /**\n     * return <= 0: should free socket\n     * return > 0: should update socket timeout\n     * return undefined: not find custom timeout\n     */ let freeSocketTimeout = this.options.freeSocketTimeout;\n        const socketActiveTTL = this.options.socketActiveTTL;\n        if (socketActiveTTL) {\n            // check socketActiveTTL\n            const aliveTime = Date.now() - socket[SOCKET_CREATED_TIME];\n            const diff = socketActiveTTL - aliveTime;\n            if (diff <= 0) {\n                return diff;\n            }\n            if (freeSocketTimeout && diff < freeSocketTimeout) {\n                freeSocketTimeout = diff;\n            }\n        }\n        // set freeSocketTimeout\n        if (freeSocketTimeout) {\n            // set free keepalive timer\n            // try to use socket custom freeSocketTimeout first, support headers['keep-alive']\n            // https://github.com/node-modules/urllib/blob/b76053020923f4d99a1c93cf2e16e0c5ba10bacf/lib/urllib.js#L498\n            const customFreeSocketTimeout = socket.freeSocketTimeout || socket.freeSocketKeepAliveTimeout;\n            return customFreeSocketTimeout || freeSocketTimeout;\n        }\n    }\n    keepSocketAlive(socket) {\n        const result = super.keepSocketAlive(socket);\n        // should not keepAlive, do nothing\n        if (!result) return result;\n        const customTimeout = this.calcSocketTimeout(socket);\n        if (typeof customTimeout === \"undefined\") {\n            return true;\n        }\n        if (customTimeout <= 0) {\n            debug(\"%s(requests: %s, finished: %s) free but need to destroy by TTL, request count %s, diff is %s\", socket[SOCKET_NAME], socket[SOCKET_REQUEST_COUNT], socket[SOCKET_REQUEST_FINISHED_COUNT], customTimeout);\n            return false;\n        }\n        if (socket.timeout !== customTimeout) {\n            socket.setTimeout(customTimeout);\n        }\n        return true;\n    }\n    // only call on addRequest\n    reuseSocket(...args) {\n        // reuseSocket(socket, req)\n        super.reuseSocket(...args);\n        const socket = args[0];\n        const req = args[1];\n        req.reusedSocket = true;\n        const agentTimeout = this.options.timeout;\n        if (getSocketTimeout(socket) !== agentTimeout) {\n            // reset timeout before use\n            socket.setTimeout(agentTimeout);\n            debug(\"%s reset timeout to %sms\", socket[SOCKET_NAME], agentTimeout);\n        }\n        socket[SOCKET_REQUEST_COUNT]++;\n        debug(\"%s(requests: %s, finished: %s) reuse on addRequest, timeout %sms\", socket[SOCKET_NAME], socket[SOCKET_REQUEST_COUNT], socket[SOCKET_REQUEST_FINISHED_COUNT], getSocketTimeout(socket));\n    }\n    [CREATE_ID]() {\n        const id = this[CURRENT_ID]++;\n        if (this[CURRENT_ID] === Number.MAX_SAFE_INTEGER) this[CURRENT_ID] = 0;\n        return id;\n    }\n    [INIT_SOCKET$1](socket, options) {\n        // bugfix here.\n        // https on node 8, 10 won't set agent.options.timeout by default\n        // TODO: need to fix on node itself\n        if (options.timeout) {\n            const timeout = getSocketTimeout(socket);\n            if (!timeout) {\n                socket.setTimeout(options.timeout);\n            }\n        }\n        if (this.options.keepAlive) {\n            // Disable Nagle's algorithm: http://blog.caustik.com/2012/04/08/scaling-node-js-to-100k-concurrent-connections/\n            // https://fengmk2.com/benchmark/nagle-algorithm-delayed-ack-mock.html\n            socket.setNoDelay(true);\n        }\n        this.createSocketCount++;\n        if (this.options.socketActiveTTL) {\n            socket[SOCKET_CREATED_TIME] = Date.now();\n        }\n        // don't show the hole '-----BEGIN CERTIFICATE----' key string\n        socket[SOCKET_NAME] = `sock[${this[CREATE_ID]()}#${options._agentKey}]`.split(\"-----BEGIN\", 1)[0];\n        socket[SOCKET_REQUEST_COUNT] = 1;\n        socket[SOCKET_REQUEST_FINISHED_COUNT] = 0;\n        installListeners(this, socket, options);\n    }\n    createConnection(options, oncreate) {\n        let called = false;\n        const onNewCreate = (err, socket)=>{\n            if (called) return;\n            called = true;\n            if (err) {\n                this.createSocketErrorCount++;\n                return oncreate(err);\n            }\n            this[INIT_SOCKET$1](socket, options);\n            oncreate(err, socket);\n        };\n        const newSocket = super.createConnection(options, onNewCreate);\n        if (newSocket) onNewCreate(null, newSocket);\n        return newSocket;\n    }\n    get statusChanged() {\n        const changed = this.createSocketCount !== this.createSocketCountLastCheck || this.createSocketErrorCount !== this.createSocketErrorCountLastCheck || this.closeSocketCount !== this.closeSocketCountLastCheck || this.errorSocketCount !== this.errorSocketCountLastCheck || this.timeoutSocketCount !== this.timeoutSocketCountLastCheck || this.requestCount !== this.requestCountLastCheck;\n        if (changed) {\n            this.createSocketCountLastCheck = this.createSocketCount;\n            this.createSocketErrorCountLastCheck = this.createSocketErrorCount;\n            this.closeSocketCountLastCheck = this.closeSocketCount;\n            this.errorSocketCountLastCheck = this.errorSocketCount;\n            this.timeoutSocketCountLastCheck = this.timeoutSocketCount;\n            this.requestCountLastCheck = this.requestCount;\n        }\n        return changed;\n    }\n    getCurrentStatus() {\n        return {\n            createSocketCount: this.createSocketCount,\n            createSocketErrorCount: this.createSocketErrorCount,\n            closeSocketCount: this.closeSocketCount,\n            errorSocketCount: this.errorSocketCount,\n            timeoutSocketCount: this.timeoutSocketCount,\n            requestCount: this.requestCount,\n            freeSockets: inspect(this.freeSockets),\n            sockets: inspect(this.sockets),\n            requests: inspect(this.requests)\n        };\n    }\n}\n// node 8 don't has timeout attribute on socket\n// https://github.com/nodejs/node/pull/21204/files#diff-e6ef024c3775d787c38487a6309e491dR408\nfunction getSocketTimeout(socket) {\n    return socket.timeout || socket._idleTimeout;\n}\nfunction installListeners(agent, socket, options) {\n    debug(\"%s create, timeout %sms\", socket[SOCKET_NAME], getSocketTimeout(socket));\n    // listener socket events: close, timeout, error, free\n    function onFree() {\n        // create and socket.emit('free') logic\n        // https://github.com/nodejs/node/blob/master/lib/_http_agent.js#L311\n        // no req on the socket, it should be the new socket\n        if (!socket._httpMessage && socket[SOCKET_REQUEST_COUNT] === 1) return;\n        socket[SOCKET_REQUEST_FINISHED_COUNT]++;\n        agent.requestCount++;\n        debug(\"%s(requests: %s, finished: %s) free\", socket[SOCKET_NAME], socket[SOCKET_REQUEST_COUNT], socket[SOCKET_REQUEST_FINISHED_COUNT]);\n        // should reuse on pedding requests?\n        const name = agent.getName(options);\n        if (socket.writable && agent.requests[name] && agent.requests[name].length) {\n            // will be reuse on agent free listener\n            socket[SOCKET_REQUEST_COUNT]++;\n            debug(\"%s(requests: %s, finished: %s) will be reuse on agent free event\", socket[SOCKET_NAME], socket[SOCKET_REQUEST_COUNT], socket[SOCKET_REQUEST_FINISHED_COUNT]);\n        }\n    }\n    socket.on(\"free\", onFree);\n    function onClose(isError) {\n        debug(\"%s(requests: %s, finished: %s) close, isError: %s\", socket[SOCKET_NAME], socket[SOCKET_REQUEST_COUNT], socket[SOCKET_REQUEST_FINISHED_COUNT], isError);\n        agent.closeSocketCount++;\n    }\n    socket.on(\"close\", onClose);\n    // start socket timeout handler\n    function onTimeout() {\n        // onTimeout and emitRequestTimeout(_http_client.js)\n        // https://github.com/nodejs/node/blob/v12.x/lib/_http_client.js#L711\n        const listenerCount = socket.listeners(\"timeout\").length;\n        // node <= 10, default listenerCount is 1, onTimeout\n        // 11 < node <= 12, default listenerCount is 2, onTimeout and emitRequestTimeout\n        // node >= 13, default listenerCount is 3, onTimeout,\n        //   onTimeout(https://github.com/nodejs/node/pull/32000/files#diff-5f7fb0850412c6be189faeddea6c5359R333)\n        //   and emitRequestTimeout\n        const timeout = getSocketTimeout(socket);\n        const req = socket._httpMessage;\n        const reqTimeoutListenerCount = req && req.listeners(\"timeout\").length || 0;\n        debug(\"%s(requests: %s, finished: %s) timeout after %sms, listeners %s, defaultTimeoutListenerCount %s, hasHttpRequest %s, HttpRequest timeoutListenerCount %s\", socket[SOCKET_NAME], socket[SOCKET_REQUEST_COUNT], socket[SOCKET_REQUEST_FINISHED_COUNT], timeout, listenerCount, defaultTimeoutListenerCount, !!req, reqTimeoutListenerCount);\n        if (debug.enabled) {\n            debug(\"timeout listeners: %s\", socket.listeners(\"timeout\").map((f)=>f.name).join(\", \"));\n        }\n        agent.timeoutSocketCount++;\n        const name = agent.getName(options);\n        if (agent.freeSockets[name] && agent.freeSockets[name].indexOf(socket) !== -1) {\n            // free socket timeout, destroy quietly\n            socket.destroy();\n            // Remove it from freeSockets list immediately to prevent new requests\n            // from being sent through this socket.\n            agent.removeSocket(socket, options);\n            debug(\"%s is free, destroy quietly\", socket[SOCKET_NAME]);\n        } else {\n            // if there is no any request socket timeout handler,\n            // agent need to handle socket timeout itself.\n            //\n            // custom request socket timeout handle logic must follow these rules:\n            //  1. Destroy socket first\n            //  2. Must emit socket 'agentRemove' event tell agent remove socket\n            //     from freeSockets list immediately.\n            //     Otherise you may be get 'socket hang up' error when reuse\n            //     free socket and timeout happen in the same time.\n            if (reqTimeoutListenerCount === 0) {\n                const error = new Error(\"Socket timeout\");\n                error.code = \"ERR_SOCKET_TIMEOUT\";\n                error.timeout = timeout;\n                // must manually call socket.end() or socket.destroy() to end the connection.\n                // https://nodejs.org/dist/latest-v10.x/docs/api/net.html#net_socket_settimeout_timeout_callback\n                socket.destroy(error);\n                agent.removeSocket(socket, options);\n                debug(\"%s destroy with timeout error\", socket[SOCKET_NAME]);\n            }\n        }\n    }\n    socket.on(\"timeout\", onTimeout);\n    function onError(err) {\n        const listenerCount = socket.listeners(\"error\").length;\n        debug(\"%s(requests: %s, finished: %s) error: %s, listenerCount: %s\", socket[SOCKET_NAME], socket[SOCKET_REQUEST_COUNT], socket[SOCKET_REQUEST_FINISHED_COUNT], err, listenerCount);\n        agent.errorSocketCount++;\n        if (listenerCount === 1) {\n            // if socket don't contain error event handler, don't catch it, emit it again\n            debug(\"%s emit uncaught error event\", socket[SOCKET_NAME]);\n            socket.removeListener(\"error\", onError);\n            socket.emit(\"error\", err);\n        }\n    }\n    socket.on(\"error\", onError);\n    function onRemove() {\n        debug(\"%s(requests: %s, finished: %s) agentRemove\", socket[SOCKET_NAME], socket[SOCKET_REQUEST_COUNT], socket[SOCKET_REQUEST_FINISHED_COUNT]);\n        // We need this function for cases like HTTP 'upgrade'\n        // (defined by WebSockets) where we need to remove a socket from the\n        // pool because it'll be locked up indefinitely\n        socket.removeListener(\"close\", onClose);\n        socket.removeListener(\"error\", onError);\n        socket.removeListener(\"free\", onFree);\n        socket.removeListener(\"timeout\", onTimeout);\n        socket.removeListener(\"agentRemove\", onRemove);\n    }\n    socket.on(\"agentRemove\", onRemove);\n}\nvar agent = Agent;\nfunction inspect(obj) {\n    const res = {};\n    for(const key in obj){\n        res[key] = obj[key].length;\n    }\n    return res;\n}\nconst OriginalHttpsAgent = (https__WEBPACK_IMPORTED_MODULE_8___default().Agent);\nconst HttpAgent = agent;\nconst { INIT_SOCKET, CREATE_HTTPS_CONNECTION } = constants;\nlet HttpsAgent$1 = class HttpsAgent extends HttpAgent {\n    constructor(options){\n        super(options);\n        this.defaultPort = 443;\n        this.protocol = \"https:\";\n        this.maxCachedSessions = this.options.maxCachedSessions;\n        /* istanbul ignore next */ if (this.maxCachedSessions === undefined) {\n            this.maxCachedSessions = 100;\n        }\n        this._sessionCache = {\n            map: {},\n            list: []\n        };\n    }\n    createConnection(options, oncreate) {\n        const socket = this[CREATE_HTTPS_CONNECTION](options, oncreate);\n        this[INIT_SOCKET](socket, options);\n        return socket;\n    }\n};\n// https://github.com/nodejs/node/blob/master/lib/https.js#L89\nHttpsAgent$1.prototype[CREATE_HTTPS_CONNECTION] = OriginalHttpsAgent.prototype.createConnection;\n[\n    \"getName\",\n    \"_getSession\",\n    \"_cacheSession\",\n    // https://github.com/nodejs/node/pull/4982\n    \"_evictSession\"\n].forEach(function(method) {\n    /* istanbul ignore next */ if (typeof OriginalHttpsAgent.prototype[method] === \"function\") {\n        HttpsAgent$1.prototype[method] = OriginalHttpsAgent.prototype[method];\n    }\n});\nvar https_agent = HttpsAgent$1;\nagentkeepalive.exports = agent;\nvar HttpsAgent = agentkeepalive.exports.HttpsAgent = https_agent;\nagentkeepalive.exports.constants = constants;\nvar agentkeepaliveExports = agentkeepalive.exports;\nvar HttpKeepAliveAgent = /*@__PURE__*/ getDefaultExportFromCjs(agentkeepaliveExports);\nvar objToString = Object.prototype.toString;\nvar objKeys = Object.keys || function(obj) {\n    var keys = [];\n    for(var name in obj){\n        keys.push(name);\n    }\n    return keys;\n};\nfunction stringify(val, isArrayProp) {\n    var i, max, str, keys, key, propVal, toStr;\n    if (val === true) {\n        return \"true\";\n    }\n    if (val === false) {\n        return \"false\";\n    }\n    switch(typeof val){\n        case \"object\":\n            if (val === null) {\n                return null;\n            } else if (val.toJSON && typeof val.toJSON === \"function\") {\n                return stringify(val.toJSON(), isArrayProp);\n            } else {\n                toStr = objToString.call(val);\n                if (toStr === \"[object Array]\") {\n                    str = \"[\";\n                    max = val.length - 1;\n                    for(i = 0; i < max; i++){\n                        str += stringify(val[i], true) + \",\";\n                    }\n                    if (max > -1) {\n                        str += stringify(val[i], true);\n                    }\n                    return str + \"]\";\n                } else if (toStr === \"[object Object]\") {\n                    // only object is left\n                    keys = objKeys(val).sort();\n                    max = keys.length;\n                    str = \"\";\n                    i = 0;\n                    while(i < max){\n                        key = keys[i];\n                        propVal = stringify(val[key], false);\n                        if (propVal !== undefined) {\n                            if (str) {\n                                str += \",\";\n                            }\n                            str += JSON.stringify(key) + \":\" + propVal;\n                        }\n                        i++;\n                    }\n                    return \"{\" + str + \"}\";\n                } else {\n                    return JSON.stringify(val);\n                }\n            }\n        case \"function\":\n        case \"undefined\":\n            return isArrayProp ? null : undefined;\n        case \"string\":\n            return JSON.stringify(val);\n        default:\n            return isFinite(val) ? val : null;\n    }\n}\nvar fastStableStringify = function(val) {\n    var returnVal = stringify(val, false);\n    if (returnVal !== undefined) {\n        return \"\" + returnVal;\n    }\n};\nvar fastStableStringify$1 = /*@__PURE__*/ getDefaultExportFromCjs(fastStableStringify);\nconst MINIMUM_SLOT_PER_EPOCH = 32;\n// Returns the number of trailing zeros in the binary representation of self.\nfunction trailingZeros(n) {\n    let trailingZeros = 0;\n    while(n > 1){\n        n /= 2;\n        trailingZeros++;\n    }\n    return trailingZeros;\n}\n// Returns the smallest power of two greater than or equal to n\nfunction nextPowerOfTwo(n) {\n    if (n === 0) return 1;\n    n--;\n    n |= n >> 1;\n    n |= n >> 2;\n    n |= n >> 4;\n    n |= n >> 8;\n    n |= n >> 16;\n    n |= n >> 32;\n    return n + 1;\n}\n/**\n * Epoch schedule\n * (see https://docs.solana.com/terminology#epoch)\n * Can be retrieved with the {@link Connection.getEpochSchedule} method\n */ class EpochSchedule {\n    constructor(slotsPerEpoch, leaderScheduleSlotOffset, warmup, firstNormalEpoch, firstNormalSlot){\n        /** The maximum number of slots in each epoch */ this.slotsPerEpoch = void 0;\n        /** The number of slots before beginning of an epoch to calculate a leader schedule for that epoch */ this.leaderScheduleSlotOffset = void 0;\n        /** Indicates whether epochs start short and grow */ this.warmup = void 0;\n        /** The first epoch with `slotsPerEpoch` slots */ this.firstNormalEpoch = void 0;\n        /** The first slot of `firstNormalEpoch` */ this.firstNormalSlot = void 0;\n        this.slotsPerEpoch = slotsPerEpoch;\n        this.leaderScheduleSlotOffset = leaderScheduleSlotOffset;\n        this.warmup = warmup;\n        this.firstNormalEpoch = firstNormalEpoch;\n        this.firstNormalSlot = firstNormalSlot;\n    }\n    getEpoch(slot) {\n        return this.getEpochAndSlotIndex(slot)[0];\n    }\n    getEpochAndSlotIndex(slot) {\n        if (slot < this.firstNormalSlot) {\n            const epoch = trailingZeros(nextPowerOfTwo(slot + MINIMUM_SLOT_PER_EPOCH + 1)) - trailingZeros(MINIMUM_SLOT_PER_EPOCH) - 1;\n            const epochLen = this.getSlotsInEpoch(epoch);\n            const slotIndex = slot - (epochLen - MINIMUM_SLOT_PER_EPOCH);\n            return [\n                epoch,\n                slotIndex\n            ];\n        } else {\n            const normalSlotIndex = slot - this.firstNormalSlot;\n            const normalEpochIndex = Math.floor(normalSlotIndex / this.slotsPerEpoch);\n            const epoch = this.firstNormalEpoch + normalEpochIndex;\n            const slotIndex = normalSlotIndex % this.slotsPerEpoch;\n            return [\n                epoch,\n                slotIndex\n            ];\n        }\n    }\n    getFirstSlotInEpoch(epoch) {\n        if (epoch <= this.firstNormalEpoch) {\n            return (Math.pow(2, epoch) - 1) * MINIMUM_SLOT_PER_EPOCH;\n        } else {\n            return (epoch - this.firstNormalEpoch) * this.slotsPerEpoch + this.firstNormalSlot;\n        }\n    }\n    getLastSlotInEpoch(epoch) {\n        return this.getFirstSlotInEpoch(epoch) + this.getSlotsInEpoch(epoch) - 1;\n    }\n    getSlotsInEpoch(epoch) {\n        if (epoch < this.firstNormalEpoch) {\n            return Math.pow(2, epoch + trailingZeros(MINIMUM_SLOT_PER_EPOCH));\n        } else {\n            return this.slotsPerEpoch;\n        }\n    }\n}\nclass SendTransactionError extends Error {\n    constructor(message, logs){\n        super(message);\n        this.logs = void 0;\n        this.logs = logs;\n    }\n}\n// Keep in sync with client/src/rpc_custom_errors.rs\n// Typescript `enums` thwart tree-shaking. See https://bargsten.org/jsts/enums/\nconst SolanaJSONRPCErrorCode = {\n    JSON_RPC_SERVER_ERROR_BLOCK_CLEANED_UP: -32001,\n    JSON_RPC_SERVER_ERROR_SEND_TRANSACTION_PREFLIGHT_FAILURE: -32002,\n    JSON_RPC_SERVER_ERROR_TRANSACTION_SIGNATURE_VERIFICATION_FAILURE: -32003,\n    JSON_RPC_SERVER_ERROR_BLOCK_NOT_AVAILABLE: -32004,\n    JSON_RPC_SERVER_ERROR_NODE_UNHEALTHY: -32005,\n    JSON_RPC_SERVER_ERROR_TRANSACTION_PRECOMPILE_VERIFICATION_FAILURE: -32006,\n    JSON_RPC_SERVER_ERROR_SLOT_SKIPPED: -32007,\n    JSON_RPC_SERVER_ERROR_NO_SNAPSHOT: -32008,\n    JSON_RPC_SERVER_ERROR_LONG_TERM_STORAGE_SLOT_SKIPPED: -32009,\n    JSON_RPC_SERVER_ERROR_KEY_EXCLUDED_FROM_SECONDARY_INDEX: -32010,\n    JSON_RPC_SERVER_ERROR_TRANSACTION_HISTORY_NOT_AVAILABLE: -32011,\n    JSON_RPC_SCAN_ERROR: -32012,\n    JSON_RPC_SERVER_ERROR_TRANSACTION_SIGNATURE_LEN_MISMATCH: -32013,\n    JSON_RPC_SERVER_ERROR_BLOCK_STATUS_NOT_AVAILABLE_YET: -32014,\n    JSON_RPC_SERVER_ERROR_UNSUPPORTED_TRANSACTION_VERSION: -32015,\n    JSON_RPC_SERVER_ERROR_MIN_CONTEXT_SLOT_NOT_REACHED: -32016\n};\nclass SolanaJSONRPCError extends Error {\n    constructor({ code, message, data }, customMessage){\n        super(customMessage != null ? `${customMessage}: ${message}` : message);\n        this.code = void 0;\n        this.data = void 0;\n        this.code = code;\n        this.data = data;\n        this.name = \"SolanaJSONRPCError\";\n    }\n}\nvar fetchImpl = typeof globalThis.fetch === \"function\" ? // The Fetch API is supported experimentally in Node 17.5+ and natively in Node 18+.\nglobalThis.fetch : // Otherwise use the polyfill.\nasync function(input, init) {\n    const processedInput = typeof input === \"string\" && input.slice(0, 2) === \"//\" ? \"https:\" + input : input;\n    return await node_fetch__WEBPACK_IMPORTED_MODULE_10__[\"default\"](processedInput, init);\n};\nclass RpcWebSocketClient extends rpc_websockets_dist_lib_client_cjs__WEBPACK_IMPORTED_MODULE_11__[\"default\"] {\n    constructor(address, options, generate_request_id){\n        const webSocketFactory = (url)=>{\n            const rpc = rpc_websockets_dist_lib_client_websocket_cjs__WEBPACK_IMPORTED_MODULE_12___default()(url, {\n                autoconnect: true,\n                max_reconnects: 5,\n                reconnect: true,\n                reconnect_interval: 1000,\n                ...options\n            });\n            if (\"socket\" in rpc) {\n                this.underlyingSocket = rpc.socket;\n            } else {\n                this.underlyingSocket = rpc;\n            }\n            return rpc;\n        };\n        super(webSocketFactory, address, options, generate_request_id);\n        this.underlyingSocket = void 0;\n    }\n    call(...args) {\n        const readyState = this.underlyingSocket?.readyState;\n        if (readyState === 1 /* WebSocket.OPEN */ ) {\n            return super.call(...args);\n        }\n        return Promise.reject(new Error(\"Tried to call a JSON-RPC method `\" + args[0] + \"` but the socket was not `CONNECTING` or `OPEN` (`readyState` was \" + readyState + \")\"));\n    }\n    notify(...args) {\n        const readyState = this.underlyingSocket?.readyState;\n        if (readyState === 1 /* WebSocket.OPEN */ ) {\n            return super.notify(...args);\n        }\n        return Promise.reject(new Error(\"Tried to send a JSON-RPC notification `\" + args[0] + \"` but the socket was not `CONNECTING` or `OPEN` (`readyState` was \" + readyState + \")\"));\n    }\n}\n/**\n * @internal\n */ /**\n * Decode account data buffer using an AccountType\n * @internal\n */ function decodeData(type, data) {\n    let decoded;\n    try {\n        decoded = type.layout.decode(data);\n    } catch (err) {\n        throw new Error(\"invalid instruction; \" + err);\n    }\n    if (decoded.typeIndex !== type.index) {\n        throw new Error(`invalid account data; account type mismatch ${decoded.typeIndex} != ${type.index}`);\n    }\n    return decoded;\n}\n/// The serialized size of lookup table metadata\nconst LOOKUP_TABLE_META_SIZE = 56;\nclass AddressLookupTableAccount {\n    constructor(args){\n        this.key = void 0;\n        this.state = void 0;\n        this.key = args.key;\n        this.state = args.state;\n    }\n    isActive() {\n        const U64_MAX = BigInt(\"0xffffffffffffffff\");\n        return this.state.deactivationSlot === U64_MAX;\n    }\n    static deserialize(accountData) {\n        const meta = decodeData(LookupTableMetaLayout, accountData);\n        const serializedAddressesLen = accountData.length - LOOKUP_TABLE_META_SIZE;\n        assert(serializedAddressesLen >= 0, \"lookup table is invalid\");\n        assert(serializedAddressesLen % 32 === 0, \"lookup table is invalid\");\n        const numSerializedAddresses = serializedAddressesLen / 32;\n        const { addresses } = _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.struct([\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.seq(publicKey(), numSerializedAddresses, \"addresses\")\n        ]).decode(accountData.slice(LOOKUP_TABLE_META_SIZE));\n        return {\n            deactivationSlot: meta.deactivationSlot,\n            lastExtendedSlot: meta.lastExtendedSlot,\n            lastExtendedSlotStartIndex: meta.lastExtendedStartIndex,\n            authority: meta.authority.length !== 0 ? new PublicKey(meta.authority[0]) : undefined,\n            addresses: addresses.map((address)=>new PublicKey(address))\n        };\n    }\n}\nconst LookupTableMetaLayout = {\n    index: 1,\n    layout: _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.struct([\n        _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u32(\"typeIndex\"),\n        u64(\"deactivationSlot\"),\n        _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.nu64(\"lastExtendedSlot\"),\n        _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u8(\"lastExtendedStartIndex\"),\n        _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u8(),\n        // option\n        _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.seq(publicKey(), _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.offset(_solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u8(), -1), \"authority\")\n    ])\n};\nconst URL_RE = /^[^:]+:\\/\\/([^:[]+|\\[[^\\]]+\\])(:\\d+)?(.*)/i;\nfunction makeWebsocketUrl(endpoint) {\n    const matches = endpoint.match(URL_RE);\n    if (matches == null) {\n        throw TypeError(`Failed to validate endpoint URL \\`${endpoint}\\``);\n    }\n    const [_, // eslint-disable-line @typescript-eslint/no-unused-vars\n    hostish, portWithColon, rest] = matches;\n    const protocol = endpoint.startsWith(\"https:\") ? \"wss:\" : \"ws:\";\n    const startPort = portWithColon == null ? null : parseInt(portWithColon.slice(1), 10);\n    const websocketPort = // Only shift the port by +1 as a convention for ws(s) only if given endpoint\n    // is explicitly specifying the endpoint port (HTTP-based RPC), assuming\n    // we're directly trying to connect to agave-validator's ws listening port.\n    // When the endpoint omits the port, we're connecting to the protocol\n    // default ports: http(80) or https(443) and it's assumed we're behind a reverse\n    // proxy which manages WebSocket upgrade and backend port redirection.\n    startPort == null ? \"\" : `:${startPort + 1}`;\n    return `${protocol}//${hostish}${websocketPort}${rest}`;\n}\nconst PublicKeyFromString = (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.coerce)((0,superstruct__WEBPACK_IMPORTED_MODULE_15__.instance)(PublicKey), (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.string)(), (value)=>new PublicKey(value));\nconst RawAccountDataResult = (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.tuple)([\n    (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.string)(),\n    (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.literal)(\"base64\")\n]);\nconst BufferFromRawAccountData = (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.coerce)((0,superstruct__WEBPACK_IMPORTED_MODULE_15__.instance)(buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer), RawAccountDataResult, (value)=>buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.from(value[0], \"base64\"));\n/**\n * Attempt to use a recent blockhash for up to 30 seconds\n * @internal\n */ const BLOCKHASH_CACHE_TIMEOUT_MS = 30 * 1000;\n/**\n * HACK.\n * Copied from rpc-websockets/dist/lib/client.\n * Otherwise, `yarn build` fails with:\n * https://gist.github.com/steveluscher/c057eca81d479ef705cdb53162f9971d\n */ /** @internal */ /** @internal */ /** @internal */ /** @internal */ /** @internal */ /**\n * @internal\n * Every subscription contains the args used to open the subscription with\n * the server, and a list of callers interested in notifications.\n */ /**\n * @internal\n * A subscription may be in various states of connectedness. Only when it is\n * fully connected will it have a server subscription id associated with it.\n * This id can be returned to the server to unsubscribe the client entirely.\n */ /**\n * A type that encapsulates a subscription's RPC method\n * names and notification (callback) signature.\n */ /**\n * @internal\n * Utility type that keeps tagged unions intact while omitting properties.\n */ /**\n * @internal\n * This type represents a single subscribable 'topic.' It's made up of:\n *\n * - The args used to open the subscription with the server,\n * - The state of the subscription, in terms of its connectedness, and\n * - The set of callbacks to call when the server publishes notifications\n *\n * This record gets indexed by `SubscriptionConfigHash` and is used to\n * set up subscriptions, fan out notifications, and track subscription state.\n */ /**\n * @internal\n */ /**\n * Extra contextual information for RPC responses\n */ /**\n * Options for sending transactions\n */ /**\n * Options for confirming transactions\n */ /**\n * Options for getConfirmedSignaturesForAddress2\n */ /**\n * Options for getSignaturesForAddress\n */ /**\n * RPC Response with extra contextual information\n */ /**\n * A strategy for confirming transactions that uses the last valid\n * block height for a given blockhash to check for transaction expiration.\n */ /**\n * A strategy for confirming durable nonce transactions.\n */ /**\n * Properties shared by all transaction confirmation strategies\n */ /**\n * This type represents all transaction confirmation strategies\n */ /* @internal */ function assertEndpointUrl(putativeUrl) {\n    if (/^https?:/.test(putativeUrl) === false) {\n        throw new TypeError(\"Endpoint URL must start with `http:` or `https:`.\");\n    }\n    return putativeUrl;\n}\n/** @internal */ function extractCommitmentFromConfig(commitmentOrConfig) {\n    let commitment;\n    let config;\n    if (typeof commitmentOrConfig === \"string\") {\n        commitment = commitmentOrConfig;\n    } else if (commitmentOrConfig) {\n        const { commitment: specifiedCommitment, ...specifiedConfig } = commitmentOrConfig;\n        commitment = specifiedCommitment;\n        config = specifiedConfig;\n    }\n    return {\n        commitment,\n        config\n    };\n}\n/**\n * @internal\n */ function createRpcResult(result) {\n    return (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.union)([\n        (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.type)({\n            jsonrpc: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.literal)(\"2.0\"),\n            id: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.string)(),\n            result\n        }),\n        (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.type)({\n            jsonrpc: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.literal)(\"2.0\"),\n            id: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.string)(),\n            error: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.type)({\n                code: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.unknown)(),\n                message: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.string)(),\n                data: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.optional)((0,superstruct__WEBPACK_IMPORTED_MODULE_15__.any)())\n            })\n        })\n    ]);\n}\nconst UnknownRpcResult = createRpcResult((0,superstruct__WEBPACK_IMPORTED_MODULE_15__.unknown)());\n/**\n * @internal\n */ function jsonRpcResult(schema) {\n    return (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.coerce)(createRpcResult(schema), UnknownRpcResult, (value)=>{\n        if (\"error\" in value) {\n            return value;\n        } else {\n            return {\n                ...value,\n                result: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.create)(value.result, schema)\n            };\n        }\n    });\n}\n/**\n * @internal\n */ function jsonRpcResultAndContext(value) {\n    return jsonRpcResult((0,superstruct__WEBPACK_IMPORTED_MODULE_15__.type)({\n        context: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.type)({\n            slot: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.number)()\n        }),\n        value\n    }));\n}\n/**\n * @internal\n */ function notificationResultAndContext(value) {\n    return (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.type)({\n        context: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.type)({\n            slot: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.number)()\n        }),\n        value\n    });\n}\n/**\n * @internal\n */ function versionedMessageFromResponse(version, response) {\n    if (version === 0) {\n        return new MessageV0({\n            header: response.header,\n            staticAccountKeys: response.accountKeys.map((accountKey)=>new PublicKey(accountKey)),\n            recentBlockhash: response.recentBlockhash,\n            compiledInstructions: response.instructions.map((ix)=>({\n                    programIdIndex: ix.programIdIndex,\n                    accountKeyIndexes: ix.accounts,\n                    data: bs58__WEBPACK_IMPORTED_MODULE_2___default().decode(ix.data)\n                })),\n            addressTableLookups: response.addressTableLookups\n        });\n    } else {\n        return new Message(response);\n    }\n}\n/**\n * The level of commitment desired when querying state\n * <pre>\n *   'processed': Query the most recent block which has reached 1 confirmation by the connected node\n *   'confirmed': Query the most recent block which has reached 1 confirmation by the cluster\n *   'finalized': Query the most recent block which has been finalized by the cluster\n * </pre>\n */ // Deprecated as of v1.5.5\n/**\n * A subset of Commitment levels, which are at least optimistically confirmed\n * <pre>\n *   'confirmed': Query the most recent block which has reached 1 confirmation by the cluster\n *   'finalized': Query the most recent block which has been finalized by the cluster\n * </pre>\n */ /**\n * Filter for largest accounts query\n * <pre>\n *   'circulating':    Return the largest accounts that are part of the circulating supply\n *   'nonCirculating': Return the largest accounts that are not part of the circulating supply\n * </pre>\n */ /**\n * Configuration object for changing `getAccountInfo` query behavior\n */ /**\n * Configuration object for changing `getBalance` query behavior\n */ /**\n * Configuration object for changing `getBlock` query behavior\n */ /**\n * Configuration object for changing `getBlock` query behavior\n */ /**\n * Configuration object for changing `getStakeMinimumDelegation` query behavior\n */ /**\n * Configuration object for changing `getBlockHeight` query behavior\n */ /**\n * Configuration object for changing `getEpochInfo` query behavior\n */ /**\n * Configuration object for changing `getInflationReward` query behavior\n */ /**\n * Configuration object for changing `getLatestBlockhash` query behavior\n */ /**\n * Configuration object for changing `isBlockhashValid` query behavior\n */ /**\n * Configuration object for changing `getSlot` query behavior\n */ /**\n * Configuration object for changing `getSlotLeader` query behavior\n */ /**\n * Configuration object for changing `getTransaction` query behavior\n */ /**\n * Configuration object for changing `getTransaction` query behavior\n */ /**\n * Configuration object for changing `getLargestAccounts` query behavior\n */ /**\n * Configuration object for changing `getSupply` request behavior\n */ /**\n * Configuration object for changing query behavior\n */ /**\n * Information describing a cluster node\n */ /**\n * Information describing a vote account\n */ /**\n * A collection of cluster vote accounts\n */ /**\n * Network Inflation\n * (see https://docs.solana.com/implemented-proposals/ed_overview)\n */ const GetInflationGovernorResult = (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.type)({\n    foundation: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.number)(),\n    foundationTerm: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.number)(),\n    initial: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.number)(),\n    taper: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.number)(),\n    terminal: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.number)()\n});\n/**\n * The inflation reward for an epoch\n */ /**\n * Expected JSON RPC response for the \"getInflationReward\" message\n */ const GetInflationRewardResult = jsonRpcResult((0,superstruct__WEBPACK_IMPORTED_MODULE_15__.array)((0,superstruct__WEBPACK_IMPORTED_MODULE_15__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_15__.type)({\n    epoch: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.number)(),\n    effectiveSlot: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.number)(),\n    amount: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.number)(),\n    postBalance: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.number)(),\n    commission: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.optional)((0,superstruct__WEBPACK_IMPORTED_MODULE_15__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_15__.number)()))\n}))));\n/**\n * Configuration object for changing `getRecentPrioritizationFees` query behavior\n */ /**\n * Expected JSON RPC response for the \"getRecentPrioritizationFees\" message\n */ const GetRecentPrioritizationFeesResult = (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.array)((0,superstruct__WEBPACK_IMPORTED_MODULE_15__.type)({\n    slot: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.number)(),\n    prioritizationFee: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.number)()\n}));\n/**\n * Expected JSON RPC response for the \"getInflationRate\" message\n */ const GetInflationRateResult = (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.type)({\n    total: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.number)(),\n    validator: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.number)(),\n    foundation: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.number)(),\n    epoch: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.number)()\n});\n/**\n * Information about the current epoch\n */ const GetEpochInfoResult = (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.type)({\n    epoch: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.number)(),\n    slotIndex: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.number)(),\n    slotsInEpoch: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.number)(),\n    absoluteSlot: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.number)(),\n    blockHeight: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.optional)((0,superstruct__WEBPACK_IMPORTED_MODULE_15__.number)()),\n    transactionCount: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.optional)((0,superstruct__WEBPACK_IMPORTED_MODULE_15__.number)())\n});\nconst GetEpochScheduleResult = (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.type)({\n    slotsPerEpoch: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.number)(),\n    leaderScheduleSlotOffset: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.number)(),\n    warmup: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.boolean)(),\n    firstNormalEpoch: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.number)(),\n    firstNormalSlot: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.number)()\n});\n/**\n * Leader schedule\n * (see https://docs.solana.com/terminology#leader-schedule)\n */ const GetLeaderScheduleResult = (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.record)((0,superstruct__WEBPACK_IMPORTED_MODULE_15__.string)(), (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.array)((0,superstruct__WEBPACK_IMPORTED_MODULE_15__.number)()));\n/**\n * Transaction error or null\n */ const TransactionErrorResult = (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_15__.union)([\n    (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.type)({}),\n    (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.string)()\n]));\n/**\n * Signature status for a transaction\n */ const SignatureStatusResult = (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.type)({\n    err: TransactionErrorResult\n});\n/**\n * Transaction signature received notification\n */ const SignatureReceivedResult = (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.literal)(\"receivedSignature\");\n/**\n * Version info for a node\n */ const VersionResult = (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.type)({\n    \"solana-core\": (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.string)(),\n    \"feature-set\": (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.optional)((0,superstruct__WEBPACK_IMPORTED_MODULE_15__.number)())\n});\nconst SimulatedTransactionResponseStruct = jsonRpcResultAndContext((0,superstruct__WEBPACK_IMPORTED_MODULE_15__.type)({\n    err: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_15__.union)([\n        (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.type)({}),\n        (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.string)()\n    ])),\n    logs: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_15__.array)((0,superstruct__WEBPACK_IMPORTED_MODULE_15__.string)())),\n    accounts: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.optional)((0,superstruct__WEBPACK_IMPORTED_MODULE_15__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_15__.array)((0,superstruct__WEBPACK_IMPORTED_MODULE_15__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_15__.type)({\n        executable: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.boolean)(),\n        owner: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.string)(),\n        lamports: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.number)(),\n        data: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.array)((0,superstruct__WEBPACK_IMPORTED_MODULE_15__.string)()),\n        rentEpoch: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.optional)((0,superstruct__WEBPACK_IMPORTED_MODULE_15__.number)())\n    }))))),\n    unitsConsumed: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.optional)((0,superstruct__WEBPACK_IMPORTED_MODULE_15__.number)()),\n    returnData: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.optional)((0,superstruct__WEBPACK_IMPORTED_MODULE_15__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_15__.type)({\n        programId: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.string)(),\n        data: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.tuple)([\n            (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.string)(),\n            (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.literal)(\"base64\")\n        ])\n    })))\n}));\n/**\n * Metadata for a parsed confirmed transaction on the ledger\n *\n * @deprecated Deprecated since Solana v1.8.0. Please use {@link ParsedTransactionMeta} instead.\n */ /**\n * Collection of addresses loaded by a transaction using address table lookups\n */ /**\n * Metadata for a parsed transaction on the ledger\n */ /**\n * Metadata for a confirmed transaction on the ledger\n */ /**\n * A processed transaction from the RPC API\n */ /**\n * A processed transaction from the RPC API\n */ /**\n * A processed transaction message from the RPC API\n */ /**\n * A confirmed transaction on the ledger\n *\n * @deprecated Deprecated since Solana v1.8.0.\n */ /**\n * A partially decoded transaction instruction\n */ /**\n * A parsed transaction message account\n */ /**\n * A parsed transaction instruction\n */ /**\n * A parsed address table lookup\n */ /**\n * A parsed transaction message\n */ /**\n * A parsed transaction\n */ /**\n * A parsed and confirmed transaction on the ledger\n *\n * @deprecated Deprecated since Solana v1.8.0. Please use {@link ParsedTransactionWithMeta} instead.\n */ /**\n * A parsed transaction on the ledger with meta\n */ /**\n * A processed block fetched from the RPC API\n */ /**\n * A processed block fetched from the RPC API where the `transactionDetails` mode is `accounts`\n */ /**\n * A processed block fetched from the RPC API where the `transactionDetails` mode is `none`\n */ /**\n * A block with parsed transactions\n */ /**\n * A block with parsed transactions where the `transactionDetails` mode is `accounts`\n */ /**\n * A block with parsed transactions where the `transactionDetails` mode is `none`\n */ /**\n * A processed block fetched from the RPC API\n */ /**\n * A processed block fetched from the RPC API where the `transactionDetails` mode is `accounts`\n */ /**\n * A processed block fetched from the RPC API where the `transactionDetails` mode is `none`\n */ /**\n * A confirmed block on the ledger\n *\n * @deprecated Deprecated since Solana v1.8.0.\n */ /**\n * A Block on the ledger with signatures only\n */ /**\n * recent block production information\n */ /**\n * Expected JSON RPC response for the \"getBlockProduction\" message\n */ const BlockProductionResponseStruct = jsonRpcResultAndContext((0,superstruct__WEBPACK_IMPORTED_MODULE_15__.type)({\n    byIdentity: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.record)((0,superstruct__WEBPACK_IMPORTED_MODULE_15__.string)(), (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.array)((0,superstruct__WEBPACK_IMPORTED_MODULE_15__.number)())),\n    range: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.type)({\n        firstSlot: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.number)(),\n        lastSlot: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.number)()\n    })\n}));\n/**\n * A performance sample\n */ function createRpcClient(url, httpHeaders, customFetch, fetchMiddleware, disableRetryOnRateLimit, httpAgent) {\n    const fetch = customFetch ? customFetch : fetchImpl;\n    let agent;\n    {\n        if (httpAgent == null) {\n            {\n                const agentOptions = {\n                    // One second fewer than the Solana RPC's keepalive timeout.\n                    // Read more: https://github.com/solana-labs/solana/issues/27859#issuecomment-1340097889\n                    freeSocketTimeout: 19000,\n                    keepAlive: true,\n                    maxSockets: 25\n                };\n                if (url.startsWith(\"https:\")) {\n                    agent = new HttpsAgent(agentOptions);\n                } else {\n                    agent = new HttpKeepAliveAgent(agentOptions);\n                }\n            }\n        } else {\n            if (httpAgent !== false) {\n                const isHttps = url.startsWith(\"https:\");\n                if (isHttps && !(httpAgent instanceof https__WEBPACK_IMPORTED_MODULE_8__.Agent)) {\n                    throw new Error(\"The endpoint `\" + url + \"` can only be paired with an `https.Agent`. You have, instead, supplied an \" + \"`http.Agent` through `httpAgent`.\");\n                } else if (!isHttps && httpAgent instanceof https__WEBPACK_IMPORTED_MODULE_8__.Agent) {\n                    throw new Error(\"The endpoint `\" + url + \"` can only be paired with an `http.Agent`. You have, instead, supplied an \" + \"`https.Agent` through `httpAgent`.\");\n                }\n                agent = httpAgent;\n            }\n        }\n    }\n    let fetchWithMiddleware;\n    if (fetchMiddleware) {\n        fetchWithMiddleware = async (info, init)=>{\n            const modifiedFetchArgs = await new Promise((resolve, reject)=>{\n                try {\n                    fetchMiddleware(info, init, (modifiedInfo, modifiedInit)=>resolve([\n                            modifiedInfo,\n                            modifiedInit\n                        ]));\n                } catch (error) {\n                    reject(error);\n                }\n            });\n            return await fetch(...modifiedFetchArgs);\n        };\n    }\n    const clientBrowser = new (jayson_lib_client_browser__WEBPACK_IMPORTED_MODULE_9___default())(async (request, callback)=>{\n        const options = {\n            method: \"POST\",\n            body: request,\n            agent,\n            headers: Object.assign({\n                \"Content-Type\": \"application/json\"\n            }, httpHeaders || {}, COMMON_HTTP_HEADERS)\n        };\n        try {\n            let too_many_requests_retries = 5;\n            let res;\n            let waitTime = 500;\n            for(;;){\n                if (fetchWithMiddleware) {\n                    res = await fetchWithMiddleware(url, options);\n                } else {\n                    res = await fetch(url, options);\n                }\n                if (res.status !== 429 /* Too many requests */ ) {\n                    break;\n                }\n                if (disableRetryOnRateLimit === true) {\n                    break;\n                }\n                too_many_requests_retries -= 1;\n                if (too_many_requests_retries === 0) {\n                    break;\n                }\n                console.error(`Server responded with ${res.status} ${res.statusText}.  Retrying after ${waitTime}ms delay...`);\n                await sleep(waitTime);\n                waitTime *= 2;\n            }\n            const text = await res.text();\n            if (res.ok) {\n                callback(null, text);\n            } else {\n                callback(new Error(`${res.status} ${res.statusText}: ${text}`));\n            }\n        } catch (err) {\n            if (err instanceof Error) callback(err);\n        }\n    }, {});\n    return clientBrowser;\n}\nfunction createRpcRequest(client) {\n    return (method, args)=>{\n        return new Promise((resolve, reject)=>{\n            client.request(method, args, (err, response)=>{\n                if (err) {\n                    reject(err);\n                    return;\n                }\n                resolve(response);\n            });\n        });\n    };\n}\nfunction createRpcBatchRequest(client) {\n    return (requests)=>{\n        return new Promise((resolve, reject)=>{\n            // Do nothing if requests is empty\n            if (requests.length === 0) resolve([]);\n            const batch = requests.map((params)=>{\n                return client.request(params.methodName, params.args);\n            });\n            client.request(batch, (err, response)=>{\n                if (err) {\n                    reject(err);\n                    return;\n                }\n                resolve(response);\n            });\n        });\n    };\n}\n/**\n * Expected JSON RPC response for the \"getInflationGovernor\" message\n */ const GetInflationGovernorRpcResult = jsonRpcResult(GetInflationGovernorResult);\n/**\n * Expected JSON RPC response for the \"getInflationRate\" message\n */ const GetInflationRateRpcResult = jsonRpcResult(GetInflationRateResult);\n/**\n * Expected JSON RPC response for the \"getRecentPrioritizationFees\" message\n */ const GetRecentPrioritizationFeesRpcResult = jsonRpcResult(GetRecentPrioritizationFeesResult);\n/**\n * Expected JSON RPC response for the \"getEpochInfo\" message\n */ const GetEpochInfoRpcResult = jsonRpcResult(GetEpochInfoResult);\n/**\n * Expected JSON RPC response for the \"getEpochSchedule\" message\n */ const GetEpochScheduleRpcResult = jsonRpcResult(GetEpochScheduleResult);\n/**\n * Expected JSON RPC response for the \"getLeaderSchedule\" message\n */ const GetLeaderScheduleRpcResult = jsonRpcResult(GetLeaderScheduleResult);\n/**\n * Expected JSON RPC response for the \"minimumLedgerSlot\" and \"getFirstAvailableBlock\" messages\n */ const SlotRpcResult = jsonRpcResult((0,superstruct__WEBPACK_IMPORTED_MODULE_15__.number)());\n/**\n * Supply\n */ /**\n * Expected JSON RPC response for the \"getSupply\" message\n */ const GetSupplyRpcResult = jsonRpcResultAndContext((0,superstruct__WEBPACK_IMPORTED_MODULE_15__.type)({\n    total: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.number)(),\n    circulating: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.number)(),\n    nonCirculating: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.number)(),\n    nonCirculatingAccounts: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.array)(PublicKeyFromString)\n}));\n/**\n * Token amount object which returns a token amount in different formats\n * for various client use cases.\n */ /**\n * Expected JSON RPC structure for token amounts\n */ const TokenAmountResult = (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.type)({\n    amount: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.string)(),\n    uiAmount: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_15__.number)()),\n    decimals: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.number)(),\n    uiAmountString: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.optional)((0,superstruct__WEBPACK_IMPORTED_MODULE_15__.string)())\n});\n/**\n * Token address and balance.\n */ /**\n * Expected JSON RPC response for the \"getTokenLargestAccounts\" message\n */ const GetTokenLargestAccountsResult = jsonRpcResultAndContext((0,superstruct__WEBPACK_IMPORTED_MODULE_15__.array)((0,superstruct__WEBPACK_IMPORTED_MODULE_15__.type)({\n    address: PublicKeyFromString,\n    amount: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.string)(),\n    uiAmount: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_15__.number)()),\n    decimals: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.number)(),\n    uiAmountString: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.optional)((0,superstruct__WEBPACK_IMPORTED_MODULE_15__.string)())\n})));\n/**\n * Expected JSON RPC response for the \"getTokenAccountsByOwner\" message\n */ const GetTokenAccountsByOwner = jsonRpcResultAndContext((0,superstruct__WEBPACK_IMPORTED_MODULE_15__.array)((0,superstruct__WEBPACK_IMPORTED_MODULE_15__.type)({\n    pubkey: PublicKeyFromString,\n    account: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.type)({\n        executable: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.boolean)(),\n        owner: PublicKeyFromString,\n        lamports: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.number)(),\n        data: BufferFromRawAccountData,\n        rentEpoch: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.number)()\n    })\n})));\nconst ParsedAccountDataResult = (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.type)({\n    program: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.string)(),\n    parsed: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.unknown)(),\n    space: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.number)()\n});\n/**\n * Expected JSON RPC response for the \"getTokenAccountsByOwner\" message with parsed data\n */ const GetParsedTokenAccountsByOwner = jsonRpcResultAndContext((0,superstruct__WEBPACK_IMPORTED_MODULE_15__.array)((0,superstruct__WEBPACK_IMPORTED_MODULE_15__.type)({\n    pubkey: PublicKeyFromString,\n    account: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.type)({\n        executable: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.boolean)(),\n        owner: PublicKeyFromString,\n        lamports: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.number)(),\n        data: ParsedAccountDataResult,\n        rentEpoch: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.number)()\n    })\n})));\n/**\n * Pair of an account address and its balance\n */ /**\n * Expected JSON RPC response for the \"getLargestAccounts\" message\n */ const GetLargestAccountsRpcResult = jsonRpcResultAndContext((0,superstruct__WEBPACK_IMPORTED_MODULE_15__.array)((0,superstruct__WEBPACK_IMPORTED_MODULE_15__.type)({\n    lamports: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.number)(),\n    address: PublicKeyFromString\n})));\n/**\n * @internal\n */ const AccountInfoResult = (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.type)({\n    executable: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.boolean)(),\n    owner: PublicKeyFromString,\n    lamports: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.number)(),\n    data: BufferFromRawAccountData,\n    rentEpoch: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.number)()\n});\n/**\n * @internal\n */ const KeyedAccountInfoResult = (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.type)({\n    pubkey: PublicKeyFromString,\n    account: AccountInfoResult\n});\nconst ParsedOrRawAccountData = (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.coerce)((0,superstruct__WEBPACK_IMPORTED_MODULE_15__.union)([\n    (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.instance)(buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer),\n    ParsedAccountDataResult\n]), (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.union)([\n    RawAccountDataResult,\n    ParsedAccountDataResult\n]), (value)=>{\n    if (Array.isArray(value)) {\n        return (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.create)(value, BufferFromRawAccountData);\n    } else {\n        return value;\n    }\n});\n/**\n * @internal\n */ const ParsedAccountInfoResult = (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.type)({\n    executable: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.boolean)(),\n    owner: PublicKeyFromString,\n    lamports: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.number)(),\n    data: ParsedOrRawAccountData,\n    rentEpoch: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.number)()\n});\nconst KeyedParsedAccountInfoResult = (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.type)({\n    pubkey: PublicKeyFromString,\n    account: ParsedAccountInfoResult\n});\n/**\n * @internal\n */ const StakeActivationResult = (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.type)({\n    state: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.union)([\n        (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.literal)(\"active\"),\n        (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.literal)(\"inactive\"),\n        (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.literal)(\"activating\"),\n        (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.literal)(\"deactivating\")\n    ]),\n    active: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.number)(),\n    inactive: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.number)()\n});\n/**\n * Expected JSON RPC response for the \"getConfirmedSignaturesForAddress2\" message\n */ const GetConfirmedSignaturesForAddress2RpcResult = jsonRpcResult((0,superstruct__WEBPACK_IMPORTED_MODULE_15__.array)((0,superstruct__WEBPACK_IMPORTED_MODULE_15__.type)({\n    signature: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.string)(),\n    slot: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.number)(),\n    err: TransactionErrorResult,\n    memo: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_15__.string)()),\n    blockTime: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.optional)((0,superstruct__WEBPACK_IMPORTED_MODULE_15__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_15__.number)()))\n})));\n/**\n * Expected JSON RPC response for the \"getSignaturesForAddress\" message\n */ const GetSignaturesForAddressRpcResult = jsonRpcResult((0,superstruct__WEBPACK_IMPORTED_MODULE_15__.array)((0,superstruct__WEBPACK_IMPORTED_MODULE_15__.type)({\n    signature: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.string)(),\n    slot: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.number)(),\n    err: TransactionErrorResult,\n    memo: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_15__.string)()),\n    blockTime: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.optional)((0,superstruct__WEBPACK_IMPORTED_MODULE_15__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_15__.number)()))\n})));\n/***\n * Expected JSON RPC response for the \"accountNotification\" message\n */ const AccountNotificationResult = (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.type)({\n    subscription: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.number)(),\n    result: notificationResultAndContext(AccountInfoResult)\n});\n/**\n * @internal\n */ const ProgramAccountInfoResult = (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.type)({\n    pubkey: PublicKeyFromString,\n    account: AccountInfoResult\n});\n/***\n * Expected JSON RPC response for the \"programNotification\" message\n */ const ProgramAccountNotificationResult = (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.type)({\n    subscription: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.number)(),\n    result: notificationResultAndContext(ProgramAccountInfoResult)\n});\n/**\n * @internal\n */ const SlotInfoResult = (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.type)({\n    parent: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.number)(),\n    slot: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.number)(),\n    root: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.number)()\n});\n/**\n * Expected JSON RPC response for the \"slotNotification\" message\n */ const SlotNotificationResult = (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.type)({\n    subscription: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.number)(),\n    result: SlotInfoResult\n});\n/**\n * Slot updates which can be used for tracking the live progress of a cluster.\n * - `\"firstShredReceived\"`: connected node received the first shred of a block.\n * Indicates that a new block that is being produced.\n * - `\"completed\"`: connected node has received all shreds of a block. Indicates\n * a block was recently produced.\n * - `\"optimisticConfirmation\"`: block was optimistically confirmed by the\n * cluster. It is not guaranteed that an optimistic confirmation notification\n * will be sent for every finalized blocks.\n * - `\"root\"`: the connected node rooted this block.\n * - `\"createdBank\"`: the connected node has started validating this block.\n * - `\"frozen\"`: the connected node has validated this block.\n * - `\"dead\"`: the connected node failed to validate this block.\n */ /**\n * @internal\n */ const SlotUpdateResult = (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.union)([\n    (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.type)({\n        type: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.union)([\n            (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.literal)(\"firstShredReceived\"),\n            (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.literal)(\"completed\"),\n            (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.literal)(\"optimisticConfirmation\"),\n            (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.literal)(\"root\")\n        ]),\n        slot: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.number)(),\n        timestamp: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.number)()\n    }),\n    (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.type)({\n        type: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.literal)(\"createdBank\"),\n        parent: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.number)(),\n        slot: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.number)(),\n        timestamp: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.number)()\n    }),\n    (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.type)({\n        type: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.literal)(\"frozen\"),\n        slot: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.number)(),\n        timestamp: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.number)(),\n        stats: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.type)({\n            numTransactionEntries: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.number)(),\n            numSuccessfulTransactions: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.number)(),\n            numFailedTransactions: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.number)(),\n            maxTransactionsPerEntry: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.number)()\n        })\n    }),\n    (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.type)({\n        type: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.literal)(\"dead\"),\n        slot: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.number)(),\n        timestamp: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.number)(),\n        err: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.string)()\n    })\n]);\n/**\n * Expected JSON RPC response for the \"slotsUpdatesNotification\" message\n */ const SlotUpdateNotificationResult = (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.type)({\n    subscription: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.number)(),\n    result: SlotUpdateResult\n});\n/**\n * Expected JSON RPC response for the \"signatureNotification\" message\n */ const SignatureNotificationResult = (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.type)({\n    subscription: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.number)(),\n    result: notificationResultAndContext((0,superstruct__WEBPACK_IMPORTED_MODULE_15__.union)([\n        SignatureStatusResult,\n        SignatureReceivedResult\n    ]))\n});\n/**\n * Expected JSON RPC response for the \"rootNotification\" message\n */ const RootNotificationResult = (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.type)({\n    subscription: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.number)(),\n    result: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.number)()\n});\nconst ContactInfoResult = (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.type)({\n    pubkey: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.string)(),\n    gossip: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_15__.string)()),\n    tpu: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_15__.string)()),\n    rpc: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_15__.string)()),\n    version: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_15__.string)())\n});\nconst VoteAccountInfoResult = (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.type)({\n    votePubkey: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.string)(),\n    nodePubkey: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.string)(),\n    activatedStake: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.number)(),\n    epochVoteAccount: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.boolean)(),\n    epochCredits: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.array)((0,superstruct__WEBPACK_IMPORTED_MODULE_15__.tuple)([\n        (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.number)(),\n        (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.number)(),\n        (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.number)()\n    ])),\n    commission: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.number)(),\n    lastVote: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.number)(),\n    rootSlot: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_15__.number)())\n});\n/**\n * Expected JSON RPC response for the \"getVoteAccounts\" message\n */ const GetVoteAccounts = jsonRpcResult((0,superstruct__WEBPACK_IMPORTED_MODULE_15__.type)({\n    current: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.array)(VoteAccountInfoResult),\n    delinquent: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.array)(VoteAccountInfoResult)\n}));\nconst ConfirmationStatus = (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.union)([\n    (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.literal)(\"processed\"),\n    (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.literal)(\"confirmed\"),\n    (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.literal)(\"finalized\")\n]);\nconst SignatureStatusResponse = (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.type)({\n    slot: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.number)(),\n    confirmations: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_15__.number)()),\n    err: TransactionErrorResult,\n    confirmationStatus: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.optional)(ConfirmationStatus)\n});\n/**\n * Expected JSON RPC response for the \"getSignatureStatuses\" message\n */ const GetSignatureStatusesRpcResult = jsonRpcResultAndContext((0,superstruct__WEBPACK_IMPORTED_MODULE_15__.array)((0,superstruct__WEBPACK_IMPORTED_MODULE_15__.nullable)(SignatureStatusResponse)));\n/**\n * Expected JSON RPC response for the \"getMinimumBalanceForRentExemption\" message\n */ const GetMinimumBalanceForRentExemptionRpcResult = jsonRpcResult((0,superstruct__WEBPACK_IMPORTED_MODULE_15__.number)());\nconst AddressTableLookupStruct = (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.type)({\n    accountKey: PublicKeyFromString,\n    writableIndexes: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.array)((0,superstruct__WEBPACK_IMPORTED_MODULE_15__.number)()),\n    readonlyIndexes: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.array)((0,superstruct__WEBPACK_IMPORTED_MODULE_15__.number)())\n});\nconst ConfirmedTransactionResult = (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.type)({\n    signatures: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.array)((0,superstruct__WEBPACK_IMPORTED_MODULE_15__.string)()),\n    message: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.type)({\n        accountKeys: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.array)((0,superstruct__WEBPACK_IMPORTED_MODULE_15__.string)()),\n        header: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.type)({\n            numRequiredSignatures: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.number)(),\n            numReadonlySignedAccounts: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.number)(),\n            numReadonlyUnsignedAccounts: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.number)()\n        }),\n        instructions: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.array)((0,superstruct__WEBPACK_IMPORTED_MODULE_15__.type)({\n            accounts: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.array)((0,superstruct__WEBPACK_IMPORTED_MODULE_15__.number)()),\n            data: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.string)(),\n            programIdIndex: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.number)()\n        })),\n        recentBlockhash: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.string)(),\n        addressTableLookups: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.optional)((0,superstruct__WEBPACK_IMPORTED_MODULE_15__.array)(AddressTableLookupStruct))\n    })\n});\nconst AnnotatedAccountKey = (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.type)({\n    pubkey: PublicKeyFromString,\n    signer: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.boolean)(),\n    writable: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.boolean)(),\n    source: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.optional)((0,superstruct__WEBPACK_IMPORTED_MODULE_15__.union)([\n        (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.literal)(\"transaction\"),\n        (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.literal)(\"lookupTable\")\n    ]))\n});\nconst ConfirmedTransactionAccountsModeResult = (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.type)({\n    accountKeys: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.array)(AnnotatedAccountKey),\n    signatures: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.array)((0,superstruct__WEBPACK_IMPORTED_MODULE_15__.string)())\n});\nconst ParsedInstructionResult = (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.type)({\n    parsed: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.unknown)(),\n    program: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.string)(),\n    programId: PublicKeyFromString\n});\nconst RawInstructionResult = (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.type)({\n    accounts: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.array)(PublicKeyFromString),\n    data: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.string)(),\n    programId: PublicKeyFromString\n});\nconst InstructionResult = (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.union)([\n    RawInstructionResult,\n    ParsedInstructionResult\n]);\nconst UnknownInstructionResult = (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.union)([\n    (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.type)({\n        parsed: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.unknown)(),\n        program: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.string)(),\n        programId: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.string)()\n    }),\n    (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.type)({\n        accounts: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.array)((0,superstruct__WEBPACK_IMPORTED_MODULE_15__.string)()),\n        data: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.string)(),\n        programId: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.string)()\n    })\n]);\nconst ParsedOrRawInstruction = (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.coerce)(InstructionResult, UnknownInstructionResult, (value)=>{\n    if (\"accounts\" in value) {\n        return (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.create)(value, RawInstructionResult);\n    } else {\n        return (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.create)(value, ParsedInstructionResult);\n    }\n});\n/**\n * @internal\n */ const ParsedConfirmedTransactionResult = (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.type)({\n    signatures: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.array)((0,superstruct__WEBPACK_IMPORTED_MODULE_15__.string)()),\n    message: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.type)({\n        accountKeys: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.array)(AnnotatedAccountKey),\n        instructions: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.array)(ParsedOrRawInstruction),\n        recentBlockhash: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.string)(),\n        addressTableLookups: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.optional)((0,superstruct__WEBPACK_IMPORTED_MODULE_15__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_15__.array)(AddressTableLookupStruct)))\n    })\n});\nconst TokenBalanceResult = (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.type)({\n    accountIndex: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.number)(),\n    mint: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.string)(),\n    owner: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.optional)((0,superstruct__WEBPACK_IMPORTED_MODULE_15__.string)()),\n    uiTokenAmount: TokenAmountResult\n});\nconst LoadedAddressesResult = (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.type)({\n    writable: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.array)(PublicKeyFromString),\n    readonly: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.array)(PublicKeyFromString)\n});\n/**\n * @internal\n */ const ConfirmedTransactionMetaResult = (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.type)({\n    err: TransactionErrorResult,\n    fee: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.number)(),\n    innerInstructions: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.optional)((0,superstruct__WEBPACK_IMPORTED_MODULE_15__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_15__.array)((0,superstruct__WEBPACK_IMPORTED_MODULE_15__.type)({\n        index: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.number)(),\n        instructions: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.array)((0,superstruct__WEBPACK_IMPORTED_MODULE_15__.type)({\n            accounts: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.array)((0,superstruct__WEBPACK_IMPORTED_MODULE_15__.number)()),\n            data: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.string)(),\n            programIdIndex: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.number)()\n        }))\n    })))),\n    preBalances: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.array)((0,superstruct__WEBPACK_IMPORTED_MODULE_15__.number)()),\n    postBalances: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.array)((0,superstruct__WEBPACK_IMPORTED_MODULE_15__.number)()),\n    logMessages: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.optional)((0,superstruct__WEBPACK_IMPORTED_MODULE_15__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_15__.array)((0,superstruct__WEBPACK_IMPORTED_MODULE_15__.string)()))),\n    preTokenBalances: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.optional)((0,superstruct__WEBPACK_IMPORTED_MODULE_15__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_15__.array)(TokenBalanceResult))),\n    postTokenBalances: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.optional)((0,superstruct__WEBPACK_IMPORTED_MODULE_15__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_15__.array)(TokenBalanceResult))),\n    loadedAddresses: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.optional)(LoadedAddressesResult),\n    computeUnitsConsumed: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.optional)((0,superstruct__WEBPACK_IMPORTED_MODULE_15__.number)())\n});\n/**\n * @internal\n */ const ParsedConfirmedTransactionMetaResult = (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.type)({\n    err: TransactionErrorResult,\n    fee: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.number)(),\n    innerInstructions: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.optional)((0,superstruct__WEBPACK_IMPORTED_MODULE_15__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_15__.array)((0,superstruct__WEBPACK_IMPORTED_MODULE_15__.type)({\n        index: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.number)(),\n        instructions: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.array)(ParsedOrRawInstruction)\n    })))),\n    preBalances: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.array)((0,superstruct__WEBPACK_IMPORTED_MODULE_15__.number)()),\n    postBalances: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.array)((0,superstruct__WEBPACK_IMPORTED_MODULE_15__.number)()),\n    logMessages: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.optional)((0,superstruct__WEBPACK_IMPORTED_MODULE_15__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_15__.array)((0,superstruct__WEBPACK_IMPORTED_MODULE_15__.string)()))),\n    preTokenBalances: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.optional)((0,superstruct__WEBPACK_IMPORTED_MODULE_15__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_15__.array)(TokenBalanceResult))),\n    postTokenBalances: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.optional)((0,superstruct__WEBPACK_IMPORTED_MODULE_15__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_15__.array)(TokenBalanceResult))),\n    loadedAddresses: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.optional)(LoadedAddressesResult),\n    computeUnitsConsumed: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.optional)((0,superstruct__WEBPACK_IMPORTED_MODULE_15__.number)())\n});\nconst TransactionVersionStruct = (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.union)([\n    (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.literal)(0),\n    (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.literal)(\"legacy\")\n]);\n/** @internal */ const RewardsResult = (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.type)({\n    pubkey: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.string)(),\n    lamports: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.number)(),\n    postBalance: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_15__.number)()),\n    rewardType: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_15__.string)()),\n    commission: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.optional)((0,superstruct__WEBPACK_IMPORTED_MODULE_15__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_15__.number)()))\n});\n/**\n * Expected JSON RPC response for the \"getBlock\" message\n */ const GetBlockRpcResult = jsonRpcResult((0,superstruct__WEBPACK_IMPORTED_MODULE_15__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_15__.type)({\n    blockhash: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.string)(),\n    previousBlockhash: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.string)(),\n    parentSlot: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.number)(),\n    transactions: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.array)((0,superstruct__WEBPACK_IMPORTED_MODULE_15__.type)({\n        transaction: ConfirmedTransactionResult,\n        meta: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.nullable)(ConfirmedTransactionMetaResult),\n        version: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.optional)(TransactionVersionStruct)\n    })),\n    rewards: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.optional)((0,superstruct__WEBPACK_IMPORTED_MODULE_15__.array)(RewardsResult)),\n    blockTime: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_15__.number)()),\n    blockHeight: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_15__.number)())\n})));\n/**\n * Expected JSON RPC response for the \"getBlock\" message when `transactionDetails` is `none`\n */ const GetNoneModeBlockRpcResult = jsonRpcResult((0,superstruct__WEBPACK_IMPORTED_MODULE_15__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_15__.type)({\n    blockhash: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.string)(),\n    previousBlockhash: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.string)(),\n    parentSlot: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.number)(),\n    rewards: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.optional)((0,superstruct__WEBPACK_IMPORTED_MODULE_15__.array)(RewardsResult)),\n    blockTime: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_15__.number)()),\n    blockHeight: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_15__.number)())\n})));\n/**\n * Expected JSON RPC response for the \"getBlock\" message when `transactionDetails` is `accounts`\n */ const GetAccountsModeBlockRpcResult = jsonRpcResult((0,superstruct__WEBPACK_IMPORTED_MODULE_15__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_15__.type)({\n    blockhash: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.string)(),\n    previousBlockhash: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.string)(),\n    parentSlot: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.number)(),\n    transactions: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.array)((0,superstruct__WEBPACK_IMPORTED_MODULE_15__.type)({\n        transaction: ConfirmedTransactionAccountsModeResult,\n        meta: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.nullable)(ConfirmedTransactionMetaResult),\n        version: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.optional)(TransactionVersionStruct)\n    })),\n    rewards: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.optional)((0,superstruct__WEBPACK_IMPORTED_MODULE_15__.array)(RewardsResult)),\n    blockTime: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_15__.number)()),\n    blockHeight: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_15__.number)())\n})));\n/**\n * Expected parsed JSON RPC response for the \"getBlock\" message\n */ const GetParsedBlockRpcResult = jsonRpcResult((0,superstruct__WEBPACK_IMPORTED_MODULE_15__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_15__.type)({\n    blockhash: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.string)(),\n    previousBlockhash: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.string)(),\n    parentSlot: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.number)(),\n    transactions: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.array)((0,superstruct__WEBPACK_IMPORTED_MODULE_15__.type)({\n        transaction: ParsedConfirmedTransactionResult,\n        meta: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.nullable)(ParsedConfirmedTransactionMetaResult),\n        version: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.optional)(TransactionVersionStruct)\n    })),\n    rewards: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.optional)((0,superstruct__WEBPACK_IMPORTED_MODULE_15__.array)(RewardsResult)),\n    blockTime: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_15__.number)()),\n    blockHeight: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_15__.number)())\n})));\n/**\n * Expected parsed JSON RPC response for the \"getBlock\" message  when `transactionDetails` is `accounts`\n */ const GetParsedAccountsModeBlockRpcResult = jsonRpcResult((0,superstruct__WEBPACK_IMPORTED_MODULE_15__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_15__.type)({\n    blockhash: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.string)(),\n    previousBlockhash: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.string)(),\n    parentSlot: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.number)(),\n    transactions: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.array)((0,superstruct__WEBPACK_IMPORTED_MODULE_15__.type)({\n        transaction: ConfirmedTransactionAccountsModeResult,\n        meta: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.nullable)(ParsedConfirmedTransactionMetaResult),\n        version: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.optional)(TransactionVersionStruct)\n    })),\n    rewards: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.optional)((0,superstruct__WEBPACK_IMPORTED_MODULE_15__.array)(RewardsResult)),\n    blockTime: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_15__.number)()),\n    blockHeight: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_15__.number)())\n})));\n/**\n * Expected parsed JSON RPC response for the \"getBlock\" message  when `transactionDetails` is `none`\n */ const GetParsedNoneModeBlockRpcResult = jsonRpcResult((0,superstruct__WEBPACK_IMPORTED_MODULE_15__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_15__.type)({\n    blockhash: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.string)(),\n    previousBlockhash: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.string)(),\n    parentSlot: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.number)(),\n    rewards: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.optional)((0,superstruct__WEBPACK_IMPORTED_MODULE_15__.array)(RewardsResult)),\n    blockTime: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_15__.number)()),\n    blockHeight: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_15__.number)())\n})));\n/**\n * Expected JSON RPC response for the \"getConfirmedBlock\" message\n *\n * @deprecated Deprecated since Solana v1.8.0. Please use {@link GetBlockRpcResult} instead.\n */ const GetConfirmedBlockRpcResult = jsonRpcResult((0,superstruct__WEBPACK_IMPORTED_MODULE_15__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_15__.type)({\n    blockhash: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.string)(),\n    previousBlockhash: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.string)(),\n    parentSlot: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.number)(),\n    transactions: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.array)((0,superstruct__WEBPACK_IMPORTED_MODULE_15__.type)({\n        transaction: ConfirmedTransactionResult,\n        meta: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.nullable)(ConfirmedTransactionMetaResult)\n    })),\n    rewards: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.optional)((0,superstruct__WEBPACK_IMPORTED_MODULE_15__.array)(RewardsResult)),\n    blockTime: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_15__.number)())\n})));\n/**\n * Expected JSON RPC response for the \"getBlock\" message\n */ const GetBlockSignaturesRpcResult = jsonRpcResult((0,superstruct__WEBPACK_IMPORTED_MODULE_15__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_15__.type)({\n    blockhash: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.string)(),\n    previousBlockhash: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.string)(),\n    parentSlot: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.number)(),\n    signatures: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.array)((0,superstruct__WEBPACK_IMPORTED_MODULE_15__.string)()),\n    blockTime: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_15__.number)())\n})));\n/**\n * Expected JSON RPC response for the \"getTransaction\" message\n */ const GetTransactionRpcResult = jsonRpcResult((0,superstruct__WEBPACK_IMPORTED_MODULE_15__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_15__.type)({\n    slot: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.number)(),\n    meta: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.nullable)(ConfirmedTransactionMetaResult),\n    blockTime: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.optional)((0,superstruct__WEBPACK_IMPORTED_MODULE_15__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_15__.number)())),\n    transaction: ConfirmedTransactionResult,\n    version: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.optional)(TransactionVersionStruct)\n})));\n/**\n * Expected parsed JSON RPC response for the \"getTransaction\" message\n */ const GetParsedTransactionRpcResult = jsonRpcResult((0,superstruct__WEBPACK_IMPORTED_MODULE_15__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_15__.type)({\n    slot: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.number)(),\n    transaction: ParsedConfirmedTransactionResult,\n    meta: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.nullable)(ParsedConfirmedTransactionMetaResult),\n    blockTime: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.optional)((0,superstruct__WEBPACK_IMPORTED_MODULE_15__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_15__.number)())),\n    version: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.optional)(TransactionVersionStruct)\n})));\n/**\n * Expected JSON RPC response for the \"getRecentBlockhash\" message\n *\n * @deprecated Deprecated since Solana v1.8.0. Please use {@link GetLatestBlockhashRpcResult} instead.\n */ const GetRecentBlockhashAndContextRpcResult = jsonRpcResultAndContext((0,superstruct__WEBPACK_IMPORTED_MODULE_15__.type)({\n    blockhash: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.string)(),\n    feeCalculator: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.type)({\n        lamportsPerSignature: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.number)()\n    })\n}));\n/**\n * Expected JSON RPC response for the \"getLatestBlockhash\" message\n */ const GetLatestBlockhashRpcResult = jsonRpcResultAndContext((0,superstruct__WEBPACK_IMPORTED_MODULE_15__.type)({\n    blockhash: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.string)(),\n    lastValidBlockHeight: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.number)()\n}));\n/**\n * Expected JSON RPC response for the \"isBlockhashValid\" message\n */ const IsBlockhashValidRpcResult = jsonRpcResultAndContext((0,superstruct__WEBPACK_IMPORTED_MODULE_15__.boolean)());\nconst PerfSampleResult = (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.type)({\n    slot: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.number)(),\n    numTransactions: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.number)(),\n    numSlots: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.number)(),\n    samplePeriodSecs: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.number)()\n});\n/*\n * Expected JSON RPC response for \"getRecentPerformanceSamples\" message\n */ const GetRecentPerformanceSamplesRpcResult = jsonRpcResult((0,superstruct__WEBPACK_IMPORTED_MODULE_15__.array)(PerfSampleResult));\n/**\n * Expected JSON RPC response for the \"getFeeCalculatorForBlockhash\" message\n */ const GetFeeCalculatorRpcResult = jsonRpcResultAndContext((0,superstruct__WEBPACK_IMPORTED_MODULE_15__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_15__.type)({\n    feeCalculator: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.type)({\n        lamportsPerSignature: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.number)()\n    })\n})));\n/**\n * Expected JSON RPC response for the \"requestAirdrop\" message\n */ const RequestAirdropRpcResult = jsonRpcResult((0,superstruct__WEBPACK_IMPORTED_MODULE_15__.string)());\n/**\n * Expected JSON RPC response for the \"sendTransaction\" message\n */ const SendTransactionRpcResult = jsonRpcResult((0,superstruct__WEBPACK_IMPORTED_MODULE_15__.string)());\n/**\n * Information about the latest slot being processed by a node\n */ /**\n * Parsed account data\n */ /**\n * Stake Activation data\n */ /**\n * Data slice argument for getProgramAccounts\n */ /**\n * Memory comparison filter for getProgramAccounts\n */ /**\n * Data size comparison filter for getProgramAccounts\n */ /**\n * A filter object for getProgramAccounts\n */ /**\n * Configuration object for getProgramAccounts requests\n */ /**\n * Configuration object for getParsedProgramAccounts\n */ /**\n * Configuration object for getMultipleAccounts\n */ /**\n * Configuration object for `getStakeActivation`\n */ /**\n * Configuration object for `getStakeActivation`\n */ /**\n * Configuration object for `getStakeActivation`\n */ /**\n * Configuration object for `getNonce`\n */ /**\n * Configuration object for `getNonceAndContext`\n */ /**\n * Information describing an account\n */ /**\n * Account information identified by pubkey\n */ /**\n * Callback function for account change notifications\n */ /**\n * Callback function for program account change notifications\n */ /**\n * Callback function for slot change notifications\n */ /**\n * Callback function for slot update notifications\n */ /**\n * Callback function for signature status notifications\n */ /**\n * Signature status notification with transaction result\n */ /**\n * Signature received notification\n */ /**\n * Callback function for signature notifications\n */ /**\n * Signature subscription options\n */ /**\n * Callback function for root change notifications\n */ /**\n * @internal\n */ const LogsResult = (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.type)({\n    err: TransactionErrorResult,\n    logs: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.array)((0,superstruct__WEBPACK_IMPORTED_MODULE_15__.string)()),\n    signature: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.string)()\n});\n/**\n * Logs result.\n */ /**\n * Expected JSON RPC response for the \"logsNotification\" message.\n */ const LogsNotificationResult = (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.type)({\n    result: notificationResultAndContext(LogsResult),\n    subscription: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.number)()\n});\n/**\n * Filter for log subscriptions.\n */ /**\n * Callback function for log notifications.\n */ /**\n * Signature result\n */ /**\n * Transaction error\n */ /**\n * Transaction confirmation status\n * <pre>\n *   'processed': Transaction landed in a block which has reached 1 confirmation by the connected node\n *   'confirmed': Transaction landed in a block which has reached 1 confirmation by the cluster\n *   'finalized': Transaction landed in a block which has been finalized by the cluster\n * </pre>\n */ /**\n * Signature status\n */ /**\n * A confirmed signature with its status\n */ /**\n * An object defining headers to be passed to the RPC server\n */ /**\n * The type of the JavaScript `fetch()` API\n */ /**\n * A callback used to augment the outgoing HTTP request\n */ /**\n * Configuration for instantiating a Connection\n */ /** @internal */ const COMMON_HTTP_HEADERS = {\n    \"solana-client\": `js/${\"0.0.0-development\"}`\n};\n/**\n * A connection to a fullnode JSON RPC endpoint\n */ class Connection {\n    /**\n   * Establish a JSON RPC connection\n   *\n   * @param endpoint URL to the fullnode JSON RPC endpoint\n   * @param commitmentOrConfig optional default commitment level or optional ConnectionConfig configuration object\n   */ constructor(endpoint, _commitmentOrConfig){\n        /** @internal */ this._commitment = void 0;\n        /** @internal */ this._confirmTransactionInitialTimeout = void 0;\n        /** @internal */ this._rpcEndpoint = void 0;\n        /** @internal */ this._rpcWsEndpoint = void 0;\n        /** @internal */ this._rpcClient = void 0;\n        /** @internal */ this._rpcRequest = void 0;\n        /** @internal */ this._rpcBatchRequest = void 0;\n        /** @internal */ this._rpcWebSocket = void 0;\n        /** @internal */ this._rpcWebSocketConnected = false;\n        /** @internal */ this._rpcWebSocketHeartbeat = null;\n        /** @internal */ this._rpcWebSocketIdleTimeout = null;\n        /** @internal\n     * A number that we increment every time an active connection closes.\n     * Used to determine whether the same socket connection that was open\n     * when an async operation started is the same one that's active when\n     * its continuation fires.\n     *\n     */ this._rpcWebSocketGeneration = 0;\n        /** @internal */ this._disableBlockhashCaching = false;\n        /** @internal */ this._pollingBlockhash = false;\n        /** @internal */ this._blockhashInfo = {\n            latestBlockhash: null,\n            lastFetch: 0,\n            transactionSignatures: [],\n            simulatedSignatures: []\n        };\n        /** @internal */ this._nextClientSubscriptionId = 0;\n        /** @internal */ this._subscriptionDisposeFunctionsByClientSubscriptionId = {};\n        /** @internal */ this._subscriptionHashByClientSubscriptionId = {};\n        /** @internal */ this._subscriptionStateChangeCallbacksByHash = {};\n        /** @internal */ this._subscriptionCallbacksByServerSubscriptionId = {};\n        /** @internal */ this._subscriptionsByHash = {};\n        /**\n     * Special case.\n     * After a signature is processed, RPCs automatically dispose of the\n     * subscription on the server side. We need to track which of these\n     * subscriptions have been disposed in such a way, so that we know\n     * whether the client is dealing with a not-yet-processed signature\n     * (in which case we must tear down the server subscription) or an\n     * already-processed signature (in which case the client can simply\n     * clear out the subscription locally without telling the server).\n     *\n     * NOTE: There is a proposal to eliminate this special case, here:\n     * https://github.com/solana-labs/solana/issues/18892\n     */ /** @internal */ this._subscriptionsAutoDisposedByRpc = new Set();\n        /*\n     * Returns the current block height of the node\n     */ this.getBlockHeight = (()=>{\n            const requestPromises = {};\n            return async (commitmentOrConfig)=>{\n                const { commitment, config } = extractCommitmentFromConfig(commitmentOrConfig);\n                const args = this._buildArgs([], commitment, undefined /* encoding */ , config);\n                const requestHash = fastStableStringify$1(args);\n                requestPromises[requestHash] = requestPromises[requestHash] ?? (async ()=>{\n                    try {\n                        const unsafeRes = await this._rpcRequest(\"getBlockHeight\", args);\n                        const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.create)(unsafeRes, jsonRpcResult((0,superstruct__WEBPACK_IMPORTED_MODULE_15__.number)()));\n                        if (\"error\" in res) {\n                            throw new SolanaJSONRPCError(res.error, \"failed to get block height information\");\n                        }\n                        return res.result;\n                    } finally{\n                        delete requestPromises[requestHash];\n                    }\n                })();\n                return await requestPromises[requestHash];\n            };\n        })();\n        let wsEndpoint;\n        let httpHeaders;\n        let fetch;\n        let fetchMiddleware;\n        let disableRetryOnRateLimit;\n        let httpAgent;\n        if (_commitmentOrConfig && typeof _commitmentOrConfig === \"string\") {\n            this._commitment = _commitmentOrConfig;\n        } else if (_commitmentOrConfig) {\n            this._commitment = _commitmentOrConfig.commitment;\n            this._confirmTransactionInitialTimeout = _commitmentOrConfig.confirmTransactionInitialTimeout;\n            wsEndpoint = _commitmentOrConfig.wsEndpoint;\n            httpHeaders = _commitmentOrConfig.httpHeaders;\n            fetch = _commitmentOrConfig.fetch;\n            fetchMiddleware = _commitmentOrConfig.fetchMiddleware;\n            disableRetryOnRateLimit = _commitmentOrConfig.disableRetryOnRateLimit;\n            httpAgent = _commitmentOrConfig.httpAgent;\n        }\n        this._rpcEndpoint = assertEndpointUrl(endpoint);\n        this._rpcWsEndpoint = wsEndpoint || makeWebsocketUrl(endpoint);\n        this._rpcClient = createRpcClient(endpoint, httpHeaders, fetch, fetchMiddleware, disableRetryOnRateLimit, httpAgent);\n        this._rpcRequest = createRpcRequest(this._rpcClient);\n        this._rpcBatchRequest = createRpcBatchRequest(this._rpcClient);\n        this._rpcWebSocket = new RpcWebSocketClient(this._rpcWsEndpoint, {\n            autoconnect: false,\n            max_reconnects: Infinity\n        });\n        this._rpcWebSocket.on(\"open\", this._wsOnOpen.bind(this));\n        this._rpcWebSocket.on(\"error\", this._wsOnError.bind(this));\n        this._rpcWebSocket.on(\"close\", this._wsOnClose.bind(this));\n        this._rpcWebSocket.on(\"accountNotification\", this._wsOnAccountNotification.bind(this));\n        this._rpcWebSocket.on(\"programNotification\", this._wsOnProgramAccountNotification.bind(this));\n        this._rpcWebSocket.on(\"slotNotification\", this._wsOnSlotNotification.bind(this));\n        this._rpcWebSocket.on(\"slotsUpdatesNotification\", this._wsOnSlotUpdatesNotification.bind(this));\n        this._rpcWebSocket.on(\"signatureNotification\", this._wsOnSignatureNotification.bind(this));\n        this._rpcWebSocket.on(\"rootNotification\", this._wsOnRootNotification.bind(this));\n        this._rpcWebSocket.on(\"logsNotification\", this._wsOnLogsNotification.bind(this));\n    }\n    /**\n   * The default commitment used for requests\n   */ get commitment() {\n        return this._commitment;\n    }\n    /**\n   * The RPC endpoint\n   */ get rpcEndpoint() {\n        return this._rpcEndpoint;\n    }\n    /**\n   * Fetch the balance for the specified public key, return with context\n   */ async getBalanceAndContext(publicKey, commitmentOrConfig) {\n        /** @internal */ const { commitment, config } = extractCommitmentFromConfig(commitmentOrConfig);\n        const args = this._buildArgs([\n            publicKey.toBase58()\n        ], commitment, undefined /* encoding */ , config);\n        const unsafeRes = await this._rpcRequest(\"getBalance\", args);\n        const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.create)(unsafeRes, jsonRpcResultAndContext((0,superstruct__WEBPACK_IMPORTED_MODULE_15__.number)()));\n        if (\"error\" in res) {\n            throw new SolanaJSONRPCError(res.error, `failed to get balance for ${publicKey.toBase58()}`);\n        }\n        return res.result;\n    }\n    /**\n   * Fetch the balance for the specified public key\n   */ async getBalance(publicKey, commitmentOrConfig) {\n        return await this.getBalanceAndContext(publicKey, commitmentOrConfig).then((x)=>x.value).catch((e)=>{\n            throw new Error(\"failed to get balance of account \" + publicKey.toBase58() + \": \" + e);\n        });\n    }\n    /**\n   * Fetch the estimated production time of a block\n   */ async getBlockTime(slot) {\n        const unsafeRes = await this._rpcRequest(\"getBlockTime\", [\n            slot\n        ]);\n        const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.create)(unsafeRes, jsonRpcResult((0,superstruct__WEBPACK_IMPORTED_MODULE_15__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_15__.number)())));\n        if (\"error\" in res) {\n            throw new SolanaJSONRPCError(res.error, `failed to get block time for slot ${slot}`);\n        }\n        return res.result;\n    }\n    /**\n   * Fetch the lowest slot that the node has information about in its ledger.\n   * This value may increase over time if the node is configured to purge older ledger data\n   */ async getMinimumLedgerSlot() {\n        const unsafeRes = await this._rpcRequest(\"minimumLedgerSlot\", []);\n        const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.create)(unsafeRes, jsonRpcResult((0,superstruct__WEBPACK_IMPORTED_MODULE_15__.number)()));\n        if (\"error\" in res) {\n            throw new SolanaJSONRPCError(res.error, \"failed to get minimum ledger slot\");\n        }\n        return res.result;\n    }\n    /**\n   * Fetch the slot of the lowest confirmed block that has not been purged from the ledger\n   */ async getFirstAvailableBlock() {\n        const unsafeRes = await this._rpcRequest(\"getFirstAvailableBlock\", []);\n        const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.create)(unsafeRes, SlotRpcResult);\n        if (\"error\" in res) {\n            throw new SolanaJSONRPCError(res.error, \"failed to get first available block\");\n        }\n        return res.result;\n    }\n    /**\n   * Fetch information about the current supply\n   */ async getSupply(config) {\n        let configArg = {};\n        if (typeof config === \"string\") {\n            configArg = {\n                commitment: config\n            };\n        } else if (config) {\n            configArg = {\n                ...config,\n                commitment: config && config.commitment || this.commitment\n            };\n        } else {\n            configArg = {\n                commitment: this.commitment\n            };\n        }\n        const unsafeRes = await this._rpcRequest(\"getSupply\", [\n            configArg\n        ]);\n        const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.create)(unsafeRes, GetSupplyRpcResult);\n        if (\"error\" in res) {\n            throw new SolanaJSONRPCError(res.error, \"failed to get supply\");\n        }\n        return res.result;\n    }\n    /**\n   * Fetch the current supply of a token mint\n   */ async getTokenSupply(tokenMintAddress, commitment) {\n        const args = this._buildArgs([\n            tokenMintAddress.toBase58()\n        ], commitment);\n        const unsafeRes = await this._rpcRequest(\"getTokenSupply\", args);\n        const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.create)(unsafeRes, jsonRpcResultAndContext(TokenAmountResult));\n        if (\"error\" in res) {\n            throw new SolanaJSONRPCError(res.error, \"failed to get token supply\");\n        }\n        return res.result;\n    }\n    /**\n   * Fetch the current balance of a token account\n   */ async getTokenAccountBalance(tokenAddress, commitment) {\n        const args = this._buildArgs([\n            tokenAddress.toBase58()\n        ], commitment);\n        const unsafeRes = await this._rpcRequest(\"getTokenAccountBalance\", args);\n        const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.create)(unsafeRes, jsonRpcResultAndContext(TokenAmountResult));\n        if (\"error\" in res) {\n            throw new SolanaJSONRPCError(res.error, \"failed to get token account balance\");\n        }\n        return res.result;\n    }\n    /**\n   * Fetch all the token accounts owned by the specified account\n   *\n   * @return {Promise<RpcResponseAndContext<GetProgramAccountsResponse>}\n   */ async getTokenAccountsByOwner(ownerAddress, filter, commitmentOrConfig) {\n        const { commitment, config } = extractCommitmentFromConfig(commitmentOrConfig);\n        let _args = [\n            ownerAddress.toBase58()\n        ];\n        if (\"mint\" in filter) {\n            _args.push({\n                mint: filter.mint.toBase58()\n            });\n        } else {\n            _args.push({\n                programId: filter.programId.toBase58()\n            });\n        }\n        const args = this._buildArgs(_args, commitment, \"base64\", config);\n        const unsafeRes = await this._rpcRequest(\"getTokenAccountsByOwner\", args);\n        const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.create)(unsafeRes, GetTokenAccountsByOwner);\n        if (\"error\" in res) {\n            throw new SolanaJSONRPCError(res.error, `failed to get token accounts owned by account ${ownerAddress.toBase58()}`);\n        }\n        return res.result;\n    }\n    /**\n   * Fetch parsed token accounts owned by the specified account\n   *\n   * @return {Promise<RpcResponseAndContext<Array<{pubkey: PublicKey, account: AccountInfo<ParsedAccountData>}>>>}\n   */ async getParsedTokenAccountsByOwner(ownerAddress, filter, commitment) {\n        let _args = [\n            ownerAddress.toBase58()\n        ];\n        if (\"mint\" in filter) {\n            _args.push({\n                mint: filter.mint.toBase58()\n            });\n        } else {\n            _args.push({\n                programId: filter.programId.toBase58()\n            });\n        }\n        const args = this._buildArgs(_args, commitment, \"jsonParsed\");\n        const unsafeRes = await this._rpcRequest(\"getTokenAccountsByOwner\", args);\n        const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.create)(unsafeRes, GetParsedTokenAccountsByOwner);\n        if (\"error\" in res) {\n            throw new SolanaJSONRPCError(res.error, `failed to get token accounts owned by account ${ownerAddress.toBase58()}`);\n        }\n        return res.result;\n    }\n    /**\n   * Fetch the 20 largest accounts with their current balances\n   */ async getLargestAccounts(config) {\n        const arg = {\n            ...config,\n            commitment: config && config.commitment || this.commitment\n        };\n        const args = arg.filter || arg.commitment ? [\n            arg\n        ] : [];\n        const unsafeRes = await this._rpcRequest(\"getLargestAccounts\", args);\n        const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.create)(unsafeRes, GetLargestAccountsRpcResult);\n        if (\"error\" in res) {\n            throw new SolanaJSONRPCError(res.error, \"failed to get largest accounts\");\n        }\n        return res.result;\n    }\n    /**\n   * Fetch the 20 largest token accounts with their current balances\n   * for a given mint.\n   */ async getTokenLargestAccounts(mintAddress, commitment) {\n        const args = this._buildArgs([\n            mintAddress.toBase58()\n        ], commitment);\n        const unsafeRes = await this._rpcRequest(\"getTokenLargestAccounts\", args);\n        const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.create)(unsafeRes, GetTokenLargestAccountsResult);\n        if (\"error\" in res) {\n            throw new SolanaJSONRPCError(res.error, \"failed to get token largest accounts\");\n        }\n        return res.result;\n    }\n    /**\n   * Fetch all the account info for the specified public key, return with context\n   */ async getAccountInfoAndContext(publicKey, commitmentOrConfig) {\n        const { commitment, config } = extractCommitmentFromConfig(commitmentOrConfig);\n        const args = this._buildArgs([\n            publicKey.toBase58()\n        ], commitment, \"base64\", config);\n        const unsafeRes = await this._rpcRequest(\"getAccountInfo\", args);\n        const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.create)(unsafeRes, jsonRpcResultAndContext((0,superstruct__WEBPACK_IMPORTED_MODULE_15__.nullable)(AccountInfoResult)));\n        if (\"error\" in res) {\n            throw new SolanaJSONRPCError(res.error, `failed to get info about account ${publicKey.toBase58()}`);\n        }\n        return res.result;\n    }\n    /**\n   * Fetch parsed account info for the specified public key\n   */ async getParsedAccountInfo(publicKey, commitmentOrConfig) {\n        const { commitment, config } = extractCommitmentFromConfig(commitmentOrConfig);\n        const args = this._buildArgs([\n            publicKey.toBase58()\n        ], commitment, \"jsonParsed\", config);\n        const unsafeRes = await this._rpcRequest(\"getAccountInfo\", args);\n        const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.create)(unsafeRes, jsonRpcResultAndContext((0,superstruct__WEBPACK_IMPORTED_MODULE_15__.nullable)(ParsedAccountInfoResult)));\n        if (\"error\" in res) {\n            throw new SolanaJSONRPCError(res.error, `failed to get info about account ${publicKey.toBase58()}`);\n        }\n        return res.result;\n    }\n    /**\n   * Fetch all the account info for the specified public key\n   */ async getAccountInfo(publicKey, commitmentOrConfig) {\n        try {\n            const res = await this.getAccountInfoAndContext(publicKey, commitmentOrConfig);\n            return res.value;\n        } catch (e) {\n            throw new Error(\"failed to get info about account \" + publicKey.toBase58() + \": \" + e);\n        }\n    }\n    /**\n   * Fetch all the account info for multiple accounts specified by an array of public keys, return with context\n   */ async getMultipleParsedAccounts(publicKeys, rawConfig) {\n        const { commitment, config } = extractCommitmentFromConfig(rawConfig);\n        const keys = publicKeys.map((key)=>key.toBase58());\n        const args = this._buildArgs([\n            keys\n        ], commitment, \"jsonParsed\", config);\n        const unsafeRes = await this._rpcRequest(\"getMultipleAccounts\", args);\n        const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.create)(unsafeRes, jsonRpcResultAndContext((0,superstruct__WEBPACK_IMPORTED_MODULE_15__.array)((0,superstruct__WEBPACK_IMPORTED_MODULE_15__.nullable)(ParsedAccountInfoResult))));\n        if (\"error\" in res) {\n            throw new SolanaJSONRPCError(res.error, `failed to get info for accounts ${keys}`);\n        }\n        return res.result;\n    }\n    /**\n   * Fetch all the account info for multiple accounts specified by an array of public keys, return with context\n   */ async getMultipleAccountsInfoAndContext(publicKeys, commitmentOrConfig) {\n        const { commitment, config } = extractCommitmentFromConfig(commitmentOrConfig);\n        const keys = publicKeys.map((key)=>key.toBase58());\n        const args = this._buildArgs([\n            keys\n        ], commitment, \"base64\", config);\n        const unsafeRes = await this._rpcRequest(\"getMultipleAccounts\", args);\n        const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.create)(unsafeRes, jsonRpcResultAndContext((0,superstruct__WEBPACK_IMPORTED_MODULE_15__.array)((0,superstruct__WEBPACK_IMPORTED_MODULE_15__.nullable)(AccountInfoResult))));\n        if (\"error\" in res) {\n            throw new SolanaJSONRPCError(res.error, `failed to get info for accounts ${keys}`);\n        }\n        return res.result;\n    }\n    /**\n   * Fetch all the account info for multiple accounts specified by an array of public keys\n   */ async getMultipleAccountsInfo(publicKeys, commitmentOrConfig) {\n        const res = await this.getMultipleAccountsInfoAndContext(publicKeys, commitmentOrConfig);\n        return res.value;\n    }\n    /**\n   * Returns epoch activation information for a stake account that has been delegated\n   */ async getStakeActivation(publicKey, commitmentOrConfig, epoch) {\n        const { commitment, config } = extractCommitmentFromConfig(commitmentOrConfig);\n        const args = this._buildArgs([\n            publicKey.toBase58()\n        ], commitment, undefined /* encoding */ , {\n            ...config,\n            epoch: epoch != null ? epoch : config?.epoch\n        });\n        const unsafeRes = await this._rpcRequest(\"getStakeActivation\", args);\n        const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.create)(unsafeRes, jsonRpcResult(StakeActivationResult));\n        if (\"error\" in res) {\n            throw new SolanaJSONRPCError(res.error, `failed to get Stake Activation ${publicKey.toBase58()}`);\n        }\n        return res.result;\n    }\n    /**\n   * Fetch all the accounts owned by the specified program id\n   *\n   * @return {Promise<Array<{pubkey: PublicKey, account: AccountInfo<Buffer>}>>}\n   */ // eslint-disable-next-line no-dupe-class-members\n    // eslint-disable-next-line no-dupe-class-members\n    async getProgramAccounts(programId, configOrCommitment) {\n        const { commitment, config } = extractCommitmentFromConfig(configOrCommitment);\n        const { encoding, ...configWithoutEncoding } = config || {};\n        const args = this._buildArgs([\n            programId.toBase58()\n        ], commitment, encoding || \"base64\", configWithoutEncoding);\n        const unsafeRes = await this._rpcRequest(\"getProgramAccounts\", args);\n        const baseSchema = (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.array)(KeyedAccountInfoResult);\n        const res = configWithoutEncoding.withContext === true ? (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.create)(unsafeRes, jsonRpcResultAndContext(baseSchema)) : (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.create)(unsafeRes, jsonRpcResult(baseSchema));\n        if (\"error\" in res) {\n            throw new SolanaJSONRPCError(res.error, `failed to get accounts owned by program ${programId.toBase58()}`);\n        }\n        return res.result;\n    }\n    /**\n   * Fetch and parse all the accounts owned by the specified program id\n   *\n   * @return {Promise<Array<{pubkey: PublicKey, account: AccountInfo<Buffer | ParsedAccountData>}>>}\n   */ async getParsedProgramAccounts(programId, configOrCommitment) {\n        const { commitment, config } = extractCommitmentFromConfig(configOrCommitment);\n        const args = this._buildArgs([\n            programId.toBase58()\n        ], commitment, \"jsonParsed\", config);\n        const unsafeRes = await this._rpcRequest(\"getProgramAccounts\", args);\n        const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.create)(unsafeRes, jsonRpcResult((0,superstruct__WEBPACK_IMPORTED_MODULE_15__.array)(KeyedParsedAccountInfoResult)));\n        if (\"error\" in res) {\n            throw new SolanaJSONRPCError(res.error, `failed to get accounts owned by program ${programId.toBase58()}`);\n        }\n        return res.result;\n    }\n    /** @deprecated Instead, call `confirmTransaction` and pass in {@link TransactionConfirmationStrategy} */ // eslint-disable-next-line no-dupe-class-members\n    // eslint-disable-next-line no-dupe-class-members\n    async confirmTransaction(strategy, commitment) {\n        let rawSignature;\n        if (typeof strategy == \"string\") {\n            rawSignature = strategy;\n        } else {\n            const config = strategy;\n            if (config.abortSignal?.aborted) {\n                return Promise.reject(config.abortSignal.reason);\n            }\n            rawSignature = config.signature;\n        }\n        let decodedSignature;\n        try {\n            decodedSignature = bs58__WEBPACK_IMPORTED_MODULE_2___default().decode(rawSignature);\n        } catch (err) {\n            throw new Error(\"signature must be base58 encoded: \" + rawSignature);\n        }\n        assert(decodedSignature.length === 64, \"signature has invalid length\");\n        if (typeof strategy === \"string\") {\n            return await this.confirmTransactionUsingLegacyTimeoutStrategy({\n                commitment: commitment || this.commitment,\n                signature: rawSignature\n            });\n        } else if (\"lastValidBlockHeight\" in strategy) {\n            return await this.confirmTransactionUsingBlockHeightExceedanceStrategy({\n                commitment: commitment || this.commitment,\n                strategy\n            });\n        } else {\n            return await this.confirmTransactionUsingDurableNonceStrategy({\n                commitment: commitment || this.commitment,\n                strategy\n            });\n        }\n    }\n    getCancellationPromise(signal) {\n        return new Promise((_, reject)=>{\n            if (signal == null) {\n                return;\n            }\n            if (signal.aborted) {\n                reject(signal.reason);\n            } else {\n                signal.addEventListener(\"abort\", ()=>{\n                    reject(signal.reason);\n                });\n            }\n        });\n    }\n    getTransactionConfirmationPromise({ commitment, signature }) {\n        let signatureSubscriptionId;\n        let disposeSignatureSubscriptionStateChangeObserver;\n        let done = false;\n        const confirmationPromise = new Promise((resolve, reject)=>{\n            try {\n                signatureSubscriptionId = this.onSignature(signature, (result, context)=>{\n                    signatureSubscriptionId = undefined;\n                    const response = {\n                        context,\n                        value: result\n                    };\n                    resolve({\n                        __type: TransactionStatus.PROCESSED,\n                        response\n                    });\n                }, commitment);\n                const subscriptionSetupPromise = new Promise((resolveSubscriptionSetup)=>{\n                    if (signatureSubscriptionId == null) {\n                        resolveSubscriptionSetup();\n                    } else {\n                        disposeSignatureSubscriptionStateChangeObserver = this._onSubscriptionStateChange(signatureSubscriptionId, (nextState)=>{\n                            if (nextState === \"subscribed\") {\n                                resolveSubscriptionSetup();\n                            }\n                        });\n                    }\n                });\n                (async ()=>{\n                    await subscriptionSetupPromise;\n                    if (done) return;\n                    const response = await this.getSignatureStatus(signature);\n                    if (done) return;\n                    if (response == null) {\n                        return;\n                    }\n                    const { context, value } = response;\n                    if (value == null) {\n                        return;\n                    }\n                    if (value?.err) {\n                        reject(value.err);\n                    } else {\n                        switch(commitment){\n                            case \"confirmed\":\n                            case \"single\":\n                            case \"singleGossip\":\n                                {\n                                    if (value.confirmationStatus === \"processed\") {\n                                        return;\n                                    }\n                                    break;\n                                }\n                            case \"finalized\":\n                            case \"max\":\n                            case \"root\":\n                                {\n                                    if (value.confirmationStatus === \"processed\" || value.confirmationStatus === \"confirmed\") {\n                                        return;\n                                    }\n                                    break;\n                                }\n                            // exhaust enums to ensure full coverage\n                            case \"processed\":\n                            case \"recent\":\n                        }\n                        done = true;\n                        resolve({\n                            __type: TransactionStatus.PROCESSED,\n                            response: {\n                                context,\n                                value\n                            }\n                        });\n                    }\n                })();\n            } catch (err) {\n                reject(err);\n            }\n        });\n        const abortConfirmation = ()=>{\n            if (disposeSignatureSubscriptionStateChangeObserver) {\n                disposeSignatureSubscriptionStateChangeObserver();\n                disposeSignatureSubscriptionStateChangeObserver = undefined;\n            }\n            if (signatureSubscriptionId != null) {\n                this.removeSignatureListener(signatureSubscriptionId);\n                signatureSubscriptionId = undefined;\n            }\n        };\n        return {\n            abortConfirmation,\n            confirmationPromise\n        };\n    }\n    async confirmTransactionUsingBlockHeightExceedanceStrategy({ commitment, strategy: { abortSignal, lastValidBlockHeight, signature } }) {\n        let done = false;\n        const expiryPromise = new Promise((resolve)=>{\n            const checkBlockHeight = async ()=>{\n                try {\n                    const blockHeight = await this.getBlockHeight(commitment);\n                    return blockHeight;\n                } catch (_e) {\n                    return -1;\n                }\n            };\n            (async ()=>{\n                let currentBlockHeight = await checkBlockHeight();\n                if (done) return;\n                while(currentBlockHeight <= lastValidBlockHeight){\n                    await sleep(1000);\n                    if (done) return;\n                    currentBlockHeight = await checkBlockHeight();\n                    if (done) return;\n                }\n                resolve({\n                    __type: TransactionStatus.BLOCKHEIGHT_EXCEEDED\n                });\n            })();\n        });\n        const { abortConfirmation, confirmationPromise } = this.getTransactionConfirmationPromise({\n            commitment,\n            signature\n        });\n        const cancellationPromise = this.getCancellationPromise(abortSignal);\n        let result;\n        try {\n            const outcome = await Promise.race([\n                cancellationPromise,\n                confirmationPromise,\n                expiryPromise\n            ]);\n            if (outcome.__type === TransactionStatus.PROCESSED) {\n                result = outcome.response;\n            } else {\n                throw new TransactionExpiredBlockheightExceededError(signature);\n            }\n        } finally{\n            done = true;\n            abortConfirmation();\n        }\n        return result;\n    }\n    async confirmTransactionUsingDurableNonceStrategy({ commitment, strategy: { abortSignal, minContextSlot, nonceAccountPubkey, nonceValue, signature } }) {\n        let done = false;\n        const expiryPromise = new Promise((resolve)=>{\n            let currentNonceValue = nonceValue;\n            let lastCheckedSlot = null;\n            const getCurrentNonceValue = async ()=>{\n                try {\n                    const { context, value: nonceAccount } = await this.getNonceAndContext(nonceAccountPubkey, {\n                        commitment,\n                        minContextSlot\n                    });\n                    lastCheckedSlot = context.slot;\n                    return nonceAccount?.nonce;\n                } catch (e) {\n                    // If for whatever reason we can't reach/read the nonce\n                    // account, just keep using the last-known value.\n                    return currentNonceValue;\n                }\n            };\n            (async ()=>{\n                currentNonceValue = await getCurrentNonceValue();\n                if (done) return;\n                while(true // eslint-disable-line no-constant-condition\n                ){\n                    if (nonceValue !== currentNonceValue) {\n                        resolve({\n                            __type: TransactionStatus.NONCE_INVALID,\n                            slotInWhichNonceDidAdvance: lastCheckedSlot\n                        });\n                        return;\n                    }\n                    await sleep(2000);\n                    if (done) return;\n                    currentNonceValue = await getCurrentNonceValue();\n                    if (done) return;\n                }\n            })();\n        });\n        const { abortConfirmation, confirmationPromise } = this.getTransactionConfirmationPromise({\n            commitment,\n            signature\n        });\n        const cancellationPromise = this.getCancellationPromise(abortSignal);\n        let result;\n        try {\n            const outcome = await Promise.race([\n                cancellationPromise,\n                confirmationPromise,\n                expiryPromise\n            ]);\n            if (outcome.__type === TransactionStatus.PROCESSED) {\n                result = outcome.response;\n            } else {\n                // Double check that the transaction is indeed unconfirmed.\n                let signatureStatus;\n                while(true // eslint-disable-line no-constant-condition\n                ){\n                    const status = await this.getSignatureStatus(signature);\n                    if (status == null) {\n                        break;\n                    }\n                    if (status.context.slot < (outcome.slotInWhichNonceDidAdvance ?? minContextSlot)) {\n                        await sleep(400);\n                        continue;\n                    }\n                    signatureStatus = status;\n                    break;\n                }\n                if (signatureStatus?.value) {\n                    const commitmentForStatus = commitment || \"finalized\";\n                    const { confirmationStatus } = signatureStatus.value;\n                    switch(commitmentForStatus){\n                        case \"processed\":\n                        case \"recent\":\n                            if (confirmationStatus !== \"processed\" && confirmationStatus !== \"confirmed\" && confirmationStatus !== \"finalized\") {\n                                throw new TransactionExpiredNonceInvalidError(signature);\n                            }\n                            break;\n                        case \"confirmed\":\n                        case \"single\":\n                        case \"singleGossip\":\n                            if (confirmationStatus !== \"confirmed\" && confirmationStatus !== \"finalized\") {\n                                throw new TransactionExpiredNonceInvalidError(signature);\n                            }\n                            break;\n                        case \"finalized\":\n                        case \"max\":\n                        case \"root\":\n                            if (confirmationStatus !== \"finalized\") {\n                                throw new TransactionExpiredNonceInvalidError(signature);\n                            }\n                            break;\n                        default:\n                            // Exhaustive switch.\n                            // eslint-disable-next-line @typescript-eslint/no-unused-vars\n                            ((_)=>{})(commitmentForStatus);\n                    }\n                    result = {\n                        context: signatureStatus.context,\n                        value: {\n                            err: signatureStatus.value.err\n                        }\n                    };\n                } else {\n                    throw new TransactionExpiredNonceInvalidError(signature);\n                }\n            }\n        } finally{\n            done = true;\n            abortConfirmation();\n        }\n        return result;\n    }\n    async confirmTransactionUsingLegacyTimeoutStrategy({ commitment, signature }) {\n        let timeoutId;\n        const expiryPromise = new Promise((resolve)=>{\n            let timeoutMs = this._confirmTransactionInitialTimeout || 60 * 1000;\n            switch(commitment){\n                case \"processed\":\n                case \"recent\":\n                case \"single\":\n                case \"confirmed\":\n                case \"singleGossip\":\n                    {\n                        timeoutMs = this._confirmTransactionInitialTimeout || 30 * 1000;\n                        break;\n                    }\n            }\n            timeoutId = setTimeout(()=>resolve({\n                    __type: TransactionStatus.TIMED_OUT,\n                    timeoutMs\n                }), timeoutMs);\n        });\n        const { abortConfirmation, confirmationPromise } = this.getTransactionConfirmationPromise({\n            commitment,\n            signature\n        });\n        let result;\n        try {\n            const outcome = await Promise.race([\n                confirmationPromise,\n                expiryPromise\n            ]);\n            if (outcome.__type === TransactionStatus.PROCESSED) {\n                result = outcome.response;\n            } else {\n                throw new TransactionExpiredTimeoutError(signature, outcome.timeoutMs / 1000);\n            }\n        } finally{\n            clearTimeout(timeoutId);\n            abortConfirmation();\n        }\n        return result;\n    }\n    /**\n   * Return the list of nodes that are currently participating in the cluster\n   */ async getClusterNodes() {\n        const unsafeRes = await this._rpcRequest(\"getClusterNodes\", []);\n        const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.create)(unsafeRes, jsonRpcResult((0,superstruct__WEBPACK_IMPORTED_MODULE_15__.array)(ContactInfoResult)));\n        if (\"error\" in res) {\n            throw new SolanaJSONRPCError(res.error, \"failed to get cluster nodes\");\n        }\n        return res.result;\n    }\n    /**\n   * Return the list of nodes that are currently participating in the cluster\n   */ async getVoteAccounts(commitment) {\n        const args = this._buildArgs([], commitment);\n        const unsafeRes = await this._rpcRequest(\"getVoteAccounts\", args);\n        const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.create)(unsafeRes, GetVoteAccounts);\n        if (\"error\" in res) {\n            throw new SolanaJSONRPCError(res.error, \"failed to get vote accounts\");\n        }\n        return res.result;\n    }\n    /**\n   * Fetch the current slot that the node is processing\n   */ async getSlot(commitmentOrConfig) {\n        const { commitment, config } = extractCommitmentFromConfig(commitmentOrConfig);\n        const args = this._buildArgs([], commitment, undefined /* encoding */ , config);\n        const unsafeRes = await this._rpcRequest(\"getSlot\", args);\n        const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.create)(unsafeRes, jsonRpcResult((0,superstruct__WEBPACK_IMPORTED_MODULE_15__.number)()));\n        if (\"error\" in res) {\n            throw new SolanaJSONRPCError(res.error, \"failed to get slot\");\n        }\n        return res.result;\n    }\n    /**\n   * Fetch the current slot leader of the cluster\n   */ async getSlotLeader(commitmentOrConfig) {\n        const { commitment, config } = extractCommitmentFromConfig(commitmentOrConfig);\n        const args = this._buildArgs([], commitment, undefined /* encoding */ , config);\n        const unsafeRes = await this._rpcRequest(\"getSlotLeader\", args);\n        const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.create)(unsafeRes, jsonRpcResult((0,superstruct__WEBPACK_IMPORTED_MODULE_15__.string)()));\n        if (\"error\" in res) {\n            throw new SolanaJSONRPCError(res.error, \"failed to get slot leader\");\n        }\n        return res.result;\n    }\n    /**\n   * Fetch `limit` number of slot leaders starting from `startSlot`\n   *\n   * @param startSlot fetch slot leaders starting from this slot\n   * @param limit number of slot leaders to return\n   */ async getSlotLeaders(startSlot, limit) {\n        const args = [\n            startSlot,\n            limit\n        ];\n        const unsafeRes = await this._rpcRequest(\"getSlotLeaders\", args);\n        const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.create)(unsafeRes, jsonRpcResult((0,superstruct__WEBPACK_IMPORTED_MODULE_15__.array)(PublicKeyFromString)));\n        if (\"error\" in res) {\n            throw new SolanaJSONRPCError(res.error, \"failed to get slot leaders\");\n        }\n        return res.result;\n    }\n    /**\n   * Fetch the current status of a signature\n   */ async getSignatureStatus(signature, config) {\n        const { context, value: values } = await this.getSignatureStatuses([\n            signature\n        ], config);\n        assert(values.length === 1);\n        const value = values[0];\n        return {\n            context,\n            value\n        };\n    }\n    /**\n   * Fetch the current statuses of a batch of signatures\n   */ async getSignatureStatuses(signatures, config) {\n        const params = [\n            signatures\n        ];\n        if (config) {\n            params.push(config);\n        }\n        const unsafeRes = await this._rpcRequest(\"getSignatureStatuses\", params);\n        const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.create)(unsafeRes, GetSignatureStatusesRpcResult);\n        if (\"error\" in res) {\n            throw new SolanaJSONRPCError(res.error, \"failed to get signature status\");\n        }\n        return res.result;\n    }\n    /**\n   * Fetch the current transaction count of the cluster\n   */ async getTransactionCount(commitmentOrConfig) {\n        const { commitment, config } = extractCommitmentFromConfig(commitmentOrConfig);\n        const args = this._buildArgs([], commitment, undefined /* encoding */ , config);\n        const unsafeRes = await this._rpcRequest(\"getTransactionCount\", args);\n        const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.create)(unsafeRes, jsonRpcResult((0,superstruct__WEBPACK_IMPORTED_MODULE_15__.number)()));\n        if (\"error\" in res) {\n            throw new SolanaJSONRPCError(res.error, \"failed to get transaction count\");\n        }\n        return res.result;\n    }\n    /**\n   * Fetch the current total currency supply of the cluster in lamports\n   *\n   * @deprecated Deprecated since v1.2.8. Please use {@link getSupply} instead.\n   */ async getTotalSupply(commitment) {\n        const result = await this.getSupply({\n            commitment,\n            excludeNonCirculatingAccountsList: true\n        });\n        return result.value.total;\n    }\n    /**\n   * Fetch the cluster InflationGovernor parameters\n   */ async getInflationGovernor(commitment) {\n        const args = this._buildArgs([], commitment);\n        const unsafeRes = await this._rpcRequest(\"getInflationGovernor\", args);\n        const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.create)(unsafeRes, GetInflationGovernorRpcResult);\n        if (\"error\" in res) {\n            throw new SolanaJSONRPCError(res.error, \"failed to get inflation\");\n        }\n        return res.result;\n    }\n    /**\n   * Fetch the inflation reward for a list of addresses for an epoch\n   */ async getInflationReward(addresses, epoch, commitmentOrConfig) {\n        const { commitment, config } = extractCommitmentFromConfig(commitmentOrConfig);\n        const args = this._buildArgs([\n            addresses.map((pubkey)=>pubkey.toBase58())\n        ], commitment, undefined /* encoding */ , {\n            ...config,\n            epoch: epoch != null ? epoch : config?.epoch\n        });\n        const unsafeRes = await this._rpcRequest(\"getInflationReward\", args);\n        const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.create)(unsafeRes, GetInflationRewardResult);\n        if (\"error\" in res) {\n            throw new SolanaJSONRPCError(res.error, \"failed to get inflation reward\");\n        }\n        return res.result;\n    }\n    /**\n   * Fetch the specific inflation values for the current epoch\n   */ async getInflationRate() {\n        const unsafeRes = await this._rpcRequest(\"getInflationRate\", []);\n        const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.create)(unsafeRes, GetInflationRateRpcResult);\n        if (\"error\" in res) {\n            throw new SolanaJSONRPCError(res.error, \"failed to get inflation rate\");\n        }\n        return res.result;\n    }\n    /**\n   * Fetch the Epoch Info parameters\n   */ async getEpochInfo(commitmentOrConfig) {\n        const { commitment, config } = extractCommitmentFromConfig(commitmentOrConfig);\n        const args = this._buildArgs([], commitment, undefined /* encoding */ , config);\n        const unsafeRes = await this._rpcRequest(\"getEpochInfo\", args);\n        const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.create)(unsafeRes, GetEpochInfoRpcResult);\n        if (\"error\" in res) {\n            throw new SolanaJSONRPCError(res.error, \"failed to get epoch info\");\n        }\n        return res.result;\n    }\n    /**\n   * Fetch the Epoch Schedule parameters\n   */ async getEpochSchedule() {\n        const unsafeRes = await this._rpcRequest(\"getEpochSchedule\", []);\n        const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.create)(unsafeRes, GetEpochScheduleRpcResult);\n        if (\"error\" in res) {\n            throw new SolanaJSONRPCError(res.error, \"failed to get epoch schedule\");\n        }\n        const epochSchedule = res.result;\n        return new EpochSchedule(epochSchedule.slotsPerEpoch, epochSchedule.leaderScheduleSlotOffset, epochSchedule.warmup, epochSchedule.firstNormalEpoch, epochSchedule.firstNormalSlot);\n    }\n    /**\n   * Fetch the leader schedule for the current epoch\n   * @return {Promise<RpcResponseAndContext<LeaderSchedule>>}\n   */ async getLeaderSchedule() {\n        const unsafeRes = await this._rpcRequest(\"getLeaderSchedule\", []);\n        const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.create)(unsafeRes, GetLeaderScheduleRpcResult);\n        if (\"error\" in res) {\n            throw new SolanaJSONRPCError(res.error, \"failed to get leader schedule\");\n        }\n        return res.result;\n    }\n    /**\n   * Fetch the minimum balance needed to exempt an account of `dataLength`\n   * size from rent\n   */ async getMinimumBalanceForRentExemption(dataLength, commitment) {\n        const args = this._buildArgs([\n            dataLength\n        ], commitment);\n        const unsafeRes = await this._rpcRequest(\"getMinimumBalanceForRentExemption\", args);\n        const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.create)(unsafeRes, GetMinimumBalanceForRentExemptionRpcResult);\n        if (\"error\" in res) {\n            console.warn(\"Unable to fetch minimum balance for rent exemption\");\n            return 0;\n        }\n        return res.result;\n    }\n    /**\n   * Fetch a recent blockhash from the cluster, return with context\n   * @return {Promise<RpcResponseAndContext<{blockhash: Blockhash, feeCalculator: FeeCalculator}>>}\n   *\n   * @deprecated Deprecated since Solana v1.8.0. Please use {@link getLatestBlockhash} instead.\n   */ async getRecentBlockhashAndContext(commitment) {\n        const args = this._buildArgs([], commitment);\n        const unsafeRes = await this._rpcRequest(\"getRecentBlockhash\", args);\n        const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.create)(unsafeRes, GetRecentBlockhashAndContextRpcResult);\n        if (\"error\" in res) {\n            throw new SolanaJSONRPCError(res.error, \"failed to get recent blockhash\");\n        }\n        return res.result;\n    }\n    /**\n   * Fetch recent performance samples\n   * @return {Promise<Array<PerfSample>>}\n   */ async getRecentPerformanceSamples(limit) {\n        const unsafeRes = await this._rpcRequest(\"getRecentPerformanceSamples\", limit ? [\n            limit\n        ] : []);\n        const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.create)(unsafeRes, GetRecentPerformanceSamplesRpcResult);\n        if (\"error\" in res) {\n            throw new SolanaJSONRPCError(res.error, \"failed to get recent performance samples\");\n        }\n        return res.result;\n    }\n    /**\n   * Fetch the fee calculator for a recent blockhash from the cluster, return with context\n   *\n   * @deprecated Deprecated since Solana v1.8.0. Please use {@link getFeeForMessage} instead.\n   */ async getFeeCalculatorForBlockhash(blockhash, commitment) {\n        const args = this._buildArgs([\n            blockhash\n        ], commitment);\n        const unsafeRes = await this._rpcRequest(\"getFeeCalculatorForBlockhash\", args);\n        const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.create)(unsafeRes, GetFeeCalculatorRpcResult);\n        if (\"error\" in res) {\n            throw new SolanaJSONRPCError(res.error, \"failed to get fee calculator\");\n        }\n        const { context, value } = res.result;\n        return {\n            context,\n            value: value !== null ? value.feeCalculator : null\n        };\n    }\n    /**\n   * Fetch the fee for a message from the cluster, return with context\n   */ async getFeeForMessage(message, commitment) {\n        const wireMessage = toBuffer(message.serialize()).toString(\"base64\");\n        const args = this._buildArgs([\n            wireMessage\n        ], commitment);\n        const unsafeRes = await this._rpcRequest(\"getFeeForMessage\", args);\n        const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.create)(unsafeRes, jsonRpcResultAndContext((0,superstruct__WEBPACK_IMPORTED_MODULE_15__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_15__.number)())));\n        if (\"error\" in res) {\n            throw new SolanaJSONRPCError(res.error, \"failed to get fee for message\");\n        }\n        if (res.result === null) {\n            throw new Error(\"invalid blockhash\");\n        }\n        return res.result;\n    }\n    /**\n   * Fetch a list of prioritization fees from recent blocks.\n   */ async getRecentPrioritizationFees(config) {\n        const accounts = config?.lockedWritableAccounts?.map((key)=>key.toBase58());\n        const args = accounts?.length ? [\n            accounts\n        ] : [];\n        const unsafeRes = await this._rpcRequest(\"getRecentPrioritizationFees\", args);\n        const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.create)(unsafeRes, GetRecentPrioritizationFeesRpcResult);\n        if (\"error\" in res) {\n            throw new SolanaJSONRPCError(res.error, \"failed to get recent prioritization fees\");\n        }\n        return res.result;\n    }\n    /**\n   * Fetch a recent blockhash from the cluster\n   * @return {Promise<{blockhash: Blockhash, feeCalculator: FeeCalculator}>}\n   *\n   * @deprecated Deprecated since Solana v1.8.0. Please use {@link getLatestBlockhash} instead.\n   */ async getRecentBlockhash(commitment) {\n        try {\n            const res = await this.getRecentBlockhashAndContext(commitment);\n            return res.value;\n        } catch (e) {\n            throw new Error(\"failed to get recent blockhash: \" + e);\n        }\n    }\n    /**\n   * Fetch the latest blockhash from the cluster\n   * @return {Promise<BlockhashWithExpiryBlockHeight>}\n   */ async getLatestBlockhash(commitmentOrConfig) {\n        try {\n            const res = await this.getLatestBlockhashAndContext(commitmentOrConfig);\n            return res.value;\n        } catch (e) {\n            throw new Error(\"failed to get recent blockhash: \" + e);\n        }\n    }\n    /**\n   * Fetch the latest blockhash from the cluster\n   * @return {Promise<BlockhashWithExpiryBlockHeight>}\n   */ async getLatestBlockhashAndContext(commitmentOrConfig) {\n        const { commitment, config } = extractCommitmentFromConfig(commitmentOrConfig);\n        const args = this._buildArgs([], commitment, undefined /* encoding */ , config);\n        const unsafeRes = await this._rpcRequest(\"getLatestBlockhash\", args);\n        const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.create)(unsafeRes, GetLatestBlockhashRpcResult);\n        if (\"error\" in res) {\n            throw new SolanaJSONRPCError(res.error, \"failed to get latest blockhash\");\n        }\n        return res.result;\n    }\n    /**\n   * Returns whether a blockhash is still valid or not\n   */ async isBlockhashValid(blockhash, rawConfig) {\n        const { commitment, config } = extractCommitmentFromConfig(rawConfig);\n        const args = this._buildArgs([\n            blockhash\n        ], commitment, undefined /* encoding */ , config);\n        const unsafeRes = await this._rpcRequest(\"isBlockhashValid\", args);\n        const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.create)(unsafeRes, IsBlockhashValidRpcResult);\n        if (\"error\" in res) {\n            throw new SolanaJSONRPCError(res.error, \"failed to determine if the blockhash `\" + blockhash + \"`is valid\");\n        }\n        return res.result;\n    }\n    /**\n   * Fetch the node version\n   */ async getVersion() {\n        const unsafeRes = await this._rpcRequest(\"getVersion\", []);\n        const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.create)(unsafeRes, jsonRpcResult(VersionResult));\n        if (\"error\" in res) {\n            throw new SolanaJSONRPCError(res.error, \"failed to get version\");\n        }\n        return res.result;\n    }\n    /**\n   * Fetch the genesis hash\n   */ async getGenesisHash() {\n        const unsafeRes = await this._rpcRequest(\"getGenesisHash\", []);\n        const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.create)(unsafeRes, jsonRpcResult((0,superstruct__WEBPACK_IMPORTED_MODULE_15__.string)()));\n        if (\"error\" in res) {\n            throw new SolanaJSONRPCError(res.error, \"failed to get genesis hash\");\n        }\n        return res.result;\n    }\n    /**\n   * Fetch a processed block from the cluster.\n   *\n   * @deprecated Instead, call `getBlock` using a `GetVersionedBlockConfig` by\n   * setting the `maxSupportedTransactionVersion` property.\n   */ /**\n   * @deprecated Instead, call `getBlock` using a `GetVersionedBlockConfig` by\n   * setting the `maxSupportedTransactionVersion` property.\n   */ // eslint-disable-next-line no-dupe-class-members\n    /**\n   * @deprecated Instead, call `getBlock` using a `GetVersionedBlockConfig` by\n   * setting the `maxSupportedTransactionVersion` property.\n   */ // eslint-disable-next-line no-dupe-class-members\n    /**\n   * Fetch a processed block from the cluster.\n   */ // eslint-disable-next-line no-dupe-class-members\n    // eslint-disable-next-line no-dupe-class-members\n    // eslint-disable-next-line no-dupe-class-members\n    /**\n   * Fetch a processed block from the cluster.\n   */ // eslint-disable-next-line no-dupe-class-members\n    async getBlock(slot, rawConfig) {\n        const { commitment, config } = extractCommitmentFromConfig(rawConfig);\n        const args = this._buildArgsAtLeastConfirmed([\n            slot\n        ], commitment, undefined /* encoding */ , config);\n        const unsafeRes = await this._rpcRequest(\"getBlock\", args);\n        try {\n            switch(config?.transactionDetails){\n                case \"accounts\":\n                    {\n                        const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.create)(unsafeRes, GetAccountsModeBlockRpcResult);\n                        if (\"error\" in res) {\n                            throw res.error;\n                        }\n                        return res.result;\n                    }\n                case \"none\":\n                    {\n                        const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.create)(unsafeRes, GetNoneModeBlockRpcResult);\n                        if (\"error\" in res) {\n                            throw res.error;\n                        }\n                        return res.result;\n                    }\n                default:\n                    {\n                        const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.create)(unsafeRes, GetBlockRpcResult);\n                        if (\"error\" in res) {\n                            throw res.error;\n                        }\n                        const { result } = res;\n                        return result ? {\n                            ...result,\n                            transactions: result.transactions.map(({ transaction, meta, version })=>({\n                                    meta,\n                                    transaction: {\n                                        ...transaction,\n                                        message: versionedMessageFromResponse(version, transaction.message)\n                                    },\n                                    version\n                                }))\n                        } : null;\n                    }\n            }\n        } catch (e) {\n            throw new SolanaJSONRPCError(e, \"failed to get confirmed block\");\n        }\n    }\n    /**\n   * Fetch parsed transaction details for a confirmed or finalized block\n   */ // eslint-disable-next-line no-dupe-class-members\n    // eslint-disable-next-line no-dupe-class-members\n    // eslint-disable-next-line no-dupe-class-members\n    async getParsedBlock(slot, rawConfig) {\n        const { commitment, config } = extractCommitmentFromConfig(rawConfig);\n        const args = this._buildArgsAtLeastConfirmed([\n            slot\n        ], commitment, \"jsonParsed\", config);\n        const unsafeRes = await this._rpcRequest(\"getBlock\", args);\n        try {\n            switch(config?.transactionDetails){\n                case \"accounts\":\n                    {\n                        const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.create)(unsafeRes, GetParsedAccountsModeBlockRpcResult);\n                        if (\"error\" in res) {\n                            throw res.error;\n                        }\n                        return res.result;\n                    }\n                case \"none\":\n                    {\n                        const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.create)(unsafeRes, GetParsedNoneModeBlockRpcResult);\n                        if (\"error\" in res) {\n                            throw res.error;\n                        }\n                        return res.result;\n                    }\n                default:\n                    {\n                        const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.create)(unsafeRes, GetParsedBlockRpcResult);\n                        if (\"error\" in res) {\n                            throw res.error;\n                        }\n                        return res.result;\n                    }\n            }\n        } catch (e) {\n            throw new SolanaJSONRPCError(e, \"failed to get block\");\n        }\n    }\n    /*\n   * Returns recent block production information from the current or previous epoch\n   */ async getBlockProduction(configOrCommitment) {\n        let extra;\n        let commitment;\n        if (typeof configOrCommitment === \"string\") {\n            commitment = configOrCommitment;\n        } else if (configOrCommitment) {\n            const { commitment: c, ...rest } = configOrCommitment;\n            commitment = c;\n            extra = rest;\n        }\n        const args = this._buildArgs([], commitment, \"base64\", extra);\n        const unsafeRes = await this._rpcRequest(\"getBlockProduction\", args);\n        const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.create)(unsafeRes, BlockProductionResponseStruct);\n        if (\"error\" in res) {\n            throw new SolanaJSONRPCError(res.error, \"failed to get block production information\");\n        }\n        return res.result;\n    }\n    /**\n   * Fetch a confirmed or finalized transaction from the cluster.\n   *\n   * @deprecated Instead, call `getTransaction` using a\n   * `GetVersionedTransactionConfig` by setting the\n   * `maxSupportedTransactionVersion` property.\n   */ /**\n   * Fetch a confirmed or finalized transaction from the cluster.\n   */ // eslint-disable-next-line no-dupe-class-members\n    /**\n   * Fetch a confirmed or finalized transaction from the cluster.\n   */ // eslint-disable-next-line no-dupe-class-members\n    async getTransaction(signature, rawConfig) {\n        const { commitment, config } = extractCommitmentFromConfig(rawConfig);\n        const args = this._buildArgsAtLeastConfirmed([\n            signature\n        ], commitment, undefined /* encoding */ , config);\n        const unsafeRes = await this._rpcRequest(\"getTransaction\", args);\n        const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.create)(unsafeRes, GetTransactionRpcResult);\n        if (\"error\" in res) {\n            throw new SolanaJSONRPCError(res.error, \"failed to get transaction\");\n        }\n        const result = res.result;\n        if (!result) return result;\n        return {\n            ...result,\n            transaction: {\n                ...result.transaction,\n                message: versionedMessageFromResponse(result.version, result.transaction.message)\n            }\n        };\n    }\n    /**\n   * Fetch parsed transaction details for a confirmed or finalized transaction\n   */ async getParsedTransaction(signature, commitmentOrConfig) {\n        const { commitment, config } = extractCommitmentFromConfig(commitmentOrConfig);\n        const args = this._buildArgsAtLeastConfirmed([\n            signature\n        ], commitment, \"jsonParsed\", config);\n        const unsafeRes = await this._rpcRequest(\"getTransaction\", args);\n        const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.create)(unsafeRes, GetParsedTransactionRpcResult);\n        if (\"error\" in res) {\n            throw new SolanaJSONRPCError(res.error, \"failed to get transaction\");\n        }\n        return res.result;\n    }\n    /**\n   * Fetch parsed transaction details for a batch of confirmed transactions\n   */ async getParsedTransactions(signatures, commitmentOrConfig) {\n        const { commitment, config } = extractCommitmentFromConfig(commitmentOrConfig);\n        const batch = signatures.map((signature)=>{\n            const args = this._buildArgsAtLeastConfirmed([\n                signature\n            ], commitment, \"jsonParsed\", config);\n            return {\n                methodName: \"getTransaction\",\n                args\n            };\n        });\n        const unsafeRes = await this._rpcBatchRequest(batch);\n        const res = unsafeRes.map((unsafeRes)=>{\n            const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.create)(unsafeRes, GetParsedTransactionRpcResult);\n            if (\"error\" in res) {\n                throw new SolanaJSONRPCError(res.error, \"failed to get transactions\");\n            }\n            return res.result;\n        });\n        return res;\n    }\n    /**\n   * Fetch transaction details for a batch of confirmed transactions.\n   * Similar to {@link getParsedTransactions} but returns a {@link TransactionResponse}.\n   *\n   * @deprecated Instead, call `getTransactions` using a\n   * `GetVersionedTransactionConfig` by setting the\n   * `maxSupportedTransactionVersion` property.\n   */ /**\n   * Fetch transaction details for a batch of confirmed transactions.\n   * Similar to {@link getParsedTransactions} but returns a {@link\n   * VersionedTransactionResponse}.\n   */ // eslint-disable-next-line no-dupe-class-members\n    /**\n   * Fetch transaction details for a batch of confirmed transactions.\n   * Similar to {@link getParsedTransactions} but returns a {@link\n   * VersionedTransactionResponse}.\n   */ // eslint-disable-next-line no-dupe-class-members\n    async getTransactions(signatures, commitmentOrConfig) {\n        const { commitment, config } = extractCommitmentFromConfig(commitmentOrConfig);\n        const batch = signatures.map((signature)=>{\n            const args = this._buildArgsAtLeastConfirmed([\n                signature\n            ], commitment, undefined /* encoding */ , config);\n            return {\n                methodName: \"getTransaction\",\n                args\n            };\n        });\n        const unsafeRes = await this._rpcBatchRequest(batch);\n        const res = unsafeRes.map((unsafeRes)=>{\n            const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.create)(unsafeRes, GetTransactionRpcResult);\n            if (\"error\" in res) {\n                throw new SolanaJSONRPCError(res.error, \"failed to get transactions\");\n            }\n            const result = res.result;\n            if (!result) return result;\n            return {\n                ...result,\n                transaction: {\n                    ...result.transaction,\n                    message: versionedMessageFromResponse(result.version, result.transaction.message)\n                }\n            };\n        });\n        return res;\n    }\n    /**\n   * Fetch a list of Transactions and transaction statuses from the cluster\n   * for a confirmed block.\n   *\n   * @deprecated Deprecated since v1.13.0. Please use {@link getBlock} instead.\n   */ async getConfirmedBlock(slot, commitment) {\n        const args = this._buildArgsAtLeastConfirmed([\n            slot\n        ], commitment);\n        const unsafeRes = await this._rpcRequest(\"getConfirmedBlock\", args);\n        const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.create)(unsafeRes, GetConfirmedBlockRpcResult);\n        if (\"error\" in res) {\n            throw new SolanaJSONRPCError(res.error, \"failed to get confirmed block\");\n        }\n        const result = res.result;\n        if (!result) {\n            throw new Error(\"Confirmed block \" + slot + \" not found\");\n        }\n        const block = {\n            ...result,\n            transactions: result.transactions.map(({ transaction, meta })=>{\n                const message = new Message(transaction.message);\n                return {\n                    meta,\n                    transaction: {\n                        ...transaction,\n                        message\n                    }\n                };\n            })\n        };\n        return {\n            ...block,\n            transactions: block.transactions.map(({ transaction, meta })=>{\n                return {\n                    meta,\n                    transaction: Transaction.populate(transaction.message, transaction.signatures)\n                };\n            })\n        };\n    }\n    /**\n   * Fetch confirmed blocks between two slots\n   */ async getBlocks(startSlot, endSlot, commitment) {\n        const args = this._buildArgsAtLeastConfirmed(endSlot !== undefined ? [\n            startSlot,\n            endSlot\n        ] : [\n            startSlot\n        ], commitment);\n        const unsafeRes = await this._rpcRequest(\"getBlocks\", args);\n        const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.create)(unsafeRes, jsonRpcResult((0,superstruct__WEBPACK_IMPORTED_MODULE_15__.array)((0,superstruct__WEBPACK_IMPORTED_MODULE_15__.number)())));\n        if (\"error\" in res) {\n            throw new SolanaJSONRPCError(res.error, \"failed to get blocks\");\n        }\n        return res.result;\n    }\n    /**\n   * Fetch a list of Signatures from the cluster for a block, excluding rewards\n   */ async getBlockSignatures(slot, commitment) {\n        const args = this._buildArgsAtLeastConfirmed([\n            slot\n        ], commitment, undefined, {\n            transactionDetails: \"signatures\",\n            rewards: false\n        });\n        const unsafeRes = await this._rpcRequest(\"getBlock\", args);\n        const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.create)(unsafeRes, GetBlockSignaturesRpcResult);\n        if (\"error\" in res) {\n            throw new SolanaJSONRPCError(res.error, \"failed to get block\");\n        }\n        const result = res.result;\n        if (!result) {\n            throw new Error(\"Block \" + slot + \" not found\");\n        }\n        return result;\n    }\n    /**\n   * Fetch a list of Signatures from the cluster for a confirmed block, excluding rewards\n   *\n   * @deprecated Deprecated since Solana v1.8.0. Please use {@link getBlockSignatures} instead.\n   */ async getConfirmedBlockSignatures(slot, commitment) {\n        const args = this._buildArgsAtLeastConfirmed([\n            slot\n        ], commitment, undefined, {\n            transactionDetails: \"signatures\",\n            rewards: false\n        });\n        const unsafeRes = await this._rpcRequest(\"getConfirmedBlock\", args);\n        const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.create)(unsafeRes, GetBlockSignaturesRpcResult);\n        if (\"error\" in res) {\n            throw new SolanaJSONRPCError(res.error, \"failed to get confirmed block\");\n        }\n        const result = res.result;\n        if (!result) {\n            throw new Error(\"Confirmed block \" + slot + \" not found\");\n        }\n        return result;\n    }\n    /**\n   * Fetch a transaction details for a confirmed transaction\n   *\n   * @deprecated Deprecated since Solana v1.8.0. Please use {@link getTransaction} instead.\n   */ async getConfirmedTransaction(signature, commitment) {\n        const args = this._buildArgsAtLeastConfirmed([\n            signature\n        ], commitment);\n        const unsafeRes = await this._rpcRequest(\"getConfirmedTransaction\", args);\n        const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.create)(unsafeRes, GetTransactionRpcResult);\n        if (\"error\" in res) {\n            throw new SolanaJSONRPCError(res.error, \"failed to get transaction\");\n        }\n        const result = res.result;\n        if (!result) return result;\n        const message = new Message(result.transaction.message);\n        const signatures = result.transaction.signatures;\n        return {\n            ...result,\n            transaction: Transaction.populate(message, signatures)\n        };\n    }\n    /**\n   * Fetch parsed transaction details for a confirmed transaction\n   *\n   * @deprecated Deprecated since Solana v1.8.0. Please use {@link getParsedTransaction} instead.\n   */ async getParsedConfirmedTransaction(signature, commitment) {\n        const args = this._buildArgsAtLeastConfirmed([\n            signature\n        ], commitment, \"jsonParsed\");\n        const unsafeRes = await this._rpcRequest(\"getConfirmedTransaction\", args);\n        const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.create)(unsafeRes, GetParsedTransactionRpcResult);\n        if (\"error\" in res) {\n            throw new SolanaJSONRPCError(res.error, \"failed to get confirmed transaction\");\n        }\n        return res.result;\n    }\n    /**\n   * Fetch parsed transaction details for a batch of confirmed transactions\n   *\n   * @deprecated Deprecated since Solana v1.8.0. Please use {@link getParsedTransactions} instead.\n   */ async getParsedConfirmedTransactions(signatures, commitment) {\n        const batch = signatures.map((signature)=>{\n            const args = this._buildArgsAtLeastConfirmed([\n                signature\n            ], commitment, \"jsonParsed\");\n            return {\n                methodName: \"getConfirmedTransaction\",\n                args\n            };\n        });\n        const unsafeRes = await this._rpcBatchRequest(batch);\n        const res = unsafeRes.map((unsafeRes)=>{\n            const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.create)(unsafeRes, GetParsedTransactionRpcResult);\n            if (\"error\" in res) {\n                throw new SolanaJSONRPCError(res.error, \"failed to get confirmed transactions\");\n            }\n            return res.result;\n        });\n        return res;\n    }\n    /**\n   * Fetch a list of all the confirmed signatures for transactions involving an address\n   * within a specified slot range. Max range allowed is 10,000 slots.\n   *\n   * @deprecated Deprecated since v1.3. Please use {@link getConfirmedSignaturesForAddress2} instead.\n   *\n   * @param address queried address\n   * @param startSlot start slot, inclusive\n   * @param endSlot end slot, inclusive\n   */ async getConfirmedSignaturesForAddress(address, startSlot, endSlot) {\n        let options = {};\n        let firstAvailableBlock = await this.getFirstAvailableBlock();\n        while(!(\"until\" in options)){\n            startSlot--;\n            if (startSlot <= 0 || startSlot < firstAvailableBlock) {\n                break;\n            }\n            try {\n                const block = await this.getConfirmedBlockSignatures(startSlot, \"finalized\");\n                if (block.signatures.length > 0) {\n                    options.until = block.signatures[block.signatures.length - 1].toString();\n                }\n            } catch (err) {\n                if (err instanceof Error && err.message.includes(\"skipped\")) {\n                    continue;\n                } else {\n                    throw err;\n                }\n            }\n        }\n        let highestConfirmedRoot = await this.getSlot(\"finalized\");\n        while(!(\"before\" in options)){\n            endSlot++;\n            if (endSlot > highestConfirmedRoot) {\n                break;\n            }\n            try {\n                const block = await this.getConfirmedBlockSignatures(endSlot);\n                if (block.signatures.length > 0) {\n                    options.before = block.signatures[block.signatures.length - 1].toString();\n                }\n            } catch (err) {\n                if (err instanceof Error && err.message.includes(\"skipped\")) {\n                    continue;\n                } else {\n                    throw err;\n                }\n            }\n        }\n        const confirmedSignatureInfo = await this.getConfirmedSignaturesForAddress2(address, options);\n        return confirmedSignatureInfo.map((info)=>info.signature);\n    }\n    /**\n   * Returns confirmed signatures for transactions involving an\n   * address backwards in time from the provided signature or most recent confirmed block\n   *\n   *\n   * @param address queried address\n   * @param options\n   */ async getConfirmedSignaturesForAddress2(address, options, commitment) {\n        const args = this._buildArgsAtLeastConfirmed([\n            address.toBase58()\n        ], commitment, undefined, options);\n        const unsafeRes = await this._rpcRequest(\"getConfirmedSignaturesForAddress2\", args);\n        const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.create)(unsafeRes, GetConfirmedSignaturesForAddress2RpcResult);\n        if (\"error\" in res) {\n            throw new SolanaJSONRPCError(res.error, \"failed to get confirmed signatures for address\");\n        }\n        return res.result;\n    }\n    /**\n   * Returns confirmed signatures for transactions involving an\n   * address backwards in time from the provided signature or most recent confirmed block\n   *\n   *\n   * @param address queried address\n   * @param options\n   */ async getSignaturesForAddress(address, options, commitment) {\n        const args = this._buildArgsAtLeastConfirmed([\n            address.toBase58()\n        ], commitment, undefined, options);\n        const unsafeRes = await this._rpcRequest(\"getSignaturesForAddress\", args);\n        const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.create)(unsafeRes, GetSignaturesForAddressRpcResult);\n        if (\"error\" in res) {\n            throw new SolanaJSONRPCError(res.error, \"failed to get signatures for address\");\n        }\n        return res.result;\n    }\n    async getAddressLookupTable(accountKey, config) {\n        const { context, value: accountInfo } = await this.getAccountInfoAndContext(accountKey, config);\n        let value = null;\n        if (accountInfo !== null) {\n            value = new AddressLookupTableAccount({\n                key: accountKey,\n                state: AddressLookupTableAccount.deserialize(accountInfo.data)\n            });\n        }\n        return {\n            context,\n            value\n        };\n    }\n    /**\n   * Fetch the contents of a Nonce account from the cluster, return with context\n   */ async getNonceAndContext(nonceAccount, commitmentOrConfig) {\n        const { context, value: accountInfo } = await this.getAccountInfoAndContext(nonceAccount, commitmentOrConfig);\n        let value = null;\n        if (accountInfo !== null) {\n            value = NonceAccount.fromAccountData(accountInfo.data);\n        }\n        return {\n            context,\n            value\n        };\n    }\n    /**\n   * Fetch the contents of a Nonce account from the cluster\n   */ async getNonce(nonceAccount, commitmentOrConfig) {\n        return await this.getNonceAndContext(nonceAccount, commitmentOrConfig).then((x)=>x.value).catch((e)=>{\n            throw new Error(\"failed to get nonce for account \" + nonceAccount.toBase58() + \": \" + e);\n        });\n    }\n    /**\n   * Request an allocation of lamports to the specified address\n   *\n   * ```typescript\n   * import { Connection, PublicKey, LAMPORTS_PER_SOL } from \"@solana/web3.js\";\n   *\n   * (async () => {\n   *   const connection = new Connection(\"https://api.testnet.solana.com\", \"confirmed\");\n   *   const myAddress = new PublicKey(\"2nr1bHFT86W9tGnyvmYW4vcHKsQB3sVQfnddasz4kExM\");\n   *   const signature = await connection.requestAirdrop(myAddress, LAMPORTS_PER_SOL);\n   *   await connection.confirmTransaction(signature);\n   * })();\n   * ```\n   */ async requestAirdrop(to, lamports) {\n        const unsafeRes = await this._rpcRequest(\"requestAirdrop\", [\n            to.toBase58(),\n            lamports\n        ]);\n        const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.create)(unsafeRes, RequestAirdropRpcResult);\n        if (\"error\" in res) {\n            throw new SolanaJSONRPCError(res.error, `airdrop to ${to.toBase58()} failed`);\n        }\n        return res.result;\n    }\n    /**\n   * @internal\n   */ async _blockhashWithExpiryBlockHeight(disableCache) {\n        if (!disableCache) {\n            // Wait for polling to finish\n            while(this._pollingBlockhash){\n                await sleep(100);\n            }\n            const timeSinceFetch = Date.now() - this._blockhashInfo.lastFetch;\n            const expired = timeSinceFetch >= BLOCKHASH_CACHE_TIMEOUT_MS;\n            if (this._blockhashInfo.latestBlockhash !== null && !expired) {\n                return this._blockhashInfo.latestBlockhash;\n            }\n        }\n        return await this._pollNewBlockhash();\n    }\n    /**\n   * @internal\n   */ async _pollNewBlockhash() {\n        this._pollingBlockhash = true;\n        try {\n            const startTime = Date.now();\n            const cachedLatestBlockhash = this._blockhashInfo.latestBlockhash;\n            const cachedBlockhash = cachedLatestBlockhash ? cachedLatestBlockhash.blockhash : null;\n            for(let i = 0; i < 50; i++){\n                const latestBlockhash = await this.getLatestBlockhash(\"finalized\");\n                if (cachedBlockhash !== latestBlockhash.blockhash) {\n                    this._blockhashInfo = {\n                        latestBlockhash,\n                        lastFetch: Date.now(),\n                        transactionSignatures: [],\n                        simulatedSignatures: []\n                    };\n                    return latestBlockhash;\n                }\n                // Sleep for approximately half a slot\n                await sleep(MS_PER_SLOT / 2);\n            }\n            throw new Error(`Unable to obtain a new blockhash after ${Date.now() - startTime}ms`);\n        } finally{\n            this._pollingBlockhash = false;\n        }\n    }\n    /**\n   * get the stake minimum delegation\n   */ async getStakeMinimumDelegation(config) {\n        const { commitment, config: configArg } = extractCommitmentFromConfig(config);\n        const args = this._buildArgs([], commitment, \"base64\", configArg);\n        const unsafeRes = await this._rpcRequest(\"getStakeMinimumDelegation\", args);\n        const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.create)(unsafeRes, jsonRpcResultAndContext((0,superstruct__WEBPACK_IMPORTED_MODULE_15__.number)()));\n        if (\"error\" in res) {\n            throw new SolanaJSONRPCError(res.error, `failed to get stake minimum delegation`);\n        }\n        return res.result;\n    }\n    /**\n   * Simulate a transaction\n   *\n   * @deprecated Instead, call {@link simulateTransaction} with {@link\n   * VersionedTransaction} and {@link SimulateTransactionConfig} parameters\n   */ /**\n   * Simulate a transaction\n   */ // eslint-disable-next-line no-dupe-class-members\n    /**\n   * Simulate a transaction\n   */ // eslint-disable-next-line no-dupe-class-members\n    async simulateTransaction(transactionOrMessage, configOrSigners, includeAccounts) {\n        if (\"message\" in transactionOrMessage) {\n            const versionedTx = transactionOrMessage;\n            const wireTransaction = versionedTx.serialize();\n            const encodedTransaction = buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.from(wireTransaction).toString(\"base64\");\n            if (Array.isArray(configOrSigners) || includeAccounts !== undefined) {\n                throw new Error(\"Invalid arguments\");\n            }\n            const config = configOrSigners || {};\n            config.encoding = \"base64\";\n            if (!(\"commitment\" in config)) {\n                config.commitment = this.commitment;\n            }\n            const args = [\n                encodedTransaction,\n                config\n            ];\n            const unsafeRes = await this._rpcRequest(\"simulateTransaction\", args);\n            const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.create)(unsafeRes, SimulatedTransactionResponseStruct);\n            if (\"error\" in res) {\n                throw new Error(\"failed to simulate transaction: \" + res.error.message);\n            }\n            return res.result;\n        }\n        let transaction;\n        if (transactionOrMessage instanceof Transaction) {\n            let originalTx = transactionOrMessage;\n            transaction = new Transaction();\n            transaction.feePayer = originalTx.feePayer;\n            transaction.instructions = transactionOrMessage.instructions;\n            transaction.nonceInfo = originalTx.nonceInfo;\n            transaction.signatures = originalTx.signatures;\n        } else {\n            transaction = Transaction.populate(transactionOrMessage);\n            // HACK: this function relies on mutating the populated transaction\n            transaction._message = transaction._json = undefined;\n        }\n        if (configOrSigners !== undefined && !Array.isArray(configOrSigners)) {\n            throw new Error(\"Invalid arguments\");\n        }\n        const signers = configOrSigners;\n        if (transaction.nonceInfo && signers) {\n            transaction.sign(...signers);\n        } else {\n            let disableCache = this._disableBlockhashCaching;\n            for(;;){\n                const latestBlockhash = await this._blockhashWithExpiryBlockHeight(disableCache);\n                transaction.lastValidBlockHeight = latestBlockhash.lastValidBlockHeight;\n                transaction.recentBlockhash = latestBlockhash.blockhash;\n                if (!signers) break;\n                transaction.sign(...signers);\n                if (!transaction.signature) {\n                    throw new Error(\"!signature\"); // should never happen\n                }\n                const signature = transaction.signature.toString(\"base64\");\n                if (!this._blockhashInfo.simulatedSignatures.includes(signature) && !this._blockhashInfo.transactionSignatures.includes(signature)) {\n                    // The signature of this transaction has not been seen before with the\n                    // current recentBlockhash, all done. Let's break\n                    this._blockhashInfo.simulatedSignatures.push(signature);\n                    break;\n                } else {\n                    // This transaction would be treated as duplicate (its derived signature\n                    // matched to one of already recorded signatures).\n                    // So, we must fetch a new blockhash for a different signature by disabling\n                    // our cache not to wait for the cache expiration (BLOCKHASH_CACHE_TIMEOUT_MS).\n                    disableCache = true;\n                }\n            }\n        }\n        const message = transaction._compile();\n        const signData = message.serialize();\n        const wireTransaction = transaction._serialize(signData);\n        const encodedTransaction = wireTransaction.toString(\"base64\");\n        const config = {\n            encoding: \"base64\",\n            commitment: this.commitment\n        };\n        if (includeAccounts) {\n            const addresses = (Array.isArray(includeAccounts) ? includeAccounts : message.nonProgramIds()).map((key)=>key.toBase58());\n            config[\"accounts\"] = {\n                encoding: \"base64\",\n                addresses\n            };\n        }\n        if (signers) {\n            config.sigVerify = true;\n        }\n        const args = [\n            encodedTransaction,\n            config\n        ];\n        const unsafeRes = await this._rpcRequest(\"simulateTransaction\", args);\n        const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.create)(unsafeRes, SimulatedTransactionResponseStruct);\n        if (\"error\" in res) {\n            let logs;\n            if (\"data\" in res.error) {\n                logs = res.error.data.logs;\n                if (logs && Array.isArray(logs)) {\n                    const traceIndent = \"\\n    \";\n                    const logTrace = traceIndent + logs.join(traceIndent);\n                    console.error(res.error.message, logTrace);\n                }\n            }\n            throw new SendTransactionError(\"failed to simulate transaction: \" + res.error.message, logs);\n        }\n        return res.result;\n    }\n    /**\n   * Sign and send a transaction\n   *\n   * @deprecated Instead, call {@link sendTransaction} with a {@link\n   * VersionedTransaction}\n   */ /**\n   * Send a signed transaction\n   */ // eslint-disable-next-line no-dupe-class-members\n    /**\n   * Sign and send a transaction\n   */ // eslint-disable-next-line no-dupe-class-members\n    async sendTransaction(transaction, signersOrOptions, options) {\n        if (\"version\" in transaction) {\n            if (signersOrOptions && Array.isArray(signersOrOptions)) {\n                throw new Error(\"Invalid arguments\");\n            }\n            const wireTransaction = transaction.serialize();\n            return await this.sendRawTransaction(wireTransaction, signersOrOptions);\n        }\n        if (signersOrOptions === undefined || !Array.isArray(signersOrOptions)) {\n            throw new Error(\"Invalid arguments\");\n        }\n        const signers = signersOrOptions;\n        if (transaction.nonceInfo) {\n            transaction.sign(...signers);\n        } else {\n            let disableCache = this._disableBlockhashCaching;\n            for(;;){\n                const latestBlockhash = await this._blockhashWithExpiryBlockHeight(disableCache);\n                transaction.lastValidBlockHeight = latestBlockhash.lastValidBlockHeight;\n                transaction.recentBlockhash = latestBlockhash.blockhash;\n                transaction.sign(...signers);\n                if (!transaction.signature) {\n                    throw new Error(\"!signature\"); // should never happen\n                }\n                const signature = transaction.signature.toString(\"base64\");\n                if (!this._blockhashInfo.transactionSignatures.includes(signature)) {\n                    // The signature of this transaction has not been seen before with the\n                    // current recentBlockhash, all done. Let's break\n                    this._blockhashInfo.transactionSignatures.push(signature);\n                    break;\n                } else {\n                    // This transaction would be treated as duplicate (its derived signature\n                    // matched to one of already recorded signatures).\n                    // So, we must fetch a new blockhash for a different signature by disabling\n                    // our cache not to wait for the cache expiration (BLOCKHASH_CACHE_TIMEOUT_MS).\n                    disableCache = true;\n                }\n            }\n        }\n        const wireTransaction = transaction.serialize();\n        return await this.sendRawTransaction(wireTransaction, options);\n    }\n    /**\n   * Send a transaction that has already been signed and serialized into the\n   * wire format\n   */ async sendRawTransaction(rawTransaction, options) {\n        const encodedTransaction = toBuffer(rawTransaction).toString(\"base64\");\n        const result = await this.sendEncodedTransaction(encodedTransaction, options);\n        return result;\n    }\n    /**\n   * Send a transaction that has already been signed, serialized into the\n   * wire format, and encoded as a base64 string\n   */ async sendEncodedTransaction(encodedTransaction, options) {\n        const config = {\n            encoding: \"base64\"\n        };\n        const skipPreflight = options && options.skipPreflight;\n        const preflightCommitment = skipPreflight === true ? \"processed\" // FIXME Remove when https://github.com/anza-xyz/agave/pull/483 is deployed.\n         : options && options.preflightCommitment || this.commitment;\n        if (options && options.maxRetries != null) {\n            config.maxRetries = options.maxRetries;\n        }\n        if (options && options.minContextSlot != null) {\n            config.minContextSlot = options.minContextSlot;\n        }\n        if (skipPreflight) {\n            config.skipPreflight = skipPreflight;\n        }\n        if (preflightCommitment) {\n            config.preflightCommitment = preflightCommitment;\n        }\n        const args = [\n            encodedTransaction,\n            config\n        ];\n        const unsafeRes = await this._rpcRequest(\"sendTransaction\", args);\n        const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.create)(unsafeRes, SendTransactionRpcResult);\n        if (\"error\" in res) {\n            let logs;\n            if (\"data\" in res.error) {\n                logs = res.error.data.logs;\n            }\n            throw new SendTransactionError(\"failed to send transaction: \" + res.error.message, logs);\n        }\n        return res.result;\n    }\n    /**\n   * @internal\n   */ _wsOnOpen() {\n        this._rpcWebSocketConnected = true;\n        this._rpcWebSocketHeartbeat = setInterval(()=>{\n            // Ping server every 5s to prevent idle timeouts\n            (async ()=>{\n                try {\n                    await this._rpcWebSocket.notify(\"ping\");\n                // eslint-disable-next-line no-empty\n                } catch  {}\n            })();\n        }, 5000);\n        this._updateSubscriptions();\n    }\n    /**\n   * @internal\n   */ _wsOnError(err) {\n        this._rpcWebSocketConnected = false;\n        console.error(\"ws error:\", err.message);\n    }\n    /**\n   * @internal\n   */ _wsOnClose(code) {\n        this._rpcWebSocketConnected = false;\n        this._rpcWebSocketGeneration = (this._rpcWebSocketGeneration + 1) % Number.MAX_SAFE_INTEGER;\n        if (this._rpcWebSocketIdleTimeout) {\n            clearTimeout(this._rpcWebSocketIdleTimeout);\n            this._rpcWebSocketIdleTimeout = null;\n        }\n        if (this._rpcWebSocketHeartbeat) {\n            clearInterval(this._rpcWebSocketHeartbeat);\n            this._rpcWebSocketHeartbeat = null;\n        }\n        if (code === 1000) {\n            // explicit close, check if any subscriptions have been made since close\n            this._updateSubscriptions();\n            return;\n        }\n        // implicit close, prepare subscriptions for auto-reconnect\n        this._subscriptionCallbacksByServerSubscriptionId = {};\n        Object.entries(this._subscriptionsByHash).forEach(([hash, subscription])=>{\n            this._setSubscription(hash, {\n                ...subscription,\n                state: \"pending\"\n            });\n        });\n    }\n    /**\n   * @internal\n   */ _setSubscription(hash, nextSubscription) {\n        const prevState = this._subscriptionsByHash[hash]?.state;\n        this._subscriptionsByHash[hash] = nextSubscription;\n        if (prevState !== nextSubscription.state) {\n            const stateChangeCallbacks = this._subscriptionStateChangeCallbacksByHash[hash];\n            if (stateChangeCallbacks) {\n                stateChangeCallbacks.forEach((cb)=>{\n                    try {\n                        cb(nextSubscription.state);\n                    // eslint-disable-next-line no-empty\n                    } catch  {}\n                });\n            }\n        }\n    }\n    /**\n   * @internal\n   */ _onSubscriptionStateChange(clientSubscriptionId, callback) {\n        const hash = this._subscriptionHashByClientSubscriptionId[clientSubscriptionId];\n        if (hash == null) {\n            return ()=>{};\n        }\n        const stateChangeCallbacks = this._subscriptionStateChangeCallbacksByHash[hash] ||= new Set();\n        stateChangeCallbacks.add(callback);\n        return ()=>{\n            stateChangeCallbacks.delete(callback);\n            if (stateChangeCallbacks.size === 0) {\n                delete this._subscriptionStateChangeCallbacksByHash[hash];\n            }\n        };\n    }\n    /**\n   * @internal\n   */ async _updateSubscriptions() {\n        if (Object.keys(this._subscriptionsByHash).length === 0) {\n            if (this._rpcWebSocketConnected) {\n                this._rpcWebSocketConnected = false;\n                this._rpcWebSocketIdleTimeout = setTimeout(()=>{\n                    this._rpcWebSocketIdleTimeout = null;\n                    try {\n                        this._rpcWebSocket.close();\n                    } catch (err) {\n                        // swallow error if socket has already been closed.\n                        if (err instanceof Error) {\n                            console.log(`Error when closing socket connection: ${err.message}`);\n                        }\n                    }\n                }, 500);\n            }\n            return;\n        }\n        if (this._rpcWebSocketIdleTimeout !== null) {\n            clearTimeout(this._rpcWebSocketIdleTimeout);\n            this._rpcWebSocketIdleTimeout = null;\n            this._rpcWebSocketConnected = true;\n        }\n        if (!this._rpcWebSocketConnected) {\n            this._rpcWebSocket.connect();\n            return;\n        }\n        const activeWebSocketGeneration = this._rpcWebSocketGeneration;\n        const isCurrentConnectionStillActive = ()=>{\n            return activeWebSocketGeneration === this._rpcWebSocketGeneration;\n        };\n        await Promise.all(// Don't be tempted to change this to `Object.entries`. We call\n        // `_updateSubscriptions` recursively when processing the state,\n        // so it's important that we look up the *current* version of\n        // each subscription, every time we process a hash.\n        Object.keys(this._subscriptionsByHash).map(async (hash)=>{\n            const subscription = this._subscriptionsByHash[hash];\n            if (subscription === undefined) {\n                // This entry has since been deleted. Skip.\n                return;\n            }\n            switch(subscription.state){\n                case \"pending\":\n                case \"unsubscribed\":\n                    if (subscription.callbacks.size === 0) {\n                        /**\n             * You can end up here when:\n             *\n             * - a subscription has recently unsubscribed\n             *   without having new callbacks added to it\n             *   while the unsubscribe was in flight, or\n             * - when a pending subscription has its\n             *   listeners removed before a request was\n             *   sent to the server.\n             *\n             * Being that nobody is interested in this\n             * subscription any longer, delete it.\n             */ delete this._subscriptionsByHash[hash];\n                        if (subscription.state === \"unsubscribed\") {\n                            delete this._subscriptionCallbacksByServerSubscriptionId[subscription.serverSubscriptionId];\n                        }\n                        await this._updateSubscriptions();\n                        return;\n                    }\n                    await (async ()=>{\n                        const { args, method } = subscription;\n                        try {\n                            this._setSubscription(hash, {\n                                ...subscription,\n                                state: \"subscribing\"\n                            });\n                            const serverSubscriptionId = await this._rpcWebSocket.call(method, args);\n                            this._setSubscription(hash, {\n                                ...subscription,\n                                serverSubscriptionId,\n                                state: \"subscribed\"\n                            });\n                            this._subscriptionCallbacksByServerSubscriptionId[serverSubscriptionId] = subscription.callbacks;\n                            await this._updateSubscriptions();\n                        } catch (e) {\n                            if (e instanceof Error) {\n                                console.error(`${method} error for argument`, args, e.message);\n                            }\n                            if (!isCurrentConnectionStillActive()) {\n                                return;\n                            }\n                            // TODO: Maybe add an 'errored' state or a retry limit?\n                            this._setSubscription(hash, {\n                                ...subscription,\n                                state: \"pending\"\n                            });\n                            await this._updateSubscriptions();\n                        }\n                    })();\n                    break;\n                case \"subscribed\":\n                    if (subscription.callbacks.size === 0) {\n                        // By the time we successfully set up a subscription\n                        // with the server, the client stopped caring about it.\n                        // Tear it down now.\n                        await (async ()=>{\n                            const { serverSubscriptionId, unsubscribeMethod } = subscription;\n                            if (this._subscriptionsAutoDisposedByRpc.has(serverSubscriptionId)) {\n                                /**\n                 * Special case.\n                 * If we're dealing with a subscription that has been auto-\n                 * disposed by the RPC, then we can skip the RPC call to\n                 * tear down the subscription here.\n                 *\n                 * NOTE: There is a proposal to eliminate this special case, here:\n                 * https://github.com/solana-labs/solana/issues/18892\n                 */ this._subscriptionsAutoDisposedByRpc.delete(serverSubscriptionId);\n                            } else {\n                                this._setSubscription(hash, {\n                                    ...subscription,\n                                    state: \"unsubscribing\"\n                                });\n                                this._setSubscription(hash, {\n                                    ...subscription,\n                                    state: \"unsubscribing\"\n                                });\n                                try {\n                                    await this._rpcWebSocket.call(unsubscribeMethod, [\n                                        serverSubscriptionId\n                                    ]);\n                                } catch (e) {\n                                    if (e instanceof Error) {\n                                        console.error(`${unsubscribeMethod} error:`, e.message);\n                                    }\n                                    if (!isCurrentConnectionStillActive()) {\n                                        return;\n                                    }\n                                    // TODO: Maybe add an 'errored' state or a retry limit?\n                                    this._setSubscription(hash, {\n                                        ...subscription,\n                                        state: \"subscribed\"\n                                    });\n                                    await this._updateSubscriptions();\n                                    return;\n                                }\n                            }\n                            this._setSubscription(hash, {\n                                ...subscription,\n                                state: \"unsubscribed\"\n                            });\n                            await this._updateSubscriptions();\n                        })();\n                    }\n                    break;\n            }\n        }));\n    }\n    /**\n   * @internal\n   */ _handleServerNotification(serverSubscriptionId, callbackArgs) {\n        const callbacks = this._subscriptionCallbacksByServerSubscriptionId[serverSubscriptionId];\n        if (callbacks === undefined) {\n            return;\n        }\n        callbacks.forEach((cb)=>{\n            try {\n                cb(// I failed to find a way to convince TypeScript that `cb` is of type\n                // `TCallback` which is certainly compatible with `Parameters<TCallback>`.\n                // See https://github.com/microsoft/TypeScript/issues/47615\n                // @ts-ignore\n                ...callbackArgs);\n            } catch (e) {\n                console.error(e);\n            }\n        });\n    }\n    /**\n   * @internal\n   */ _wsOnAccountNotification(notification) {\n        const { result, subscription } = (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.create)(notification, AccountNotificationResult);\n        this._handleServerNotification(subscription, [\n            result.value,\n            result.context\n        ]);\n    }\n    /**\n   * @internal\n   */ _makeSubscription(subscriptionConfig, /**\n   * When preparing `args` for a call to `_makeSubscription`, be sure\n   * to carefully apply a default `commitment` property, if necessary.\n   *\n   * - If the user supplied a `commitment` use that.\n   * - Otherwise, if the `Connection::commitment` is set, use that.\n   * - Otherwise, set it to the RPC server default: `finalized`.\n   *\n   * This is extremely important to ensure that these two fundamentally\n   * identical subscriptions produce the same identifying hash:\n   *\n   * - A subscription made without specifying a commitment.\n   * - A subscription made where the commitment specified is the same\n   *   as the default applied to the subscription above.\n   *\n   * Example; these two subscriptions must produce the same hash:\n   *\n   * - An `accountSubscribe` subscription for `'PUBKEY'`\n   * - An `accountSubscribe` subscription for `'PUBKEY'` with commitment\n   *   `'finalized'`.\n   *\n   * See the 'making a subscription with defaulted params omitted' test\n   * in `connection-subscriptions.ts` for more.\n   */ args) {\n        const clientSubscriptionId = this._nextClientSubscriptionId++;\n        const hash = fastStableStringify$1([\n            subscriptionConfig.method,\n            args\n        ]);\n        const existingSubscription = this._subscriptionsByHash[hash];\n        if (existingSubscription === undefined) {\n            this._subscriptionsByHash[hash] = {\n                ...subscriptionConfig,\n                args,\n                callbacks: new Set([\n                    subscriptionConfig.callback\n                ]),\n                state: \"pending\"\n            };\n        } else {\n            existingSubscription.callbacks.add(subscriptionConfig.callback);\n        }\n        this._subscriptionHashByClientSubscriptionId[clientSubscriptionId] = hash;\n        this._subscriptionDisposeFunctionsByClientSubscriptionId[clientSubscriptionId] = async ()=>{\n            delete this._subscriptionDisposeFunctionsByClientSubscriptionId[clientSubscriptionId];\n            delete this._subscriptionHashByClientSubscriptionId[clientSubscriptionId];\n            const subscription = this._subscriptionsByHash[hash];\n            assert(subscription !== undefined, `Could not find a \\`Subscription\\` when tearing down client subscription #${clientSubscriptionId}`);\n            subscription.callbacks.delete(subscriptionConfig.callback);\n            await this._updateSubscriptions();\n        };\n        this._updateSubscriptions();\n        return clientSubscriptionId;\n    }\n    /**\n   * Register a callback to be invoked whenever the specified account changes\n   *\n   * @param publicKey Public key of the account to monitor\n   * @param callback Function to invoke whenever the account is changed\n   * @param commitment Specify the commitment level account changes must reach before notification\n   * @return subscription id\n   */ onAccountChange(publicKey, callback, commitment) {\n        const args = this._buildArgs([\n            publicKey.toBase58()\n        ], commitment || this._commitment || \"finalized\", // Apply connection/server default.\n        \"base64\");\n        return this._makeSubscription({\n            callback,\n            method: \"accountSubscribe\",\n            unsubscribeMethod: \"accountUnsubscribe\"\n        }, args);\n    }\n    /**\n   * Deregister an account notification callback\n   *\n   * @param clientSubscriptionId client subscription id to deregister\n   */ async removeAccountChangeListener(clientSubscriptionId) {\n        await this._unsubscribeClientSubscription(clientSubscriptionId, \"account change\");\n    }\n    /**\n   * @internal\n   */ _wsOnProgramAccountNotification(notification) {\n        const { result, subscription } = (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.create)(notification, ProgramAccountNotificationResult);\n        this._handleServerNotification(subscription, [\n            {\n                accountId: result.value.pubkey,\n                accountInfo: result.value.account\n            },\n            result.context\n        ]);\n    }\n    /**\n   * Register a callback to be invoked whenever accounts owned by the\n   * specified program change\n   *\n   * @param programId Public key of the program to monitor\n   * @param callback Function to invoke whenever the account is changed\n   * @param commitment Specify the commitment level account changes must reach before notification\n   * @param filters The program account filters to pass into the RPC method\n   * @return subscription id\n   */ onProgramAccountChange(programId, callback, commitment, filters) {\n        const args = this._buildArgs([\n            programId.toBase58()\n        ], commitment || this._commitment || \"finalized\", // Apply connection/server default.\n        \"base64\" /* encoding */ , filters ? {\n            filters: filters\n        } : undefined /* extra */ );\n        return this._makeSubscription({\n            callback,\n            method: \"programSubscribe\",\n            unsubscribeMethod: \"programUnsubscribe\"\n        }, args);\n    }\n    /**\n   * Deregister an account notification callback\n   *\n   * @param clientSubscriptionId client subscription id to deregister\n   */ async removeProgramAccountChangeListener(clientSubscriptionId) {\n        await this._unsubscribeClientSubscription(clientSubscriptionId, \"program account change\");\n    }\n    /**\n   * Registers a callback to be invoked whenever logs are emitted.\n   */ onLogs(filter, callback, commitment) {\n        const args = this._buildArgs([\n            typeof filter === \"object\" ? {\n                mentions: [\n                    filter.toString()\n                ]\n            } : filter\n        ], commitment || this._commitment || \"finalized\" // Apply connection/server default.\n        );\n        return this._makeSubscription({\n            callback,\n            method: \"logsSubscribe\",\n            unsubscribeMethod: \"logsUnsubscribe\"\n        }, args);\n    }\n    /**\n   * Deregister a logs callback.\n   *\n   * @param clientSubscriptionId client subscription id to deregister.\n   */ async removeOnLogsListener(clientSubscriptionId) {\n        await this._unsubscribeClientSubscription(clientSubscriptionId, \"logs\");\n    }\n    /**\n   * @internal\n   */ _wsOnLogsNotification(notification) {\n        const { result, subscription } = (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.create)(notification, LogsNotificationResult);\n        this._handleServerNotification(subscription, [\n            result.value,\n            result.context\n        ]);\n    }\n    /**\n   * @internal\n   */ _wsOnSlotNotification(notification) {\n        const { result, subscription } = (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.create)(notification, SlotNotificationResult);\n        this._handleServerNotification(subscription, [\n            result\n        ]);\n    }\n    /**\n   * Register a callback to be invoked upon slot changes\n   *\n   * @param callback Function to invoke whenever the slot changes\n   * @return subscription id\n   */ onSlotChange(callback) {\n        return this._makeSubscription({\n            callback,\n            method: \"slotSubscribe\",\n            unsubscribeMethod: \"slotUnsubscribe\"\n        }, []);\n    }\n    /**\n   * Deregister a slot notification callback\n   *\n   * @param clientSubscriptionId client subscription id to deregister\n   */ async removeSlotChangeListener(clientSubscriptionId) {\n        await this._unsubscribeClientSubscription(clientSubscriptionId, \"slot change\");\n    }\n    /**\n   * @internal\n   */ _wsOnSlotUpdatesNotification(notification) {\n        const { result, subscription } = (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.create)(notification, SlotUpdateNotificationResult);\n        this._handleServerNotification(subscription, [\n            result\n        ]);\n    }\n    /**\n   * Register a callback to be invoked upon slot updates. {@link SlotUpdate}'s\n   * may be useful to track live progress of a cluster.\n   *\n   * @param callback Function to invoke whenever the slot updates\n   * @return subscription id\n   */ onSlotUpdate(callback) {\n        return this._makeSubscription({\n            callback,\n            method: \"slotsUpdatesSubscribe\",\n            unsubscribeMethod: \"slotsUpdatesUnsubscribe\"\n        }, []);\n    }\n    /**\n   * Deregister a slot update notification callback\n   *\n   * @param clientSubscriptionId client subscription id to deregister\n   */ async removeSlotUpdateListener(clientSubscriptionId) {\n        await this._unsubscribeClientSubscription(clientSubscriptionId, \"slot update\");\n    }\n    /**\n   * @internal\n   */ async _unsubscribeClientSubscription(clientSubscriptionId, subscriptionName) {\n        const dispose = this._subscriptionDisposeFunctionsByClientSubscriptionId[clientSubscriptionId];\n        if (dispose) {\n            await dispose();\n        } else {\n            console.warn(\"Ignored unsubscribe request because an active subscription with id \" + `\\`${clientSubscriptionId}\\` for '${subscriptionName}' events ` + \"could not be found.\");\n        }\n    }\n    _buildArgs(args, override, encoding, extra) {\n        const commitment = override || this._commitment;\n        if (commitment || encoding || extra) {\n            let options = {};\n            if (encoding) {\n                options.encoding = encoding;\n            }\n            if (commitment) {\n                options.commitment = commitment;\n            }\n            if (extra) {\n                options = Object.assign(options, extra);\n            }\n            args.push(options);\n        }\n        return args;\n    }\n    /**\n   * @internal\n   */ _buildArgsAtLeastConfirmed(args, override, encoding, extra) {\n        const commitment = override || this._commitment;\n        if (commitment && ![\n            \"confirmed\",\n            \"finalized\"\n        ].includes(commitment)) {\n            throw new Error(\"Using Connection with default commitment: `\" + this._commitment + \"`, but method requires at least `confirmed`\");\n        }\n        return this._buildArgs(args, override, encoding, extra);\n    }\n    /**\n   * @internal\n   */ _wsOnSignatureNotification(notification) {\n        const { result, subscription } = (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.create)(notification, SignatureNotificationResult);\n        if (result.value !== \"receivedSignature\") {\n            /**\n       * Special case.\n       * After a signature is processed, RPCs automatically dispose of the\n       * subscription on the server side. We need to track which of these\n       * subscriptions have been disposed in such a way, so that we know\n       * whether the client is dealing with a not-yet-processed signature\n       * (in which case we must tear down the server subscription) or an\n       * already-processed signature (in which case the client can simply\n       * clear out the subscription locally without telling the server).\n       *\n       * NOTE: There is a proposal to eliminate this special case, here:\n       * https://github.com/solana-labs/solana/issues/18892\n       */ this._subscriptionsAutoDisposedByRpc.add(subscription);\n        }\n        this._handleServerNotification(subscription, result.value === \"receivedSignature\" ? [\n            {\n                type: \"received\"\n            },\n            result.context\n        ] : [\n            {\n                type: \"status\",\n                result: result.value\n            },\n            result.context\n        ]);\n    }\n    /**\n   * Register a callback to be invoked upon signature updates\n   *\n   * @param signature Transaction signature string in base 58\n   * @param callback Function to invoke on signature notifications\n   * @param commitment Specify the commitment level signature must reach before notification\n   * @return subscription id\n   */ onSignature(signature, callback, commitment) {\n        const args = this._buildArgs([\n            signature\n        ], commitment || this._commitment || \"finalized\" // Apply connection/server default.\n        );\n        const clientSubscriptionId = this._makeSubscription({\n            callback: (notification, context)=>{\n                if (notification.type === \"status\") {\n                    callback(notification.result, context);\n                    // Signatures subscriptions are auto-removed by the RPC service\n                    // so no need to explicitly send an unsubscribe message.\n                    try {\n                        this.removeSignatureListener(clientSubscriptionId);\n                    // eslint-disable-next-line no-empty\n                    } catch (_err) {\n                    // Already removed.\n                    }\n                }\n            },\n            method: \"signatureSubscribe\",\n            unsubscribeMethod: \"signatureUnsubscribe\"\n        }, args);\n        return clientSubscriptionId;\n    }\n    /**\n   * Register a callback to be invoked when a transaction is\n   * received and/or processed.\n   *\n   * @param signature Transaction signature string in base 58\n   * @param callback Function to invoke on signature notifications\n   * @param options Enable received notifications and set the commitment\n   *   level that signature must reach before notification\n   * @return subscription id\n   */ onSignatureWithOptions(signature, callback, options) {\n        const { commitment, ...extra } = {\n            ...options,\n            commitment: options && options.commitment || this._commitment || \"finalized\" // Apply connection/server default.\n        };\n        const args = this._buildArgs([\n            signature\n        ], commitment, undefined /* encoding */ , extra);\n        const clientSubscriptionId = this._makeSubscription({\n            callback: (notification, context)=>{\n                callback(notification, context);\n                // Signatures subscriptions are auto-removed by the RPC service\n                // so no need to explicitly send an unsubscribe message.\n                try {\n                    this.removeSignatureListener(clientSubscriptionId);\n                // eslint-disable-next-line no-empty\n                } catch (_err) {\n                // Already removed.\n                }\n            },\n            method: \"signatureSubscribe\",\n            unsubscribeMethod: \"signatureUnsubscribe\"\n        }, args);\n        return clientSubscriptionId;\n    }\n    /**\n   * Deregister a signature notification callback\n   *\n   * @param clientSubscriptionId client subscription id to deregister\n   */ async removeSignatureListener(clientSubscriptionId) {\n        await this._unsubscribeClientSubscription(clientSubscriptionId, \"signature result\");\n    }\n    /**\n   * @internal\n   */ _wsOnRootNotification(notification) {\n        const { result, subscription } = (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.create)(notification, RootNotificationResult);\n        this._handleServerNotification(subscription, [\n            result\n        ]);\n    }\n    /**\n   * Register a callback to be invoked upon root changes\n   *\n   * @param callback Function to invoke whenever the root changes\n   * @return subscription id\n   */ onRootChange(callback) {\n        return this._makeSubscription({\n            callback,\n            method: \"rootSubscribe\",\n            unsubscribeMethod: \"rootUnsubscribe\"\n        }, []);\n    }\n    /**\n   * Deregister a root notification callback\n   *\n   * @param clientSubscriptionId client subscription id to deregister\n   */ async removeRootChangeListener(clientSubscriptionId) {\n        await this._unsubscribeClientSubscription(clientSubscriptionId, \"root change\");\n    }\n}\n/**\n * Keypair signer interface\n */ /**\n * An account keypair used for signing transactions.\n */ class Keypair {\n    /**\n   * Create a new keypair instance.\n   * Generate random keypair if no {@link Ed25519Keypair} is provided.\n   *\n   * @param {Ed25519Keypair} keypair ed25519 keypair\n   */ constructor(keypair){\n        this._keypair = void 0;\n        this._keypair = keypair ?? generateKeypair();\n    }\n    /**\n   * Generate a new random keypair\n   *\n   * @returns {Keypair} Keypair\n   */ static generate() {\n        return new Keypair(generateKeypair());\n    }\n    /**\n   * Create a keypair from a raw secret key byte array.\n   *\n   * This method should only be used to recreate a keypair from a previously\n   * generated secret key. Generating keypairs from a random seed should be done\n   * with the {@link Keypair.fromSeed} method.\n   *\n   * @throws error if the provided secret key is invalid and validation is not skipped.\n   *\n   * @param secretKey secret key byte array\n   * @param options skip secret key validation\n   *\n   * @returns {Keypair} Keypair\n   */ static fromSecretKey(secretKey, options) {\n        if (secretKey.byteLength !== 64) {\n            throw new Error(\"bad secret key size\");\n        }\n        const publicKey = secretKey.slice(32, 64);\n        if (!options || !options.skipValidation) {\n            const privateScalar = secretKey.slice(0, 32);\n            const computedPublicKey = getPublicKey(privateScalar);\n            for(let ii = 0; ii < 32; ii++){\n                if (publicKey[ii] !== computedPublicKey[ii]) {\n                    throw new Error(\"provided secretKey is invalid\");\n                }\n            }\n        }\n        return new Keypair({\n            publicKey,\n            secretKey\n        });\n    }\n    /**\n   * Generate a keypair from a 32 byte seed.\n   *\n   * @param seed seed byte array\n   *\n   * @returns {Keypair} Keypair\n   */ static fromSeed(seed) {\n        const publicKey = getPublicKey(seed);\n        const secretKey = new Uint8Array(64);\n        secretKey.set(seed);\n        secretKey.set(publicKey, 32);\n        return new Keypair({\n            publicKey,\n            secretKey\n        });\n    }\n    /**\n   * The public key for this keypair\n   *\n   * @returns {PublicKey} PublicKey\n   */ get publicKey() {\n        return new PublicKey(this._keypair.publicKey);\n    }\n    /**\n   * The raw secret key for this keypair\n   * @returns {Uint8Array} Secret key in an array of Uint8 bytes\n   */ get secretKey() {\n        return new Uint8Array(this._keypair.secretKey);\n    }\n}\n/**\n * An enumeration of valid LookupTableInstructionType's\n */ /**\n * An enumeration of valid address lookup table InstructionType's\n * @internal\n */ const LOOKUP_TABLE_INSTRUCTION_LAYOUTS = Object.freeze({\n    CreateLookupTable: {\n        index: 0,\n        layout: _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.struct([\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u32(\"instruction\"),\n            u64(\"recentSlot\"),\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u8(\"bumpSeed\")\n        ])\n    },\n    FreezeLookupTable: {\n        index: 1,\n        layout: _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.struct([\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u32(\"instruction\")\n        ])\n    },\n    ExtendLookupTable: {\n        index: 2,\n        layout: _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.struct([\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u32(\"instruction\"),\n            u64(),\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.seq(publicKey(), _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.offset(_solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u32(), -8), \"addresses\")\n        ])\n    },\n    DeactivateLookupTable: {\n        index: 3,\n        layout: _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.struct([\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u32(\"instruction\")\n        ])\n    },\n    CloseLookupTable: {\n        index: 4,\n        layout: _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.struct([\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u32(\"instruction\")\n        ])\n    }\n});\nclass AddressLookupTableInstruction {\n    /**\n   * @internal\n   */ constructor(){}\n    static decodeInstructionType(instruction) {\n        this.checkProgramId(instruction.programId);\n        const instructionTypeLayout = _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u32(\"instruction\");\n        const index = instructionTypeLayout.decode(instruction.data);\n        let type;\n        for (const [layoutType, layout] of Object.entries(LOOKUP_TABLE_INSTRUCTION_LAYOUTS)){\n            if (layout.index == index) {\n                type = layoutType;\n                break;\n            }\n        }\n        if (!type) {\n            throw new Error(\"Invalid Instruction. Should be a LookupTable Instruction\");\n        }\n        return type;\n    }\n    static decodeCreateLookupTable(instruction) {\n        this.checkProgramId(instruction.programId);\n        this.checkKeysLength(instruction.keys, 4);\n        const { recentSlot } = decodeData$1(LOOKUP_TABLE_INSTRUCTION_LAYOUTS.CreateLookupTable, instruction.data);\n        return {\n            authority: instruction.keys[1].pubkey,\n            payer: instruction.keys[2].pubkey,\n            recentSlot: Number(recentSlot)\n        };\n    }\n    static decodeExtendLookupTable(instruction) {\n        this.checkProgramId(instruction.programId);\n        if (instruction.keys.length < 2) {\n            throw new Error(`invalid instruction; found ${instruction.keys.length} keys, expected at least 2`);\n        }\n        const { addresses } = decodeData$1(LOOKUP_TABLE_INSTRUCTION_LAYOUTS.ExtendLookupTable, instruction.data);\n        return {\n            lookupTable: instruction.keys[0].pubkey,\n            authority: instruction.keys[1].pubkey,\n            payer: instruction.keys.length > 2 ? instruction.keys[2].pubkey : undefined,\n            addresses: addresses.map((buffer)=>new PublicKey(buffer))\n        };\n    }\n    static decodeCloseLookupTable(instruction) {\n        this.checkProgramId(instruction.programId);\n        this.checkKeysLength(instruction.keys, 3);\n        return {\n            lookupTable: instruction.keys[0].pubkey,\n            authority: instruction.keys[1].pubkey,\n            recipient: instruction.keys[2].pubkey\n        };\n    }\n    static decodeFreezeLookupTable(instruction) {\n        this.checkProgramId(instruction.programId);\n        this.checkKeysLength(instruction.keys, 2);\n        return {\n            lookupTable: instruction.keys[0].pubkey,\n            authority: instruction.keys[1].pubkey\n        };\n    }\n    static decodeDeactivateLookupTable(instruction) {\n        this.checkProgramId(instruction.programId);\n        this.checkKeysLength(instruction.keys, 2);\n        return {\n            lookupTable: instruction.keys[0].pubkey,\n            authority: instruction.keys[1].pubkey\n        };\n    }\n    /**\n   * @internal\n   */ static checkProgramId(programId) {\n        if (!programId.equals(AddressLookupTableProgram.programId)) {\n            throw new Error(\"invalid instruction; programId is not AddressLookupTable Program\");\n        }\n    }\n    /**\n   * @internal\n   */ static checkKeysLength(keys, expectedLength) {\n        if (keys.length < expectedLength) {\n            throw new Error(`invalid instruction; found ${keys.length} keys, expected at least ${expectedLength}`);\n        }\n    }\n}\nclass AddressLookupTableProgram {\n    /**\n   * @internal\n   */ constructor(){}\n    static createLookupTable(params) {\n        const [lookupTableAddress, bumpSeed] = PublicKey.findProgramAddressSync([\n            params.authority.toBuffer(),\n            (0,bigint_buffer__WEBPACK_IMPORTED_MODULE_5__.toBufferLE)(BigInt(params.recentSlot), 8)\n        ], this.programId);\n        const type = LOOKUP_TABLE_INSTRUCTION_LAYOUTS.CreateLookupTable;\n        const data = encodeData(type, {\n            recentSlot: BigInt(params.recentSlot),\n            bumpSeed: bumpSeed\n        });\n        const keys = [\n            {\n                pubkey: lookupTableAddress,\n                isSigner: false,\n                isWritable: true\n            },\n            {\n                pubkey: params.authority,\n                isSigner: true,\n                isWritable: false\n            },\n            {\n                pubkey: params.payer,\n                isSigner: true,\n                isWritable: true\n            },\n            {\n                pubkey: SystemProgram.programId,\n                isSigner: false,\n                isWritable: false\n            }\n        ];\n        return [\n            new TransactionInstruction({\n                programId: this.programId,\n                keys: keys,\n                data: data\n            }),\n            lookupTableAddress\n        ];\n    }\n    static freezeLookupTable(params) {\n        const type = LOOKUP_TABLE_INSTRUCTION_LAYOUTS.FreezeLookupTable;\n        const data = encodeData(type);\n        const keys = [\n            {\n                pubkey: params.lookupTable,\n                isSigner: false,\n                isWritable: true\n            },\n            {\n                pubkey: params.authority,\n                isSigner: true,\n                isWritable: false\n            }\n        ];\n        return new TransactionInstruction({\n            programId: this.programId,\n            keys: keys,\n            data: data\n        });\n    }\n    static extendLookupTable(params) {\n        const type = LOOKUP_TABLE_INSTRUCTION_LAYOUTS.ExtendLookupTable;\n        const data = encodeData(type, {\n            addresses: params.addresses.map((addr)=>addr.toBytes())\n        });\n        const keys = [\n            {\n                pubkey: params.lookupTable,\n                isSigner: false,\n                isWritable: true\n            },\n            {\n                pubkey: params.authority,\n                isSigner: true,\n                isWritable: false\n            }\n        ];\n        if (params.payer) {\n            keys.push({\n                pubkey: params.payer,\n                isSigner: true,\n                isWritable: true\n            }, {\n                pubkey: SystemProgram.programId,\n                isSigner: false,\n                isWritable: false\n            });\n        }\n        return new TransactionInstruction({\n            programId: this.programId,\n            keys: keys,\n            data: data\n        });\n    }\n    static deactivateLookupTable(params) {\n        const type = LOOKUP_TABLE_INSTRUCTION_LAYOUTS.DeactivateLookupTable;\n        const data = encodeData(type);\n        const keys = [\n            {\n                pubkey: params.lookupTable,\n                isSigner: false,\n                isWritable: true\n            },\n            {\n                pubkey: params.authority,\n                isSigner: true,\n                isWritable: false\n            }\n        ];\n        return new TransactionInstruction({\n            programId: this.programId,\n            keys: keys,\n            data: data\n        });\n    }\n    static closeLookupTable(params) {\n        const type = LOOKUP_TABLE_INSTRUCTION_LAYOUTS.CloseLookupTable;\n        const data = encodeData(type);\n        const keys = [\n            {\n                pubkey: params.lookupTable,\n                isSigner: false,\n                isWritable: true\n            },\n            {\n                pubkey: params.authority,\n                isSigner: true,\n                isWritable: false\n            },\n            {\n                pubkey: params.recipient,\n                isSigner: false,\n                isWritable: true\n            }\n        ];\n        return new TransactionInstruction({\n            programId: this.programId,\n            keys: keys,\n            data: data\n        });\n    }\n}\nAddressLookupTableProgram.programId = new PublicKey(\"AddressLookupTab1e1111111111111111111111111\");\n/**\n * Compute Budget Instruction class\n */ class ComputeBudgetInstruction {\n    /**\n   * @internal\n   */ constructor(){}\n    /**\n   * Decode a compute budget instruction and retrieve the instruction type.\n   */ static decodeInstructionType(instruction) {\n        this.checkProgramId(instruction.programId);\n        const instructionTypeLayout = _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u8(\"instruction\");\n        const typeIndex = instructionTypeLayout.decode(instruction.data);\n        let type;\n        for (const [ixType, layout] of Object.entries(COMPUTE_BUDGET_INSTRUCTION_LAYOUTS)){\n            if (layout.index == typeIndex) {\n                type = ixType;\n                break;\n            }\n        }\n        if (!type) {\n            throw new Error(\"Instruction type incorrect; not a ComputeBudgetInstruction\");\n        }\n        return type;\n    }\n    /**\n   * Decode request units compute budget instruction and retrieve the instruction params.\n   */ static decodeRequestUnits(instruction) {\n        this.checkProgramId(instruction.programId);\n        const { units, additionalFee } = decodeData$1(COMPUTE_BUDGET_INSTRUCTION_LAYOUTS.RequestUnits, instruction.data);\n        return {\n            units,\n            additionalFee\n        };\n    }\n    /**\n   * Decode request heap frame compute budget instruction and retrieve the instruction params.\n   */ static decodeRequestHeapFrame(instruction) {\n        this.checkProgramId(instruction.programId);\n        const { bytes } = decodeData$1(COMPUTE_BUDGET_INSTRUCTION_LAYOUTS.RequestHeapFrame, instruction.data);\n        return {\n            bytes\n        };\n    }\n    /**\n   * Decode set compute unit limit compute budget instruction and retrieve the instruction params.\n   */ static decodeSetComputeUnitLimit(instruction) {\n        this.checkProgramId(instruction.programId);\n        const { units } = decodeData$1(COMPUTE_BUDGET_INSTRUCTION_LAYOUTS.SetComputeUnitLimit, instruction.data);\n        return {\n            units\n        };\n    }\n    /**\n   * Decode set compute unit price compute budget instruction and retrieve the instruction params.\n   */ static decodeSetComputeUnitPrice(instruction) {\n        this.checkProgramId(instruction.programId);\n        const { microLamports } = decodeData$1(COMPUTE_BUDGET_INSTRUCTION_LAYOUTS.SetComputeUnitPrice, instruction.data);\n        return {\n            microLamports\n        };\n    }\n    /**\n   * @internal\n   */ static checkProgramId(programId) {\n        if (!programId.equals(ComputeBudgetProgram.programId)) {\n            throw new Error(\"invalid instruction; programId is not ComputeBudgetProgram\");\n        }\n    }\n}\n/**\n * An enumeration of valid ComputeBudgetInstructionType's\n */ /**\n * Request units instruction params\n */ /**\n * Request heap frame instruction params\n */ /**\n * Set compute unit limit instruction params\n */ /**\n * Set compute unit price instruction params\n */ /**\n * An enumeration of valid ComputeBudget InstructionType's\n * @internal\n */ const COMPUTE_BUDGET_INSTRUCTION_LAYOUTS = Object.freeze({\n    RequestUnits: {\n        index: 0,\n        layout: _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.struct([\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u8(\"instruction\"),\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u32(\"units\"),\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u32(\"additionalFee\")\n        ])\n    },\n    RequestHeapFrame: {\n        index: 1,\n        layout: _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.struct([\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u8(\"instruction\"),\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u32(\"bytes\")\n        ])\n    },\n    SetComputeUnitLimit: {\n        index: 2,\n        layout: _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.struct([\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u8(\"instruction\"),\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u32(\"units\")\n        ])\n    },\n    SetComputeUnitPrice: {\n        index: 3,\n        layout: _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.struct([\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u8(\"instruction\"),\n            u64(\"microLamports\")\n        ])\n    }\n});\n/**\n * Factory class for transaction instructions to interact with the Compute Budget program\n */ class ComputeBudgetProgram {\n    /**\n   * @internal\n   */ constructor(){}\n    /**\n   * Public key that identifies the Compute Budget program\n   */ /**\n   * @deprecated Instead, call {@link setComputeUnitLimit} and/or {@link setComputeUnitPrice}\n   */ static requestUnits(params) {\n        const type = COMPUTE_BUDGET_INSTRUCTION_LAYOUTS.RequestUnits;\n        const data = encodeData(type, params);\n        return new TransactionInstruction({\n            keys: [],\n            programId: this.programId,\n            data\n        });\n    }\n    static requestHeapFrame(params) {\n        const type = COMPUTE_BUDGET_INSTRUCTION_LAYOUTS.RequestHeapFrame;\n        const data = encodeData(type, params);\n        return new TransactionInstruction({\n            keys: [],\n            programId: this.programId,\n            data\n        });\n    }\n    static setComputeUnitLimit(params) {\n        const type = COMPUTE_BUDGET_INSTRUCTION_LAYOUTS.SetComputeUnitLimit;\n        const data = encodeData(type, params);\n        return new TransactionInstruction({\n            keys: [],\n            programId: this.programId,\n            data\n        });\n    }\n    static setComputeUnitPrice(params) {\n        const type = COMPUTE_BUDGET_INSTRUCTION_LAYOUTS.SetComputeUnitPrice;\n        const data = encodeData(type, {\n            microLamports: BigInt(params.microLamports)\n        });\n        return new TransactionInstruction({\n            keys: [],\n            programId: this.programId,\n            data\n        });\n    }\n}\nComputeBudgetProgram.programId = new PublicKey(\"ComputeBudget111111111111111111111111111111\");\nconst PRIVATE_KEY_BYTES$1 = 64;\nconst PUBLIC_KEY_BYTES$1 = 32;\nconst SIGNATURE_BYTES = 64;\n/**\n * Params for creating an ed25519 instruction using a public key\n */ /**\n * Params for creating an ed25519 instruction using a private key\n */ const ED25519_INSTRUCTION_LAYOUT = _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.struct([\n    _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u8(\"numSignatures\"),\n    _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u8(\"padding\"),\n    _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u16(\"signatureOffset\"),\n    _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u16(\"signatureInstructionIndex\"),\n    _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u16(\"publicKeyOffset\"),\n    _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u16(\"publicKeyInstructionIndex\"),\n    _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u16(\"messageDataOffset\"),\n    _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u16(\"messageDataSize\"),\n    _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u16(\"messageInstructionIndex\")\n]);\nclass Ed25519Program {\n    /**\n   * @internal\n   */ constructor(){}\n    /**\n   * Public key that identifies the ed25519 program\n   */ /**\n   * Create an ed25519 instruction with a public key and signature. The\n   * public key must be a buffer that is 32 bytes long, and the signature\n   * must be a buffer of 64 bytes.\n   */ static createInstructionWithPublicKey(params) {\n        const { publicKey, message, signature, instructionIndex } = params;\n        assert(publicKey.length === PUBLIC_KEY_BYTES$1, `Public Key must be ${PUBLIC_KEY_BYTES$1} bytes but received ${publicKey.length} bytes`);\n        assert(signature.length === SIGNATURE_BYTES, `Signature must be ${SIGNATURE_BYTES} bytes but received ${signature.length} bytes`);\n        const publicKeyOffset = ED25519_INSTRUCTION_LAYOUT.span;\n        const signatureOffset = publicKeyOffset + publicKey.length;\n        const messageDataOffset = signatureOffset + signature.length;\n        const numSignatures = 1;\n        const instructionData = buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.alloc(messageDataOffset + message.length);\n        const index = instructionIndex == null ? 0xffff // An index of `u16::MAX` makes it default to the current instruction.\n         : instructionIndex;\n        ED25519_INSTRUCTION_LAYOUT.encode({\n            numSignatures,\n            padding: 0,\n            signatureOffset,\n            signatureInstructionIndex: index,\n            publicKeyOffset,\n            publicKeyInstructionIndex: index,\n            messageDataOffset,\n            messageDataSize: message.length,\n            messageInstructionIndex: index\n        }, instructionData);\n        instructionData.fill(publicKey, publicKeyOffset);\n        instructionData.fill(signature, signatureOffset);\n        instructionData.fill(message, messageDataOffset);\n        return new TransactionInstruction({\n            keys: [],\n            programId: Ed25519Program.programId,\n            data: instructionData\n        });\n    }\n    /**\n   * Create an ed25519 instruction with a private key. The private key\n   * must be a buffer that is 64 bytes long.\n   */ static createInstructionWithPrivateKey(params) {\n        const { privateKey, message, instructionIndex } = params;\n        assert(privateKey.length === PRIVATE_KEY_BYTES$1, `Private key must be ${PRIVATE_KEY_BYTES$1} bytes but received ${privateKey.length} bytes`);\n        try {\n            const keypair = Keypair.fromSecretKey(privateKey);\n            const publicKey = keypair.publicKey.toBytes();\n            const signature = sign(message, keypair.secretKey);\n            return this.createInstructionWithPublicKey({\n                publicKey,\n                message,\n                signature,\n                instructionIndex\n            });\n        } catch (error) {\n            throw new Error(`Error creating instruction; ${error}`);\n        }\n    }\n}\nEd25519Program.programId = new PublicKey(\"Ed25519SigVerify111111111111111111111111111\");\nconst ecdsaSign = (msgHash, privKey)=>{\n    const signature = _noble_curves_secp256k1__WEBPACK_IMPORTED_MODULE_16__.secp256k1.sign(msgHash, privKey);\n    return [\n        signature.toCompactRawBytes(),\n        signature.recovery\n    ];\n};\n_noble_curves_secp256k1__WEBPACK_IMPORTED_MODULE_16__.secp256k1.utils.isValidPrivateKey;\nconst publicKeyCreate = _noble_curves_secp256k1__WEBPACK_IMPORTED_MODULE_16__.secp256k1.getPublicKey;\nconst PRIVATE_KEY_BYTES = 32;\nconst ETHEREUM_ADDRESS_BYTES = 20;\nconst PUBLIC_KEY_BYTES = 64;\nconst SIGNATURE_OFFSETS_SERIALIZED_SIZE = 11;\n/**\n * Params for creating an secp256k1 instruction using a public key\n */ /**\n * Params for creating an secp256k1 instruction using an Ethereum address\n */ /**\n * Params for creating an secp256k1 instruction using a private key\n */ const SECP256K1_INSTRUCTION_LAYOUT = _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.struct([\n    _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u8(\"numSignatures\"),\n    _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u16(\"signatureOffset\"),\n    _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u8(\"signatureInstructionIndex\"),\n    _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u16(\"ethAddressOffset\"),\n    _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u8(\"ethAddressInstructionIndex\"),\n    _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u16(\"messageDataOffset\"),\n    _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u16(\"messageDataSize\"),\n    _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u8(\"messageInstructionIndex\"),\n    _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.blob(20, \"ethAddress\"),\n    _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.blob(64, \"signature\"),\n    _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u8(\"recoveryId\")\n]);\nclass Secp256k1Program {\n    /**\n   * @internal\n   */ constructor(){}\n    /**\n   * Public key that identifies the secp256k1 program\n   */ /**\n   * Construct an Ethereum address from a secp256k1 public key buffer.\n   * @param {Buffer} publicKey a 64 byte secp256k1 public key buffer\n   */ static publicKeyToEthAddress(publicKey) {\n        assert(publicKey.length === PUBLIC_KEY_BYTES, `Public key must be ${PUBLIC_KEY_BYTES} bytes but received ${publicKey.length} bytes`);\n        try {\n            return buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.from((0,_noble_hashes_sha3__WEBPACK_IMPORTED_MODULE_17__.keccak_256)(toBuffer(publicKey))).slice(-ETHEREUM_ADDRESS_BYTES);\n        } catch (error) {\n            throw new Error(`Error constructing Ethereum address: ${error}`);\n        }\n    }\n    /**\n   * Create an secp256k1 instruction with a public key. The public key\n   * must be a buffer that is 64 bytes long.\n   */ static createInstructionWithPublicKey(params) {\n        const { publicKey, message, signature, recoveryId, instructionIndex } = params;\n        return Secp256k1Program.createInstructionWithEthAddress({\n            ethAddress: Secp256k1Program.publicKeyToEthAddress(publicKey),\n            message,\n            signature,\n            recoveryId,\n            instructionIndex\n        });\n    }\n    /**\n   * Create an secp256k1 instruction with an Ethereum address. The address\n   * must be a hex string or a buffer that is 20 bytes long.\n   */ static createInstructionWithEthAddress(params) {\n        const { ethAddress: rawAddress, message, signature, recoveryId, instructionIndex = 0 } = params;\n        let ethAddress;\n        if (typeof rawAddress === \"string\") {\n            if (rawAddress.startsWith(\"0x\")) {\n                ethAddress = buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.from(rawAddress.substr(2), \"hex\");\n            } else {\n                ethAddress = buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.from(rawAddress, \"hex\");\n            }\n        } else {\n            ethAddress = rawAddress;\n        }\n        assert(ethAddress.length === ETHEREUM_ADDRESS_BYTES, `Address must be ${ETHEREUM_ADDRESS_BYTES} bytes but received ${ethAddress.length} bytes`);\n        const dataStart = 1 + SIGNATURE_OFFSETS_SERIALIZED_SIZE;\n        const ethAddressOffset = dataStart;\n        const signatureOffset = dataStart + ethAddress.length;\n        const messageDataOffset = signatureOffset + signature.length + 1;\n        const numSignatures = 1;\n        const instructionData = buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.alloc(SECP256K1_INSTRUCTION_LAYOUT.span + message.length);\n        SECP256K1_INSTRUCTION_LAYOUT.encode({\n            numSignatures,\n            signatureOffset,\n            signatureInstructionIndex: instructionIndex,\n            ethAddressOffset,\n            ethAddressInstructionIndex: instructionIndex,\n            messageDataOffset,\n            messageDataSize: message.length,\n            messageInstructionIndex: instructionIndex,\n            signature: toBuffer(signature),\n            ethAddress: toBuffer(ethAddress),\n            recoveryId\n        }, instructionData);\n        instructionData.fill(toBuffer(message), SECP256K1_INSTRUCTION_LAYOUT.span);\n        return new TransactionInstruction({\n            keys: [],\n            programId: Secp256k1Program.programId,\n            data: instructionData\n        });\n    }\n    /**\n   * Create an secp256k1 instruction with a private key. The private key\n   * must be a buffer that is 32 bytes long.\n   */ static createInstructionWithPrivateKey(params) {\n        const { privateKey: pkey, message, instructionIndex } = params;\n        assert(pkey.length === PRIVATE_KEY_BYTES, `Private key must be ${PRIVATE_KEY_BYTES} bytes but received ${pkey.length} bytes`);\n        try {\n            const privateKey = toBuffer(pkey);\n            const publicKey = publicKeyCreate(privateKey, false).slice(1); // throw away leading byte\n            const messageHash = buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.from((0,_noble_hashes_sha3__WEBPACK_IMPORTED_MODULE_17__.keccak_256)(toBuffer(message)));\n            const [signature, recoveryId] = ecdsaSign(messageHash, privateKey);\n            return this.createInstructionWithPublicKey({\n                publicKey,\n                message,\n                signature,\n                recoveryId,\n                instructionIndex\n            });\n        } catch (error) {\n            throw new Error(`Error creating instruction; ${error}`);\n        }\n    }\n}\nSecp256k1Program.programId = new PublicKey(\"KeccakSecp256k11111111111111111111111111111\");\nvar _Lockup;\n/**\n * Address of the stake config account which configures the rate\n * of stake warmup and cooldown as well as the slashing penalty.\n */ const STAKE_CONFIG_ID = new PublicKey(\"StakeConfig11111111111111111111111111111111\");\n/**\n * Stake account authority info\n */ class Authorized {\n    /**\n   * Create a new Authorized object\n   * @param staker the stake authority\n   * @param withdrawer the withdraw authority\n   */ constructor(staker, withdrawer){\n        /** stake authority */ this.staker = void 0;\n        /** withdraw authority */ this.withdrawer = void 0;\n        this.staker = staker;\n        this.withdrawer = withdrawer;\n    }\n}\n/**\n * Stake account lockup info\n */ class Lockup {\n    /**\n   * Create a new Lockup object\n   */ constructor(unixTimestamp, epoch, custodian){\n        /** Unix timestamp of lockup expiration */ this.unixTimestamp = void 0;\n        /** Epoch of lockup expiration */ this.epoch = void 0;\n        /** Lockup custodian authority */ this.custodian = void 0;\n        this.unixTimestamp = unixTimestamp;\n        this.epoch = epoch;\n        this.custodian = custodian;\n    }\n}\n_Lockup = Lockup;\nLockup.default = new _Lockup(0, 0, PublicKey.default);\n/**\n * Create stake account transaction params\n */ /**\n * Create stake account with seed transaction params\n */ /**\n * Initialize stake instruction params\n */ /**\n * Delegate stake instruction params\n */ /**\n * Authorize stake instruction params\n */ /**\n * Authorize stake instruction params using a derived key\n */ /**\n * Split stake instruction params\n */ /**\n * Split with seed transaction params\n */ /**\n * Withdraw stake instruction params\n */ /**\n * Deactivate stake instruction params\n */ /**\n * Merge stake instruction params\n */ /**\n * Stake Instruction class\n */ class StakeInstruction {\n    /**\n   * @internal\n   */ constructor(){}\n    /**\n   * Decode a stake instruction and retrieve the instruction type.\n   */ static decodeInstructionType(instruction) {\n        this.checkProgramId(instruction.programId);\n        const instructionTypeLayout = _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u32(\"instruction\");\n        const typeIndex = instructionTypeLayout.decode(instruction.data);\n        let type;\n        for (const [ixType, layout] of Object.entries(STAKE_INSTRUCTION_LAYOUTS)){\n            if (layout.index == typeIndex) {\n                type = ixType;\n                break;\n            }\n        }\n        if (!type) {\n            throw new Error(\"Instruction type incorrect; not a StakeInstruction\");\n        }\n        return type;\n    }\n    /**\n   * Decode a initialize stake instruction and retrieve the instruction params.\n   */ static decodeInitialize(instruction) {\n        this.checkProgramId(instruction.programId);\n        this.checkKeyLength(instruction.keys, 2);\n        const { authorized, lockup } = decodeData$1(STAKE_INSTRUCTION_LAYOUTS.Initialize, instruction.data);\n        return {\n            stakePubkey: instruction.keys[0].pubkey,\n            authorized: new Authorized(new PublicKey(authorized.staker), new PublicKey(authorized.withdrawer)),\n            lockup: new Lockup(lockup.unixTimestamp, lockup.epoch, new PublicKey(lockup.custodian))\n        };\n    }\n    /**\n   * Decode a delegate stake instruction and retrieve the instruction params.\n   */ static decodeDelegate(instruction) {\n        this.checkProgramId(instruction.programId);\n        this.checkKeyLength(instruction.keys, 6);\n        decodeData$1(STAKE_INSTRUCTION_LAYOUTS.Delegate, instruction.data);\n        return {\n            stakePubkey: instruction.keys[0].pubkey,\n            votePubkey: instruction.keys[1].pubkey,\n            authorizedPubkey: instruction.keys[5].pubkey\n        };\n    }\n    /**\n   * Decode an authorize stake instruction and retrieve the instruction params.\n   */ static decodeAuthorize(instruction) {\n        this.checkProgramId(instruction.programId);\n        this.checkKeyLength(instruction.keys, 3);\n        const { newAuthorized, stakeAuthorizationType } = decodeData$1(STAKE_INSTRUCTION_LAYOUTS.Authorize, instruction.data);\n        const o = {\n            stakePubkey: instruction.keys[0].pubkey,\n            authorizedPubkey: instruction.keys[2].pubkey,\n            newAuthorizedPubkey: new PublicKey(newAuthorized),\n            stakeAuthorizationType: {\n                index: stakeAuthorizationType\n            }\n        };\n        if (instruction.keys.length > 3) {\n            o.custodianPubkey = instruction.keys[3].pubkey;\n        }\n        return o;\n    }\n    /**\n   * Decode an authorize-with-seed stake instruction and retrieve the instruction params.\n   */ static decodeAuthorizeWithSeed(instruction) {\n        this.checkProgramId(instruction.programId);\n        this.checkKeyLength(instruction.keys, 2);\n        const { newAuthorized, stakeAuthorizationType, authoritySeed, authorityOwner } = decodeData$1(STAKE_INSTRUCTION_LAYOUTS.AuthorizeWithSeed, instruction.data);\n        const o = {\n            stakePubkey: instruction.keys[0].pubkey,\n            authorityBase: instruction.keys[1].pubkey,\n            authoritySeed: authoritySeed,\n            authorityOwner: new PublicKey(authorityOwner),\n            newAuthorizedPubkey: new PublicKey(newAuthorized),\n            stakeAuthorizationType: {\n                index: stakeAuthorizationType\n            }\n        };\n        if (instruction.keys.length > 3) {\n            o.custodianPubkey = instruction.keys[3].pubkey;\n        }\n        return o;\n    }\n    /**\n   * Decode a split stake instruction and retrieve the instruction params.\n   */ static decodeSplit(instruction) {\n        this.checkProgramId(instruction.programId);\n        this.checkKeyLength(instruction.keys, 3);\n        const { lamports } = decodeData$1(STAKE_INSTRUCTION_LAYOUTS.Split, instruction.data);\n        return {\n            stakePubkey: instruction.keys[0].pubkey,\n            splitStakePubkey: instruction.keys[1].pubkey,\n            authorizedPubkey: instruction.keys[2].pubkey,\n            lamports\n        };\n    }\n    /**\n   * Decode a merge stake instruction and retrieve the instruction params.\n   */ static decodeMerge(instruction) {\n        this.checkProgramId(instruction.programId);\n        this.checkKeyLength(instruction.keys, 3);\n        decodeData$1(STAKE_INSTRUCTION_LAYOUTS.Merge, instruction.data);\n        return {\n            stakePubkey: instruction.keys[0].pubkey,\n            sourceStakePubKey: instruction.keys[1].pubkey,\n            authorizedPubkey: instruction.keys[4].pubkey\n        };\n    }\n    /**\n   * Decode a withdraw stake instruction and retrieve the instruction params.\n   */ static decodeWithdraw(instruction) {\n        this.checkProgramId(instruction.programId);\n        this.checkKeyLength(instruction.keys, 5);\n        const { lamports } = decodeData$1(STAKE_INSTRUCTION_LAYOUTS.Withdraw, instruction.data);\n        const o = {\n            stakePubkey: instruction.keys[0].pubkey,\n            toPubkey: instruction.keys[1].pubkey,\n            authorizedPubkey: instruction.keys[4].pubkey,\n            lamports\n        };\n        if (instruction.keys.length > 5) {\n            o.custodianPubkey = instruction.keys[5].pubkey;\n        }\n        return o;\n    }\n    /**\n   * Decode a deactivate stake instruction and retrieve the instruction params.\n   */ static decodeDeactivate(instruction) {\n        this.checkProgramId(instruction.programId);\n        this.checkKeyLength(instruction.keys, 3);\n        decodeData$1(STAKE_INSTRUCTION_LAYOUTS.Deactivate, instruction.data);\n        return {\n            stakePubkey: instruction.keys[0].pubkey,\n            authorizedPubkey: instruction.keys[2].pubkey\n        };\n    }\n    /**\n   * @internal\n   */ static checkProgramId(programId) {\n        if (!programId.equals(StakeProgram.programId)) {\n            throw new Error(\"invalid instruction; programId is not StakeProgram\");\n        }\n    }\n    /**\n   * @internal\n   */ static checkKeyLength(keys, expectedLength) {\n        if (keys.length < expectedLength) {\n            throw new Error(`invalid instruction; found ${keys.length} keys, expected at least ${expectedLength}`);\n        }\n    }\n}\n/**\n * An enumeration of valid StakeInstructionType's\n */ /**\n * An enumeration of valid stake InstructionType's\n * @internal\n */ const STAKE_INSTRUCTION_LAYOUTS = Object.freeze({\n    Initialize: {\n        index: 0,\n        layout: _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.struct([\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u32(\"instruction\"),\n            authorized(),\n            lockup()\n        ])\n    },\n    Authorize: {\n        index: 1,\n        layout: _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.struct([\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u32(\"instruction\"),\n            publicKey(\"newAuthorized\"),\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u32(\"stakeAuthorizationType\")\n        ])\n    },\n    Delegate: {\n        index: 2,\n        layout: _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.struct([\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u32(\"instruction\")\n        ])\n    },\n    Split: {\n        index: 3,\n        layout: _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.struct([\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u32(\"instruction\"),\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.ns64(\"lamports\")\n        ])\n    },\n    Withdraw: {\n        index: 4,\n        layout: _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.struct([\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u32(\"instruction\"),\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.ns64(\"lamports\")\n        ])\n    },\n    Deactivate: {\n        index: 5,\n        layout: _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.struct([\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u32(\"instruction\")\n        ])\n    },\n    Merge: {\n        index: 7,\n        layout: _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.struct([\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u32(\"instruction\")\n        ])\n    },\n    AuthorizeWithSeed: {\n        index: 8,\n        layout: _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.struct([\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u32(\"instruction\"),\n            publicKey(\"newAuthorized\"),\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u32(\"stakeAuthorizationType\"),\n            rustString(\"authoritySeed\"),\n            publicKey(\"authorityOwner\")\n        ])\n    }\n});\n/**\n * Stake authorization type\n */ /**\n * An enumeration of valid StakeAuthorizationLayout's\n */ const StakeAuthorizationLayout = Object.freeze({\n    Staker: {\n        index: 0\n    },\n    Withdrawer: {\n        index: 1\n    }\n});\n/**\n * Factory class for transactions to interact with the Stake program\n */ class StakeProgram {\n    /**\n   * @internal\n   */ constructor(){}\n    /**\n   * Public key that identifies the Stake program\n   */ /**\n   * Generate an Initialize instruction to add to a Stake Create transaction\n   */ static initialize(params) {\n        const { stakePubkey, authorized, lockup: maybeLockup } = params;\n        const lockup = maybeLockup || Lockup.default;\n        const type = STAKE_INSTRUCTION_LAYOUTS.Initialize;\n        const data = encodeData(type, {\n            authorized: {\n                staker: toBuffer(authorized.staker.toBuffer()),\n                withdrawer: toBuffer(authorized.withdrawer.toBuffer())\n            },\n            lockup: {\n                unixTimestamp: lockup.unixTimestamp,\n                epoch: lockup.epoch,\n                custodian: toBuffer(lockup.custodian.toBuffer())\n            }\n        });\n        const instructionData = {\n            keys: [\n                {\n                    pubkey: stakePubkey,\n                    isSigner: false,\n                    isWritable: true\n                },\n                {\n                    pubkey: SYSVAR_RENT_PUBKEY,\n                    isSigner: false,\n                    isWritable: false\n                }\n            ],\n            programId: this.programId,\n            data\n        };\n        return new TransactionInstruction(instructionData);\n    }\n    /**\n   * Generate a Transaction that creates a new Stake account at\n   *   an address generated with `from`, a seed, and the Stake programId\n   */ static createAccountWithSeed(params) {\n        const transaction = new Transaction();\n        transaction.add(SystemProgram.createAccountWithSeed({\n            fromPubkey: params.fromPubkey,\n            newAccountPubkey: params.stakePubkey,\n            basePubkey: params.basePubkey,\n            seed: params.seed,\n            lamports: params.lamports,\n            space: this.space,\n            programId: this.programId\n        }));\n        const { stakePubkey, authorized, lockup } = params;\n        return transaction.add(this.initialize({\n            stakePubkey,\n            authorized,\n            lockup\n        }));\n    }\n    /**\n   * Generate a Transaction that creates a new Stake account\n   */ static createAccount(params) {\n        const transaction = new Transaction();\n        transaction.add(SystemProgram.createAccount({\n            fromPubkey: params.fromPubkey,\n            newAccountPubkey: params.stakePubkey,\n            lamports: params.lamports,\n            space: this.space,\n            programId: this.programId\n        }));\n        const { stakePubkey, authorized, lockup } = params;\n        return transaction.add(this.initialize({\n            stakePubkey,\n            authorized,\n            lockup\n        }));\n    }\n    /**\n   * Generate a Transaction that delegates Stake tokens to a validator\n   * Vote PublicKey. This transaction can also be used to redelegate Stake\n   * to a new validator Vote PublicKey.\n   */ static delegate(params) {\n        const { stakePubkey, authorizedPubkey, votePubkey } = params;\n        const type = STAKE_INSTRUCTION_LAYOUTS.Delegate;\n        const data = encodeData(type);\n        return new Transaction().add({\n            keys: [\n                {\n                    pubkey: stakePubkey,\n                    isSigner: false,\n                    isWritable: true\n                },\n                {\n                    pubkey: votePubkey,\n                    isSigner: false,\n                    isWritable: false\n                },\n                {\n                    pubkey: SYSVAR_CLOCK_PUBKEY,\n                    isSigner: false,\n                    isWritable: false\n                },\n                {\n                    pubkey: SYSVAR_STAKE_HISTORY_PUBKEY,\n                    isSigner: false,\n                    isWritable: false\n                },\n                {\n                    pubkey: STAKE_CONFIG_ID,\n                    isSigner: false,\n                    isWritable: false\n                },\n                {\n                    pubkey: authorizedPubkey,\n                    isSigner: true,\n                    isWritable: false\n                }\n            ],\n            programId: this.programId,\n            data\n        });\n    }\n    /**\n   * Generate a Transaction that authorizes a new PublicKey as Staker\n   * or Withdrawer on the Stake account.\n   */ static authorize(params) {\n        const { stakePubkey, authorizedPubkey, newAuthorizedPubkey, stakeAuthorizationType, custodianPubkey } = params;\n        const type = STAKE_INSTRUCTION_LAYOUTS.Authorize;\n        const data = encodeData(type, {\n            newAuthorized: toBuffer(newAuthorizedPubkey.toBuffer()),\n            stakeAuthorizationType: stakeAuthorizationType.index\n        });\n        const keys = [\n            {\n                pubkey: stakePubkey,\n                isSigner: false,\n                isWritable: true\n            },\n            {\n                pubkey: SYSVAR_CLOCK_PUBKEY,\n                isSigner: false,\n                isWritable: true\n            },\n            {\n                pubkey: authorizedPubkey,\n                isSigner: true,\n                isWritable: false\n            }\n        ];\n        if (custodianPubkey) {\n            keys.push({\n                pubkey: custodianPubkey,\n                isSigner: true,\n                isWritable: false\n            });\n        }\n        return new Transaction().add({\n            keys,\n            programId: this.programId,\n            data\n        });\n    }\n    /**\n   * Generate a Transaction that authorizes a new PublicKey as Staker\n   * or Withdrawer on the Stake account.\n   */ static authorizeWithSeed(params) {\n        const { stakePubkey, authorityBase, authoritySeed, authorityOwner, newAuthorizedPubkey, stakeAuthorizationType, custodianPubkey } = params;\n        const type = STAKE_INSTRUCTION_LAYOUTS.AuthorizeWithSeed;\n        const data = encodeData(type, {\n            newAuthorized: toBuffer(newAuthorizedPubkey.toBuffer()),\n            stakeAuthorizationType: stakeAuthorizationType.index,\n            authoritySeed: authoritySeed,\n            authorityOwner: toBuffer(authorityOwner.toBuffer())\n        });\n        const keys = [\n            {\n                pubkey: stakePubkey,\n                isSigner: false,\n                isWritable: true\n            },\n            {\n                pubkey: authorityBase,\n                isSigner: true,\n                isWritable: false\n            },\n            {\n                pubkey: SYSVAR_CLOCK_PUBKEY,\n                isSigner: false,\n                isWritable: false\n            }\n        ];\n        if (custodianPubkey) {\n            keys.push({\n                pubkey: custodianPubkey,\n                isSigner: true,\n                isWritable: false\n            });\n        }\n        return new Transaction().add({\n            keys,\n            programId: this.programId,\n            data\n        });\n    }\n    /**\n   * @internal\n   */ static splitInstruction(params) {\n        const { stakePubkey, authorizedPubkey, splitStakePubkey, lamports } = params;\n        const type = STAKE_INSTRUCTION_LAYOUTS.Split;\n        const data = encodeData(type, {\n            lamports\n        });\n        return new TransactionInstruction({\n            keys: [\n                {\n                    pubkey: stakePubkey,\n                    isSigner: false,\n                    isWritable: true\n                },\n                {\n                    pubkey: splitStakePubkey,\n                    isSigner: false,\n                    isWritable: true\n                },\n                {\n                    pubkey: authorizedPubkey,\n                    isSigner: true,\n                    isWritable: false\n                }\n            ],\n            programId: this.programId,\n            data\n        });\n    }\n    /**\n   * Generate a Transaction that splits Stake tokens into another stake account\n   */ static split(params, // Compute the cost of allocating the new stake account in lamports\n    rentExemptReserve) {\n        const transaction = new Transaction();\n        transaction.add(SystemProgram.createAccount({\n            fromPubkey: params.authorizedPubkey,\n            newAccountPubkey: params.splitStakePubkey,\n            lamports: rentExemptReserve,\n            space: this.space,\n            programId: this.programId\n        }));\n        return transaction.add(this.splitInstruction(params));\n    }\n    /**\n   * Generate a Transaction that splits Stake tokens into another account\n   * derived from a base public key and seed\n   */ static splitWithSeed(params, // If this stake account is new, compute the cost of allocating it in lamports\n    rentExemptReserve) {\n        const { stakePubkey, authorizedPubkey, splitStakePubkey, basePubkey, seed, lamports } = params;\n        const transaction = new Transaction();\n        transaction.add(SystemProgram.allocate({\n            accountPubkey: splitStakePubkey,\n            basePubkey,\n            seed,\n            space: this.space,\n            programId: this.programId\n        }));\n        if (rentExemptReserve && rentExemptReserve > 0) {\n            transaction.add(SystemProgram.transfer({\n                fromPubkey: params.authorizedPubkey,\n                toPubkey: splitStakePubkey,\n                lamports: rentExemptReserve\n            }));\n        }\n        return transaction.add(this.splitInstruction({\n            stakePubkey,\n            authorizedPubkey,\n            splitStakePubkey,\n            lamports\n        }));\n    }\n    /**\n   * Generate a Transaction that merges Stake accounts.\n   */ static merge(params) {\n        const { stakePubkey, sourceStakePubKey, authorizedPubkey } = params;\n        const type = STAKE_INSTRUCTION_LAYOUTS.Merge;\n        const data = encodeData(type);\n        return new Transaction().add({\n            keys: [\n                {\n                    pubkey: stakePubkey,\n                    isSigner: false,\n                    isWritable: true\n                },\n                {\n                    pubkey: sourceStakePubKey,\n                    isSigner: false,\n                    isWritable: true\n                },\n                {\n                    pubkey: SYSVAR_CLOCK_PUBKEY,\n                    isSigner: false,\n                    isWritable: false\n                },\n                {\n                    pubkey: SYSVAR_STAKE_HISTORY_PUBKEY,\n                    isSigner: false,\n                    isWritable: false\n                },\n                {\n                    pubkey: authorizedPubkey,\n                    isSigner: true,\n                    isWritable: false\n                }\n            ],\n            programId: this.programId,\n            data\n        });\n    }\n    /**\n   * Generate a Transaction that withdraws deactivated Stake tokens.\n   */ static withdraw(params) {\n        const { stakePubkey, authorizedPubkey, toPubkey, lamports, custodianPubkey } = params;\n        const type = STAKE_INSTRUCTION_LAYOUTS.Withdraw;\n        const data = encodeData(type, {\n            lamports\n        });\n        const keys = [\n            {\n                pubkey: stakePubkey,\n                isSigner: false,\n                isWritable: true\n            },\n            {\n                pubkey: toPubkey,\n                isSigner: false,\n                isWritable: true\n            },\n            {\n                pubkey: SYSVAR_CLOCK_PUBKEY,\n                isSigner: false,\n                isWritable: false\n            },\n            {\n                pubkey: SYSVAR_STAKE_HISTORY_PUBKEY,\n                isSigner: false,\n                isWritable: false\n            },\n            {\n                pubkey: authorizedPubkey,\n                isSigner: true,\n                isWritable: false\n            }\n        ];\n        if (custodianPubkey) {\n            keys.push({\n                pubkey: custodianPubkey,\n                isSigner: true,\n                isWritable: false\n            });\n        }\n        return new Transaction().add({\n            keys,\n            programId: this.programId,\n            data\n        });\n    }\n    /**\n   * Generate a Transaction that deactivates Stake tokens.\n   */ static deactivate(params) {\n        const { stakePubkey, authorizedPubkey } = params;\n        const type = STAKE_INSTRUCTION_LAYOUTS.Deactivate;\n        const data = encodeData(type);\n        return new Transaction().add({\n            keys: [\n                {\n                    pubkey: stakePubkey,\n                    isSigner: false,\n                    isWritable: true\n                },\n                {\n                    pubkey: SYSVAR_CLOCK_PUBKEY,\n                    isSigner: false,\n                    isWritable: false\n                },\n                {\n                    pubkey: authorizedPubkey,\n                    isSigner: true,\n                    isWritable: false\n                }\n            ],\n            programId: this.programId,\n            data\n        });\n    }\n}\nStakeProgram.programId = new PublicKey(\"Stake11111111111111111111111111111111111111\");\n/**\n * Max space of a Stake account\n *\n * This is generated from the solana-stake-program StakeState struct as\n * `StakeStateV2::size_of()`:\n * https://docs.rs/solana-stake-program/latest/solana_stake_program/stake_state/enum.StakeStateV2.html\n */ StakeProgram.space = 200;\n/**\n * Vote account info\n */ class VoteInit {\n    /** [0, 100] */ constructor(nodePubkey, authorizedVoter, authorizedWithdrawer, commission){\n        this.nodePubkey = void 0;\n        this.authorizedVoter = void 0;\n        this.authorizedWithdrawer = void 0;\n        this.commission = void 0;\n        this.nodePubkey = nodePubkey;\n        this.authorizedVoter = authorizedVoter;\n        this.authorizedWithdrawer = authorizedWithdrawer;\n        this.commission = commission;\n    }\n}\n/**\n * Create vote account transaction params\n */ /**\n * InitializeAccount instruction params\n */ /**\n * Authorize instruction params\n */ /**\n * AuthorizeWithSeed instruction params\n */ /**\n * Withdraw from vote account transaction params\n */ /**\n * Update validator identity (node pubkey) vote account instruction params.\n */ /**\n * Vote Instruction class\n */ class VoteInstruction {\n    /**\n   * @internal\n   */ constructor(){}\n    /**\n   * Decode a vote instruction and retrieve the instruction type.\n   */ static decodeInstructionType(instruction) {\n        this.checkProgramId(instruction.programId);\n        const instructionTypeLayout = _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u32(\"instruction\");\n        const typeIndex = instructionTypeLayout.decode(instruction.data);\n        let type;\n        for (const [ixType, layout] of Object.entries(VOTE_INSTRUCTION_LAYOUTS)){\n            if (layout.index == typeIndex) {\n                type = ixType;\n                break;\n            }\n        }\n        if (!type) {\n            throw new Error(\"Instruction type incorrect; not a VoteInstruction\");\n        }\n        return type;\n    }\n    /**\n   * Decode an initialize vote instruction and retrieve the instruction params.\n   */ static decodeInitializeAccount(instruction) {\n        this.checkProgramId(instruction.programId);\n        this.checkKeyLength(instruction.keys, 4);\n        const { voteInit } = decodeData$1(VOTE_INSTRUCTION_LAYOUTS.InitializeAccount, instruction.data);\n        return {\n            votePubkey: instruction.keys[0].pubkey,\n            nodePubkey: instruction.keys[3].pubkey,\n            voteInit: new VoteInit(new PublicKey(voteInit.nodePubkey), new PublicKey(voteInit.authorizedVoter), new PublicKey(voteInit.authorizedWithdrawer), voteInit.commission)\n        };\n    }\n    /**\n   * Decode an authorize instruction and retrieve the instruction params.\n   */ static decodeAuthorize(instruction) {\n        this.checkProgramId(instruction.programId);\n        this.checkKeyLength(instruction.keys, 3);\n        const { newAuthorized, voteAuthorizationType } = decodeData$1(VOTE_INSTRUCTION_LAYOUTS.Authorize, instruction.data);\n        return {\n            votePubkey: instruction.keys[0].pubkey,\n            authorizedPubkey: instruction.keys[2].pubkey,\n            newAuthorizedPubkey: new PublicKey(newAuthorized),\n            voteAuthorizationType: {\n                index: voteAuthorizationType\n            }\n        };\n    }\n    /**\n   * Decode an authorize instruction and retrieve the instruction params.\n   */ static decodeAuthorizeWithSeed(instruction) {\n        this.checkProgramId(instruction.programId);\n        this.checkKeyLength(instruction.keys, 3);\n        const { voteAuthorizeWithSeedArgs: { currentAuthorityDerivedKeyOwnerPubkey, currentAuthorityDerivedKeySeed, newAuthorized, voteAuthorizationType } } = decodeData$1(VOTE_INSTRUCTION_LAYOUTS.AuthorizeWithSeed, instruction.data);\n        return {\n            currentAuthorityDerivedKeyBasePubkey: instruction.keys[2].pubkey,\n            currentAuthorityDerivedKeyOwnerPubkey: new PublicKey(currentAuthorityDerivedKeyOwnerPubkey),\n            currentAuthorityDerivedKeySeed: currentAuthorityDerivedKeySeed,\n            newAuthorizedPubkey: new PublicKey(newAuthorized),\n            voteAuthorizationType: {\n                index: voteAuthorizationType\n            },\n            votePubkey: instruction.keys[0].pubkey\n        };\n    }\n    /**\n   * Decode a withdraw instruction and retrieve the instruction params.\n   */ static decodeWithdraw(instruction) {\n        this.checkProgramId(instruction.programId);\n        this.checkKeyLength(instruction.keys, 3);\n        const { lamports } = decodeData$1(VOTE_INSTRUCTION_LAYOUTS.Withdraw, instruction.data);\n        return {\n            votePubkey: instruction.keys[0].pubkey,\n            authorizedWithdrawerPubkey: instruction.keys[2].pubkey,\n            lamports,\n            toPubkey: instruction.keys[1].pubkey\n        };\n    }\n    /**\n   * @internal\n   */ static checkProgramId(programId) {\n        if (!programId.equals(VoteProgram.programId)) {\n            throw new Error(\"invalid instruction; programId is not VoteProgram\");\n        }\n    }\n    /**\n   * @internal\n   */ static checkKeyLength(keys, expectedLength) {\n        if (keys.length < expectedLength) {\n            throw new Error(`invalid instruction; found ${keys.length} keys, expected at least ${expectedLength}`);\n        }\n    }\n}\n/**\n * An enumeration of valid VoteInstructionType's\n */ /** @internal */ const VOTE_INSTRUCTION_LAYOUTS = Object.freeze({\n    InitializeAccount: {\n        index: 0,\n        layout: _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.struct([\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u32(\"instruction\"),\n            voteInit()\n        ])\n    },\n    Authorize: {\n        index: 1,\n        layout: _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.struct([\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u32(\"instruction\"),\n            publicKey(\"newAuthorized\"),\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u32(\"voteAuthorizationType\")\n        ])\n    },\n    Withdraw: {\n        index: 3,\n        layout: _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.struct([\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u32(\"instruction\"),\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.ns64(\"lamports\")\n        ])\n    },\n    UpdateValidatorIdentity: {\n        index: 4,\n        layout: _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.struct([\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u32(\"instruction\")\n        ])\n    },\n    AuthorizeWithSeed: {\n        index: 10,\n        layout: _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.struct([\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u32(\"instruction\"),\n            voteAuthorizeWithSeedArgs()\n        ])\n    }\n});\n/**\n * VoteAuthorize type\n */ /**\n * An enumeration of valid VoteAuthorization layouts.\n */ const VoteAuthorizationLayout = Object.freeze({\n    Voter: {\n        index: 0\n    },\n    Withdrawer: {\n        index: 1\n    }\n});\n/**\n * Factory class for transactions to interact with the Vote program\n */ class VoteProgram {\n    /**\n   * @internal\n   */ constructor(){}\n    /**\n   * Public key that identifies the Vote program\n   */ /**\n   * Generate an Initialize instruction.\n   */ static initializeAccount(params) {\n        const { votePubkey, nodePubkey, voteInit } = params;\n        const type = VOTE_INSTRUCTION_LAYOUTS.InitializeAccount;\n        const data = encodeData(type, {\n            voteInit: {\n                nodePubkey: toBuffer(voteInit.nodePubkey.toBuffer()),\n                authorizedVoter: toBuffer(voteInit.authorizedVoter.toBuffer()),\n                authorizedWithdrawer: toBuffer(voteInit.authorizedWithdrawer.toBuffer()),\n                commission: voteInit.commission\n            }\n        });\n        const instructionData = {\n            keys: [\n                {\n                    pubkey: votePubkey,\n                    isSigner: false,\n                    isWritable: true\n                },\n                {\n                    pubkey: SYSVAR_RENT_PUBKEY,\n                    isSigner: false,\n                    isWritable: false\n                },\n                {\n                    pubkey: SYSVAR_CLOCK_PUBKEY,\n                    isSigner: false,\n                    isWritable: false\n                },\n                {\n                    pubkey: nodePubkey,\n                    isSigner: true,\n                    isWritable: false\n                }\n            ],\n            programId: this.programId,\n            data\n        };\n        return new TransactionInstruction(instructionData);\n    }\n    /**\n   * Generate a transaction that creates a new Vote account.\n   */ static createAccount(params) {\n        const transaction = new Transaction();\n        transaction.add(SystemProgram.createAccount({\n            fromPubkey: params.fromPubkey,\n            newAccountPubkey: params.votePubkey,\n            lamports: params.lamports,\n            space: this.space,\n            programId: this.programId\n        }));\n        return transaction.add(this.initializeAccount({\n            votePubkey: params.votePubkey,\n            nodePubkey: params.voteInit.nodePubkey,\n            voteInit: params.voteInit\n        }));\n    }\n    /**\n   * Generate a transaction that authorizes a new Voter or Withdrawer on the Vote account.\n   */ static authorize(params) {\n        const { votePubkey, authorizedPubkey, newAuthorizedPubkey, voteAuthorizationType } = params;\n        const type = VOTE_INSTRUCTION_LAYOUTS.Authorize;\n        const data = encodeData(type, {\n            newAuthorized: toBuffer(newAuthorizedPubkey.toBuffer()),\n            voteAuthorizationType: voteAuthorizationType.index\n        });\n        const keys = [\n            {\n                pubkey: votePubkey,\n                isSigner: false,\n                isWritable: true\n            },\n            {\n                pubkey: SYSVAR_CLOCK_PUBKEY,\n                isSigner: false,\n                isWritable: false\n            },\n            {\n                pubkey: authorizedPubkey,\n                isSigner: true,\n                isWritable: false\n            }\n        ];\n        return new Transaction().add({\n            keys,\n            programId: this.programId,\n            data\n        });\n    }\n    /**\n   * Generate a transaction that authorizes a new Voter or Withdrawer on the Vote account\n   * where the current Voter or Withdrawer authority is a derived key.\n   */ static authorizeWithSeed(params) {\n        const { currentAuthorityDerivedKeyBasePubkey, currentAuthorityDerivedKeyOwnerPubkey, currentAuthorityDerivedKeySeed, newAuthorizedPubkey, voteAuthorizationType, votePubkey } = params;\n        const type = VOTE_INSTRUCTION_LAYOUTS.AuthorizeWithSeed;\n        const data = encodeData(type, {\n            voteAuthorizeWithSeedArgs: {\n                currentAuthorityDerivedKeyOwnerPubkey: toBuffer(currentAuthorityDerivedKeyOwnerPubkey.toBuffer()),\n                currentAuthorityDerivedKeySeed: currentAuthorityDerivedKeySeed,\n                newAuthorized: toBuffer(newAuthorizedPubkey.toBuffer()),\n                voteAuthorizationType: voteAuthorizationType.index\n            }\n        });\n        const keys = [\n            {\n                pubkey: votePubkey,\n                isSigner: false,\n                isWritable: true\n            },\n            {\n                pubkey: SYSVAR_CLOCK_PUBKEY,\n                isSigner: false,\n                isWritable: false\n            },\n            {\n                pubkey: currentAuthorityDerivedKeyBasePubkey,\n                isSigner: true,\n                isWritable: false\n            }\n        ];\n        return new Transaction().add({\n            keys,\n            programId: this.programId,\n            data\n        });\n    }\n    /**\n   * Generate a transaction to withdraw from a Vote account.\n   */ static withdraw(params) {\n        const { votePubkey, authorizedWithdrawerPubkey, lamports, toPubkey } = params;\n        const type = VOTE_INSTRUCTION_LAYOUTS.Withdraw;\n        const data = encodeData(type, {\n            lamports\n        });\n        const keys = [\n            {\n                pubkey: votePubkey,\n                isSigner: false,\n                isWritable: true\n            },\n            {\n                pubkey: toPubkey,\n                isSigner: false,\n                isWritable: true\n            },\n            {\n                pubkey: authorizedWithdrawerPubkey,\n                isSigner: true,\n                isWritable: false\n            }\n        ];\n        return new Transaction().add({\n            keys,\n            programId: this.programId,\n            data\n        });\n    }\n    /**\n   * Generate a transaction to withdraw safely from a Vote account.\n   *\n   * This function was created as a safeguard for vote accounts running validators, `safeWithdraw`\n   * checks that the withdraw amount will not exceed the specified balance while leaving enough left\n   * to cover rent. If you wish to close the vote account by withdrawing the full amount, call the\n   * `withdraw` method directly.\n   */ static safeWithdraw(params, currentVoteAccountBalance, rentExemptMinimum) {\n        if (params.lamports > currentVoteAccountBalance - rentExemptMinimum) {\n            throw new Error(\"Withdraw will leave vote account with insufficient funds.\");\n        }\n        return VoteProgram.withdraw(params);\n    }\n    /**\n   * Generate a transaction to update the validator identity (node pubkey) of a Vote account.\n   */ static updateValidatorIdentity(params) {\n        const { votePubkey, authorizedWithdrawerPubkey, nodePubkey } = params;\n        const type = VOTE_INSTRUCTION_LAYOUTS.UpdateValidatorIdentity;\n        const data = encodeData(type);\n        const keys = [\n            {\n                pubkey: votePubkey,\n                isSigner: false,\n                isWritable: true\n            },\n            {\n                pubkey: nodePubkey,\n                isSigner: true,\n                isWritable: false\n            },\n            {\n                pubkey: authorizedWithdrawerPubkey,\n                isSigner: true,\n                isWritable: false\n            }\n        ];\n        return new Transaction().add({\n            keys,\n            programId: this.programId,\n            data\n        });\n    }\n}\nVoteProgram.programId = new PublicKey(\"Vote111111111111111111111111111111111111111\");\n/**\n * Max space of a Vote account\n *\n * This is generated from the solana-vote-program VoteState struct as\n * `VoteState::size_of()`:\n * https://docs.rs/solana-vote-program/1.9.5/solana_vote_program/vote_state/struct.VoteState.html#method.size_of\n *\n * KEEP IN SYNC WITH `VoteState::size_of()` in https://github.com/solana-labs/solana/blob/a474cb24b9238f5edcc982f65c0b37d4a1046f7e/sdk/program/src/vote/state/mod.rs#L340-L342\n */ VoteProgram.space = 3762;\nconst VALIDATOR_INFO_KEY = new PublicKey(\"Va1idator1nfo111111111111111111111111111111\");\n/**\n * @internal\n */ /**\n * Info used to identity validators.\n */ const InfoString = (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.type)({\n    name: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.string)(),\n    website: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.optional)((0,superstruct__WEBPACK_IMPORTED_MODULE_15__.string)()),\n    details: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.optional)((0,superstruct__WEBPACK_IMPORTED_MODULE_15__.string)()),\n    keybaseUsername: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.optional)((0,superstruct__WEBPACK_IMPORTED_MODULE_15__.string)())\n});\n/**\n * ValidatorInfo class\n */ class ValidatorInfo {\n    /**\n   * Construct a valid ValidatorInfo\n   *\n   * @param key validator public key\n   * @param info validator information\n   */ constructor(key, info){\n        /**\n     * validator public key\n     */ this.key = void 0;\n        /**\n     * validator information\n     */ this.info = void 0;\n        this.key = key;\n        this.info = info;\n    }\n    /**\n   * Deserialize ValidatorInfo from the config account data. Exactly two config\n   * keys are required in the data.\n   *\n   * @param buffer config account data\n   * @return null if info was not found\n   */ static fromConfigData(buffer) {\n        let byteArray = [\n            ...buffer\n        ];\n        const configKeyCount = decodeLength(byteArray);\n        if (configKeyCount !== 2) return null;\n        const configKeys = [];\n        for(let i = 0; i < 2; i++){\n            const publicKey = new PublicKey(guardedSplice(byteArray, 0, PUBLIC_KEY_LENGTH));\n            const isSigner = guardedShift(byteArray) === 1;\n            configKeys.push({\n                publicKey,\n                isSigner\n            });\n        }\n        if (configKeys[0].publicKey.equals(VALIDATOR_INFO_KEY)) {\n            if (configKeys[1].isSigner) {\n                const rawInfo = rustString().decode(buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.from(byteArray));\n                const info = JSON.parse(rawInfo);\n                (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.assert)(info, InfoString);\n                return new ValidatorInfo(configKeys[1].publicKey, info);\n            }\n        }\n        return null;\n    }\n}\nconst VOTE_PROGRAM_ID = new PublicKey(\"Vote111111111111111111111111111111111111111\");\n/**\n * History of how many credits earned by the end of each epoch\n */ /**\n * See https://github.com/solana-labs/solana/blob/8a12ed029cfa38d4a45400916c2463fb82bbec8c/programs/vote_api/src/vote_state.rs#L68-L88\n *\n * @internal\n */ const VoteAccountLayout = _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.struct([\n    publicKey(\"nodePubkey\"),\n    publicKey(\"authorizedWithdrawer\"),\n    _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u8(\"commission\"),\n    _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.nu64(),\n    // votes.length\n    _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.seq(_solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.struct([\n        _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.nu64(\"slot\"),\n        _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u32(\"confirmationCount\")\n    ]), _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.offset(_solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u32(), -8), \"votes\"),\n    _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u8(\"rootSlotValid\"),\n    _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.nu64(\"rootSlot\"),\n    _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.nu64(),\n    // authorizedVoters.length\n    _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.seq(_solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.struct([\n        _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.nu64(\"epoch\"),\n        publicKey(\"authorizedVoter\")\n    ]), _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.offset(_solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u32(), -8), \"authorizedVoters\"),\n    _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.struct([\n        _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.seq(_solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.struct([\n            publicKey(\"authorizedPubkey\"),\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.nu64(\"epochOfLastAuthorizedSwitch\"),\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.nu64(\"targetEpoch\")\n        ]), 32, \"buf\"),\n        _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.nu64(\"idx\"),\n        _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u8(\"isEmpty\")\n    ], \"priorVoters\"),\n    _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.nu64(),\n    // epochCredits.length\n    _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.seq(_solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.struct([\n        _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.nu64(\"epoch\"),\n        _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.nu64(\"credits\"),\n        _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.nu64(\"prevCredits\")\n    ]), _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.offset(_solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u32(), -8), \"epochCredits\"),\n    _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.struct([\n        _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.nu64(\"slot\"),\n        _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.nu64(\"timestamp\")\n    ], \"lastTimestamp\")\n]);\n/**\n * VoteAccount class\n */ class VoteAccount {\n    /**\n   * @internal\n   */ constructor(args){\n        this.nodePubkey = void 0;\n        this.authorizedWithdrawer = void 0;\n        this.commission = void 0;\n        this.rootSlot = void 0;\n        this.votes = void 0;\n        this.authorizedVoters = void 0;\n        this.priorVoters = void 0;\n        this.epochCredits = void 0;\n        this.lastTimestamp = void 0;\n        this.nodePubkey = args.nodePubkey;\n        this.authorizedWithdrawer = args.authorizedWithdrawer;\n        this.commission = args.commission;\n        this.rootSlot = args.rootSlot;\n        this.votes = args.votes;\n        this.authorizedVoters = args.authorizedVoters;\n        this.priorVoters = args.priorVoters;\n        this.epochCredits = args.epochCredits;\n        this.lastTimestamp = args.lastTimestamp;\n    }\n    /**\n   * Deserialize VoteAccount from the account data.\n   *\n   * @param buffer account data\n   * @return VoteAccount\n   */ static fromAccountData(buffer) {\n        const versionOffset = 4;\n        const va = VoteAccountLayout.decode(toBuffer(buffer), versionOffset);\n        let rootSlot = va.rootSlot;\n        if (!va.rootSlotValid) {\n            rootSlot = null;\n        }\n        return new VoteAccount({\n            nodePubkey: new PublicKey(va.nodePubkey),\n            authorizedWithdrawer: new PublicKey(va.authorizedWithdrawer),\n            commission: va.commission,\n            votes: va.votes,\n            rootSlot,\n            authorizedVoters: va.authorizedVoters.map(parseAuthorizedVoter),\n            priorVoters: getPriorVoters(va.priorVoters),\n            epochCredits: va.epochCredits,\n            lastTimestamp: va.lastTimestamp\n        });\n    }\n}\nfunction parseAuthorizedVoter({ authorizedVoter, epoch }) {\n    return {\n        epoch,\n        authorizedVoter: new PublicKey(authorizedVoter)\n    };\n}\nfunction parsePriorVoters({ authorizedPubkey, epochOfLastAuthorizedSwitch, targetEpoch }) {\n    return {\n        authorizedPubkey: new PublicKey(authorizedPubkey),\n        epochOfLastAuthorizedSwitch,\n        targetEpoch\n    };\n}\nfunction getPriorVoters({ buf, idx, isEmpty }) {\n    if (isEmpty) {\n        return [];\n    }\n    return [\n        ...buf.slice(idx + 1).map(parsePriorVoters),\n        ...buf.slice(0, idx).map(parsePriorVoters)\n    ];\n}\nconst endpoint = {\n    http: {\n        devnet: \"http://api.devnet.solana.com\",\n        testnet: \"http://api.testnet.solana.com\",\n        \"mainnet-beta\": \"http://api.mainnet-beta.solana.com/\"\n    },\n    https: {\n        devnet: \"https://api.devnet.solana.com\",\n        testnet: \"https://api.testnet.solana.com\",\n        \"mainnet-beta\": \"https://api.mainnet-beta.solana.com/\"\n    }\n};\n/**\n * Retrieves the RPC API URL for the specified cluster\n * @param {Cluster} [cluster=\"devnet\"] - The cluster name of the RPC API URL to use. Possible options: 'devnet' | 'testnet' | 'mainnet-beta'\n * @param {boolean} [tls=\"http\"] - Use TLS when connecting to cluster.\n *\n * @returns {string} URL string of the RPC endpoint\n */ function clusterApiUrl(cluster, tls) {\n    const key = tls === false ? \"http\" : \"https\";\n    if (!cluster) {\n        return endpoint[key][\"devnet\"];\n    }\n    const url = endpoint[key][cluster];\n    if (!url) {\n        throw new Error(`Unknown ${key} cluster: ${cluster}`);\n    }\n    return url;\n}\n/**\n * Send and confirm a raw transaction\n *\n * If `commitment` option is not specified, defaults to 'max' commitment.\n *\n * @param {Connection} connection\n * @param {Buffer} rawTransaction\n * @param {TransactionConfirmationStrategy} confirmationStrategy\n * @param {ConfirmOptions} [options]\n * @returns {Promise<TransactionSignature>}\n */ /**\n * @deprecated Calling `sendAndConfirmRawTransaction()` without a `confirmationStrategy`\n * is no longer supported and will be removed in a future version.\n */ // eslint-disable-next-line no-redeclare\n// eslint-disable-next-line no-redeclare\nasync function sendAndConfirmRawTransaction(connection, rawTransaction, confirmationStrategyOrConfirmOptions, maybeConfirmOptions) {\n    let confirmationStrategy;\n    let options;\n    if (confirmationStrategyOrConfirmOptions && Object.prototype.hasOwnProperty.call(confirmationStrategyOrConfirmOptions, \"lastValidBlockHeight\")) {\n        confirmationStrategy = confirmationStrategyOrConfirmOptions;\n        options = maybeConfirmOptions;\n    } else if (confirmationStrategyOrConfirmOptions && Object.prototype.hasOwnProperty.call(confirmationStrategyOrConfirmOptions, \"nonceValue\")) {\n        confirmationStrategy = confirmationStrategyOrConfirmOptions;\n        options = maybeConfirmOptions;\n    } else {\n        options = confirmationStrategyOrConfirmOptions;\n    }\n    const sendOptions = options && {\n        skipPreflight: options.skipPreflight,\n        preflightCommitment: options.preflightCommitment || options.commitment,\n        minContextSlot: options.minContextSlot\n    };\n    const signature = await connection.sendRawTransaction(rawTransaction, sendOptions);\n    const commitment = options && options.commitment;\n    const confirmationPromise = confirmationStrategy ? connection.confirmTransaction(confirmationStrategy, commitment) : connection.confirmTransaction(signature, commitment);\n    const status = (await confirmationPromise).value;\n    if (status.err) {\n        throw new Error(`Raw transaction ${signature} failed (${JSON.stringify(status)})`);\n    }\n    return signature;\n}\n/**\n * There are 1-billion lamports in one SOL\n */ const LAMPORTS_PER_SOL = 1000000000;\n //# sourceMappingURL=index.esm.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vYW5jaG9yL25vZGVfbW9kdWxlcy9Ac29sYW5hL3dlYjMuanMvbGliL2luZGV4LmVzbS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQWdDO0FBQ2dCO0FBQ3pCO0FBQ0M7QUFDc0I7QUFDdUI7QUFDZjtBQUNUO0FBQ1U7QUFDekI7QUFDRTtBQUN1QjtBQUMySDtBQUNoSTtBQUNWO0FBQ2tDO0FBQ0U7QUFDNUI7QUFDSTtBQUVwRDs7OztDQUlDLEdBRUQ7O0NBRUMsR0FFRCxNQUFNeUMscUJBQXFCeEMsMkRBQU9BLENBQUN5QyxLQUFLLENBQUNDLGdCQUFnQjtBQUN6RCxNQUFNQyxrQkFBa0I7SUFDdEIsTUFBTUMsZ0JBQWdCNUMsMkRBQU9BLENBQUN5QyxLQUFLLENBQUNDLGdCQUFnQjtJQUNwRCxNQUFNRyxZQUFZQyxhQUFhRjtJQUMvQixNQUFNRyxZQUFZLElBQUlDLFdBQVc7SUFDakNELFVBQVVFLEdBQUcsQ0FBQ0w7SUFDZEcsVUFBVUUsR0FBRyxDQUFDSixXQUFXO0lBQ3pCLE9BQU87UUFDTEE7UUFDQUU7SUFDRjtBQUNGO0FBQ0EsTUFBTUQsZUFBZTlDLDJEQUFPQSxDQUFDOEMsWUFBWTtBQUN6QyxTQUFTSSxVQUFVTCxTQUFTO0lBQzFCLElBQUk7UUFDRjdDLDJEQUFPQSxDQUFDbUQsYUFBYSxDQUFDQyxPQUFPLENBQUNQO1FBQzlCLE9BQU87SUFDVCxFQUFFLE9BQU07UUFDTixPQUFPO0lBQ1Q7QUFDRjtBQUNBLE1BQU1RLE9BQU8sQ0FBQ0MsU0FBU1AsWUFBYy9DLDJEQUFPQSxDQUFDcUQsSUFBSSxDQUFDQyxTQUFTUCxVQUFVUSxLQUFLLENBQUMsR0FBRztBQUM5RSxNQUFNQyxTQUFTeEQsMkRBQU9BLENBQUN3RCxNQUFNO0FBRTdCLE1BQU1DLFdBQVdDLENB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QVEsQ0FBQyxDQUFDO0lBQ25GO0lBQ0EsT0FBT2xVO0FBQ1Q7QUFFQTs7Q0FFQyxHQUNELE1BQU0yMEMsbUJBQW1CO0FBRTZnRCxDQUN0aUQscUNBQXFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4uL2FuY2hvci9ub2RlX21vZHVsZXMvQHNvbGFuYS93ZWIzLmpzL2xpYi9pbmRleC5lc20uanM/YTUxZiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBCdWZmZXIgfSBmcm9tICdidWZmZXInO1xuaW1wb3J0IHsgZWQyNTUxOSB9IGZyb20gJ0Bub2JsZS9jdXJ2ZXMvZWQyNTUxOSc7XG5pbXBvcnQgQk4gZnJvbSAnYm4uanMnO1xuaW1wb3J0IGJzNTggZnJvbSAnYnM1OCc7XG5pbXBvcnQgeyBzaGEyNTYgfSBmcm9tICdAbm9ibGUvaGFzaGVzL3NoYTI1Nic7XG5pbXBvcnQgeyBzZXJpYWxpemUsIGRlc2VyaWFsaXplLCBkZXNlcmlhbGl6ZVVuY2hlY2tlZCB9IGZyb20gJ2JvcnNoJztcbmltcG9ydCAqIGFzIEJ1ZmZlckxheW91dCBmcm9tICdAc29sYW5hL2J1ZmZlci1sYXlvdXQnO1xuaW1wb3J0IHsgYmxvYiB9IGZyb20gJ0Bzb2xhbmEvYnVmZmVyLWxheW91dCc7XG5pbXBvcnQgeyB0b0JpZ0ludExFLCB0b0J1ZmZlckxFIH0gZnJvbSAnYmlnaW50LWJ1ZmZlcic7XG5pbXBvcnQgcmVxdWlyZSQkMCBmcm9tICd1dGlsJztcbmltcG9ydCByZXF1aXJlJCQwJDEgZnJvbSAnaHR0cCc7XG5pbXBvcnQgcmVxdWlyZSQkMCQyLCB7IEFnZW50IGFzIEFnZW50JDEgfSBmcm9tICdodHRwcyc7XG5pbXBvcnQgeyBjb2VyY2UsIGluc3RhbmNlLCBzdHJpbmcsIHR1cGxlLCBsaXRlcmFsLCB1bmtub3duLCB0eXBlLCBudW1iZXIsIGFycmF5LCBudWxsYWJsZSwgb3B0aW9uYWwsIGJvb2xlYW4sIHJlY29yZCwgdW5pb24sIGNyZWF0ZSwgYW55LCBhc3NlcnQgYXMgYXNzZXJ0JDEgfSBmcm9tICdzdXBlcnN0cnVjdCc7XG5pbXBvcnQgUnBjQ2xpZW50IGZyb20gJ2pheXNvbi9saWIvY2xpZW50L2Jyb3dzZXInO1xuaW1wb3J0ICogYXMgbm9kZUZldGNoIGZyb20gJ25vZGUtZmV0Y2gnO1xuaW1wb3J0IFJwY1dlYlNvY2tldENvbW1vbkNsaWVudCBmcm9tICdycGMtd2Vic29ja2V0cy9kaXN0L2xpYi9jbGllbnQuY2pzJztcbmltcG9ydCBXZWJzb2NrZXRGYWN0b3J5IGZyb20gJ3JwYy13ZWJzb2NrZXRzL2Rpc3QvbGliL2NsaWVudC93ZWJzb2NrZXQuY2pzJztcbmltcG9ydCB7IGtlY2Nha18yNTYgfSBmcm9tICdAbm9ibGUvaGFzaGVzL3NoYTMnO1xuaW1wb3J0IHsgc2VjcDI1NmsxIH0gZnJvbSAnQG5vYmxlL2N1cnZlcy9zZWNwMjU2azEnO1xuXG4vKipcbiAqIEEgNjQgYnl0ZSBzZWNyZXQga2V5LCB0aGUgZmlyc3QgMzIgYnl0ZXMgb2Ygd2hpY2ggaXMgdGhlXG4gKiBwcml2YXRlIHNjYWxhciBhbmQgdGhlIGxhc3QgMzIgYnl0ZXMgaXMgdGhlIHB1YmxpYyBrZXkuXG4gKiBSZWFkIG1vcmU6IGh0dHBzOi8vYmxvZy5tb3ppbGxhLm9yZy93YXJuZXIvMjAxMS8xMS8yOS9lZDI1NTE5LWtleXMvXG4gKi9cblxuLyoqXG4gKiBFZDI1NTE5IEtleXBhaXJcbiAqL1xuXG5jb25zdCBnZW5lcmF0ZVByaXZhdGVLZXkgPSBlZDI1NTE5LnV0aWxzLnJhbmRvbVByaXZhdGVLZXk7XG5jb25zdCBnZW5lcmF0ZUtleXBhaXIgPSAoKSA9PiB7XG4gIGNvbnN0IHByaXZhdGVTY2FsYXIgPSBlZDI1NTE5LnV0aWxzLnJhbmRvbVByaXZhdGVLZXkoKTtcbiAgY29uc3QgcHVibGljS2V5ID0gZ2V0UHVibGljS2V5KHByaXZhdGVTY2FsYXIpO1xuICBjb25zdCBzZWNyZXRLZXkgPSBuZXcgVWludDhBcnJheSg2NCk7XG4gIHNlY3JldEtleS5zZXQocHJpdmF0ZVNjYWxhcik7XG4gIHNlY3JldEtleS5zZXQocHVibGljS2V5LCAzMik7XG4gIHJldHVybiB7XG4gICAgcHVibGljS2V5LFxuICAgIHNlY3JldEtleVxuICB9O1xufTtcbmNvbnN0IGdldFB1YmxpY0tleSA9IGVkMjU1MTkuZ2V0UHVibGljS2V5O1xuZnVuY3Rpb24gaXNPbkN1cnZlKHB1YmxpY0tleSkge1xuICB0cnkge1xuICAgIGVkMjU1MTkuRXh0ZW5kZWRQb2ludC5mcm9tSGV4KHB1YmxpY0tleSk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0gY2F0Y2gge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufVxuY29uc3Qgc2lnbiA9IChtZXNzYWdlLCBzZWNyZXRLZXkpID0+IGVkMjU1MTkuc2lnbihtZXNzYWdlLCBzZWNyZXRLZXkuc2xpY2UoMCwgMzIpKTtcbmNvbnN0IHZlcmlmeSA9IGVkMjU1MTkudmVyaWZ5O1xuXG5jb25zdCB0b0J1ZmZlciA9IGFyciA9PiB7XG4gIGlmIChCdWZmZXIuaXNCdWZmZXIoYXJyKSkge1xuICAgIHJldHVybiBhcnI7XG4gIH0gZWxzZSBpZiAoYXJyIGluc3RhbmNlb2YgVWludDhBcnJheSkge1xuICAgIHJldHVybiBCdWZmZXIuZnJvbShhcnIuYnVmZmVyLCBhcnIuYnl0ZU9mZnNldCwgYXJyLmJ5dGVMZW5ndGgpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBCdWZmZXIuZnJvbShhcnIpO1xuICB9XG59O1xuXG4vLyBDbGFzcyB3cmFwcGluZyBhIHBsYWluIG9iamVjdFxuY2xhc3MgU3RydWN0IHtcbiAgY29uc3RydWN0b3IocHJvcGVydGllcykge1xuICAgIE9iamVjdC5hc3NpZ24odGhpcywgcHJvcGVydGllcyk7XG4gIH1cbiAgZW5jb2RlKCkge1xuICAgIHJldHVybiBCdWZmZXIuZnJvbShzZXJpYWxpemUoU09MQU5BX1NDSEVNQSwgdGhpcykpO1xuICB9XG4gIHN0YXRpYyBkZWNvZGUoZGF0YSkge1xuICAgIHJldHVybiBkZXNlcmlhbGl6ZShTT0xBTkFfU0NIRU1BLCB0aGlzLCBkYXRhKTtcbiAgfVxuICBzdGF0aWMgZGVjb2RlVW5jaGVja2VkKGRhdGEpIHtcbiAgICByZXR1cm4gZGVzZXJpYWxpemVVbmNoZWNrZWQoU09MQU5BX1NDSEVNQSwgdGhpcywgZGF0YSk7XG4gIH1cbn1cblxuLy8gQ2xhc3MgcmVwcmVzZW50aW5nIGEgUnVzdC1jb21wYXRpYmxlIGVudW0sIHNpbmNlIGVudW1zIGFyZSBvbmx5IHN0cmluZ3Mgb3Jcbi8vIG51bWJlcnMgaW4gcHVyZSBKU1xuY2xhc3MgRW51bSBleHRlbmRzIFN0cnVjdCB7XG4gIGNvbnN0cnVjdG9yKHByb3BlcnRpZXMpIHtcbiAgICBzdXBlcihwcm9wZXJ0aWVzKTtcbiAgICB0aGlzLmVudW0gPSAnJztcbiAgICBpZiAoT2JqZWN0LmtleXMocHJvcGVydGllcykubGVuZ3RoICE9PSAxKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0VudW0gY2FuIG9ubHkgdGFrZSBzaW5nbGUgdmFsdWUnKTtcbiAgICB9XG4gICAgT2JqZWN0LmtleXMocHJvcGVydGllcykubWFwKGtleSA9PiB7XG4gICAgICB0aGlzLmVudW0gPSBrZXk7XG4gICAgfSk7XG4gIH1cbn1cbmNvbnN0IFNPTEFOQV9TQ0hFTUEgPSBuZXcgTWFwKCk7XG5cbnZhciBfUHVibGljS2V5O1xuXG4vKipcbiAqIE1heGltdW0gbGVuZ3RoIG9mIGRlcml2ZWQgcHVia2V5IHNlZWRcbiAqL1xuY29uc3QgTUFYX1NFRURfTEVOR1RIID0gMzI7XG5cbi8qKlxuICogU2l6ZSBvZiBwdWJsaWMga2V5IGluIGJ5dGVzXG4gKi9cbmNvbnN0IFBVQkxJQ19LRVlfTEVOR1RIID0gMzI7XG5cbi8qKlxuICogVmFsdWUgdG8gYmUgY29udmVydGVkIGludG8gcHVibGljIGtleVxuICovXG5cbi8qKlxuICogSlNPTiBvYmplY3QgcmVwcmVzZW50YXRpb24gb2YgUHVibGljS2V5IGNsYXNzXG4gKi9cblxuZnVuY3Rpb24gaXNQdWJsaWNLZXlEYXRhKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZS5fYm4gIT09IHVuZGVmaW5lZDtcbn1cblxuLy8gbG9jYWwgY291bnRlciB1c2VkIGJ5IFB1YmxpY0tleS51bmlxdWUoKVxubGV0IHVuaXF1ZVB1YmxpY0tleUNvdW50ZXIgPSAxO1xuXG4vKipcbiAqIEEgcHVibGljIGtleVxuICovXG5jbGFzcyBQdWJsaWNLZXkgZXh0ZW5kcyBTdHJ1Y3Qge1xuICAvKipcbiAgICogQ3JlYXRlIGEgbmV3IFB1YmxpY0tleSBvYmplY3RcbiAgICogQHBhcmFtIHZhbHVlIGVkMjU1MTkgcHVibGljIGtleSBhcyBidWZmZXIgb3IgYmFzZS01OCBlbmNvZGVkIHN0cmluZ1xuICAgKi9cbiAgY29uc3RydWN0b3IodmFsdWUpIHtcbiAgICBzdXBlcih7fSk7XG4gICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgIHRoaXMuX2JuID0gdm9pZCAwO1xuICAgIGlmIChpc1B1YmxpY0tleURhdGEodmFsdWUpKSB7XG4gICAgICB0aGlzLl9ibiA9IHZhbHVlLl9ibjtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgLy8gYXNzdW1lIGJhc2UgNTggZW5jb2RpbmcgYnkgZGVmYXVsdFxuICAgICAgICBjb25zdCBkZWNvZGVkID0gYnM1OC5kZWNvZGUodmFsdWUpO1xuICAgICAgICBpZiAoZGVjb2RlZC5sZW5ndGggIT0gUFVCTElDX0tFWV9MRU5HVEgpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgcHVibGljIGtleSBpbnB1dGApO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2JuID0gbmV3IEJOKGRlY29kZWQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5fYm4gPSBuZXcgQk4odmFsdWUpO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMuX2JuLmJ5dGVMZW5ndGgoKSA+IFBVQkxJQ19LRVlfTEVOR1RIKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBwdWJsaWMga2V5IGlucHV0YCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYSB1bmlxdWUgUHVibGljS2V5IGZvciB0ZXN0cyBhbmQgYmVuY2htYXJrcyB1c2luZyBhIGNvdW50ZXJcbiAgICovXG4gIHN0YXRpYyB1bmlxdWUoKSB7XG4gICAgY29uc3Qga2V5ID0gbmV3IFB1YmxpY0tleSh1bmlxdWVQdWJsaWNLZXlDb3VudGVyKTtcbiAgICB1bmlxdWVQdWJsaWNLZXlDb3VudGVyICs9IDE7XG4gICAgcmV0dXJuIG5ldyBQdWJsaWNLZXkoa2V5LnRvQnVmZmVyKCkpO1xuICB9XG5cbiAgLyoqXG4gICAqIERlZmF1bHQgcHVibGljIGtleSB2YWx1ZS4gVGhlIGJhc2U1OC1lbmNvZGVkIHN0cmluZyByZXByZXNlbnRhdGlvbiBpcyBhbGwgb25lcyAoYXMgc2VlbiBiZWxvdylcbiAgICogVGhlIHVuZGVybHlpbmcgQk4gbnVtYmVyIGlzIDMyIGJ5dGVzIHRoYXQgYXJlIGFsbCB6ZXJvc1xuICAgKi9cblxuICAvKipcbiAgICogQ2hlY2tzIGlmIHR3byBwdWJsaWNLZXlzIGFyZSBlcXVhbFxuICAgKi9cbiAgZXF1YWxzKHB1YmxpY0tleSkge1xuICAgIHJldHVybiB0aGlzLl9ibi5lcShwdWJsaWNLZXkuX2JuKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gdGhlIGJhc2UtNTggcmVwcmVzZW50YXRpb24gb2YgdGhlIHB1YmxpYyBrZXlcbiAgICovXG4gIHRvQmFzZTU4KCkge1xuICAgIHJldHVybiBiczU4LmVuY29kZSh0aGlzLnRvQnl0ZXMoKSk7XG4gIH1cbiAgdG9KU09OKCkge1xuICAgIHJldHVybiB0aGlzLnRvQmFzZTU4KCk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJuIHRoZSBieXRlIGFycmF5IHJlcHJlc2VudGF0aW9uIG9mIHRoZSBwdWJsaWMga2V5IGluIGJpZyBlbmRpYW5cbiAgICovXG4gIHRvQnl0ZXMoKSB7XG4gICAgY29uc3QgYnVmID0gdGhpcy50b0J1ZmZlcigpO1xuICAgIHJldHVybiBuZXcgVWludDhBcnJheShidWYuYnVmZmVyLCBidWYuYnl0ZU9mZnNldCwgYnVmLmJ5dGVMZW5ndGgpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiB0aGUgQnVmZmVyIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBwdWJsaWMga2V5IGluIGJpZyBlbmRpYW5cbiAgICovXG4gIHRvQnVmZmVyKCkge1xuICAgIGNvbnN0IGIgPSB0aGlzLl9ibi50b0FycmF5TGlrZShCdWZmZXIpO1xuICAgIGlmIChiLmxlbmd0aCA9PT0gUFVCTElDX0tFWV9MRU5HVEgpIHtcbiAgICAgIHJldHVybiBiO1xuICAgIH1cbiAgICBjb25zdCB6ZXJvUGFkID0gQnVmZmVyLmFsbG9jKDMyKTtcbiAgICBiLmNvcHkoemVyb1BhZCwgMzIgLSBiLmxlbmd0aCk7XG4gICAgcmV0dXJuIHplcm9QYWQ7XG4gIH1cbiAgZ2V0IFtTeW1ib2wudG9TdHJpbmdUYWddKCkge1xuICAgIHJldHVybiBgUHVibGljS2V5KCR7dGhpcy50b1N0cmluZygpfSlgO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiB0aGUgYmFzZS01OCByZXByZXNlbnRhdGlvbiBvZiB0aGUgcHVibGljIGtleVxuICAgKi9cbiAgdG9TdHJpbmcoKSB7XG4gICAgcmV0dXJuIHRoaXMudG9CYXNlNTgoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZXJpdmUgYSBwdWJsaWMga2V5IGZyb20gYW5vdGhlciBrZXksIGEgc2VlZCwgYW5kIGEgcHJvZ3JhbSBJRC5cbiAgICogVGhlIHByb2dyYW0gSUQgd2lsbCBhbHNvIHNlcnZlIGFzIHRoZSBvd25lciBvZiB0aGUgcHVibGljIGtleSwgZ2l2aW5nXG4gICAqIGl0IHBlcm1pc3Npb24gdG8gd3JpdGUgZGF0YSB0byB0aGUgYWNjb3VudC5cbiAgICovXG4gIC8qIGVzbGludC1kaXNhYmxlIHJlcXVpcmUtYXdhaXQgKi9cbiAgc3RhdGljIGFzeW5jIGNyZWF0ZVdpdGhTZWVkKGZyb21QdWJsaWNLZXksIHNlZWQsIHByb2dyYW1JZCkge1xuICAgIGNvbnN0IGJ1ZmZlciA9IEJ1ZmZlci5jb25jYXQoW2Zyb21QdWJsaWNLZXkudG9CdWZmZXIoKSwgQnVmZmVyLmZyb20oc2VlZCksIHByb2dyYW1JZC50b0J1ZmZlcigpXSk7XG4gICAgY29uc3QgcHVibGljS2V5Qnl0ZXMgPSBzaGEyNTYoYnVmZmVyKTtcbiAgICByZXR1cm4gbmV3IFB1YmxpY0tleShwdWJsaWNLZXlCeXRlcyk7XG4gIH1cblxuICAvKipcbiAgICogRGVyaXZlIGEgcHJvZ3JhbSBhZGRyZXNzIGZyb20gc2VlZHMgYW5kIGEgcHJvZ3JhbSBJRC5cbiAgICovXG4gIC8qIGVzbGludC1kaXNhYmxlIHJlcXVpcmUtYXdhaXQgKi9cbiAgc3RhdGljIGNyZWF0ZVByb2dyYW1BZGRyZXNzU3luYyhzZWVkcywgcHJvZ3JhbUlkKSB7XG4gICAgbGV0IGJ1ZmZlciA9IEJ1ZmZlci5hbGxvYygwKTtcbiAgICBzZWVkcy5mb3JFYWNoKGZ1bmN0aW9uIChzZWVkKSB7XG4gICAgICBpZiAoc2VlZC5sZW5ndGggPiBNQVhfU0VFRF9MRU5HVEgpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgTWF4IHNlZWQgbGVuZ3RoIGV4Y2VlZGVkYCk7XG4gICAgICB9XG4gICAgICBidWZmZXIgPSBCdWZmZXIuY29uY2F0KFtidWZmZXIsIHRvQnVmZmVyKHNlZWQpXSk7XG4gICAgfSk7XG4gICAgYnVmZmVyID0gQnVmZmVyLmNvbmNhdChbYnVmZmVyLCBwcm9ncmFtSWQudG9CdWZmZXIoKSwgQnVmZmVyLmZyb20oJ1Byb2dyYW1EZXJpdmVkQWRkcmVzcycpXSk7XG4gICAgY29uc3QgcHVibGljS2V5Qnl0ZXMgPSBzaGEyNTYoYnVmZmVyKTtcbiAgICBpZiAoaXNPbkN1cnZlKHB1YmxpY0tleUJ5dGVzKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIHNlZWRzLCBhZGRyZXNzIG11c3QgZmFsbCBvZmYgdGhlIGN1cnZlYCk7XG4gICAgfVxuICAgIHJldHVybiBuZXcgUHVibGljS2V5KHB1YmxpY0tleUJ5dGVzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBc3luYyB2ZXJzaW9uIG9mIGNyZWF0ZVByb2dyYW1BZGRyZXNzU3luY1xuICAgKiBGb3IgYmFja3dhcmRzIGNvbXBhdGliaWxpdHlcbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgVXNlIHtAbGluayBjcmVhdGVQcm9ncmFtQWRkcmVzc1N5bmN9IGluc3RlYWRcbiAgICovXG4gIC8qIGVzbGludC1kaXNhYmxlIHJlcXVpcmUtYXdhaXQgKi9cbiAgc3RhdGljIGFzeW5jIGNyZWF0ZVByb2dyYW1BZGRyZXNzKHNlZWRzLCBwcm9ncmFtSWQpIHtcbiAgICByZXR1cm4gdGhpcy5jcmVhdGVQcm9ncmFtQWRkcmVzc1N5bmMoc2VlZHMsIHByb2dyYW1JZCk7XG4gIH1cblxuICAvKipcbiAgICogRmluZCBhIHZhbGlkIHByb2dyYW0gYWRkcmVzc1xuICAgKlxuICAgKiBWYWxpZCBwcm9ncmFtIGFkZHJlc3NlcyBtdXN0IGZhbGwgb2ZmIHRoZSBlZDI1NTE5IGN1cnZlLiAgVGhpcyBmdW5jdGlvblxuICAgKiBpdGVyYXRlcyBhIG5vbmNlIHVudGlsIGl0IGZpbmRzIG9uZSB0aGF0IHdoZW4gY29tYmluZWQgd2l0aCB0aGUgc2VlZHNcbiAgICogcmVzdWx0cyBpbiBhIHZhbGlkIHByb2dyYW0gYWRkcmVzcy5cbiAgICovXG4gIHN0YXRpYyBmaW5kUHJvZ3JhbUFkZHJlc3NTeW5jKHNlZWRzLCBwcm9ncmFtSWQpIHtcbiAgICBsZXQgbm9uY2UgPSAyNTU7XG4gICAgbGV0IGFkZHJlc3M7XG4gICAgd2hpbGUgKG5vbmNlICE9IDApIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IHNlZWRzV2l0aE5vbmNlID0gc2VlZHMuY29uY2F0KEJ1ZmZlci5mcm9tKFtub25jZV0pKTtcbiAgICAgICAgYWRkcmVzcyA9IHRoaXMuY3JlYXRlUHJvZ3JhbUFkZHJlc3NTeW5jKHNlZWRzV2l0aE5vbmNlLCBwcm9ncmFtSWQpO1xuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIGlmIChlcnIgaW5zdGFuY2VvZiBUeXBlRXJyb3IpIHtcbiAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgIH1cbiAgICAgICAgbm9uY2UtLTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICByZXR1cm4gW2FkZHJlc3MsIG5vbmNlXTtcbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKGBVbmFibGUgdG8gZmluZCBhIHZpYWJsZSBwcm9ncmFtIGFkZHJlc3Mgbm9uY2VgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBc3luYyB2ZXJzaW9uIG9mIGZpbmRQcm9ncmFtQWRkcmVzc1N5bmNcbiAgICogRm9yIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5XG4gICAqXG4gICAqIEBkZXByZWNhdGVkIFVzZSB7QGxpbmsgZmluZFByb2dyYW1BZGRyZXNzU3luY30gaW5zdGVhZFxuICAgKi9cbiAgc3RhdGljIGFzeW5jIGZpbmRQcm9ncmFtQWRkcmVzcyhzZWVkcywgcHJvZ3JhbUlkKSB7XG4gICAgcmV0dXJuIHRoaXMuZmluZFByb2dyYW1BZGRyZXNzU3luYyhzZWVkcywgcHJvZ3JhbUlkKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDaGVjayB0aGF0IGEgcHVia2V5IGlzIG9uIHRoZSBlZDI1NTE5IGN1cnZlLlxuICAgKi9cbiAgc3RhdGljIGlzT25DdXJ2ZShwdWJrZXlEYXRhKSB7XG4gICAgY29uc3QgcHVia2V5ID0gbmV3IFB1YmxpY0tleShwdWJrZXlEYXRhKTtcbiAgICByZXR1cm4gaXNPbkN1cnZlKHB1YmtleS50b0J5dGVzKCkpO1xuICB9XG59XG5fUHVibGljS2V5ID0gUHVibGljS2V5O1xuUHVibGljS2V5LmRlZmF1bHQgPSBuZXcgX1B1YmxpY0tleSgnMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTEnKTtcblNPTEFOQV9TQ0hFTUEuc2V0KFB1YmxpY0tleSwge1xuICBraW5kOiAnc3RydWN0JyxcbiAgZmllbGRzOiBbWydfYm4nLCAndTI1NiddXVxufSk7XG5cbi8qKlxuICogQW4gYWNjb3VudCBrZXkgcGFpciAocHVibGljIGFuZCBzZWNyZXQga2V5cykuXG4gKlxuICogQGRlcHJlY2F0ZWQgc2luY2UgdjEuMTAuMCwgcGxlYXNlIHVzZSB7QGxpbmsgS2V5cGFpcn0gaW5zdGVhZC5cbiAqL1xuY2xhc3MgQWNjb3VudCB7XG4gIC8qKlxuICAgKiBDcmVhdGUgYSBuZXcgQWNjb3VudCBvYmplY3RcbiAgICpcbiAgICogSWYgdGhlIHNlY3JldEtleSBwYXJhbWV0ZXIgaXMgbm90IHByb3ZpZGVkIGEgbmV3IGtleSBwYWlyIGlzIHJhbmRvbWx5XG4gICAqIGNyZWF0ZWQgZm9yIHRoZSBhY2NvdW50XG4gICAqXG4gICAqIEBwYXJhbSBzZWNyZXRLZXkgU2VjcmV0IGtleSBmb3IgdGhlIGFjY291bnRcbiAgICovXG4gIGNvbnN0cnVjdG9yKHNlY3JldEtleSkge1xuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICB0aGlzLl9wdWJsaWNLZXkgPSB2b2lkIDA7XG4gICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgIHRoaXMuX3NlY3JldEtleSA9IHZvaWQgMDtcbiAgICBpZiAoc2VjcmV0S2V5KSB7XG4gICAgICBjb25zdCBzZWNyZXRLZXlCdWZmZXIgPSB0b0J1ZmZlcihzZWNyZXRLZXkpO1xuICAgICAgaWYgKHNlY3JldEtleS5sZW5ndGggIT09IDY0KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignYmFkIHNlY3JldCBrZXkgc2l6ZScpO1xuICAgICAgfVxuICAgICAgdGhpcy5fcHVibGljS2V5ID0gc2VjcmV0S2V5QnVmZmVyLnNsaWNlKDMyLCA2NCk7XG4gICAgICB0aGlzLl9zZWNyZXRLZXkgPSBzZWNyZXRLZXlCdWZmZXIuc2xpY2UoMCwgMzIpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9zZWNyZXRLZXkgPSB0b0J1ZmZlcihnZW5lcmF0ZVByaXZhdGVLZXkoKSk7XG4gICAgICB0aGlzLl9wdWJsaWNLZXkgPSB0b0J1ZmZlcihnZXRQdWJsaWNLZXkodGhpcy5fc2VjcmV0S2V5KSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFRoZSBwdWJsaWMga2V5IGZvciB0aGlzIGFjY291bnRcbiAgICovXG4gIGdldCBwdWJsaWNLZXkoKSB7XG4gICAgcmV0dXJuIG5ldyBQdWJsaWNLZXkodGhpcy5fcHVibGljS2V5KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGUgKip1bmVuY3J5cHRlZCoqIHNlY3JldCBrZXkgZm9yIHRoaXMgYWNjb3VudC4gVGhlIGZpcnN0IDMyIGJ5dGVzXG4gICAqIGlzIHRoZSBwcml2YXRlIHNjYWxhciBhbmQgdGhlIGxhc3QgMzIgYnl0ZXMgaXMgdGhlIHB1YmxpYyBrZXkuXG4gICAqIFJlYWQgbW9yZTogaHR0cHM6Ly9ibG9nLm1vemlsbGEub3JnL3dhcm5lci8yMDExLzExLzI5L2VkMjU1MTkta2V5cy9cbiAgICovXG4gIGdldCBzZWNyZXRLZXkoKSB7XG4gICAgcmV0dXJuIEJ1ZmZlci5jb25jYXQoW3RoaXMuX3NlY3JldEtleSwgdGhpcy5fcHVibGljS2V5XSwgNjQpO1xuICB9XG59XG5cbmNvbnN0IEJQRl9MT0FERVJfREVQUkVDQVRFRF9QUk9HUkFNX0lEID0gbmV3IFB1YmxpY0tleSgnQlBGTG9hZGVyMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMScpO1xuXG4vKipcbiAqIE1heGltdW0gb3Zlci10aGUtd2lyZSBzaXplIG9mIGEgVHJhbnNhY3Rpb25cbiAqXG4gKiAxMjgwIGlzIElQdjYgbWluaW11bSBNVFVcbiAqIDQwIGJ5dGVzIGlzIHRoZSBzaXplIG9mIHRoZSBJUHY2IGhlYWRlclxuICogOCBieXRlcyBpcyB0aGUgc2l6ZSBvZiB0aGUgZnJhZ21lbnQgaGVhZGVyXG4gKi9cbmNvbnN0IFBBQ0tFVF9EQVRBX1NJWkUgPSAxMjgwIC0gNDAgLSA4O1xuY29uc3QgVkVSU0lPTl9QUkVGSVhfTUFTSyA9IDB4N2Y7XG5jb25zdCBTSUdOQVRVUkVfTEVOR1RIX0lOX0JZVEVTID0gNjQ7XG5cbmNsYXNzIFRyYW5zYWN0aW9uRXhwaXJlZEJsb2NraGVpZ2h0RXhjZWVkZWRFcnJvciBleHRlbmRzIEVycm9yIHtcbiAgY29uc3RydWN0b3Ioc2lnbmF0dXJlKSB7XG4gICAgc3VwZXIoYFNpZ25hdHVyZSAke3NpZ25hdHVyZX0gaGFzIGV4cGlyZWQ6IGJsb2NrIGhlaWdodCBleGNlZWRlZC5gKTtcbiAgICB0aGlzLnNpZ25hdHVyZSA9IHZvaWQgMDtcbiAgICB0aGlzLnNpZ25hdHVyZSA9IHNpZ25hdHVyZTtcbiAgfVxufVxuT2JqZWN0LmRlZmluZVByb3BlcnR5KFRyYW5zYWN0aW9uRXhwaXJlZEJsb2NraGVpZ2h0RXhjZWVkZWRFcnJvci5wcm90b3R5cGUsICduYW1lJywge1xuICB2YWx1ZTogJ1RyYW5zYWN0aW9uRXhwaXJlZEJsb2NraGVpZ2h0RXhjZWVkZWRFcnJvcidcbn0pO1xuY2xhc3MgVHJhbnNhY3Rpb25FeHBpcmVkVGltZW91dEVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICBjb25zdHJ1Y3RvcihzaWduYXR1cmUsIHRpbWVvdXRTZWNvbmRzKSB7XG4gICAgc3VwZXIoYFRyYW5zYWN0aW9uIHdhcyBub3QgY29uZmlybWVkIGluICR7dGltZW91dFNlY29uZHMudG9GaXhlZCgyKX0gc2Vjb25kcy4gSXQgaXMgYCArICd1bmtub3duIGlmIGl0IHN1Y2NlZWRlZCBvciBmYWlsZWQuIENoZWNrIHNpZ25hdHVyZSAnICsgYCR7c2lnbmF0dXJlfSB1c2luZyB0aGUgU29sYW5hIEV4cGxvcmVyIG9yIENMSSB0b29scy5gKTtcbiAgICB0aGlzLnNpZ25hdHVyZSA9IHZvaWQgMDtcbiAgICB0aGlzLnNpZ25hdHVyZSA9IHNpZ25hdHVyZTtcbiAgfVxufVxuT2JqZWN0LmRlZmluZVByb3BlcnR5KFRyYW5zYWN0aW9uRXhwaXJlZFRpbWVvdXRFcnJvci5wcm90b3R5cGUsICduYW1lJywge1xuICB2YWx1ZTogJ1RyYW5zYWN0aW9uRXhwaXJlZFRpbWVvdXRFcnJvcidcbn0pO1xuY2xhc3MgVHJhbnNhY3Rpb25FeHBpcmVkTm9uY2VJbnZhbGlkRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gIGNvbnN0cnVjdG9yKHNpZ25hdHVyZSkge1xuICAgIHN1cGVyKGBTaWduYXR1cmUgJHtzaWduYXR1cmV9IGhhcyBleHBpcmVkOiB0aGUgbm9uY2UgaXMgbm8gbG9uZ2VyIHZhbGlkLmApO1xuICAgIHRoaXMuc2lnbmF0dXJlID0gdm9pZCAwO1xuICAgIHRoaXMuc2lnbmF0dXJlID0gc2lnbmF0dXJlO1xuICB9XG59XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoVHJhbnNhY3Rpb25FeHBpcmVkTm9uY2VJbnZhbGlkRXJyb3IucHJvdG90eXBlLCAnbmFtZScsIHtcbiAgdmFsdWU6ICdUcmFuc2FjdGlvbkV4cGlyZWROb25jZUludmFsaWRFcnJvcidcbn0pO1xuXG5jbGFzcyBNZXNzYWdlQWNjb3VudEtleXMge1xuICBjb25zdHJ1Y3RvcihzdGF0aWNBY2NvdW50S2V5cywgYWNjb3VudEtleXNGcm9tTG9va3Vwcykge1xuICAgIHRoaXMuc3RhdGljQWNjb3VudEtleXMgPSB2b2lkIDA7XG4gICAgdGhpcy5hY2NvdW50S2V5c0Zyb21Mb29rdXBzID0gdm9pZCAwO1xuICAgIHRoaXMuc3RhdGljQWNjb3VudEtleXMgPSBzdGF0aWNBY2NvdW50S2V5cztcbiAgICB0aGlzLmFjY291bnRLZXlzRnJvbUxvb2t1cHMgPSBhY2NvdW50S2V5c0Zyb21Mb29rdXBzO1xuICB9XG4gIGtleVNlZ21lbnRzKCkge1xuICAgIGNvbnN0IGtleVNlZ21lbnRzID0gW3RoaXMuc3RhdGljQWNjb3VudEtleXNdO1xuICAgIGlmICh0aGlzLmFjY291bnRLZXlzRnJvbUxvb2t1cHMpIHtcbiAgICAgIGtleVNlZ21lbnRzLnB1c2godGhpcy5hY2NvdW50S2V5c0Zyb21Mb29rdXBzLndyaXRhYmxlKTtcbiAgICAgIGtleVNlZ21lbnRzLnB1c2godGhpcy5hY2NvdW50S2V5c0Zyb21Mb29rdXBzLnJlYWRvbmx5KTtcbiAgICB9XG4gICAgcmV0dXJuIGtleVNlZ21lbnRzO1xuICB9XG4gIGdldChpbmRleCkge1xuICAgIGZvciAoY29uc3Qga2V5U2VnbWVudCBvZiB0aGlzLmtleVNlZ21lbnRzKCkpIHtcbiAgICAgIGlmIChpbmRleCA8IGtleVNlZ21lbnQubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBrZXlTZWdtZW50W2luZGV4XTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGluZGV4IC09IGtleVNlZ21lbnQubGVuZ3RoO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm47XG4gIH1cbiAgZ2V0IGxlbmd0aCgpIHtcbiAgICByZXR1cm4gdGhpcy5rZXlTZWdtZW50cygpLmZsYXQoKS5sZW5ndGg7XG4gIH1cbiAgY29tcGlsZUluc3RydWN0aW9ucyhpbnN0cnVjdGlvbnMpIHtcbiAgICAvLyBCYWlsIGVhcmx5IGlmIGFueSBhY2NvdW50IGluZGV4ZXMgd291bGQgb3ZlcmZsb3cgYSB1OFxuICAgIGNvbnN0IFU4X01BWCA9IDI1NTtcbiAgICBpZiAodGhpcy5sZW5ndGggPiBVOF9NQVggKyAxKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0FjY291bnQgaW5kZXggb3ZlcmZsb3cgZW5jb3VudGVyZWQgZHVyaW5nIGNvbXBpbGF0aW9uJyk7XG4gICAgfVxuICAgIGNvbnN0IGtleUluZGV4TWFwID0gbmV3IE1hcCgpO1xuICAgIHRoaXMua2V5U2VnbWVudHMoKS5mbGF0KCkuZm9yRWFjaCgoa2V5LCBpbmRleCkgPT4ge1xuICAgICAga2V5SW5kZXhNYXAuc2V0KGtleS50b0Jhc2U1OCgpLCBpbmRleCk7XG4gICAgfSk7XG4gICAgY29uc3QgZmluZEtleUluZGV4ID0ga2V5ID0+IHtcbiAgICAgIGNvbnN0IGtleUluZGV4ID0ga2V5SW5kZXhNYXAuZ2V0KGtleS50b0Jhc2U1OCgpKTtcbiAgICAgIGlmIChrZXlJbmRleCA9PT0gdW5kZWZpbmVkKSB0aHJvdyBuZXcgRXJyb3IoJ0VuY291bnRlcmVkIGFuIHVua25vd24gaW5zdHJ1Y3Rpb24gYWNjb3VudCBrZXkgZHVyaW5nIGNvbXBpbGF0aW9uJyk7XG4gICAgICByZXR1cm4ga2V5SW5kZXg7XG4gICAgfTtcbiAgICByZXR1cm4gaW5zdHJ1Y3Rpb25zLm1hcChpbnN0cnVjdGlvbiA9PiB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBwcm9ncmFtSWRJbmRleDogZmluZEtleUluZGV4KGluc3RydWN0aW9uLnByb2dyYW1JZCksXG4gICAgICAgIGFjY291bnRLZXlJbmRleGVzOiBpbnN0cnVjdGlvbi5rZXlzLm1hcChtZXRhID0+IGZpbmRLZXlJbmRleChtZXRhLnB1YmtleSkpLFxuICAgICAgICBkYXRhOiBpbnN0cnVjdGlvbi5kYXRhXG4gICAgICB9O1xuICAgIH0pO1xuICB9XG59XG5cbi8qKlxuICogTGF5b3V0IGZvciBhIHB1YmxpYyBrZXlcbiAqL1xuY29uc3QgcHVibGljS2V5ID0gKHByb3BlcnR5ID0gJ3B1YmxpY0tleScpID0+IHtcbiAgcmV0dXJuIEJ1ZmZlckxheW91dC5ibG9iKDMyLCBwcm9wZXJ0eSk7XG59O1xuXG4vKipcbiAqIExheW91dCBmb3IgYSBzaWduYXR1cmVcbiAqL1xuY29uc3Qgc2lnbmF0dXJlID0gKHByb3BlcnR5ID0gJ3NpZ25hdHVyZScpID0+IHtcbiAgcmV0dXJuIEJ1ZmZlckxheW91dC5ibG9iKDY0LCBwcm9wZXJ0eSk7XG59O1xuLyoqXG4gKiBMYXlvdXQgZm9yIGEgUnVzdCBTdHJpbmcgdHlwZVxuICovXG5jb25zdCBydXN0U3RyaW5nID0gKHByb3BlcnR5ID0gJ3N0cmluZycpID0+IHtcbiAgY29uc3QgcnNsID0gQnVmZmVyTGF5b3V0LnN0cnVjdChbQnVmZmVyTGF5b3V0LnUzMignbGVuZ3RoJyksIEJ1ZmZlckxheW91dC51MzIoJ2xlbmd0aFBhZGRpbmcnKSwgQnVmZmVyTGF5b3V0LmJsb2IoQnVmZmVyTGF5b3V0Lm9mZnNldChCdWZmZXJMYXlvdXQudTMyKCksIC04KSwgJ2NoYXJzJyldLCBwcm9wZXJ0eSk7XG4gIGNvbnN0IF9kZWNvZGUgPSByc2wuZGVjb2RlLmJpbmQocnNsKTtcbiAgY29uc3QgX2VuY29kZSA9IHJzbC5lbmNvZGUuYmluZChyc2wpO1xuICBjb25zdCByc2xTaGltID0gcnNsO1xuICByc2xTaGltLmRlY29kZSA9IChiLCBvZmZzZXQpID0+IHtcbiAgICBjb25zdCBkYXRhID0gX2RlY29kZShiLCBvZmZzZXQpO1xuICAgIHJldHVybiBkYXRhWydjaGFycyddLnRvU3RyaW5nKCk7XG4gIH07XG4gIHJzbFNoaW0uZW5jb2RlID0gKHN0ciwgYiwgb2Zmc2V0KSA9PiB7XG4gICAgY29uc3QgZGF0YSA9IHtcbiAgICAgIGNoYXJzOiBCdWZmZXIuZnJvbShzdHIsICd1dGY4JylcbiAgICB9O1xuICAgIHJldHVybiBfZW5jb2RlKGRhdGEsIGIsIG9mZnNldCk7XG4gIH07XG4gIHJzbFNoaW0uYWxsb2MgPSBzdHIgPT4ge1xuICAgIHJldHVybiBCdWZmZXJMYXlvdXQudTMyKCkuc3BhbiArIEJ1ZmZlckxheW91dC51MzIoKS5zcGFuICsgQnVmZmVyLmZyb20oc3RyLCAndXRmOCcpLmxlbmd0aDtcbiAgfTtcbiAgcmV0dXJuIHJzbFNoaW07XG59O1xuXG4vKipcbiAqIExheW91dCBmb3IgYW4gQXV0aG9yaXplZCBvYmplY3RcbiAqL1xuY29uc3QgYXV0aG9yaXplZCA9IChwcm9wZXJ0eSA9ICdhdXRob3JpemVkJykgPT4ge1xuICByZXR1cm4gQnVmZmVyTGF5b3V0LnN0cnVjdChbcHVibGljS2V5KCdzdGFrZXInKSwgcHVibGljS2V5KCd3aXRoZHJhd2VyJyldLCBwcm9wZXJ0eSk7XG59O1xuXG4vKipcbiAqIExheW91dCBmb3IgYSBMb2NrdXAgb2JqZWN0XG4gKi9cbmNvbnN0IGxvY2t1cCA9IChwcm9wZXJ0eSA9ICdsb2NrdXAnKSA9PiB7XG4gIHJldHVybiBCdWZmZXJMYXlvdXQuc3RydWN0KFtCdWZmZXJMYXlvdXQubnM2NCgndW5peFRpbWVzdGFtcCcpLCBCdWZmZXJMYXlvdXQubnM2NCgnZXBvY2gnKSwgcHVibGljS2V5KCdjdXN0b2RpYW4nKV0sIHByb3BlcnR5KTtcbn07XG5cbi8qKlxuICogIExheW91dCBmb3IgYSBWb3RlSW5pdCBvYmplY3RcbiAqL1xuY29uc3Qgdm90ZUluaXQgPSAocHJvcGVydHkgPSAndm90ZUluaXQnKSA9PiB7XG4gIHJldHVybiBCdWZmZXJMYXlvdXQuc3RydWN0KFtwdWJsaWNLZXkoJ25vZGVQdWJrZXknKSwgcHVibGljS2V5KCdhdXRob3JpemVkVm90ZXInKSwgcHVibGljS2V5KCdhdXRob3JpemVkV2l0aGRyYXdlcicpLCBCdWZmZXJMYXlvdXQudTgoJ2NvbW1pc3Npb24nKV0sIHByb3BlcnR5KTtcbn07XG5cbi8qKlxuICogIExheW91dCBmb3IgYSBWb3RlQXV0aG9yaXplV2l0aFNlZWRBcmdzIG9iamVjdFxuICovXG5jb25zdCB2b3RlQXV0aG9yaXplV2l0aFNlZWRBcmdzID0gKHByb3BlcnR5ID0gJ3ZvdGVBdXRob3JpemVXaXRoU2VlZEFyZ3MnKSA9PiB7XG4gIHJldHVybiBCdWZmZXJMYXlvdXQuc3RydWN0KFtCdWZmZXJMYXlvdXQudTMyKCd2b3RlQXV0aG9yaXphdGlvblR5cGUnKSwgcHVibGljS2V5KCdjdXJyZW50QXV0aG9yaXR5RGVyaXZlZEtleU93bmVyUHVia2V5JyksIHJ1c3RTdHJpbmcoJ2N1cnJlbnRBdXRob3JpdHlEZXJpdmVkS2V5U2VlZCcpLCBwdWJsaWNLZXkoJ25ld0F1dGhvcml6ZWQnKV0sIHByb3BlcnR5KTtcbn07XG5mdW5jdGlvbiBnZXRBbGxvYyh0eXBlLCBmaWVsZHMpIHtcbiAgY29uc3QgZ2V0SXRlbUFsbG9jID0gaXRlbSA9PiB7XG4gICAgaWYgKGl0ZW0uc3BhbiA+PSAwKSB7XG4gICAgICByZXR1cm4gaXRlbS5zcGFuO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIGl0ZW0uYWxsb2MgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHJldHVybiBpdGVtLmFsbG9jKGZpZWxkc1tpdGVtLnByb3BlcnR5XSk7XG4gICAgfSBlbHNlIGlmICgnY291bnQnIGluIGl0ZW0gJiYgJ2VsZW1lbnRMYXlvdXQnIGluIGl0ZW0pIHtcbiAgICAgIGNvbnN0IGZpZWxkID0gZmllbGRzW2l0ZW0ucHJvcGVydHldO1xuICAgICAgaWYgKEFycmF5LmlzQXJyYXkoZmllbGQpKSB7XG4gICAgICAgIHJldHVybiBmaWVsZC5sZW5ndGggKiBnZXRJdGVtQWxsb2MoaXRlbS5lbGVtZW50TGF5b3V0KTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKCdmaWVsZHMnIGluIGl0ZW0pIHtcbiAgICAgIC8vIFRoaXMgaXMgYSBgU3RydWN0dXJlYCB3aG9zZSBzaXplIG5lZWRzIHRvIGJlIHJlY3Vyc2l2ZWx5IG1lYXN1cmVkLlxuICAgICAgcmV0dXJuIGdldEFsbG9jKHtcbiAgICAgICAgbGF5b3V0OiBpdGVtXG4gICAgICB9LCBmaWVsZHNbaXRlbS5wcm9wZXJ0eV0pO1xuICAgIH1cbiAgICAvLyBDb3VsZG4ndCBkZXRlcm1pbmUgYWxsb2NhdGVkIHNpemUgb2YgbGF5b3V0XG4gICAgcmV0dXJuIDA7XG4gIH07XG4gIGxldCBhbGxvYyA9IDA7XG4gIHR5cGUubGF5b3V0LmZpZWxkcy5mb3JFYWNoKGl0ZW0gPT4ge1xuICAgIGFsbG9jICs9IGdldEl0ZW1BbGxvYyhpdGVtKTtcbiAgfSk7XG4gIHJldHVybiBhbGxvYztcbn1cblxuZnVuY3Rpb24gZGVjb2RlTGVuZ3RoKGJ5dGVzKSB7XG4gIGxldCBsZW4gPSAwO1xuICBsZXQgc2l6ZSA9IDA7XG4gIGZvciAoOzspIHtcbiAgICBsZXQgZWxlbSA9IGJ5dGVzLnNoaWZ0KCk7XG4gICAgbGVuIHw9IChlbGVtICYgMHg3ZikgPDwgc2l6ZSAqIDc7XG4gICAgc2l6ZSArPSAxO1xuICAgIGlmICgoZWxlbSAmIDB4ODApID09PSAwKSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGxlbjtcbn1cbmZ1bmN0aW9uIGVuY29kZUxlbmd0aChieXRlcywgbGVuKSB7XG4gIGxldCByZW1fbGVuID0gbGVuO1xuICBmb3IgKDs7KSB7XG4gICAgbGV0IGVsZW0gPSByZW1fbGVuICYgMHg3ZjtcbiAgICByZW1fbGVuID4+PSA3O1xuICAgIGlmIChyZW1fbGVuID09IDApIHtcbiAgICAgIGJ5dGVzLnB1c2goZWxlbSk7XG4gICAgICBicmVhaztcbiAgICB9IGVsc2Uge1xuICAgICAgZWxlbSB8PSAweDgwO1xuICAgICAgYnl0ZXMucHVzaChlbGVtKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gYXNzZXJ0IChjb25kaXRpb24sIG1lc3NhZ2UpIHtcbiAgaWYgKCFjb25kaXRpb24pIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IobWVzc2FnZSB8fCAnQXNzZXJ0aW9uIGZhaWxlZCcpO1xuICB9XG59XG5cbmNsYXNzIENvbXBpbGVkS2V5cyB7XG4gIGNvbnN0cnVjdG9yKHBheWVyLCBrZXlNZXRhTWFwKSB7XG4gICAgdGhpcy5wYXllciA9IHZvaWQgMDtcbiAgICB0aGlzLmtleU1ldGFNYXAgPSB2b2lkIDA7XG4gICAgdGhpcy5wYXllciA9IHBheWVyO1xuICAgIHRoaXMua2V5TWV0YU1hcCA9IGtleU1ldGFNYXA7XG4gIH1cbiAgc3RhdGljIGNvbXBpbGUoaW5zdHJ1Y3Rpb25zLCBwYXllcikge1xuICAgIGNvbnN0IGtleU1ldGFNYXAgPSBuZXcgTWFwKCk7XG4gICAgY29uc3QgZ2V0T3JJbnNlcnREZWZhdWx0ID0gcHVia2V5ID0+IHtcbiAgICAgIGNvbnN0IGFkZHJlc3MgPSBwdWJrZXkudG9CYXNlNTgoKTtcbiAgICAgIGxldCBrZXlNZXRhID0ga2V5TWV0YU1hcC5nZXQoYWRkcmVzcyk7XG4gICAgICBpZiAoa2V5TWV0YSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGtleU1ldGEgPSB7XG4gICAgICAgICAgaXNTaWduZXI6IGZhbHNlLFxuICAgICAgICAgIGlzV3JpdGFibGU6IGZhbHNlLFxuICAgICAgICAgIGlzSW52b2tlZDogZmFsc2VcbiAgICAgICAgfTtcbiAgICAgICAga2V5TWV0YU1hcC5zZXQoYWRkcmVzcywga2V5TWV0YSk7XG4gICAgICB9XG4gICAgICByZXR1cm4ga2V5TWV0YTtcbiAgICB9O1xuICAgIGNvbnN0IHBheWVyS2V5TWV0YSA9IGdldE9ySW5zZXJ0RGVmYXVsdChwYXllcik7XG4gICAgcGF5ZXJLZXlNZXRhLmlzU2lnbmVyID0gdHJ1ZTtcbiAgICBwYXllcktleU1ldGEuaXNXcml0YWJsZSA9IHRydWU7XG4gICAgZm9yIChjb25zdCBpeCBvZiBpbnN0cnVjdGlvbnMpIHtcbiAgICAgIGdldE9ySW5zZXJ0RGVmYXVsdChpeC5wcm9ncmFtSWQpLmlzSW52b2tlZCA9IHRydWU7XG4gICAgICBmb3IgKGNvbnN0IGFjY291bnRNZXRhIG9mIGl4LmtleXMpIHtcbiAgICAgICAgY29uc3Qga2V5TWV0YSA9IGdldE9ySW5zZXJ0RGVmYXVsdChhY2NvdW50TWV0YS5wdWJrZXkpO1xuICAgICAgICBrZXlNZXRhLmlzU2lnbmVyIHx8PSBhY2NvdW50TWV0YS5pc1NpZ25lcjtcbiAgICAgICAga2V5TWV0YS5pc1dyaXRhYmxlIHx8PSBhY2NvdW50TWV0YS5pc1dyaXRhYmxlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbmV3IENvbXBpbGVkS2V5cyhwYXllciwga2V5TWV0YU1hcCk7XG4gIH1cbiAgZ2V0TWVzc2FnZUNvbXBvbmVudHMoKSB7XG4gICAgY29uc3QgbWFwRW50cmllcyA9IFsuLi50aGlzLmtleU1ldGFNYXAuZW50cmllcygpXTtcbiAgICBhc3NlcnQobWFwRW50cmllcy5sZW5ndGggPD0gMjU2LCAnTWF4IHN0YXRpYyBhY2NvdW50IGtleXMgbGVuZ3RoIGV4Y2VlZGVkJyk7XG4gICAgY29uc3Qgd3JpdGFibGVTaWduZXJzID0gbWFwRW50cmllcy5maWx0ZXIoKFssIG1ldGFdKSA9PiBtZXRhLmlzU2lnbmVyICYmIG1ldGEuaXNXcml0YWJsZSk7XG4gICAgY29uc3QgcmVhZG9ubHlTaWduZXJzID0gbWFwRW50cmllcy5maWx0ZXIoKFssIG1ldGFdKSA9PiBtZXRhLmlzU2lnbmVyICYmICFtZXRhLmlzV3JpdGFibGUpO1xuICAgIGNvbnN0IHdyaXRhYmxlTm9uU2lnbmVycyA9IG1hcEVudHJpZXMuZmlsdGVyKChbLCBtZXRhXSkgPT4gIW1ldGEuaXNTaWduZXIgJiYgbWV0YS5pc1dyaXRhYmxlKTtcbiAgICBjb25zdCByZWFkb25seU5vblNpZ25lcnMgPSBtYXBFbnRyaWVzLmZpbHRlcigoWywgbWV0YV0pID0+ICFtZXRhLmlzU2lnbmVyICYmICFtZXRhLmlzV3JpdGFibGUpO1xuICAgIGNvbnN0IGhlYWRlciA9IHtcbiAgICAgIG51bVJlcXVpcmVkU2lnbmF0dXJlczogd3JpdGFibGVTaWduZXJzLmxlbmd0aCArIHJlYWRvbmx5U2lnbmVycy5sZW5ndGgsXG4gICAgICBudW1SZWFkb25seVNpZ25lZEFjY291bnRzOiByZWFkb25seVNpZ25lcnMubGVuZ3RoLFxuICAgICAgbnVtUmVhZG9ubHlVbnNpZ25lZEFjY291bnRzOiByZWFkb25seU5vblNpZ25lcnMubGVuZ3RoXG4gICAgfTtcblxuICAgIC8vIHNhbml0eSBjaGVja3NcbiAgICB7XG4gICAgICBhc3NlcnQod3JpdGFibGVTaWduZXJzLmxlbmd0aCA+IDAsICdFeHBlY3RlZCBhdCBsZWFzdCBvbmUgd3JpdGFibGUgc2lnbmVyIGtleScpO1xuICAgICAgY29uc3QgW3BheWVyQWRkcmVzc10gPSB3cml0YWJsZVNpZ25lcnNbMF07XG4gICAgICBhc3NlcnQocGF5ZXJBZGRyZXNzID09PSB0aGlzLnBheWVyLnRvQmFzZTU4KCksICdFeHBlY3RlZCBmaXJzdCB3cml0YWJsZSBzaWduZXIga2V5IHRvIGJlIHRoZSBmZWUgcGF5ZXInKTtcbiAgICB9XG4gICAgY29uc3Qgc3RhdGljQWNjb3VudEtleXMgPSBbLi4ud3JpdGFibGVTaWduZXJzLm1hcCgoW2FkZHJlc3NdKSA9PiBuZXcgUHVibGljS2V5KGFkZHJlc3MpKSwgLi4ucmVhZG9ubHlTaWduZXJzLm1hcCgoW2FkZHJlc3NdKSA9PiBuZXcgUHVibGljS2V5KGFkZHJlc3MpKSwgLi4ud3JpdGFibGVOb25TaWduZXJzLm1hcCgoW2FkZHJlc3NdKSA9PiBuZXcgUHVibGljS2V5KGFkZHJlc3MpKSwgLi4ucmVhZG9ubHlOb25TaWduZXJzLm1hcCgoW2FkZHJlc3NdKSA9PiBuZXcgUHVibGljS2V5KGFkZHJlc3MpKV07XG4gICAgcmV0dXJuIFtoZWFkZXIsIHN0YXRpY0FjY291bnRLZXlzXTtcbiAgfVxuICBleHRyYWN0VGFibGVMb29rdXAobG9va3VwVGFibGUpIHtcbiAgICBjb25zdCBbd3JpdGFibGVJbmRleGVzLCBkcmFpbmVkV3JpdGFibGVLZXlzXSA9IHRoaXMuZHJhaW5LZXlzRm91bmRJbkxvb2t1cFRhYmxlKGxvb2t1cFRhYmxlLnN0YXRlLmFkZHJlc3Nlcywga2V5TWV0YSA9PiAha2V5TWV0YS5pc1NpZ25lciAmJiAha2V5TWV0YS5pc0ludm9rZWQgJiYga2V5TWV0YS5pc1dyaXRhYmxlKTtcbiAgICBjb25zdCBbcmVhZG9ubHlJbmRleGVzLCBkcmFpbmVkUmVhZG9ubHlLZXlzXSA9IHRoaXMuZHJhaW5LZXlzRm91bmRJbkxvb2t1cFRhYmxlKGxvb2t1cFRhYmxlLnN0YXRlLmFkZHJlc3Nlcywga2V5TWV0YSA9PiAha2V5TWV0YS5pc1NpZ25lciAmJiAha2V5TWV0YS5pc0ludm9rZWQgJiYgIWtleU1ldGEuaXNXcml0YWJsZSk7XG5cbiAgICAvLyBEb24ndCBleHRyYWN0IGxvb2t1cCBpZiBubyBrZXlzIHdlcmUgZm91bmRcbiAgICBpZiAod3JpdGFibGVJbmRleGVzLmxlbmd0aCA9PT0gMCAmJiByZWFkb25seUluZGV4ZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHJldHVybiBbe1xuICAgICAgYWNjb3VudEtleTogbG9va3VwVGFibGUua2V5LFxuICAgICAgd3JpdGFibGVJbmRleGVzLFxuICAgICAgcmVhZG9ubHlJbmRleGVzXG4gICAgfSwge1xuICAgICAgd3JpdGFibGU6IGRyYWluZWRXcml0YWJsZUtleXMsXG4gICAgICByZWFkb25seTogZHJhaW5lZFJlYWRvbmx5S2V5c1xuICAgIH1dO1xuICB9XG5cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBkcmFpbktleXNGb3VuZEluTG9va3VwVGFibGUobG9va3VwVGFibGVFbnRyaWVzLCBrZXlNZXRhRmlsdGVyKSB7XG4gICAgY29uc3QgbG9va3VwVGFibGVJbmRleGVzID0gbmV3IEFycmF5KCk7XG4gICAgY29uc3QgZHJhaW5lZEtleXMgPSBuZXcgQXJyYXkoKTtcbiAgICBmb3IgKGNvbnN0IFthZGRyZXNzLCBrZXlNZXRhXSBvZiB0aGlzLmtleU1ldGFNYXAuZW50cmllcygpKSB7XG4gICAgICBpZiAoa2V5TWV0YUZpbHRlcihrZXlNZXRhKSkge1xuICAgICAgICBjb25zdCBrZXkgPSBuZXcgUHVibGljS2V5KGFkZHJlc3MpO1xuICAgICAgICBjb25zdCBsb29rdXBUYWJsZUluZGV4ID0gbG9va3VwVGFibGVFbnRyaWVzLmZpbmRJbmRleChlbnRyeSA9PiBlbnRyeS5lcXVhbHMoa2V5KSk7XG4gICAgICAgIGlmIChsb29rdXBUYWJsZUluZGV4ID49IDApIHtcbiAgICAgICAgICBhc3NlcnQobG9va3VwVGFibGVJbmRleCA8IDI1NiwgJ01heCBsb29rdXAgdGFibGUgaW5kZXggZXhjZWVkZWQnKTtcbiAgICAgICAgICBsb29rdXBUYWJsZUluZGV4ZXMucHVzaChsb29rdXBUYWJsZUluZGV4KTtcbiAgICAgICAgICBkcmFpbmVkS2V5cy5wdXNoKGtleSk7XG4gICAgICAgICAgdGhpcy5rZXlNZXRhTWFwLmRlbGV0ZShhZGRyZXNzKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gW2xvb2t1cFRhYmxlSW5kZXhlcywgZHJhaW5lZEtleXNdO1xuICB9XG59XG5cbmNvbnN0IEVORF9PRl9CVUZGRVJfRVJST1JfTUVTU0FHRSA9ICdSZWFjaGVkIGVuZCBvZiBidWZmZXIgdW5leHBlY3RlZGx5JztcblxuLyoqXG4gKiBEZWxlZ2F0ZXMgdG8gYEFycmF5I3NoaWZ0YCwgYnV0IHRocm93cyBpZiB0aGUgYXJyYXkgaXMgemVyby1sZW5ndGguXG4gKi9cbmZ1bmN0aW9uIGd1YXJkZWRTaGlmdChieXRlQXJyYXkpIHtcbiAgaWYgKGJ5dGVBcnJheS5sZW5ndGggPT09IDApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoRU5EX09GX0JVRkZFUl9FUlJPUl9NRVNTQUdFKTtcbiAgfVxuICByZXR1cm4gYnl0ZUFycmF5LnNoaWZ0KCk7XG59XG5cbi8qKlxuICogRGVsZWdhdGVzIHRvIGBBcnJheSNzcGxpY2VgLCBidXQgdGhyb3dzIGlmIHRoZSBzZWN0aW9uIGJlaW5nIHNwbGljZWQgb3V0IGV4dGVuZHMgcGFzdCB0aGUgZW5kIG9mXG4gKiB0aGUgYXJyYXkuXG4gKi9cbmZ1bmN0aW9uIGd1YXJkZWRTcGxpY2UoYnl0ZUFycmF5LCAuLi5hcmdzKSB7XG4gIGNvbnN0IFtzdGFydF0gPSBhcmdzO1xuICBpZiAoYXJncy5sZW5ndGggPT09IDIgLy8gSW1wbGllcyB0aGF0IGBkZWxldGVDb3VudGAgd2FzIHN1cHBsaWVkXG4gID8gc3RhcnQgKyAoYXJnc1sxXSA/PyAwKSA+IGJ5dGVBcnJheS5sZW5ndGggOiBzdGFydCA+PSBieXRlQXJyYXkubGVuZ3RoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKEVORF9PRl9CVUZGRVJfRVJST1JfTUVTU0FHRSk7XG4gIH1cbiAgcmV0dXJuIGJ5dGVBcnJheS5zcGxpY2UoLi4uYXJncyk7XG59XG5cbi8qKlxuICogQW4gaW5zdHJ1Y3Rpb24gdG8gZXhlY3V0ZSBieSBhIHByb2dyYW1cbiAqXG4gKiBAcHJvcGVydHkge251bWJlcn0gcHJvZ3JhbUlkSW5kZXhcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyW119IGFjY291bnRzXG4gKiBAcHJvcGVydHkge3N0cmluZ30gZGF0YVxuICovXG5cbi8qKlxuICogTWVzc2FnZSBjb25zdHJ1Y3RvciBhcmd1bWVudHNcbiAqL1xuXG4vKipcbiAqIExpc3Qgb2YgaW5zdHJ1Y3Rpb25zIHRvIGJlIHByb2Nlc3NlZCBhdG9taWNhbGx5XG4gKi9cbmNsYXNzIE1lc3NhZ2Uge1xuICBjb25zdHJ1Y3RvcihhcmdzKSB7XG4gICAgdGhpcy5oZWFkZXIgPSB2b2lkIDA7XG4gICAgdGhpcy5hY2NvdW50S2V5cyA9IHZvaWQgMDtcbiAgICB0aGlzLnJlY2VudEJsb2NraGFzaCA9IHZvaWQgMDtcbiAgICB0aGlzLmluc3RydWN0aW9ucyA9IHZvaWQgMDtcbiAgICB0aGlzLmluZGV4VG9Qcm9ncmFtSWRzID0gbmV3IE1hcCgpO1xuICAgIHRoaXMuaGVhZGVyID0gYXJncy5oZWFkZXI7XG4gICAgdGhpcy5hY2NvdW50S2V5cyA9IGFyZ3MuYWNjb3VudEtleXMubWFwKGFjY291bnQgPT4gbmV3IFB1YmxpY0tleShhY2NvdW50KSk7XG4gICAgdGhpcy5yZWNlbnRCbG9ja2hhc2ggPSBhcmdzLnJlY2VudEJsb2NraGFzaDtcbiAgICB0aGlzLmluc3RydWN0aW9ucyA9IGFyZ3MuaW5zdHJ1Y3Rpb25zO1xuICAgIHRoaXMuaW5zdHJ1Y3Rpb25zLmZvckVhY2goaXggPT4gdGhpcy5pbmRleFRvUHJvZ3JhbUlkcy5zZXQoaXgucHJvZ3JhbUlkSW5kZXgsIHRoaXMuYWNjb3VudEtleXNbaXgucHJvZ3JhbUlkSW5kZXhdKSk7XG4gIH1cbiAgZ2V0IHZlcnNpb24oKSB7XG4gICAgcmV0dXJuICdsZWdhY3knO1xuICB9XG4gIGdldCBzdGF0aWNBY2NvdW50S2V5cygpIHtcbiAgICByZXR1cm4gdGhpcy5hY2NvdW50S2V5cztcbiAgfVxuICBnZXQgY29tcGlsZWRJbnN0cnVjdGlvbnMoKSB7XG4gICAgcmV0dXJuIHRoaXMuaW5zdHJ1Y3Rpb25zLm1hcChpeCA9PiAoe1xuICAgICAgcHJvZ3JhbUlkSW5kZXg6IGl4LnByb2dyYW1JZEluZGV4LFxuICAgICAgYWNjb3VudEtleUluZGV4ZXM6IGl4LmFjY291bnRzLFxuICAgICAgZGF0YTogYnM1OC5kZWNvZGUoaXguZGF0YSlcbiAgICB9KSk7XG4gIH1cbiAgZ2V0IGFkZHJlc3NUYWJsZUxvb2t1cHMoKSB7XG4gICAgcmV0dXJuIFtdO1xuICB9XG4gIGdldEFjY291bnRLZXlzKCkge1xuICAgIHJldHVybiBuZXcgTWVzc2FnZUFjY291bnRLZXlzKHRoaXMuc3RhdGljQWNjb3VudEtleXMpO1xuICB9XG4gIHN0YXRpYyBjb21waWxlKGFyZ3MpIHtcbiAgICBjb25zdCBjb21waWxlZEtleXMgPSBDb21waWxlZEtleXMuY29tcGlsZShhcmdzLmluc3RydWN0aW9ucywgYXJncy5wYXllcktleSk7XG4gICAgY29uc3QgW2hlYWRlciwgc3RhdGljQWNjb3VudEtleXNdID0gY29tcGlsZWRLZXlzLmdldE1lc3NhZ2VDb21wb25lbnRzKCk7XG4gICAgY29uc3QgYWNjb3VudEtleXMgPSBuZXcgTWVzc2FnZUFjY291bnRLZXlzKHN0YXRpY0FjY291bnRLZXlzKTtcbiAgICBjb25zdCBpbnN0cnVjdGlvbnMgPSBhY2NvdW50S2V5cy5jb21waWxlSW5zdHJ1Y3Rpb25zKGFyZ3MuaW5zdHJ1Y3Rpb25zKS5tYXAoaXggPT4gKHtcbiAgICAgIHByb2dyYW1JZEluZGV4OiBpeC5wcm9ncmFtSWRJbmRleCxcbiAgICAgIGFjY291bnRzOiBpeC5hY2NvdW50S2V5SW5kZXhlcyxcbiAgICAgIGRhdGE6IGJzNTguZW5jb2RlKGl4LmRhdGEpXG4gICAgfSkpO1xuICAgIHJldHVybiBuZXcgTWVzc2FnZSh7XG4gICAgICBoZWFkZXIsXG4gICAgICBhY2NvdW50S2V5czogc3RhdGljQWNjb3VudEtleXMsXG4gICAgICByZWNlbnRCbG9ja2hhc2g6IGFyZ3MucmVjZW50QmxvY2toYXNoLFxuICAgICAgaW5zdHJ1Y3Rpb25zXG4gICAgfSk7XG4gIH1cbiAgaXNBY2NvdW50U2lnbmVyKGluZGV4KSB7XG4gICAgcmV0dXJuIGluZGV4IDwgdGhpcy5oZWFkZXIubnVtUmVxdWlyZWRTaWduYXR1cmVzO1xuICB9XG4gIGlzQWNjb3VudFdyaXRhYmxlKGluZGV4KSB7XG4gICAgY29uc3QgbnVtU2lnbmVkQWNjb3VudHMgPSB0aGlzLmhlYWRlci5udW1SZXF1aXJlZFNpZ25hdHVyZXM7XG4gICAgaWYgKGluZGV4ID49IHRoaXMuaGVhZGVyLm51bVJlcXVpcmVkU2lnbmF0dXJlcykge1xuICAgICAgY29uc3QgdW5zaWduZWRBY2NvdW50SW5kZXggPSBpbmRleCAtIG51bVNpZ25lZEFjY291bnRzO1xuICAgICAgY29uc3QgbnVtVW5zaWduZWRBY2NvdW50cyA9IHRoaXMuYWNjb3VudEtleXMubGVuZ3RoIC0gbnVtU2lnbmVkQWNjb3VudHM7XG4gICAgICBjb25zdCBudW1Xcml0YWJsZVVuc2lnbmVkQWNjb3VudHMgPSBudW1VbnNpZ25lZEFjY291bnRzIC0gdGhpcy5oZWFkZXIubnVtUmVhZG9ubHlVbnNpZ25lZEFjY291bnRzO1xuICAgICAgcmV0dXJuIHVuc2lnbmVkQWNjb3VudEluZGV4IDwgbnVtV3JpdGFibGVVbnNpZ25lZEFjY291bnRzO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBudW1Xcml0YWJsZVNpZ25lZEFjY291bnRzID0gbnVtU2lnbmVkQWNjb3VudHMgLSB0aGlzLmhlYWRlci5udW1SZWFkb25seVNpZ25lZEFjY291bnRzO1xuICAgICAgcmV0dXJuIGluZGV4IDwgbnVtV3JpdGFibGVTaWduZWRBY2NvdW50cztcbiAgICB9XG4gIH1cbiAgaXNQcm9ncmFtSWQoaW5kZXgpIHtcbiAgICByZXR1cm4gdGhpcy5pbmRleFRvUHJvZ3JhbUlkcy5oYXMoaW5kZXgpO1xuICB9XG4gIHByb2dyYW1JZHMoKSB7XG4gICAgcmV0dXJuIFsuLi50aGlzLmluZGV4VG9Qcm9ncmFtSWRzLnZhbHVlcygpXTtcbiAgfVxuICBub25Qcm9ncmFtSWRzKCkge1xuICAgIHJldHVybiB0aGlzLmFjY291bnRLZXlzLmZpbHRlcigoXywgaW5kZXgpID0+ICF0aGlzLmlzUHJvZ3JhbUlkKGluZGV4KSk7XG4gIH1cbiAgc2VyaWFsaXplKCkge1xuICAgIGNvbnN0IG51bUtleXMgPSB0aGlzLmFjY291bnRLZXlzLmxlbmd0aDtcbiAgICBsZXQga2V5Q291bnQgPSBbXTtcbiAgICBlbmNvZGVMZW5ndGgoa2V5Q291bnQsIG51bUtleXMpO1xuICAgIGNvbnN0IGluc3RydWN0aW9ucyA9IHRoaXMuaW5zdHJ1Y3Rpb25zLm1hcChpbnN0cnVjdGlvbiA9PiB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIGFjY291bnRzLFxuICAgICAgICBwcm9ncmFtSWRJbmRleFxuICAgICAgfSA9IGluc3RydWN0aW9uO1xuICAgICAgY29uc3QgZGF0YSA9IEFycmF5LmZyb20oYnM1OC5kZWNvZGUoaW5zdHJ1Y3Rpb24uZGF0YSkpO1xuICAgICAgbGV0IGtleUluZGljZXNDb3VudCA9IFtdO1xuICAgICAgZW5jb2RlTGVuZ3RoKGtleUluZGljZXNDb3VudCwgYWNjb3VudHMubGVuZ3RoKTtcbiAgICAgIGxldCBkYXRhQ291bnQgPSBbXTtcbiAgICAgIGVuY29kZUxlbmd0aChkYXRhQ291bnQsIGRhdGEubGVuZ3RoKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHByb2dyYW1JZEluZGV4LFxuICAgICAgICBrZXlJbmRpY2VzQ291bnQ6IEJ1ZmZlci5mcm9tKGtleUluZGljZXNDb3VudCksXG4gICAgICAgIGtleUluZGljZXM6IGFjY291bnRzLFxuICAgICAgICBkYXRhTGVuZ3RoOiBCdWZmZXIuZnJvbShkYXRhQ291bnQpLFxuICAgICAgICBkYXRhXG4gICAgICB9O1xuICAgIH0pO1xuICAgIGxldCBpbnN0cnVjdGlvbkNvdW50ID0gW107XG4gICAgZW5jb2RlTGVuZ3RoKGluc3RydWN0aW9uQ291bnQsIGluc3RydWN0aW9ucy5sZW5ndGgpO1xuICAgIGxldCBpbnN0cnVjdGlvbkJ1ZmZlciA9IEJ1ZmZlci5hbGxvYyhQQUNLRVRfREFUQV9TSVpFKTtcbiAgICBCdWZmZXIuZnJvbShpbnN0cnVjdGlvbkNvdW50KS5jb3B5KGluc3RydWN0aW9uQnVmZmVyKTtcbiAgICBsZXQgaW5zdHJ1Y3Rpb25CdWZmZXJMZW5ndGggPSBpbnN0cnVjdGlvbkNvdW50Lmxlbmd0aDtcbiAgICBpbnN0cnVjdGlvbnMuZm9yRWFjaChpbnN0cnVjdGlvbiA9PiB7XG4gICAgICBjb25zdCBpbnN0cnVjdGlvbkxheW91dCA9IEJ1ZmZlckxheW91dC5zdHJ1Y3QoW0J1ZmZlckxheW91dC51OCgncHJvZ3JhbUlkSW5kZXgnKSwgQnVmZmVyTGF5b3V0LmJsb2IoaW5zdHJ1Y3Rpb24ua2V5SW5kaWNlc0NvdW50Lmxlbmd0aCwgJ2tleUluZGljZXNDb3VudCcpLCBCdWZmZXJMYXlvdXQuc2VxKEJ1ZmZlckxheW91dC51OCgna2V5SW5kZXgnKSwgaW5zdHJ1Y3Rpb24ua2V5SW5kaWNlcy5sZW5ndGgsICdrZXlJbmRpY2VzJyksIEJ1ZmZlckxheW91dC5ibG9iKGluc3RydWN0aW9uLmRhdGFMZW5ndGgubGVuZ3RoLCAnZGF0YUxlbmd0aCcpLCBCdWZmZXJMYXlvdXQuc2VxKEJ1ZmZlckxheW91dC51OCgndXNlcmRhdHVtJyksIGluc3RydWN0aW9uLmRhdGEubGVuZ3RoLCAnZGF0YScpXSk7XG4gICAgICBjb25zdCBsZW5ndGggPSBpbnN0cnVjdGlvbkxheW91dC5lbmNvZGUoaW5zdHJ1Y3Rpb24sIGluc3RydWN0aW9uQnVmZmVyLCBpbnN0cnVjdGlvbkJ1ZmZlckxlbmd0aCk7XG4gICAgICBpbnN0cnVjdGlvbkJ1ZmZlckxlbmd0aCArPSBsZW5ndGg7XG4gICAgfSk7XG4gICAgaW5zdHJ1Y3Rpb25CdWZmZXIgPSBpbnN0cnVjdGlvbkJ1ZmZlci5zbGljZSgwLCBpbnN0cnVjdGlvbkJ1ZmZlckxlbmd0aCk7XG4gICAgY29uc3Qgc2lnbkRhdGFMYXlvdXQgPSBCdWZmZXJMYXlvdXQuc3RydWN0KFtCdWZmZXJMYXlvdXQuYmxvYigxLCAnbnVtUmVxdWlyZWRTaWduYXR1cmVzJyksIEJ1ZmZlckxheW91dC5ibG9iKDEsICdudW1SZWFkb25seVNpZ25lZEFjY291bnRzJyksIEJ1ZmZlckxheW91dC5ibG9iKDEsICdudW1SZWFkb25seVVuc2lnbmVkQWNjb3VudHMnKSwgQnVmZmVyTGF5b3V0LmJsb2Ioa2V5Q291bnQubGVuZ3RoLCAna2V5Q291bnQnKSwgQnVmZmVyTGF5b3V0LnNlcShwdWJsaWNLZXkoJ2tleScpLCBudW1LZXlzLCAna2V5cycpLCBwdWJsaWNLZXkoJ3JlY2VudEJsb2NraGFzaCcpXSk7XG4gICAgY29uc3QgdHJhbnNhY3Rpb24gPSB7XG4gICAgICBudW1SZXF1aXJlZFNpZ25hdHVyZXM6IEJ1ZmZlci5mcm9tKFt0aGlzLmhlYWRlci5udW1SZXF1aXJlZFNpZ25hdHVyZXNdKSxcbiAgICAgIG51bVJlYWRvbmx5U2lnbmVkQWNjb3VudHM6IEJ1ZmZlci5mcm9tKFt0aGlzLmhlYWRlci5udW1SZWFkb25seVNpZ25lZEFjY291bnRzXSksXG4gICAgICBudW1SZWFkb25seVVuc2lnbmVkQWNjb3VudHM6IEJ1ZmZlci5mcm9tKFt0aGlzLmhlYWRlci5udW1SZWFkb25seVVuc2lnbmVkQWNjb3VudHNdKSxcbiAgICAgIGtleUNvdW50OiBCdWZmZXIuZnJvbShrZXlDb3VudCksXG4gICAgICBrZXlzOiB0aGlzLmFjY291bnRLZXlzLm1hcChrZXkgPT4gdG9CdWZmZXIoa2V5LnRvQnl0ZXMoKSkpLFxuICAgICAgcmVjZW50QmxvY2toYXNoOiBiczU4LmRlY29kZSh0aGlzLnJlY2VudEJsb2NraGFzaClcbiAgICB9O1xuICAgIGxldCBzaWduRGF0YSA9IEJ1ZmZlci5hbGxvYygyMDQ4KTtcbiAgICBjb25zdCBsZW5ndGggPSBzaWduRGF0YUxheW91dC5lbmNvZGUodHJhbnNhY3Rpb24sIHNpZ25EYXRhKTtcbiAgICBpbnN0cnVjdGlvbkJ1ZmZlci5jb3B5KHNpZ25EYXRhLCBsZW5ndGgpO1xuICAgIHJldHVybiBzaWduRGF0YS5zbGljZSgwLCBsZW5ndGggKyBpbnN0cnVjdGlvbkJ1ZmZlci5sZW5ndGgpO1xuICB9XG5cbiAgLyoqXG4gICAqIERlY29kZSBhIGNvbXBpbGVkIG1lc3NhZ2UgaW50byBhIE1lc3NhZ2Ugb2JqZWN0LlxuICAgKi9cbiAgc3RhdGljIGZyb20oYnVmZmVyKSB7XG4gICAgLy8gU2xpY2UgdXAgd2lyZSBkYXRhXG4gICAgbGV0IGJ5dGVBcnJheSA9IFsuLi5idWZmZXJdO1xuICAgIGNvbnN0IG51bVJlcXVpcmVkU2lnbmF0dXJlcyA9IGd1YXJkZWRTaGlmdChieXRlQXJyYXkpO1xuICAgIGlmIChudW1SZXF1aXJlZFNpZ25hdHVyZXMgIT09IChudW1SZXF1aXJlZFNpZ25hdHVyZXMgJiBWRVJTSU9OX1BSRUZJWF9NQVNLKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdWZXJzaW9uZWQgbWVzc2FnZXMgbXVzdCBiZSBkZXNlcmlhbGl6ZWQgd2l0aCBWZXJzaW9uZWRNZXNzYWdlLmRlc2VyaWFsaXplKCknKTtcbiAgICB9XG4gICAgY29uc3QgbnVtUmVhZG9ubHlTaWduZWRBY2NvdW50cyA9IGd1YXJkZWRTaGlmdChieXRlQXJyYXkpO1xuICAgIGNvbnN0IG51bVJlYWRvbmx5VW5zaWduZWRBY2NvdW50cyA9IGd1YXJkZWRTaGlmdChieXRlQXJyYXkpO1xuICAgIGNvbnN0IGFjY291bnRDb3VudCA9IGRlY29kZUxlbmd0aChieXRlQXJyYXkpO1xuICAgIGxldCBhY2NvdW50S2V5cyA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYWNjb3VudENvdW50OyBpKyspIHtcbiAgICAgIGNvbnN0IGFjY291bnQgPSBndWFyZGVkU3BsaWNlKGJ5dGVBcnJheSwgMCwgUFVCTElDX0tFWV9MRU5HVEgpO1xuICAgICAgYWNjb3VudEtleXMucHVzaChuZXcgUHVibGljS2V5KEJ1ZmZlci5mcm9tKGFjY291bnQpKSk7XG4gICAgfVxuICAgIGNvbnN0IHJlY2VudEJsb2NraGFzaCA9IGd1YXJkZWRTcGxpY2UoYnl0ZUFycmF5LCAwLCBQVUJMSUNfS0VZX0xFTkdUSCk7XG4gICAgY29uc3QgaW5zdHJ1Y3Rpb25Db3VudCA9IGRlY29kZUxlbmd0aChieXRlQXJyYXkpO1xuICAgIGxldCBpbnN0cnVjdGlvbnMgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGluc3RydWN0aW9uQ291bnQ7IGkrKykge1xuICAgICAgY29uc3QgcHJvZ3JhbUlkSW5kZXggPSBndWFyZGVkU2hpZnQoYnl0ZUFycmF5KTtcbiAgICAgIGNvbnN0IGFjY291bnRDb3VudCA9IGRlY29kZUxlbmd0aChieXRlQXJyYXkpO1xuICAgICAgY29uc3QgYWNjb3VudHMgPSBndWFyZGVkU3BsaWNlKGJ5dGVBcnJheSwgMCwgYWNjb3VudENvdW50KTtcbiAgICAgIGNvbnN0IGRhdGFMZW5ndGggPSBkZWNvZGVMZW5ndGgoYnl0ZUFycmF5KTtcbiAgICAgIGNvbnN0IGRhdGFTbGljZSA9IGd1YXJkZWRTcGxpY2UoYnl0ZUFycmF5LCAwLCBkYXRhTGVuZ3RoKTtcbiAgICAgIGNvbnN0IGRhdGEgPSBiczU4LmVuY29kZShCdWZmZXIuZnJvbShkYXRhU2xpY2UpKTtcbiAgICAgIGluc3RydWN0aW9ucy5wdXNoKHtcbiAgICAgICAgcHJvZ3JhbUlkSW5kZXgsXG4gICAgICAgIGFjY291bnRzLFxuICAgICAgICBkYXRhXG4gICAgICB9KTtcbiAgICB9XG4gICAgY29uc3QgbWVzc2FnZUFyZ3MgPSB7XG4gICAgICBoZWFkZXI6IHtcbiAgICAgICAgbnVtUmVxdWlyZWRTaWduYXR1cmVzLFxuICAgICAgICBudW1SZWFkb25seVNpZ25lZEFjY291bnRzLFxuICAgICAgICBudW1SZWFkb25seVVuc2lnbmVkQWNjb3VudHNcbiAgICAgIH0sXG4gICAgICByZWNlbnRCbG9ja2hhc2g6IGJzNTguZW5jb2RlKEJ1ZmZlci5mcm9tKHJlY2VudEJsb2NraGFzaCkpLFxuICAgICAgYWNjb3VudEtleXMsXG4gICAgICBpbnN0cnVjdGlvbnNcbiAgICB9O1xuICAgIHJldHVybiBuZXcgTWVzc2FnZShtZXNzYWdlQXJncyk7XG4gIH1cbn1cblxuLyoqXG4gKiBNZXNzYWdlIGNvbnN0cnVjdG9yIGFyZ3VtZW50c1xuICovXG5cbmNsYXNzIE1lc3NhZ2VWMCB7XG4gIGNvbnN0cnVjdG9yKGFyZ3MpIHtcbiAgICB0aGlzLmhlYWRlciA9IHZvaWQgMDtcbiAgICB0aGlzLnN0YXRpY0FjY291bnRLZXlzID0gdm9pZCAwO1xuICAgIHRoaXMucmVjZW50QmxvY2toYXNoID0gdm9pZCAwO1xuICAgIHRoaXMuY29tcGlsZWRJbnN0cnVjdGlvbnMgPSB2b2lkIDA7XG4gICAgdGhpcy5hZGRyZXNzVGFibGVMb29rdXBzID0gdm9pZCAwO1xuICAgIHRoaXMuaGVhZGVyID0gYXJncy5oZWFkZXI7XG4gICAgdGhpcy5zdGF0aWNBY2NvdW50S2V5cyA9IGFyZ3Muc3RhdGljQWNjb3VudEtleXM7XG4gICAgdGhpcy5yZWNlbnRCbG9ja2hhc2ggPSBhcmdzLnJlY2VudEJsb2NraGFzaDtcbiAgICB0aGlzLmNvbXBpbGVkSW5zdHJ1Y3Rpb25zID0gYXJncy5jb21waWxlZEluc3RydWN0aW9ucztcbiAgICB0aGlzLmFkZHJlc3NUYWJsZUxvb2t1cHMgPSBhcmdzLmFkZHJlc3NUYWJsZUxvb2t1cHM7XG4gIH1cbiAgZ2V0IHZlcnNpb24oKSB7XG4gICAgcmV0dXJuIDA7XG4gIH1cbiAgZ2V0IG51bUFjY291bnRLZXlzRnJvbUxvb2t1cHMoKSB7XG4gICAgbGV0IGNvdW50ID0gMDtcbiAgICBmb3IgKGNvbnN0IGxvb2t1cCBvZiB0aGlzLmFkZHJlc3NUYWJsZUxvb2t1cHMpIHtcbiAgICAgIGNvdW50ICs9IGxvb2t1cC5yZWFkb25seUluZGV4ZXMubGVuZ3RoICsgbG9va3VwLndyaXRhYmxlSW5kZXhlcy5sZW5ndGg7XG4gICAgfVxuICAgIHJldHVybiBjb3VudDtcbiAgfVxuICBnZXRBY2NvdW50S2V5cyhhcmdzKSB7XG4gICAgbGV0IGFjY291bnRLZXlzRnJvbUxvb2t1cHM7XG4gICAgaWYgKGFyZ3MgJiYgJ2FjY291bnRLZXlzRnJvbUxvb2t1cHMnIGluIGFyZ3MgJiYgYXJncy5hY2NvdW50S2V5c0Zyb21Mb29rdXBzKSB7XG4gICAgICBpZiAodGhpcy5udW1BY2NvdW50S2V5c0Zyb21Mb29rdXBzICE9IGFyZ3MuYWNjb3VudEtleXNGcm9tTG9va3Vwcy53cml0YWJsZS5sZW5ndGggKyBhcmdzLmFjY291bnRLZXlzRnJvbUxvb2t1cHMucmVhZG9ubHkubGVuZ3RoKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignRmFpbGVkIHRvIGdldCBhY2NvdW50IGtleXMgYmVjYXVzZSBvZiBhIG1pc21hdGNoIGluIHRoZSBudW1iZXIgb2YgYWNjb3VudCBrZXlzIGZyb20gbG9va3VwcycpO1xuICAgICAgfVxuICAgICAgYWNjb3VudEtleXNGcm9tTG9va3VwcyA9IGFyZ3MuYWNjb3VudEtleXNGcm9tTG9va3VwcztcbiAgICB9IGVsc2UgaWYgKGFyZ3MgJiYgJ2FkZHJlc3NMb29rdXBUYWJsZUFjY291bnRzJyBpbiBhcmdzICYmIGFyZ3MuYWRkcmVzc0xvb2t1cFRhYmxlQWNjb3VudHMpIHtcbiAgICAgIGFjY291bnRLZXlzRnJvbUxvb2t1cHMgPSB0aGlzLnJlc29sdmVBZGRyZXNzVGFibGVMb29rdXBzKGFyZ3MuYWRkcmVzc0xvb2t1cFRhYmxlQWNjb3VudHMpO1xuICAgIH0gZWxzZSBpZiAodGhpcy5hZGRyZXNzVGFibGVMb29rdXBzLmxlbmd0aCA+IDApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignRmFpbGVkIHRvIGdldCBhY2NvdW50IGtleXMgYmVjYXVzZSBhZGRyZXNzIHRhYmxlIGxvb2t1cHMgd2VyZSBub3QgcmVzb2x2ZWQnKTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBNZXNzYWdlQWNjb3VudEtleXModGhpcy5zdGF0aWNBY2NvdW50S2V5cywgYWNjb3VudEtleXNGcm9tTG9va3Vwcyk7XG4gIH1cbiAgaXNBY2NvdW50U2lnbmVyKGluZGV4KSB7XG4gICAgcmV0dXJuIGluZGV4IDwgdGhpcy5oZWFkZXIubnVtUmVxdWlyZWRTaWduYXR1cmVzO1xuICB9XG4gIGlzQWNjb3VudFdyaXRhYmxlKGluZGV4KSB7XG4gICAgY29uc3QgbnVtU2lnbmVkQWNjb3VudHMgPSB0aGlzLmhlYWRlci5udW1SZXF1aXJlZFNpZ25hdHVyZXM7XG4gICAgY29uc3QgbnVtU3RhdGljQWNjb3VudEtleXMgPSB0aGlzLnN0YXRpY0FjY291bnRLZXlzLmxlbmd0aDtcbiAgICBpZiAoaW5kZXggPj0gbnVtU3RhdGljQWNjb3VudEtleXMpIHtcbiAgICAgIGNvbnN0IGxvb2t1cEFjY291bnRLZXlzSW5kZXggPSBpbmRleCAtIG51bVN0YXRpY0FjY291bnRLZXlzO1xuICAgICAgY29uc3QgbnVtV3JpdGFibGVMb29rdXBBY2NvdW50S2V5cyA9IHRoaXMuYWRkcmVzc1RhYmxlTG9va3Vwcy5yZWR1Y2UoKGNvdW50LCBsb29rdXApID0+IGNvdW50ICsgbG9va3VwLndyaXRhYmxlSW5kZXhlcy5sZW5ndGgsIDApO1xuICAgICAgcmV0dXJuIGxvb2t1cEFjY291bnRLZXlzSW5kZXggPCBudW1Xcml0YWJsZUxvb2t1cEFjY291bnRLZXlzO1xuICAgIH0gZWxzZSBpZiAoaW5kZXggPj0gdGhpcy5oZWFkZXIubnVtUmVxdWlyZWRTaWduYXR1cmVzKSB7XG4gICAgICBjb25zdCB1bnNpZ25lZEFjY291bnRJbmRleCA9IGluZGV4IC0gbnVtU2lnbmVkQWNjb3VudHM7XG4gICAgICBjb25zdCBudW1VbnNpZ25lZEFjY291bnRzID0gbnVtU3RhdGljQWNjb3VudEtleXMgLSBudW1TaWduZWRBY2NvdW50cztcbiAgICAgIGNvbnN0IG51bVdyaXRhYmxlVW5zaWduZWRBY2NvdW50cyA9IG51bVVuc2lnbmVkQWNjb3VudHMgLSB0aGlzLmhlYWRlci5udW1SZWFkb25seVVuc2lnbmVkQWNjb3VudHM7XG4gICAgICByZXR1cm4gdW5zaWduZWRBY2NvdW50SW5kZXggPCBudW1Xcml0YWJsZVVuc2lnbmVkQWNjb3VudHM7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IG51bVdyaXRhYmxlU2lnbmVkQWNjb3VudHMgPSBudW1TaWduZWRBY2NvdW50cyAtIHRoaXMuaGVhZGVyLm51bVJlYWRvbmx5U2lnbmVkQWNjb3VudHM7XG4gICAgICByZXR1cm4gaW5kZXggPCBudW1Xcml0YWJsZVNpZ25lZEFjY291bnRzO1xuICAgIH1cbiAgfVxuICByZXNvbHZlQWRkcmVzc1RhYmxlTG9va3VwcyhhZGRyZXNzTG9va3VwVGFibGVBY2NvdW50cykge1xuICAgIGNvbnN0IGFjY291bnRLZXlzRnJvbUxvb2t1cHMgPSB7XG4gICAgICB3cml0YWJsZTogW10sXG4gICAgICByZWFkb25seTogW11cbiAgICB9O1xuICAgIGZvciAoY29uc3QgdGFibGVMb29rdXAgb2YgdGhpcy5hZGRyZXNzVGFibGVMb29rdXBzKSB7XG4gICAgICBjb25zdCB0YWJsZUFjY291bnQgPSBhZGRyZXNzTG9va3VwVGFibGVBY2NvdW50cy5maW5kKGFjY291bnQgPT4gYWNjb3VudC5rZXkuZXF1YWxzKHRhYmxlTG9va3VwLmFjY291bnRLZXkpKTtcbiAgICAgIGlmICghdGFibGVBY2NvdW50KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgRmFpbGVkIHRvIGZpbmQgYWRkcmVzcyBsb29rdXAgdGFibGUgYWNjb3VudCBmb3IgdGFibGUga2V5ICR7dGFibGVMb29rdXAuYWNjb3VudEtleS50b0Jhc2U1OCgpfWApO1xuICAgICAgfVxuICAgICAgZm9yIChjb25zdCBpbmRleCBvZiB0YWJsZUxvb2t1cC53cml0YWJsZUluZGV4ZXMpIHtcbiAgICAgICAgaWYgKGluZGV4IDwgdGFibGVBY2NvdW50LnN0YXRlLmFkZHJlc3Nlcy5sZW5ndGgpIHtcbiAgICAgICAgICBhY2NvdW50S2V5c0Zyb21Mb29rdXBzLndyaXRhYmxlLnB1c2godGFibGVBY2NvdW50LnN0YXRlLmFkZHJlc3Nlc1tpbmRleF0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgRmFpbGVkIHRvIGZpbmQgYWRkcmVzcyBmb3IgaW5kZXggJHtpbmRleH0gaW4gYWRkcmVzcyBsb29rdXAgdGFibGUgJHt0YWJsZUxvb2t1cC5hY2NvdW50S2V5LnRvQmFzZTU4KCl9YCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGZvciAoY29uc3QgaW5kZXggb2YgdGFibGVMb29rdXAucmVhZG9ubHlJbmRleGVzKSB7XG4gICAgICAgIGlmIChpbmRleCA8IHRhYmxlQWNjb3VudC5zdGF0ZS5hZGRyZXNzZXMubGVuZ3RoKSB7XG4gICAgICAgICAgYWNjb3VudEtleXNGcm9tTG9va3Vwcy5yZWFkb25seS5wdXNoKHRhYmxlQWNjb3VudC5zdGF0ZS5hZGRyZXNzZXNbaW5kZXhdKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEZhaWxlZCB0byBmaW5kIGFkZHJlc3MgZm9yIGluZGV4ICR7aW5kZXh9IGluIGFkZHJlc3MgbG9va3VwIHRhYmxlICR7dGFibGVMb29rdXAuYWNjb3VudEtleS50b0Jhc2U1OCgpfWApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBhY2NvdW50S2V5c0Zyb21Mb29rdXBzO1xuICB9XG4gIHN0YXRpYyBjb21waWxlKGFyZ3MpIHtcbiAgICBjb25zdCBjb21waWxlZEtleXMgPSBDb21waWxlZEtleXMuY29tcGlsZShhcmdzLmluc3RydWN0aW9ucywgYXJncy5wYXllcktleSk7XG4gICAgY29uc3QgYWRkcmVzc1RhYmxlTG9va3VwcyA9IG5ldyBBcnJheSgpO1xuICAgIGNvbnN0IGFjY291bnRLZXlzRnJvbUxvb2t1cHMgPSB7XG4gICAgICB3cml0YWJsZTogbmV3IEFycmF5KCksXG4gICAgICByZWFkb25seTogbmV3IEFycmF5KClcbiAgICB9O1xuICAgIGNvbnN0IGxvb2t1cFRhYmxlQWNjb3VudHMgPSBhcmdzLmFkZHJlc3NMb29rdXBUYWJsZUFjY291bnRzIHx8IFtdO1xuICAgIGZvciAoY29uc3QgbG9va3VwVGFibGUgb2YgbG9va3VwVGFibGVBY2NvdW50cykge1xuICAgICAgY29uc3QgZXh0cmFjdFJlc3VsdCA9IGNvbXBpbGVkS2V5cy5leHRyYWN0VGFibGVMb29rdXAobG9va3VwVGFibGUpO1xuICAgICAgaWYgKGV4dHJhY3RSZXN1bHQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBjb25zdCBbYWRkcmVzc1RhYmxlTG9va3VwLCB7XG4gICAgICAgICAgd3JpdGFibGUsXG4gICAgICAgICAgcmVhZG9ubHlcbiAgICAgICAgfV0gPSBleHRyYWN0UmVzdWx0O1xuICAgICAgICBhZGRyZXNzVGFibGVMb29rdXBzLnB1c2goYWRkcmVzc1RhYmxlTG9va3VwKTtcbiAgICAgICAgYWNjb3VudEtleXNGcm9tTG9va3Vwcy53cml0YWJsZS5wdXNoKC4uLndyaXRhYmxlKTtcbiAgICAgICAgYWNjb3VudEtleXNGcm9tTG9va3Vwcy5yZWFkb25seS5wdXNoKC4uLnJlYWRvbmx5KTtcbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgW2hlYWRlciwgc3RhdGljQWNjb3VudEtleXNdID0gY29tcGlsZWRLZXlzLmdldE1lc3NhZ2VDb21wb25lbnRzKCk7XG4gICAgY29uc3QgYWNjb3VudEtleXMgPSBuZXcgTWVzc2FnZUFjY291bnRLZXlzKHN0YXRpY0FjY291bnRLZXlzLCBhY2NvdW50S2V5c0Zyb21Mb29rdXBzKTtcbiAgICBjb25zdCBjb21waWxlZEluc3RydWN0aW9ucyA9IGFjY291bnRLZXlzLmNvbXBpbGVJbnN0cnVjdGlvbnMoYXJncy5pbnN0cnVjdGlvbnMpO1xuICAgIHJldHVybiBuZXcgTWVzc2FnZVYwKHtcbiAgICAgIGhlYWRlcixcbiAgICAgIHN0YXRpY0FjY291bnRLZXlzLFxuICAgICAgcmVjZW50QmxvY2toYXNoOiBhcmdzLnJlY2VudEJsb2NraGFzaCxcbiAgICAgIGNvbXBpbGVkSW5zdHJ1Y3Rpb25zLFxuICAgICAgYWRkcmVzc1RhYmxlTG9va3Vwc1xuICAgIH0pO1xuICB9XG4gIHNlcmlhbGl6ZSgpIHtcbiAgICBjb25zdCBlbmNvZGVkU3RhdGljQWNjb3VudEtleXNMZW5ndGggPSBBcnJheSgpO1xuICAgIGVuY29kZUxlbmd0aChlbmNvZGVkU3RhdGljQWNjb3VudEtleXNMZW5ndGgsIHRoaXMuc3RhdGljQWNjb3VudEtleXMubGVuZ3RoKTtcbiAgICBjb25zdCBzZXJpYWxpemVkSW5zdHJ1Y3Rpb25zID0gdGhpcy5zZXJpYWxpemVJbnN0cnVjdGlvbnMoKTtcbiAgICBjb25zdCBlbmNvZGVkSW5zdHJ1Y3Rpb25zTGVuZ3RoID0gQXJyYXkoKTtcbiAgICBlbmNvZGVMZW5ndGgoZW5jb2RlZEluc3RydWN0aW9uc0xlbmd0aCwgdGhpcy5jb21waWxlZEluc3RydWN0aW9ucy5sZW5ndGgpO1xuICAgIGNvbnN0IHNlcmlhbGl6ZWRBZGRyZXNzVGFibGVMb29rdXBzID0gdGhpcy5zZXJpYWxpemVBZGRyZXNzVGFibGVMb29rdXBzKCk7XG4gICAgY29uc3QgZW5jb2RlZEFkZHJlc3NUYWJsZUxvb2t1cHNMZW5ndGggPSBBcnJheSgpO1xuICAgIGVuY29kZUxlbmd0aChlbmNvZGVkQWRkcmVzc1RhYmxlTG9va3Vwc0xlbmd0aCwgdGhpcy5hZGRyZXNzVGFibGVMb29rdXBzLmxlbmd0aCk7XG4gICAgY29uc3QgbWVzc2FnZUxheW91dCA9IEJ1ZmZlckxheW91dC5zdHJ1Y3QoW0J1ZmZlckxheW91dC51OCgncHJlZml4JyksIEJ1ZmZlckxheW91dC5zdHJ1Y3QoW0J1ZmZlckxheW91dC51OCgnbnVtUmVxdWlyZWRTaWduYXR1cmVzJyksIEJ1ZmZlckxheW91dC51OCgnbnVtUmVhZG9ubHlTaWduZWRBY2NvdW50cycpLCBCdWZmZXJMYXlvdXQudTgoJ251bVJlYWRvbmx5VW5zaWduZWRBY2NvdW50cycpXSwgJ2hlYWRlcicpLCBCdWZmZXJMYXlvdXQuYmxvYihlbmNvZGVkU3RhdGljQWNjb3VudEtleXNMZW5ndGgubGVuZ3RoLCAnc3RhdGljQWNjb3VudEtleXNMZW5ndGgnKSwgQnVmZmVyTGF5b3V0LnNlcShwdWJsaWNLZXkoKSwgdGhpcy5zdGF0aWNBY2NvdW50S2V5cy5sZW5ndGgsICdzdGF0aWNBY2NvdW50S2V5cycpLCBwdWJsaWNLZXkoJ3JlY2VudEJsb2NraGFzaCcpLCBCdWZmZXJMYXlvdXQuYmxvYihlbmNvZGVkSW5zdHJ1Y3Rpb25zTGVuZ3RoLmxlbmd0aCwgJ2luc3RydWN0aW9uc0xlbmd0aCcpLCBCdWZmZXJMYXlvdXQuYmxvYihzZXJpYWxpemVkSW5zdHJ1Y3Rpb25zLmxlbmd0aCwgJ3NlcmlhbGl6ZWRJbnN0cnVjdGlvbnMnKSwgQnVmZmVyTGF5b3V0LmJsb2IoZW5jb2RlZEFkZHJlc3NUYWJsZUxvb2t1cHNMZW5ndGgubGVuZ3RoLCAnYWRkcmVzc1RhYmxlTG9va3Vwc0xlbmd0aCcpLCBCdWZmZXJMYXlvdXQuYmxvYihzZXJpYWxpemVkQWRkcmVzc1RhYmxlTG9va3Vwcy5sZW5ndGgsICdzZXJpYWxpemVkQWRkcmVzc1RhYmxlTG9va3VwcycpXSk7XG4gICAgY29uc3Qgc2VyaWFsaXplZE1lc3NhZ2UgPSBuZXcgVWludDhBcnJheShQQUNLRVRfREFUQV9TSVpFKTtcbiAgICBjb25zdCBNRVNTQUdFX1ZFUlNJT05fMF9QUkVGSVggPSAxIDw8IDc7XG4gICAgY29uc3Qgc2VyaWFsaXplZE1lc3NhZ2VMZW5ndGggPSBtZXNzYWdlTGF5b3V0LmVuY29kZSh7XG4gICAgICBwcmVmaXg6IE1FU1NBR0VfVkVSU0lPTl8wX1BSRUZJWCxcbiAgICAgIGhlYWRlcjogdGhpcy5oZWFkZXIsXG4gICAgICBzdGF0aWNBY2NvdW50S2V5c0xlbmd0aDogbmV3IFVpbnQ4QXJyYXkoZW5jb2RlZFN0YXRpY0FjY291bnRLZXlzTGVuZ3RoKSxcbiAgICAgIHN0YXRpY0FjY291bnRLZXlzOiB0aGlzLnN0YXRpY0FjY291bnRLZXlzLm1hcChrZXkgPT4ga2V5LnRvQnl0ZXMoKSksXG4gICAgICByZWNlbnRCbG9ja2hhc2g6IGJzNTguZGVjb2RlKHRoaXMucmVjZW50QmxvY2toYXNoKSxcbiAgICAgIGluc3RydWN0aW9uc0xlbmd0aDogbmV3IFVpbnQ4QXJyYXkoZW5jb2RlZEluc3RydWN0aW9uc0xlbmd0aCksXG4gICAgICBzZXJpYWxpemVkSW5zdHJ1Y3Rpb25zLFxuICAgICAgYWRkcmVzc1RhYmxlTG9va3Vwc0xlbmd0aDogbmV3IFVpbnQ4QXJyYXkoZW5jb2RlZEFkZHJlc3NUYWJsZUxvb2t1cHNMZW5ndGgpLFxuICAgICAgc2VyaWFsaXplZEFkZHJlc3NUYWJsZUxvb2t1cHNcbiAgICB9LCBzZXJpYWxpemVkTWVzc2FnZSk7XG4gICAgcmV0dXJuIHNlcmlhbGl6ZWRNZXNzYWdlLnNsaWNlKDAsIHNlcmlhbGl6ZWRNZXNzYWdlTGVuZ3RoKTtcbiAgfVxuICBzZXJpYWxpemVJbnN0cnVjdGlvbnMoKSB7XG4gICAgbGV0IHNlcmlhbGl6ZWRMZW5ndGggPSAwO1xuICAgIGNvbnN0IHNlcmlhbGl6ZWRJbnN0cnVjdGlvbnMgPSBuZXcgVWludDhBcnJheShQQUNLRVRfREFUQV9TSVpFKTtcbiAgICBmb3IgKGNvbnN0IGluc3RydWN0aW9uIG9mIHRoaXMuY29tcGlsZWRJbnN0cnVjdGlvbnMpIHtcbiAgICAgIGNvbnN0IGVuY29kZWRBY2NvdW50S2V5SW5kZXhlc0xlbmd0aCA9IEFycmF5KCk7XG4gICAgICBlbmNvZGVMZW5ndGgoZW5jb2RlZEFjY291bnRLZXlJbmRleGVzTGVuZ3RoLCBpbnN0cnVjdGlvbi5hY2NvdW50S2V5SW5kZXhlcy5sZW5ndGgpO1xuICAgICAgY29uc3QgZW5jb2RlZERhdGFMZW5ndGggPSBBcnJheSgpO1xuICAgICAgZW5jb2RlTGVuZ3RoKGVuY29kZWREYXRhTGVuZ3RoLCBpbnN0cnVjdGlvbi5kYXRhLmxlbmd0aCk7XG4gICAgICBjb25zdCBpbnN0cnVjdGlvbkxheW91dCA9IEJ1ZmZlckxheW91dC5zdHJ1Y3QoW0J1ZmZlckxheW91dC51OCgncHJvZ3JhbUlkSW5kZXgnKSwgQnVmZmVyTGF5b3V0LmJsb2IoZW5jb2RlZEFjY291bnRLZXlJbmRleGVzTGVuZ3RoLmxlbmd0aCwgJ2VuY29kZWRBY2NvdW50S2V5SW5kZXhlc0xlbmd0aCcpLCBCdWZmZXJMYXlvdXQuc2VxKEJ1ZmZlckxheW91dC51OCgpLCBpbnN0cnVjdGlvbi5hY2NvdW50S2V5SW5kZXhlcy5sZW5ndGgsICdhY2NvdW50S2V5SW5kZXhlcycpLCBCdWZmZXJMYXlvdXQuYmxvYihlbmNvZGVkRGF0YUxlbmd0aC5sZW5ndGgsICdlbmNvZGVkRGF0YUxlbmd0aCcpLCBCdWZmZXJMYXlvdXQuYmxvYihpbnN0cnVjdGlvbi5kYXRhLmxlbmd0aCwgJ2RhdGEnKV0pO1xuICAgICAgc2VyaWFsaXplZExlbmd0aCArPSBpbnN0cnVjdGlvbkxheW91dC5lbmNvZGUoe1xuICAgICAgICBwcm9ncmFtSWRJbmRleDogaW5zdHJ1Y3Rpb24ucHJvZ3JhbUlkSW5kZXgsXG4gICAgICAgIGVuY29kZWRBY2NvdW50S2V5SW5kZXhlc0xlbmd0aDogbmV3IFVpbnQ4QXJyYXkoZW5jb2RlZEFjY291bnRLZXlJbmRleGVzTGVuZ3RoKSxcbiAgICAgICAgYWNjb3VudEtleUluZGV4ZXM6IGluc3RydWN0aW9uLmFjY291bnRLZXlJbmRleGVzLFxuICAgICAgICBlbmNvZGVkRGF0YUxlbmd0aDogbmV3IFVpbnQ4QXJyYXkoZW5jb2RlZERhdGFMZW5ndGgpLFxuICAgICAgICBkYXRhOiBpbnN0cnVjdGlvbi5kYXRhXG4gICAgICB9LCBzZXJpYWxpemVkSW5zdHJ1Y3Rpb25zLCBzZXJpYWxpemVkTGVuZ3RoKTtcbiAgICB9XG4gICAgcmV0dXJuIHNlcmlhbGl6ZWRJbnN0cnVjdGlvbnMuc2xpY2UoMCwgc2VyaWFsaXplZExlbmd0aCk7XG4gIH1cbiAgc2VyaWFsaXplQWRkcmVzc1RhYmxlTG9va3VwcygpIHtcbiAgICBsZXQgc2VyaWFsaXplZExlbmd0aCA9IDA7XG4gICAgY29uc3Qgc2VyaWFsaXplZEFkZHJlc3NUYWJsZUxvb2t1cHMgPSBuZXcgVWludDhBcnJheShQQUNLRVRfREFUQV9TSVpFKTtcbiAgICBmb3IgKGNvbnN0IGxvb2t1cCBvZiB0aGlzLmFkZHJlc3NUYWJsZUxvb2t1cHMpIHtcbiAgICAgIGNvbnN0IGVuY29kZWRXcml0YWJsZUluZGV4ZXNMZW5ndGggPSBBcnJheSgpO1xuICAgICAgZW5jb2RlTGVuZ3RoKGVuY29kZWRXcml0YWJsZUluZGV4ZXNMZW5ndGgsIGxvb2t1cC53cml0YWJsZUluZGV4ZXMubGVuZ3RoKTtcbiAgICAgIGNvbnN0IGVuY29kZWRSZWFkb25seUluZGV4ZXNMZW5ndGggPSBBcnJheSgpO1xuICAgICAgZW5jb2RlTGVuZ3RoKGVuY29kZWRSZWFkb25seUluZGV4ZXNMZW5ndGgsIGxvb2t1cC5yZWFkb25seUluZGV4ZXMubGVuZ3RoKTtcbiAgICAgIGNvbnN0IGFkZHJlc3NUYWJsZUxvb2t1cExheW91dCA9IEJ1ZmZlckxheW91dC5zdHJ1Y3QoW3B1YmxpY0tleSgnYWNjb3VudEtleScpLCBCdWZmZXJMYXlvdXQuYmxvYihlbmNvZGVkV3JpdGFibGVJbmRleGVzTGVuZ3RoLmxlbmd0aCwgJ2VuY29kZWRXcml0YWJsZUluZGV4ZXNMZW5ndGgnKSwgQnVmZmVyTGF5b3V0LnNlcShCdWZmZXJMYXlvdXQudTgoKSwgbG9va3VwLndyaXRhYmxlSW5kZXhlcy5sZW5ndGgsICd3cml0YWJsZUluZGV4ZXMnKSwgQnVmZmVyTGF5b3V0LmJsb2IoZW5jb2RlZFJlYWRvbmx5SW5kZXhlc0xlbmd0aC5sZW5ndGgsICdlbmNvZGVkUmVhZG9ubHlJbmRleGVzTGVuZ3RoJyksIEJ1ZmZlckxheW91dC5zZXEoQnVmZmVyTGF5b3V0LnU4KCksIGxvb2t1cC5yZWFkb25seUluZGV4ZXMubGVuZ3RoLCAncmVhZG9ubHlJbmRleGVzJyldKTtcbiAgICAgIHNlcmlhbGl6ZWRMZW5ndGggKz0gYWRkcmVzc1RhYmxlTG9va3VwTGF5b3V0LmVuY29kZSh7XG4gICAgICAgIGFjY291bnRLZXk6IGxvb2t1cC5hY2NvdW50S2V5LnRvQnl0ZXMoKSxcbiAgICAgICAgZW5jb2RlZFdyaXRhYmxlSW5kZXhlc0xlbmd0aDogbmV3IFVpbnQ4QXJyYXkoZW5jb2RlZFdyaXRhYmxlSW5kZXhlc0xlbmd0aCksXG4gICAgICAgIHdyaXRhYmxlSW5kZXhlczogbG9va3VwLndyaXRhYmxlSW5kZXhlcyxcbiAgICAgICAgZW5jb2RlZFJlYWRvbmx5SW5kZXhlc0xlbmd0aDogbmV3IFVpbnQ4QXJyYXkoZW5jb2RlZFJlYWRvbmx5SW5kZXhlc0xlbmd0aCksXG4gICAgICAgIHJlYWRvbmx5SW5kZXhlczogbG9va3VwLnJlYWRvbmx5SW5kZXhlc1xuICAgICAgfSwgc2VyaWFsaXplZEFkZHJlc3NUYWJsZUxvb2t1cHMsIHNlcmlhbGl6ZWRMZW5ndGgpO1xuICAgIH1cbiAgICByZXR1cm4gc2VyaWFsaXplZEFkZHJlc3NUYWJsZUxvb2t1cHMuc2xpY2UoMCwgc2VyaWFsaXplZExlbmd0aCk7XG4gIH1cbiAgc3RhdGljIGRlc2VyaWFsaXplKHNlcmlhbGl6ZWRNZXNzYWdlKSB7XG4gICAgbGV0IGJ5dGVBcnJheSA9IFsuLi5zZXJpYWxpemVkTWVzc2FnZV07XG4gICAgY29uc3QgcHJlZml4ID0gZ3VhcmRlZFNoaWZ0KGJ5dGVBcnJheSk7XG4gICAgY29uc3QgbWFza2VkUHJlZml4ID0gcHJlZml4ICYgVkVSU0lPTl9QUkVGSVhfTUFTSztcbiAgICBhc3NlcnQocHJlZml4ICE9PSBtYXNrZWRQcmVmaXgsIGBFeHBlY3RlZCB2ZXJzaW9uZWQgbWVzc2FnZSBidXQgcmVjZWl2ZWQgbGVnYWN5IG1lc3NhZ2VgKTtcbiAgICBjb25zdCB2ZXJzaW9uID0gbWFza2VkUHJlZml4O1xuICAgIGFzc2VydCh2ZXJzaW9uID09PSAwLCBgRXhwZWN0ZWQgdmVyc2lvbmVkIG1lc3NhZ2Ugd2l0aCB2ZXJzaW9uIDAgYnV0IGZvdW5kIHZlcnNpb24gJHt2ZXJzaW9ufWApO1xuICAgIGNvbnN0IGhlYWRlciA9IHtcbiAgICAgIG51bVJlcXVpcmVkU2lnbmF0dXJlczogZ3VhcmRlZFNoaWZ0KGJ5dGVBcnJheSksXG4gICAgICBudW1SZWFkb25seVNpZ25lZEFjY291bnRzOiBndWFyZGVkU2hpZnQoYnl0ZUFycmF5KSxcbiAgICAgIG51bVJlYWRvbmx5VW5zaWduZWRBY2NvdW50czogZ3VhcmRlZFNoaWZ0KGJ5dGVBcnJheSlcbiAgICB9O1xuICAgIGNvbnN0IHN0YXRpY0FjY291bnRLZXlzID0gW107XG4gICAgY29uc3Qgc3RhdGljQWNjb3VudEtleXNMZW5ndGggPSBkZWNvZGVMZW5ndGgoYnl0ZUFycmF5KTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHN0YXRpY0FjY291bnRLZXlzTGVuZ3RoOyBpKyspIHtcbiAgICAgIHN0YXRpY0FjY291bnRLZXlzLnB1c2gobmV3IFB1YmxpY0tleShndWFyZGVkU3BsaWNlKGJ5dGVBcnJheSwgMCwgUFVCTElDX0tFWV9MRU5HVEgpKSk7XG4gICAgfVxuICAgIGNvbnN0IHJlY2VudEJsb2NraGFzaCA9IGJzNTguZW5jb2RlKGd1YXJkZWRTcGxpY2UoYnl0ZUFycmF5LCAwLCBQVUJMSUNfS0VZX0xFTkdUSCkpO1xuICAgIGNvbnN0IGluc3RydWN0aW9uQ291bnQgPSBkZWNvZGVMZW5ndGgoYnl0ZUFycmF5KTtcbiAgICBjb25zdCBjb21waWxlZEluc3RydWN0aW9ucyA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaW5zdHJ1Y3Rpb25Db3VudDsgaSsrKSB7XG4gICAgICBjb25zdCBwcm9ncmFtSWRJbmRleCA9IGd1YXJkZWRTaGlmdChieXRlQXJyYXkpO1xuICAgICAgY29uc3QgYWNjb3VudEtleUluZGV4ZXNMZW5ndGggPSBkZWNvZGVMZW5ndGgoYnl0ZUFycmF5KTtcbiAgICAgIGNvbnN0IGFjY291bnRLZXlJbmRleGVzID0gZ3VhcmRlZFNwbGljZShieXRlQXJyYXksIDAsIGFjY291bnRLZXlJbmRleGVzTGVuZ3RoKTtcbiAgICAgIGNvbnN0IGRhdGFMZW5ndGggPSBkZWNvZGVMZW5ndGgoYnl0ZUFycmF5KTtcbiAgICAgIGNvbnN0IGRhdGEgPSBuZXcgVWludDhBcnJheShndWFyZGVkU3BsaWNlKGJ5dGVBcnJheSwgMCwgZGF0YUxlbmd0aCkpO1xuICAgICAgY29tcGlsZWRJbnN0cnVjdGlvbnMucHVzaCh7XG4gICAgICAgIHByb2dyYW1JZEluZGV4LFxuICAgICAgICBhY2NvdW50S2V5SW5kZXhlcyxcbiAgICAgICAgZGF0YVxuICAgICAgfSk7XG4gICAgfVxuICAgIGNvbnN0IGFkZHJlc3NUYWJsZUxvb2t1cHNDb3VudCA9IGRlY29kZUxlbmd0aChieXRlQXJyYXkpO1xuICAgIGNvbnN0IGFkZHJlc3NUYWJsZUxvb2t1cHMgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGFkZHJlc3NUYWJsZUxvb2t1cHNDb3VudDsgaSsrKSB7XG4gICAgICBjb25zdCBhY2NvdW50S2V5ID0gbmV3IFB1YmxpY0tleShndWFyZGVkU3BsaWNlKGJ5dGVBcnJheSwgMCwgUFVCTElDX0tFWV9MRU5HVEgpKTtcbiAgICAgIGNvbnN0IHdyaXRhYmxlSW5kZXhlc0xlbmd0aCA9IGRlY29kZUxlbmd0aChieXRlQXJyYXkpO1xuICAgICAgY29uc3Qgd3JpdGFibGVJbmRleGVzID0gZ3VhcmRlZFNwbGljZShieXRlQXJyYXksIDAsIHdyaXRhYmxlSW5kZXhlc0xlbmd0aCk7XG4gICAgICBjb25zdCByZWFkb25seUluZGV4ZXNMZW5ndGggPSBkZWNvZGVMZW5ndGgoYnl0ZUFycmF5KTtcbiAgICAgIGNvbnN0IHJlYWRvbmx5SW5kZXhlcyA9IGd1YXJkZWRTcGxpY2UoYnl0ZUFycmF5LCAwLCByZWFkb25seUluZGV4ZXNMZW5ndGgpO1xuICAgICAgYWRkcmVzc1RhYmxlTG9va3Vwcy5wdXNoKHtcbiAgICAgICAgYWNjb3VudEtleSxcbiAgICAgICAgd3JpdGFibGVJbmRleGVzLFxuICAgICAgICByZWFkb25seUluZGV4ZXNcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IE1lc3NhZ2VWMCh7XG4gICAgICBoZWFkZXIsXG4gICAgICBzdGF0aWNBY2NvdW50S2V5cyxcbiAgICAgIHJlY2VudEJsb2NraGFzaCxcbiAgICAgIGNvbXBpbGVkSW5zdHJ1Y3Rpb25zLFxuICAgICAgYWRkcmVzc1RhYmxlTG9va3Vwc1xuICAgIH0pO1xuICB9XG59XG5cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1yZWRlY2xhcmVcbmNvbnN0IFZlcnNpb25lZE1lc3NhZ2UgPSB7XG4gIGRlc2VyaWFsaXplTWVzc2FnZVZlcnNpb24oc2VyaWFsaXplZE1lc3NhZ2UpIHtcbiAgICBjb25zdCBwcmVmaXggPSBzZXJpYWxpemVkTWVzc2FnZVswXTtcbiAgICBjb25zdCBtYXNrZWRQcmVmaXggPSBwcmVmaXggJiBWRVJTSU9OX1BSRUZJWF9NQVNLO1xuXG4gICAgLy8gaWYgdGhlIGhpZ2hlc3QgYml0IG9mIHRoZSBwcmVmaXggaXMgbm90IHNldCwgdGhlIG1lc3NhZ2UgaXMgbm90IHZlcnNpb25lZFxuICAgIGlmIChtYXNrZWRQcmVmaXggPT09IHByZWZpeCkge1xuICAgICAgcmV0dXJuICdsZWdhY3knO1xuICAgIH1cblxuICAgIC8vIHRoZSBsb3dlciA3IGJpdHMgb2YgdGhlIHByZWZpeCBpbmRpY2F0ZSB0aGUgbWVzc2FnZSB2ZXJzaW9uXG4gICAgcmV0dXJuIG1hc2tlZFByZWZpeDtcbiAgfSxcbiAgZGVzZXJpYWxpemU6IHNlcmlhbGl6ZWRNZXNzYWdlID0+IHtcbiAgICBjb25zdCB2ZXJzaW9uID0gVmVyc2lvbmVkTWVzc2FnZS5kZXNlcmlhbGl6ZU1lc3NhZ2VWZXJzaW9uKHNlcmlhbGl6ZWRNZXNzYWdlKTtcbiAgICBpZiAodmVyc2lvbiA9PT0gJ2xlZ2FjeScpIHtcbiAgICAgIHJldHVybiBNZXNzYWdlLmZyb20oc2VyaWFsaXplZE1lc3NhZ2UpO1xuICAgIH1cbiAgICBpZiAodmVyc2lvbiA9PT0gMCkge1xuICAgICAgcmV0dXJuIE1lc3NhZ2VWMC5kZXNlcmlhbGl6ZShzZXJpYWxpemVkTWVzc2FnZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgVHJhbnNhY3Rpb24gbWVzc2FnZSB2ZXJzaW9uICR7dmVyc2lvbn0gZGVzZXJpYWxpemF0aW9uIGlzIG5vdCBzdXBwb3J0ZWRgKTtcbiAgICB9XG4gIH1cbn07XG5cbi8qKiBAaW50ZXJuYWwgKi9cblxuLyoqXG4gKiBUcmFuc2FjdGlvbiBzaWduYXR1cmUgYXMgYmFzZS01OCBlbmNvZGVkIHN0cmluZ1xuICovXG5cbmxldCBUcmFuc2FjdGlvblN0YXR1cyA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoVHJhbnNhY3Rpb25TdGF0dXMpIHtcbiAgVHJhbnNhY3Rpb25TdGF0dXNbVHJhbnNhY3Rpb25TdGF0dXNbXCJCTE9DS0hFSUdIVF9FWENFRURFRFwiXSA9IDBdID0gXCJCTE9DS0hFSUdIVF9FWENFRURFRFwiO1xuICBUcmFuc2FjdGlvblN0YXR1c1tUcmFuc2FjdGlvblN0YXR1c1tcIlBST0NFU1NFRFwiXSA9IDFdID0gXCJQUk9DRVNTRURcIjtcbiAgVHJhbnNhY3Rpb25TdGF0dXNbVHJhbnNhY3Rpb25TdGF0dXNbXCJUSU1FRF9PVVRcIl0gPSAyXSA9IFwiVElNRURfT1VUXCI7XG4gIFRyYW5zYWN0aW9uU3RhdHVzW1RyYW5zYWN0aW9uU3RhdHVzW1wiTk9OQ0VfSU5WQUxJRFwiXSA9IDNdID0gXCJOT05DRV9JTlZBTElEXCI7XG4gIHJldHVybiBUcmFuc2FjdGlvblN0YXR1cztcbn0oe30pO1xuXG4vKipcbiAqIERlZmF1bHQgKGVtcHR5KSBzaWduYXR1cmVcbiAqL1xuY29uc3QgREVGQVVMVF9TSUdOQVRVUkUgPSBCdWZmZXIuYWxsb2MoU0lHTkFUVVJFX0xFTkdUSF9JTl9CWVRFUykuZmlsbCgwKTtcblxuLyoqXG4gKiBBY2NvdW50IG1ldGFkYXRhIHVzZWQgdG8gZGVmaW5lIGluc3RydWN0aW9uc1xuICovXG5cbi8qKlxuICogTGlzdCBvZiBUcmFuc2FjdGlvbkluc3RydWN0aW9uIG9iamVjdCBmaWVsZHMgdGhhdCBtYXkgYmUgaW5pdGlhbGl6ZWQgYXQgY29uc3RydWN0aW9uXG4gKi9cblxuLyoqXG4gKiBDb25maWd1cmF0aW9uIG9iamVjdCBmb3IgVHJhbnNhY3Rpb24uc2VyaWFsaXplKClcbiAqL1xuXG4vKipcbiAqIEBpbnRlcm5hbFxuICovXG5cbi8qKlxuICogVHJhbnNhY3Rpb24gSW5zdHJ1Y3Rpb24gY2xhc3NcbiAqL1xuY2xhc3MgVHJhbnNhY3Rpb25JbnN0cnVjdGlvbiB7XG4gIGNvbnN0cnVjdG9yKG9wdHMpIHtcbiAgICAvKipcbiAgICAgKiBQdWJsaWMga2V5cyB0byBpbmNsdWRlIGluIHRoaXMgdHJhbnNhY3Rpb25cbiAgICAgKiBCb29sZWFuIHJlcHJlc2VudHMgd2hldGhlciB0aGlzIHB1YmtleSBuZWVkcyB0byBzaWduIHRoZSB0cmFuc2FjdGlvblxuICAgICAqL1xuICAgIHRoaXMua2V5cyA9IHZvaWQgMDtcbiAgICAvKipcbiAgICAgKiBQcm9ncmFtIElkIHRvIGV4ZWN1dGVcbiAgICAgKi9cbiAgICB0aGlzLnByb2dyYW1JZCA9IHZvaWQgMDtcbiAgICAvKipcbiAgICAgKiBQcm9ncmFtIGlucHV0XG4gICAgICovXG4gICAgdGhpcy5kYXRhID0gQnVmZmVyLmFsbG9jKDApO1xuICAgIHRoaXMucHJvZ3JhbUlkID0gb3B0cy5wcm9ncmFtSWQ7XG4gICAgdGhpcy5rZXlzID0gb3B0cy5rZXlzO1xuICAgIGlmIChvcHRzLmRhdGEpIHtcbiAgICAgIHRoaXMuZGF0YSA9IG9wdHMuZGF0YTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQGludGVybmFsXG4gICAqL1xuICB0b0pTT04oKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGtleXM6IHRoaXMua2V5cy5tYXAoKHtcbiAgICAgICAgcHVia2V5LFxuICAgICAgICBpc1NpZ25lcixcbiAgICAgICAgaXNXcml0YWJsZVxuICAgICAgfSkgPT4gKHtcbiAgICAgICAgcHVia2V5OiBwdWJrZXkudG9KU09OKCksXG4gICAgICAgIGlzU2lnbmVyLFxuICAgICAgICBpc1dyaXRhYmxlXG4gICAgICB9KSksXG4gICAgICBwcm9ncmFtSWQ6IHRoaXMucHJvZ3JhbUlkLnRvSlNPTigpLFxuICAgICAgZGF0YTogWy4uLnRoaXMuZGF0YV1cbiAgICB9O1xuICB9XG59XG5cbi8qKlxuICogUGFpciBvZiBzaWduYXR1cmUgYW5kIGNvcnJlc3BvbmRpbmcgcHVibGljIGtleVxuICovXG5cbi8qKlxuICogTGlzdCBvZiBUcmFuc2FjdGlvbiBvYmplY3QgZmllbGRzIHRoYXQgbWF5IGJlIGluaXRpYWxpemVkIGF0IGNvbnN0cnVjdGlvblxuICovXG5cbi8vIEZvciBiYWNrd2FyZCBjb21wYXRpYmlsaXR5OyBhbiB1bmZvcnR1bmF0ZSBjb25zZXF1ZW5jZSBvZiBiZWluZ1xuLy8gZm9yY2VkIHRvIG92ZXItZXhwb3J0IHR5cGVzIGJ5IHRoZSBkb2N1bWVudGF0aW9uIGdlbmVyYXRvci5cbi8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vc29sYW5hLWxhYnMvc29sYW5hL3B1bGwvMjU4MjBcblxuLyoqXG4gKiBCbG9ja2hhc2gtYmFzZWQgdHJhbnNhY3Rpb25zIGhhdmUgYSBsaWZldGltZSB0aGF0IGFyZSBkZWZpbmVkIGJ5XG4gKiB0aGUgYmxvY2toYXNoIHRoZXkgaW5jbHVkZS4gQW55IHRyYW5zYWN0aW9uIHdob3NlIGJsb2NraGFzaCBpc1xuICogdG9vIG9sZCB3aWxsIGJlIHJlamVjdGVkLlxuICovXG5cbi8qKlxuICogVXNlIHRoZXNlIG9wdGlvbnMgdG8gY29uc3RydWN0IGEgZHVyYWJsZSBub25jZSB0cmFuc2FjdGlvbi5cbiAqL1xuXG4vKipcbiAqIE5vbmNlIGluZm9ybWF0aW9uIHRvIGJlIHVzZWQgdG8gYnVpbGQgYW4gb2ZmbGluZSBUcmFuc2FjdGlvbi5cbiAqL1xuXG4vKipcbiAqIEBpbnRlcm5hbFxuICovXG5cbi8qKlxuICogVHJhbnNhY3Rpb24gY2xhc3NcbiAqL1xuY2xhc3MgVHJhbnNhY3Rpb24ge1xuICAvKipcbiAgICogVGhlIGZpcnN0IChwYXllcikgVHJhbnNhY3Rpb24gc2lnbmF0dXJlXG4gICAqXG4gICAqIEByZXR1cm5zIHtCdWZmZXIgfCBudWxsfSBCdWZmZXIgb2YgcGF5ZXIncyBzaWduYXR1cmVcbiAgICovXG4gIGdldCBzaWduYXR1cmUoKSB7XG4gICAgaWYgKHRoaXMuc2lnbmF0dXJlcy5sZW5ndGggPiAwKSB7XG4gICAgICByZXR1cm4gdGhpcy5zaWduYXR1cmVzWzBdLnNpZ25hdHVyZTtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICAvKipcbiAgICogVGhlIHRyYW5zYWN0aW9uIGZlZSBwYXllclxuICAgKi9cblxuICAvLyBDb25zdHJ1Y3QgYSB0cmFuc2FjdGlvbiB3aXRoIGEgYmxvY2toYXNoIGFuZCBsYXN0VmFsaWRCbG9ja0hlaWdodFxuXG4gIC8vIENvbnN0cnVjdCBhIHRyYW5zYWN0aW9uIHVzaW5nIGEgZHVyYWJsZSBub25jZVxuXG4gIC8qKlxuICAgKiBAZGVwcmVjYXRlZCBgVHJhbnNhY3Rpb25DdG9yRmllbGRzYCBoYXMgYmVlbiBkZXByZWNhdGVkIGFuZCB3aWxsIGJlIHJlbW92ZWQgaW4gYSBmdXR1cmUgdmVyc2lvbi5cbiAgICogUGxlYXNlIHN1cHBseSBhIGBUcmFuc2FjdGlvbkJsb2NraGFzaEN0b3JgIGluc3RlYWQuXG4gICAqL1xuXG4gIC8qKlxuICAgKiBDb25zdHJ1Y3QgYW4gZW1wdHkgVHJhbnNhY3Rpb25cbiAgICovXG4gIGNvbnN0cnVjdG9yKG9wdHMpIHtcbiAgICAvKipcbiAgICAgKiBTaWduYXR1cmVzIGZvciB0aGUgdHJhbnNhY3Rpb24uICBUeXBpY2FsbHkgY3JlYXRlZCBieSBpbnZva2luZyB0aGVcbiAgICAgKiBgc2lnbigpYCBtZXRob2RcbiAgICAgKi9cbiAgICB0aGlzLnNpZ25hdHVyZXMgPSBbXTtcbiAgICB0aGlzLmZlZVBheWVyID0gdm9pZCAwO1xuICAgIC8qKlxuICAgICAqIFRoZSBpbnN0cnVjdGlvbnMgdG8gYXRvbWljYWxseSBleGVjdXRlXG4gICAgICovXG4gICAgdGhpcy5pbnN0cnVjdGlvbnMgPSBbXTtcbiAgICAvKipcbiAgICAgKiBBIHJlY2VudCB0cmFuc2FjdGlvbiBpZC4gTXVzdCBiZSBwb3B1bGF0ZWQgYnkgdGhlIGNhbGxlclxuICAgICAqL1xuICAgIHRoaXMucmVjZW50QmxvY2toYXNoID0gdm9pZCAwO1xuICAgIC8qKlxuICAgICAqIHRoZSBsYXN0IGJsb2NrIGNoYWluIGNhbiBhZHZhbmNlIHRvIGJlZm9yZSB0eCBpcyBkZWNsYXJlZCBleHBpcmVkXG4gICAgICogKi9cbiAgICB0aGlzLmxhc3RWYWxpZEJsb2NrSGVpZ2h0ID0gdm9pZCAwO1xuICAgIC8qKlxuICAgICAqIE9wdGlvbmFsIE5vbmNlIGluZm9ybWF0aW9uLiBJZiBwb3B1bGF0ZWQsIHRyYW5zYWN0aW9uIHdpbGwgdXNlIGEgZHVyYWJsZVxuICAgICAqIE5vbmNlIGhhc2ggaW5zdGVhZCBvZiBhIHJlY2VudEJsb2NraGFzaC4gTXVzdCBiZSBwb3B1bGF0ZWQgYnkgdGhlIGNhbGxlclxuICAgICAqL1xuICAgIHRoaXMubm9uY2VJbmZvID0gdm9pZCAwO1xuICAgIC8qKlxuICAgICAqIElmIHRoaXMgaXMgYSBub25jZSB0cmFuc2FjdGlvbiB0aGlzIHJlcHJlc2VudHMgdGhlIG1pbmltdW0gc2xvdCBmcm9tIHdoaWNoXG4gICAgICogdG8gZXZhbHVhdGUgaWYgdGhlIG5vbmNlIGhhcyBhZHZhbmNlZCB3aGVuIGF0dGVtcHRpbmcgdG8gY29uZmlybSB0aGVcbiAgICAgKiB0cmFuc2FjdGlvbi4gVGhpcyBwcm90ZWN0cyBhZ2FpbnN0IGEgY2FzZSB3aGVyZSB0aGUgdHJhbnNhY3Rpb24gY29uZmlybWF0aW9uXG4gICAgICogbG9naWMgbG9hZHMgdGhlIG5vbmNlIGFjY291bnQgZnJvbSBhbiBvbGQgc2xvdCBhbmQgYXNzdW1lcyB0aGUgbWlzbWF0Y2ggaW5cbiAgICAgKiBub25jZSB2YWx1ZSBpbXBsaWVzIHRoYXQgdGhlIG5vbmNlIGhhcyBiZWVuIGFkdmFuY2VkLlxuICAgICAqL1xuICAgIHRoaXMubWluTm9uY2VDb250ZXh0U2xvdCA9IHZvaWQgMDtcbiAgICAvKipcbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICB0aGlzLl9tZXNzYWdlID0gdm9pZCAwO1xuICAgIC8qKlxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIHRoaXMuX2pzb24gPSB2b2lkIDA7XG4gICAgaWYgKCFvcHRzKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChvcHRzLmZlZVBheWVyKSB7XG4gICAgICB0aGlzLmZlZVBheWVyID0gb3B0cy5mZWVQYXllcjtcbiAgICB9XG4gICAgaWYgKG9wdHMuc2lnbmF0dXJlcykge1xuICAgICAgdGhpcy5zaWduYXR1cmVzID0gb3B0cy5zaWduYXR1cmVzO1xuICAgIH1cbiAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9wdHMsICdub25jZUluZm8nKSkge1xuICAgICAgY29uc3Qge1xuICAgICAgICBtaW5Db250ZXh0U2xvdCxcbiAgICAgICAgbm9uY2VJbmZvXG4gICAgICB9ID0gb3B0cztcbiAgICAgIHRoaXMubWluTm9uY2VDb250ZXh0U2xvdCA9IG1pbkNvbnRleHRTbG90O1xuICAgICAgdGhpcy5ub25jZUluZm8gPSBub25jZUluZm87XG4gICAgfSBlbHNlIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob3B0cywgJ2xhc3RWYWxpZEJsb2NrSGVpZ2h0JykpIHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgYmxvY2toYXNoLFxuICAgICAgICBsYXN0VmFsaWRCbG9ja0hlaWdodFxuICAgICAgfSA9IG9wdHM7XG4gICAgICB0aGlzLnJlY2VudEJsb2NraGFzaCA9IGJsb2NraGFzaDtcbiAgICAgIHRoaXMubGFzdFZhbGlkQmxvY2tIZWlnaHQgPSBsYXN0VmFsaWRCbG9ja0hlaWdodDtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3Qge1xuICAgICAgICByZWNlbnRCbG9ja2hhc2gsXG4gICAgICAgIG5vbmNlSW5mb1xuICAgICAgfSA9IG9wdHM7XG4gICAgICBpZiAobm9uY2VJbmZvKSB7XG4gICAgICAgIHRoaXMubm9uY2VJbmZvID0gbm9uY2VJbmZvO1xuICAgICAgfVxuICAgICAgdGhpcy5yZWNlbnRCbG9ja2hhc2ggPSByZWNlbnRCbG9ja2hhc2g7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgdG9KU09OKCkge1xuICAgIHJldHVybiB7XG4gICAgICByZWNlbnRCbG9ja2hhc2g6IHRoaXMucmVjZW50QmxvY2toYXNoIHx8IG51bGwsXG4gICAgICBmZWVQYXllcjogdGhpcy5mZWVQYXllciA/IHRoaXMuZmVlUGF5ZXIudG9KU09OKCkgOiBudWxsLFxuICAgICAgbm9uY2VJbmZvOiB0aGlzLm5vbmNlSW5mbyA/IHtcbiAgICAgICAgbm9uY2U6IHRoaXMubm9uY2VJbmZvLm5vbmNlLFxuICAgICAgICBub25jZUluc3RydWN0aW9uOiB0aGlzLm5vbmNlSW5mby5ub25jZUluc3RydWN0aW9uLnRvSlNPTigpXG4gICAgICB9IDogbnVsbCxcbiAgICAgIGluc3RydWN0aW9uczogdGhpcy5pbnN0cnVjdGlvbnMubWFwKGluc3RydWN0aW9uID0+IGluc3RydWN0aW9uLnRvSlNPTigpKSxcbiAgICAgIHNpZ25lcnM6IHRoaXMuc2lnbmF0dXJlcy5tYXAoKHtcbiAgICAgICAgcHVibGljS2V5XG4gICAgICB9KSA9PiB7XG4gICAgICAgIHJldHVybiBwdWJsaWNLZXkudG9KU09OKCk7XG4gICAgICB9KVxuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogQWRkIG9uZSBvciBtb3JlIGluc3RydWN0aW9ucyB0byB0aGlzIFRyYW5zYWN0aW9uXG4gICAqXG4gICAqIEBwYXJhbSB7QXJyYXk8IFRyYW5zYWN0aW9uIHwgVHJhbnNhY3Rpb25JbnN0cnVjdGlvbiB8IFRyYW5zYWN0aW9uSW5zdHJ1Y3Rpb25DdG9yRmllbGRzID59IGl0ZW1zIC0gSW5zdHJ1Y3Rpb25zIHRvIGFkZCB0byB0aGUgVHJhbnNhY3Rpb25cbiAgICovXG4gIGFkZCguLi5pdGVtcykge1xuICAgIGlmIChpdGVtcy5sZW5ndGggPT09IDApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignTm8gaW5zdHJ1Y3Rpb25zJyk7XG4gICAgfVxuICAgIGl0ZW1zLmZvckVhY2goaXRlbSA9PiB7XG4gICAgICBpZiAoJ2luc3RydWN0aW9ucycgaW4gaXRlbSkge1xuICAgICAgICB0aGlzLmluc3RydWN0aW9ucyA9IHRoaXMuaW5zdHJ1Y3Rpb25zLmNvbmNhdChpdGVtLmluc3RydWN0aW9ucyk7XG4gICAgICB9IGVsc2UgaWYgKCdkYXRhJyBpbiBpdGVtICYmICdwcm9ncmFtSWQnIGluIGl0ZW0gJiYgJ2tleXMnIGluIGl0ZW0pIHtcbiAgICAgICAgdGhpcy5pbnN0cnVjdGlvbnMucHVzaChpdGVtKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuaW5zdHJ1Y3Rpb25zLnB1c2gobmV3IFRyYW5zYWN0aW9uSW5zdHJ1Y3Rpb24oaXRlbSkpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIENvbXBpbGUgdHJhbnNhY3Rpb24gZGF0YVxuICAgKi9cbiAgY29tcGlsZU1lc3NhZ2UoKSB7XG4gICAgaWYgKHRoaXMuX21lc3NhZ2UgJiYgSlNPTi5zdHJpbmdpZnkodGhpcy50b0pTT04oKSkgPT09IEpTT04uc3RyaW5naWZ5KHRoaXMuX2pzb24pKSB7XG4gICAgICByZXR1cm4gdGhpcy5fbWVzc2FnZTtcbiAgICB9XG4gICAgbGV0IHJlY2VudEJsb2NraGFzaDtcbiAgICBsZXQgaW5zdHJ1Y3Rpb25zO1xuICAgIGlmICh0aGlzLm5vbmNlSW5mbykge1xuICAgICAgcmVjZW50QmxvY2toYXNoID0gdGhpcy5ub25jZUluZm8ubm9uY2U7XG4gICAgICBpZiAodGhpcy5pbnN0cnVjdGlvbnNbMF0gIT0gdGhpcy5ub25jZUluZm8ubm9uY2VJbnN0cnVjdGlvbikge1xuICAgICAgICBpbnN0cnVjdGlvbnMgPSBbdGhpcy5ub25jZUluZm8ubm9uY2VJbnN0cnVjdGlvbiwgLi4udGhpcy5pbnN0cnVjdGlvbnNdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaW5zdHJ1Y3Rpb25zID0gdGhpcy5pbnN0cnVjdGlvbnM7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlY2VudEJsb2NraGFzaCA9IHRoaXMucmVjZW50QmxvY2toYXNoO1xuICAgICAgaW5zdHJ1Y3Rpb25zID0gdGhpcy5pbnN0cnVjdGlvbnM7XG4gICAgfVxuICAgIGlmICghcmVjZW50QmxvY2toYXNoKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RyYW5zYWN0aW9uIHJlY2VudEJsb2NraGFzaCByZXF1aXJlZCcpO1xuICAgIH1cbiAgICBpZiAoaW5zdHJ1Y3Rpb25zLmxlbmd0aCA8IDEpIHtcbiAgICAgIGNvbnNvbGUud2FybignTm8gaW5zdHJ1Y3Rpb25zIHByb3ZpZGVkJyk7XG4gICAgfVxuICAgIGxldCBmZWVQYXllcjtcbiAgICBpZiAodGhpcy5mZWVQYXllcikge1xuICAgICAgZmVlUGF5ZXIgPSB0aGlzLmZlZVBheWVyO1xuICAgIH0gZWxzZSBpZiAodGhpcy5zaWduYXR1cmVzLmxlbmd0aCA+IDAgJiYgdGhpcy5zaWduYXR1cmVzWzBdLnB1YmxpY0tleSkge1xuICAgICAgLy8gVXNlIGltcGxpY2l0IGZlZSBwYXllclxuICAgICAgZmVlUGF5ZXIgPSB0aGlzLnNpZ25hdHVyZXNbMF0ucHVibGljS2V5O1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RyYW5zYWN0aW9uIGZlZSBwYXllciByZXF1aXJlZCcpO1xuICAgIH1cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGluc3RydWN0aW9ucy5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKGluc3RydWN0aW9uc1tpXS5wcm9ncmFtSWQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFRyYW5zYWN0aW9uIGluc3RydWN0aW9uIGluZGV4ICR7aX0gaGFzIHVuZGVmaW5lZCBwcm9ncmFtIGlkYCk7XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IHByb2dyYW1JZHMgPSBbXTtcbiAgICBjb25zdCBhY2NvdW50TWV0YXMgPSBbXTtcbiAgICBpbnN0cnVjdGlvbnMuZm9yRWFjaChpbnN0cnVjdGlvbiA9PiB7XG4gICAgICBpbnN0cnVjdGlvbi5rZXlzLmZvckVhY2goYWNjb3VudE1ldGEgPT4ge1xuICAgICAgICBhY2NvdW50TWV0YXMucHVzaCh7XG4gICAgICAgICAgLi4uYWNjb3VudE1ldGFcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICAgIGNvbnN0IHByb2dyYW1JZCA9IGluc3RydWN0aW9uLnByb2dyYW1JZC50b1N0cmluZygpO1xuICAgICAgaWYgKCFwcm9ncmFtSWRzLmluY2x1ZGVzKHByb2dyYW1JZCkpIHtcbiAgICAgICAgcHJvZ3JhbUlkcy5wdXNoKHByb2dyYW1JZCk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICAvLyBBcHBlbmQgcHJvZ3JhbUlEIGFjY291bnQgbWV0YXNcbiAgICBwcm9ncmFtSWRzLmZvckVhY2gocHJvZ3JhbUlkID0+IHtcbiAgICAgIGFjY291bnRNZXRhcy5wdXNoKHtcbiAgICAgICAgcHVia2V5OiBuZXcgUHVibGljS2V5KHByb2dyYW1JZCksXG4gICAgICAgIGlzU2lnbmVyOiBmYWxzZSxcbiAgICAgICAgaXNXcml0YWJsZTogZmFsc2VcbiAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgLy8gQ3VsbCBkdXBsaWNhdGUgYWNjb3VudCBtZXRhc1xuICAgIGNvbnN0IHVuaXF1ZU1ldGFzID0gW107XG4gICAgYWNjb3VudE1ldGFzLmZvckVhY2goYWNjb3VudE1ldGEgPT4ge1xuICAgICAgY29uc3QgcHVia2V5U3RyaW5nID0gYWNjb3VudE1ldGEucHVia2V5LnRvU3RyaW5nKCk7XG4gICAgICBjb25zdCB1bmlxdWVJbmRleCA9IHVuaXF1ZU1ldGFzLmZpbmRJbmRleCh4ID0+IHtcbiAgICAgICAgcmV0dXJuIHgucHVia2V5LnRvU3RyaW5nKCkgPT09IHB1YmtleVN0cmluZztcbiAgICAgIH0pO1xuICAgICAgaWYgKHVuaXF1ZUluZGV4ID4gLTEpIHtcbiAgICAgICAgdW5pcXVlTWV0YXNbdW5pcXVlSW5kZXhdLmlzV3JpdGFibGUgPSB1bmlxdWVNZXRhc1t1bmlxdWVJbmRleF0uaXNXcml0YWJsZSB8fCBhY2NvdW50TWV0YS5pc1dyaXRhYmxlO1xuICAgICAgICB1bmlxdWVNZXRhc1t1bmlxdWVJbmRleF0uaXNTaWduZXIgPSB1bmlxdWVNZXRhc1t1bmlxdWVJbmRleF0uaXNTaWduZXIgfHwgYWNjb3VudE1ldGEuaXNTaWduZXI7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB1bmlxdWVNZXRhcy5wdXNoKGFjY291bnRNZXRhKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIC8vIFNvcnQuIFByaW9yaXRpemluZyBmaXJzdCBieSBzaWduZXIsIHRoZW4gYnkgd3JpdGFibGVcbiAgICB1bmlxdWVNZXRhcy5zb3J0KGZ1bmN0aW9uICh4LCB5KSB7XG4gICAgICBpZiAoeC5pc1NpZ25lciAhPT0geS5pc1NpZ25lcikge1xuICAgICAgICAvLyBTaWduZXJzIGFsd2F5cyBjb21lIGJlZm9yZSBub24tc2lnbmVyc1xuICAgICAgICByZXR1cm4geC5pc1NpZ25lciA/IC0xIDogMTtcbiAgICAgIH1cbiAgICAgIGlmICh4LmlzV3JpdGFibGUgIT09IHkuaXNXcml0YWJsZSkge1xuICAgICAgICAvLyBXcml0YWJsZSBhY2NvdW50cyBhbHdheXMgY29tZSBiZWZvcmUgcmVhZC1vbmx5IGFjY291bnRzXG4gICAgICAgIHJldHVybiB4LmlzV3JpdGFibGUgPyAtMSA6IDE7XG4gICAgICB9XG4gICAgICAvLyBPdGhlcndpc2UsIHNvcnQgYnkgcHVia2V5LCBzdHJpbmd3aXNlLlxuICAgICAgY29uc3Qgb3B0aW9ucyA9IHtcbiAgICAgICAgbG9jYWxlTWF0Y2hlcjogJ2Jlc3QgZml0JyxcbiAgICAgICAgdXNhZ2U6ICdzb3J0JyxcbiAgICAgICAgc2Vuc2l0aXZpdHk6ICd2YXJpYW50JyxcbiAgICAgICAgaWdub3JlUHVuY3R1YXRpb246IGZhbHNlLFxuICAgICAgICBudW1lcmljOiBmYWxzZSxcbiAgICAgICAgY2FzZUZpcnN0OiAnbG93ZXInXG4gICAgICB9O1xuICAgICAgcmV0dXJuIHgucHVia2V5LnRvQmFzZTU4KCkubG9jYWxlQ29tcGFyZSh5LnB1YmtleS50b0Jhc2U1OCgpLCAnZW4nLCBvcHRpb25zKTtcbiAgICB9KTtcblxuICAgIC8vIE1vdmUgZmVlIHBheWVyIHRvIHRoZSBmcm9udFxuICAgIGNvbnN0IGZlZVBheWVySW5kZXggPSB1bmlxdWVNZXRhcy5maW5kSW5kZXgoeCA9PiB7XG4gICAgICByZXR1cm4geC5wdWJrZXkuZXF1YWxzKGZlZVBheWVyKTtcbiAgICB9KTtcbiAgICBpZiAoZmVlUGF5ZXJJbmRleCA+IC0xKSB7XG4gICAgICBjb25zdCBbcGF5ZXJNZXRhXSA9IHVuaXF1ZU1ldGFzLnNwbGljZShmZWVQYXllckluZGV4LCAxKTtcbiAgICAgIHBheWVyTWV0YS5pc1NpZ25lciA9IHRydWU7XG4gICAgICBwYXllck1ldGEuaXNXcml0YWJsZSA9IHRydWU7XG4gICAgICB1bmlxdWVNZXRhcy51bnNoaWZ0KHBheWVyTWV0YSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHVuaXF1ZU1ldGFzLnVuc2hpZnQoe1xuICAgICAgICBwdWJrZXk6IGZlZVBheWVyLFxuICAgICAgICBpc1NpZ25lcjogdHJ1ZSxcbiAgICAgICAgaXNXcml0YWJsZTogdHJ1ZVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLy8gRGlzYWxsb3cgdW5rbm93biBzaWduZXJzXG4gICAgZm9yIChjb25zdCBzaWduYXR1cmUgb2YgdGhpcy5zaWduYXR1cmVzKSB7XG4gICAgICBjb25zdCB1bmlxdWVJbmRleCA9IHVuaXF1ZU1ldGFzLmZpbmRJbmRleCh4ID0+IHtcbiAgICAgICAgcmV0dXJuIHgucHVia2V5LmVxdWFscyhzaWduYXR1cmUucHVibGljS2V5KTtcbiAgICAgIH0pO1xuICAgICAgaWYgKHVuaXF1ZUluZGV4ID4gLTEpIHtcbiAgICAgICAgaWYgKCF1bmlxdWVNZXRhc1t1bmlxdWVJbmRleF0uaXNTaWduZXIpIHtcbiAgICAgICAgICB1bmlxdWVNZXRhc1t1bmlxdWVJbmRleF0uaXNTaWduZXIgPSB0cnVlO1xuICAgICAgICAgIGNvbnNvbGUud2FybignVHJhbnNhY3Rpb24gcmVmZXJlbmNlcyBhIHNpZ25hdHVyZSB0aGF0IGlzIHVubmVjZXNzYXJ5LCAnICsgJ29ubHkgdGhlIGZlZSBwYXllciBhbmQgaW5zdHJ1Y3Rpb24gc2lnbmVyIGFjY291bnRzIHNob3VsZCBzaWduIGEgdHJhbnNhY3Rpb24uICcgKyAnVGhpcyBiZWhhdmlvciBpcyBkZXByZWNhdGVkIGFuZCB3aWxsIHRocm93IGFuIGVycm9yIGluIHRoZSBuZXh0IG1ham9yIHZlcnNpb24gcmVsZWFzZS4nKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGB1bmtub3duIHNpZ25lcjogJHtzaWduYXR1cmUucHVibGljS2V5LnRvU3RyaW5nKCl9YCk7XG4gICAgICB9XG4gICAgfVxuICAgIGxldCBudW1SZXF1aXJlZFNpZ25hdHVyZXMgPSAwO1xuICAgIGxldCBudW1SZWFkb25seVNpZ25lZEFjY291bnRzID0gMDtcbiAgICBsZXQgbnVtUmVhZG9ubHlVbnNpZ25lZEFjY291bnRzID0gMDtcblxuICAgIC8vIFNwbGl0IG91dCBzaWduaW5nIGZyb20gbm9uLXNpZ25pbmcga2V5cyBhbmQgY291bnQgaGVhZGVyIHZhbHVlc1xuICAgIGNvbnN0IHNpZ25lZEtleXMgPSBbXTtcbiAgICBjb25zdCB1bnNpZ25lZEtleXMgPSBbXTtcbiAgICB1bmlxdWVNZXRhcy5mb3JFYWNoKCh7XG4gICAgICBwdWJrZXksXG4gICAgICBpc1NpZ25lcixcbiAgICAgIGlzV3JpdGFibGVcbiAgICB9KSA9PiB7XG4gICAgICBpZiAoaXNTaWduZXIpIHtcbiAgICAgICAgc2lnbmVkS2V5cy5wdXNoKHB1YmtleS50b1N0cmluZygpKTtcbiAgICAgICAgbnVtUmVxdWlyZWRTaWduYXR1cmVzICs9IDE7XG4gICAgICAgIGlmICghaXNXcml0YWJsZSkge1xuICAgICAgICAgIG51bVJlYWRvbmx5U2lnbmVkQWNjb3VudHMgKz0gMTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdW5zaWduZWRLZXlzLnB1c2gocHVia2V5LnRvU3RyaW5nKCkpO1xuICAgICAgICBpZiAoIWlzV3JpdGFibGUpIHtcbiAgICAgICAgICBudW1SZWFkb25seVVuc2lnbmVkQWNjb3VudHMgKz0gMTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICAgIGNvbnN0IGFjY291bnRLZXlzID0gc2lnbmVkS2V5cy5jb25jYXQodW5zaWduZWRLZXlzKTtcbiAgICBjb25zdCBjb21waWxlZEluc3RydWN0aW9ucyA9IGluc3RydWN0aW9ucy5tYXAoaW5zdHJ1Y3Rpb24gPT4ge1xuICAgICAgY29uc3Qge1xuICAgICAgICBkYXRhLFxuICAgICAgICBwcm9ncmFtSWRcbiAgICAgIH0gPSBpbnN0cnVjdGlvbjtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHByb2dyYW1JZEluZGV4OiBhY2NvdW50S2V5cy5pbmRleE9mKHByb2dyYW1JZC50b1N0cmluZygpKSxcbiAgICAgICAgYWNjb3VudHM6IGluc3RydWN0aW9uLmtleXMubWFwKG1ldGEgPT4gYWNjb3VudEtleXMuaW5kZXhPZihtZXRhLnB1YmtleS50b1N0cmluZygpKSksXG4gICAgICAgIGRhdGE6IGJzNTguZW5jb2RlKGRhdGEpXG4gICAgICB9O1xuICAgIH0pO1xuICAgIGNvbXBpbGVkSW5zdHJ1Y3Rpb25zLmZvckVhY2goaW5zdHJ1Y3Rpb24gPT4ge1xuICAgICAgYXNzZXJ0KGluc3RydWN0aW9uLnByb2dyYW1JZEluZGV4ID49IDApO1xuICAgICAgaW5zdHJ1Y3Rpb24uYWNjb3VudHMuZm9yRWFjaChrZXlJbmRleCA9PiBhc3NlcnQoa2V5SW5kZXggPj0gMCkpO1xuICAgIH0pO1xuICAgIHJldHVybiBuZXcgTWVzc2FnZSh7XG4gICAgICBoZWFkZXI6IHtcbiAgICAgICAgbnVtUmVxdWlyZWRTaWduYXR1cmVzLFxuICAgICAgICBudW1SZWFkb25seVNpZ25lZEFjY291bnRzLFxuICAgICAgICBudW1SZWFkb25seVVuc2lnbmVkQWNjb3VudHNcbiAgICAgIH0sXG4gICAgICBhY2NvdW50S2V5cyxcbiAgICAgIHJlY2VudEJsb2NraGFzaCxcbiAgICAgIGluc3RydWN0aW9uczogY29tcGlsZWRJbnN0cnVjdGlvbnNcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIF9jb21waWxlKCkge1xuICAgIGNvbnN0IG1lc3NhZ2UgPSB0aGlzLmNvbXBpbGVNZXNzYWdlKCk7XG4gICAgY29uc3Qgc2lnbmVkS2V5cyA9IG1lc3NhZ2UuYWNjb3VudEtleXMuc2xpY2UoMCwgbWVzc2FnZS5oZWFkZXIubnVtUmVxdWlyZWRTaWduYXR1cmVzKTtcbiAgICBpZiAodGhpcy5zaWduYXR1cmVzLmxlbmd0aCA9PT0gc2lnbmVkS2V5cy5sZW5ndGgpIHtcbiAgICAgIGNvbnN0IHZhbGlkID0gdGhpcy5zaWduYXR1cmVzLmV2ZXJ5KChwYWlyLCBpbmRleCkgPT4ge1xuICAgICAgICByZXR1cm4gc2lnbmVkS2V5c1tpbmRleF0uZXF1YWxzKHBhaXIucHVibGljS2V5KTtcbiAgICAgIH0pO1xuICAgICAgaWYgKHZhbGlkKSByZXR1cm4gbWVzc2FnZTtcbiAgICB9XG4gICAgdGhpcy5zaWduYXR1cmVzID0gc2lnbmVkS2V5cy5tYXAocHVibGljS2V5ID0+ICh7XG4gICAgICBzaWduYXR1cmU6IG51bGwsXG4gICAgICBwdWJsaWNLZXlcbiAgICB9KSk7XG4gICAgcmV0dXJuIG1lc3NhZ2U7XG4gIH1cblxuICAvKipcbiAgICogR2V0IGEgYnVmZmVyIG9mIHRoZSBUcmFuc2FjdGlvbiBkYXRhIHRoYXQgbmVlZCB0byBiZSBjb3ZlcmVkIGJ5IHNpZ25hdHVyZXNcbiAgICovXG4gIHNlcmlhbGl6ZU1lc3NhZ2UoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2NvbXBpbGUoKS5zZXJpYWxpemUoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIGVzdGltYXRlZCBmZWUgYXNzb2NpYXRlZCB3aXRoIGEgdHJhbnNhY3Rpb25cbiAgICpcbiAgICogQHBhcmFtIHtDb25uZWN0aW9ufSBjb25uZWN0aW9uIENvbm5lY3Rpb24gdG8gUlBDIEVuZHBvaW50LlxuICAgKlxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxudW1iZXIgfCBudWxsPn0gVGhlIGVzdGltYXRlZCBmZWUgZm9yIHRoZSB0cmFuc2FjdGlvblxuICAgKi9cbiAgYXN5bmMgZ2V0RXN0aW1hdGVkRmVlKGNvbm5lY3Rpb24pIHtcbiAgICByZXR1cm4gKGF3YWl0IGNvbm5lY3Rpb24uZ2V0RmVlRm9yTWVzc2FnZSh0aGlzLmNvbXBpbGVNZXNzYWdlKCkpKS52YWx1ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTcGVjaWZ5IHRoZSBwdWJsaWMga2V5cyB3aGljaCB3aWxsIGJlIHVzZWQgdG8gc2lnbiB0aGUgVHJhbnNhY3Rpb24uXG4gICAqIFRoZSBmaXJzdCBzaWduZXIgd2lsbCBiZSB1c2VkIGFzIHRoZSB0cmFuc2FjdGlvbiBmZWUgcGF5ZXIgYWNjb3VudC5cbiAgICpcbiAgICogU2lnbmF0dXJlcyBjYW4gYmUgYWRkZWQgd2l0aCBlaXRoZXIgYHBhcnRpYWxTaWduYCBvciBgYWRkU2lnbmF0dXJlYFxuICAgKlxuICAgKiBAZGVwcmVjYXRlZCBEZXByZWNhdGVkIHNpbmNlIHYwLjg0LjAuIE9ubHkgdGhlIGZlZSBwYXllciBuZWVkcyB0byBiZVxuICAgKiBzcGVjaWZpZWQgYW5kIGl0IGNhbiBiZSBzZXQgaW4gdGhlIFRyYW5zYWN0aW9uIGNvbnN0cnVjdG9yIG9yIHdpdGggdGhlXG4gICAqIGBmZWVQYXllcmAgcHJvcGVydHkuXG4gICAqL1xuICBzZXRTaWduZXJzKC4uLnNpZ25lcnMpIHtcbiAgICBpZiAoc2lnbmVycy5sZW5ndGggPT09IDApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignTm8gc2lnbmVycycpO1xuICAgIH1cbiAgICBjb25zdCBzZWVuID0gbmV3IFNldCgpO1xuICAgIHRoaXMuc2lnbmF0dXJlcyA9IHNpZ25lcnMuZmlsdGVyKHB1YmxpY0tleSA9PiB7XG4gICAgICBjb25zdCBrZXkgPSBwdWJsaWNLZXkudG9TdHJpbmcoKTtcbiAgICAgIGlmIChzZWVuLmhhcyhrZXkpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNlZW4uYWRkKGtleSk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH0pLm1hcChwdWJsaWNLZXkgPT4gKHtcbiAgICAgIHNpZ25hdHVyZTogbnVsbCxcbiAgICAgIHB1YmxpY0tleVxuICAgIH0pKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTaWduIHRoZSBUcmFuc2FjdGlvbiB3aXRoIHRoZSBzcGVjaWZpZWQgc2lnbmVycy4gTXVsdGlwbGUgc2lnbmF0dXJlcyBtYXlcbiAgICogYmUgYXBwbGllZCB0byBhIFRyYW5zYWN0aW9uLiBUaGUgZmlyc3Qgc2lnbmF0dXJlIGlzIGNvbnNpZGVyZWQgXCJwcmltYXJ5XCJcbiAgICogYW5kIGlzIHVzZWQgaWRlbnRpZnkgYW5kIGNvbmZpcm0gdHJhbnNhY3Rpb25zLlxuICAgKlxuICAgKiBJZiB0aGUgVHJhbnNhY3Rpb24gYGZlZVBheWVyYCBpcyBub3Qgc2V0LCB0aGUgZmlyc3Qgc2lnbmVyIHdpbGwgYmUgdXNlZFxuICAgKiBhcyB0aGUgdHJhbnNhY3Rpb24gZmVlIHBheWVyIGFjY291bnQuXG4gICAqXG4gICAqIFRyYW5zYWN0aW9uIGZpZWxkcyBzaG91bGQgbm90IGJlIG1vZGlmaWVkIGFmdGVyIHRoZSBmaXJzdCBjYWxsIHRvIGBzaWduYCxcbiAgICogYXMgZG9pbmcgc28gbWF5IGludmFsaWRhdGUgdGhlIHNpZ25hdHVyZSBhbmQgY2F1c2UgdGhlIFRyYW5zYWN0aW9uIHRvIGJlXG4gICAqIHJlamVjdGVkLlxuICAgKlxuICAgKiBUaGUgVHJhbnNhY3Rpb24gbXVzdCBiZSBhc3NpZ25lZCBhIHZhbGlkIGByZWNlbnRCbG9ja2hhc2hgIGJlZm9yZSBpbnZva2luZyB0aGlzIG1ldGhvZFxuICAgKlxuICAgKiBAcGFyYW0ge0FycmF5PFNpZ25lcj59IHNpZ25lcnMgQXJyYXkgb2Ygc2lnbmVycyB0aGF0IHdpbGwgc2lnbiB0aGUgdHJhbnNhY3Rpb25cbiAgICovXG4gIHNpZ24oLi4uc2lnbmVycykge1xuICAgIGlmIChzaWduZXJzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdObyBzaWduZXJzJyk7XG4gICAgfVxuXG4gICAgLy8gRGVkdXBlIHNpZ25lcnNcbiAgICBjb25zdCBzZWVuID0gbmV3IFNldCgpO1xuICAgIGNvbnN0IHVuaXF1ZVNpZ25lcnMgPSBbXTtcbiAgICBmb3IgKGNvbnN0IHNpZ25lciBvZiBzaWduZXJzKSB7XG4gICAgICBjb25zdCBrZXkgPSBzaWduZXIucHVibGljS2V5LnRvU3RyaW5nKCk7XG4gICAgICBpZiAoc2Vlbi5oYXMoa2V5KSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNlZW4uYWRkKGtleSk7XG4gICAgICAgIHVuaXF1ZVNpZ25lcnMucHVzaChzaWduZXIpO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLnNpZ25hdHVyZXMgPSB1bmlxdWVTaWduZXJzLm1hcChzaWduZXIgPT4gKHtcbiAgICAgIHNpZ25hdHVyZTogbnVsbCxcbiAgICAgIHB1YmxpY0tleTogc2lnbmVyLnB1YmxpY0tleVxuICAgIH0pKTtcbiAgICBjb25zdCBtZXNzYWdlID0gdGhpcy5fY29tcGlsZSgpO1xuICAgIHRoaXMuX3BhcnRpYWxTaWduKG1lc3NhZ2UsIC4uLnVuaXF1ZVNpZ25lcnMpO1xuICB9XG5cbiAgLyoqXG4gICAqIFBhcnRpYWxseSBzaWduIGEgdHJhbnNhY3Rpb24gd2l0aCB0aGUgc3BlY2lmaWVkIGFjY291bnRzLiBBbGwgYWNjb3VudHMgbXVzdFxuICAgKiBjb3JyZXNwb25kIHRvIGVpdGhlciB0aGUgZmVlIHBheWVyIG9yIGEgc2lnbmVyIGFjY291bnQgaW4gdGhlIHRyYW5zYWN0aW9uXG4gICAqIGluc3RydWN0aW9ucy5cbiAgICpcbiAgICogQWxsIHRoZSBjYXZlYXRzIGZyb20gdGhlIGBzaWduYCBtZXRob2QgYXBwbHkgdG8gYHBhcnRpYWxTaWduYFxuICAgKlxuICAgKiBAcGFyYW0ge0FycmF5PFNpZ25lcj59IHNpZ25lcnMgQXJyYXkgb2Ygc2lnbmVycyB0aGF0IHdpbGwgc2lnbiB0aGUgdHJhbnNhY3Rpb25cbiAgICovXG4gIHBhcnRpYWxTaWduKC4uLnNpZ25lcnMpIHtcbiAgICBpZiAoc2lnbmVycy5sZW5ndGggPT09IDApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignTm8gc2lnbmVycycpO1xuICAgIH1cblxuICAgIC8vIERlZHVwZSBzaWduZXJzXG4gICAgY29uc3Qgc2VlbiA9IG5ldyBTZXQoKTtcbiAgICBjb25zdCB1bmlxdWVTaWduZXJzID0gW107XG4gICAgZm9yIChjb25zdCBzaWduZXIgb2Ygc2lnbmVycykge1xuICAgICAgY29uc3Qga2V5ID0gc2lnbmVyLnB1YmxpY0tleS50b1N0cmluZygpO1xuICAgICAgaWYgKHNlZW4uaGFzKGtleSkpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzZWVuLmFkZChrZXkpO1xuICAgICAgICB1bmlxdWVTaWduZXJzLnB1c2goc2lnbmVyKTtcbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgbWVzc2FnZSA9IHRoaXMuX2NvbXBpbGUoKTtcbiAgICB0aGlzLl9wYXJ0aWFsU2lnbihtZXNzYWdlLCAuLi51bmlxdWVTaWduZXJzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIF9wYXJ0aWFsU2lnbihtZXNzYWdlLCAuLi5zaWduZXJzKSB7XG4gICAgY29uc3Qgc2lnbkRhdGEgPSBtZXNzYWdlLnNlcmlhbGl6ZSgpO1xuICAgIHNpZ25lcnMuZm9yRWFjaChzaWduZXIgPT4ge1xuICAgICAgY29uc3Qgc2lnbmF0dXJlID0gc2lnbihzaWduRGF0YSwgc2lnbmVyLnNlY3JldEtleSk7XG4gICAgICB0aGlzLl9hZGRTaWduYXR1cmUoc2lnbmVyLnB1YmxpY0tleSwgdG9CdWZmZXIoc2lnbmF0dXJlKSk7XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogQWRkIGFuIGV4dGVybmFsbHkgY3JlYXRlZCBzaWduYXR1cmUgdG8gYSB0cmFuc2FjdGlvbi4gVGhlIHB1YmxpYyBrZXlcbiAgICogbXVzdCBjb3JyZXNwb25kIHRvIGVpdGhlciB0aGUgZmVlIHBheWVyIG9yIGEgc2lnbmVyIGFjY291bnQgaW4gdGhlIHRyYW5zYWN0aW9uXG4gICAqIGluc3RydWN0aW9ucy5cbiAgICpcbiAgICogQHBhcmFtIHtQdWJsaWNLZXl9IHB1YmtleSBQdWJsaWMga2V5IHRoYXQgd2lsbCBiZSBhZGRlZCB0byB0aGUgdHJhbnNhY3Rpb24uXG4gICAqIEBwYXJhbSB7QnVmZmVyfSBzaWduYXR1cmUgQW4gZXh0ZXJuYWxseSBjcmVhdGVkIHNpZ25hdHVyZSB0byBhZGQgdG8gdGhlIHRyYW5zYWN0aW9uLlxuICAgKi9cbiAgYWRkU2lnbmF0dXJlKHB1YmtleSwgc2lnbmF0dXJlKSB7XG4gICAgdGhpcy5fY29tcGlsZSgpOyAvLyBFbnN1cmUgc2lnbmF0dXJlcyBhcnJheSBpcyBwb3B1bGF0ZWRcbiAgICB0aGlzLl9hZGRTaWduYXR1cmUocHVia2V5LCBzaWduYXR1cmUpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgX2FkZFNpZ25hdHVyZShwdWJrZXksIHNpZ25hdHVyZSkge1xuICAgIGFzc2VydChzaWduYXR1cmUubGVuZ3RoID09PSA2NCk7XG4gICAgY29uc3QgaW5kZXggPSB0aGlzLnNpZ25hdHVyZXMuZmluZEluZGV4KHNpZ3BhaXIgPT4gcHVia2V5LmVxdWFscyhzaWdwYWlyLnB1YmxpY0tleSkpO1xuICAgIGlmIChpbmRleCA8IDApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgdW5rbm93biBzaWduZXI6ICR7cHVia2V5LnRvU3RyaW5nKCl9YCk7XG4gICAgfVxuICAgIHRoaXMuc2lnbmF0dXJlc1tpbmRleF0uc2lnbmF0dXJlID0gQnVmZmVyLmZyb20oc2lnbmF0dXJlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBWZXJpZnkgc2lnbmF0dXJlcyBvZiBhIFRyYW5zYWN0aW9uXG4gICAqIE9wdGlvbmFsIHBhcmFtZXRlciBzcGVjaWZpZXMgaWYgd2UncmUgZXhwZWN0aW5nIGEgZnVsbHkgc2lnbmVkIFRyYW5zYWN0aW9uIG9yIGEgcGFydGlhbGx5IHNpZ25lZCBvbmUuXG4gICAqIElmIG5vIGJvb2xlYW4gaXMgcHJvdmlkZWQsIHdlIGV4cGVjdCBhIGZ1bGx5IHNpZ25lZCBUcmFuc2FjdGlvbiBieSBkZWZhdWx0LlxuICAgKlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtyZXF1aXJlQWxsU2lnbmF0dXJlcz10cnVlXSBSZXF1aXJlIGEgZnVsbHkgc2lnbmVkIFRyYW5zYWN0aW9uXG4gICAqL1xuICB2ZXJpZnlTaWduYXR1cmVzKHJlcXVpcmVBbGxTaWduYXR1cmVzID0gdHJ1ZSkge1xuICAgIGNvbnN0IHNpZ25hdHVyZUVycm9ycyA9IHRoaXMuX2dldE1lc3NhZ2VTaWduZWRuZXNzRXJyb3JzKHRoaXMuc2VyaWFsaXplTWVzc2FnZSgpLCByZXF1aXJlQWxsU2lnbmF0dXJlcyk7XG4gICAgcmV0dXJuICFzaWduYXR1cmVFcnJvcnM7XG4gIH1cblxuICAvKipcbiAgICogQGludGVybmFsXG4gICAqL1xuICBfZ2V0TWVzc2FnZVNpZ25lZG5lc3NFcnJvcnMobWVzc2FnZSwgcmVxdWlyZUFsbFNpZ25hdHVyZXMpIHtcbiAgICBjb25zdCBlcnJvcnMgPSB7fTtcbiAgICBmb3IgKGNvbnN0IHtcbiAgICAgIHNpZ25hdHVyZSxcbiAgICAgIHB1YmxpY0tleVxuICAgIH0gb2YgdGhpcy5zaWduYXR1cmVzKSB7XG4gICAgICBpZiAoc2lnbmF0dXJlID09PSBudWxsKSB7XG4gICAgICAgIGlmIChyZXF1aXJlQWxsU2lnbmF0dXJlcykge1xuICAgICAgICAgIChlcnJvcnMubWlzc2luZyB8fD0gW10pLnB1c2gocHVibGljS2V5KTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKCF2ZXJpZnkoc2lnbmF0dXJlLCBtZXNzYWdlLCBwdWJsaWNLZXkudG9CeXRlcygpKSkge1xuICAgICAgICAgIChlcnJvcnMuaW52YWxpZCB8fD0gW10pLnB1c2gocHVibGljS2V5KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZXJyb3JzLmludmFsaWQgfHwgZXJyb3JzLm1pc3NpbmcgPyBlcnJvcnMgOiB1bmRlZmluZWQ7XG4gIH1cblxuICAvKipcbiAgICogU2VyaWFsaXplIHRoZSBUcmFuc2FjdGlvbiBpbiB0aGUgd2lyZSBmb3JtYXQuXG4gICAqXG4gICAqIEBwYXJhbSB7QnVmZmVyfSBbY29uZmlnXSBDb25maWcgb2YgdHJhbnNhY3Rpb24uXG4gICAqXG4gICAqIEByZXR1cm5zIHtCdWZmZXJ9IFNpZ25hdHVyZSBvZiB0cmFuc2FjdGlvbiBpbiB3aXJlIGZvcm1hdC5cbiAgICovXG4gIHNlcmlhbGl6ZShjb25maWcpIHtcbiAgICBjb25zdCB7XG4gICAgICByZXF1aXJlQWxsU2lnbmF0dXJlcyxcbiAgICAgIHZlcmlmeVNpZ25hdHVyZXNcbiAgICB9ID0gT2JqZWN0LmFzc2lnbih7XG4gICAgICByZXF1aXJlQWxsU2lnbmF0dXJlczogdHJ1ZSxcbiAgICAgIHZlcmlmeVNpZ25hdHVyZXM6IHRydWVcbiAgICB9LCBjb25maWcpO1xuICAgIGNvbnN0IHNpZ25EYXRhID0gdGhpcy5zZXJpYWxpemVNZXNzYWdlKCk7XG4gICAgaWYgKHZlcmlmeVNpZ25hdHVyZXMpIHtcbiAgICAgIGNvbnN0IHNpZ0Vycm9ycyA9IHRoaXMuX2dldE1lc3NhZ2VTaWduZWRuZXNzRXJyb3JzKHNpZ25EYXRhLCByZXF1aXJlQWxsU2lnbmF0dXJlcyk7XG4gICAgICBpZiAoc2lnRXJyb3JzKSB7XG4gICAgICAgIGxldCBlcnJvck1lc3NhZ2UgPSAnU2lnbmF0dXJlIHZlcmlmaWNhdGlvbiBmYWlsZWQuJztcbiAgICAgICAgaWYgKHNpZ0Vycm9ycy5pbnZhbGlkKSB7XG4gICAgICAgICAgZXJyb3JNZXNzYWdlICs9IGBcXG5JbnZhbGlkIHNpZ25hdHVyZSBmb3IgcHVibGljIGtleSR7c2lnRXJyb3JzLmludmFsaWQubGVuZ3RoID09PSAxID8gJycgOiAnKHMpJ30gW1xcYCR7c2lnRXJyb3JzLmludmFsaWQubWFwKHAgPT4gcC50b0Jhc2U1OCgpKS5qb2luKCdgLCBgJyl9XFxgXS5gO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzaWdFcnJvcnMubWlzc2luZykge1xuICAgICAgICAgIGVycm9yTWVzc2FnZSArPSBgXFxuTWlzc2luZyBzaWduYXR1cmUgZm9yIHB1YmxpYyBrZXkke3NpZ0Vycm9ycy5taXNzaW5nLmxlbmd0aCA9PT0gMSA/ICcnIDogJyhzKSd9IFtcXGAke3NpZ0Vycm9ycy5taXNzaW5nLm1hcChwID0+IHAudG9CYXNlNTgoKSkuam9pbignYCwgYCcpfVxcYF0uYDtcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyb3JNZXNzYWdlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX3NlcmlhbGl6ZShzaWduRGF0YSk7XG4gIH1cblxuICAvKipcbiAgICogQGludGVybmFsXG4gICAqL1xuICBfc2VyaWFsaXplKHNpZ25EYXRhKSB7XG4gICAgY29uc3Qge1xuICAgICAgc2lnbmF0dXJlc1xuICAgIH0gPSB0aGlzO1xuICAgIGNvbnN0IHNpZ25hdHVyZUNvdW50ID0gW107XG4gICAgZW5jb2RlTGVuZ3RoKHNpZ25hdHVyZUNvdW50LCBzaWduYXR1cmVzLmxlbmd0aCk7XG4gICAgY29uc3QgdHJhbnNhY3Rpb25MZW5ndGggPSBzaWduYXR1cmVDb3VudC5sZW5ndGggKyBzaWduYXR1cmVzLmxlbmd0aCAqIDY0ICsgc2lnbkRhdGEubGVuZ3RoO1xuICAgIGNvbnN0IHdpcmVUcmFuc2FjdGlvbiA9IEJ1ZmZlci5hbGxvYyh0cmFuc2FjdGlvbkxlbmd0aCk7XG4gICAgYXNzZXJ0KHNpZ25hdHVyZXMubGVuZ3RoIDwgMjU2KTtcbiAgICBCdWZmZXIuZnJvbShzaWduYXR1cmVDb3VudCkuY29weSh3aXJlVHJhbnNhY3Rpb24sIDApO1xuICAgIHNpZ25hdHVyZXMuZm9yRWFjaCgoe1xuICAgICAgc2lnbmF0dXJlXG4gICAgfSwgaW5kZXgpID0+IHtcbiAgICAgIGlmIChzaWduYXR1cmUgIT09IG51bGwpIHtcbiAgICAgICAgYXNzZXJ0KHNpZ25hdHVyZS5sZW5ndGggPT09IDY0LCBgc2lnbmF0dXJlIGhhcyBpbnZhbGlkIGxlbmd0aGApO1xuICAgICAgICBCdWZmZXIuZnJvbShzaWduYXR1cmUpLmNvcHkod2lyZVRyYW5zYWN0aW9uLCBzaWduYXR1cmVDb3VudC5sZW5ndGggKyBpbmRleCAqIDY0KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBzaWduRGF0YS5jb3B5KHdpcmVUcmFuc2FjdGlvbiwgc2lnbmF0dXJlQ291bnQubGVuZ3RoICsgc2lnbmF0dXJlcy5sZW5ndGggKiA2NCk7XG4gICAgYXNzZXJ0KHdpcmVUcmFuc2FjdGlvbi5sZW5ndGggPD0gUEFDS0VUX0RBVEFfU0laRSwgYFRyYW5zYWN0aW9uIHRvbyBsYXJnZTogJHt3aXJlVHJhbnNhY3Rpb24ubGVuZ3RofSA+ICR7UEFDS0VUX0RBVEFfU0laRX1gKTtcbiAgICByZXR1cm4gd2lyZVRyYW5zYWN0aW9uO1xuICB9XG5cbiAgLyoqXG4gICAqIERlcHJlY2F0ZWQgbWV0aG9kXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgZ2V0IGtleXMoKSB7XG4gICAgYXNzZXJ0KHRoaXMuaW5zdHJ1Y3Rpb25zLmxlbmd0aCA9PT0gMSk7XG4gICAgcmV0dXJuIHRoaXMuaW5zdHJ1Y3Rpb25zWzBdLmtleXMubWFwKGtleU9iaiA9PiBrZXlPYmoucHVia2V5KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZXByZWNhdGVkIG1ldGhvZFxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIGdldCBwcm9ncmFtSWQoKSB7XG4gICAgYXNzZXJ0KHRoaXMuaW5zdHJ1Y3Rpb25zLmxlbmd0aCA9PT0gMSk7XG4gICAgcmV0dXJuIHRoaXMuaW5zdHJ1Y3Rpb25zWzBdLnByb2dyYW1JZDtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZXByZWNhdGVkIG1ldGhvZFxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIGdldCBkYXRhKCkge1xuICAgIGFzc2VydCh0aGlzLmluc3RydWN0aW9ucy5sZW5ndGggPT09IDEpO1xuICAgIHJldHVybiB0aGlzLmluc3RydWN0aW9uc1swXS5kYXRhO1xuICB9XG5cbiAgLyoqXG4gICAqIFBhcnNlIGEgd2lyZSB0cmFuc2FjdGlvbiBpbnRvIGEgVHJhbnNhY3Rpb24gb2JqZWN0LlxuICAgKlxuICAgKiBAcGFyYW0ge0J1ZmZlciB8IFVpbnQ4QXJyYXkgfCBBcnJheTxudW1iZXI+fSBidWZmZXIgU2lnbmF0dXJlIG9mIHdpcmUgVHJhbnNhY3Rpb25cbiAgICpcbiAgICogQHJldHVybnMge1RyYW5zYWN0aW9ufSBUcmFuc2FjdGlvbiBhc3NvY2lhdGVkIHdpdGggdGhlIHNpZ25hdHVyZVxuICAgKi9cbiAgc3RhdGljIGZyb20oYnVmZmVyKSB7XG4gICAgLy8gU2xpY2UgdXAgd2lyZSBkYXRhXG4gICAgbGV0IGJ5dGVBcnJheSA9IFsuLi5idWZmZXJdO1xuICAgIGNvbnN0IHNpZ25hdHVyZUNvdW50ID0gZGVjb2RlTGVuZ3RoKGJ5dGVBcnJheSk7XG4gICAgbGV0IHNpZ25hdHVyZXMgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNpZ25hdHVyZUNvdW50OyBpKyspIHtcbiAgICAgIGNvbnN0IHNpZ25hdHVyZSA9IGd1YXJkZWRTcGxpY2UoYnl0ZUFycmF5LCAwLCBTSUdOQVRVUkVfTEVOR1RIX0lOX0JZVEVTKTtcbiAgICAgIHNpZ25hdHVyZXMucHVzaChiczU4LmVuY29kZShCdWZmZXIuZnJvbShzaWduYXR1cmUpKSk7XG4gICAgfVxuICAgIHJldHVybiBUcmFuc2FjdGlvbi5wb3B1bGF0ZShNZXNzYWdlLmZyb20oYnl0ZUFycmF5KSwgc2lnbmF0dXJlcyk7XG4gIH1cblxuICAvKipcbiAgICogUG9wdWxhdGUgVHJhbnNhY3Rpb24gb2JqZWN0IGZyb20gbWVzc2FnZSBhbmQgc2lnbmF0dXJlc1xuICAgKlxuICAgKiBAcGFyYW0ge01lc3NhZ2V9IG1lc3NhZ2UgTWVzc2FnZSBvZiB0cmFuc2FjdGlvblxuICAgKiBAcGFyYW0ge0FycmF5PHN0cmluZz59IHNpZ25hdHVyZXMgTGlzdCBvZiBzaWduYXR1cmVzIHRvIGFzc2lnbiB0byB0aGUgdHJhbnNhY3Rpb25cbiAgICpcbiAgICogQHJldHVybnMge1RyYW5zYWN0aW9ufSBUaGUgcG9wdWxhdGVkIFRyYW5zYWN0aW9uXG4gICAqL1xuICBzdGF0aWMgcG9wdWxhdGUobWVzc2FnZSwgc2lnbmF0dXJlcyA9IFtdKSB7XG4gICAgY29uc3QgdHJhbnNhY3Rpb24gPSBuZXcgVHJhbnNhY3Rpb24oKTtcbiAgICB0cmFuc2FjdGlvbi5yZWNlbnRCbG9ja2hhc2ggPSBtZXNzYWdlLnJlY2VudEJsb2NraGFzaDtcbiAgICBpZiAobWVzc2FnZS5oZWFkZXIubnVtUmVxdWlyZWRTaWduYXR1cmVzID4gMCkge1xuICAgICAgdHJhbnNhY3Rpb24uZmVlUGF5ZXIgPSBtZXNzYWdlLmFjY291bnRLZXlzWzBdO1xuICAgIH1cbiAgICBzaWduYXR1cmVzLmZvckVhY2goKHNpZ25hdHVyZSwgaW5kZXgpID0+IHtcbiAgICAgIGNvbnN0IHNpZ1B1YmtleVBhaXIgPSB7XG4gICAgICAgIHNpZ25hdHVyZTogc2lnbmF0dXJlID09IGJzNTguZW5jb2RlKERFRkFVTFRfU0lHTkFUVVJFKSA/IG51bGwgOiBiczU4LmRlY29kZShzaWduYXR1cmUpLFxuICAgICAgICBwdWJsaWNLZXk6IG1lc3NhZ2UuYWNjb3VudEtleXNbaW5kZXhdXG4gICAgICB9O1xuICAgICAgdHJhbnNhY3Rpb24uc2lnbmF0dXJlcy5wdXNoKHNpZ1B1YmtleVBhaXIpO1xuICAgIH0pO1xuICAgIG1lc3NhZ2UuaW5zdHJ1Y3Rpb25zLmZvckVhY2goaW5zdHJ1Y3Rpb24gPT4ge1xuICAgICAgY29uc3Qga2V5cyA9IGluc3RydWN0aW9uLmFjY291bnRzLm1hcChhY2NvdW50ID0+IHtcbiAgICAgICAgY29uc3QgcHVia2V5ID0gbWVzc2FnZS5hY2NvdW50S2V5c1thY2NvdW50XTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBwdWJrZXksXG4gICAgICAgICAgaXNTaWduZXI6IHRyYW5zYWN0aW9uLnNpZ25hdHVyZXMuc29tZShrZXlPYmogPT4ga2V5T2JqLnB1YmxpY0tleS50b1N0cmluZygpID09PSBwdWJrZXkudG9TdHJpbmcoKSkgfHwgbWVzc2FnZS5pc0FjY291bnRTaWduZXIoYWNjb3VudCksXG4gICAgICAgICAgaXNXcml0YWJsZTogbWVzc2FnZS5pc0FjY291bnRXcml0YWJsZShhY2NvdW50KVxuICAgICAgICB9O1xuICAgICAgfSk7XG4gICAgICB0cmFuc2FjdGlvbi5pbnN0cnVjdGlvbnMucHVzaChuZXcgVHJhbnNhY3Rpb25JbnN0cnVjdGlvbih7XG4gICAgICAgIGtleXMsXG4gICAgICAgIHByb2dyYW1JZDogbWVzc2FnZS5hY2NvdW50S2V5c1tpbnN0cnVjdGlvbi5wcm9ncmFtSWRJbmRleF0sXG4gICAgICAgIGRhdGE6IGJzNTguZGVjb2RlKGluc3RydWN0aW9uLmRhdGEpXG4gICAgICB9KSk7XG4gICAgfSk7XG4gICAgdHJhbnNhY3Rpb24uX21lc3NhZ2UgPSBtZXNzYWdlO1xuICAgIHRyYW5zYWN0aW9uLl9qc29uID0gdHJhbnNhY3Rpb24udG9KU09OKCk7XG4gICAgcmV0dXJuIHRyYW5zYWN0aW9uO1xuICB9XG59XG5cbmNsYXNzIFRyYW5zYWN0aW9uTWVzc2FnZSB7XG4gIGNvbnN0cnVjdG9yKGFyZ3MpIHtcbiAgICB0aGlzLnBheWVyS2V5ID0gdm9pZCAwO1xuICAgIHRoaXMuaW5zdHJ1Y3Rpb25zID0gdm9pZCAwO1xuICAgIHRoaXMucmVjZW50QmxvY2toYXNoID0gdm9pZCAwO1xuICAgIHRoaXMucGF5ZXJLZXkgPSBhcmdzLnBheWVyS2V5O1xuICAgIHRoaXMuaW5zdHJ1Y3Rpb25zID0gYXJncy5pbnN0cnVjdGlvbnM7XG4gICAgdGhpcy5yZWNlbnRCbG9ja2hhc2ggPSBhcmdzLnJlY2VudEJsb2NraGFzaDtcbiAgfVxuICBzdGF0aWMgZGVjb21waWxlKG1lc3NhZ2UsIGFyZ3MpIHtcbiAgICBjb25zdCB7XG4gICAgICBoZWFkZXIsXG4gICAgICBjb21waWxlZEluc3RydWN0aW9ucyxcbiAgICAgIHJlY2VudEJsb2NraGFzaFxuICAgIH0gPSBtZXNzYWdlO1xuICAgIGNvbnN0IHtcbiAgICAgIG51bVJlcXVpcmVkU2lnbmF0dXJlcyxcbiAgICAgIG51bVJlYWRvbmx5U2lnbmVkQWNjb3VudHMsXG4gICAgICBudW1SZWFkb25seVVuc2lnbmVkQWNjb3VudHNcbiAgICB9ID0gaGVhZGVyO1xuICAgIGNvbnN0IG51bVdyaXRhYmxlU2lnbmVkQWNjb3VudHMgPSBudW1SZXF1aXJlZFNpZ25hdHVyZXMgLSBudW1SZWFkb25seVNpZ25lZEFjY291bnRzO1xuICAgIGFzc2VydChudW1Xcml0YWJsZVNpZ25lZEFjY291bnRzID4gMCwgJ01lc3NhZ2UgaGVhZGVyIGlzIGludmFsaWQnKTtcbiAgICBjb25zdCBudW1Xcml0YWJsZVVuc2lnbmVkQWNjb3VudHMgPSBtZXNzYWdlLnN0YXRpY0FjY291bnRLZXlzLmxlbmd0aCAtIG51bVJlcXVpcmVkU2lnbmF0dXJlcyAtIG51bVJlYWRvbmx5VW5zaWduZWRBY2NvdW50cztcbiAgICBhc3NlcnQobnVtV3JpdGFibGVVbnNpZ25lZEFjY291bnRzID49IDAsICdNZXNzYWdlIGhlYWRlciBpcyBpbnZhbGlkJyk7XG4gICAgY29uc3QgYWNjb3VudEtleXMgPSBtZXNzYWdlLmdldEFjY291bnRLZXlzKGFyZ3MpO1xuICAgIGNvbnN0IHBheWVyS2V5ID0gYWNjb3VudEtleXMuZ2V0KDApO1xuICAgIGlmIChwYXllcktleSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZhaWxlZCB0byBkZWNvbXBpbGUgbWVzc2FnZSBiZWNhdXNlIG5vIGFjY291bnQga2V5cyB3ZXJlIGZvdW5kJyk7XG4gICAgfVxuICAgIGNvbnN0IGluc3RydWN0aW9ucyA9IFtdO1xuICAgIGZvciAoY29uc3QgY29tcGlsZWRJeCBvZiBjb21waWxlZEluc3RydWN0aW9ucykge1xuICAgICAgY29uc3Qga2V5cyA9IFtdO1xuICAgICAgZm9yIChjb25zdCBrZXlJbmRleCBvZiBjb21waWxlZEl4LmFjY291bnRLZXlJbmRleGVzKSB7XG4gICAgICAgIGNvbnN0IHB1YmtleSA9IGFjY291bnRLZXlzLmdldChrZXlJbmRleCk7XG4gICAgICAgIGlmIChwdWJrZXkgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgRmFpbGVkIHRvIGZpbmQga2V5IGZvciBhY2NvdW50IGtleSBpbmRleCAke2tleUluZGV4fWApO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGlzU2lnbmVyID0ga2V5SW5kZXggPCBudW1SZXF1aXJlZFNpZ25hdHVyZXM7XG4gICAgICAgIGxldCBpc1dyaXRhYmxlO1xuICAgICAgICBpZiAoaXNTaWduZXIpIHtcbiAgICAgICAgICBpc1dyaXRhYmxlID0ga2V5SW5kZXggPCBudW1Xcml0YWJsZVNpZ25lZEFjY291bnRzO1xuICAgICAgICB9IGVsc2UgaWYgKGtleUluZGV4IDwgYWNjb3VudEtleXMuc3RhdGljQWNjb3VudEtleXMubGVuZ3RoKSB7XG4gICAgICAgICAgaXNXcml0YWJsZSA9IGtleUluZGV4IC0gbnVtUmVxdWlyZWRTaWduYXR1cmVzIDwgbnVtV3JpdGFibGVVbnNpZ25lZEFjY291bnRzO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlzV3JpdGFibGUgPSBrZXlJbmRleCAtIGFjY291bnRLZXlzLnN0YXRpY0FjY291bnRLZXlzLmxlbmd0aCA8XG4gICAgICAgICAgLy8gYWNjb3VudEtleXNGcm9tTG9va3VwcyBjYW5ub3QgYmUgdW5kZWZpbmVkIGJlY2F1c2Ugd2UgYWxyZWFkeSBmb3VuZCBhIHB1YmtleSBmb3IgdGhpcyBpbmRleCBhYm92ZVxuICAgICAgICAgIGFjY291bnRLZXlzLmFjY291bnRLZXlzRnJvbUxvb2t1cHMud3JpdGFibGUubGVuZ3RoO1xuICAgICAgICB9XG4gICAgICAgIGtleXMucHVzaCh7XG4gICAgICAgICAgcHVia2V5LFxuICAgICAgICAgIGlzU2lnbmVyOiBrZXlJbmRleCA8IGhlYWRlci5udW1SZXF1aXJlZFNpZ25hdHVyZXMsXG4gICAgICAgICAgaXNXcml0YWJsZVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHByb2dyYW1JZCA9IGFjY291bnRLZXlzLmdldChjb21waWxlZEl4LnByb2dyYW1JZEluZGV4KTtcbiAgICAgIGlmIChwcm9ncmFtSWQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEZhaWxlZCB0byBmaW5kIHByb2dyYW0gaWQgZm9yIHByb2dyYW0gaWQgaW5kZXggJHtjb21waWxlZEl4LnByb2dyYW1JZEluZGV4fWApO1xuICAgICAgfVxuICAgICAgaW5zdHJ1Y3Rpb25zLnB1c2gobmV3IFRyYW5zYWN0aW9uSW5zdHJ1Y3Rpb24oe1xuICAgICAgICBwcm9ncmFtSWQsXG4gICAgICAgIGRhdGE6IHRvQnVmZmVyKGNvbXBpbGVkSXguZGF0YSksXG4gICAgICAgIGtleXNcbiAgICAgIH0pKTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBUcmFuc2FjdGlvbk1lc3NhZ2Uoe1xuICAgICAgcGF5ZXJLZXksXG4gICAgICBpbnN0cnVjdGlvbnMsXG4gICAgICByZWNlbnRCbG9ja2hhc2hcbiAgICB9KTtcbiAgfVxuICBjb21waWxlVG9MZWdhY3lNZXNzYWdlKCkge1xuICAgIHJldHVybiBNZXNzYWdlLmNvbXBpbGUoe1xuICAgICAgcGF5ZXJLZXk6IHRoaXMucGF5ZXJLZXksXG4gICAgICByZWNlbnRCbG9ja2hhc2g6IHRoaXMucmVjZW50QmxvY2toYXNoLFxuICAgICAgaW5zdHJ1Y3Rpb25zOiB0aGlzLmluc3RydWN0aW9uc1xuICAgIH0pO1xuICB9XG4gIGNvbXBpbGVUb1YwTWVzc2FnZShhZGRyZXNzTG9va3VwVGFibGVBY2NvdW50cykge1xuICAgIHJldHVybiBNZXNzYWdlVjAuY29tcGlsZSh7XG4gICAgICBwYXllcktleTogdGhpcy5wYXllcktleSxcbiAgICAgIHJlY2VudEJsb2NraGFzaDogdGhpcy5yZWNlbnRCbG9ja2hhc2gsXG4gICAgICBpbnN0cnVjdGlvbnM6IHRoaXMuaW5zdHJ1Y3Rpb25zLFxuICAgICAgYWRkcmVzc0xvb2t1cFRhYmxlQWNjb3VudHNcbiAgICB9KTtcbiAgfVxufVxuXG4vKipcbiAqIFZlcnNpb25lZCB0cmFuc2FjdGlvbiBjbGFzc1xuICovXG5jbGFzcyBWZXJzaW9uZWRUcmFuc2FjdGlvbiB7XG4gIGdldCB2ZXJzaW9uKCkge1xuICAgIHJldHVybiB0aGlzLm1lc3NhZ2UudmVyc2lvbjtcbiAgfVxuICBjb25zdHJ1Y3RvcihtZXNzYWdlLCBzaWduYXR1cmVzKSB7XG4gICAgdGhpcy5zaWduYXR1cmVzID0gdm9pZCAwO1xuICAgIHRoaXMubWVzc2FnZSA9IHZvaWQgMDtcbiAgICBpZiAoc2lnbmF0dXJlcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBhc3NlcnQoc2lnbmF0dXJlcy5sZW5ndGggPT09IG1lc3NhZ2UuaGVhZGVyLm51bVJlcXVpcmVkU2lnbmF0dXJlcywgJ0V4cGVjdGVkIHNpZ25hdHVyZXMgbGVuZ3RoIHRvIGJlIGVxdWFsIHRvIHRoZSBudW1iZXIgb2YgcmVxdWlyZWQgc2lnbmF0dXJlcycpO1xuICAgICAgdGhpcy5zaWduYXR1cmVzID0gc2lnbmF0dXJlcztcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgZGVmYXVsdFNpZ25hdHVyZXMgPSBbXTtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbWVzc2FnZS5oZWFkZXIubnVtUmVxdWlyZWRTaWduYXR1cmVzOyBpKyspIHtcbiAgICAgICAgZGVmYXVsdFNpZ25hdHVyZXMucHVzaChuZXcgVWludDhBcnJheShTSUdOQVRVUkVfTEVOR1RIX0lOX0JZVEVTKSk7XG4gICAgICB9XG4gICAgICB0aGlzLnNpZ25hdHVyZXMgPSBkZWZhdWx0U2lnbmF0dXJlcztcbiAgICB9XG4gICAgdGhpcy5tZXNzYWdlID0gbWVzc2FnZTtcbiAgfVxuICBzZXJpYWxpemUoKSB7XG4gICAgY29uc3Qgc2VyaWFsaXplZE1lc3NhZ2UgPSB0aGlzLm1lc3NhZ2Uuc2VyaWFsaXplKCk7XG4gICAgY29uc3QgZW5jb2RlZFNpZ25hdHVyZXNMZW5ndGggPSBBcnJheSgpO1xuICAgIGVuY29kZUxlbmd0aChlbmNvZGVkU2lnbmF0dXJlc0xlbmd0aCwgdGhpcy5zaWduYXR1cmVzLmxlbmd0aCk7XG4gICAgY29uc3QgdHJhbnNhY3Rpb25MYXlvdXQgPSBCdWZmZXJMYXlvdXQuc3RydWN0KFtCdWZmZXJMYXlvdXQuYmxvYihlbmNvZGVkU2lnbmF0dXJlc0xlbmd0aC5sZW5ndGgsICdlbmNvZGVkU2lnbmF0dXJlc0xlbmd0aCcpLCBCdWZmZXJMYXlvdXQuc2VxKHNpZ25hdHVyZSgpLCB0aGlzLnNpZ25hdHVyZXMubGVuZ3RoLCAnc2lnbmF0dXJlcycpLCBCdWZmZXJMYXlvdXQuYmxvYihzZXJpYWxpemVkTWVzc2FnZS5sZW5ndGgsICdzZXJpYWxpemVkTWVzc2FnZScpXSk7XG4gICAgY29uc3Qgc2VyaWFsaXplZFRyYW5zYWN0aW9uID0gbmV3IFVpbnQ4QXJyYXkoMjA0OCk7XG4gICAgY29uc3Qgc2VyaWFsaXplZFRyYW5zYWN0aW9uTGVuZ3RoID0gdHJhbnNhY3Rpb25MYXlvdXQuZW5jb2RlKHtcbiAgICAgIGVuY29kZWRTaWduYXR1cmVzTGVuZ3RoOiBuZXcgVWludDhBcnJheShlbmNvZGVkU2lnbmF0dXJlc0xlbmd0aCksXG4gICAgICBzaWduYXR1cmVzOiB0aGlzLnNpZ25hdHVyZXMsXG4gICAgICBzZXJpYWxpemVkTWVzc2FnZVxuICAgIH0sIHNlcmlhbGl6ZWRUcmFuc2FjdGlvbik7XG4gICAgcmV0dXJuIHNlcmlhbGl6ZWRUcmFuc2FjdGlvbi5zbGljZSgwLCBzZXJpYWxpemVkVHJhbnNhY3Rpb25MZW5ndGgpO1xuICB9XG4gIHN0YXRpYyBkZXNlcmlhbGl6ZShzZXJpYWxpemVkVHJhbnNhY3Rpb24pIHtcbiAgICBsZXQgYnl0ZUFycmF5ID0gWy4uLnNlcmlhbGl6ZWRUcmFuc2FjdGlvbl07XG4gICAgY29uc3Qgc2lnbmF0dXJlcyA9IFtdO1xuICAgIGNvbnN0IHNpZ25hdHVyZXNMZW5ndGggPSBkZWNvZGVMZW5ndGgoYnl0ZUFycmF5KTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNpZ25hdHVyZXNMZW5ndGg7IGkrKykge1xuICAgICAgc2lnbmF0dXJlcy5wdXNoKG5ldyBVaW50OEFycmF5KGd1YXJkZWRTcGxpY2UoYnl0ZUFycmF5LCAwLCBTSUdOQVRVUkVfTEVOR1RIX0lOX0JZVEVTKSkpO1xuICAgIH1cbiAgICBjb25zdCBtZXNzYWdlID0gVmVyc2lvbmVkTWVzc2FnZS5kZXNlcmlhbGl6ZShuZXcgVWludDhBcnJheShieXRlQXJyYXkpKTtcbiAgICByZXR1cm4gbmV3IFZlcnNpb25lZFRyYW5zYWN0aW9uKG1lc3NhZ2UsIHNpZ25hdHVyZXMpO1xuICB9XG4gIHNpZ24oc2lnbmVycykge1xuICAgIGNvbnN0IG1lc3NhZ2VEYXRhID0gdGhpcy5tZXNzYWdlLnNlcmlhbGl6ZSgpO1xuICAgIGNvbnN0IHNpZ25lclB1YmtleXMgPSB0aGlzLm1lc3NhZ2Uuc3RhdGljQWNjb3VudEtleXMuc2xpY2UoMCwgdGhpcy5tZXNzYWdlLmhlYWRlci5udW1SZXF1aXJlZFNpZ25hdHVyZXMpO1xuICAgIGZvciAoY29uc3Qgc2lnbmVyIG9mIHNpZ25lcnMpIHtcbiAgICAgIGNvbnN0IHNpZ25lckluZGV4ID0gc2lnbmVyUHVia2V5cy5maW5kSW5kZXgocHVia2V5ID0+IHB1YmtleS5lcXVhbHMoc2lnbmVyLnB1YmxpY0tleSkpO1xuICAgICAgYXNzZXJ0KHNpZ25lckluZGV4ID49IDAsIGBDYW5ub3Qgc2lnbiB3aXRoIG5vbiBzaWduZXIga2V5ICR7c2lnbmVyLnB1YmxpY0tleS50b0Jhc2U1OCgpfWApO1xuICAgICAgdGhpcy5zaWduYXR1cmVzW3NpZ25lckluZGV4XSA9IHNpZ24obWVzc2FnZURhdGEsIHNpZ25lci5zZWNyZXRLZXkpO1xuICAgIH1cbiAgfVxuICBhZGRTaWduYXR1cmUocHVibGljS2V5LCBzaWduYXR1cmUpIHtcbiAgICBhc3NlcnQoc2lnbmF0dXJlLmJ5dGVMZW5ndGggPT09IDY0LCAnU2lnbmF0dXJlIG11c3QgYmUgNjQgYnl0ZXMgbG9uZycpO1xuICAgIGNvbnN0IHNpZ25lclB1YmtleXMgPSB0aGlzLm1lc3NhZ2Uuc3RhdGljQWNjb3VudEtleXMuc2xpY2UoMCwgdGhpcy5tZXNzYWdlLmhlYWRlci5udW1SZXF1aXJlZFNpZ25hdHVyZXMpO1xuICAgIGNvbnN0IHNpZ25lckluZGV4ID0gc2lnbmVyUHVia2V5cy5maW5kSW5kZXgocHVia2V5ID0+IHB1YmtleS5lcXVhbHMocHVibGljS2V5KSk7XG4gICAgYXNzZXJ0KHNpZ25lckluZGV4ID49IDAsIGBDYW4gbm90IGFkZCBzaWduYXR1cmU7IFxcYCR7cHVibGljS2V5LnRvQmFzZTU4KCl9XFxgIGlzIG5vdCByZXF1aXJlZCB0byBzaWduIHRoaXMgdHJhbnNhY3Rpb25gKTtcbiAgICB0aGlzLnNpZ25hdHVyZXNbc2lnbmVySW5kZXhdID0gc2lnbmF0dXJlO1xuICB9XG59XG5cbi8vIFRPRE86IFRoZXNlIGNvbnN0YW50cyBzaG91bGQgYmUgcmVtb3ZlZCBpbiBmYXZvciBvZiByZWFkaW5nIHRoZW0gb3V0IG9mIGFcbi8vIFN5c2NhbGwgYWNjb3VudFxuXG4vKipcbiAqIEBpbnRlcm5hbFxuICovXG5jb25zdCBOVU1fVElDS1NfUEVSX1NFQ09ORCA9IDE2MDtcblxuLyoqXG4gKiBAaW50ZXJuYWxcbiAqL1xuY29uc3QgREVGQVVMVF9USUNLU19QRVJfU0xPVCA9IDY0O1xuXG4vKipcbiAqIEBpbnRlcm5hbFxuICovXG5jb25zdCBOVU1fU0xPVFNfUEVSX1NFQ09ORCA9IE5VTV9USUNLU19QRVJfU0VDT05EIC8gREVGQVVMVF9USUNLU19QRVJfU0xPVDtcblxuLyoqXG4gKiBAaW50ZXJuYWxcbiAqL1xuY29uc3QgTVNfUEVSX1NMT1QgPSAxMDAwIC8gTlVNX1NMT1RTX1BFUl9TRUNPTkQ7XG5cbmNvbnN0IFNZU1ZBUl9DTE9DS19QVUJLRVkgPSBuZXcgUHVibGljS2V5KCdTeXN2YXJDMW9jazExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExJyk7XG5jb25zdCBTWVNWQVJfRVBPQ0hfU0NIRURVTEVfUFVCS0VZID0gbmV3IFB1YmxpY0tleSgnU3lzdmFyRXBvY2hTY2hlZHUxZTExMTExMTExMTExMTExMTExMTExMTExMScpO1xuY29uc3QgU1lTVkFSX0lOU1RSVUNUSU9OU19QVUJLRVkgPSBuZXcgUHVibGljS2V5KCdTeXN2YXIxbnN0cnVjdGlvbnMxMTExMTExMTExMTExMTExMTExMTExMTExJyk7XG5jb25zdCBTWVNWQVJfUkVDRU5UX0JMT0NLSEFTSEVTX1BVQktFWSA9IG5ldyBQdWJsaWNLZXkoJ1N5c3ZhclJlY2VudEIxb2NrSGFzaGVzMTExMTExMTExMTExMTExMTExMTEnKTtcbmNvbnN0IFNZU1ZBUl9SRU5UX1BVQktFWSA9IG5ldyBQdWJsaWNLZXkoJ1N5c3ZhclJlbnQxMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTEnKTtcbmNvbnN0IFNZU1ZBUl9SRVdBUkRTX1BVQktFWSA9IG5ldyBQdWJsaWNLZXkoJ1N5c3ZhclJld2FyZHMxMTExMTExMTExMTExMTExMTExMTExMTExMTExMTEnKTtcbmNvbnN0IFNZU1ZBUl9TTE9UX0hBU0hFU19QVUJLRVkgPSBuZXcgUHVibGljS2V5KCdTeXN2YXJTMW90SGFzaGVzMTExMTExMTExMTExMTExMTExMTExMTExMTExJyk7XG5jb25zdCBTWVNWQVJfU0xPVF9ISVNUT1JZX1BVQktFWSA9IG5ldyBQdWJsaWNLZXkoJ1N5c3ZhclMxb3RIaXN0b3J5MTExMTExMTExMTExMTExMTExMTExMTExMTEnKTtcbmNvbnN0IFNZU1ZBUl9TVEFLRV9ISVNUT1JZX1BVQktFWSA9IG5ldyBQdWJsaWNLZXkoJ1N5c3ZhclN0YWtlSGlzdG9yeTExMTExMTExMTExMTExMTExMTExMTExMTEnKTtcblxuLyoqXG4gKiBTaWduLCBzZW5kIGFuZCBjb25maXJtIGEgdHJhbnNhY3Rpb24uXG4gKlxuICogSWYgYGNvbW1pdG1lbnRgIG9wdGlvbiBpcyBub3Qgc3BlY2lmaWVkLCBkZWZhdWx0cyB0byAnbWF4JyBjb21taXRtZW50LlxuICpcbiAqIEBwYXJhbSB7Q29ubmVjdGlvbn0gY29ubmVjdGlvblxuICogQHBhcmFtIHtUcmFuc2FjdGlvbn0gdHJhbnNhY3Rpb25cbiAqIEBwYXJhbSB7QXJyYXk8U2lnbmVyPn0gc2lnbmVyc1xuICogQHBhcmFtIHtDb25maXJtT3B0aW9uc30gW29wdGlvbnNdXG4gKiBAcmV0dXJucyB7UHJvbWlzZTxUcmFuc2FjdGlvblNpZ25hdHVyZT59XG4gKi9cbmFzeW5jIGZ1bmN0aW9uIHNlbmRBbmRDb25maXJtVHJhbnNhY3Rpb24oY29ubmVjdGlvbiwgdHJhbnNhY3Rpb24sIHNpZ25lcnMsIG9wdGlvbnMpIHtcbiAgY29uc3Qgc2VuZE9wdGlvbnMgPSBvcHRpb25zICYmIHtcbiAgICBza2lwUHJlZmxpZ2h0OiBvcHRpb25zLnNraXBQcmVmbGlnaHQsXG4gICAgcHJlZmxpZ2h0Q29tbWl0bWVudDogb3B0aW9ucy5wcmVmbGlnaHRDb21taXRtZW50IHx8IG9wdGlvbnMuY29tbWl0bWVudCxcbiAgICBtYXhSZXRyaWVzOiBvcHRpb25zLm1heFJldHJpZXMsXG4gICAgbWluQ29udGV4dFNsb3Q6IG9wdGlvbnMubWluQ29udGV4dFNsb3RcbiAgfTtcbiAgY29uc3Qgc2lnbmF0dXJlID0gYXdhaXQgY29ubmVjdGlvbi5zZW5kVHJhbnNhY3Rpb24odHJhbnNhY3Rpb24sIHNpZ25lcnMsIHNlbmRPcHRpb25zKTtcbiAgbGV0IHN0YXR1cztcbiAgaWYgKHRyYW5zYWN0aW9uLnJlY2VudEJsb2NraGFzaCAhPSBudWxsICYmIHRyYW5zYWN0aW9uLmxhc3RWYWxpZEJsb2NrSGVpZ2h0ICE9IG51bGwpIHtcbiAgICBzdGF0dXMgPSAoYXdhaXQgY29ubmVjdGlvbi5jb25maXJtVHJhbnNhY3Rpb24oe1xuICAgICAgYWJvcnRTaWduYWw6IG9wdGlvbnM/LmFib3J0U2lnbmFsLFxuICAgICAgc2lnbmF0dXJlOiBzaWduYXR1cmUsXG4gICAgICBibG9ja2hhc2g6IHRyYW5zYWN0aW9uLnJlY2VudEJsb2NraGFzaCxcbiAgICAgIGxhc3RWYWxpZEJsb2NrSGVpZ2h0OiB0cmFuc2FjdGlvbi5sYXN0VmFsaWRCbG9ja0hlaWdodFxuICAgIH0sIG9wdGlvbnMgJiYgb3B0aW9ucy5jb21taXRtZW50KSkudmFsdWU7XG4gIH0gZWxzZSBpZiAodHJhbnNhY3Rpb24ubWluTm9uY2VDb250ZXh0U2xvdCAhPSBudWxsICYmIHRyYW5zYWN0aW9uLm5vbmNlSW5mbyAhPSBudWxsKSB7XG4gICAgY29uc3Qge1xuICAgICAgbm9uY2VJbnN0cnVjdGlvblxuICAgIH0gPSB0cmFuc2FjdGlvbi5ub25jZUluZm87XG4gICAgY29uc3Qgbm9uY2VBY2NvdW50UHVia2V5ID0gbm9uY2VJbnN0cnVjdGlvbi5rZXlzWzBdLnB1YmtleTtcbiAgICBzdGF0dXMgPSAoYXdhaXQgY29ubmVjdGlvbi5jb25maXJtVHJhbnNhY3Rpb24oe1xuICAgICAgYWJvcnRTaWduYWw6IG9wdGlvbnM/LmFib3J0U2lnbmFsLFxuICAgICAgbWluQ29udGV4dFNsb3Q6IHRyYW5zYWN0aW9uLm1pbk5vbmNlQ29udGV4dFNsb3QsXG4gICAgICBub25jZUFjY291bnRQdWJrZXksXG4gICAgICBub25jZVZhbHVlOiB0cmFuc2FjdGlvbi5ub25jZUluZm8ubm9uY2UsXG4gICAgICBzaWduYXR1cmVcbiAgICB9LCBvcHRpb25zICYmIG9wdGlvbnMuY29tbWl0bWVudCkpLnZhbHVlO1xuICB9IGVsc2Uge1xuICAgIGlmIChvcHRpb25zPy5hYm9ydFNpZ25hbCAhPSBudWxsKSB7XG4gICAgICBjb25zb2xlLndhcm4oJ3NlbmRBbmRDb25maXJtVHJhbnNhY3Rpb24oKTogQSB0cmFuc2FjdGlvbiB3aXRoIGEgZGVwcmVjYXRlZCBjb25maXJtYXRpb24gc3RyYXRlZ3kgd2FzICcgKyAnc3VwcGxpZWQgYWxvbmcgd2l0aCBhbiBgYWJvcnRTaWduYWxgLiBPbmx5IHRyYW5zYWN0aW9ucyBoYXZpbmcgYGxhc3RWYWxpZEJsb2NrSGVpZ2h0YCAnICsgJ29yIGEgY29tYmluYXRpb24gb2YgYG5vbmNlSW5mb2AgYW5kIGBtaW5Ob25jZUNvbnRleHRTbG90YCBhcmUgYWJvcnRhYmxlLicpO1xuICAgIH1cbiAgICBzdGF0dXMgPSAoYXdhaXQgY29ubmVjdGlvbi5jb25maXJtVHJhbnNhY3Rpb24oc2lnbmF0dXJlLCBvcHRpb25zICYmIG9wdGlvbnMuY29tbWl0bWVudCkpLnZhbHVlO1xuICB9XG4gIGlmIChzdGF0dXMuZXJyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBUcmFuc2FjdGlvbiAke3NpZ25hdHVyZX0gZmFpbGVkICgke0pTT04uc3RyaW5naWZ5KHN0YXR1cyl9KWApO1xuICB9XG4gIHJldHVybiBzaWduYXR1cmU7XG59XG5cbi8vIHp6elxuZnVuY3Rpb24gc2xlZXAobXMpIHtcbiAgcmV0dXJuIG5ldyBQcm9taXNlKHJlc29sdmUgPT4gc2V0VGltZW91dChyZXNvbHZlLCBtcykpO1xufVxuXG4vKipcbiAqIEBpbnRlcm5hbFxuICovXG5cbi8qKlxuICogUG9wdWxhdGUgYSBidWZmZXIgb2YgaW5zdHJ1Y3Rpb24gZGF0YSB1c2luZyBhbiBJbnN0cnVjdGlvblR5cGVcbiAqIEBpbnRlcm5hbFxuICovXG5mdW5jdGlvbiBlbmNvZGVEYXRhKHR5cGUsIGZpZWxkcykge1xuICBjb25zdCBhbGxvY0xlbmd0aCA9IHR5cGUubGF5b3V0LnNwYW4gPj0gMCA/IHR5cGUubGF5b3V0LnNwYW4gOiBnZXRBbGxvYyh0eXBlLCBmaWVsZHMpO1xuICBjb25zdCBkYXRhID0gQnVmZmVyLmFsbG9jKGFsbG9jTGVuZ3RoKTtcbiAgY29uc3QgbGF5b3V0RmllbGRzID0gT2JqZWN0LmFzc2lnbih7XG4gICAgaW5zdHJ1Y3Rpb246IHR5cGUuaW5kZXhcbiAgfSwgZmllbGRzKTtcbiAgdHlwZS5sYXlvdXQuZW5jb2RlKGxheW91dEZpZWxkcywgZGF0YSk7XG4gIHJldHVybiBkYXRhO1xufVxuXG4vKipcbiAqIERlY29kZSBpbnN0cnVjdGlvbiBkYXRhIGJ1ZmZlciB1c2luZyBhbiBJbnN0cnVjdGlvblR5cGVcbiAqIEBpbnRlcm5hbFxuICovXG5mdW5jdGlvbiBkZWNvZGVEYXRhJDEodHlwZSwgYnVmZmVyKSB7XG4gIGxldCBkYXRhO1xuICB0cnkge1xuICAgIGRhdGEgPSB0eXBlLmxheW91dC5kZWNvZGUoYnVmZmVyKTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIGluc3RydWN0aW9uOyAnICsgZXJyKTtcbiAgfVxuICBpZiAoZGF0YS5pbnN0cnVjdGlvbiAhPT0gdHlwZS5pbmRleCkge1xuICAgIHRocm93IG5ldyBFcnJvcihgaW52YWxpZCBpbnN0cnVjdGlvbjsgaW5zdHJ1Y3Rpb24gaW5kZXggbWlzbWF0Y2ggJHtkYXRhLmluc3RydWN0aW9ufSAhPSAke3R5cGUuaW5kZXh9YCk7XG4gIH1cbiAgcmV0dXJuIGRhdGE7XG59XG5cbi8qKlxuICogaHR0cHM6Ly9naXRodWIuY29tL3NvbGFuYS1sYWJzL3NvbGFuYS9ibG9iLzkwYmVkZDdlMDY3YjViOGYzZGRiYjQ1ZGEwMGE0ZTljYWJiMjJjNjIvc2RrL3NyYy9mZWVfY2FsY3VsYXRvci5ycyNMNy1MMTFcbiAqXG4gKiBAaW50ZXJuYWxcbiAqL1xuY29uc3QgRmVlQ2FsY3VsYXRvckxheW91dCA9IEJ1ZmZlckxheW91dC5udTY0KCdsYW1wb3J0c1BlclNpZ25hdHVyZScpO1xuXG4vKipcbiAqIENhbGN1bGF0b3IgZm9yIHRyYW5zYWN0aW9uIGZlZXMuXG4gKlxuICogQGRlcHJlY2F0ZWQgRGVwcmVjYXRlZCBzaW5jZSBTb2xhbmEgdjEuOC4wLlxuICovXG5cbi8qKlxuICogU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9zb2xhbmEtbGFicy9zb2xhbmEvYmxvYi8wZWEyODQzZWM5Y2RjNTE3NTcyYjhlNjJjOTU5ZjQxYjU1Y2Y0NDUzL3Nkay9zcmMvbm9uY2Vfc3RhdGUucnMjTDI5LUwzMlxuICpcbiAqIEBpbnRlcm5hbFxuICovXG5jb25zdCBOb25jZUFjY291bnRMYXlvdXQgPSBCdWZmZXJMYXlvdXQuc3RydWN0KFtCdWZmZXJMYXlvdXQudTMyKCd2ZXJzaW9uJyksIEJ1ZmZlckxheW91dC51MzIoJ3N0YXRlJyksIHB1YmxpY0tleSgnYXV0aG9yaXplZFB1YmtleScpLCBwdWJsaWNLZXkoJ25vbmNlJyksIEJ1ZmZlckxheW91dC5zdHJ1Y3QoW0ZlZUNhbGN1bGF0b3JMYXlvdXRdLCAnZmVlQ2FsY3VsYXRvcicpXSk7XG5jb25zdCBOT05DRV9BQ0NPVU5UX0xFTkdUSCA9IE5vbmNlQWNjb3VudExheW91dC5zcGFuO1xuXG4vKipcbiAqIEEgZHVyYWJsZSBub25jZSBpcyBhIDMyIGJ5dGUgdmFsdWUgZW5jb2RlZCBhcyBhIGJhc2U1OCBzdHJpbmcuXG4gKi9cblxuLyoqXG4gKiBOb25jZUFjY291bnQgY2xhc3NcbiAqL1xuY2xhc3MgTm9uY2VBY2NvdW50IHtcbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgY29uc3RydWN0b3IoYXJncykge1xuICAgIHRoaXMuYXV0aG9yaXplZFB1YmtleSA9IHZvaWQgMDtcbiAgICB0aGlzLm5vbmNlID0gdm9pZCAwO1xuICAgIHRoaXMuZmVlQ2FsY3VsYXRvciA9IHZvaWQgMDtcbiAgICB0aGlzLmF1dGhvcml6ZWRQdWJrZXkgPSBhcmdzLmF1dGhvcml6ZWRQdWJrZXk7XG4gICAgdGhpcy5ub25jZSA9IGFyZ3Mubm9uY2U7XG4gICAgdGhpcy5mZWVDYWxjdWxhdG9yID0gYXJncy5mZWVDYWxjdWxhdG9yO1xuICB9XG5cbiAgLyoqXG4gICAqIERlc2VyaWFsaXplIE5vbmNlQWNjb3VudCBmcm9tIHRoZSBhY2NvdW50IGRhdGEuXG4gICAqXG4gICAqIEBwYXJhbSBidWZmZXIgYWNjb3VudCBkYXRhXG4gICAqIEByZXR1cm4gTm9uY2VBY2NvdW50XG4gICAqL1xuICBzdGF0aWMgZnJvbUFjY291bnREYXRhKGJ1ZmZlcikge1xuICAgIGNvbnN0IG5vbmNlQWNjb3VudCA9IE5vbmNlQWNjb3VudExheW91dC5kZWNvZGUodG9CdWZmZXIoYnVmZmVyKSwgMCk7XG4gICAgcmV0dXJuIG5ldyBOb25jZUFjY291bnQoe1xuICAgICAgYXV0aG9yaXplZFB1YmtleTogbmV3IFB1YmxpY0tleShub25jZUFjY291bnQuYXV0aG9yaXplZFB1YmtleSksXG4gICAgICBub25jZTogbmV3IFB1YmxpY0tleShub25jZUFjY291bnQubm9uY2UpLnRvU3RyaW5nKCksXG4gICAgICBmZWVDYWxjdWxhdG9yOiBub25jZUFjY291bnQuZmVlQ2FsY3VsYXRvclxuICAgIH0pO1xuICB9XG59XG5cbmNvbnN0IGVuY29kZURlY29kZSA9IGxheW91dCA9PiB7XG4gIGNvbnN0IGRlY29kZSA9IGxheW91dC5kZWNvZGUuYmluZChsYXlvdXQpO1xuICBjb25zdCBlbmNvZGUgPSBsYXlvdXQuZW5jb2RlLmJpbmQobGF5b3V0KTtcbiAgcmV0dXJuIHtcbiAgICBkZWNvZGUsXG4gICAgZW5jb2RlXG4gIH07XG59O1xuY29uc3QgYmlnSW50ID0gbGVuZ3RoID0+IHByb3BlcnR5ID0+IHtcbiAgY29uc3QgbGF5b3V0ID0gYmxvYihsZW5ndGgsIHByb3BlcnR5KTtcbiAgY29uc3Qge1xuICAgIGVuY29kZSxcbiAgICBkZWNvZGVcbiAgfSA9IGVuY29kZURlY29kZShsYXlvdXQpO1xuICBjb25zdCBiaWdJbnRMYXlvdXQgPSBsYXlvdXQ7XG4gIGJpZ0ludExheW91dC5kZWNvZGUgPSAoYnVmZmVyLCBvZmZzZXQpID0+IHtcbiAgICBjb25zdCBzcmMgPSBkZWNvZGUoYnVmZmVyLCBvZmZzZXQpO1xuICAgIHJldHVybiB0b0JpZ0ludExFKEJ1ZmZlci5mcm9tKHNyYykpO1xuICB9O1xuICBiaWdJbnRMYXlvdXQuZW5jb2RlID0gKGJpZ0ludCwgYnVmZmVyLCBvZmZzZXQpID0+IHtcbiAgICBjb25zdCBzcmMgPSB0b0J1ZmZlckxFKGJpZ0ludCwgbGVuZ3RoKTtcbiAgICByZXR1cm4gZW5jb2RlKHNyYywgYnVmZmVyLCBvZmZzZXQpO1xuICB9O1xuICByZXR1cm4gYmlnSW50TGF5b3V0O1xufTtcbmNvbnN0IHU2NCA9IGJpZ0ludCg4KTtcblxuLyoqXG4gKiBDcmVhdGUgYWNjb3VudCBzeXN0ZW0gdHJhbnNhY3Rpb24gcGFyYW1zXG4gKi9cblxuLyoqXG4gKiBUcmFuc2ZlciBzeXN0ZW0gdHJhbnNhY3Rpb24gcGFyYW1zXG4gKi9cblxuLyoqXG4gKiBBc3NpZ24gc3lzdGVtIHRyYW5zYWN0aW9uIHBhcmFtc1xuICovXG5cbi8qKlxuICogQ3JlYXRlIGFjY291bnQgd2l0aCBzZWVkIHN5c3RlbSB0cmFuc2FjdGlvbiBwYXJhbXNcbiAqL1xuXG4vKipcbiAqIENyZWF0ZSBub25jZSBhY2NvdW50IHN5c3RlbSB0cmFuc2FjdGlvbiBwYXJhbXNcbiAqL1xuXG4vKipcbiAqIENyZWF0ZSBub25jZSBhY2NvdW50IHdpdGggc2VlZCBzeXN0ZW0gdHJhbnNhY3Rpb24gcGFyYW1zXG4gKi9cblxuLyoqXG4gKiBJbml0aWFsaXplIG5vbmNlIGFjY291bnQgc3lzdGVtIGluc3RydWN0aW9uIHBhcmFtc1xuICovXG5cbi8qKlxuICogQWR2YW5jZSBub25jZSBhY2NvdW50IHN5c3RlbSBpbnN0cnVjdGlvbiBwYXJhbXNcbiAqL1xuXG4vKipcbiAqIFdpdGhkcmF3IG5vbmNlIGFjY291bnQgc3lzdGVtIHRyYW5zYWN0aW9uIHBhcmFtc1xuICovXG5cbi8qKlxuICogQXV0aG9yaXplIG5vbmNlIGFjY291bnQgc3lzdGVtIHRyYW5zYWN0aW9uIHBhcmFtc1xuICovXG5cbi8qKlxuICogQWxsb2NhdGUgYWNjb3VudCBzeXN0ZW0gdHJhbnNhY3Rpb24gcGFyYW1zXG4gKi9cblxuLyoqXG4gKiBBbGxvY2F0ZSBhY2NvdW50IHdpdGggc2VlZCBzeXN0ZW0gdHJhbnNhY3Rpb24gcGFyYW1zXG4gKi9cblxuLyoqXG4gKiBBc3NpZ24gYWNjb3VudCB3aXRoIHNlZWQgc3lzdGVtIHRyYW5zYWN0aW9uIHBhcmFtc1xuICovXG5cbi8qKlxuICogVHJhbnNmZXIgd2l0aCBzZWVkIHN5c3RlbSB0cmFuc2FjdGlvbiBwYXJhbXNcbiAqL1xuXG4vKiogRGVjb2RlZCB0cmFuc2ZlciBzeXN0ZW0gdHJhbnNhY3Rpb24gaW5zdHJ1Y3Rpb24gKi9cblxuLyoqIERlY29kZWQgdHJhbnNmZXJXaXRoU2VlZCBzeXN0ZW0gdHJhbnNhY3Rpb24gaW5zdHJ1Y3Rpb24gKi9cblxuLyoqXG4gKiBTeXN0ZW0gSW5zdHJ1Y3Rpb24gY2xhc3NcbiAqL1xuY2xhc3MgU3lzdGVtSW5zdHJ1Y3Rpb24ge1xuICAvKipcbiAgICogQGludGVybmFsXG4gICAqL1xuICBjb25zdHJ1Y3RvcigpIHt9XG5cbiAgLyoqXG4gICAqIERlY29kZSBhIHN5c3RlbSBpbnN0cnVjdGlvbiBhbmQgcmV0cmlldmUgdGhlIGluc3RydWN0aW9uIHR5cGUuXG4gICAqL1xuICBzdGF0aWMgZGVjb2RlSW5zdHJ1Y3Rpb25UeXBlKGluc3RydWN0aW9uKSB7XG4gICAgdGhpcy5jaGVja1Byb2dyYW1JZChpbnN0cnVjdGlvbi5wcm9ncmFtSWQpO1xuICAgIGNvbnN0IGluc3RydWN0aW9uVHlwZUxheW91dCA9IEJ1ZmZlckxheW91dC51MzIoJ2luc3RydWN0aW9uJyk7XG4gICAgY29uc3QgdHlwZUluZGV4ID0gaW5zdHJ1Y3Rpb25UeXBlTGF5b3V0LmRlY29kZShpbnN0cnVjdGlvbi5kYXRhKTtcbiAgICBsZXQgdHlwZTtcbiAgICBmb3IgKGNvbnN0IFtpeFR5cGUsIGxheW91dF0gb2YgT2JqZWN0LmVudHJpZXMoU1lTVEVNX0lOU1RSVUNUSU9OX0xBWU9VVFMpKSB7XG4gICAgICBpZiAobGF5b3V0LmluZGV4ID09IHR5cGVJbmRleCkge1xuICAgICAgICB0eXBlID0gaXhUeXBlO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKCF0eXBlKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0luc3RydWN0aW9uIHR5cGUgaW5jb3JyZWN0OyBub3QgYSBTeXN0ZW1JbnN0cnVjdGlvbicpO1xuICAgIH1cbiAgICByZXR1cm4gdHlwZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZWNvZGUgYSBjcmVhdGUgYWNjb3VudCBzeXN0ZW0gaW5zdHJ1Y3Rpb24gYW5kIHJldHJpZXZlIHRoZSBpbnN0cnVjdGlvbiBwYXJhbXMuXG4gICAqL1xuICBzdGF0aWMgZGVjb2RlQ3JlYXRlQWNjb3VudChpbnN0cnVjdGlvbikge1xuICAgIHRoaXMuY2hlY2tQcm9ncmFtSWQoaW5zdHJ1Y3Rpb24ucHJvZ3JhbUlkKTtcbiAgICB0aGlzLmNoZWNrS2V5TGVuZ3RoKGluc3RydWN0aW9uLmtleXMsIDIpO1xuICAgIGNvbnN0IHtcbiAgICAgIGxhbXBvcnRzLFxuICAgICAgc3BhY2UsXG4gICAgICBwcm9ncmFtSWRcbiAgICB9ID0gZGVjb2RlRGF0YSQxKFNZU1RFTV9JTlNUUlVDVElPTl9MQVlPVVRTLkNyZWF0ZSwgaW5zdHJ1Y3Rpb24uZGF0YSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIGZyb21QdWJrZXk6IGluc3RydWN0aW9uLmtleXNbMF0ucHVia2V5LFxuICAgICAgbmV3QWNjb3VudFB1YmtleTogaW5zdHJ1Y3Rpb24ua2V5c1sxXS5wdWJrZXksXG4gICAgICBsYW1wb3J0cyxcbiAgICAgIHNwYWNlLFxuICAgICAgcHJvZ3JhbUlkOiBuZXcgUHVibGljS2V5KHByb2dyYW1JZClcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIERlY29kZSBhIHRyYW5zZmVyIHN5c3RlbSBpbnN0cnVjdGlvbiBhbmQgcmV0cmlldmUgdGhlIGluc3RydWN0aW9uIHBhcmFtcy5cbiAgICovXG4gIHN0YXRpYyBkZWNvZGVUcmFuc2ZlcihpbnN0cnVjdGlvbikge1xuICAgIHRoaXMuY2hlY2tQcm9ncmFtSWQoaW5zdHJ1Y3Rpb24ucHJvZ3JhbUlkKTtcbiAgICB0aGlzLmNoZWNrS2V5TGVuZ3RoKGluc3RydWN0aW9uLmtleXMsIDIpO1xuICAgIGNvbnN0IHtcbiAgICAgIGxhbXBvcnRzXG4gICAgfSA9IGRlY29kZURhdGEkMShTWVNURU1fSU5TVFJVQ1RJT05fTEFZT1VUUy5UcmFuc2ZlciwgaW5zdHJ1Y3Rpb24uZGF0YSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIGZyb21QdWJrZXk6IGluc3RydWN0aW9uLmtleXNbMF0ucHVia2V5LFxuICAgICAgdG9QdWJrZXk6IGluc3RydWN0aW9uLmtleXNbMV0ucHVia2V5LFxuICAgICAgbGFtcG9ydHNcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIERlY29kZSBhIHRyYW5zZmVyIHdpdGggc2VlZCBzeXN0ZW0gaW5zdHJ1Y3Rpb24gYW5kIHJldHJpZXZlIHRoZSBpbnN0cnVjdGlvbiBwYXJhbXMuXG4gICAqL1xuICBzdGF0aWMgZGVjb2RlVHJhbnNmZXJXaXRoU2VlZChpbnN0cnVjdGlvbikge1xuICAgIHRoaXMuY2hlY2tQcm9ncmFtSWQoaW5zdHJ1Y3Rpb24ucHJvZ3JhbUlkKTtcbiAgICB0aGlzLmNoZWNrS2V5TGVuZ3RoKGluc3RydWN0aW9uLmtleXMsIDMpO1xuICAgIGNvbnN0IHtcbiAgICAgIGxhbXBvcnRzLFxuICAgICAgc2VlZCxcbiAgICAgIHByb2dyYW1JZFxuICAgIH0gPSBkZWNvZGVEYXRhJDEoU1lTVEVNX0lOU1RSVUNUSU9OX0xBWU9VVFMuVHJhbnNmZXJXaXRoU2VlZCwgaW5zdHJ1Y3Rpb24uZGF0YSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIGZyb21QdWJrZXk6IGluc3RydWN0aW9uLmtleXNbMF0ucHVia2V5LFxuICAgICAgYmFzZVB1YmtleTogaW5zdHJ1Y3Rpb24ua2V5c1sxXS5wdWJrZXksXG4gICAgICB0b1B1YmtleTogaW5zdHJ1Y3Rpb24ua2V5c1syXS5wdWJrZXksXG4gICAgICBsYW1wb3J0cyxcbiAgICAgIHNlZWQsXG4gICAgICBwcm9ncmFtSWQ6IG5ldyBQdWJsaWNLZXkocHJvZ3JhbUlkKVxuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogRGVjb2RlIGFuIGFsbG9jYXRlIHN5c3RlbSBpbnN0cnVjdGlvbiBhbmQgcmV0cmlldmUgdGhlIGluc3RydWN0aW9uIHBhcmFtcy5cbiAgICovXG4gIHN0YXRpYyBkZWNvZGVBbGxvY2F0ZShpbnN0cnVjdGlvbikge1xuICAgIHRoaXMuY2hlY2tQcm9ncmFtSWQoaW5zdHJ1Y3Rpb24ucHJvZ3JhbUlkKTtcbiAgICB0aGlzLmNoZWNrS2V5TGVuZ3RoKGluc3RydWN0aW9uLmtleXMsIDEpO1xuICAgIGNvbnN0IHtcbiAgICAgIHNwYWNlXG4gICAgfSA9IGRlY29kZURhdGEkMShTWVNURU1fSU5TVFJVQ1RJT05fTEFZT1VUUy5BbGxvY2F0ZSwgaW5zdHJ1Y3Rpb24uZGF0YSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIGFjY291bnRQdWJrZXk6IGluc3RydWN0aW9uLmtleXNbMF0ucHVia2V5LFxuICAgICAgc3BhY2VcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIERlY29kZSBhbiBhbGxvY2F0ZSB3aXRoIHNlZWQgc3lzdGVtIGluc3RydWN0aW9uIGFuZCByZXRyaWV2ZSB0aGUgaW5zdHJ1Y3Rpb24gcGFyYW1zLlxuICAgKi9cbiAgc3RhdGljIGRlY29kZUFsbG9jYXRlV2l0aFNlZWQoaW5zdHJ1Y3Rpb24pIHtcbiAgICB0aGlzLmNoZWNrUHJvZ3JhbUlkKGluc3RydWN0aW9uLnByb2dyYW1JZCk7XG4gICAgdGhpcy5jaGVja0tleUxlbmd0aChpbnN0cnVjdGlvbi5rZXlzLCAxKTtcbiAgICBjb25zdCB7XG4gICAgICBiYXNlLFxuICAgICAgc2VlZCxcbiAgICAgIHNwYWNlLFxuICAgICAgcHJvZ3JhbUlkXG4gICAgfSA9IGRlY29kZURhdGEkMShTWVNURU1fSU5TVFJVQ1RJT05fTEFZT1VUUy5BbGxvY2F0ZVdpdGhTZWVkLCBpbnN0cnVjdGlvbi5kYXRhKTtcbiAgICByZXR1cm4ge1xuICAgICAgYWNjb3VudFB1YmtleTogaW5zdHJ1Y3Rpb24ua2V5c1swXS5wdWJrZXksXG4gICAgICBiYXNlUHVia2V5OiBuZXcgUHVibGljS2V5KGJhc2UpLFxuICAgICAgc2VlZCxcbiAgICAgIHNwYWNlLFxuICAgICAgcHJvZ3JhbUlkOiBuZXcgUHVibGljS2V5KHByb2dyYW1JZClcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIERlY29kZSBhbiBhc3NpZ24gc3lzdGVtIGluc3RydWN0aW9uIGFuZCByZXRyaWV2ZSB0aGUgaW5zdHJ1Y3Rpb24gcGFyYW1zLlxuICAgKi9cbiAgc3RhdGljIGRlY29kZUFzc2lnbihpbnN0cnVjdGlvbikge1xuICAgIHRoaXMuY2hlY2tQcm9ncmFtSWQoaW5zdHJ1Y3Rpb24ucHJvZ3JhbUlkKTtcbiAgICB0aGlzLmNoZWNrS2V5TGVuZ3RoKGluc3RydWN0aW9uLmtleXMsIDEpO1xuICAgIGNvbnN0IHtcbiAgICAgIHByb2dyYW1JZFxuICAgIH0gPSBkZWNvZGVEYXRhJDEoU1lTVEVNX0lOU1RSVUNUSU9OX0xBWU9VVFMuQXNzaWduLCBpbnN0cnVjdGlvbi5kYXRhKTtcbiAgICByZXR1cm4ge1xuICAgICAgYWNjb3VudFB1YmtleTogaW5zdHJ1Y3Rpb24ua2V5c1swXS5wdWJrZXksXG4gICAgICBwcm9ncmFtSWQ6IG5ldyBQdWJsaWNLZXkocHJvZ3JhbUlkKVxuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogRGVjb2RlIGFuIGFzc2lnbiB3aXRoIHNlZWQgc3lzdGVtIGluc3RydWN0aW9uIGFuZCByZXRyaWV2ZSB0aGUgaW5zdHJ1Y3Rpb24gcGFyYW1zLlxuICAgKi9cbiAgc3RhdGljIGRlY29kZUFzc2lnbldpdGhTZWVkKGluc3RydWN0aW9uKSB7XG4gICAgdGhpcy5jaGVja1Byb2dyYW1JZChpbnN0cnVjdGlvbi5wcm9ncmFtSWQpO1xuICAgIHRoaXMuY2hlY2tLZXlMZW5ndGgoaW5zdHJ1Y3Rpb24ua2V5cywgMSk7XG4gICAgY29uc3Qge1xuICAgICAgYmFzZSxcbiAgICAgIHNlZWQsXG4gICAgICBwcm9ncmFtSWRcbiAgICB9ID0gZGVjb2RlRGF0YSQxKFNZU1RFTV9JTlNUUlVDVElPTl9MQVlPVVRTLkFzc2lnbldpdGhTZWVkLCBpbnN0cnVjdGlvbi5kYXRhKTtcbiAgICByZXR1cm4ge1xuICAgICAgYWNjb3VudFB1YmtleTogaW5zdHJ1Y3Rpb24ua2V5c1swXS5wdWJrZXksXG4gICAgICBiYXNlUHVia2V5OiBuZXcgUHVibGljS2V5KGJhc2UpLFxuICAgICAgc2VlZCxcbiAgICAgIHByb2dyYW1JZDogbmV3IFB1YmxpY0tleShwcm9ncmFtSWQpXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZWNvZGUgYSBjcmVhdGUgYWNjb3VudCB3aXRoIHNlZWQgc3lzdGVtIGluc3RydWN0aW9uIGFuZCByZXRyaWV2ZSB0aGUgaW5zdHJ1Y3Rpb24gcGFyYW1zLlxuICAgKi9cbiAgc3RhdGljIGRlY29kZUNyZWF0ZVdpdGhTZWVkKGluc3RydWN0aW9uKSB7XG4gICAgdGhpcy5jaGVja1Byb2dyYW1JZChpbnN0cnVjdGlvbi5wcm9ncmFtSWQpO1xuICAgIHRoaXMuY2hlY2tLZXlMZW5ndGgoaW5zdHJ1Y3Rpb24ua2V5cywgMik7XG4gICAgY29uc3Qge1xuICAgICAgYmFzZSxcbiAgICAgIHNlZWQsXG4gICAgICBsYW1wb3J0cyxcbiAgICAgIHNwYWNlLFxuICAgICAgcHJvZ3JhbUlkXG4gICAgfSA9IGRlY29kZURhdGEkMShTWVNURU1fSU5TVFJVQ1RJT05fTEFZT1VUUy5DcmVhdGVXaXRoU2VlZCwgaW5zdHJ1Y3Rpb24uZGF0YSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIGZyb21QdWJrZXk6IGluc3RydWN0aW9uLmtleXNbMF0ucHVia2V5LFxuICAgICAgbmV3QWNjb3VudFB1YmtleTogaW5zdHJ1Y3Rpb24ua2V5c1sxXS5wdWJrZXksXG4gICAgICBiYXNlUHVia2V5OiBuZXcgUHVibGljS2V5KGJhc2UpLFxuICAgICAgc2VlZCxcbiAgICAgIGxhbXBvcnRzLFxuICAgICAgc3BhY2UsXG4gICAgICBwcm9ncmFtSWQ6IG5ldyBQdWJsaWNLZXkocHJvZ3JhbUlkKVxuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogRGVjb2RlIGEgbm9uY2UgaW5pdGlhbGl6ZSBzeXN0ZW0gaW5zdHJ1Y3Rpb24gYW5kIHJldHJpZXZlIHRoZSBpbnN0cnVjdGlvbiBwYXJhbXMuXG4gICAqL1xuICBzdGF0aWMgZGVjb2RlTm9uY2VJbml0aWFsaXplKGluc3RydWN0aW9uKSB7XG4gICAgdGhpcy5jaGVja1Byb2dyYW1JZChpbnN0cnVjdGlvbi5wcm9ncmFtSWQpO1xuICAgIHRoaXMuY2hlY2tLZXlMZW5ndGgoaW5zdHJ1Y3Rpb24ua2V5cywgMyk7XG4gICAgY29uc3Qge1xuICAgICAgYXV0aG9yaXplZFxuICAgIH0gPSBkZWNvZGVEYXRhJDEoU1lTVEVNX0lOU1RSVUNUSU9OX0xBWU9VVFMuSW5pdGlhbGl6ZU5vbmNlQWNjb3VudCwgaW5zdHJ1Y3Rpb24uZGF0YSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIG5vbmNlUHVia2V5OiBpbnN0cnVjdGlvbi5rZXlzWzBdLnB1YmtleSxcbiAgICAgIGF1dGhvcml6ZWRQdWJrZXk6IG5ldyBQdWJsaWNLZXkoYXV0aG9yaXplZClcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIERlY29kZSBhIG5vbmNlIGFkdmFuY2Ugc3lzdGVtIGluc3RydWN0aW9uIGFuZCByZXRyaWV2ZSB0aGUgaW5zdHJ1Y3Rpb24gcGFyYW1zLlxuICAgKi9cbiAgc3RhdGljIGRlY29kZU5vbmNlQWR2YW5jZShpbnN0cnVjdGlvbikge1xuICAgIHRoaXMuY2hlY2tQcm9ncmFtSWQoaW5zdHJ1Y3Rpb24ucHJvZ3JhbUlkKTtcbiAgICB0aGlzLmNoZWNrS2V5TGVuZ3RoKGluc3RydWN0aW9uLmtleXMsIDMpO1xuICAgIGRlY29kZURhdGEkMShTWVNURU1fSU5TVFJVQ1RJT05fTEFZT1VUUy5BZHZhbmNlTm9uY2VBY2NvdW50LCBpbnN0cnVjdGlvbi5kYXRhKTtcbiAgICByZXR1cm4ge1xuICAgICAgbm9uY2VQdWJrZXk6IGluc3RydWN0aW9uLmtleXNbMF0ucHVia2V5LFxuICAgICAgYXV0aG9yaXplZFB1YmtleTogaW5zdHJ1Y3Rpb24ua2V5c1syXS5wdWJrZXlcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIERlY29kZSBhIG5vbmNlIHdpdGhkcmF3IHN5c3RlbSBpbnN0cnVjdGlvbiBhbmQgcmV0cmlldmUgdGhlIGluc3RydWN0aW9uIHBhcmFtcy5cbiAgICovXG4gIHN0YXRpYyBkZWNvZGVOb25jZVdpdGhkcmF3KGluc3RydWN0aW9uKSB7XG4gICAgdGhpcy5jaGVja1Byb2dyYW1JZChpbnN0cnVjdGlvbi5wcm9ncmFtSWQpO1xuICAgIHRoaXMuY2hlY2tLZXlMZW5ndGgoaW5zdHJ1Y3Rpb24ua2V5cywgNSk7XG4gICAgY29uc3Qge1xuICAgICAgbGFtcG9ydHNcbiAgICB9ID0gZGVjb2RlRGF0YSQxKFNZU1RFTV9JTlNUUlVDVElPTl9MQVlPVVRTLldpdGhkcmF3Tm9uY2VBY2NvdW50LCBpbnN0cnVjdGlvbi5kYXRhKTtcbiAgICByZXR1cm4ge1xuICAgICAgbm9uY2VQdWJrZXk6IGluc3RydWN0aW9uLmtleXNbMF0ucHVia2V5LFxuICAgICAgdG9QdWJrZXk6IGluc3RydWN0aW9uLmtleXNbMV0ucHVia2V5LFxuICAgICAgYXV0aG9yaXplZFB1YmtleTogaW5zdHJ1Y3Rpb24ua2V5c1s0XS5wdWJrZXksXG4gICAgICBsYW1wb3J0c1xuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogRGVjb2RlIGEgbm9uY2UgYXV0aG9yaXplIHN5c3RlbSBpbnN0cnVjdGlvbiBhbmQgcmV0cmlldmUgdGhlIGluc3RydWN0aW9uIHBhcmFtcy5cbiAgICovXG4gIHN0YXRpYyBkZWNvZGVOb25jZUF1dGhvcml6ZShpbnN0cnVjdGlvbikge1xuICAgIHRoaXMuY2hlY2tQcm9ncmFtSWQoaW5zdHJ1Y3Rpb24ucHJvZ3JhbUlkKTtcbiAgICB0aGlzLmNoZWNrS2V5TGVuZ3RoKGluc3RydWN0aW9uLmtleXMsIDIpO1xuICAgIGNvbnN0IHtcbiAgICAgIGF1dGhvcml6ZWRcbiAgICB9ID0gZGVjb2RlRGF0YSQxKFNZU1RFTV9JTlNUUlVDVElPTl9MQVlPVVRTLkF1dGhvcml6ZU5vbmNlQWNjb3VudCwgaW5zdHJ1Y3Rpb24uZGF0YSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIG5vbmNlUHVia2V5OiBpbnN0cnVjdGlvbi5rZXlzWzBdLnB1YmtleSxcbiAgICAgIGF1dGhvcml6ZWRQdWJrZXk6IGluc3RydWN0aW9uLmtleXNbMV0ucHVia2V5LFxuICAgICAgbmV3QXV0aG9yaXplZFB1YmtleTogbmV3IFB1YmxpY0tleShhdXRob3JpemVkKVxuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogQGludGVybmFsXG4gICAqL1xuICBzdGF0aWMgY2hlY2tQcm9ncmFtSWQocHJvZ3JhbUlkKSB7XG4gICAgaWYgKCFwcm9ncmFtSWQuZXF1YWxzKFN5c3RlbVByb2dyYW0ucHJvZ3JhbUlkKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIGluc3RydWN0aW9uOyBwcm9ncmFtSWQgaXMgbm90IFN5c3RlbVByb2dyYW0nKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQGludGVybmFsXG4gICAqL1xuICBzdGF0aWMgY2hlY2tLZXlMZW5ndGgoa2V5cywgZXhwZWN0ZWRMZW5ndGgpIHtcbiAgICBpZiAoa2V5cy5sZW5ndGggPCBleHBlY3RlZExlbmd0aCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBpbnZhbGlkIGluc3RydWN0aW9uOyBmb3VuZCAke2tleXMubGVuZ3RofSBrZXlzLCBleHBlY3RlZCBhdCBsZWFzdCAke2V4cGVjdGVkTGVuZ3RofWApO1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIEFuIGVudW1lcmF0aW9uIG9mIHZhbGlkIFN5c3RlbUluc3RydWN0aW9uVHlwZSdzXG4gKi9cblxuLyoqXG4gKiBBbiBlbnVtZXJhdGlvbiBvZiB2YWxpZCBzeXN0ZW0gSW5zdHJ1Y3Rpb25UeXBlJ3NcbiAqIEBpbnRlcm5hbFxuICovXG5jb25zdCBTWVNURU1fSU5TVFJVQ1RJT05fTEFZT1VUUyA9IE9iamVjdC5mcmVlemUoe1xuICBDcmVhdGU6IHtcbiAgICBpbmRleDogMCxcbiAgICBsYXlvdXQ6IEJ1ZmZlckxheW91dC5zdHJ1Y3QoW0J1ZmZlckxheW91dC51MzIoJ2luc3RydWN0aW9uJyksIEJ1ZmZlckxheW91dC5uczY0KCdsYW1wb3J0cycpLCBCdWZmZXJMYXlvdXQubnM2NCgnc3BhY2UnKSwgcHVibGljS2V5KCdwcm9ncmFtSWQnKV0pXG4gIH0sXG4gIEFzc2lnbjoge1xuICAgIGluZGV4OiAxLFxuICAgIGxheW91dDogQnVmZmVyTGF5b3V0LnN0cnVjdChbQnVmZmVyTGF5b3V0LnUzMignaW5zdHJ1Y3Rpb24nKSwgcHVibGljS2V5KCdwcm9ncmFtSWQnKV0pXG4gIH0sXG4gIFRyYW5zZmVyOiB7XG4gICAgaW5kZXg6IDIsXG4gICAgbGF5b3V0OiBCdWZmZXJMYXlvdXQuc3RydWN0KFtCdWZmZXJMYXlvdXQudTMyKCdpbnN0cnVjdGlvbicpLCB1NjQoJ2xhbXBvcnRzJyldKVxuICB9LFxuICBDcmVhdGVXaXRoU2VlZDoge1xuICAgIGluZGV4OiAzLFxuICAgIGxheW91dDogQnVmZmVyTGF5b3V0LnN0cnVjdChbQnVmZmVyTGF5b3V0LnUzMignaW5zdHJ1Y3Rpb24nKSwgcHVibGljS2V5KCdiYXNlJyksIHJ1c3RTdHJpbmcoJ3NlZWQnKSwgQnVmZmVyTGF5b3V0Lm5zNjQoJ2xhbXBvcnRzJyksIEJ1ZmZlckxheW91dC5uczY0KCdzcGFjZScpLCBwdWJsaWNLZXkoJ3Byb2dyYW1JZCcpXSlcbiAgfSxcbiAgQWR2YW5jZU5vbmNlQWNjb3VudDoge1xuICAgIGluZGV4OiA0LFxuICAgIGxheW91dDogQnVmZmVyTGF5b3V0LnN0cnVjdChbQnVmZmVyTGF5b3V0LnUzMignaW5zdHJ1Y3Rpb24nKV0pXG4gIH0sXG4gIFdpdGhkcmF3Tm9uY2VBY2NvdW50OiB7XG4gICAgaW5kZXg6IDUsXG4gICAgbGF5b3V0OiBCdWZmZXJMYXlvdXQuc3RydWN0KFtCdWZmZXJMYXlvdXQudTMyKCdpbnN0cnVjdGlvbicpLCBCdWZmZXJMYXlvdXQubnM2NCgnbGFtcG9ydHMnKV0pXG4gIH0sXG4gIEluaXRpYWxpemVOb25jZUFjY291bnQ6IHtcbiAgICBpbmRleDogNixcbiAgICBsYXlvdXQ6IEJ1ZmZlckxheW91dC5zdHJ1Y3QoW0J1ZmZlckxheW91dC51MzIoJ2luc3RydWN0aW9uJyksIHB1YmxpY0tleSgnYXV0aG9yaXplZCcpXSlcbiAgfSxcbiAgQXV0aG9yaXplTm9uY2VBY2NvdW50OiB7XG4gICAgaW5kZXg6IDcsXG4gICAgbGF5b3V0OiBCdWZmZXJMYXlvdXQuc3RydWN0KFtCdWZmZXJMYXlvdXQudTMyKCdpbnN0cnVjdGlvbicpLCBwdWJsaWNLZXkoJ2F1dGhvcml6ZWQnKV0pXG4gIH0sXG4gIEFsbG9jYXRlOiB7XG4gICAgaW5kZXg6IDgsXG4gICAgbGF5b3V0OiBCdWZmZXJMYXlvdXQuc3RydWN0KFtCdWZmZXJMYXlvdXQudTMyKCdpbnN0cnVjdGlvbicpLCBCdWZmZXJMYXlvdXQubnM2NCgnc3BhY2UnKV0pXG4gIH0sXG4gIEFsbG9jYXRlV2l0aFNlZWQ6IHtcbiAgICBpbmRleDogOSxcbiAgICBsYXlvdXQ6IEJ1ZmZlckxheW91dC5zdHJ1Y3QoW0J1ZmZlckxheW91dC51MzIoJ2luc3RydWN0aW9uJyksIHB1YmxpY0tleSgnYmFzZScpLCBydXN0U3RyaW5nKCdzZWVkJyksIEJ1ZmZlckxheW91dC5uczY0KCdzcGFjZScpLCBwdWJsaWNLZXkoJ3Byb2dyYW1JZCcpXSlcbiAgfSxcbiAgQXNzaWduV2l0aFNlZWQ6IHtcbiAgICBpbmRleDogMTAsXG4gICAgbGF5b3V0OiBCdWZmZXJMYXlvdXQuc3RydWN0KFtCdWZmZXJMYXlvdXQudTMyKCdpbnN0cnVjdGlvbicpLCBwdWJsaWNLZXkoJ2Jhc2UnKSwgcnVzdFN0cmluZygnc2VlZCcpLCBwdWJsaWNLZXkoJ3Byb2dyYW1JZCcpXSlcbiAgfSxcbiAgVHJhbnNmZXJXaXRoU2VlZDoge1xuICAgIGluZGV4OiAxMSxcbiAgICBsYXlvdXQ6IEJ1ZmZlckxheW91dC5zdHJ1Y3QoW0J1ZmZlckxheW91dC51MzIoJ2luc3RydWN0aW9uJyksIHU2NCgnbGFtcG9ydHMnKSwgcnVzdFN0cmluZygnc2VlZCcpLCBwdWJsaWNLZXkoJ3Byb2dyYW1JZCcpXSlcbiAgfSxcbiAgVXBncmFkZU5vbmNlQWNjb3VudDoge1xuICAgIGluZGV4OiAxMixcbiAgICBsYXlvdXQ6IEJ1ZmZlckxheW91dC5zdHJ1Y3QoW0J1ZmZlckxheW91dC51MzIoJ2luc3RydWN0aW9uJyldKVxuICB9XG59KTtcblxuLyoqXG4gKiBGYWN0b3J5IGNsYXNzIGZvciB0cmFuc2FjdGlvbnMgdG8gaW50ZXJhY3Qgd2l0aCB0aGUgU3lzdGVtIHByb2dyYW1cbiAqL1xuY2xhc3MgU3lzdGVtUHJvZ3JhbSB7XG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIGNvbnN0cnVjdG9yKCkge31cblxuICAvKipcbiAgICogUHVibGljIGtleSB0aGF0IGlkZW50aWZpZXMgdGhlIFN5c3RlbSBwcm9ncmFtXG4gICAqL1xuXG4gIC8qKlxuICAgKiBHZW5lcmF0ZSBhIHRyYW5zYWN0aW9uIGluc3RydWN0aW9uIHRoYXQgY3JlYXRlcyBhIG5ldyBhY2NvdW50XG4gICAqL1xuICBzdGF0aWMgY3JlYXRlQWNjb3VudChwYXJhbXMpIHtcbiAgICBjb25zdCB0eXBlID0gU1lTVEVNX0lOU1RSVUNUSU9OX0xBWU9VVFMuQ3JlYXRlO1xuICAgIGNvbnN0IGRhdGEgPSBlbmNvZGVEYXRhKHR5cGUsIHtcbiAgICAgIGxhbXBvcnRzOiBwYXJhbXMubGFtcG9ydHMsXG4gICAgICBzcGFjZTogcGFyYW1zLnNwYWNlLFxuICAgICAgcHJvZ3JhbUlkOiB0b0J1ZmZlcihwYXJhbXMucHJvZ3JhbUlkLnRvQnVmZmVyKCkpXG4gICAgfSk7XG4gICAgcmV0dXJuIG5ldyBUcmFuc2FjdGlvbkluc3RydWN0aW9uKHtcbiAgICAgIGtleXM6IFt7XG4gICAgICAgIHB1YmtleTogcGFyYW1zLmZyb21QdWJrZXksXG4gICAgICAgIGlzU2lnbmVyOiB0cnVlLFxuICAgICAgICBpc1dyaXRhYmxlOiB0cnVlXG4gICAgICB9LCB7XG4gICAgICAgIHB1YmtleTogcGFyYW1zLm5ld0FjY291bnRQdWJrZXksXG4gICAgICAgIGlzU2lnbmVyOiB0cnVlLFxuICAgICAgICBpc1dyaXRhYmxlOiB0cnVlXG4gICAgICB9XSxcbiAgICAgIHByb2dyYW1JZDogdGhpcy5wcm9ncmFtSWQsXG4gICAgICBkYXRhXG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogR2VuZXJhdGUgYSB0cmFuc2FjdGlvbiBpbnN0cnVjdGlvbiB0aGF0IHRyYW5zZmVycyBsYW1wb3J0cyBmcm9tIG9uZSBhY2NvdW50IHRvIGFub3RoZXJcbiAgICovXG4gIHN0YXRpYyB0cmFuc2ZlcihwYXJhbXMpIHtcbiAgICBsZXQgZGF0YTtcbiAgICBsZXQga2V5cztcbiAgICBpZiAoJ2Jhc2VQdWJrZXknIGluIHBhcmFtcykge1xuICAgICAgY29uc3QgdHlwZSA9IFNZU1RFTV9JTlNUUlVDVElPTl9MQVlPVVRTLlRyYW5zZmVyV2l0aFNlZWQ7XG4gICAgICBkYXRhID0gZW5jb2RlRGF0YSh0eXBlLCB7XG4gICAgICAgIGxhbXBvcnRzOiBCaWdJbnQocGFyYW1zLmxhbXBvcnRzKSxcbiAgICAgICAgc2VlZDogcGFyYW1zLnNlZWQsXG4gICAgICAgIHByb2dyYW1JZDogdG9CdWZmZXIocGFyYW1zLnByb2dyYW1JZC50b0J1ZmZlcigpKVxuICAgICAgfSk7XG4gICAgICBrZXlzID0gW3tcbiAgICAgICAgcHVia2V5OiBwYXJhbXMuZnJvbVB1YmtleSxcbiAgICAgICAgaXNTaWduZXI6IGZhbHNlLFxuICAgICAgICBpc1dyaXRhYmxlOiB0cnVlXG4gICAgICB9LCB7XG4gICAgICAgIHB1YmtleTogcGFyYW1zLmJhc2VQdWJrZXksXG4gICAgICAgIGlzU2lnbmVyOiB0cnVlLFxuICAgICAgICBpc1dyaXRhYmxlOiBmYWxzZVxuICAgICAgfSwge1xuICAgICAgICBwdWJrZXk6IHBhcmFtcy50b1B1YmtleSxcbiAgICAgICAgaXNTaWduZXI6IGZhbHNlLFxuICAgICAgICBpc1dyaXRhYmxlOiB0cnVlXG4gICAgICB9XTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgdHlwZSA9IFNZU1RFTV9JTlNUUlVDVElPTl9MQVlPVVRTLlRyYW5zZmVyO1xuICAgICAgZGF0YSA9IGVuY29kZURhdGEodHlwZSwge1xuICAgICAgICBsYW1wb3J0czogQmlnSW50KHBhcmFtcy5sYW1wb3J0cylcbiAgICAgIH0pO1xuICAgICAga2V5cyA9IFt7XG4gICAgICAgIHB1YmtleTogcGFyYW1zLmZyb21QdWJrZXksXG4gICAgICAgIGlzU2lnbmVyOiB0cnVlLFxuICAgICAgICBpc1dyaXRhYmxlOiB0cnVlXG4gICAgICB9LCB7XG4gICAgICAgIHB1YmtleTogcGFyYW1zLnRvUHVia2V5LFxuICAgICAgICBpc1NpZ25lcjogZmFsc2UsXG4gICAgICAgIGlzV3JpdGFibGU6IHRydWVcbiAgICAgIH1dO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IFRyYW5zYWN0aW9uSW5zdHJ1Y3Rpb24oe1xuICAgICAga2V5cyxcbiAgICAgIHByb2dyYW1JZDogdGhpcy5wcm9ncmFtSWQsXG4gICAgICBkYXRhXG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogR2VuZXJhdGUgYSB0cmFuc2FjdGlvbiBpbnN0cnVjdGlvbiB0aGF0IGFzc2lnbnMgYW4gYWNjb3VudCB0byBhIHByb2dyYW1cbiAgICovXG4gIHN0YXRpYyBhc3NpZ24ocGFyYW1zKSB7XG4gICAgbGV0IGRhdGE7XG4gICAgbGV0IGtleXM7XG4gICAgaWYgKCdiYXNlUHVia2V5JyBpbiBwYXJhbXMpIHtcbiAgICAgIGNvbnN0IHR5cGUgPSBTWVNURU1fSU5TVFJVQ1RJT05fTEFZT1VUUy5Bc3NpZ25XaXRoU2VlZDtcbiAgICAgIGRhdGEgPSBlbmNvZGVEYXRhKHR5cGUsIHtcbiAgICAgICAgYmFzZTogdG9CdWZmZXIocGFyYW1zLmJhc2VQdWJrZXkudG9CdWZmZXIoKSksXG4gICAgICAgIHNlZWQ6IHBhcmFtcy5zZWVkLFxuICAgICAgICBwcm9ncmFtSWQ6IHRvQnVmZmVyKHBhcmFtcy5wcm9ncmFtSWQudG9CdWZmZXIoKSlcbiAgICAgIH0pO1xuICAgICAga2V5cyA9IFt7XG4gICAgICAgIHB1YmtleTogcGFyYW1zLmFjY291bnRQdWJrZXksXG4gICAgICAgIGlzU2lnbmVyOiBmYWxzZSxcbiAgICAgICAgaXNXcml0YWJsZTogdHJ1ZVxuICAgICAgfSwge1xuICAgICAgICBwdWJrZXk6IHBhcmFtcy5iYXNlUHVia2V5LFxuICAgICAgICBpc1NpZ25lcjogdHJ1ZSxcbiAgICAgICAgaXNXcml0YWJsZTogZmFsc2VcbiAgICAgIH1dO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCB0eXBlID0gU1lTVEVNX0lOU1RSVUNUSU9OX0xBWU9VVFMuQXNzaWduO1xuICAgICAgZGF0YSA9IGVuY29kZURhdGEodHlwZSwge1xuICAgICAgICBwcm9ncmFtSWQ6IHRvQnVmZmVyKHBhcmFtcy5wcm9ncmFtSWQudG9CdWZmZXIoKSlcbiAgICAgIH0pO1xuICAgICAga2V5cyA9IFt7XG4gICAgICAgIHB1YmtleTogcGFyYW1zLmFjY291bnRQdWJrZXksXG4gICAgICAgIGlzU2lnbmVyOiB0cnVlLFxuICAgICAgICBpc1dyaXRhYmxlOiB0cnVlXG4gICAgICB9XTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBUcmFuc2FjdGlvbkluc3RydWN0aW9uKHtcbiAgICAgIGtleXMsXG4gICAgICBwcm9ncmFtSWQ6IHRoaXMucHJvZ3JhbUlkLFxuICAgICAgZGF0YVxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEdlbmVyYXRlIGEgdHJhbnNhY3Rpb24gaW5zdHJ1Y3Rpb24gdGhhdCBjcmVhdGVzIGEgbmV3IGFjY291bnQgYXRcbiAgICogICBhbiBhZGRyZXNzIGdlbmVyYXRlZCB3aXRoIGBmcm9tYCwgYSBzZWVkLCBhbmQgcHJvZ3JhbUlkXG4gICAqL1xuICBzdGF0aWMgY3JlYXRlQWNjb3VudFdpdGhTZWVkKHBhcmFtcykge1xuICAgIGNvbnN0IHR5cGUgPSBTWVNURU1fSU5TVFJVQ1RJT05fTEFZT1VUUy5DcmVhdGVXaXRoU2VlZDtcbiAgICBjb25zdCBkYXRhID0gZW5jb2RlRGF0YSh0eXBlLCB7XG4gICAgICBiYXNlOiB0b0J1ZmZlcihwYXJhbXMuYmFzZVB1YmtleS50b0J1ZmZlcigpKSxcbiAgICAgIHNlZWQ6IHBhcmFtcy5zZWVkLFxuICAgICAgbGFtcG9ydHM6IHBhcmFtcy5sYW1wb3J0cyxcbiAgICAgIHNwYWNlOiBwYXJhbXMuc3BhY2UsXG4gICAgICBwcm9ncmFtSWQ6IHRvQnVmZmVyKHBhcmFtcy5wcm9ncmFtSWQudG9CdWZmZXIoKSlcbiAgICB9KTtcbiAgICBsZXQga2V5cyA9IFt7XG4gICAgICBwdWJrZXk6IHBhcmFtcy5mcm9tUHVia2V5LFxuICAgICAgaXNTaWduZXI6IHRydWUsXG4gICAgICBpc1dyaXRhYmxlOiB0cnVlXG4gICAgfSwge1xuICAgICAgcHVia2V5OiBwYXJhbXMubmV3QWNjb3VudFB1YmtleSxcbiAgICAgIGlzU2lnbmVyOiBmYWxzZSxcbiAgICAgIGlzV3JpdGFibGU6IHRydWVcbiAgICB9XTtcbiAgICBpZiAocGFyYW1zLmJhc2VQdWJrZXkgIT0gcGFyYW1zLmZyb21QdWJrZXkpIHtcbiAgICAgIGtleXMucHVzaCh7XG4gICAgICAgIHB1YmtleTogcGFyYW1zLmJhc2VQdWJrZXksXG4gICAgICAgIGlzU2lnbmVyOiB0cnVlLFxuICAgICAgICBpc1dyaXRhYmxlOiBmYWxzZVxuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBuZXcgVHJhbnNhY3Rpb25JbnN0cnVjdGlvbih7XG4gICAgICBrZXlzLFxuICAgICAgcHJvZ3JhbUlkOiB0aGlzLnByb2dyYW1JZCxcbiAgICAgIGRhdGFcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZW5lcmF0ZSBhIHRyYW5zYWN0aW9uIHRoYXQgY3JlYXRlcyBhIG5ldyBOb25jZSBhY2NvdW50XG4gICAqL1xuICBzdGF0aWMgY3JlYXRlTm9uY2VBY2NvdW50KHBhcmFtcykge1xuICAgIGNvbnN0IHRyYW5zYWN0aW9uID0gbmV3IFRyYW5zYWN0aW9uKCk7XG4gICAgaWYgKCdiYXNlUHVia2V5JyBpbiBwYXJhbXMgJiYgJ3NlZWQnIGluIHBhcmFtcykge1xuICAgICAgdHJhbnNhY3Rpb24uYWRkKFN5c3RlbVByb2dyYW0uY3JlYXRlQWNjb3VudFdpdGhTZWVkKHtcbiAgICAgICAgZnJvbVB1YmtleTogcGFyYW1zLmZyb21QdWJrZXksXG4gICAgICAgIG5ld0FjY291bnRQdWJrZXk6IHBhcmFtcy5ub25jZVB1YmtleSxcbiAgICAgICAgYmFzZVB1YmtleTogcGFyYW1zLmJhc2VQdWJrZXksXG4gICAgICAgIHNlZWQ6IHBhcmFtcy5zZWVkLFxuICAgICAgICBsYW1wb3J0czogcGFyYW1zLmxhbXBvcnRzLFxuICAgICAgICBzcGFjZTogTk9OQ0VfQUNDT1VOVF9MRU5HVEgsXG4gICAgICAgIHByb2dyYW1JZDogdGhpcy5wcm9ncmFtSWRcbiAgICAgIH0pKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdHJhbnNhY3Rpb24uYWRkKFN5c3RlbVByb2dyYW0uY3JlYXRlQWNjb3VudCh7XG4gICAgICAgIGZyb21QdWJrZXk6IHBhcmFtcy5mcm9tUHVia2V5LFxuICAgICAgICBuZXdBY2NvdW50UHVia2V5OiBwYXJhbXMubm9uY2VQdWJrZXksXG4gICAgICAgIGxhbXBvcnRzOiBwYXJhbXMubGFtcG9ydHMsXG4gICAgICAgIHNwYWNlOiBOT05DRV9BQ0NPVU5UX0xFTkdUSCxcbiAgICAgICAgcHJvZ3JhbUlkOiB0aGlzLnByb2dyYW1JZFxuICAgICAgfSkpO1xuICAgIH1cbiAgICBjb25zdCBpbml0UGFyYW1zID0ge1xuICAgICAgbm9uY2VQdWJrZXk6IHBhcmFtcy5ub25jZVB1YmtleSxcbiAgICAgIGF1dGhvcml6ZWRQdWJrZXk6IHBhcmFtcy5hdXRob3JpemVkUHVia2V5XG4gICAgfTtcbiAgICB0cmFuc2FjdGlvbi5hZGQodGhpcy5ub25jZUluaXRpYWxpemUoaW5pdFBhcmFtcykpO1xuICAgIHJldHVybiB0cmFuc2FjdGlvbjtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZW5lcmF0ZSBhbiBpbnN0cnVjdGlvbiB0byBpbml0aWFsaXplIGEgTm9uY2UgYWNjb3VudFxuICAgKi9cbiAgc3RhdGljIG5vbmNlSW5pdGlhbGl6ZShwYXJhbXMpIHtcbiAgICBjb25zdCB0eXBlID0gU1lTVEVNX0lOU1RSVUNUSU9OX0xBWU9VVFMuSW5pdGlhbGl6ZU5vbmNlQWNjb3VudDtcbiAgICBjb25zdCBkYXRhID0gZW5jb2RlRGF0YSh0eXBlLCB7XG4gICAgICBhdXRob3JpemVkOiB0b0J1ZmZlcihwYXJhbXMuYXV0aG9yaXplZFB1YmtleS50b0J1ZmZlcigpKVxuICAgIH0pO1xuICAgIGNvbnN0IGluc3RydWN0aW9uRGF0YSA9IHtcbiAgICAgIGtleXM6IFt7XG4gICAgICAgIHB1YmtleTogcGFyYW1zLm5vbmNlUHVia2V5LFxuICAgICAgICBpc1NpZ25lcjogZmFsc2UsXG4gICAgICAgIGlzV3JpdGFibGU6IHRydWVcbiAgICAgIH0sIHtcbiAgICAgICAgcHVia2V5OiBTWVNWQVJfUkVDRU5UX0JMT0NLSEFTSEVTX1BVQktFWSxcbiAgICAgICAgaXNTaWduZXI6IGZhbHNlLFxuICAgICAgICBpc1dyaXRhYmxlOiBmYWxzZVxuICAgICAgfSwge1xuICAgICAgICBwdWJrZXk6IFNZU1ZBUl9SRU5UX1BVQktFWSxcbiAgICAgICAgaXNTaWduZXI6IGZhbHNlLFxuICAgICAgICBpc1dyaXRhYmxlOiBmYWxzZVxuICAgICAgfV0sXG4gICAgICBwcm9ncmFtSWQ6IHRoaXMucHJvZ3JhbUlkLFxuICAgICAgZGF0YVxuICAgIH07XG4gICAgcmV0dXJuIG5ldyBUcmFuc2FjdGlvbkluc3RydWN0aW9uKGluc3RydWN0aW9uRGF0YSk7XG4gIH1cblxuICAvKipcbiAgICogR2VuZXJhdGUgYW4gaW5zdHJ1Y3Rpb24gdG8gYWR2YW5jZSB0aGUgbm9uY2UgaW4gYSBOb25jZSBhY2NvdW50XG4gICAqL1xuICBzdGF0aWMgbm9uY2VBZHZhbmNlKHBhcmFtcykge1xuICAgIGNvbnN0IHR5cGUgPSBTWVNURU1fSU5TVFJVQ1RJT05fTEFZT1VUUy5BZHZhbmNlTm9uY2VBY2NvdW50O1xuICAgIGNvbnN0IGRhdGEgPSBlbmNvZGVEYXRhKHR5cGUpO1xuICAgIGNvbnN0IGluc3RydWN0aW9uRGF0YSA9IHtcbiAgICAgIGtleXM6IFt7XG4gICAgICAgIHB1YmtleTogcGFyYW1zLm5vbmNlUHVia2V5LFxuICAgICAgICBpc1NpZ25lcjogZmFsc2UsXG4gICAgICAgIGlzV3JpdGFibGU6IHRydWVcbiAgICAgIH0sIHtcbiAgICAgICAgcHVia2V5OiBTWVNWQVJfUkVDRU5UX0JMT0NLSEFTSEVTX1BVQktFWSxcbiAgICAgICAgaXNTaWduZXI6IGZhbHNlLFxuICAgICAgICBpc1dyaXRhYmxlOiBmYWxzZVxuICAgICAgfSwge1xuICAgICAgICBwdWJrZXk6IHBhcmFtcy5hdXRob3JpemVkUHVia2V5LFxuICAgICAgICBpc1NpZ25lcjogdHJ1ZSxcbiAgICAgICAgaXNXcml0YWJsZTogZmFsc2VcbiAgICAgIH1dLFxuICAgICAgcHJvZ3JhbUlkOiB0aGlzLnByb2dyYW1JZCxcbiAgICAgIGRhdGFcbiAgICB9O1xuICAgIHJldHVybiBuZXcgVHJhbnNhY3Rpb25JbnN0cnVjdGlvbihpbnN0cnVjdGlvbkRhdGEpO1xuICB9XG5cbiAgLyoqXG4gICAqIEdlbmVyYXRlIGEgdHJhbnNhY3Rpb24gaW5zdHJ1Y3Rpb24gdGhhdCB3aXRoZHJhd3MgbGFtcG9ydHMgZnJvbSBhIE5vbmNlIGFjY291bnRcbiAgICovXG4gIHN0YXRpYyBub25jZVdpdGhkcmF3KHBhcmFtcykge1xuICAgIGNvbnN0IHR5cGUgPSBTWVNURU1fSU5TVFJVQ1RJT05fTEFZT1VUUy5XaXRoZHJhd05vbmNlQWNjb3VudDtcbiAgICBjb25zdCBkYXRhID0gZW5jb2RlRGF0YSh0eXBlLCB7XG4gICAgICBsYW1wb3J0czogcGFyYW1zLmxhbXBvcnRzXG4gICAgfSk7XG4gICAgcmV0dXJuIG5ldyBUcmFuc2FjdGlvbkluc3RydWN0aW9uKHtcbiAgICAgIGtleXM6IFt7XG4gICAgICAgIHB1YmtleTogcGFyYW1zLm5vbmNlUHVia2V5LFxuICAgICAgICBpc1NpZ25lcjogZmFsc2UsXG4gICAgICAgIGlzV3JpdGFibGU6IHRydWVcbiAgICAgIH0sIHtcbiAgICAgICAgcHVia2V5OiBwYXJhbXMudG9QdWJrZXksXG4gICAgICAgIGlzU2lnbmVyOiBmYWxzZSxcbiAgICAgICAgaXNXcml0YWJsZTogdHJ1ZVxuICAgICAgfSwge1xuICAgICAgICBwdWJrZXk6IFNZU1ZBUl9SRUNFTlRfQkxPQ0tIQVNIRVNfUFVCS0VZLFxuICAgICAgICBpc1NpZ25lcjogZmFsc2UsXG4gICAgICAgIGlzV3JpdGFibGU6IGZhbHNlXG4gICAgICB9LCB7XG4gICAgICAgIHB1YmtleTogU1lTVkFSX1JFTlRfUFVCS0VZLFxuICAgICAgICBpc1NpZ25lcjogZmFsc2UsXG4gICAgICAgIGlzV3JpdGFibGU6IGZhbHNlXG4gICAgICB9LCB7XG4gICAgICAgIHB1YmtleTogcGFyYW1zLmF1dGhvcml6ZWRQdWJrZXksXG4gICAgICAgIGlzU2lnbmVyOiB0cnVlLFxuICAgICAgICBpc1dyaXRhYmxlOiBmYWxzZVxuICAgICAgfV0sXG4gICAgICBwcm9ncmFtSWQ6IHRoaXMucHJvZ3JhbUlkLFxuICAgICAgZGF0YVxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEdlbmVyYXRlIGEgdHJhbnNhY3Rpb24gaW5zdHJ1Y3Rpb24gdGhhdCBhdXRob3JpemVzIGEgbmV3IFB1YmxpY0tleSBhcyB0aGUgYXV0aG9yaXR5XG4gICAqIG9uIGEgTm9uY2UgYWNjb3VudC5cbiAgICovXG4gIHN0YXRpYyBub25jZUF1dGhvcml6ZShwYXJhbXMpIHtcbiAgICBjb25zdCB0eXBlID0gU1lTVEVNX0lOU1RSVUNUSU9OX0xBWU9VVFMuQXV0aG9yaXplTm9uY2VBY2NvdW50O1xuICAgIGNvbnN0IGRhdGEgPSBlbmNvZGVEYXRhKHR5cGUsIHtcbiAgICAgIGF1dGhvcml6ZWQ6IHRvQnVmZmVyKHBhcmFtcy5uZXdBdXRob3JpemVkUHVia2V5LnRvQnVmZmVyKCkpXG4gICAgfSk7XG4gICAgcmV0dXJuIG5ldyBUcmFuc2FjdGlvbkluc3RydWN0aW9uKHtcbiAgICAgIGtleXM6IFt7XG4gICAgICAgIHB1YmtleTogcGFyYW1zLm5vbmNlUHVia2V5LFxuICAgICAgICBpc1NpZ25lcjogZmFsc2UsXG4gICAgICAgIGlzV3JpdGFibGU6IHRydWVcbiAgICAgIH0sIHtcbiAgICAgICAgcHVia2V5OiBwYXJhbXMuYXV0aG9yaXplZFB1YmtleSxcbiAgICAgICAgaXNTaWduZXI6IHRydWUsXG4gICAgICAgIGlzV3JpdGFibGU6IGZhbHNlXG4gICAgICB9XSxcbiAgICAgIHByb2dyYW1JZDogdGhpcy5wcm9ncmFtSWQsXG4gICAgICBkYXRhXG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogR2VuZXJhdGUgYSB0cmFuc2FjdGlvbiBpbnN0cnVjdGlvbiB0aGF0IGFsbG9jYXRlcyBzcGFjZSBpbiBhbiBhY2NvdW50IHdpdGhvdXQgZnVuZGluZ1xuICAgKi9cbiAgc3RhdGljIGFsbG9jYXRlKHBhcmFtcykge1xuICAgIGxldCBkYXRhO1xuICAgIGxldCBrZXlzO1xuICAgIGlmICgnYmFzZVB1YmtleScgaW4gcGFyYW1zKSB7XG4gICAgICBjb25zdCB0eXBlID0gU1lTVEVNX0lOU1RSVUNUSU9OX0xBWU9VVFMuQWxsb2NhdGVXaXRoU2VlZDtcbiAgICAgIGRhdGEgPSBlbmNvZGVEYXRhKHR5cGUsIHtcbiAgICAgICAgYmFzZTogdG9CdWZmZXIocGFyYW1zLmJhc2VQdWJrZXkudG9CdWZmZXIoKSksXG4gICAgICAgIHNlZWQ6IHBhcmFtcy5zZWVkLFxuICAgICAgICBzcGFjZTogcGFyYW1zLnNwYWNlLFxuICAgICAgICBwcm9ncmFtSWQ6IHRvQnVmZmVyKHBhcmFtcy5wcm9ncmFtSWQudG9CdWZmZXIoKSlcbiAgICAgIH0pO1xuICAgICAga2V5cyA9IFt7XG4gICAgICAgIHB1YmtleTogcGFyYW1zLmFjY291bnRQdWJrZXksXG4gICAgICAgIGlzU2lnbmVyOiBmYWxzZSxcbiAgICAgICAgaXNXcml0YWJsZTogdHJ1ZVxuICAgICAgfSwge1xuICAgICAgICBwdWJrZXk6IHBhcmFtcy5iYXNlUHVia2V5LFxuICAgICAgICBpc1NpZ25lcjogdHJ1ZSxcbiAgICAgICAgaXNXcml0YWJsZTogZmFsc2VcbiAgICAgIH1dO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCB0eXBlID0gU1lTVEVNX0lOU1RSVUNUSU9OX0xBWU9VVFMuQWxsb2NhdGU7XG4gICAgICBkYXRhID0gZW5jb2RlRGF0YSh0eXBlLCB7XG4gICAgICAgIHNwYWNlOiBwYXJhbXMuc3BhY2VcbiAgICAgIH0pO1xuICAgICAga2V5cyA9IFt7XG4gICAgICAgIHB1YmtleTogcGFyYW1zLmFjY291bnRQdWJrZXksXG4gICAgICAgIGlzU2lnbmVyOiB0cnVlLFxuICAgICAgICBpc1dyaXRhYmxlOiB0cnVlXG4gICAgICB9XTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBUcmFuc2FjdGlvbkluc3RydWN0aW9uKHtcbiAgICAgIGtleXMsXG4gICAgICBwcm9ncmFtSWQ6IHRoaXMucHJvZ3JhbUlkLFxuICAgICAgZGF0YVxuICAgIH0pO1xuICB9XG59XG5TeXN0ZW1Qcm9ncmFtLnByb2dyYW1JZCA9IG5ldyBQdWJsaWNLZXkoJzExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExJyk7XG5cbi8vIEtlZXAgcHJvZ3JhbSBjaHVua3MgdW5kZXIgUEFDS0VUX0RBVEFfU0laRSwgbGVhdmluZyBlbm91Z2ggcm9vbSBmb3IgdGhlXG4vLyByZXN0IG9mIHRoZSBUcmFuc2FjdGlvbiBmaWVsZHNcbi8vXG4vLyBUT0RPOiByZXBsYWNlIDMwMCB3aXRoIGEgcHJvcGVyIGNvbnN0YW50IGZvciB0aGUgc2l6ZSBvZiB0aGUgb3RoZXJcbi8vIFRyYW5zYWN0aW9uIGZpZWxkc1xuY29uc3QgQ0hVTktfU0laRSA9IFBBQ0tFVF9EQVRBX1NJWkUgLSAzMDA7XG5cbi8qKlxuICogUHJvZ3JhbSBsb2FkZXIgaW50ZXJmYWNlXG4gKi9cbmNsYXNzIExvYWRlciB7XG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIGNvbnN0cnVjdG9yKCkge31cblxuICAvKipcbiAgICogQW1vdW50IG9mIHByb2dyYW0gZGF0YSBwbGFjZWQgaW4gZWFjaCBsb2FkIFRyYW5zYWN0aW9uXG4gICAqL1xuXG4gIC8qKlxuICAgKiBNaW5pbXVtIG51bWJlciBvZiBzaWduYXR1cmVzIHJlcXVpcmVkIHRvIGxvYWQgYSBwcm9ncmFtIG5vdCBpbmNsdWRpbmdcbiAgICogcmV0cmllc1xuICAgKlxuICAgKiBDYW4gYmUgdXNlZCB0byBjYWxjdWxhdGUgdHJhbnNhY3Rpb24gZmVlc1xuICAgKi9cbiAgc3RhdGljIGdldE1pbk51bVNpZ25hdHVyZXMoZGF0YUxlbmd0aCkge1xuICAgIHJldHVybiAyICogKFxuICAgIC8vIEV2ZXJ5IHRyYW5zYWN0aW9uIHJlcXVpcmVzIHR3byBzaWduYXR1cmVzIChwYXllciArIHByb2dyYW0pXG4gICAgTWF0aC5jZWlsKGRhdGFMZW5ndGggLyBMb2FkZXIuY2h1bmtTaXplKSArIDEgK1xuICAgIC8vIEFkZCBvbmUgZm9yIENyZWF0ZSB0cmFuc2FjdGlvblxuICAgIDEpIC8vIEFkZCBvbmUgZm9yIEZpbmFsaXplIHRyYW5zYWN0aW9uXG4gICAgO1xuICB9XG5cbiAgLyoqXG4gICAqIExvYWRzIGEgZ2VuZXJpYyBwcm9ncmFtXG4gICAqXG4gICAqIEBwYXJhbSBjb25uZWN0aW9uIFRoZSBjb25uZWN0aW9uIHRvIHVzZVxuICAgKiBAcGFyYW0gcGF5ZXIgU3lzdGVtIGFjY291bnQgdGhhdCBwYXlzIHRvIGxvYWQgdGhlIHByb2dyYW1cbiAgICogQHBhcmFtIHByb2dyYW0gQWNjb3VudCB0byBsb2FkIHRoZSBwcm9ncmFtIGludG9cbiAgICogQHBhcmFtIHByb2dyYW1JZCBQdWJsaWMga2V5IHRoYXQgaWRlbnRpZmllcyB0aGUgbG9hZGVyXG4gICAqIEBwYXJhbSBkYXRhIFByb2dyYW0gb2N0ZXRzXG4gICAqIEByZXR1cm4gdHJ1ZSBpZiBwcm9ncmFtIHdhcyBsb2FkZWQgc3VjY2Vzc2Z1bGx5LCBmYWxzZSBpZiBwcm9ncmFtIHdhcyBhbHJlYWR5IGxvYWRlZFxuICAgKi9cbiAgc3RhdGljIGFzeW5jIGxvYWQoY29ubmVjdGlvbiwgcGF5ZXIsIHByb2dyYW0sIHByb2dyYW1JZCwgZGF0YSkge1xuICAgIHtcbiAgICAgIGNvbnN0IGJhbGFuY2VOZWVkZWQgPSBhd2FpdCBjb25uZWN0aW9uLmdldE1pbmltdW1CYWxhbmNlRm9yUmVudEV4ZW1wdGlvbihkYXRhLmxlbmd0aCk7XG5cbiAgICAgIC8vIEZldGNoIHByb2dyYW0gYWNjb3VudCBpbmZvIHRvIGNoZWNrIGlmIGl0IGhhcyBhbHJlYWR5IGJlZW4gY3JlYXRlZFxuICAgICAgY29uc3QgcHJvZ3JhbUluZm8gPSBhd2FpdCBjb25uZWN0aW9uLmdldEFjY291bnRJbmZvKHByb2dyYW0ucHVibGljS2V5LCAnY29uZmlybWVkJyk7XG4gICAgICBsZXQgdHJhbnNhY3Rpb24gPSBudWxsO1xuICAgICAgaWYgKHByb2dyYW1JbmZvICE9PSBudWxsKSB7XG4gICAgICAgIGlmIChwcm9ncmFtSW5mby5leGVjdXRhYmxlKSB7XG4gICAgICAgICAgY29uc29sZS5lcnJvcignUHJvZ3JhbSBsb2FkIGZhaWxlZCwgYWNjb3VudCBpcyBhbHJlYWR5IGV4ZWN1dGFibGUnKTtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHByb2dyYW1JbmZvLmRhdGEubGVuZ3RoICE9PSBkYXRhLmxlbmd0aCkge1xuICAgICAgICAgIHRyYW5zYWN0aW9uID0gdHJhbnNhY3Rpb24gfHwgbmV3IFRyYW5zYWN0aW9uKCk7XG4gICAgICAgICAgdHJhbnNhY3Rpb24uYWRkKFN5c3RlbVByb2dyYW0uYWxsb2NhdGUoe1xuICAgICAgICAgICAgYWNjb3VudFB1YmtleTogcHJvZ3JhbS5wdWJsaWNLZXksXG4gICAgICAgICAgICBzcGFjZTogZGF0YS5sZW5ndGhcbiAgICAgICAgICB9KSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFwcm9ncmFtSW5mby5vd25lci5lcXVhbHMocHJvZ3JhbUlkKSkge1xuICAgICAgICAgIHRyYW5zYWN0aW9uID0gdHJhbnNhY3Rpb24gfHwgbmV3IFRyYW5zYWN0aW9uKCk7XG4gICAgICAgICAgdHJhbnNhY3Rpb24uYWRkKFN5c3RlbVByb2dyYW0uYXNzaWduKHtcbiAgICAgICAgICAgIGFjY291bnRQdWJrZXk6IHByb2dyYW0ucHVibGljS2V5LFxuICAgICAgICAgICAgcHJvZ3JhbUlkXG4gICAgICAgICAgfSkpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwcm9ncmFtSW5mby5sYW1wb3J0cyA8IGJhbGFuY2VOZWVkZWQpIHtcbiAgICAgICAgICB0cmFuc2FjdGlvbiA9IHRyYW5zYWN0aW9uIHx8IG5ldyBUcmFuc2FjdGlvbigpO1xuICAgICAgICAgIHRyYW5zYWN0aW9uLmFkZChTeXN0ZW1Qcm9ncmFtLnRyYW5zZmVyKHtcbiAgICAgICAgICAgIGZyb21QdWJrZXk6IHBheWVyLnB1YmxpY0tleSxcbiAgICAgICAgICAgIHRvUHVia2V5OiBwcm9ncmFtLnB1YmxpY0tleSxcbiAgICAgICAgICAgIGxhbXBvcnRzOiBiYWxhbmNlTmVlZGVkIC0gcHJvZ3JhbUluZm8ubGFtcG9ydHNcbiAgICAgICAgICB9KSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRyYW5zYWN0aW9uID0gbmV3IFRyYW5zYWN0aW9uKCkuYWRkKFN5c3RlbVByb2dyYW0uY3JlYXRlQWNjb3VudCh7XG4gICAgICAgICAgZnJvbVB1YmtleTogcGF5ZXIucHVibGljS2V5LFxuICAgICAgICAgIG5ld0FjY291bnRQdWJrZXk6IHByb2dyYW0ucHVibGljS2V5LFxuICAgICAgICAgIGxhbXBvcnRzOiBiYWxhbmNlTmVlZGVkID4gMCA/IGJhbGFuY2VOZWVkZWQgOiAxLFxuICAgICAgICAgIHNwYWNlOiBkYXRhLmxlbmd0aCxcbiAgICAgICAgICBwcm9ncmFtSWRcbiAgICAgICAgfSkpO1xuICAgICAgfVxuXG4gICAgICAvLyBJZiB0aGUgYWNjb3VudCBpcyBhbHJlYWR5IGNyZWF0ZWQgY29ycmVjdGx5LCBza2lwIHRoaXMgc3RlcFxuICAgICAgLy8gYW5kIHByb2NlZWQgZGlyZWN0bHkgdG8gbG9hZGluZyBpbnN0cnVjdGlvbnNcbiAgICAgIGlmICh0cmFuc2FjdGlvbiAhPT0gbnVsbCkge1xuICAgICAgICBhd2FpdCBzZW5kQW5kQ29uZmlybVRyYW5zYWN0aW9uKGNvbm5lY3Rpb24sIHRyYW5zYWN0aW9uLCBbcGF5ZXIsIHByb2dyYW1dLCB7XG4gICAgICAgICAgY29tbWl0bWVudDogJ2NvbmZpcm1lZCdcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IGRhdGFMYXlvdXQgPSBCdWZmZXJMYXlvdXQuc3RydWN0KFtCdWZmZXJMYXlvdXQudTMyKCdpbnN0cnVjdGlvbicpLCBCdWZmZXJMYXlvdXQudTMyKCdvZmZzZXQnKSwgQnVmZmVyTGF5b3V0LnUzMignYnl0ZXNMZW5ndGgnKSwgQnVmZmVyTGF5b3V0LnUzMignYnl0ZXNMZW5ndGhQYWRkaW5nJyksIEJ1ZmZlckxheW91dC5zZXEoQnVmZmVyTGF5b3V0LnU4KCdieXRlJyksIEJ1ZmZlckxheW91dC5vZmZzZXQoQnVmZmVyTGF5b3V0LnUzMigpLCAtOCksICdieXRlcycpXSk7XG4gICAgY29uc3QgY2h1bmtTaXplID0gTG9hZGVyLmNodW5rU2l6ZTtcbiAgICBsZXQgb2Zmc2V0ID0gMDtcbiAgICBsZXQgYXJyYXkgPSBkYXRhO1xuICAgIGxldCB0cmFuc2FjdGlvbnMgPSBbXTtcbiAgICB3aGlsZSAoYXJyYXkubGVuZ3RoID4gMCkge1xuICAgICAgY29uc3QgYnl0ZXMgPSBhcnJheS5zbGljZSgwLCBjaHVua1NpemUpO1xuICAgICAgY29uc3QgZGF0YSA9IEJ1ZmZlci5hbGxvYyhjaHVua1NpemUgKyAxNik7XG4gICAgICBkYXRhTGF5b3V0LmVuY29kZSh7XG4gICAgICAgIGluc3RydWN0aW9uOiAwLFxuICAgICAgICAvLyBMb2FkIGluc3RydWN0aW9uXG4gICAgICAgIG9mZnNldCxcbiAgICAgICAgYnl0ZXM6IGJ5dGVzLFxuICAgICAgICBieXRlc0xlbmd0aDogMCxcbiAgICAgICAgYnl0ZXNMZW5ndGhQYWRkaW5nOiAwXG4gICAgICB9LCBkYXRhKTtcbiAgICAgIGNvbnN0IHRyYW5zYWN0aW9uID0gbmV3IFRyYW5zYWN0aW9uKCkuYWRkKHtcbiAgICAgICAga2V5czogW3tcbiAgICAgICAgICBwdWJrZXk6IHByb2dyYW0ucHVibGljS2V5LFxuICAgICAgICAgIGlzU2lnbmVyOiB0cnVlLFxuICAgICAgICAgIGlzV3JpdGFibGU6IHRydWVcbiAgICAgICAgfV0sXG4gICAgICAgIHByb2dyYW1JZCxcbiAgICAgICAgZGF0YVxuICAgICAgfSk7XG4gICAgICB0cmFuc2FjdGlvbnMucHVzaChzZW5kQW5kQ29uZmlybVRyYW5zYWN0aW9uKGNvbm5lY3Rpb24sIHRyYW5zYWN0aW9uLCBbcGF5ZXIsIHByb2dyYW1dLCB7XG4gICAgICAgIGNvbW1pdG1lbnQ6ICdjb25maXJtZWQnXG4gICAgICB9KSk7XG5cbiAgICAgIC8vIERlbGF5IGJldHdlZW4gc2VuZHMgaW4gYW4gYXR0ZW1wdCB0byByZWR1Y2UgcmF0ZSBsaW1pdCBlcnJvcnNcbiAgICAgIGlmIChjb25uZWN0aW9uLl9ycGNFbmRwb2ludC5pbmNsdWRlcygnc29sYW5hLmNvbScpKSB7XG4gICAgICAgIGNvbnN0IFJFUVVFU1RTX1BFUl9TRUNPTkQgPSA0O1xuICAgICAgICBhd2FpdCBzbGVlcCgxMDAwIC8gUkVRVUVTVFNfUEVSX1NFQ09ORCk7XG4gICAgICB9XG4gICAgICBvZmZzZXQgKz0gY2h1bmtTaXplO1xuICAgICAgYXJyYXkgPSBhcnJheS5zbGljZShjaHVua1NpemUpO1xuICAgIH1cbiAgICBhd2FpdCBQcm9taXNlLmFsbCh0cmFuc2FjdGlvbnMpO1xuXG4gICAgLy8gRmluYWxpemUgdGhlIGFjY291bnQgbG9hZGVkIHdpdGggcHJvZ3JhbSBkYXRhIGZvciBleGVjdXRpb25cbiAgICB7XG4gICAgICBjb25zdCBkYXRhTGF5b3V0ID0gQnVmZmVyTGF5b3V0LnN0cnVjdChbQnVmZmVyTGF5b3V0LnUzMignaW5zdHJ1Y3Rpb24nKV0pO1xuICAgICAgY29uc3QgZGF0YSA9IEJ1ZmZlci5hbGxvYyhkYXRhTGF5b3V0LnNwYW4pO1xuICAgICAgZGF0YUxheW91dC5lbmNvZGUoe1xuICAgICAgICBpbnN0cnVjdGlvbjogMSAvLyBGaW5hbGl6ZSBpbnN0cnVjdGlvblxuICAgICAgfSwgZGF0YSk7XG4gICAgICBjb25zdCB0cmFuc2FjdGlvbiA9IG5ldyBUcmFuc2FjdGlvbigpLmFkZCh7XG4gICAgICAgIGtleXM6IFt7XG4gICAgICAgICAgcHVia2V5OiBwcm9ncmFtLnB1YmxpY0tleSxcbiAgICAgICAgICBpc1NpZ25lcjogdHJ1ZSxcbiAgICAgICAgICBpc1dyaXRhYmxlOiB0cnVlXG4gICAgICAgIH0sIHtcbiAgICAgICAgICBwdWJrZXk6IFNZU1ZBUl9SRU5UX1BVQktFWSxcbiAgICAgICAgICBpc1NpZ25lcjogZmFsc2UsXG4gICAgICAgICAgaXNXcml0YWJsZTogZmFsc2VcbiAgICAgICAgfV0sXG4gICAgICAgIHByb2dyYW1JZCxcbiAgICAgICAgZGF0YVxuICAgICAgfSk7XG4gICAgICBjb25zdCBkZXBsb3lDb21taXRtZW50ID0gJ3Byb2Nlc3NlZCc7XG4gICAgICBjb25zdCBmaW5hbGl6ZVNpZ25hdHVyZSA9IGF3YWl0IGNvbm5lY3Rpb24uc2VuZFRyYW5zYWN0aW9uKHRyYW5zYWN0aW9uLCBbcGF5ZXIsIHByb2dyYW1dLCB7XG4gICAgICAgIHByZWZsaWdodENvbW1pdG1lbnQ6IGRlcGxveUNvbW1pdG1lbnRcbiAgICAgIH0pO1xuICAgICAgY29uc3Qge1xuICAgICAgICBjb250ZXh0LFxuICAgICAgICB2YWx1ZVxuICAgICAgfSA9IGF3YWl0IGNvbm5lY3Rpb24uY29uZmlybVRyYW5zYWN0aW9uKHtcbiAgICAgICAgc2lnbmF0dXJlOiBmaW5hbGl6ZVNpZ25hdHVyZSxcbiAgICAgICAgbGFzdFZhbGlkQmxvY2tIZWlnaHQ6IHRyYW5zYWN0aW9uLmxhc3RWYWxpZEJsb2NrSGVpZ2h0LFxuICAgICAgICBibG9ja2hhc2g6IHRyYW5zYWN0aW9uLnJlY2VudEJsb2NraGFzaFxuICAgICAgfSwgZGVwbG95Q29tbWl0bWVudCk7XG4gICAgICBpZiAodmFsdWUuZXJyKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgVHJhbnNhY3Rpb24gJHtmaW5hbGl6ZVNpZ25hdHVyZX0gZmFpbGVkICgke0pTT04uc3RyaW5naWZ5KHZhbHVlKX0pYCk7XG4gICAgICB9XG4gICAgICAvLyBXZSBwcmV2ZW50IHByb2dyYW1zIGZyb20gYmVpbmcgdXNhYmxlIHVudGlsIHRoZSBzbG90IGFmdGVyIHRoZWlyIGRlcGxveW1lbnQuXG4gICAgICAvLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL3NvbGFuYS1sYWJzL3NvbGFuYS9wdWxsLzI5NjU0XG4gICAgICB3aGlsZSAodHJ1ZSAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLWNvbnN0YW50LWNvbmRpdGlvblxuICAgICAgKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgY29uc3QgY3VycmVudFNsb3QgPSBhd2FpdCBjb25uZWN0aW9uLmdldFNsb3Qoe1xuICAgICAgICAgICAgY29tbWl0bWVudDogZGVwbG95Q29tbWl0bWVudFxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGlmIChjdXJyZW50U2xvdCA+IGNvbnRleHQuc2xvdCkge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoIHtcbiAgICAgICAgICAvKiBlbXB0eSAqL1xuICAgICAgICB9XG4gICAgICAgIGF3YWl0IG5ldyBQcm9taXNlKHJlc29sdmUgPT4gc2V0VGltZW91dChyZXNvbHZlLCBNYXRoLnJvdW5kKE1TX1BFUl9TTE9UIC8gMikpKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBzdWNjZXNzXG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbn1cbkxvYWRlci5jaHVua1NpemUgPSBDSFVOS19TSVpFO1xuXG4vKipcbiAqIEBkZXByZWNhdGVkIERlcHJlY2F0ZWQgc2luY2UgU29sYW5hIHYxLjE3LjIwLlxuICovXG5jb25zdCBCUEZfTE9BREVSX1BST0dSQU1fSUQgPSBuZXcgUHVibGljS2V5KCdCUEZMb2FkZXIyMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExJyk7XG5cbi8qKlxuICogRmFjdG9yeSBjbGFzcyBmb3IgdHJhbnNhY3Rpb25zIHRvIGludGVyYWN0IHdpdGggYSBwcm9ncmFtIGxvYWRlclxuICpcbiAqIEBkZXByZWNhdGVkIERlcHJlY2F0ZWQgc2luY2UgU29sYW5hIHYxLjE3LjIwLlxuICovXG5jbGFzcyBCcGZMb2FkZXIge1xuICAvKipcbiAgICogTWluaW11bSBudW1iZXIgb2Ygc2lnbmF0dXJlcyByZXF1aXJlZCB0byBsb2FkIGEgcHJvZ3JhbSBub3QgaW5jbHVkaW5nXG4gICAqIHJldHJpZXNcbiAgICpcbiAgICogQ2FuIGJlIHVzZWQgdG8gY2FsY3VsYXRlIHRyYW5zYWN0aW9uIGZlZXNcbiAgICovXG4gIHN0YXRpYyBnZXRNaW5OdW1TaWduYXR1cmVzKGRhdGFMZW5ndGgpIHtcbiAgICByZXR1cm4gTG9hZGVyLmdldE1pbk51bVNpZ25hdHVyZXMoZGF0YUxlbmd0aCk7XG4gIH1cblxuICAvKipcbiAgICogTG9hZCBhIFNCRiBwcm9ncmFtXG4gICAqXG4gICAqIEBwYXJhbSBjb25uZWN0aW9uIFRoZSBjb25uZWN0aW9uIHRvIHVzZVxuICAgKiBAcGFyYW0gcGF5ZXIgQWNjb3VudCB0aGF0IHdpbGwgcGF5IHByb2dyYW0gbG9hZGluZyBmZWVzXG4gICAqIEBwYXJhbSBwcm9ncmFtIEFjY291bnQgdG8gbG9hZCB0aGUgcHJvZ3JhbSBpbnRvXG4gICAqIEBwYXJhbSBlbGYgVGhlIGVudGlyZSBFTEYgY29udGFpbmluZyB0aGUgU0JGIHByb2dyYW1cbiAgICogQHBhcmFtIGxvYWRlclByb2dyYW1JZCBUaGUgcHJvZ3JhbSBpZCBvZiB0aGUgQlBGIGxvYWRlciB0byB1c2VcbiAgICogQHJldHVybiB0cnVlIGlmIHByb2dyYW0gd2FzIGxvYWRlZCBzdWNjZXNzZnVsbHksIGZhbHNlIGlmIHByb2dyYW0gd2FzIGFscmVhZHkgbG9hZGVkXG4gICAqL1xuICBzdGF0aWMgbG9hZChjb25uZWN0aW9uLCBwYXllciwgcHJvZ3JhbSwgZWxmLCBsb2FkZXJQcm9ncmFtSWQpIHtcbiAgICByZXR1cm4gTG9hZGVyLmxvYWQoY29ubmVjdGlvbiwgcGF5ZXIsIHByb2dyYW0sIGxvYWRlclByb2dyYW1JZCwgZWxmKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBnZXREZWZhdWx0RXhwb3J0RnJvbUNqcyAoeCkge1xuXHRyZXR1cm4geCAmJiB4Ll9fZXNNb2R1bGUgJiYgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHgsICdkZWZhdWx0JykgPyB4WydkZWZhdWx0J10gOiB4O1xufVxuXG52YXIgYWdlbnRrZWVwYWxpdmUgPSB7ZXhwb3J0czoge319O1xuXG4vKipcbiAqIEhlbHBlcnMuXG4gKi9cblxudmFyIHMgPSAxMDAwO1xudmFyIG0gPSBzICogNjA7XG52YXIgaCA9IG0gKiA2MDtcbnZhciBkID0gaCAqIDI0O1xudmFyIHcgPSBkICogNztcbnZhciB5ID0gZCAqIDM2NS4yNTtcblxuLyoqXG4gKiBQYXJzZSBvciBmb3JtYXQgdGhlIGdpdmVuIGB2YWxgLlxuICpcbiAqIE9wdGlvbnM6XG4gKlxuICogIC0gYGxvbmdgIHZlcmJvc2UgZm9ybWF0dGluZyBbZmFsc2VdXG4gKlxuICogQHBhcmFtIHtTdHJpbmd8TnVtYmVyfSB2YWxcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAqIEB0aHJvd3Mge0Vycm9yfSB0aHJvdyBhbiBlcnJvciBpZiB2YWwgaXMgbm90IGEgbm9uLWVtcHR5IHN0cmluZyBvciBhIG51bWJlclxuICogQHJldHVybiB7U3RyaW5nfE51bWJlcn1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxudmFyIG1zJDIgPSBmdW5jdGlvbiAodmFsLCBvcHRpb25zKSB7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICB2YXIgdHlwZSA9IHR5cGVvZiB2YWw7XG4gIGlmICh0eXBlID09PSAnc3RyaW5nJyAmJiB2YWwubGVuZ3RoID4gMCkge1xuICAgIHJldHVybiBwYXJzZSh2YWwpO1xuICB9IGVsc2UgaWYgKHR5cGUgPT09ICdudW1iZXInICYmIGlzRmluaXRlKHZhbCkpIHtcbiAgICByZXR1cm4gb3B0aW9ucy5sb25nID8gZm10TG9uZyh2YWwpIDogZm10U2hvcnQodmFsKTtcbiAgfVxuICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgJ3ZhbCBpcyBub3QgYSBub24tZW1wdHkgc3RyaW5nIG9yIGEgdmFsaWQgbnVtYmVyLiB2YWw9JyArXG4gICAgICBKU09OLnN0cmluZ2lmeSh2YWwpXG4gICk7XG59O1xuXG4vKipcbiAqIFBhcnNlIHRoZSBnaXZlbiBgc3RyYCBhbmQgcmV0dXJuIG1pbGxpc2Vjb25kcy5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyXG4gKiBAcmV0dXJuIHtOdW1iZXJ9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBwYXJzZShzdHIpIHtcbiAgc3RyID0gU3RyaW5nKHN0cik7XG4gIGlmIChzdHIubGVuZ3RoID4gMTAwKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHZhciBtYXRjaCA9IC9eKC0/KD86XFxkKyk/XFwuP1xcZCspICoobWlsbGlzZWNvbmRzP3xtc2Vjcz98bXN8c2Vjb25kcz98c2Vjcz98c3xtaW51dGVzP3xtaW5zP3xtfGhvdXJzP3xocnM/fGh8ZGF5cz98ZHx3ZWVrcz98d3x5ZWFycz98eXJzP3x5KT8kL2kuZXhlYyhcbiAgICBzdHJcbiAgKTtcbiAgaWYgKCFtYXRjaCkge1xuICAgIHJldHVybjtcbiAgfVxuICB2YXIgbiA9IHBhcnNlRmxvYXQobWF0Y2hbMV0pO1xuICB2YXIgdHlwZSA9IChtYXRjaFsyXSB8fCAnbXMnKS50b0xvd2VyQ2FzZSgpO1xuICBzd2l0Y2ggKHR5cGUpIHtcbiAgICBjYXNlICd5ZWFycyc6XG4gICAgY2FzZSAneWVhcic6XG4gICAgY2FzZSAneXJzJzpcbiAgICBjYXNlICd5cic6XG4gICAgY2FzZSAneSc6XG4gICAgICByZXR1cm4gbiAqIHk7XG4gICAgY2FzZSAnd2Vla3MnOlxuICAgIGNhc2UgJ3dlZWsnOlxuICAgIGNhc2UgJ3cnOlxuICAgICAgcmV0dXJuIG4gKiB3O1xuICAgIGNhc2UgJ2RheXMnOlxuICAgIGNhc2UgJ2RheSc6XG4gICAgY2FzZSAnZCc6XG4gICAgICByZXR1cm4gbiAqIGQ7XG4gICAgY2FzZSAnaG91cnMnOlxuICAgIGNhc2UgJ2hvdXInOlxuICAgIGNhc2UgJ2hycyc6XG4gICAgY2FzZSAnaHInOlxuICAgIGNhc2UgJ2gnOlxuICAgICAgcmV0dXJuIG4gKiBoO1xuICAgIGNhc2UgJ21pbnV0ZXMnOlxuICAgIGNhc2UgJ21pbnV0ZSc6XG4gICAgY2FzZSAnbWlucyc6XG4gICAgY2FzZSAnbWluJzpcbiAgICBjYXNlICdtJzpcbiAgICAgIHJldHVybiBuICogbTtcbiAgICBjYXNlICdzZWNvbmRzJzpcbiAgICBjYXNlICdzZWNvbmQnOlxuICAgIGNhc2UgJ3NlY3MnOlxuICAgIGNhc2UgJ3NlYyc6XG4gICAgY2FzZSAncyc6XG4gICAgICByZXR1cm4gbiAqIHM7XG4gICAgY2FzZSAnbWlsbGlzZWNvbmRzJzpcbiAgICBjYXNlICdtaWxsaXNlY29uZCc6XG4gICAgY2FzZSAnbXNlY3MnOlxuICAgIGNhc2UgJ21zZWMnOlxuICAgIGNhc2UgJ21zJzpcbiAgICAgIHJldHVybiBuO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG59XG5cbi8qKlxuICogU2hvcnQgZm9ybWF0IGZvciBgbXNgLlxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSBtc1xuICogQHJldHVybiB7U3RyaW5nfVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gZm10U2hvcnQobXMpIHtcbiAgdmFyIG1zQWJzID0gTWF0aC5hYnMobXMpO1xuICBpZiAobXNBYnMgPj0gZCkge1xuICAgIHJldHVybiBNYXRoLnJvdW5kKG1zIC8gZCkgKyAnZCc7XG4gIH1cbiAgaWYgKG1zQWJzID49IGgpIHtcbiAgICByZXR1cm4gTWF0aC5yb3VuZChtcyAvIGgpICsgJ2gnO1xuICB9XG4gIGlmIChtc0FicyA+PSBtKSB7XG4gICAgcmV0dXJuIE1hdGgucm91bmQobXMgLyBtKSArICdtJztcbiAgfVxuICBpZiAobXNBYnMgPj0gcykge1xuICAgIHJldHVybiBNYXRoLnJvdW5kKG1zIC8gcykgKyAncyc7XG4gIH1cbiAgcmV0dXJuIG1zICsgJ21zJztcbn1cblxuLyoqXG4gKiBMb25nIGZvcm1hdCBmb3IgYG1zYC5cbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gbXNcbiAqIEByZXR1cm4ge1N0cmluZ31cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIGZtdExvbmcobXMpIHtcbiAgdmFyIG1zQWJzID0gTWF0aC5hYnMobXMpO1xuICBpZiAobXNBYnMgPj0gZCkge1xuICAgIHJldHVybiBwbHVyYWwobXMsIG1zQWJzLCBkLCAnZGF5Jyk7XG4gIH1cbiAgaWYgKG1zQWJzID49IGgpIHtcbiAgICByZXR1cm4gcGx1cmFsKG1zLCBtc0FicywgaCwgJ2hvdXInKTtcbiAgfVxuICBpZiAobXNBYnMgPj0gbSkge1xuICAgIHJldHVybiBwbHVyYWwobXMsIG1zQWJzLCBtLCAnbWludXRlJyk7XG4gIH1cbiAgaWYgKG1zQWJzID49IHMpIHtcbiAgICByZXR1cm4gcGx1cmFsKG1zLCBtc0FicywgcywgJ3NlY29uZCcpO1xuICB9XG4gIHJldHVybiBtcyArICcgbXMnO1xufVxuXG4vKipcbiAqIFBsdXJhbGl6YXRpb24gaGVscGVyLlxuICovXG5cbmZ1bmN0aW9uIHBsdXJhbChtcywgbXNBYnMsIG4sIG5hbWUpIHtcbiAgdmFyIGlzUGx1cmFsID0gbXNBYnMgPj0gbiAqIDEuNTtcbiAgcmV0dXJuIE1hdGgucm91bmQobXMgLyBuKSArICcgJyArIG5hbWUgKyAoaXNQbHVyYWwgPyAncycgOiAnJyk7XG59XG5cbi8qIVxuICogaHVtYW5pemUtbXMgLSBpbmRleC5qc1xuICogQ29weXJpZ2h0KGMpIDIwMTQgZGVhZF9ob3JzZSA8ZGVhZF9ob3JzZUBxcS5jb20+XG4gKiBNSVQgTGljZW5zZWRcbiAqL1xuXG4vKipcbiAqIE1vZHVsZSBkZXBlbmRlbmNpZXMuXG4gKi9cblxudmFyIHV0aWwgPSByZXF1aXJlJCQwO1xudmFyIG1zJDEgPSBtcyQyO1xuXG52YXIgaHVtYW5pemVNcyA9IGZ1bmN0aW9uICh0KSB7XG4gIGlmICh0eXBlb2YgdCA9PT0gJ251bWJlcicpIHJldHVybiB0O1xuICB2YXIgciA9IG1zJDEodCk7XG4gIGlmIChyID09PSB1bmRlZmluZWQpIHtcbiAgICB2YXIgZXJyID0gbmV3IEVycm9yKHV0aWwuZm9ybWF0KCdodW1hbml6ZS1tcyglaikgcmVzdWx0IHVuZGVmaW5lZCcsIHQpKTtcbiAgICBjb25zb2xlLndhcm4oZXJyLnN0YWNrKTtcbiAgfVxuICByZXR1cm4gcjtcbn07XG5cbnZhciBjb25zdGFudHMgPSB7XG4gIC8vIGFnZW50XG4gIENVUlJFTlRfSUQ6IFN5bWJvbCgnYWdlbnRrZWVwYWxpdmUjY3VycmVudElkJyksXG4gIENSRUFURV9JRDogU3ltYm9sKCdhZ2VudGtlZXBhbGl2ZSNjcmVhdGVJZCcpLFxuICBJTklUX1NPQ0tFVDogU3ltYm9sKCdhZ2VudGtlZXBhbGl2ZSNpbml0U29ja2V0JyksXG4gIENSRUFURV9IVFRQU19DT05ORUNUSU9OOiBTeW1ib2woJ2FnZW50a2VlcGFsaXZlI2NyZWF0ZUh0dHBzQ29ubmVjdGlvbicpLFxuICAvLyBzb2NrZXRcbiAgU09DS0VUX0NSRUFURURfVElNRTogU3ltYm9sKCdhZ2VudGtlZXBhbGl2ZSNzb2NrZXRDcmVhdGVkVGltZScpLFxuICBTT0NLRVRfTkFNRTogU3ltYm9sKCdhZ2VudGtlZXBhbGl2ZSNzb2NrZXROYW1lJyksXG4gIFNPQ0tFVF9SRVFVRVNUX0NPVU5UOiBTeW1ib2woJ2FnZW50a2VlcGFsaXZlI3NvY2tldFJlcXVlc3RDb3VudCcpLFxuICBTT0NLRVRfUkVRVUVTVF9GSU5JU0hFRF9DT1VOVDogU3ltYm9sKCdhZ2VudGtlZXBhbGl2ZSNzb2NrZXRSZXF1ZXN0RmluaXNoZWRDb3VudCcpLFxufTtcblxuY29uc3QgT3JpZ2luYWxBZ2VudCA9IHJlcXVpcmUkJDAkMS5BZ2VudDtcbmNvbnN0IG1zID0gaHVtYW5pemVNcztcbmNvbnN0IGRlYnVnID0gcmVxdWlyZSQkMC5kZWJ1Z2xvZygnYWdlbnRrZWVwYWxpdmUnKTtcbmNvbnN0IHtcbiAgSU5JVF9TT0NLRVQ6IElOSVRfU09DS0VUJDEsXG4gIENVUlJFTlRfSUQsXG4gIENSRUFURV9JRCxcbiAgU09DS0VUX0NSRUFURURfVElNRSxcbiAgU09DS0VUX05BTUUsXG4gIFNPQ0tFVF9SRVFVRVNUX0NPVU5ULFxuICBTT0NLRVRfUkVRVUVTVF9GSU5JU0hFRF9DT1VOVCxcbn0gPSBjb25zdGFudHM7XG5cbi8vIE9yaWdpbmFsQWdlbnQgY29tZSBmcm9tXG4vLyAtIGh0dHBzOi8vZ2l0aHViLmNvbS9ub2RlanMvbm9kZS9ibG9iL3Y4LjEyLjAvbGliL19odHRwX2FnZW50LmpzXG4vLyAtIGh0dHBzOi8vZ2l0aHViLmNvbS9ub2RlanMvbm9kZS9ibG9iL3YxMC4xMi4wL2xpYi9faHR0cF9hZ2VudC5qc1xuXG4vLyBub2RlIDw9IDEwXG5sZXQgZGVmYXVsdFRpbWVvdXRMaXN0ZW5lckNvdW50ID0gMTtcbmNvbnN0IG1ham9yVmVyc2lvbiA9IHBhcnNlSW50KHByb2Nlc3MudmVyc2lvbi5zcGxpdCgnLicsIDEpWzBdLnN1YnN0cmluZygxKSk7XG5pZiAobWFqb3JWZXJzaW9uID49IDExICYmIG1ham9yVmVyc2lvbiA8PSAxMikge1xuICBkZWZhdWx0VGltZW91dExpc3RlbmVyQ291bnQgPSAyO1xufSBlbHNlIGlmIChtYWpvclZlcnNpb24gPj0gMTMpIHtcbiAgZGVmYXVsdFRpbWVvdXRMaXN0ZW5lckNvdW50ID0gMztcbn1cblxuZnVuY3Rpb24gZGVwcmVjYXRlKG1lc3NhZ2UpIHtcbiAgY29uc29sZS5sb2coJ1thZ2VudGtlZXBhbGl2ZTpkZXByZWNhdGVkXSAlcycsIG1lc3NhZ2UpO1xufVxuXG5jbGFzcyBBZ2VudCBleHRlbmRzIE9yaWdpbmFsQWdlbnQge1xuICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgb3B0aW9ucy5rZWVwQWxpdmUgPSBvcHRpb25zLmtlZXBBbGl2ZSAhPT0gZmFsc2U7XG4gICAgLy8gZGVmYXVsdCBpcyBrZWVwLWFsaXZlIGFuZCA0cyBmcmVlIHNvY2tldCB0aW1lb3V0XG4gICAgLy8gc2VlIGh0dHBzOi8vbWVkaXVtLmNvbS9zc2Vuc2UtdGVjaC9yZWR1Y2UtbmV0d29ya2luZy1lcnJvcnMtaW4tbm9kZWpzLTIzYjRlYjlmMmQ4M1xuICAgIGlmIChvcHRpb25zLmZyZWVTb2NrZXRUaW1lb3V0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgIG9wdGlvbnMuZnJlZVNvY2tldFRpbWVvdXQgPSA0MDAwO1xuICAgIH1cbiAgICAvLyBMZWdhY3kgQVBJOiBrZWVwQWxpdmVUaW1lb3V0IHNob3VsZCBiZSByZW5hbWUgdG8gYGZyZWVTb2NrZXRUaW1lb3V0YFxuICAgIGlmIChvcHRpb25zLmtlZXBBbGl2ZVRpbWVvdXQpIHtcbiAgICAgIGRlcHJlY2F0ZSgnb3B0aW9ucy5rZWVwQWxpdmVUaW1lb3V0IGlzIGRlcHJlY2F0ZWQsIHBsZWFzZSB1c2Ugb3B0aW9ucy5mcmVlU29ja2V0VGltZW91dCBpbnN0ZWFkJyk7XG4gICAgICBvcHRpb25zLmZyZWVTb2NrZXRUaW1lb3V0ID0gb3B0aW9ucy5rZWVwQWxpdmVUaW1lb3V0O1xuICAgICAgZGVsZXRlIG9wdGlvbnMua2VlcEFsaXZlVGltZW91dDtcbiAgICB9XG4gICAgLy8gTGVnYWN5IEFQSTogZnJlZVNvY2tldEtlZXBBbGl2ZVRpbWVvdXQgc2hvdWxkIGJlIHJlbmFtZSB0byBgZnJlZVNvY2tldFRpbWVvdXRgXG4gICAgaWYgKG9wdGlvbnMuZnJlZVNvY2tldEtlZXBBbGl2ZVRpbWVvdXQpIHtcbiAgICAgIGRlcHJlY2F0ZSgnb3B0aW9ucy5mcmVlU29ja2V0S2VlcEFsaXZlVGltZW91dCBpcyBkZXByZWNhdGVkLCBwbGVhc2UgdXNlIG9wdGlvbnMuZnJlZVNvY2tldFRpbWVvdXQgaW5zdGVhZCcpO1xuICAgICAgb3B0aW9ucy5mcmVlU29ja2V0VGltZW91dCA9IG9wdGlvbnMuZnJlZVNvY2tldEtlZXBBbGl2ZVRpbWVvdXQ7XG4gICAgICBkZWxldGUgb3B0aW9ucy5mcmVlU29ja2V0S2VlcEFsaXZlVGltZW91dDtcbiAgICB9XG5cbiAgICAvLyBTZXRzIHRoZSBzb2NrZXQgdG8gdGltZW91dCBhZnRlciB0aW1lb3V0IG1pbGxpc2Vjb25kcyBvZiBpbmFjdGl2aXR5IG9uIHRoZSBzb2NrZXQuXG4gICAgLy8gQnkgZGVmYXVsdCBpcyBkb3VibGUgZnJlZSBzb2NrZXQgdGltZW91dC5cbiAgICBpZiAob3B0aW9ucy50aW1lb3V0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgIC8vIG1ha2Ugc3VyZSBzb2NrZXQgZGVmYXVsdCBpbmFjdGl2aXR5IHRpbWVvdXQgPj0gOHNcbiAgICAgIG9wdGlvbnMudGltZW91dCA9IE1hdGgubWF4KG9wdGlvbnMuZnJlZVNvY2tldFRpbWVvdXQgKiAyLCA4MDAwKTtcbiAgICB9XG5cbiAgICAvLyBzdXBwb3J0IGh1bWFuaXplIGZvcm1hdFxuICAgIG9wdGlvbnMudGltZW91dCA9IG1zKG9wdGlvbnMudGltZW91dCk7XG4gICAgb3B0aW9ucy5mcmVlU29ja2V0VGltZW91dCA9IG1zKG9wdGlvbnMuZnJlZVNvY2tldFRpbWVvdXQpO1xuICAgIG9wdGlvbnMuc29ja2V0QWN0aXZlVFRMID0gb3B0aW9ucy5zb2NrZXRBY3RpdmVUVEwgPyBtcyhvcHRpb25zLnNvY2tldEFjdGl2ZVRUTCkgOiAwO1xuXG4gICAgc3VwZXIob3B0aW9ucyk7XG5cbiAgICB0aGlzW0NVUlJFTlRfSURdID0gMDtcblxuICAgIC8vIGNyZWF0ZSBzb2NrZXQgc3VjY2VzcyBjb3VudGVyXG4gICAgdGhpcy5jcmVhdGVTb2NrZXRDb3VudCA9IDA7XG4gICAgdGhpcy5jcmVhdGVTb2NrZXRDb3VudExhc3RDaGVjayA9IDA7XG5cbiAgICB0aGlzLmNyZWF0ZVNvY2tldEVycm9yQ291bnQgPSAwO1xuICAgIHRoaXMuY3JlYXRlU29ja2V0RXJyb3JDb3VudExhc3RDaGVjayA9IDA7XG5cbiAgICB0aGlzLmNsb3NlU29ja2V0Q291bnQgPSAwO1xuICAgIHRoaXMuY2xvc2VTb2NrZXRDb3VudExhc3RDaGVjayA9IDA7XG5cbiAgICAvLyBzb2NrZXQgZXJyb3IgZXZlbnQgY291bnRcbiAgICB0aGlzLmVycm9yU29ja2V0Q291bnQgPSAwO1xuICAgIHRoaXMuZXJyb3JTb2NrZXRDb3VudExhc3RDaGVjayA9IDA7XG5cbiAgICAvLyByZXF1ZXN0IGZpbmlzaGVkIGNvdW50ZXJcbiAgICB0aGlzLnJlcXVlc3RDb3VudCA9IDA7XG4gICAgdGhpcy5yZXF1ZXN0Q291bnRMYXN0Q2hlY2sgPSAwO1xuXG4gICAgLy8gaW5jbHVkaW5nIGZyZWUgc29ja2V0IHRpbWVvdXQgY291bnRlclxuICAgIHRoaXMudGltZW91dFNvY2tldENvdW50ID0gMDtcbiAgICB0aGlzLnRpbWVvdXRTb2NrZXRDb3VudExhc3RDaGVjayA9IDA7XG5cbiAgICB0aGlzLm9uKCdmcmVlJywgc29ja2V0ID0+IHtcbiAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9ub2RlanMvbm9kZS9wdWxsLzMyMDAwXG4gICAgICAvLyBOb2RlLmpzIG5hdGl2ZSBhZ2VudCB3aWxsIGNoZWNrIHNvY2tldCB0aW1lb3V0IGVxcyBhZ2VudC5vcHRpb25zLnRpbWVvdXQuXG4gICAgICAvLyBVc2UgdGhlIHR0bCBvciBmcmVlU29ja2V0VGltZW91dCB0byBvdmVyd3JpdGUuXG4gICAgICBjb25zdCB0aW1lb3V0ID0gdGhpcy5jYWxjU29ja2V0VGltZW91dChzb2NrZXQpO1xuICAgICAgaWYgKHRpbWVvdXQgPiAwICYmIHNvY2tldC50aW1lb3V0ICE9PSB0aW1lb3V0KSB7XG4gICAgICAgIHNvY2tldC5zZXRUaW1lb3V0KHRpbWVvdXQpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgZ2V0IGZyZWVTb2NrZXRLZWVwQWxpdmVUaW1lb3V0KCkge1xuICAgIGRlcHJlY2F0ZSgnYWdlbnQuZnJlZVNvY2tldEtlZXBBbGl2ZVRpbWVvdXQgaXMgZGVwcmVjYXRlZCwgcGxlYXNlIHVzZSBhZ2VudC5vcHRpb25zLmZyZWVTb2NrZXRUaW1lb3V0IGluc3RlYWQnKTtcbiAgICByZXR1cm4gdGhpcy5vcHRpb25zLmZyZWVTb2NrZXRUaW1lb3V0O1xuICB9XG5cbiAgZ2V0IHRpbWVvdXQoKSB7XG4gICAgZGVwcmVjYXRlKCdhZ2VudC50aW1lb3V0IGlzIGRlcHJlY2F0ZWQsIHBsZWFzZSB1c2UgYWdlbnQub3B0aW9ucy50aW1lb3V0IGluc3RlYWQnKTtcbiAgICByZXR1cm4gdGhpcy5vcHRpb25zLnRpbWVvdXQ7XG4gIH1cblxuICBnZXQgc29ja2V0QWN0aXZlVFRMKCkge1xuICAgIGRlcHJlY2F0ZSgnYWdlbnQuc29ja2V0QWN0aXZlVFRMIGlzIGRlcHJlY2F0ZWQsIHBsZWFzZSB1c2UgYWdlbnQub3B0aW9ucy5zb2NrZXRBY3RpdmVUVEwgaW5zdGVhZCcpO1xuICAgIHJldHVybiB0aGlzLm9wdGlvbnMuc29ja2V0QWN0aXZlVFRMO1xuICB9XG5cbiAgY2FsY1NvY2tldFRpbWVvdXQoc29ja2V0KSB7XG4gICAgLyoqXG4gICAgICogcmV0dXJuIDw9IDA6IHNob3VsZCBmcmVlIHNvY2tldFxuICAgICAqIHJldHVybiA+IDA6IHNob3VsZCB1cGRhdGUgc29ja2V0IHRpbWVvdXRcbiAgICAgKiByZXR1cm4gdW5kZWZpbmVkOiBub3QgZmluZCBjdXN0b20gdGltZW91dFxuICAgICAqL1xuICAgIGxldCBmcmVlU29ja2V0VGltZW91dCA9IHRoaXMub3B0aW9ucy5mcmVlU29ja2V0VGltZW91dDtcbiAgICBjb25zdCBzb2NrZXRBY3RpdmVUVEwgPSB0aGlzLm9wdGlvbnMuc29ja2V0QWN0aXZlVFRMO1xuICAgIGlmIChzb2NrZXRBY3RpdmVUVEwpIHtcbiAgICAgIC8vIGNoZWNrIHNvY2tldEFjdGl2ZVRUTFxuICAgICAgY29uc3QgYWxpdmVUaW1lID0gRGF0ZS5ub3coKSAtIHNvY2tldFtTT0NLRVRfQ1JFQVRFRF9USU1FXTtcbiAgICAgIGNvbnN0IGRpZmYgPSBzb2NrZXRBY3RpdmVUVEwgLSBhbGl2ZVRpbWU7XG4gICAgICBpZiAoZGlmZiA8PSAwKSB7XG4gICAgICAgIHJldHVybiBkaWZmO1xuICAgICAgfVxuICAgICAgaWYgKGZyZWVTb2NrZXRUaW1lb3V0ICYmIGRpZmYgPCBmcmVlU29ja2V0VGltZW91dCkge1xuICAgICAgICBmcmVlU29ja2V0VGltZW91dCA9IGRpZmY7XG4gICAgICB9XG4gICAgfVxuICAgIC8vIHNldCBmcmVlU29ja2V0VGltZW91dFxuICAgIGlmIChmcmVlU29ja2V0VGltZW91dCkge1xuICAgICAgLy8gc2V0IGZyZWUga2VlcGFsaXZlIHRpbWVyXG4gICAgICAvLyB0cnkgdG8gdXNlIHNvY2tldCBjdXN0b20gZnJlZVNvY2tldFRpbWVvdXQgZmlyc3QsIHN1cHBvcnQgaGVhZGVyc1sna2VlcC1hbGl2ZSddXG4gICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vbm9kZS1tb2R1bGVzL3VybGxpYi9ibG9iL2I3NjA1MzAyMDkyM2Y0ZDk5YTFjOTNjZjJlMTZlMGM1YmExMGJhY2YvbGliL3VybGxpYi5qcyNMNDk4XG4gICAgICBjb25zdCBjdXN0b21GcmVlU29ja2V0VGltZW91dCA9IHNvY2tldC5mcmVlU29ja2V0VGltZW91dCB8fCBzb2NrZXQuZnJlZVNvY2tldEtlZXBBbGl2ZVRpbWVvdXQ7XG4gICAgICByZXR1cm4gY3VzdG9tRnJlZVNvY2tldFRpbWVvdXQgfHwgZnJlZVNvY2tldFRpbWVvdXQ7XG4gICAgfVxuICB9XG5cbiAga2VlcFNvY2tldEFsaXZlKHNvY2tldCkge1xuICAgIGNvbnN0IHJlc3VsdCA9IHN1cGVyLmtlZXBTb2NrZXRBbGl2ZShzb2NrZXQpO1xuICAgIC8vIHNob3VsZCBub3Qga2VlcEFsaXZlLCBkbyBub3RoaW5nXG4gICAgaWYgKCFyZXN1bHQpIHJldHVybiByZXN1bHQ7XG5cbiAgICBjb25zdCBjdXN0b21UaW1lb3V0ID0gdGhpcy5jYWxjU29ja2V0VGltZW91dChzb2NrZXQpO1xuICAgIGlmICh0eXBlb2YgY3VzdG9tVGltZW91dCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBpZiAoY3VzdG9tVGltZW91dCA8PSAwKSB7XG4gICAgICBkZWJ1ZygnJXMocmVxdWVzdHM6ICVzLCBmaW5pc2hlZDogJXMpIGZyZWUgYnV0IG5lZWQgdG8gZGVzdHJveSBieSBUVEwsIHJlcXVlc3QgY291bnQgJXMsIGRpZmYgaXMgJXMnLFxuICAgICAgICBzb2NrZXRbU09DS0VUX05BTUVdLCBzb2NrZXRbU09DS0VUX1JFUVVFU1RfQ09VTlRdLCBzb2NrZXRbU09DS0VUX1JFUVVFU1RfRklOSVNIRURfQ09VTlRdLCBjdXN0b21UaW1lb3V0KTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKHNvY2tldC50aW1lb3V0ICE9PSBjdXN0b21UaW1lb3V0KSB7XG4gICAgICBzb2NrZXQuc2V0VGltZW91dChjdXN0b21UaW1lb3V0KTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICAvLyBvbmx5IGNhbGwgb24gYWRkUmVxdWVzdFxuICByZXVzZVNvY2tldCguLi5hcmdzKSB7XG4gICAgLy8gcmV1c2VTb2NrZXQoc29ja2V0LCByZXEpXG4gICAgc3VwZXIucmV1c2VTb2NrZXQoLi4uYXJncyk7XG4gICAgY29uc3Qgc29ja2V0ID0gYXJnc1swXTtcbiAgICBjb25zdCByZXEgPSBhcmdzWzFdO1xuICAgIHJlcS5yZXVzZWRTb2NrZXQgPSB0cnVlO1xuICAgIGNvbnN0IGFnZW50VGltZW91dCA9IHRoaXMub3B0aW9ucy50aW1lb3V0O1xuICAgIGlmIChnZXRTb2NrZXRUaW1lb3V0KHNvY2tldCkgIT09IGFnZW50VGltZW91dCkge1xuICAgICAgLy8gcmVzZXQgdGltZW91dCBiZWZvcmUgdXNlXG4gICAgICBzb2NrZXQuc2V0VGltZW91dChhZ2VudFRpbWVvdXQpO1xuICAgICAgZGVidWcoJyVzIHJlc2V0IHRpbWVvdXQgdG8gJXNtcycsIHNvY2tldFtTT0NLRVRfTkFNRV0sIGFnZW50VGltZW91dCk7XG4gICAgfVxuICAgIHNvY2tldFtTT0NLRVRfUkVRVUVTVF9DT1VOVF0rKztcbiAgICBkZWJ1ZygnJXMocmVxdWVzdHM6ICVzLCBmaW5pc2hlZDogJXMpIHJldXNlIG9uIGFkZFJlcXVlc3QsIHRpbWVvdXQgJXNtcycsXG4gICAgICBzb2NrZXRbU09DS0VUX05BTUVdLCBzb2NrZXRbU09DS0VUX1JFUVVFU1RfQ09VTlRdLCBzb2NrZXRbU09DS0VUX1JFUVVFU1RfRklOSVNIRURfQ09VTlRdLFxuICAgICAgZ2V0U29ja2V0VGltZW91dChzb2NrZXQpKTtcbiAgfVxuXG4gIFtDUkVBVEVfSURdKCkge1xuICAgIGNvbnN0IGlkID0gdGhpc1tDVVJSRU5UX0lEXSsrO1xuICAgIGlmICh0aGlzW0NVUlJFTlRfSURdID09PSBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUikgdGhpc1tDVVJSRU5UX0lEXSA9IDA7XG4gICAgcmV0dXJuIGlkO1xuICB9XG5cbiAgW0lOSVRfU09DS0VUJDFdKHNvY2tldCwgb3B0aW9ucykge1xuICAgIC8vIGJ1Z2ZpeCBoZXJlLlxuICAgIC8vIGh0dHBzIG9uIG5vZGUgOCwgMTAgd29uJ3Qgc2V0IGFnZW50Lm9wdGlvbnMudGltZW91dCBieSBkZWZhdWx0XG4gICAgLy8gVE9ETzogbmVlZCB0byBmaXggb24gbm9kZSBpdHNlbGZcbiAgICBpZiAob3B0aW9ucy50aW1lb3V0KSB7XG4gICAgICBjb25zdCB0aW1lb3V0ID0gZ2V0U29ja2V0VGltZW91dChzb2NrZXQpO1xuICAgICAgaWYgKCF0aW1lb3V0KSB7XG4gICAgICAgIHNvY2tldC5zZXRUaW1lb3V0KG9wdGlvbnMudGltZW91dCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHRoaXMub3B0aW9ucy5rZWVwQWxpdmUpIHtcbiAgICAgIC8vIERpc2FibGUgTmFnbGUncyBhbGdvcml0aG06IGh0dHA6Ly9ibG9nLmNhdXN0aWsuY29tLzIwMTIvMDQvMDgvc2NhbGluZy1ub2RlLWpzLXRvLTEwMGstY29uY3VycmVudC1jb25uZWN0aW9ucy9cbiAgICAgIC8vIGh0dHBzOi8vZmVuZ21rMi5jb20vYmVuY2htYXJrL25hZ2xlLWFsZ29yaXRobS1kZWxheWVkLWFjay1tb2NrLmh0bWxcbiAgICAgIHNvY2tldC5zZXROb0RlbGF5KHRydWUpO1xuICAgIH1cbiAgICB0aGlzLmNyZWF0ZVNvY2tldENvdW50Kys7XG4gICAgaWYgKHRoaXMub3B0aW9ucy5zb2NrZXRBY3RpdmVUVEwpIHtcbiAgICAgIHNvY2tldFtTT0NLRVRfQ1JFQVRFRF9USU1FXSA9IERhdGUubm93KCk7XG4gICAgfVxuICAgIC8vIGRvbid0IHNob3cgdGhlIGhvbGUgJy0tLS0tQkVHSU4gQ0VSVElGSUNBVEUtLS0tJyBrZXkgc3RyaW5nXG4gICAgc29ja2V0W1NPQ0tFVF9OQU1FXSA9IGBzb2NrWyR7dGhpc1tDUkVBVEVfSURdKCl9IyR7b3B0aW9ucy5fYWdlbnRLZXl9XWAuc3BsaXQoJy0tLS0tQkVHSU4nLCAxKVswXTtcbiAgICBzb2NrZXRbU09DS0VUX1JFUVVFU1RfQ09VTlRdID0gMTtcbiAgICBzb2NrZXRbU09DS0VUX1JFUVVFU1RfRklOSVNIRURfQ09VTlRdID0gMDtcbiAgICBpbnN0YWxsTGlzdGVuZXJzKHRoaXMsIHNvY2tldCwgb3B0aW9ucyk7XG4gIH1cblxuICBjcmVhdGVDb25uZWN0aW9uKG9wdGlvbnMsIG9uY3JlYXRlKSB7XG4gICAgbGV0IGNhbGxlZCA9IGZhbHNlO1xuICAgIGNvbnN0IG9uTmV3Q3JlYXRlID0gKGVyciwgc29ja2V0KSA9PiB7XG4gICAgICBpZiAoY2FsbGVkKSByZXR1cm47XG4gICAgICBjYWxsZWQgPSB0cnVlO1xuXG4gICAgICBpZiAoZXJyKSB7XG4gICAgICAgIHRoaXMuY3JlYXRlU29ja2V0RXJyb3JDb3VudCsrO1xuICAgICAgICByZXR1cm4gb25jcmVhdGUoZXJyKTtcbiAgICAgIH1cbiAgICAgIHRoaXNbSU5JVF9TT0NLRVQkMV0oc29ja2V0LCBvcHRpb25zKTtcbiAgICAgIG9uY3JlYXRlKGVyciwgc29ja2V0KTtcbiAgICB9O1xuXG4gICAgY29uc3QgbmV3U29ja2V0ID0gc3VwZXIuY3JlYXRlQ29ubmVjdGlvbihvcHRpb25zLCBvbk5ld0NyZWF0ZSk7XG4gICAgaWYgKG5ld1NvY2tldCkgb25OZXdDcmVhdGUobnVsbCwgbmV3U29ja2V0KTtcbiAgICByZXR1cm4gbmV3U29ja2V0O1xuICB9XG5cbiAgZ2V0IHN0YXR1c0NoYW5nZWQoKSB7XG4gICAgY29uc3QgY2hhbmdlZCA9IHRoaXMuY3JlYXRlU29ja2V0Q291bnQgIT09IHRoaXMuY3JlYXRlU29ja2V0Q291bnRMYXN0Q2hlY2sgfHxcbiAgICAgIHRoaXMuY3JlYXRlU29ja2V0RXJyb3JDb3VudCAhPT0gdGhpcy5jcmVhdGVTb2NrZXRFcnJvckNvdW50TGFzdENoZWNrIHx8XG4gICAgICB0aGlzLmNsb3NlU29ja2V0Q291bnQgIT09IHRoaXMuY2xvc2VTb2NrZXRDb3VudExhc3RDaGVjayB8fFxuICAgICAgdGhpcy5lcnJvclNvY2tldENvdW50ICE9PSB0aGlzLmVycm9yU29ja2V0Q291bnRMYXN0Q2hlY2sgfHxcbiAgICAgIHRoaXMudGltZW91dFNvY2tldENvdW50ICE9PSB0aGlzLnRpbWVvdXRTb2NrZXRDb3VudExhc3RDaGVjayB8fFxuICAgICAgdGhpcy5yZXF1ZXN0Q291bnQgIT09IHRoaXMucmVxdWVzdENvdW50TGFzdENoZWNrO1xuICAgIGlmIChjaGFuZ2VkKSB7XG4gICAgICB0aGlzLmNyZWF0ZVNvY2tldENvdW50TGFzdENoZWNrID0gdGhpcy5jcmVhdGVTb2NrZXRDb3VudDtcbiAgICAgIHRoaXMuY3JlYXRlU29ja2V0RXJyb3JDb3VudExhc3RDaGVjayA9IHRoaXMuY3JlYXRlU29ja2V0RXJyb3JDb3VudDtcbiAgICAgIHRoaXMuY2xvc2VTb2NrZXRDb3VudExhc3RDaGVjayA9IHRoaXMuY2xvc2VTb2NrZXRDb3VudDtcbiAgICAgIHRoaXMuZXJyb3JTb2NrZXRDb3VudExhc3RDaGVjayA9IHRoaXMuZXJyb3JTb2NrZXRDb3VudDtcbiAgICAgIHRoaXMudGltZW91dFNvY2tldENvdW50TGFzdENoZWNrID0gdGhpcy50aW1lb3V0U29ja2V0Q291bnQ7XG4gICAgICB0aGlzLnJlcXVlc3RDb3VudExhc3RDaGVjayA9IHRoaXMucmVxdWVzdENvdW50O1xuICAgIH1cbiAgICByZXR1cm4gY2hhbmdlZDtcbiAgfVxuXG4gIGdldEN1cnJlbnRTdGF0dXMoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGNyZWF0ZVNvY2tldENvdW50OiB0aGlzLmNyZWF0ZVNvY2tldENvdW50LFxuICAgICAgY3JlYXRlU29ja2V0RXJyb3JDb3VudDogdGhpcy5jcmVhdGVTb2NrZXRFcnJvckNvdW50LFxuICAgICAgY2xvc2VTb2NrZXRDb3VudDogdGhpcy5jbG9zZVNvY2tldENvdW50LFxuICAgICAgZXJyb3JTb2NrZXRDb3VudDogdGhpcy5lcnJvclNvY2tldENvdW50LFxuICAgICAgdGltZW91dFNvY2tldENvdW50OiB0aGlzLnRpbWVvdXRTb2NrZXRDb3VudCxcbiAgICAgIHJlcXVlc3RDb3VudDogdGhpcy5yZXF1ZXN0Q291bnQsXG4gICAgICBmcmVlU29ja2V0czogaW5zcGVjdCh0aGlzLmZyZWVTb2NrZXRzKSxcbiAgICAgIHNvY2tldHM6IGluc3BlY3QodGhpcy5zb2NrZXRzKSxcbiAgICAgIHJlcXVlc3RzOiBpbnNwZWN0KHRoaXMucmVxdWVzdHMpLFxuICAgIH07XG4gIH1cbn1cblxuLy8gbm9kZSA4IGRvbid0IGhhcyB0aW1lb3V0IGF0dHJpYnV0ZSBvbiBzb2NrZXRcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9ub2RlanMvbm9kZS9wdWxsLzIxMjA0L2ZpbGVzI2RpZmYtZTZlZjAyNGMzNzc1ZDc4N2MzODQ4N2E2MzA5ZTQ5MWRSNDA4XG5mdW5jdGlvbiBnZXRTb2NrZXRUaW1lb3V0KHNvY2tldCkge1xuICByZXR1cm4gc29ja2V0LnRpbWVvdXQgfHwgc29ja2V0Ll9pZGxlVGltZW91dDtcbn1cblxuZnVuY3Rpb24gaW5zdGFsbExpc3RlbmVycyhhZ2VudCwgc29ja2V0LCBvcHRpb25zKSB7XG4gIGRlYnVnKCclcyBjcmVhdGUsIHRpbWVvdXQgJXNtcycsIHNvY2tldFtTT0NLRVRfTkFNRV0sIGdldFNvY2tldFRpbWVvdXQoc29ja2V0KSk7XG5cbiAgLy8gbGlzdGVuZXIgc29ja2V0IGV2ZW50czogY2xvc2UsIHRpbWVvdXQsIGVycm9yLCBmcmVlXG4gIGZ1bmN0aW9uIG9uRnJlZSgpIHtcbiAgICAvLyBjcmVhdGUgYW5kIHNvY2tldC5lbWl0KCdmcmVlJykgbG9naWNcbiAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vbm9kZWpzL25vZGUvYmxvYi9tYXN0ZXIvbGliL19odHRwX2FnZW50LmpzI0wzMTFcbiAgICAvLyBubyByZXEgb24gdGhlIHNvY2tldCwgaXQgc2hvdWxkIGJlIHRoZSBuZXcgc29ja2V0XG4gICAgaWYgKCFzb2NrZXQuX2h0dHBNZXNzYWdlICYmIHNvY2tldFtTT0NLRVRfUkVRVUVTVF9DT1VOVF0gPT09IDEpIHJldHVybjtcblxuICAgIHNvY2tldFtTT0NLRVRfUkVRVUVTVF9GSU5JU0hFRF9DT1VOVF0rKztcbiAgICBhZ2VudC5yZXF1ZXN0Q291bnQrKztcbiAgICBkZWJ1ZygnJXMocmVxdWVzdHM6ICVzLCBmaW5pc2hlZDogJXMpIGZyZWUnLFxuICAgICAgc29ja2V0W1NPQ0tFVF9OQU1FXSwgc29ja2V0W1NPQ0tFVF9SRVFVRVNUX0NPVU5UXSwgc29ja2V0W1NPQ0tFVF9SRVFVRVNUX0ZJTklTSEVEX0NPVU5UXSk7XG5cbiAgICAvLyBzaG91bGQgcmV1c2Ugb24gcGVkZGluZyByZXF1ZXN0cz9cbiAgICBjb25zdCBuYW1lID0gYWdlbnQuZ2V0TmFtZShvcHRpb25zKTtcbiAgICBpZiAoc29ja2V0LndyaXRhYmxlICYmIGFnZW50LnJlcXVlc3RzW25hbWVdICYmIGFnZW50LnJlcXVlc3RzW25hbWVdLmxlbmd0aCkge1xuICAgICAgLy8gd2lsbCBiZSByZXVzZSBvbiBhZ2VudCBmcmVlIGxpc3RlbmVyXG4gICAgICBzb2NrZXRbU09DS0VUX1JFUVVFU1RfQ09VTlRdKys7XG4gICAgICBkZWJ1ZygnJXMocmVxdWVzdHM6ICVzLCBmaW5pc2hlZDogJXMpIHdpbGwgYmUgcmV1c2Ugb24gYWdlbnQgZnJlZSBldmVudCcsXG4gICAgICAgIHNvY2tldFtTT0NLRVRfTkFNRV0sIHNvY2tldFtTT0NLRVRfUkVRVUVTVF9DT1VOVF0sIHNvY2tldFtTT0NLRVRfUkVRVUVTVF9GSU5JU0hFRF9DT1VOVF0pO1xuICAgIH1cbiAgfVxuICBzb2NrZXQub24oJ2ZyZWUnLCBvbkZyZWUpO1xuXG4gIGZ1bmN0aW9uIG9uQ2xvc2UoaXNFcnJvcikge1xuICAgIGRlYnVnKCclcyhyZXF1ZXN0czogJXMsIGZpbmlzaGVkOiAlcykgY2xvc2UsIGlzRXJyb3I6ICVzJyxcbiAgICAgIHNvY2tldFtTT0NLRVRfTkFNRV0sIHNvY2tldFtTT0NLRVRfUkVRVUVTVF9DT1VOVF0sIHNvY2tldFtTT0NLRVRfUkVRVUVTVF9GSU5JU0hFRF9DT1VOVF0sIGlzRXJyb3IpO1xuICAgIGFnZW50LmNsb3NlU29ja2V0Q291bnQrKztcbiAgfVxuICBzb2NrZXQub24oJ2Nsb3NlJywgb25DbG9zZSk7XG5cbiAgLy8gc3RhcnQgc29ja2V0IHRpbWVvdXQgaGFuZGxlclxuICBmdW5jdGlvbiBvblRpbWVvdXQoKSB7XG4gICAgLy8gb25UaW1lb3V0IGFuZCBlbWl0UmVxdWVzdFRpbWVvdXQoX2h0dHBfY2xpZW50LmpzKVxuICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9ub2RlanMvbm9kZS9ibG9iL3YxMi54L2xpYi9faHR0cF9jbGllbnQuanMjTDcxMVxuICAgIGNvbnN0IGxpc3RlbmVyQ291bnQgPSBzb2NrZXQubGlzdGVuZXJzKCd0aW1lb3V0JykubGVuZ3RoO1xuICAgIC8vIG5vZGUgPD0gMTAsIGRlZmF1bHQgbGlzdGVuZXJDb3VudCBpcyAxLCBvblRpbWVvdXRcbiAgICAvLyAxMSA8IG5vZGUgPD0gMTIsIGRlZmF1bHQgbGlzdGVuZXJDb3VudCBpcyAyLCBvblRpbWVvdXQgYW5kIGVtaXRSZXF1ZXN0VGltZW91dFxuICAgIC8vIG5vZGUgPj0gMTMsIGRlZmF1bHQgbGlzdGVuZXJDb3VudCBpcyAzLCBvblRpbWVvdXQsXG4gICAgLy8gICBvblRpbWVvdXQoaHR0cHM6Ly9naXRodWIuY29tL25vZGVqcy9ub2RlL3B1bGwvMzIwMDAvZmlsZXMjZGlmZi01ZjdmYjA4NTA0MTJjNmJlMTg5ZmFlZGRlYTZjNTM1OVIzMzMpXG4gICAgLy8gICBhbmQgZW1pdFJlcXVlc3RUaW1lb3V0XG4gICAgY29uc3QgdGltZW91dCA9IGdldFNvY2tldFRpbWVvdXQoc29ja2V0KTtcbiAgICBjb25zdCByZXEgPSBzb2NrZXQuX2h0dHBNZXNzYWdlO1xuICAgIGNvbnN0IHJlcVRpbWVvdXRMaXN0ZW5lckNvdW50ID0gcmVxICYmIHJlcS5saXN0ZW5lcnMoJ3RpbWVvdXQnKS5sZW5ndGggfHwgMDtcbiAgICBkZWJ1ZygnJXMocmVxdWVzdHM6ICVzLCBmaW5pc2hlZDogJXMpIHRpbWVvdXQgYWZ0ZXIgJXNtcywgbGlzdGVuZXJzICVzLCBkZWZhdWx0VGltZW91dExpc3RlbmVyQ291bnQgJXMsIGhhc0h0dHBSZXF1ZXN0ICVzLCBIdHRwUmVxdWVzdCB0aW1lb3V0TGlzdGVuZXJDb3VudCAlcycsXG4gICAgICBzb2NrZXRbU09DS0VUX05BTUVdLCBzb2NrZXRbU09DS0VUX1JFUVVFU1RfQ09VTlRdLCBzb2NrZXRbU09DS0VUX1JFUVVFU1RfRklOSVNIRURfQ09VTlRdLFxuICAgICAgdGltZW91dCwgbGlzdGVuZXJDb3VudCwgZGVmYXVsdFRpbWVvdXRMaXN0ZW5lckNvdW50LCAhIXJlcSwgcmVxVGltZW91dExpc3RlbmVyQ291bnQpO1xuICAgIGlmIChkZWJ1Zy5lbmFibGVkKSB7XG4gICAgICBkZWJ1ZygndGltZW91dCBsaXN0ZW5lcnM6ICVzJywgc29ja2V0Lmxpc3RlbmVycygndGltZW91dCcpLm1hcChmID0+IGYubmFtZSkuam9pbignLCAnKSk7XG4gICAgfVxuICAgIGFnZW50LnRpbWVvdXRTb2NrZXRDb3VudCsrO1xuICAgIGNvbnN0IG5hbWUgPSBhZ2VudC5nZXROYW1lKG9wdGlvbnMpO1xuICAgIGlmIChhZ2VudC5mcmVlU29ja2V0c1tuYW1lXSAmJiBhZ2VudC5mcmVlU29ja2V0c1tuYW1lXS5pbmRleE9mKHNvY2tldCkgIT09IC0xKSB7XG4gICAgICAvLyBmcmVlIHNvY2tldCB0aW1lb3V0LCBkZXN0cm95IHF1aWV0bHlcbiAgICAgIHNvY2tldC5kZXN0cm95KCk7XG4gICAgICAvLyBSZW1vdmUgaXQgZnJvbSBmcmVlU29ja2V0cyBsaXN0IGltbWVkaWF0ZWx5IHRvIHByZXZlbnQgbmV3IHJlcXVlc3RzXG4gICAgICAvLyBmcm9tIGJlaW5nIHNlbnQgdGhyb3VnaCB0aGlzIHNvY2tldC5cbiAgICAgIGFnZW50LnJlbW92ZVNvY2tldChzb2NrZXQsIG9wdGlvbnMpO1xuICAgICAgZGVidWcoJyVzIGlzIGZyZWUsIGRlc3Ryb3kgcXVpZXRseScsIHNvY2tldFtTT0NLRVRfTkFNRV0pO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBpZiB0aGVyZSBpcyBubyBhbnkgcmVxdWVzdCBzb2NrZXQgdGltZW91dCBoYW5kbGVyLFxuICAgICAgLy8gYWdlbnQgbmVlZCB0byBoYW5kbGUgc29ja2V0IHRpbWVvdXQgaXRzZWxmLlxuICAgICAgLy9cbiAgICAgIC8vIGN1c3RvbSByZXF1ZXN0IHNvY2tldCB0aW1lb3V0IGhhbmRsZSBsb2dpYyBtdXN0IGZvbGxvdyB0aGVzZSBydWxlczpcbiAgICAgIC8vICAxLiBEZXN0cm95IHNvY2tldCBmaXJzdFxuICAgICAgLy8gIDIuIE11c3QgZW1pdCBzb2NrZXQgJ2FnZW50UmVtb3ZlJyBldmVudCB0ZWxsIGFnZW50IHJlbW92ZSBzb2NrZXRcbiAgICAgIC8vICAgICBmcm9tIGZyZWVTb2NrZXRzIGxpc3QgaW1tZWRpYXRlbHkuXG4gICAgICAvLyAgICAgT3RoZXJpc2UgeW91IG1heSBiZSBnZXQgJ3NvY2tldCBoYW5nIHVwJyBlcnJvciB3aGVuIHJldXNlXG4gICAgICAvLyAgICAgZnJlZSBzb2NrZXQgYW5kIHRpbWVvdXQgaGFwcGVuIGluIHRoZSBzYW1lIHRpbWUuXG4gICAgICBpZiAocmVxVGltZW91dExpc3RlbmVyQ291bnQgPT09IDApIHtcbiAgICAgICAgY29uc3QgZXJyb3IgPSBuZXcgRXJyb3IoJ1NvY2tldCB0aW1lb3V0Jyk7XG4gICAgICAgIGVycm9yLmNvZGUgPSAnRVJSX1NPQ0tFVF9USU1FT1VUJztcbiAgICAgICAgZXJyb3IudGltZW91dCA9IHRpbWVvdXQ7XG4gICAgICAgIC8vIG11c3QgbWFudWFsbHkgY2FsbCBzb2NrZXQuZW5kKCkgb3Igc29ja2V0LmRlc3Ryb3koKSB0byBlbmQgdGhlIGNvbm5lY3Rpb24uXG4gICAgICAgIC8vIGh0dHBzOi8vbm9kZWpzLm9yZy9kaXN0L2xhdGVzdC12MTAueC9kb2NzL2FwaS9uZXQuaHRtbCNuZXRfc29ja2V0X3NldHRpbWVvdXRfdGltZW91dF9jYWxsYmFja1xuICAgICAgICBzb2NrZXQuZGVzdHJveShlcnJvcik7XG4gICAgICAgIGFnZW50LnJlbW92ZVNvY2tldChzb2NrZXQsIG9wdGlvbnMpO1xuICAgICAgICBkZWJ1ZygnJXMgZGVzdHJveSB3aXRoIHRpbWVvdXQgZXJyb3InLCBzb2NrZXRbU09DS0VUX05BTUVdKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgc29ja2V0Lm9uKCd0aW1lb3V0Jywgb25UaW1lb3V0KTtcblxuICBmdW5jdGlvbiBvbkVycm9yKGVycikge1xuICAgIGNvbnN0IGxpc3RlbmVyQ291bnQgPSBzb2NrZXQubGlzdGVuZXJzKCdlcnJvcicpLmxlbmd0aDtcbiAgICBkZWJ1ZygnJXMocmVxdWVzdHM6ICVzLCBmaW5pc2hlZDogJXMpIGVycm9yOiAlcywgbGlzdGVuZXJDb3VudDogJXMnLFxuICAgICAgc29ja2V0W1NPQ0tFVF9OQU1FXSwgc29ja2V0W1NPQ0tFVF9SRVFVRVNUX0NPVU5UXSwgc29ja2V0W1NPQ0tFVF9SRVFVRVNUX0ZJTklTSEVEX0NPVU5UXSxcbiAgICAgIGVyciwgbGlzdGVuZXJDb3VudCk7XG4gICAgYWdlbnQuZXJyb3JTb2NrZXRDb3VudCsrO1xuICAgIGlmIChsaXN0ZW5lckNvdW50ID09PSAxKSB7XG4gICAgICAvLyBpZiBzb2NrZXQgZG9uJ3QgY29udGFpbiBlcnJvciBldmVudCBoYW5kbGVyLCBkb24ndCBjYXRjaCBpdCwgZW1pdCBpdCBhZ2FpblxuICAgICAgZGVidWcoJyVzIGVtaXQgdW5jYXVnaHQgZXJyb3IgZXZlbnQnLCBzb2NrZXRbU09DS0VUX05BTUVdKTtcbiAgICAgIHNvY2tldC5yZW1vdmVMaXN0ZW5lcignZXJyb3InLCBvbkVycm9yKTtcbiAgICAgIHNvY2tldC5lbWl0KCdlcnJvcicsIGVycik7XG4gICAgfVxuICB9XG4gIHNvY2tldC5vbignZXJyb3InLCBvbkVycm9yKTtcblxuICBmdW5jdGlvbiBvblJlbW92ZSgpIHtcbiAgICBkZWJ1ZygnJXMocmVxdWVzdHM6ICVzLCBmaW5pc2hlZDogJXMpIGFnZW50UmVtb3ZlJyxcbiAgICAgIHNvY2tldFtTT0NLRVRfTkFNRV0sXG4gICAgICBzb2NrZXRbU09DS0VUX1JFUVVFU1RfQ09VTlRdLCBzb2NrZXRbU09DS0VUX1JFUVVFU1RfRklOSVNIRURfQ09VTlRdKTtcbiAgICAvLyBXZSBuZWVkIHRoaXMgZnVuY3Rpb24gZm9yIGNhc2VzIGxpa2UgSFRUUCAndXBncmFkZSdcbiAgICAvLyAoZGVmaW5lZCBieSBXZWJTb2NrZXRzKSB3aGVyZSB3ZSBuZWVkIHRvIHJlbW92ZSBhIHNvY2tldCBmcm9tIHRoZVxuICAgIC8vIHBvb2wgYmVjYXVzZSBpdCdsbCBiZSBsb2NrZWQgdXAgaW5kZWZpbml0ZWx5XG4gICAgc29ja2V0LnJlbW92ZUxpc3RlbmVyKCdjbG9zZScsIG9uQ2xvc2UpO1xuICAgIHNvY2tldC5yZW1vdmVMaXN0ZW5lcignZXJyb3InLCBvbkVycm9yKTtcbiAgICBzb2NrZXQucmVtb3ZlTGlzdGVuZXIoJ2ZyZWUnLCBvbkZyZWUpO1xuICAgIHNvY2tldC5yZW1vdmVMaXN0ZW5lcigndGltZW91dCcsIG9uVGltZW91dCk7XG4gICAgc29ja2V0LnJlbW92ZUxpc3RlbmVyKCdhZ2VudFJlbW92ZScsIG9uUmVtb3ZlKTtcbiAgfVxuICBzb2NrZXQub24oJ2FnZW50UmVtb3ZlJywgb25SZW1vdmUpO1xufVxuXG52YXIgYWdlbnQgPSBBZ2VudDtcblxuZnVuY3Rpb24gaW5zcGVjdChvYmopIHtcbiAgY29uc3QgcmVzID0ge307XG4gIGZvciAoY29uc3Qga2V5IGluIG9iaikge1xuICAgIHJlc1trZXldID0gb2JqW2tleV0ubGVuZ3RoO1xuICB9XG4gIHJldHVybiByZXM7XG59XG5cbmNvbnN0IE9yaWdpbmFsSHR0cHNBZ2VudCA9IHJlcXVpcmUkJDAkMi5BZ2VudDtcbmNvbnN0IEh0dHBBZ2VudCA9IGFnZW50O1xuY29uc3Qge1xuICBJTklUX1NPQ0tFVCxcbiAgQ1JFQVRFX0hUVFBTX0NPTk5FQ1RJT04sXG59ID0gY29uc3RhbnRzO1xuXG5sZXQgSHR0cHNBZ2VudCQxID0gY2xhc3MgSHR0cHNBZ2VudCBleHRlbmRzIEh0dHBBZ2VudCB7XG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICBzdXBlcihvcHRpb25zKTtcblxuICAgIHRoaXMuZGVmYXVsdFBvcnQgPSA0NDM7XG4gICAgdGhpcy5wcm90b2NvbCA9ICdodHRwczonO1xuICAgIHRoaXMubWF4Q2FjaGVkU2Vzc2lvbnMgPSB0aGlzLm9wdGlvbnMubWF4Q2FjaGVkU2Vzc2lvbnM7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICBpZiAodGhpcy5tYXhDYWNoZWRTZXNzaW9ucyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aGlzLm1heENhY2hlZFNlc3Npb25zID0gMTAwO1xuICAgIH1cblxuICAgIHRoaXMuX3Nlc3Npb25DYWNoZSA9IHtcbiAgICAgIG1hcDoge30sXG4gICAgICBsaXN0OiBbXSxcbiAgICB9O1xuICB9XG5cbiAgY3JlYXRlQ29ubmVjdGlvbihvcHRpb25zLCBvbmNyZWF0ZSkge1xuICAgIGNvbnN0IHNvY2tldCA9IHRoaXNbQ1JFQVRFX0hUVFBTX0NPTk5FQ1RJT05dKG9wdGlvbnMsIG9uY3JlYXRlKTtcbiAgICB0aGlzW0lOSVRfU09DS0VUXShzb2NrZXQsIG9wdGlvbnMpO1xuICAgIHJldHVybiBzb2NrZXQ7XG4gIH1cbn07XG5cbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9ub2RlanMvbm9kZS9ibG9iL21hc3Rlci9saWIvaHR0cHMuanMjTDg5XG5IdHRwc0FnZW50JDEucHJvdG90eXBlW0NSRUFURV9IVFRQU19DT05ORUNUSU9OXSA9IE9yaWdpbmFsSHR0cHNBZ2VudC5wcm90b3R5cGUuY3JlYXRlQ29ubmVjdGlvbjtcblxuW1xuICAnZ2V0TmFtZScsXG4gICdfZ2V0U2Vzc2lvbicsXG4gICdfY2FjaGVTZXNzaW9uJyxcbiAgLy8gaHR0cHM6Ly9naXRodWIuY29tL25vZGVqcy9ub2RlL3B1bGwvNDk4MlxuICAnX2V2aWN0U2Vzc2lvbicsXG5dLmZvckVhY2goZnVuY3Rpb24obWV0aG9kKSB7XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gIGlmICh0eXBlb2YgT3JpZ2luYWxIdHRwc0FnZW50LnByb3RvdHlwZVttZXRob2RdID09PSAnZnVuY3Rpb24nKSB7XG4gICAgSHR0cHNBZ2VudCQxLnByb3RvdHlwZVttZXRob2RdID0gT3JpZ2luYWxIdHRwc0FnZW50LnByb3RvdHlwZVttZXRob2RdO1xuICB9XG59KTtcblxudmFyIGh0dHBzX2FnZW50ID0gSHR0cHNBZ2VudCQxO1xuXG5hZ2VudGtlZXBhbGl2ZS5leHBvcnRzID0gYWdlbnQ7XG52YXIgSHR0cHNBZ2VudCA9IGFnZW50a2VlcGFsaXZlLmV4cG9ydHMuSHR0cHNBZ2VudCA9IGh0dHBzX2FnZW50O1xuYWdlbnRrZWVwYWxpdmUuZXhwb3J0cy5jb25zdGFudHMgPSBjb25zdGFudHM7XG5cbnZhciBhZ2VudGtlZXBhbGl2ZUV4cG9ydHMgPSBhZ2VudGtlZXBhbGl2ZS5leHBvcnRzO1xudmFyIEh0dHBLZWVwQWxpdmVBZ2VudCA9IC8qQF9fUFVSRV9fKi9nZXREZWZhdWx0RXhwb3J0RnJvbUNqcyhhZ2VudGtlZXBhbGl2ZUV4cG9ydHMpO1xuXG52YXIgb2JqVG9TdHJpbmcgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nO1xudmFyIG9iaktleXMgPSBPYmplY3Qua2V5cyB8fCBmdW5jdGlvbihvYmopIHtcblx0XHR2YXIga2V5cyA9IFtdO1xuXHRcdGZvciAodmFyIG5hbWUgaW4gb2JqKSB7XG5cdFx0XHRrZXlzLnB1c2gobmFtZSk7XG5cdFx0fVxuXHRcdHJldHVybiBrZXlzO1xuXHR9O1xuXG5mdW5jdGlvbiBzdHJpbmdpZnkodmFsLCBpc0FycmF5UHJvcCkge1xuXHR2YXIgaSwgbWF4LCBzdHIsIGtleXMsIGtleSwgcHJvcFZhbCwgdG9TdHI7XG5cdGlmICh2YWwgPT09IHRydWUpIHtcblx0XHRyZXR1cm4gXCJ0cnVlXCI7XG5cdH1cblx0aWYgKHZhbCA9PT0gZmFsc2UpIHtcblx0XHRyZXR1cm4gXCJmYWxzZVwiO1xuXHR9XG5cdHN3aXRjaCAodHlwZW9mIHZhbCkge1xuXHRcdGNhc2UgXCJvYmplY3RcIjpcblx0XHRcdGlmICh2YWwgPT09IG51bGwpIHtcblx0XHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0XHR9IGVsc2UgaWYgKHZhbC50b0pTT04gJiYgdHlwZW9mIHZhbC50b0pTT04gPT09IFwiZnVuY3Rpb25cIikge1xuXHRcdFx0XHRyZXR1cm4gc3RyaW5naWZ5KHZhbC50b0pTT04oKSwgaXNBcnJheVByb3ApO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dG9TdHIgPSBvYmpUb1N0cmluZy5jYWxsKHZhbCk7XG5cdFx0XHRcdGlmICh0b1N0ciA9PT0gXCJbb2JqZWN0IEFycmF5XVwiKSB7XG5cdFx0XHRcdFx0c3RyID0gJ1snO1xuXHRcdFx0XHRcdG1heCA9IHZhbC5sZW5ndGggLSAxO1xuXHRcdFx0XHRcdGZvcihpID0gMDsgaSA8IG1heDsgaSsrKSB7XG5cdFx0XHRcdFx0XHRzdHIgKz0gc3RyaW5naWZ5KHZhbFtpXSwgdHJ1ZSkgKyAnLCc7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGlmIChtYXggPiAtMSkge1xuXHRcdFx0XHRcdFx0c3RyICs9IHN0cmluZ2lmeSh2YWxbaV0sIHRydWUpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRyZXR1cm4gc3RyICsgJ10nO1xuXHRcdFx0XHR9IGVsc2UgaWYgKHRvU3RyID09PSBcIltvYmplY3QgT2JqZWN0XVwiKSB7XG5cdFx0XHRcdFx0Ly8gb25seSBvYmplY3QgaXMgbGVmdFxuXHRcdFx0XHRcdGtleXMgPSBvYmpLZXlzKHZhbCkuc29ydCgpO1xuXHRcdFx0XHRcdG1heCA9IGtleXMubGVuZ3RoO1xuXHRcdFx0XHRcdHN0ciA9IFwiXCI7XG5cdFx0XHRcdFx0aSA9IDA7XG5cdFx0XHRcdFx0d2hpbGUgKGkgPCBtYXgpIHtcblx0XHRcdFx0XHRcdGtleSA9IGtleXNbaV07XG5cdFx0XHRcdFx0XHRwcm9wVmFsID0gc3RyaW5naWZ5KHZhbFtrZXldLCBmYWxzZSk7XG5cdFx0XHRcdFx0XHRpZiAocHJvcFZhbCAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdFx0XHRcdGlmIChzdHIpIHtcblx0XHRcdFx0XHRcdFx0XHRzdHIgKz0gJywnO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdHN0ciArPSBKU09OLnN0cmluZ2lmeShrZXkpICsgJzonICsgcHJvcFZhbDtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdGkrKztcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cmV0dXJuICd7JyArIHN0ciArICd9Jztcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRyZXR1cm4gSlNPTi5zdHJpbmdpZnkodmFsKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdGNhc2UgXCJmdW5jdGlvblwiOlxuXHRcdGNhc2UgXCJ1bmRlZmluZWRcIjpcblx0XHRcdHJldHVybiBpc0FycmF5UHJvcCA/IG51bGwgOiB1bmRlZmluZWQ7XG5cdFx0Y2FzZSBcInN0cmluZ1wiOlxuXHRcdFx0cmV0dXJuIEpTT04uc3RyaW5naWZ5KHZhbCk7XG5cdFx0ZGVmYXVsdDpcblx0XHRcdHJldHVybiBpc0Zpbml0ZSh2YWwpID8gdmFsIDogbnVsbDtcblx0fVxufVxuXG52YXIgZmFzdFN0YWJsZVN0cmluZ2lmeSA9IGZ1bmN0aW9uKHZhbCkge1xuXHR2YXIgcmV0dXJuVmFsID0gc3RyaW5naWZ5KHZhbCwgZmFsc2UpO1xuXHRpZiAocmV0dXJuVmFsICE9PSB1bmRlZmluZWQpIHtcblx0XHRyZXR1cm4gJycrIHJldHVyblZhbDtcblx0fVxufTtcblxudmFyIGZhc3RTdGFibGVTdHJpbmdpZnkkMSA9IC8qQF9fUFVSRV9fKi9nZXREZWZhdWx0RXhwb3J0RnJvbUNqcyhmYXN0U3RhYmxlU3RyaW5naWZ5KTtcblxuY29uc3QgTUlOSU1VTV9TTE9UX1BFUl9FUE9DSCA9IDMyO1xuXG4vLyBSZXR1cm5zIHRoZSBudW1iZXIgb2YgdHJhaWxpbmcgemVyb3MgaW4gdGhlIGJpbmFyeSByZXByZXNlbnRhdGlvbiBvZiBzZWxmLlxuZnVuY3Rpb24gdHJhaWxpbmdaZXJvcyhuKSB7XG4gIGxldCB0cmFpbGluZ1plcm9zID0gMDtcbiAgd2hpbGUgKG4gPiAxKSB7XG4gICAgbiAvPSAyO1xuICAgIHRyYWlsaW5nWmVyb3MrKztcbiAgfVxuICByZXR1cm4gdHJhaWxpbmdaZXJvcztcbn1cblxuLy8gUmV0dXJucyB0aGUgc21hbGxlc3QgcG93ZXIgb2YgdHdvIGdyZWF0ZXIgdGhhbiBvciBlcXVhbCB0byBuXG5mdW5jdGlvbiBuZXh0UG93ZXJPZlR3byhuKSB7XG4gIGlmIChuID09PSAwKSByZXR1cm4gMTtcbiAgbi0tO1xuICBuIHw9IG4gPj4gMTtcbiAgbiB8PSBuID4+IDI7XG4gIG4gfD0gbiA+PiA0O1xuICBuIHw9IG4gPj4gODtcbiAgbiB8PSBuID4+IDE2O1xuICBuIHw9IG4gPj4gMzI7XG4gIHJldHVybiBuICsgMTtcbn1cblxuLyoqXG4gKiBFcG9jaCBzY2hlZHVsZVxuICogKHNlZSBodHRwczovL2RvY3Muc29sYW5hLmNvbS90ZXJtaW5vbG9neSNlcG9jaClcbiAqIENhbiBiZSByZXRyaWV2ZWQgd2l0aCB0aGUge0BsaW5rIENvbm5lY3Rpb24uZ2V0RXBvY2hTY2hlZHVsZX0gbWV0aG9kXG4gKi9cbmNsYXNzIEVwb2NoU2NoZWR1bGUge1xuICBjb25zdHJ1Y3RvcihzbG90c1BlckVwb2NoLCBsZWFkZXJTY2hlZHVsZVNsb3RPZmZzZXQsIHdhcm11cCwgZmlyc3ROb3JtYWxFcG9jaCwgZmlyc3ROb3JtYWxTbG90KSB7XG4gICAgLyoqIFRoZSBtYXhpbXVtIG51bWJlciBvZiBzbG90cyBpbiBlYWNoIGVwb2NoICovXG4gICAgdGhpcy5zbG90c1BlckVwb2NoID0gdm9pZCAwO1xuICAgIC8qKiBUaGUgbnVtYmVyIG9mIHNsb3RzIGJlZm9yZSBiZWdpbm5pbmcgb2YgYW4gZXBvY2ggdG8gY2FsY3VsYXRlIGEgbGVhZGVyIHNjaGVkdWxlIGZvciB0aGF0IGVwb2NoICovXG4gICAgdGhpcy5sZWFkZXJTY2hlZHVsZVNsb3RPZmZzZXQgPSB2b2lkIDA7XG4gICAgLyoqIEluZGljYXRlcyB3aGV0aGVyIGVwb2NocyBzdGFydCBzaG9ydCBhbmQgZ3JvdyAqL1xuICAgIHRoaXMud2FybXVwID0gdm9pZCAwO1xuICAgIC8qKiBUaGUgZmlyc3QgZXBvY2ggd2l0aCBgc2xvdHNQZXJFcG9jaGAgc2xvdHMgKi9cbiAgICB0aGlzLmZpcnN0Tm9ybWFsRXBvY2ggPSB2b2lkIDA7XG4gICAgLyoqIFRoZSBmaXJzdCBzbG90IG9mIGBmaXJzdE5vcm1hbEVwb2NoYCAqL1xuICAgIHRoaXMuZmlyc3ROb3JtYWxTbG90ID0gdm9pZCAwO1xuICAgIHRoaXMuc2xvdHNQZXJFcG9jaCA9IHNsb3RzUGVyRXBvY2g7XG4gICAgdGhpcy5sZWFkZXJTY2hlZHVsZVNsb3RPZmZzZXQgPSBsZWFkZXJTY2hlZHVsZVNsb3RPZmZzZXQ7XG4gICAgdGhpcy53YXJtdXAgPSB3YXJtdXA7XG4gICAgdGhpcy5maXJzdE5vcm1hbEVwb2NoID0gZmlyc3ROb3JtYWxFcG9jaDtcbiAgICB0aGlzLmZpcnN0Tm9ybWFsU2xvdCA9IGZpcnN0Tm9ybWFsU2xvdDtcbiAgfVxuICBnZXRFcG9jaChzbG90KSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0RXBvY2hBbmRTbG90SW5kZXgoc2xvdClbMF07XG4gIH1cbiAgZ2V0RXBvY2hBbmRTbG90SW5kZXgoc2xvdCkge1xuICAgIGlmIChzbG90IDwgdGhpcy5maXJzdE5vcm1hbFNsb3QpIHtcbiAgICAgIGNvbnN0IGVwb2NoID0gdHJhaWxpbmdaZXJvcyhuZXh0UG93ZXJPZlR3byhzbG90ICsgTUlOSU1VTV9TTE9UX1BFUl9FUE9DSCArIDEpKSAtIHRyYWlsaW5nWmVyb3MoTUlOSU1VTV9TTE9UX1BFUl9FUE9DSCkgLSAxO1xuICAgICAgY29uc3QgZXBvY2hMZW4gPSB0aGlzLmdldFNsb3RzSW5FcG9jaChlcG9jaCk7XG4gICAgICBjb25zdCBzbG90SW5kZXggPSBzbG90IC0gKGVwb2NoTGVuIC0gTUlOSU1VTV9TTE9UX1BFUl9FUE9DSCk7XG4gICAgICByZXR1cm4gW2Vwb2NoLCBzbG90SW5kZXhdO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBub3JtYWxTbG90SW5kZXggPSBzbG90IC0gdGhpcy5maXJzdE5vcm1hbFNsb3Q7XG4gICAgICBjb25zdCBub3JtYWxFcG9jaEluZGV4ID0gTWF0aC5mbG9vcihub3JtYWxTbG90SW5kZXggLyB0aGlzLnNsb3RzUGVyRXBvY2gpO1xuICAgICAgY29uc3QgZXBvY2ggPSB0aGlzLmZpcnN0Tm9ybWFsRXBvY2ggKyBub3JtYWxFcG9jaEluZGV4O1xuICAgICAgY29uc3Qgc2xvdEluZGV4ID0gbm9ybWFsU2xvdEluZGV4ICUgdGhpcy5zbG90c1BlckVwb2NoO1xuICAgICAgcmV0dXJuIFtlcG9jaCwgc2xvdEluZGV4XTtcbiAgICB9XG4gIH1cbiAgZ2V0Rmlyc3RTbG90SW5FcG9jaChlcG9jaCkge1xuICAgIGlmIChlcG9jaCA8PSB0aGlzLmZpcnN0Tm9ybWFsRXBvY2gpIHtcbiAgICAgIHJldHVybiAoTWF0aC5wb3coMiwgZXBvY2gpIC0gMSkgKiBNSU5JTVVNX1NMT1RfUEVSX0VQT0NIO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gKGVwb2NoIC0gdGhpcy5maXJzdE5vcm1hbEVwb2NoKSAqIHRoaXMuc2xvdHNQZXJFcG9jaCArIHRoaXMuZmlyc3ROb3JtYWxTbG90O1xuICAgIH1cbiAgfVxuICBnZXRMYXN0U2xvdEluRXBvY2goZXBvY2gpIHtcbiAgICByZXR1cm4gdGhpcy5nZXRGaXJzdFNsb3RJbkVwb2NoKGVwb2NoKSArIHRoaXMuZ2V0U2xvdHNJbkVwb2NoKGVwb2NoKSAtIDE7XG4gIH1cbiAgZ2V0U2xvdHNJbkVwb2NoKGVwb2NoKSB7XG4gICAgaWYgKGVwb2NoIDwgdGhpcy5maXJzdE5vcm1hbEVwb2NoKSB7XG4gICAgICByZXR1cm4gTWF0aC5wb3coMiwgZXBvY2ggKyB0cmFpbGluZ1plcm9zKE1JTklNVU1fU0xPVF9QRVJfRVBPQ0gpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHRoaXMuc2xvdHNQZXJFcG9jaDtcbiAgICB9XG4gIH1cbn1cblxuY2xhc3MgU2VuZFRyYW5zYWN0aW9uRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gIGNvbnN0cnVjdG9yKG1lc3NhZ2UsIGxvZ3MpIHtcbiAgICBzdXBlcihtZXNzYWdlKTtcbiAgICB0aGlzLmxvZ3MgPSB2b2lkIDA7XG4gICAgdGhpcy5sb2dzID0gbG9ncztcbiAgfVxufVxuXG4vLyBLZWVwIGluIHN5bmMgd2l0aCBjbGllbnQvc3JjL3JwY19jdXN0b21fZXJyb3JzLnJzXG4vLyBUeXBlc2NyaXB0IGBlbnVtc2AgdGh3YXJ0IHRyZWUtc2hha2luZy4gU2VlIGh0dHBzOi8vYmFyZ3N0ZW4ub3JnL2pzdHMvZW51bXMvXG5jb25zdCBTb2xhbmFKU09OUlBDRXJyb3JDb2RlID0ge1xuICBKU09OX1JQQ19TRVJWRVJfRVJST1JfQkxPQ0tfQ0xFQU5FRF9VUDogLTMyMDAxLFxuICBKU09OX1JQQ19TRVJWRVJfRVJST1JfU0VORF9UUkFOU0FDVElPTl9QUkVGTElHSFRfRkFJTFVSRTogLTMyMDAyLFxuICBKU09OX1JQQ19TRVJWRVJfRVJST1JfVFJBTlNBQ1RJT05fU0lHTkFUVVJFX1ZFUklGSUNBVElPTl9GQUlMVVJFOiAtMzIwMDMsXG4gIEpTT05fUlBDX1NFUlZFUl9FUlJPUl9CTE9DS19OT1RfQVZBSUxBQkxFOiAtMzIwMDQsXG4gIEpTT05fUlBDX1NFUlZFUl9FUlJPUl9OT0RFX1VOSEVBTFRIWTogLTMyMDA1LFxuICBKU09OX1JQQ19TRVJWRVJfRVJST1JfVFJBTlNBQ1RJT05fUFJFQ09NUElMRV9WRVJJRklDQVRJT05fRkFJTFVSRTogLTMyMDA2LFxuICBKU09OX1JQQ19TRVJWRVJfRVJST1JfU0xPVF9TS0lQUEVEOiAtMzIwMDcsXG4gIEpTT05fUlBDX1NFUlZFUl9FUlJPUl9OT19TTkFQU0hPVDogLTMyMDA4LFxuICBKU09OX1JQQ19TRVJWRVJfRVJST1JfTE9OR19URVJNX1NUT1JBR0VfU0xPVF9TS0lQUEVEOiAtMzIwMDksXG4gIEpTT05fUlBDX1NFUlZFUl9FUlJPUl9LRVlfRVhDTFVERURfRlJPTV9TRUNPTkRBUllfSU5ERVg6IC0zMjAxMCxcbiAgSlNPTl9SUENfU0VSVkVSX0VSUk9SX1RSQU5TQUNUSU9OX0hJU1RPUllfTk9UX0FWQUlMQUJMRTogLTMyMDExLFxuICBKU09OX1JQQ19TQ0FOX0VSUk9SOiAtMzIwMTIsXG4gIEpTT05fUlBDX1NFUlZFUl9FUlJPUl9UUkFOU0FDVElPTl9TSUdOQVRVUkVfTEVOX01JU01BVENIOiAtMzIwMTMsXG4gIEpTT05fUlBDX1NFUlZFUl9FUlJPUl9CTE9DS19TVEFUVVNfTk9UX0FWQUlMQUJMRV9ZRVQ6IC0zMjAxNCxcbiAgSlNPTl9SUENfU0VSVkVSX0VSUk9SX1VOU1VQUE9SVEVEX1RSQU5TQUNUSU9OX1ZFUlNJT046IC0zMjAxNSxcbiAgSlNPTl9SUENfU0VSVkVSX0VSUk9SX01JTl9DT05URVhUX1NMT1RfTk9UX1JFQUNIRUQ6IC0zMjAxNlxufTtcbmNsYXNzIFNvbGFuYUpTT05SUENFcnJvciBleHRlbmRzIEVycm9yIHtcbiAgY29uc3RydWN0b3Ioe1xuICAgIGNvZGUsXG4gICAgbWVzc2FnZSxcbiAgICBkYXRhXG4gIH0sIGN1c3RvbU1lc3NhZ2UpIHtcbiAgICBzdXBlcihjdXN0b21NZXNzYWdlICE9IG51bGwgPyBgJHtjdXN0b21NZXNzYWdlfTogJHttZXNzYWdlfWAgOiBtZXNzYWdlKTtcbiAgICB0aGlzLmNvZGUgPSB2b2lkIDA7XG4gICAgdGhpcy5kYXRhID0gdm9pZCAwO1xuICAgIHRoaXMuY29kZSA9IGNvZGU7XG4gICAgdGhpcy5kYXRhID0gZGF0YTtcbiAgICB0aGlzLm5hbWUgPSAnU29sYW5hSlNPTlJQQ0Vycm9yJztcbiAgfVxufVxuXG52YXIgZmV0Y2hJbXBsID0gdHlwZW9mIGdsb2JhbFRoaXMuZmV0Y2ggPT09ICdmdW5jdGlvbicgP1xuLy8gVGhlIEZldGNoIEFQSSBpcyBzdXBwb3J0ZWQgZXhwZXJpbWVudGFsbHkgaW4gTm9kZSAxNy41KyBhbmQgbmF0aXZlbHkgaW4gTm9kZSAxOCsuXG5nbG9iYWxUaGlzLmZldGNoIDpcbi8vIE90aGVyd2lzZSB1c2UgdGhlIHBvbHlmaWxsLlxuYXN5bmMgZnVuY3Rpb24gKGlucHV0LCBpbml0KSB7XG4gIGNvbnN0IHByb2Nlc3NlZElucHV0ID0gdHlwZW9mIGlucHV0ID09PSAnc3RyaW5nJyAmJiBpbnB1dC5zbGljZSgwLCAyKSA9PT0gJy8vJyA/ICdodHRwczonICsgaW5wdXQgOiBpbnB1dDtcbiAgcmV0dXJuIGF3YWl0IG5vZGVGZXRjaC5kZWZhdWx0KHByb2Nlc3NlZElucHV0LCBpbml0KTtcbn07XG5cbmNsYXNzIFJwY1dlYlNvY2tldENsaWVudCBleHRlbmRzIFJwY1dlYlNvY2tldENvbW1vbkNsaWVudCB7XG4gIGNvbnN0cnVjdG9yKGFkZHJlc3MsIG9wdGlvbnMsIGdlbmVyYXRlX3JlcXVlc3RfaWQpIHtcbiAgICBjb25zdCB3ZWJTb2NrZXRGYWN0b3J5ID0gdXJsID0+IHtcbiAgICAgIGNvbnN0IHJwYyA9IFdlYnNvY2tldEZhY3RvcnkodXJsLCB7XG4gICAgICAgIGF1dG9jb25uZWN0OiB0cnVlLFxuICAgICAgICBtYXhfcmVjb25uZWN0czogNSxcbiAgICAgICAgcmVjb25uZWN0OiB0cnVlLFxuICAgICAgICByZWNvbm5lY3RfaW50ZXJ2YWw6IDEwMDAsXG4gICAgICAgIC4uLm9wdGlvbnNcbiAgICAgIH0pO1xuICAgICAgaWYgKCdzb2NrZXQnIGluIHJwYykge1xuICAgICAgICB0aGlzLnVuZGVybHlpbmdTb2NrZXQgPSBycGMuc29ja2V0O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy51bmRlcmx5aW5nU29ja2V0ID0gcnBjO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJwYztcbiAgICB9O1xuICAgIHN1cGVyKHdlYlNvY2tldEZhY3RvcnksIGFkZHJlc3MsIG9wdGlvbnMsIGdlbmVyYXRlX3JlcXVlc3RfaWQpO1xuICAgIHRoaXMudW5kZXJseWluZ1NvY2tldCA9IHZvaWQgMDtcbiAgfVxuICBjYWxsKC4uLmFyZ3MpIHtcbiAgICBjb25zdCByZWFkeVN0YXRlID0gdGhpcy51bmRlcmx5aW5nU29ja2V0Py5yZWFkeVN0YXRlO1xuICAgIGlmIChyZWFkeVN0YXRlID09PSAxIC8qIFdlYlNvY2tldC5PUEVOICovKSB7XG4gICAgICByZXR1cm4gc3VwZXIuY2FsbCguLi5hcmdzKTtcbiAgICB9XG4gICAgcmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBFcnJvcignVHJpZWQgdG8gY2FsbCBhIEpTT04tUlBDIG1ldGhvZCBgJyArIGFyZ3NbMF0gKyAnYCBidXQgdGhlIHNvY2tldCB3YXMgbm90IGBDT05ORUNUSU5HYCBvciBgT1BFTmAgKGByZWFkeVN0YXRlYCB3YXMgJyArIHJlYWR5U3RhdGUgKyAnKScpKTtcbiAgfVxuICBub3RpZnkoLi4uYXJncykge1xuICAgIGNvbnN0IHJlYWR5U3RhdGUgPSB0aGlzLnVuZGVybHlpbmdTb2NrZXQ/LnJlYWR5U3RhdGU7XG4gICAgaWYgKHJlYWR5U3RhdGUgPT09IDEgLyogV2ViU29ja2V0Lk9QRU4gKi8pIHtcbiAgICAgIHJldHVybiBzdXBlci5ub3RpZnkoLi4uYXJncyk7XG4gICAgfVxuICAgIHJldHVybiBQcm9taXNlLnJlamVjdChuZXcgRXJyb3IoJ1RyaWVkIHRvIHNlbmQgYSBKU09OLVJQQyBub3RpZmljYXRpb24gYCcgKyBhcmdzWzBdICsgJ2AgYnV0IHRoZSBzb2NrZXQgd2FzIG5vdCBgQ09OTkVDVElOR2Agb3IgYE9QRU5gIChgcmVhZHlTdGF0ZWAgd2FzICcgKyByZWFkeVN0YXRlICsgJyknKSk7XG4gIH1cbn1cblxuLyoqXG4gKiBAaW50ZXJuYWxcbiAqL1xuXG4vKipcbiAqIERlY29kZSBhY2NvdW50IGRhdGEgYnVmZmVyIHVzaW5nIGFuIEFjY291bnRUeXBlXG4gKiBAaW50ZXJuYWxcbiAqL1xuZnVuY3Rpb24gZGVjb2RlRGF0YSh0eXBlLCBkYXRhKSB7XG4gIGxldCBkZWNvZGVkO1xuICB0cnkge1xuICAgIGRlY29kZWQgPSB0eXBlLmxheW91dC5kZWNvZGUoZGF0YSk7XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBpbnN0cnVjdGlvbjsgJyArIGVycik7XG4gIH1cbiAgaWYgKGRlY29kZWQudHlwZUluZGV4ICE9PSB0eXBlLmluZGV4KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBpbnZhbGlkIGFjY291bnQgZGF0YTsgYWNjb3VudCB0eXBlIG1pc21hdGNoICR7ZGVjb2RlZC50eXBlSW5kZXh9ICE9ICR7dHlwZS5pbmRleH1gKTtcbiAgfVxuICByZXR1cm4gZGVjb2RlZDtcbn1cblxuLy8vIFRoZSBzZXJpYWxpemVkIHNpemUgb2YgbG9va3VwIHRhYmxlIG1ldGFkYXRhXG5jb25zdCBMT09LVVBfVEFCTEVfTUVUQV9TSVpFID0gNTY7XG5jbGFzcyBBZGRyZXNzTG9va3VwVGFibGVBY2NvdW50IHtcbiAgY29uc3RydWN0b3IoYXJncykge1xuICAgIHRoaXMua2V5ID0gdm9pZCAwO1xuICAgIHRoaXMuc3RhdGUgPSB2b2lkIDA7XG4gICAgdGhpcy5rZXkgPSBhcmdzLmtleTtcbiAgICB0aGlzLnN0YXRlID0gYXJncy5zdGF0ZTtcbiAgfVxuICBpc0FjdGl2ZSgpIHtcbiAgICBjb25zdCBVNjRfTUFYID0gQmlnSW50KCcweGZmZmZmZmZmZmZmZmZmZmYnKTtcbiAgICByZXR1cm4gdGhpcy5zdGF0ZS5kZWFjdGl2YXRpb25TbG90ID09PSBVNjRfTUFYO1xuICB9XG4gIHN0YXRpYyBkZXNlcmlhbGl6ZShhY2NvdW50RGF0YSkge1xuICAgIGNvbnN0IG1ldGEgPSBkZWNvZGVEYXRhKExvb2t1cFRhYmxlTWV0YUxheW91dCwgYWNjb3VudERhdGEpO1xuICAgIGNvbnN0IHNlcmlhbGl6ZWRBZGRyZXNzZXNMZW4gPSBhY2NvdW50RGF0YS5sZW5ndGggLSBMT09LVVBfVEFCTEVfTUVUQV9TSVpFO1xuICAgIGFzc2VydChzZXJpYWxpemVkQWRkcmVzc2VzTGVuID49IDAsICdsb29rdXAgdGFibGUgaXMgaW52YWxpZCcpO1xuICAgIGFzc2VydChzZXJpYWxpemVkQWRkcmVzc2VzTGVuICUgMzIgPT09IDAsICdsb29rdXAgdGFibGUgaXMgaW52YWxpZCcpO1xuICAgIGNvbnN0IG51bVNlcmlhbGl6ZWRBZGRyZXNzZXMgPSBzZXJpYWxpemVkQWRkcmVzc2VzTGVuIC8gMzI7XG4gICAgY29uc3Qge1xuICAgICAgYWRkcmVzc2VzXG4gICAgfSA9IEJ1ZmZlckxheW91dC5zdHJ1Y3QoW0J1ZmZlckxheW91dC5zZXEocHVibGljS2V5KCksIG51bVNlcmlhbGl6ZWRBZGRyZXNzZXMsICdhZGRyZXNzZXMnKV0pLmRlY29kZShhY2NvdW50RGF0YS5zbGljZShMT09LVVBfVEFCTEVfTUVUQV9TSVpFKSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIGRlYWN0aXZhdGlvblNsb3Q6IG1ldGEuZGVhY3RpdmF0aW9uU2xvdCxcbiAgICAgIGxhc3RFeHRlbmRlZFNsb3Q6IG1ldGEubGFzdEV4dGVuZGVkU2xvdCxcbiAgICAgIGxhc3RFeHRlbmRlZFNsb3RTdGFydEluZGV4OiBtZXRhLmxhc3RFeHRlbmRlZFN0YXJ0SW5kZXgsXG4gICAgICBhdXRob3JpdHk6IG1ldGEuYXV0aG9yaXR5Lmxlbmd0aCAhPT0gMCA/IG5ldyBQdWJsaWNLZXkobWV0YS5hdXRob3JpdHlbMF0pIDogdW5kZWZpbmVkLFxuICAgICAgYWRkcmVzc2VzOiBhZGRyZXNzZXMubWFwKGFkZHJlc3MgPT4gbmV3IFB1YmxpY0tleShhZGRyZXNzKSlcbiAgICB9O1xuICB9XG59XG5jb25zdCBMb29rdXBUYWJsZU1ldGFMYXlvdXQgPSB7XG4gIGluZGV4OiAxLFxuICBsYXlvdXQ6IEJ1ZmZlckxheW91dC5zdHJ1Y3QoW0J1ZmZlckxheW91dC51MzIoJ3R5cGVJbmRleCcpLCB1NjQoJ2RlYWN0aXZhdGlvblNsb3QnKSwgQnVmZmVyTGF5b3V0Lm51NjQoJ2xhc3RFeHRlbmRlZFNsb3QnKSwgQnVmZmVyTGF5b3V0LnU4KCdsYXN0RXh0ZW5kZWRTdGFydEluZGV4JyksIEJ1ZmZlckxheW91dC51OCgpLFxuICAvLyBvcHRpb25cbiAgQnVmZmVyTGF5b3V0LnNlcShwdWJsaWNLZXkoKSwgQnVmZmVyTGF5b3V0Lm9mZnNldChCdWZmZXJMYXlvdXQudTgoKSwgLTEpLCAnYXV0aG9yaXR5JyldKVxufTtcblxuY29uc3QgVVJMX1JFID0gL15bXjpdKzpcXC9cXC8oW146W10rfFxcW1teXFxdXStcXF0pKDpcXGQrKT8oLiopL2k7XG5mdW5jdGlvbiBtYWtlV2Vic29ja2V0VXJsKGVuZHBvaW50KSB7XG4gIGNvbnN0IG1hdGNoZXMgPSBlbmRwb2ludC5tYXRjaChVUkxfUkUpO1xuICBpZiAobWF0Y2hlcyA9PSBudWxsKSB7XG4gICAgdGhyb3cgVHlwZUVycm9yKGBGYWlsZWQgdG8gdmFsaWRhdGUgZW5kcG9pbnQgVVJMIFxcYCR7ZW5kcG9pbnR9XFxgYCk7XG4gIH1cbiAgY29uc3QgW18sXG4gIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVudXNlZC12YXJzXG4gIGhvc3Rpc2gsIHBvcnRXaXRoQ29sb24sIHJlc3RdID0gbWF0Y2hlcztcbiAgY29uc3QgcHJvdG9jb2wgPSBlbmRwb2ludC5zdGFydHNXaXRoKCdodHRwczonKSA/ICd3c3M6JyA6ICd3czonO1xuICBjb25zdCBzdGFydFBvcnQgPSBwb3J0V2l0aENvbG9uID09IG51bGwgPyBudWxsIDogcGFyc2VJbnQocG9ydFdpdGhDb2xvbi5zbGljZSgxKSwgMTApO1xuICBjb25zdCB3ZWJzb2NrZXRQb3J0ID1cbiAgLy8gT25seSBzaGlmdCB0aGUgcG9ydCBieSArMSBhcyBhIGNvbnZlbnRpb24gZm9yIHdzKHMpIG9ubHkgaWYgZ2l2ZW4gZW5kcG9pbnRcbiAgLy8gaXMgZXhwbGljaXRseSBzcGVjaWZ5aW5nIHRoZSBlbmRwb2ludCBwb3J0IChIVFRQLWJhc2VkIFJQQyksIGFzc3VtaW5nXG4gIC8vIHdlJ3JlIGRpcmVjdGx5IHRyeWluZyB0byBjb25uZWN0IHRvIGFnYXZlLXZhbGlkYXRvcidzIHdzIGxpc3RlbmluZyBwb3J0LlxuICAvLyBXaGVuIHRoZSBlbmRwb2ludCBvbWl0cyB0aGUgcG9ydCwgd2UncmUgY29ubmVjdGluZyB0byB0aGUgcHJvdG9jb2xcbiAgLy8gZGVmYXVsdCBwb3J0czogaHR0cCg4MCkgb3IgaHR0cHMoNDQzKSBhbmQgaXQncyBhc3N1bWVkIHdlJ3JlIGJlaGluZCBhIHJldmVyc2VcbiAgLy8gcHJveHkgd2hpY2ggbWFuYWdlcyBXZWJTb2NrZXQgdXBncmFkZSBhbmQgYmFja2VuZCBwb3J0IHJlZGlyZWN0aW9uLlxuICBzdGFydFBvcnQgPT0gbnVsbCA/ICcnIDogYDoke3N0YXJ0UG9ydCArIDF9YDtcbiAgcmV0dXJuIGAke3Byb3RvY29sfS8vJHtob3N0aXNofSR7d2Vic29ja2V0UG9ydH0ke3Jlc3R9YDtcbn1cblxuY29uc3QgUHVibGljS2V5RnJvbVN0cmluZyA9IGNvZXJjZShpbnN0YW5jZShQdWJsaWNLZXkpLCBzdHJpbmcoKSwgdmFsdWUgPT4gbmV3IFB1YmxpY0tleSh2YWx1ZSkpO1xuY29uc3QgUmF3QWNjb3VudERhdGFSZXN1bHQgPSB0dXBsZShbc3RyaW5nKCksIGxpdGVyYWwoJ2Jhc2U2NCcpXSk7XG5jb25zdCBCdWZmZXJGcm9tUmF3QWNjb3VudERhdGEgPSBjb2VyY2UoaW5zdGFuY2UoQnVmZmVyKSwgUmF3QWNjb3VudERhdGFSZXN1bHQsIHZhbHVlID0+IEJ1ZmZlci5mcm9tKHZhbHVlWzBdLCAnYmFzZTY0JykpO1xuXG4vKipcbiAqIEF0dGVtcHQgdG8gdXNlIGEgcmVjZW50IGJsb2NraGFzaCBmb3IgdXAgdG8gMzAgc2Vjb25kc1xuICogQGludGVybmFsXG4gKi9cbmNvbnN0IEJMT0NLSEFTSF9DQUNIRV9USU1FT1VUX01TID0gMzAgKiAxMDAwO1xuXG4vKipcbiAqIEhBQ0suXG4gKiBDb3BpZWQgZnJvbSBycGMtd2Vic29ja2V0cy9kaXN0L2xpYi9jbGllbnQuXG4gKiBPdGhlcndpc2UsIGB5YXJuIGJ1aWxkYCBmYWlscyB3aXRoOlxuICogaHR0cHM6Ly9naXN0LmdpdGh1Yi5jb20vc3RldmVsdXNjaGVyL2MwNTdlY2E4MWQ0NzllZjcwNWNkYjUzMTYyZjk5NzFkXG4gKi9cblxuLyoqIEBpbnRlcm5hbCAqL1xuLyoqIEBpbnRlcm5hbCAqL1xuLyoqIEBpbnRlcm5hbCAqL1xuLyoqIEBpbnRlcm5hbCAqL1xuXG4vKiogQGludGVybmFsICovXG4vKipcbiAqIEBpbnRlcm5hbFxuICogRXZlcnkgc3Vic2NyaXB0aW9uIGNvbnRhaW5zIHRoZSBhcmdzIHVzZWQgdG8gb3BlbiB0aGUgc3Vic2NyaXB0aW9uIHdpdGhcbiAqIHRoZSBzZXJ2ZXIsIGFuZCBhIGxpc3Qgb2YgY2FsbGVycyBpbnRlcmVzdGVkIGluIG5vdGlmaWNhdGlvbnMuXG4gKi9cblxuLyoqXG4gKiBAaW50ZXJuYWxcbiAqIEEgc3Vic2NyaXB0aW9uIG1heSBiZSBpbiB2YXJpb3VzIHN0YXRlcyBvZiBjb25uZWN0ZWRuZXNzLiBPbmx5IHdoZW4gaXQgaXNcbiAqIGZ1bGx5IGNvbm5lY3RlZCB3aWxsIGl0IGhhdmUgYSBzZXJ2ZXIgc3Vic2NyaXB0aW9uIGlkIGFzc29jaWF0ZWQgd2l0aCBpdC5cbiAqIFRoaXMgaWQgY2FuIGJlIHJldHVybmVkIHRvIHRoZSBzZXJ2ZXIgdG8gdW5zdWJzY3JpYmUgdGhlIGNsaWVudCBlbnRpcmVseS5cbiAqL1xuXG4vKipcbiAqIEEgdHlwZSB0aGF0IGVuY2Fwc3VsYXRlcyBhIHN1YnNjcmlwdGlvbidzIFJQQyBtZXRob2RcbiAqIG5hbWVzIGFuZCBub3RpZmljYXRpb24gKGNhbGxiYWNrKSBzaWduYXR1cmUuXG4gKi9cblxuLyoqXG4gKiBAaW50ZXJuYWxcbiAqIFV0aWxpdHkgdHlwZSB0aGF0IGtlZXBzIHRhZ2dlZCB1bmlvbnMgaW50YWN0IHdoaWxlIG9taXR0aW5nIHByb3BlcnRpZXMuXG4gKi9cblxuLyoqXG4gKiBAaW50ZXJuYWxcbiAqIFRoaXMgdHlwZSByZXByZXNlbnRzIGEgc2luZ2xlIHN1YnNjcmliYWJsZSAndG9waWMuJyBJdCdzIG1hZGUgdXAgb2Y6XG4gKlxuICogLSBUaGUgYXJncyB1c2VkIHRvIG9wZW4gdGhlIHN1YnNjcmlwdGlvbiB3aXRoIHRoZSBzZXJ2ZXIsXG4gKiAtIFRoZSBzdGF0ZSBvZiB0aGUgc3Vic2NyaXB0aW9uLCBpbiB0ZXJtcyBvZiBpdHMgY29ubmVjdGVkbmVzcywgYW5kXG4gKiAtIFRoZSBzZXQgb2YgY2FsbGJhY2tzIHRvIGNhbGwgd2hlbiB0aGUgc2VydmVyIHB1Ymxpc2hlcyBub3RpZmljYXRpb25zXG4gKlxuICogVGhpcyByZWNvcmQgZ2V0cyBpbmRleGVkIGJ5IGBTdWJzY3JpcHRpb25Db25maWdIYXNoYCBhbmQgaXMgdXNlZCB0b1xuICogc2V0IHVwIHN1YnNjcmlwdGlvbnMsIGZhbiBvdXQgbm90aWZpY2F0aW9ucywgYW5kIHRyYWNrIHN1YnNjcmlwdGlvbiBzdGF0ZS5cbiAqL1xuXG4vKipcbiAqIEBpbnRlcm5hbFxuICovXG5cbi8qKlxuICogRXh0cmEgY29udGV4dHVhbCBpbmZvcm1hdGlvbiBmb3IgUlBDIHJlc3BvbnNlc1xuICovXG5cbi8qKlxuICogT3B0aW9ucyBmb3Igc2VuZGluZyB0cmFuc2FjdGlvbnNcbiAqL1xuXG4vKipcbiAqIE9wdGlvbnMgZm9yIGNvbmZpcm1pbmcgdHJhbnNhY3Rpb25zXG4gKi9cblxuLyoqXG4gKiBPcHRpb25zIGZvciBnZXRDb25maXJtZWRTaWduYXR1cmVzRm9yQWRkcmVzczJcbiAqL1xuXG4vKipcbiAqIE9wdGlvbnMgZm9yIGdldFNpZ25hdHVyZXNGb3JBZGRyZXNzXG4gKi9cblxuLyoqXG4gKiBSUEMgUmVzcG9uc2Ugd2l0aCBleHRyYSBjb250ZXh0dWFsIGluZm9ybWF0aW9uXG4gKi9cblxuLyoqXG4gKiBBIHN0cmF0ZWd5IGZvciBjb25maXJtaW5nIHRyYW5zYWN0aW9ucyB0aGF0IHVzZXMgdGhlIGxhc3QgdmFsaWRcbiAqIGJsb2NrIGhlaWdodCBmb3IgYSBnaXZlbiBibG9ja2hhc2ggdG8gY2hlY2sgZm9yIHRyYW5zYWN0aW9uIGV4cGlyYXRpb24uXG4gKi9cblxuLyoqXG4gKiBBIHN0cmF0ZWd5IGZvciBjb25maXJtaW5nIGR1cmFibGUgbm9uY2UgdHJhbnNhY3Rpb25zLlxuICovXG5cbi8qKlxuICogUHJvcGVydGllcyBzaGFyZWQgYnkgYWxsIHRyYW5zYWN0aW9uIGNvbmZpcm1hdGlvbiBzdHJhdGVnaWVzXG4gKi9cblxuLyoqXG4gKiBUaGlzIHR5cGUgcmVwcmVzZW50cyBhbGwgdHJhbnNhY3Rpb24gY29uZmlybWF0aW9uIHN0cmF0ZWdpZXNcbiAqL1xuXG4vKiBAaW50ZXJuYWwgKi9cbmZ1bmN0aW9uIGFzc2VydEVuZHBvaW50VXJsKHB1dGF0aXZlVXJsKSB7XG4gIGlmICgvXmh0dHBzPzovLnRlc3QocHV0YXRpdmVVcmwpID09PSBmYWxzZSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0VuZHBvaW50IFVSTCBtdXN0IHN0YXJ0IHdpdGggYGh0dHA6YCBvciBgaHR0cHM6YC4nKTtcbiAgfVxuICByZXR1cm4gcHV0YXRpdmVVcmw7XG59XG5cbi8qKiBAaW50ZXJuYWwgKi9cbmZ1bmN0aW9uIGV4dHJhY3RDb21taXRtZW50RnJvbUNvbmZpZyhjb21taXRtZW50T3JDb25maWcpIHtcbiAgbGV0IGNvbW1pdG1lbnQ7XG4gIGxldCBjb25maWc7XG4gIGlmICh0eXBlb2YgY29tbWl0bWVudE9yQ29uZmlnID09PSAnc3RyaW5nJykge1xuICAgIGNvbW1pdG1lbnQgPSBjb21taXRtZW50T3JDb25maWc7XG4gIH0gZWxzZSBpZiAoY29tbWl0bWVudE9yQ29uZmlnKSB7XG4gICAgY29uc3Qge1xuICAgICAgY29tbWl0bWVudDogc3BlY2lmaWVkQ29tbWl0bWVudCxcbiAgICAgIC4uLnNwZWNpZmllZENvbmZpZ1xuICAgIH0gPSBjb21taXRtZW50T3JDb25maWc7XG4gICAgY29tbWl0bWVudCA9IHNwZWNpZmllZENvbW1pdG1lbnQ7XG4gICAgY29uZmlnID0gc3BlY2lmaWVkQ29uZmlnO1xuICB9XG4gIHJldHVybiB7XG4gICAgY29tbWl0bWVudCxcbiAgICBjb25maWdcbiAgfTtcbn1cblxuLyoqXG4gKiBAaW50ZXJuYWxcbiAqL1xuZnVuY3Rpb24gY3JlYXRlUnBjUmVzdWx0KHJlc3VsdCkge1xuICByZXR1cm4gdW5pb24oW3R5cGUoe1xuICAgIGpzb25ycGM6IGxpdGVyYWwoJzIuMCcpLFxuICAgIGlkOiBzdHJpbmcoKSxcbiAgICByZXN1bHRcbiAgfSksIHR5cGUoe1xuICAgIGpzb25ycGM6IGxpdGVyYWwoJzIuMCcpLFxuICAgIGlkOiBzdHJpbmcoKSxcbiAgICBlcnJvcjogdHlwZSh7XG4gICAgICBjb2RlOiB1bmtub3duKCksXG4gICAgICBtZXNzYWdlOiBzdHJpbmcoKSxcbiAgICAgIGRhdGE6IG9wdGlvbmFsKGFueSgpKVxuICAgIH0pXG4gIH0pXSk7XG59XG5jb25zdCBVbmtub3duUnBjUmVzdWx0ID0gY3JlYXRlUnBjUmVzdWx0KHVua25vd24oKSk7XG5cbi8qKlxuICogQGludGVybmFsXG4gKi9cbmZ1bmN0aW9uIGpzb25ScGNSZXN1bHQoc2NoZW1hKSB7XG4gIHJldHVybiBjb2VyY2UoY3JlYXRlUnBjUmVzdWx0KHNjaGVtYSksIFVua25vd25ScGNSZXN1bHQsIHZhbHVlID0+IHtcbiAgICBpZiAoJ2Vycm9yJyBpbiB2YWx1ZSkge1xuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICAuLi52YWx1ZSxcbiAgICAgICAgcmVzdWx0OiBjcmVhdGUodmFsdWUucmVzdWx0LCBzY2hlbWEpXG4gICAgICB9O1xuICAgIH1cbiAgfSk7XG59XG5cbi8qKlxuICogQGludGVybmFsXG4gKi9cbmZ1bmN0aW9uIGpzb25ScGNSZXN1bHRBbmRDb250ZXh0KHZhbHVlKSB7XG4gIHJldHVybiBqc29uUnBjUmVzdWx0KHR5cGUoe1xuICAgIGNvbnRleHQ6IHR5cGUoe1xuICAgICAgc2xvdDogbnVtYmVyKClcbiAgICB9KSxcbiAgICB2YWx1ZVxuICB9KSk7XG59XG5cbi8qKlxuICogQGludGVybmFsXG4gKi9cbmZ1bmN0aW9uIG5vdGlmaWNhdGlvblJlc3VsdEFuZENvbnRleHQodmFsdWUpIHtcbiAgcmV0dXJuIHR5cGUoe1xuICAgIGNvbnRleHQ6IHR5cGUoe1xuICAgICAgc2xvdDogbnVtYmVyKClcbiAgICB9KSxcbiAgICB2YWx1ZVxuICB9KTtcbn1cblxuLyoqXG4gKiBAaW50ZXJuYWxcbiAqL1xuZnVuY3Rpb24gdmVyc2lvbmVkTWVzc2FnZUZyb21SZXNwb25zZSh2ZXJzaW9uLCByZXNwb25zZSkge1xuICBpZiAodmVyc2lvbiA9PT0gMCkge1xuICAgIHJldHVybiBuZXcgTWVzc2FnZVYwKHtcbiAgICAgIGhlYWRlcjogcmVzcG9uc2UuaGVhZGVyLFxuICAgICAgc3RhdGljQWNjb3VudEtleXM6IHJlc3BvbnNlLmFjY291bnRLZXlzLm1hcChhY2NvdW50S2V5ID0+IG5ldyBQdWJsaWNLZXkoYWNjb3VudEtleSkpLFxuICAgICAgcmVjZW50QmxvY2toYXNoOiByZXNwb25zZS5yZWNlbnRCbG9ja2hhc2gsXG4gICAgICBjb21waWxlZEluc3RydWN0aW9uczogcmVzcG9uc2UuaW5zdHJ1Y3Rpb25zLm1hcChpeCA9PiAoe1xuICAgICAgICBwcm9ncmFtSWRJbmRleDogaXgucHJvZ3JhbUlkSW5kZXgsXG4gICAgICAgIGFjY291bnRLZXlJbmRleGVzOiBpeC5hY2NvdW50cyxcbiAgICAgICAgZGF0YTogYnM1OC5kZWNvZGUoaXguZGF0YSlcbiAgICAgIH0pKSxcbiAgICAgIGFkZHJlc3NUYWJsZUxvb2t1cHM6IHJlc3BvbnNlLmFkZHJlc3NUYWJsZUxvb2t1cHNcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gbmV3IE1lc3NhZ2UocmVzcG9uc2UpO1xuICB9XG59XG5cbi8qKlxuICogVGhlIGxldmVsIG9mIGNvbW1pdG1lbnQgZGVzaXJlZCB3aGVuIHF1ZXJ5aW5nIHN0YXRlXG4gKiA8cHJlPlxuICogICAncHJvY2Vzc2VkJzogUXVlcnkgdGhlIG1vc3QgcmVjZW50IGJsb2NrIHdoaWNoIGhhcyByZWFjaGVkIDEgY29uZmlybWF0aW9uIGJ5IHRoZSBjb25uZWN0ZWQgbm9kZVxuICogICAnY29uZmlybWVkJzogUXVlcnkgdGhlIG1vc3QgcmVjZW50IGJsb2NrIHdoaWNoIGhhcyByZWFjaGVkIDEgY29uZmlybWF0aW9uIGJ5IHRoZSBjbHVzdGVyXG4gKiAgICdmaW5hbGl6ZWQnOiBRdWVyeSB0aGUgbW9zdCByZWNlbnQgYmxvY2sgd2hpY2ggaGFzIGJlZW4gZmluYWxpemVkIGJ5IHRoZSBjbHVzdGVyXG4gKiA8L3ByZT5cbiAqL1xuXG4vLyBEZXByZWNhdGVkIGFzIG9mIHYxLjUuNVxuXG4vKipcbiAqIEEgc3Vic2V0IG9mIENvbW1pdG1lbnQgbGV2ZWxzLCB3aGljaCBhcmUgYXQgbGVhc3Qgb3B0aW1pc3RpY2FsbHkgY29uZmlybWVkXG4gKiA8cHJlPlxuICogICAnY29uZmlybWVkJzogUXVlcnkgdGhlIG1vc3QgcmVjZW50IGJsb2NrIHdoaWNoIGhhcyByZWFjaGVkIDEgY29uZmlybWF0aW9uIGJ5IHRoZSBjbHVzdGVyXG4gKiAgICdmaW5hbGl6ZWQnOiBRdWVyeSB0aGUgbW9zdCByZWNlbnQgYmxvY2sgd2hpY2ggaGFzIGJlZW4gZmluYWxpemVkIGJ5IHRoZSBjbHVzdGVyXG4gKiA8L3ByZT5cbiAqL1xuXG4vKipcbiAqIEZpbHRlciBmb3IgbGFyZ2VzdCBhY2NvdW50cyBxdWVyeVxuICogPHByZT5cbiAqICAgJ2NpcmN1bGF0aW5nJzogICAgUmV0dXJuIHRoZSBsYXJnZXN0IGFjY291bnRzIHRoYXQgYXJlIHBhcnQgb2YgdGhlIGNpcmN1bGF0aW5nIHN1cHBseVxuICogICAnbm9uQ2lyY3VsYXRpbmcnOiBSZXR1cm4gdGhlIGxhcmdlc3QgYWNjb3VudHMgdGhhdCBhcmUgbm90IHBhcnQgb2YgdGhlIGNpcmN1bGF0aW5nIHN1cHBseVxuICogPC9wcmU+XG4gKi9cblxuLyoqXG4gKiBDb25maWd1cmF0aW9uIG9iamVjdCBmb3IgY2hhbmdpbmcgYGdldEFjY291bnRJbmZvYCBxdWVyeSBiZWhhdmlvclxuICovXG5cbi8qKlxuICogQ29uZmlndXJhdGlvbiBvYmplY3QgZm9yIGNoYW5naW5nIGBnZXRCYWxhbmNlYCBxdWVyeSBiZWhhdmlvclxuICovXG5cbi8qKlxuICogQ29uZmlndXJhdGlvbiBvYmplY3QgZm9yIGNoYW5naW5nIGBnZXRCbG9ja2AgcXVlcnkgYmVoYXZpb3JcbiAqL1xuXG4vKipcbiAqIENvbmZpZ3VyYXRpb24gb2JqZWN0IGZvciBjaGFuZ2luZyBgZ2V0QmxvY2tgIHF1ZXJ5IGJlaGF2aW9yXG4gKi9cblxuLyoqXG4gKiBDb25maWd1cmF0aW9uIG9iamVjdCBmb3IgY2hhbmdpbmcgYGdldFN0YWtlTWluaW11bURlbGVnYXRpb25gIHF1ZXJ5IGJlaGF2aW9yXG4gKi9cblxuLyoqXG4gKiBDb25maWd1cmF0aW9uIG9iamVjdCBmb3IgY2hhbmdpbmcgYGdldEJsb2NrSGVpZ2h0YCBxdWVyeSBiZWhhdmlvclxuICovXG5cbi8qKlxuICogQ29uZmlndXJhdGlvbiBvYmplY3QgZm9yIGNoYW5naW5nIGBnZXRFcG9jaEluZm9gIHF1ZXJ5IGJlaGF2aW9yXG4gKi9cblxuLyoqXG4gKiBDb25maWd1cmF0aW9uIG9iamVjdCBmb3IgY2hhbmdpbmcgYGdldEluZmxhdGlvblJld2FyZGAgcXVlcnkgYmVoYXZpb3JcbiAqL1xuXG4vKipcbiAqIENvbmZpZ3VyYXRpb24gb2JqZWN0IGZvciBjaGFuZ2luZyBgZ2V0TGF0ZXN0QmxvY2toYXNoYCBxdWVyeSBiZWhhdmlvclxuICovXG5cbi8qKlxuICogQ29uZmlndXJhdGlvbiBvYmplY3QgZm9yIGNoYW5naW5nIGBpc0Jsb2NraGFzaFZhbGlkYCBxdWVyeSBiZWhhdmlvclxuICovXG5cbi8qKlxuICogQ29uZmlndXJhdGlvbiBvYmplY3QgZm9yIGNoYW5naW5nIGBnZXRTbG90YCBxdWVyeSBiZWhhdmlvclxuICovXG5cbi8qKlxuICogQ29uZmlndXJhdGlvbiBvYmplY3QgZm9yIGNoYW5naW5nIGBnZXRTbG90TGVhZGVyYCBxdWVyeSBiZWhhdmlvclxuICovXG5cbi8qKlxuICogQ29uZmlndXJhdGlvbiBvYmplY3QgZm9yIGNoYW5naW5nIGBnZXRUcmFuc2FjdGlvbmAgcXVlcnkgYmVoYXZpb3JcbiAqL1xuXG4vKipcbiAqIENvbmZpZ3VyYXRpb24gb2JqZWN0IGZvciBjaGFuZ2luZyBgZ2V0VHJhbnNhY3Rpb25gIHF1ZXJ5IGJlaGF2aW9yXG4gKi9cblxuLyoqXG4gKiBDb25maWd1cmF0aW9uIG9iamVjdCBmb3IgY2hhbmdpbmcgYGdldExhcmdlc3RBY2NvdW50c2AgcXVlcnkgYmVoYXZpb3JcbiAqL1xuXG4vKipcbiAqIENvbmZpZ3VyYXRpb24gb2JqZWN0IGZvciBjaGFuZ2luZyBgZ2V0U3VwcGx5YCByZXF1ZXN0IGJlaGF2aW9yXG4gKi9cblxuLyoqXG4gKiBDb25maWd1cmF0aW9uIG9iamVjdCBmb3IgY2hhbmdpbmcgcXVlcnkgYmVoYXZpb3JcbiAqL1xuXG4vKipcbiAqIEluZm9ybWF0aW9uIGRlc2NyaWJpbmcgYSBjbHVzdGVyIG5vZGVcbiAqL1xuXG4vKipcbiAqIEluZm9ybWF0aW9uIGRlc2NyaWJpbmcgYSB2b3RlIGFjY291bnRcbiAqL1xuXG4vKipcbiAqIEEgY29sbGVjdGlvbiBvZiBjbHVzdGVyIHZvdGUgYWNjb3VudHNcbiAqL1xuXG4vKipcbiAqIE5ldHdvcmsgSW5mbGF0aW9uXG4gKiAoc2VlIGh0dHBzOi8vZG9jcy5zb2xhbmEuY29tL2ltcGxlbWVudGVkLXByb3Bvc2Fscy9lZF9vdmVydmlldylcbiAqL1xuXG5jb25zdCBHZXRJbmZsYXRpb25Hb3Zlcm5vclJlc3VsdCA9IHR5cGUoe1xuICBmb3VuZGF0aW9uOiBudW1iZXIoKSxcbiAgZm91bmRhdGlvblRlcm06IG51bWJlcigpLFxuICBpbml0aWFsOiBudW1iZXIoKSxcbiAgdGFwZXI6IG51bWJlcigpLFxuICB0ZXJtaW5hbDogbnVtYmVyKClcbn0pO1xuXG4vKipcbiAqIFRoZSBpbmZsYXRpb24gcmV3YXJkIGZvciBhbiBlcG9jaFxuICovXG5cbi8qKlxuICogRXhwZWN0ZWQgSlNPTiBSUEMgcmVzcG9uc2UgZm9yIHRoZSBcImdldEluZmxhdGlvblJld2FyZFwiIG1lc3NhZ2VcbiAqL1xuY29uc3QgR2V0SW5mbGF0aW9uUmV3YXJkUmVzdWx0ID0ganNvblJwY1Jlc3VsdChhcnJheShudWxsYWJsZSh0eXBlKHtcbiAgZXBvY2g6IG51bWJlcigpLFxuICBlZmZlY3RpdmVTbG90OiBudW1iZXIoKSxcbiAgYW1vdW50OiBudW1iZXIoKSxcbiAgcG9zdEJhbGFuY2U6IG51bWJlcigpLFxuICBjb21taXNzaW9uOiBvcHRpb25hbChudWxsYWJsZShudW1iZXIoKSkpXG59KSkpKTtcblxuLyoqXG4gKiBDb25maWd1cmF0aW9uIG9iamVjdCBmb3IgY2hhbmdpbmcgYGdldFJlY2VudFByaW9yaXRpemF0aW9uRmVlc2AgcXVlcnkgYmVoYXZpb3JcbiAqL1xuXG4vKipcbiAqIEV4cGVjdGVkIEpTT04gUlBDIHJlc3BvbnNlIGZvciB0aGUgXCJnZXRSZWNlbnRQcmlvcml0aXphdGlvbkZlZXNcIiBtZXNzYWdlXG4gKi9cbmNvbnN0IEdldFJlY2VudFByaW9yaXRpemF0aW9uRmVlc1Jlc3VsdCA9IGFycmF5KHR5cGUoe1xuICBzbG90OiBudW1iZXIoKSxcbiAgcHJpb3JpdGl6YXRpb25GZWU6IG51bWJlcigpXG59KSk7XG4vKipcbiAqIEV4cGVjdGVkIEpTT04gUlBDIHJlc3BvbnNlIGZvciB0aGUgXCJnZXRJbmZsYXRpb25SYXRlXCIgbWVzc2FnZVxuICovXG5jb25zdCBHZXRJbmZsYXRpb25SYXRlUmVzdWx0ID0gdHlwZSh7XG4gIHRvdGFsOiBudW1iZXIoKSxcbiAgdmFsaWRhdG9yOiBudW1iZXIoKSxcbiAgZm91bmRhdGlvbjogbnVtYmVyKCksXG4gIGVwb2NoOiBudW1iZXIoKVxufSk7XG5cbi8qKlxuICogSW5mb3JtYXRpb24gYWJvdXQgdGhlIGN1cnJlbnQgZXBvY2hcbiAqL1xuXG5jb25zdCBHZXRFcG9jaEluZm9SZXN1bHQgPSB0eXBlKHtcbiAgZXBvY2g6IG51bWJlcigpLFxuICBzbG90SW5kZXg6IG51bWJlcigpLFxuICBzbG90c0luRXBvY2g6IG51bWJlcigpLFxuICBhYnNvbHV0ZVNsb3Q6IG51bWJlcigpLFxuICBibG9ja0hlaWdodDogb3B0aW9uYWwobnVtYmVyKCkpLFxuICB0cmFuc2FjdGlvbkNvdW50OiBvcHRpb25hbChudW1iZXIoKSlcbn0pO1xuY29uc3QgR2V0RXBvY2hTY2hlZHVsZVJlc3VsdCA9IHR5cGUoe1xuICBzbG90c1BlckVwb2NoOiBudW1iZXIoKSxcbiAgbGVhZGVyU2NoZWR1bGVTbG90T2Zmc2V0OiBudW1iZXIoKSxcbiAgd2FybXVwOiBib29sZWFuKCksXG4gIGZpcnN0Tm9ybWFsRXBvY2g6IG51bWJlcigpLFxuICBmaXJzdE5vcm1hbFNsb3Q6IG51bWJlcigpXG59KTtcblxuLyoqXG4gKiBMZWFkZXIgc2NoZWR1bGVcbiAqIChzZWUgaHR0cHM6Ly9kb2NzLnNvbGFuYS5jb20vdGVybWlub2xvZ3kjbGVhZGVyLXNjaGVkdWxlKVxuICovXG5cbmNvbnN0IEdldExlYWRlclNjaGVkdWxlUmVzdWx0ID0gcmVjb3JkKHN0cmluZygpLCBhcnJheShudW1iZXIoKSkpO1xuXG4vKipcbiAqIFRyYW5zYWN0aW9uIGVycm9yIG9yIG51bGxcbiAqL1xuY29uc3QgVHJhbnNhY3Rpb25FcnJvclJlc3VsdCA9IG51bGxhYmxlKHVuaW9uKFt0eXBlKHt9KSwgc3RyaW5nKCldKSk7XG5cbi8qKlxuICogU2lnbmF0dXJlIHN0YXR1cyBmb3IgYSB0cmFuc2FjdGlvblxuICovXG5jb25zdCBTaWduYXR1cmVTdGF0dXNSZXN1bHQgPSB0eXBlKHtcbiAgZXJyOiBUcmFuc2FjdGlvbkVycm9yUmVzdWx0XG59KTtcblxuLyoqXG4gKiBUcmFuc2FjdGlvbiBzaWduYXR1cmUgcmVjZWl2ZWQgbm90aWZpY2F0aW9uXG4gKi9cbmNvbnN0IFNpZ25hdHVyZVJlY2VpdmVkUmVzdWx0ID0gbGl0ZXJhbCgncmVjZWl2ZWRTaWduYXR1cmUnKTtcblxuLyoqXG4gKiBWZXJzaW9uIGluZm8gZm9yIGEgbm9kZVxuICovXG5cbmNvbnN0IFZlcnNpb25SZXN1bHQgPSB0eXBlKHtcbiAgJ3NvbGFuYS1jb3JlJzogc3RyaW5nKCksXG4gICdmZWF0dXJlLXNldCc6IG9wdGlvbmFsKG51bWJlcigpKVxufSk7XG5jb25zdCBTaW11bGF0ZWRUcmFuc2FjdGlvblJlc3BvbnNlU3RydWN0ID0ganNvblJwY1Jlc3VsdEFuZENvbnRleHQodHlwZSh7XG4gIGVycjogbnVsbGFibGUodW5pb24oW3R5cGUoe30pLCBzdHJpbmcoKV0pKSxcbiAgbG9nczogbnVsbGFibGUoYXJyYXkoc3RyaW5nKCkpKSxcbiAgYWNjb3VudHM6IG9wdGlvbmFsKG51bGxhYmxlKGFycmF5KG51bGxhYmxlKHR5cGUoe1xuICAgIGV4ZWN1dGFibGU6IGJvb2xlYW4oKSxcbiAgICBvd25lcjogc3RyaW5nKCksXG4gICAgbGFtcG9ydHM6IG51bWJlcigpLFxuICAgIGRhdGE6IGFycmF5KHN0cmluZygpKSxcbiAgICByZW50RXBvY2g6IG9wdGlvbmFsKG51bWJlcigpKVxuICB9KSkpKSksXG4gIHVuaXRzQ29uc3VtZWQ6IG9wdGlvbmFsKG51bWJlcigpKSxcbiAgcmV0dXJuRGF0YTogb3B0aW9uYWwobnVsbGFibGUodHlwZSh7XG4gICAgcHJvZ3JhbUlkOiBzdHJpbmcoKSxcbiAgICBkYXRhOiB0dXBsZShbc3RyaW5nKCksIGxpdGVyYWwoJ2Jhc2U2NCcpXSlcbiAgfSkpKVxufSkpO1xuXG4vKipcbiAqIE1ldGFkYXRhIGZvciBhIHBhcnNlZCBjb25maXJtZWQgdHJhbnNhY3Rpb24gb24gdGhlIGxlZGdlclxuICpcbiAqIEBkZXByZWNhdGVkIERlcHJlY2F0ZWQgc2luY2UgU29sYW5hIHYxLjguMC4gUGxlYXNlIHVzZSB7QGxpbmsgUGFyc2VkVHJhbnNhY3Rpb25NZXRhfSBpbnN0ZWFkLlxuICovXG5cbi8qKlxuICogQ29sbGVjdGlvbiBvZiBhZGRyZXNzZXMgbG9hZGVkIGJ5IGEgdHJhbnNhY3Rpb24gdXNpbmcgYWRkcmVzcyB0YWJsZSBsb29rdXBzXG4gKi9cblxuLyoqXG4gKiBNZXRhZGF0YSBmb3IgYSBwYXJzZWQgdHJhbnNhY3Rpb24gb24gdGhlIGxlZGdlclxuICovXG5cbi8qKlxuICogTWV0YWRhdGEgZm9yIGEgY29uZmlybWVkIHRyYW5zYWN0aW9uIG9uIHRoZSBsZWRnZXJcbiAqL1xuXG4vKipcbiAqIEEgcHJvY2Vzc2VkIHRyYW5zYWN0aW9uIGZyb20gdGhlIFJQQyBBUElcbiAqL1xuXG4vKipcbiAqIEEgcHJvY2Vzc2VkIHRyYW5zYWN0aW9uIGZyb20gdGhlIFJQQyBBUElcbiAqL1xuXG4vKipcbiAqIEEgcHJvY2Vzc2VkIHRyYW5zYWN0aW9uIG1lc3NhZ2UgZnJvbSB0aGUgUlBDIEFQSVxuICovXG5cbi8qKlxuICogQSBjb25maXJtZWQgdHJhbnNhY3Rpb24gb24gdGhlIGxlZGdlclxuICpcbiAqIEBkZXByZWNhdGVkIERlcHJlY2F0ZWQgc2luY2UgU29sYW5hIHYxLjguMC5cbiAqL1xuXG4vKipcbiAqIEEgcGFydGlhbGx5IGRlY29kZWQgdHJhbnNhY3Rpb24gaW5zdHJ1Y3Rpb25cbiAqL1xuXG4vKipcbiAqIEEgcGFyc2VkIHRyYW5zYWN0aW9uIG1lc3NhZ2UgYWNjb3VudFxuICovXG5cbi8qKlxuICogQSBwYXJzZWQgdHJhbnNhY3Rpb24gaW5zdHJ1Y3Rpb25cbiAqL1xuXG4vKipcbiAqIEEgcGFyc2VkIGFkZHJlc3MgdGFibGUgbG9va3VwXG4gKi9cblxuLyoqXG4gKiBBIHBhcnNlZCB0cmFuc2FjdGlvbiBtZXNzYWdlXG4gKi9cblxuLyoqXG4gKiBBIHBhcnNlZCB0cmFuc2FjdGlvblxuICovXG5cbi8qKlxuICogQSBwYXJzZWQgYW5kIGNvbmZpcm1lZCB0cmFuc2FjdGlvbiBvbiB0aGUgbGVkZ2VyXG4gKlxuICogQGRlcHJlY2F0ZWQgRGVwcmVjYXRlZCBzaW5jZSBTb2xhbmEgdjEuOC4wLiBQbGVhc2UgdXNlIHtAbGluayBQYXJzZWRUcmFuc2FjdGlvbldpdGhNZXRhfSBpbnN0ZWFkLlxuICovXG5cbi8qKlxuICogQSBwYXJzZWQgdHJhbnNhY3Rpb24gb24gdGhlIGxlZGdlciB3aXRoIG1ldGFcbiAqL1xuXG4vKipcbiAqIEEgcHJvY2Vzc2VkIGJsb2NrIGZldGNoZWQgZnJvbSB0aGUgUlBDIEFQSVxuICovXG5cbi8qKlxuICogQSBwcm9jZXNzZWQgYmxvY2sgZmV0Y2hlZCBmcm9tIHRoZSBSUEMgQVBJIHdoZXJlIHRoZSBgdHJhbnNhY3Rpb25EZXRhaWxzYCBtb2RlIGlzIGBhY2NvdW50c2BcbiAqL1xuXG4vKipcbiAqIEEgcHJvY2Vzc2VkIGJsb2NrIGZldGNoZWQgZnJvbSB0aGUgUlBDIEFQSSB3aGVyZSB0aGUgYHRyYW5zYWN0aW9uRGV0YWlsc2AgbW9kZSBpcyBgbm9uZWBcbiAqL1xuXG4vKipcbiAqIEEgYmxvY2sgd2l0aCBwYXJzZWQgdHJhbnNhY3Rpb25zXG4gKi9cblxuLyoqXG4gKiBBIGJsb2NrIHdpdGggcGFyc2VkIHRyYW5zYWN0aW9ucyB3aGVyZSB0aGUgYHRyYW5zYWN0aW9uRGV0YWlsc2AgbW9kZSBpcyBgYWNjb3VudHNgXG4gKi9cblxuLyoqXG4gKiBBIGJsb2NrIHdpdGggcGFyc2VkIHRyYW5zYWN0aW9ucyB3aGVyZSB0aGUgYHRyYW5zYWN0aW9uRGV0YWlsc2AgbW9kZSBpcyBgbm9uZWBcbiAqL1xuXG4vKipcbiAqIEEgcHJvY2Vzc2VkIGJsb2NrIGZldGNoZWQgZnJvbSB0aGUgUlBDIEFQSVxuICovXG5cbi8qKlxuICogQSBwcm9jZXNzZWQgYmxvY2sgZmV0Y2hlZCBmcm9tIHRoZSBSUEMgQVBJIHdoZXJlIHRoZSBgdHJhbnNhY3Rpb25EZXRhaWxzYCBtb2RlIGlzIGBhY2NvdW50c2BcbiAqL1xuXG4vKipcbiAqIEEgcHJvY2Vzc2VkIGJsb2NrIGZldGNoZWQgZnJvbSB0aGUgUlBDIEFQSSB3aGVyZSB0aGUgYHRyYW5zYWN0aW9uRGV0YWlsc2AgbW9kZSBpcyBgbm9uZWBcbiAqL1xuXG4vKipcbiAqIEEgY29uZmlybWVkIGJsb2NrIG9uIHRoZSBsZWRnZXJcbiAqXG4gKiBAZGVwcmVjYXRlZCBEZXByZWNhdGVkIHNpbmNlIFNvbGFuYSB2MS44LjAuXG4gKi9cblxuLyoqXG4gKiBBIEJsb2NrIG9uIHRoZSBsZWRnZXIgd2l0aCBzaWduYXR1cmVzIG9ubHlcbiAqL1xuXG4vKipcbiAqIHJlY2VudCBibG9jayBwcm9kdWN0aW9uIGluZm9ybWF0aW9uXG4gKi9cblxuLyoqXG4gKiBFeHBlY3RlZCBKU09OIFJQQyByZXNwb25zZSBmb3IgdGhlIFwiZ2V0QmxvY2tQcm9kdWN0aW9uXCIgbWVzc2FnZVxuICovXG5jb25zdCBCbG9ja1Byb2R1Y3Rpb25SZXNwb25zZVN0cnVjdCA9IGpzb25ScGNSZXN1bHRBbmRDb250ZXh0KHR5cGUoe1xuICBieUlkZW50aXR5OiByZWNvcmQoc3RyaW5nKCksIGFycmF5KG51bWJlcigpKSksXG4gIHJhbmdlOiB0eXBlKHtcbiAgICBmaXJzdFNsb3Q6IG51bWJlcigpLFxuICAgIGxhc3RTbG90OiBudW1iZXIoKVxuICB9KVxufSkpO1xuXG4vKipcbiAqIEEgcGVyZm9ybWFuY2Ugc2FtcGxlXG4gKi9cblxuZnVuY3Rpb24gY3JlYXRlUnBjQ2xpZW50KHVybCwgaHR0cEhlYWRlcnMsIGN1c3RvbUZldGNoLCBmZXRjaE1pZGRsZXdhcmUsIGRpc2FibGVSZXRyeU9uUmF0ZUxpbWl0LCBodHRwQWdlbnQpIHtcbiAgY29uc3QgZmV0Y2ggPSBjdXN0b21GZXRjaCA/IGN1c3RvbUZldGNoIDogZmV0Y2hJbXBsO1xuICBsZXQgYWdlbnQ7XG4gIHtcbiAgICBpZiAoaHR0cEFnZW50ID09IG51bGwpIHtcbiAgICAgIHtcbiAgICAgICAgY29uc3QgYWdlbnRPcHRpb25zID0ge1xuICAgICAgICAgIC8vIE9uZSBzZWNvbmQgZmV3ZXIgdGhhbiB0aGUgU29sYW5hIFJQQydzIGtlZXBhbGl2ZSB0aW1lb3V0LlxuICAgICAgICAgIC8vIFJlYWQgbW9yZTogaHR0cHM6Ly9naXRodWIuY29tL3NvbGFuYS1sYWJzL3NvbGFuYS9pc3N1ZXMvMjc4NTkjaXNzdWVjb21tZW50LTEzNDAwOTc4ODlcbiAgICAgICAgICBmcmVlU29ja2V0VGltZW91dDogMTkwMDAsXG4gICAgICAgICAga2VlcEFsaXZlOiB0cnVlLFxuICAgICAgICAgIG1heFNvY2tldHM6IDI1XG4gICAgICAgIH07XG4gICAgICAgIGlmICh1cmwuc3RhcnRzV2l0aCgnaHR0cHM6JykpIHtcbiAgICAgICAgICBhZ2VudCA9IG5ldyBIdHRwc0FnZW50KGFnZW50T3B0aW9ucyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYWdlbnQgPSBuZXcgSHR0cEtlZXBBbGl2ZUFnZW50KGFnZW50T3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKGh0dHBBZ2VudCAhPT0gZmFsc2UpIHtcbiAgICAgICAgY29uc3QgaXNIdHRwcyA9IHVybC5zdGFydHNXaXRoKCdodHRwczonKTtcbiAgICAgICAgaWYgKGlzSHR0cHMgJiYgIShodHRwQWdlbnQgaW5zdGFuY2VvZiBBZ2VudCQxKSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVGhlIGVuZHBvaW50IGAnICsgdXJsICsgJ2AgY2FuIG9ubHkgYmUgcGFpcmVkIHdpdGggYW4gYGh0dHBzLkFnZW50YC4gWW91IGhhdmUsIGluc3RlYWQsIHN1cHBsaWVkIGFuICcgKyAnYGh0dHAuQWdlbnRgIHRocm91Z2ggYGh0dHBBZ2VudGAuJyk7XG4gICAgICAgIH0gZWxzZSBpZiAoIWlzSHR0cHMgJiYgaHR0cEFnZW50IGluc3RhbmNlb2YgQWdlbnQkMSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVGhlIGVuZHBvaW50IGAnICsgdXJsICsgJ2AgY2FuIG9ubHkgYmUgcGFpcmVkIHdpdGggYW4gYGh0dHAuQWdlbnRgLiBZb3UgaGF2ZSwgaW5zdGVhZCwgc3VwcGxpZWQgYW4gJyArICdgaHR0cHMuQWdlbnRgIHRocm91Z2ggYGh0dHBBZ2VudGAuJyk7XG4gICAgICAgIH1cbiAgICAgICAgYWdlbnQgPSBodHRwQWdlbnQ7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGxldCBmZXRjaFdpdGhNaWRkbGV3YXJlO1xuICBpZiAoZmV0Y2hNaWRkbGV3YXJlKSB7XG4gICAgZmV0Y2hXaXRoTWlkZGxld2FyZSA9IGFzeW5jIChpbmZvLCBpbml0KSA9PiB7XG4gICAgICBjb25zdCBtb2RpZmllZEZldGNoQXJncyA9IGF3YWl0IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBmZXRjaE1pZGRsZXdhcmUoaW5mbywgaW5pdCwgKG1vZGlmaWVkSW5mbywgbW9kaWZpZWRJbml0KSA9PiByZXNvbHZlKFttb2RpZmllZEluZm8sIG1vZGlmaWVkSW5pdF0pKTtcbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICByZWplY3QoZXJyb3IpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBhd2FpdCBmZXRjaCguLi5tb2RpZmllZEZldGNoQXJncyk7XG4gICAgfTtcbiAgfVxuICBjb25zdCBjbGllbnRCcm93c2VyID0gbmV3IFJwY0NsaWVudChhc3luYyAocmVxdWVzdCwgY2FsbGJhY2spID0+IHtcbiAgICBjb25zdCBvcHRpb25zID0ge1xuICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICBib2R5OiByZXF1ZXN0LFxuICAgICAgYWdlbnQsXG4gICAgICBoZWFkZXJzOiBPYmplY3QuYXNzaWduKHtcbiAgICAgICAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJ1xuICAgICAgfSwgaHR0cEhlYWRlcnMgfHwge30sIENPTU1PTl9IVFRQX0hFQURFUlMpXG4gICAgfTtcbiAgICB0cnkge1xuICAgICAgbGV0IHRvb19tYW55X3JlcXVlc3RzX3JldHJpZXMgPSA1O1xuICAgICAgbGV0IHJlcztcbiAgICAgIGxldCB3YWl0VGltZSA9IDUwMDtcbiAgICAgIGZvciAoOzspIHtcbiAgICAgICAgaWYgKGZldGNoV2l0aE1pZGRsZXdhcmUpIHtcbiAgICAgICAgICByZXMgPSBhd2FpdCBmZXRjaFdpdGhNaWRkbGV3YXJlKHVybCwgb3B0aW9ucyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVzID0gYXdhaXQgZmV0Y2godXJsLCBvcHRpb25zKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocmVzLnN0YXR1cyAhPT0gNDI5IC8qIFRvbyBtYW55IHJlcXVlc3RzICovKSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRpc2FibGVSZXRyeU9uUmF0ZUxpbWl0ID09PSB0cnVlKSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgdG9vX21hbnlfcmVxdWVzdHNfcmV0cmllcyAtPSAxO1xuICAgICAgICBpZiAodG9vX21hbnlfcmVxdWVzdHNfcmV0cmllcyA9PT0gMCkge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoYFNlcnZlciByZXNwb25kZWQgd2l0aCAke3Jlcy5zdGF0dXN9ICR7cmVzLnN0YXR1c1RleHR9LiAgUmV0cnlpbmcgYWZ0ZXIgJHt3YWl0VGltZX1tcyBkZWxheS4uLmApO1xuICAgICAgICBhd2FpdCBzbGVlcCh3YWl0VGltZSk7XG4gICAgICAgIHdhaXRUaW1lICo9IDI7XG4gICAgICB9XG4gICAgICBjb25zdCB0ZXh0ID0gYXdhaXQgcmVzLnRleHQoKTtcbiAgICAgIGlmIChyZXMub2spIHtcbiAgICAgICAgY2FsbGJhY2sobnVsbCwgdGV4dCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjYWxsYmFjayhuZXcgRXJyb3IoYCR7cmVzLnN0YXR1c30gJHtyZXMuc3RhdHVzVGV4dH06ICR7dGV4dH1gKSk7XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBpZiAoZXJyIGluc3RhbmNlb2YgRXJyb3IpIGNhbGxiYWNrKGVycik7XG4gICAgfVxuICB9LCB7fSk7XG4gIHJldHVybiBjbGllbnRCcm93c2VyO1xufVxuZnVuY3Rpb24gY3JlYXRlUnBjUmVxdWVzdChjbGllbnQpIHtcbiAgcmV0dXJuIChtZXRob2QsIGFyZ3MpID0+IHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgY2xpZW50LnJlcXVlc3QobWV0aG9kLCBhcmdzLCAoZXJyLCByZXNwb25zZSkgPT4ge1xuICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgcmVqZWN0KGVycik7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHJlc29sdmUocmVzcG9uc2UpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH07XG59XG5mdW5jdGlvbiBjcmVhdGVScGNCYXRjaFJlcXVlc3QoY2xpZW50KSB7XG4gIHJldHVybiByZXF1ZXN0cyA9PiB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIC8vIERvIG5vdGhpbmcgaWYgcmVxdWVzdHMgaXMgZW1wdHlcbiAgICAgIGlmIChyZXF1ZXN0cy5sZW5ndGggPT09IDApIHJlc29sdmUoW10pO1xuICAgICAgY29uc3QgYmF0Y2ggPSByZXF1ZXN0cy5tYXAocGFyYW1zID0+IHtcbiAgICAgICAgcmV0dXJuIGNsaWVudC5yZXF1ZXN0KHBhcmFtcy5tZXRob2ROYW1lLCBwYXJhbXMuYXJncyk7XG4gICAgICB9KTtcbiAgICAgIGNsaWVudC5yZXF1ZXN0KGJhdGNoLCAoZXJyLCByZXNwb25zZSkgPT4ge1xuICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgcmVqZWN0KGVycik7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHJlc29sdmUocmVzcG9uc2UpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH07XG59XG5cbi8qKlxuICogRXhwZWN0ZWQgSlNPTiBSUEMgcmVzcG9uc2UgZm9yIHRoZSBcImdldEluZmxhdGlvbkdvdmVybm9yXCIgbWVzc2FnZVxuICovXG5jb25zdCBHZXRJbmZsYXRpb25Hb3Zlcm5vclJwY1Jlc3VsdCA9IGpzb25ScGNSZXN1bHQoR2V0SW5mbGF0aW9uR292ZXJub3JSZXN1bHQpO1xuXG4vKipcbiAqIEV4cGVjdGVkIEpTT04gUlBDIHJlc3BvbnNlIGZvciB0aGUgXCJnZXRJbmZsYXRpb25SYXRlXCIgbWVzc2FnZVxuICovXG5jb25zdCBHZXRJbmZsYXRpb25SYXRlUnBjUmVzdWx0ID0ganNvblJwY1Jlc3VsdChHZXRJbmZsYXRpb25SYXRlUmVzdWx0KTtcblxuLyoqXG4gKiBFeHBlY3RlZCBKU09OIFJQQyByZXNwb25zZSBmb3IgdGhlIFwiZ2V0UmVjZW50UHJpb3JpdGl6YXRpb25GZWVzXCIgbWVzc2FnZVxuICovXG5jb25zdCBHZXRSZWNlbnRQcmlvcml0aXphdGlvbkZlZXNScGNSZXN1bHQgPSBqc29uUnBjUmVzdWx0KEdldFJlY2VudFByaW9yaXRpemF0aW9uRmVlc1Jlc3VsdCk7XG5cbi8qKlxuICogRXhwZWN0ZWQgSlNPTiBSUEMgcmVzcG9uc2UgZm9yIHRoZSBcImdldEVwb2NoSW5mb1wiIG1lc3NhZ2VcbiAqL1xuY29uc3QgR2V0RXBvY2hJbmZvUnBjUmVzdWx0ID0ganNvblJwY1Jlc3VsdChHZXRFcG9jaEluZm9SZXN1bHQpO1xuXG4vKipcbiAqIEV4cGVjdGVkIEpTT04gUlBDIHJlc3BvbnNlIGZvciB0aGUgXCJnZXRFcG9jaFNjaGVkdWxlXCIgbWVzc2FnZVxuICovXG5jb25zdCBHZXRFcG9jaFNjaGVkdWxlUnBjUmVzdWx0ID0ganNvblJwY1Jlc3VsdChHZXRFcG9jaFNjaGVkdWxlUmVzdWx0KTtcblxuLyoqXG4gKiBFeHBlY3RlZCBKU09OIFJQQyByZXNwb25zZSBmb3IgdGhlIFwiZ2V0TGVhZGVyU2NoZWR1bGVcIiBtZXNzYWdlXG4gKi9cbmNvbnN0IEdldExlYWRlclNjaGVkdWxlUnBjUmVzdWx0ID0ganNvblJwY1Jlc3VsdChHZXRMZWFkZXJTY2hlZHVsZVJlc3VsdCk7XG5cbi8qKlxuICogRXhwZWN0ZWQgSlNPTiBSUEMgcmVzcG9uc2UgZm9yIHRoZSBcIm1pbmltdW1MZWRnZXJTbG90XCIgYW5kIFwiZ2V0Rmlyc3RBdmFpbGFibGVCbG9ja1wiIG1lc3NhZ2VzXG4gKi9cbmNvbnN0IFNsb3RScGNSZXN1bHQgPSBqc29uUnBjUmVzdWx0KG51bWJlcigpKTtcblxuLyoqXG4gKiBTdXBwbHlcbiAqL1xuXG4vKipcbiAqIEV4cGVjdGVkIEpTT04gUlBDIHJlc3BvbnNlIGZvciB0aGUgXCJnZXRTdXBwbHlcIiBtZXNzYWdlXG4gKi9cbmNvbnN0IEdldFN1cHBseVJwY1Jlc3VsdCA9IGpzb25ScGNSZXN1bHRBbmRDb250ZXh0KHR5cGUoe1xuICB0b3RhbDogbnVtYmVyKCksXG4gIGNpcmN1bGF0aW5nOiBudW1iZXIoKSxcbiAgbm9uQ2lyY3VsYXRpbmc6IG51bWJlcigpLFxuICBub25DaXJjdWxhdGluZ0FjY291bnRzOiBhcnJheShQdWJsaWNLZXlGcm9tU3RyaW5nKVxufSkpO1xuXG4vKipcbiAqIFRva2VuIGFtb3VudCBvYmplY3Qgd2hpY2ggcmV0dXJucyBhIHRva2VuIGFtb3VudCBpbiBkaWZmZXJlbnQgZm9ybWF0c1xuICogZm9yIHZhcmlvdXMgY2xpZW50IHVzZSBjYXNlcy5cbiAqL1xuXG4vKipcbiAqIEV4cGVjdGVkIEpTT04gUlBDIHN0cnVjdHVyZSBmb3IgdG9rZW4gYW1vdW50c1xuICovXG5jb25zdCBUb2tlbkFtb3VudFJlc3VsdCA9IHR5cGUoe1xuICBhbW91bnQ6IHN0cmluZygpLFxuICB1aUFtb3VudDogbnVsbGFibGUobnVtYmVyKCkpLFxuICBkZWNpbWFsczogbnVtYmVyKCksXG4gIHVpQW1vdW50U3RyaW5nOiBvcHRpb25hbChzdHJpbmcoKSlcbn0pO1xuXG4vKipcbiAqIFRva2VuIGFkZHJlc3MgYW5kIGJhbGFuY2UuXG4gKi9cblxuLyoqXG4gKiBFeHBlY3RlZCBKU09OIFJQQyByZXNwb25zZSBmb3IgdGhlIFwiZ2V0VG9rZW5MYXJnZXN0QWNjb3VudHNcIiBtZXNzYWdlXG4gKi9cbmNvbnN0IEdldFRva2VuTGFyZ2VzdEFjY291bnRzUmVzdWx0ID0ganNvblJwY1Jlc3VsdEFuZENvbnRleHQoYXJyYXkodHlwZSh7XG4gIGFkZHJlc3M6IFB1YmxpY0tleUZyb21TdHJpbmcsXG4gIGFtb3VudDogc3RyaW5nKCksXG4gIHVpQW1vdW50OiBudWxsYWJsZShudW1iZXIoKSksXG4gIGRlY2ltYWxzOiBudW1iZXIoKSxcbiAgdWlBbW91bnRTdHJpbmc6IG9wdGlvbmFsKHN0cmluZygpKVxufSkpKTtcblxuLyoqXG4gKiBFeHBlY3RlZCBKU09OIFJQQyByZXNwb25zZSBmb3IgdGhlIFwiZ2V0VG9rZW5BY2NvdW50c0J5T3duZXJcIiBtZXNzYWdlXG4gKi9cbmNvbnN0IEdldFRva2VuQWNjb3VudHNCeU93bmVyID0ganNvblJwY1Jlc3VsdEFuZENvbnRleHQoYXJyYXkodHlwZSh7XG4gIHB1YmtleTogUHVibGljS2V5RnJvbVN0cmluZyxcbiAgYWNjb3VudDogdHlwZSh7XG4gICAgZXhlY3V0YWJsZTogYm9vbGVhbigpLFxuICAgIG93bmVyOiBQdWJsaWNLZXlGcm9tU3RyaW5nLFxuICAgIGxhbXBvcnRzOiBudW1iZXIoKSxcbiAgICBkYXRhOiBCdWZmZXJGcm9tUmF3QWNjb3VudERhdGEsXG4gICAgcmVudEVwb2NoOiBudW1iZXIoKVxuICB9KVxufSkpKTtcbmNvbnN0IFBhcnNlZEFjY291bnREYXRhUmVzdWx0ID0gdHlwZSh7XG4gIHByb2dyYW06IHN0cmluZygpLFxuICBwYXJzZWQ6IHVua25vd24oKSxcbiAgc3BhY2U6IG51bWJlcigpXG59KTtcblxuLyoqXG4gKiBFeHBlY3RlZCBKU09OIFJQQyByZXNwb25zZSBmb3IgdGhlIFwiZ2V0VG9rZW5BY2NvdW50c0J5T3duZXJcIiBtZXNzYWdlIHdpdGggcGFyc2VkIGRhdGFcbiAqL1xuY29uc3QgR2V0UGFyc2VkVG9rZW5BY2NvdW50c0J5T3duZXIgPSBqc29uUnBjUmVzdWx0QW5kQ29udGV4dChhcnJheSh0eXBlKHtcbiAgcHVia2V5OiBQdWJsaWNLZXlGcm9tU3RyaW5nLFxuICBhY2NvdW50OiB0eXBlKHtcbiAgICBleGVjdXRhYmxlOiBib29sZWFuKCksXG4gICAgb3duZXI6IFB1YmxpY0tleUZyb21TdHJpbmcsXG4gICAgbGFtcG9ydHM6IG51bWJlcigpLFxuICAgIGRhdGE6IFBhcnNlZEFjY291bnREYXRhUmVzdWx0LFxuICAgIHJlbnRFcG9jaDogbnVtYmVyKClcbiAgfSlcbn0pKSk7XG5cbi8qKlxuICogUGFpciBvZiBhbiBhY2NvdW50IGFkZHJlc3MgYW5kIGl0cyBiYWxhbmNlXG4gKi9cblxuLyoqXG4gKiBFeHBlY3RlZCBKU09OIFJQQyByZXNwb25zZSBmb3IgdGhlIFwiZ2V0TGFyZ2VzdEFjY291bnRzXCIgbWVzc2FnZVxuICovXG5jb25zdCBHZXRMYXJnZXN0QWNjb3VudHNScGNSZXN1bHQgPSBqc29uUnBjUmVzdWx0QW5kQ29udGV4dChhcnJheSh0eXBlKHtcbiAgbGFtcG9ydHM6IG51bWJlcigpLFxuICBhZGRyZXNzOiBQdWJsaWNLZXlGcm9tU3RyaW5nXG59KSkpO1xuXG4vKipcbiAqIEBpbnRlcm5hbFxuICovXG5jb25zdCBBY2NvdW50SW5mb1Jlc3VsdCA9IHR5cGUoe1xuICBleGVjdXRhYmxlOiBib29sZWFuKCksXG4gIG93bmVyOiBQdWJsaWNLZXlGcm9tU3RyaW5nLFxuICBsYW1wb3J0czogbnVtYmVyKCksXG4gIGRhdGE6IEJ1ZmZlckZyb21SYXdBY2NvdW50RGF0YSxcbiAgcmVudEVwb2NoOiBudW1iZXIoKVxufSk7XG5cbi8qKlxuICogQGludGVybmFsXG4gKi9cbmNvbnN0IEtleWVkQWNjb3VudEluZm9SZXN1bHQgPSB0eXBlKHtcbiAgcHVia2V5OiBQdWJsaWNLZXlGcm9tU3RyaW5nLFxuICBhY2NvdW50OiBBY2NvdW50SW5mb1Jlc3VsdFxufSk7XG5jb25zdCBQYXJzZWRPclJhd0FjY291bnREYXRhID0gY29lcmNlKHVuaW9uKFtpbnN0YW5jZShCdWZmZXIpLCBQYXJzZWRBY2NvdW50RGF0YVJlc3VsdF0pLCB1bmlvbihbUmF3QWNjb3VudERhdGFSZXN1bHQsIFBhcnNlZEFjY291bnREYXRhUmVzdWx0XSksIHZhbHVlID0+IHtcbiAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgcmV0dXJuIGNyZWF0ZSh2YWx1ZSwgQnVmZmVyRnJvbVJhd0FjY291bnREYXRhKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbn0pO1xuXG4vKipcbiAqIEBpbnRlcm5hbFxuICovXG5jb25zdCBQYXJzZWRBY2NvdW50SW5mb1Jlc3VsdCA9IHR5cGUoe1xuICBleGVjdXRhYmxlOiBib29sZWFuKCksXG4gIG93bmVyOiBQdWJsaWNLZXlGcm9tU3RyaW5nLFxuICBsYW1wb3J0czogbnVtYmVyKCksXG4gIGRhdGE6IFBhcnNlZE9yUmF3QWNjb3VudERhdGEsXG4gIHJlbnRFcG9jaDogbnVtYmVyKClcbn0pO1xuY29uc3QgS2V5ZWRQYXJzZWRBY2NvdW50SW5mb1Jlc3VsdCA9IHR5cGUoe1xuICBwdWJrZXk6IFB1YmxpY0tleUZyb21TdHJpbmcsXG4gIGFjY291bnQ6IFBhcnNlZEFjY291bnRJbmZvUmVzdWx0XG59KTtcblxuLyoqXG4gKiBAaW50ZXJuYWxcbiAqL1xuY29uc3QgU3Rha2VBY3RpdmF0aW9uUmVzdWx0ID0gdHlwZSh7XG4gIHN0YXRlOiB1bmlvbihbbGl0ZXJhbCgnYWN0aXZlJyksIGxpdGVyYWwoJ2luYWN0aXZlJyksIGxpdGVyYWwoJ2FjdGl2YXRpbmcnKSwgbGl0ZXJhbCgnZGVhY3RpdmF0aW5nJyldKSxcbiAgYWN0aXZlOiBudW1iZXIoKSxcbiAgaW5hY3RpdmU6IG51bWJlcigpXG59KTtcblxuLyoqXG4gKiBFeHBlY3RlZCBKU09OIFJQQyByZXNwb25zZSBmb3IgdGhlIFwiZ2V0Q29uZmlybWVkU2lnbmF0dXJlc0ZvckFkZHJlc3MyXCIgbWVzc2FnZVxuICovXG5cbmNvbnN0IEdldENvbmZpcm1lZFNpZ25hdHVyZXNGb3JBZGRyZXNzMlJwY1Jlc3VsdCA9IGpzb25ScGNSZXN1bHQoYXJyYXkodHlwZSh7XG4gIHNpZ25hdHVyZTogc3RyaW5nKCksXG4gIHNsb3Q6IG51bWJlcigpLFxuICBlcnI6IFRyYW5zYWN0aW9uRXJyb3JSZXN1bHQsXG4gIG1lbW86IG51bGxhYmxlKHN0cmluZygpKSxcbiAgYmxvY2tUaW1lOiBvcHRpb25hbChudWxsYWJsZShudW1iZXIoKSkpXG59KSkpO1xuXG4vKipcbiAqIEV4cGVjdGVkIEpTT04gUlBDIHJlc3BvbnNlIGZvciB0aGUgXCJnZXRTaWduYXR1cmVzRm9yQWRkcmVzc1wiIG1lc3NhZ2VcbiAqL1xuY29uc3QgR2V0U2lnbmF0dXJlc0ZvckFkZHJlc3NScGNSZXN1bHQgPSBqc29uUnBjUmVzdWx0KGFycmF5KHR5cGUoe1xuICBzaWduYXR1cmU6IHN0cmluZygpLFxuICBzbG90OiBudW1iZXIoKSxcbiAgZXJyOiBUcmFuc2FjdGlvbkVycm9yUmVzdWx0LFxuICBtZW1vOiBudWxsYWJsZShzdHJpbmcoKSksXG4gIGJsb2NrVGltZTogb3B0aW9uYWwobnVsbGFibGUobnVtYmVyKCkpKVxufSkpKTtcblxuLyoqKlxuICogRXhwZWN0ZWQgSlNPTiBSUEMgcmVzcG9uc2UgZm9yIHRoZSBcImFjY291bnROb3RpZmljYXRpb25cIiBtZXNzYWdlXG4gKi9cbmNvbnN0IEFjY291bnROb3RpZmljYXRpb25SZXN1bHQgPSB0eXBlKHtcbiAgc3Vic2NyaXB0aW9uOiBudW1iZXIoKSxcbiAgcmVzdWx0OiBub3RpZmljYXRpb25SZXN1bHRBbmRDb250ZXh0KEFjY291bnRJbmZvUmVzdWx0KVxufSk7XG5cbi8qKlxuICogQGludGVybmFsXG4gKi9cbmNvbnN0IFByb2dyYW1BY2NvdW50SW5mb1Jlc3VsdCA9IHR5cGUoe1xuICBwdWJrZXk6IFB1YmxpY0tleUZyb21TdHJpbmcsXG4gIGFjY291bnQ6IEFjY291bnRJbmZvUmVzdWx0XG59KTtcblxuLyoqKlxuICogRXhwZWN0ZWQgSlNPTiBSUEMgcmVzcG9uc2UgZm9yIHRoZSBcInByb2dyYW1Ob3RpZmljYXRpb25cIiBtZXNzYWdlXG4gKi9cbmNvbnN0IFByb2dyYW1BY2NvdW50Tm90aWZpY2F0aW9uUmVzdWx0ID0gdHlwZSh7XG4gIHN1YnNjcmlwdGlvbjogbnVtYmVyKCksXG4gIHJlc3VsdDogbm90aWZpY2F0aW9uUmVzdWx0QW5kQ29udGV4dChQcm9ncmFtQWNjb3VudEluZm9SZXN1bHQpXG59KTtcblxuLyoqXG4gKiBAaW50ZXJuYWxcbiAqL1xuY29uc3QgU2xvdEluZm9SZXN1bHQgPSB0eXBlKHtcbiAgcGFyZW50OiBudW1iZXIoKSxcbiAgc2xvdDogbnVtYmVyKCksXG4gIHJvb3Q6IG51bWJlcigpXG59KTtcblxuLyoqXG4gKiBFeHBlY3RlZCBKU09OIFJQQyByZXNwb25zZSBmb3IgdGhlIFwic2xvdE5vdGlmaWNhdGlvblwiIG1lc3NhZ2VcbiAqL1xuY29uc3QgU2xvdE5vdGlmaWNhdGlvblJlc3VsdCA9IHR5cGUoe1xuICBzdWJzY3JpcHRpb246IG51bWJlcigpLFxuICByZXN1bHQ6IFNsb3RJbmZvUmVzdWx0XG59KTtcblxuLyoqXG4gKiBTbG90IHVwZGF0ZXMgd2hpY2ggY2FuIGJlIHVzZWQgZm9yIHRyYWNraW5nIHRoZSBsaXZlIHByb2dyZXNzIG9mIGEgY2x1c3Rlci5cbiAqIC0gYFwiZmlyc3RTaHJlZFJlY2VpdmVkXCJgOiBjb25uZWN0ZWQgbm9kZSByZWNlaXZlZCB0aGUgZmlyc3Qgc2hyZWQgb2YgYSBibG9jay5cbiAqIEluZGljYXRlcyB0aGF0IGEgbmV3IGJsb2NrIHRoYXQgaXMgYmVpbmcgcHJvZHVjZWQuXG4gKiAtIGBcImNvbXBsZXRlZFwiYDogY29ubmVjdGVkIG5vZGUgaGFzIHJlY2VpdmVkIGFsbCBzaHJlZHMgb2YgYSBibG9jay4gSW5kaWNhdGVzXG4gKiBhIGJsb2NrIHdhcyByZWNlbnRseSBwcm9kdWNlZC5cbiAqIC0gYFwib3B0aW1pc3RpY0NvbmZpcm1hdGlvblwiYDogYmxvY2sgd2FzIG9wdGltaXN0aWNhbGx5IGNvbmZpcm1lZCBieSB0aGVcbiAqIGNsdXN0ZXIuIEl0IGlzIG5vdCBndWFyYW50ZWVkIHRoYXQgYW4gb3B0aW1pc3RpYyBjb25maXJtYXRpb24gbm90aWZpY2F0aW9uXG4gKiB3aWxsIGJlIHNlbnQgZm9yIGV2ZXJ5IGZpbmFsaXplZCBibG9ja3MuXG4gKiAtIGBcInJvb3RcImA6IHRoZSBjb25uZWN0ZWQgbm9kZSByb290ZWQgdGhpcyBibG9jay5cbiAqIC0gYFwiY3JlYXRlZEJhbmtcImA6IHRoZSBjb25uZWN0ZWQgbm9kZSBoYXMgc3RhcnRlZCB2YWxpZGF0aW5nIHRoaXMgYmxvY2suXG4gKiAtIGBcImZyb3plblwiYDogdGhlIGNvbm5lY3RlZCBub2RlIGhhcyB2YWxpZGF0ZWQgdGhpcyBibG9jay5cbiAqIC0gYFwiZGVhZFwiYDogdGhlIGNvbm5lY3RlZCBub2RlIGZhaWxlZCB0byB2YWxpZGF0ZSB0aGlzIGJsb2NrLlxuICovXG5cbi8qKlxuICogQGludGVybmFsXG4gKi9cbmNvbnN0IFNsb3RVcGRhdGVSZXN1bHQgPSB1bmlvbihbdHlwZSh7XG4gIHR5cGU6IHVuaW9uKFtsaXRlcmFsKCdmaXJzdFNocmVkUmVjZWl2ZWQnKSwgbGl0ZXJhbCgnY29tcGxldGVkJyksIGxpdGVyYWwoJ29wdGltaXN0aWNDb25maXJtYXRpb24nKSwgbGl0ZXJhbCgncm9vdCcpXSksXG4gIHNsb3Q6IG51bWJlcigpLFxuICB0aW1lc3RhbXA6IG51bWJlcigpXG59KSwgdHlwZSh7XG4gIHR5cGU6IGxpdGVyYWwoJ2NyZWF0ZWRCYW5rJyksXG4gIHBhcmVudDogbnVtYmVyKCksXG4gIHNsb3Q6IG51bWJlcigpLFxuICB0aW1lc3RhbXA6IG51bWJlcigpXG59KSwgdHlwZSh7XG4gIHR5cGU6IGxpdGVyYWwoJ2Zyb3plbicpLFxuICBzbG90OiBudW1iZXIoKSxcbiAgdGltZXN0YW1wOiBudW1iZXIoKSxcbiAgc3RhdHM6IHR5cGUoe1xuICAgIG51bVRyYW5zYWN0aW9uRW50cmllczogbnVtYmVyKCksXG4gICAgbnVtU3VjY2Vzc2Z1bFRyYW5zYWN0aW9uczogbnVtYmVyKCksXG4gICAgbnVtRmFpbGVkVHJhbnNhY3Rpb25zOiBudW1iZXIoKSxcbiAgICBtYXhUcmFuc2FjdGlvbnNQZXJFbnRyeTogbnVtYmVyKClcbiAgfSlcbn0pLCB0eXBlKHtcbiAgdHlwZTogbGl0ZXJhbCgnZGVhZCcpLFxuICBzbG90OiBudW1iZXIoKSxcbiAgdGltZXN0YW1wOiBudW1iZXIoKSxcbiAgZXJyOiBzdHJpbmcoKVxufSldKTtcblxuLyoqXG4gKiBFeHBlY3RlZCBKU09OIFJQQyByZXNwb25zZSBmb3IgdGhlIFwic2xvdHNVcGRhdGVzTm90aWZpY2F0aW9uXCIgbWVzc2FnZVxuICovXG5jb25zdCBTbG90VXBkYXRlTm90aWZpY2F0aW9uUmVzdWx0ID0gdHlwZSh7XG4gIHN1YnNjcmlwdGlvbjogbnVtYmVyKCksXG4gIHJlc3VsdDogU2xvdFVwZGF0ZVJlc3VsdFxufSk7XG5cbi8qKlxuICogRXhwZWN0ZWQgSlNPTiBSUEMgcmVzcG9uc2UgZm9yIHRoZSBcInNpZ25hdHVyZU5vdGlmaWNhdGlvblwiIG1lc3NhZ2VcbiAqL1xuY29uc3QgU2lnbmF0dXJlTm90aWZpY2F0aW9uUmVzdWx0ID0gdHlwZSh7XG4gIHN1YnNjcmlwdGlvbjogbnVtYmVyKCksXG4gIHJlc3VsdDogbm90aWZpY2F0aW9uUmVzdWx0QW5kQ29udGV4dCh1bmlvbihbU2lnbmF0dXJlU3RhdHVzUmVzdWx0LCBTaWduYXR1cmVSZWNlaXZlZFJlc3VsdF0pKVxufSk7XG5cbi8qKlxuICogRXhwZWN0ZWQgSlNPTiBSUEMgcmVzcG9uc2UgZm9yIHRoZSBcInJvb3ROb3RpZmljYXRpb25cIiBtZXNzYWdlXG4gKi9cbmNvbnN0IFJvb3ROb3RpZmljYXRpb25SZXN1bHQgPSB0eXBlKHtcbiAgc3Vic2NyaXB0aW9uOiBudW1iZXIoKSxcbiAgcmVzdWx0OiBudW1iZXIoKVxufSk7XG5jb25zdCBDb250YWN0SW5mb1Jlc3VsdCA9IHR5cGUoe1xuICBwdWJrZXk6IHN0cmluZygpLFxuICBnb3NzaXA6IG51bGxhYmxlKHN0cmluZygpKSxcbiAgdHB1OiBudWxsYWJsZShzdHJpbmcoKSksXG4gIHJwYzogbnVsbGFibGUoc3RyaW5nKCkpLFxuICB2ZXJzaW9uOiBudWxsYWJsZShzdHJpbmcoKSlcbn0pO1xuY29uc3QgVm90ZUFjY291bnRJbmZvUmVzdWx0ID0gdHlwZSh7XG4gIHZvdGVQdWJrZXk6IHN0cmluZygpLFxuICBub2RlUHVia2V5OiBzdHJpbmcoKSxcbiAgYWN0aXZhdGVkU3Rha2U6IG51bWJlcigpLFxuICBlcG9jaFZvdGVBY2NvdW50OiBib29sZWFuKCksXG4gIGVwb2NoQ3JlZGl0czogYXJyYXkodHVwbGUoW251bWJlcigpLCBudW1iZXIoKSwgbnVtYmVyKCldKSksXG4gIGNvbW1pc3Npb246IG51bWJlcigpLFxuICBsYXN0Vm90ZTogbnVtYmVyKCksXG4gIHJvb3RTbG90OiBudWxsYWJsZShudW1iZXIoKSlcbn0pO1xuXG4vKipcbiAqIEV4cGVjdGVkIEpTT04gUlBDIHJlc3BvbnNlIGZvciB0aGUgXCJnZXRWb3RlQWNjb3VudHNcIiBtZXNzYWdlXG4gKi9cbmNvbnN0IEdldFZvdGVBY2NvdW50cyA9IGpzb25ScGNSZXN1bHQodHlwZSh7XG4gIGN1cnJlbnQ6IGFycmF5KFZvdGVBY2NvdW50SW5mb1Jlc3VsdCksXG4gIGRlbGlucXVlbnQ6IGFycmF5KFZvdGVBY2NvdW50SW5mb1Jlc3VsdClcbn0pKTtcbmNvbnN0IENvbmZpcm1hdGlvblN0YXR1cyA9IHVuaW9uKFtsaXRlcmFsKCdwcm9jZXNzZWQnKSwgbGl0ZXJhbCgnY29uZmlybWVkJyksIGxpdGVyYWwoJ2ZpbmFsaXplZCcpXSk7XG5jb25zdCBTaWduYXR1cmVTdGF0dXNSZXNwb25zZSA9IHR5cGUoe1xuICBzbG90OiBudW1iZXIoKSxcbiAgY29uZmlybWF0aW9uczogbnVsbGFibGUobnVtYmVyKCkpLFxuICBlcnI6IFRyYW5zYWN0aW9uRXJyb3JSZXN1bHQsXG4gIGNvbmZpcm1hdGlvblN0YXR1czogb3B0aW9uYWwoQ29uZmlybWF0aW9uU3RhdHVzKVxufSk7XG5cbi8qKlxuICogRXhwZWN0ZWQgSlNPTiBSUEMgcmVzcG9uc2UgZm9yIHRoZSBcImdldFNpZ25hdHVyZVN0YXR1c2VzXCIgbWVzc2FnZVxuICovXG5jb25zdCBHZXRTaWduYXR1cmVTdGF0dXNlc1JwY1Jlc3VsdCA9IGpzb25ScGNSZXN1bHRBbmRDb250ZXh0KGFycmF5KG51bGxhYmxlKFNpZ25hdHVyZVN0YXR1c1Jlc3BvbnNlKSkpO1xuXG4vKipcbiAqIEV4cGVjdGVkIEpTT04gUlBDIHJlc3BvbnNlIGZvciB0aGUgXCJnZXRNaW5pbXVtQmFsYW5jZUZvclJlbnRFeGVtcHRpb25cIiBtZXNzYWdlXG4gKi9cbmNvbnN0IEdldE1pbmltdW1CYWxhbmNlRm9yUmVudEV4ZW1wdGlvblJwY1Jlc3VsdCA9IGpzb25ScGNSZXN1bHQobnVtYmVyKCkpO1xuY29uc3QgQWRkcmVzc1RhYmxlTG9va3VwU3RydWN0ID0gdHlwZSh7XG4gIGFjY291bnRLZXk6IFB1YmxpY0tleUZyb21TdHJpbmcsXG4gIHdyaXRhYmxlSW5kZXhlczogYXJyYXkobnVtYmVyKCkpLFxuICByZWFkb25seUluZGV4ZXM6IGFycmF5KG51bWJlcigpKVxufSk7XG5jb25zdCBDb25maXJtZWRUcmFuc2FjdGlvblJlc3VsdCA9IHR5cGUoe1xuICBzaWduYXR1cmVzOiBhcnJheShzdHJpbmcoKSksXG4gIG1lc3NhZ2U6IHR5cGUoe1xuICAgIGFjY291bnRLZXlzOiBhcnJheShzdHJpbmcoKSksXG4gICAgaGVhZGVyOiB0eXBlKHtcbiAgICAgIG51bVJlcXVpcmVkU2lnbmF0dXJlczogbnVtYmVyKCksXG4gICAgICBudW1SZWFkb25seVNpZ25lZEFjY291bnRzOiBudW1iZXIoKSxcbiAgICAgIG51bVJlYWRvbmx5VW5zaWduZWRBY2NvdW50czogbnVtYmVyKClcbiAgICB9KSxcbiAgICBpbnN0cnVjdGlvbnM6IGFycmF5KHR5cGUoe1xuICAgICAgYWNjb3VudHM6IGFycmF5KG51bWJlcigpKSxcbiAgICAgIGRhdGE6IHN0cmluZygpLFxuICAgICAgcHJvZ3JhbUlkSW5kZXg6IG51bWJlcigpXG4gICAgfSkpLFxuICAgIHJlY2VudEJsb2NraGFzaDogc3RyaW5nKCksXG4gICAgYWRkcmVzc1RhYmxlTG9va3Vwczogb3B0aW9uYWwoYXJyYXkoQWRkcmVzc1RhYmxlTG9va3VwU3RydWN0KSlcbiAgfSlcbn0pO1xuY29uc3QgQW5ub3RhdGVkQWNjb3VudEtleSA9IHR5cGUoe1xuICBwdWJrZXk6IFB1YmxpY0tleUZyb21TdHJpbmcsXG4gIHNpZ25lcjogYm9vbGVhbigpLFxuICB3cml0YWJsZTogYm9vbGVhbigpLFxuICBzb3VyY2U6IG9wdGlvbmFsKHVuaW9uKFtsaXRlcmFsKCd0cmFuc2FjdGlvbicpLCBsaXRlcmFsKCdsb29rdXBUYWJsZScpXSkpXG59KTtcbmNvbnN0IENvbmZpcm1lZFRyYW5zYWN0aW9uQWNjb3VudHNNb2RlUmVzdWx0ID0gdHlwZSh7XG4gIGFjY291bnRLZXlzOiBhcnJheShBbm5vdGF0ZWRBY2NvdW50S2V5KSxcbiAgc2lnbmF0dXJlczogYXJyYXkoc3RyaW5nKCkpXG59KTtcbmNvbnN0IFBhcnNlZEluc3RydWN0aW9uUmVzdWx0ID0gdHlwZSh7XG4gIHBhcnNlZDogdW5rbm93bigpLFxuICBwcm9ncmFtOiBzdHJpbmcoKSxcbiAgcHJvZ3JhbUlkOiBQdWJsaWNLZXlGcm9tU3RyaW5nXG59KTtcbmNvbnN0IFJhd0luc3RydWN0aW9uUmVzdWx0ID0gdHlwZSh7XG4gIGFjY291bnRzOiBhcnJheShQdWJsaWNLZXlGcm9tU3RyaW5nKSxcbiAgZGF0YTogc3RyaW5nKCksXG4gIHByb2dyYW1JZDogUHVibGljS2V5RnJvbVN0cmluZ1xufSk7XG5jb25zdCBJbnN0cnVjdGlvblJlc3VsdCA9IHVuaW9uKFtSYXdJbnN0cnVjdGlvblJlc3VsdCwgUGFyc2VkSW5zdHJ1Y3Rpb25SZXN1bHRdKTtcbmNvbnN0IFVua25vd25JbnN0cnVjdGlvblJlc3VsdCA9IHVuaW9uKFt0eXBlKHtcbiAgcGFyc2VkOiB1bmtub3duKCksXG4gIHByb2dyYW06IHN0cmluZygpLFxuICBwcm9ncmFtSWQ6IHN0cmluZygpXG59KSwgdHlwZSh7XG4gIGFjY291bnRzOiBhcnJheShzdHJpbmcoKSksXG4gIGRhdGE6IHN0cmluZygpLFxuICBwcm9ncmFtSWQ6IHN0cmluZygpXG59KV0pO1xuY29uc3QgUGFyc2VkT3JSYXdJbnN0cnVjdGlvbiA9IGNvZXJjZShJbnN0cnVjdGlvblJlc3VsdCwgVW5rbm93bkluc3RydWN0aW9uUmVzdWx0LCB2YWx1ZSA9PiB7XG4gIGlmICgnYWNjb3VudHMnIGluIHZhbHVlKSB7XG4gICAgcmV0dXJuIGNyZWF0ZSh2YWx1ZSwgUmF3SW5zdHJ1Y3Rpb25SZXN1bHQpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBjcmVhdGUodmFsdWUsIFBhcnNlZEluc3RydWN0aW9uUmVzdWx0KTtcbiAgfVxufSk7XG5cbi8qKlxuICogQGludGVybmFsXG4gKi9cbmNvbnN0IFBhcnNlZENvbmZpcm1lZFRyYW5zYWN0aW9uUmVzdWx0ID0gdHlwZSh7XG4gIHNpZ25hdHVyZXM6IGFycmF5KHN0cmluZygpKSxcbiAgbWVzc2FnZTogdHlwZSh7XG4gICAgYWNjb3VudEtleXM6IGFycmF5KEFubm90YXRlZEFjY291bnRLZXkpLFxuICAgIGluc3RydWN0aW9uczogYXJyYXkoUGFyc2VkT3JSYXdJbnN0cnVjdGlvbiksXG4gICAgcmVjZW50QmxvY2toYXNoOiBzdHJpbmcoKSxcbiAgICBhZGRyZXNzVGFibGVMb29rdXBzOiBvcHRpb25hbChudWxsYWJsZShhcnJheShBZGRyZXNzVGFibGVMb29rdXBTdHJ1Y3QpKSlcbiAgfSlcbn0pO1xuY29uc3QgVG9rZW5CYWxhbmNlUmVzdWx0ID0gdHlwZSh7XG4gIGFjY291bnRJbmRleDogbnVtYmVyKCksXG4gIG1pbnQ6IHN0cmluZygpLFxuICBvd25lcjogb3B0aW9uYWwoc3RyaW5nKCkpLFxuICB1aVRva2VuQW1vdW50OiBUb2tlbkFtb3VudFJlc3VsdFxufSk7XG5jb25zdCBMb2FkZWRBZGRyZXNzZXNSZXN1bHQgPSB0eXBlKHtcbiAgd3JpdGFibGU6IGFycmF5KFB1YmxpY0tleUZyb21TdHJpbmcpLFxuICByZWFkb25seTogYXJyYXkoUHVibGljS2V5RnJvbVN0cmluZylcbn0pO1xuXG4vKipcbiAqIEBpbnRlcm5hbFxuICovXG5jb25zdCBDb25maXJtZWRUcmFuc2FjdGlvbk1ldGFSZXN1bHQgPSB0eXBlKHtcbiAgZXJyOiBUcmFuc2FjdGlvbkVycm9yUmVzdWx0LFxuICBmZWU6IG51bWJlcigpLFxuICBpbm5lckluc3RydWN0aW9uczogb3B0aW9uYWwobnVsbGFibGUoYXJyYXkodHlwZSh7XG4gICAgaW5kZXg6IG51bWJlcigpLFxuICAgIGluc3RydWN0aW9uczogYXJyYXkodHlwZSh7XG4gICAgICBhY2NvdW50czogYXJyYXkobnVtYmVyKCkpLFxuICAgICAgZGF0YTogc3RyaW5nKCksXG4gICAgICBwcm9ncmFtSWRJbmRleDogbnVtYmVyKClcbiAgICB9KSlcbiAgfSkpKSksXG4gIHByZUJhbGFuY2VzOiBhcnJheShudW1iZXIoKSksXG4gIHBvc3RCYWxhbmNlczogYXJyYXkobnVtYmVyKCkpLFxuICBsb2dNZXNzYWdlczogb3B0aW9uYWwobnVsbGFibGUoYXJyYXkoc3RyaW5nKCkpKSksXG4gIHByZVRva2VuQmFsYW5jZXM6IG9wdGlvbmFsKG51bGxhYmxlKGFycmF5KFRva2VuQmFsYW5jZVJlc3VsdCkpKSxcbiAgcG9zdFRva2VuQmFsYW5jZXM6IG9wdGlvbmFsKG51bGxhYmxlKGFycmF5KFRva2VuQmFsYW5jZVJlc3VsdCkpKSxcbiAgbG9hZGVkQWRkcmVzc2VzOiBvcHRpb25hbChMb2FkZWRBZGRyZXNzZXNSZXN1bHQpLFxuICBjb21wdXRlVW5pdHNDb25zdW1lZDogb3B0aW9uYWwobnVtYmVyKCkpXG59KTtcblxuLyoqXG4gKiBAaW50ZXJuYWxcbiAqL1xuY29uc3QgUGFyc2VkQ29uZmlybWVkVHJhbnNhY3Rpb25NZXRhUmVzdWx0ID0gdHlwZSh7XG4gIGVycjogVHJhbnNhY3Rpb25FcnJvclJlc3VsdCxcbiAgZmVlOiBudW1iZXIoKSxcbiAgaW5uZXJJbnN0cnVjdGlvbnM6IG9wdGlvbmFsKG51bGxhYmxlKGFycmF5KHR5cGUoe1xuICAgIGluZGV4OiBudW1iZXIoKSxcbiAgICBpbnN0cnVjdGlvbnM6IGFycmF5KFBhcnNlZE9yUmF3SW5zdHJ1Y3Rpb24pXG4gIH0pKSkpLFxuICBwcmVCYWxhbmNlczogYXJyYXkobnVtYmVyKCkpLFxuICBwb3N0QmFsYW5jZXM6IGFycmF5KG51bWJlcigpKSxcbiAgbG9nTWVzc2FnZXM6IG9wdGlvbmFsKG51bGxhYmxlKGFycmF5KHN0cmluZygpKSkpLFxuICBwcmVUb2tlbkJhbGFuY2VzOiBvcHRpb25hbChudWxsYWJsZShhcnJheShUb2tlbkJhbGFuY2VSZXN1bHQpKSksXG4gIHBvc3RUb2tlbkJhbGFuY2VzOiBvcHRpb25hbChudWxsYWJsZShhcnJheShUb2tlbkJhbGFuY2VSZXN1bHQpKSksXG4gIGxvYWRlZEFkZHJlc3Nlczogb3B0aW9uYWwoTG9hZGVkQWRkcmVzc2VzUmVzdWx0KSxcbiAgY29tcHV0ZVVuaXRzQ29uc3VtZWQ6IG9wdGlvbmFsKG51bWJlcigpKVxufSk7XG5jb25zdCBUcmFuc2FjdGlvblZlcnNpb25TdHJ1Y3QgPSB1bmlvbihbbGl0ZXJhbCgwKSwgbGl0ZXJhbCgnbGVnYWN5JyldKTtcblxuLyoqIEBpbnRlcm5hbCAqL1xuY29uc3QgUmV3YXJkc1Jlc3VsdCA9IHR5cGUoe1xuICBwdWJrZXk6IHN0cmluZygpLFxuICBsYW1wb3J0czogbnVtYmVyKCksXG4gIHBvc3RCYWxhbmNlOiBudWxsYWJsZShudW1iZXIoKSksXG4gIHJld2FyZFR5cGU6IG51bGxhYmxlKHN0cmluZygpKSxcbiAgY29tbWlzc2lvbjogb3B0aW9uYWwobnVsbGFibGUobnVtYmVyKCkpKVxufSk7XG5cbi8qKlxuICogRXhwZWN0ZWQgSlNPTiBSUEMgcmVzcG9uc2UgZm9yIHRoZSBcImdldEJsb2NrXCIgbWVzc2FnZVxuICovXG5jb25zdCBHZXRCbG9ja1JwY1Jlc3VsdCA9IGpzb25ScGNSZXN1bHQobnVsbGFibGUodHlwZSh7XG4gIGJsb2NraGFzaDogc3RyaW5nKCksXG4gIHByZXZpb3VzQmxvY2toYXNoOiBzdHJpbmcoKSxcbiAgcGFyZW50U2xvdDogbnVtYmVyKCksXG4gIHRyYW5zYWN0aW9uczogYXJyYXkodHlwZSh7XG4gICAgdHJhbnNhY3Rpb246IENvbmZpcm1lZFRyYW5zYWN0aW9uUmVzdWx0LFxuICAgIG1ldGE6IG51bGxhYmxlKENvbmZpcm1lZFRyYW5zYWN0aW9uTWV0YVJlc3VsdCksXG4gICAgdmVyc2lvbjogb3B0aW9uYWwoVHJhbnNhY3Rpb25WZXJzaW9uU3RydWN0KVxuICB9KSksXG4gIHJld2FyZHM6IG9wdGlvbmFsKGFycmF5KFJld2FyZHNSZXN1bHQpKSxcbiAgYmxvY2tUaW1lOiBudWxsYWJsZShudW1iZXIoKSksXG4gIGJsb2NrSGVpZ2h0OiBudWxsYWJsZShudW1iZXIoKSlcbn0pKSk7XG5cbi8qKlxuICogRXhwZWN0ZWQgSlNPTiBSUEMgcmVzcG9uc2UgZm9yIHRoZSBcImdldEJsb2NrXCIgbWVzc2FnZSB3aGVuIGB0cmFuc2FjdGlvbkRldGFpbHNgIGlzIGBub25lYFxuICovXG5jb25zdCBHZXROb25lTW9kZUJsb2NrUnBjUmVzdWx0ID0ganNvblJwY1Jlc3VsdChudWxsYWJsZSh0eXBlKHtcbiAgYmxvY2toYXNoOiBzdHJpbmcoKSxcbiAgcHJldmlvdXNCbG9ja2hhc2g6IHN0cmluZygpLFxuICBwYXJlbnRTbG90OiBudW1iZXIoKSxcbiAgcmV3YXJkczogb3B0aW9uYWwoYXJyYXkoUmV3YXJkc1Jlc3VsdCkpLFxuICBibG9ja1RpbWU6IG51bGxhYmxlKG51bWJlcigpKSxcbiAgYmxvY2tIZWlnaHQ6IG51bGxhYmxlKG51bWJlcigpKVxufSkpKTtcblxuLyoqXG4gKiBFeHBlY3RlZCBKU09OIFJQQyByZXNwb25zZSBmb3IgdGhlIFwiZ2V0QmxvY2tcIiBtZXNzYWdlIHdoZW4gYHRyYW5zYWN0aW9uRGV0YWlsc2AgaXMgYGFjY291bnRzYFxuICovXG5jb25zdCBHZXRBY2NvdW50c01vZGVCbG9ja1JwY1Jlc3VsdCA9IGpzb25ScGNSZXN1bHQobnVsbGFibGUodHlwZSh7XG4gIGJsb2NraGFzaDogc3RyaW5nKCksXG4gIHByZXZpb3VzQmxvY2toYXNoOiBzdHJpbmcoKSxcbiAgcGFyZW50U2xvdDogbnVtYmVyKCksXG4gIHRyYW5zYWN0aW9uczogYXJyYXkodHlwZSh7XG4gICAgdHJhbnNhY3Rpb246IENvbmZpcm1lZFRyYW5zYWN0aW9uQWNjb3VudHNNb2RlUmVzdWx0LFxuICAgIG1ldGE6IG51bGxhYmxlKENvbmZpcm1lZFRyYW5zYWN0aW9uTWV0YVJlc3VsdCksXG4gICAgdmVyc2lvbjogb3B0aW9uYWwoVHJhbnNhY3Rpb25WZXJzaW9uU3RydWN0KVxuICB9KSksXG4gIHJld2FyZHM6IG9wdGlvbmFsKGFycmF5KFJld2FyZHNSZXN1bHQpKSxcbiAgYmxvY2tUaW1lOiBudWxsYWJsZShudW1iZXIoKSksXG4gIGJsb2NrSGVpZ2h0OiBudWxsYWJsZShudW1iZXIoKSlcbn0pKSk7XG5cbi8qKlxuICogRXhwZWN0ZWQgcGFyc2VkIEpTT04gUlBDIHJlc3BvbnNlIGZvciB0aGUgXCJnZXRCbG9ja1wiIG1lc3NhZ2VcbiAqL1xuY29uc3QgR2V0UGFyc2VkQmxvY2tScGNSZXN1bHQgPSBqc29uUnBjUmVzdWx0KG51bGxhYmxlKHR5cGUoe1xuICBibG9ja2hhc2g6IHN0cmluZygpLFxuICBwcmV2aW91c0Jsb2NraGFzaDogc3RyaW5nKCksXG4gIHBhcmVudFNsb3Q6IG51bWJlcigpLFxuICB0cmFuc2FjdGlvbnM6IGFycmF5KHR5cGUoe1xuICAgIHRyYW5zYWN0aW9uOiBQYXJzZWRDb25maXJtZWRUcmFuc2FjdGlvblJlc3VsdCxcbiAgICBtZXRhOiBudWxsYWJsZShQYXJzZWRDb25maXJtZWRUcmFuc2FjdGlvbk1ldGFSZXN1bHQpLFxuICAgIHZlcnNpb246IG9wdGlvbmFsKFRyYW5zYWN0aW9uVmVyc2lvblN0cnVjdClcbiAgfSkpLFxuICByZXdhcmRzOiBvcHRpb25hbChhcnJheShSZXdhcmRzUmVzdWx0KSksXG4gIGJsb2NrVGltZTogbnVsbGFibGUobnVtYmVyKCkpLFxuICBibG9ja0hlaWdodDogbnVsbGFibGUobnVtYmVyKCkpXG59KSkpO1xuXG4vKipcbiAqIEV4cGVjdGVkIHBhcnNlZCBKU09OIFJQQyByZXNwb25zZSBmb3IgdGhlIFwiZ2V0QmxvY2tcIiBtZXNzYWdlICB3aGVuIGB0cmFuc2FjdGlvbkRldGFpbHNgIGlzIGBhY2NvdW50c2BcbiAqL1xuY29uc3QgR2V0UGFyc2VkQWNjb3VudHNNb2RlQmxvY2tScGNSZXN1bHQgPSBqc29uUnBjUmVzdWx0KG51bGxhYmxlKHR5cGUoe1xuICBibG9ja2hhc2g6IHN0cmluZygpLFxuICBwcmV2aW91c0Jsb2NraGFzaDogc3RyaW5nKCksXG4gIHBhcmVudFNsb3Q6IG51bWJlcigpLFxuICB0cmFuc2FjdGlvbnM6IGFycmF5KHR5cGUoe1xuICAgIHRyYW5zYWN0aW9uOiBDb25maXJtZWRUcmFuc2FjdGlvbkFjY291bnRzTW9kZVJlc3VsdCxcbiAgICBtZXRhOiBudWxsYWJsZShQYXJzZWRDb25maXJtZWRUcmFuc2FjdGlvbk1ldGFSZXN1bHQpLFxuICAgIHZlcnNpb246IG9wdGlvbmFsKFRyYW5zYWN0aW9uVmVyc2lvblN0cnVjdClcbiAgfSkpLFxuICByZXdhcmRzOiBvcHRpb25hbChhcnJheShSZXdhcmRzUmVzdWx0KSksXG4gIGJsb2NrVGltZTogbnVsbGFibGUobnVtYmVyKCkpLFxuICBibG9ja0hlaWdodDogbnVsbGFibGUobnVtYmVyKCkpXG59KSkpO1xuXG4vKipcbiAqIEV4cGVjdGVkIHBhcnNlZCBKU09OIFJQQyByZXNwb25zZSBmb3IgdGhlIFwiZ2V0QmxvY2tcIiBtZXNzYWdlICB3aGVuIGB0cmFuc2FjdGlvbkRldGFpbHNgIGlzIGBub25lYFxuICovXG5jb25zdCBHZXRQYXJzZWROb25lTW9kZUJsb2NrUnBjUmVzdWx0ID0ganNvblJwY1Jlc3VsdChudWxsYWJsZSh0eXBlKHtcbiAgYmxvY2toYXNoOiBzdHJpbmcoKSxcbiAgcHJldmlvdXNCbG9ja2hhc2g6IHN0cmluZygpLFxuICBwYXJlbnRTbG90OiBudW1iZXIoKSxcbiAgcmV3YXJkczogb3B0aW9uYWwoYXJyYXkoUmV3YXJkc1Jlc3VsdCkpLFxuICBibG9ja1RpbWU6IG51bGxhYmxlKG51bWJlcigpKSxcbiAgYmxvY2tIZWlnaHQ6IG51bGxhYmxlKG51bWJlcigpKVxufSkpKTtcblxuLyoqXG4gKiBFeHBlY3RlZCBKU09OIFJQQyByZXNwb25zZSBmb3IgdGhlIFwiZ2V0Q29uZmlybWVkQmxvY2tcIiBtZXNzYWdlXG4gKlxuICogQGRlcHJlY2F0ZWQgRGVwcmVjYXRlZCBzaW5jZSBTb2xhbmEgdjEuOC4wLiBQbGVhc2UgdXNlIHtAbGluayBHZXRCbG9ja1JwY1Jlc3VsdH0gaW5zdGVhZC5cbiAqL1xuY29uc3QgR2V0Q29uZmlybWVkQmxvY2tScGNSZXN1bHQgPSBqc29uUnBjUmVzdWx0KG51bGxhYmxlKHR5cGUoe1xuICBibG9ja2hhc2g6IHN0cmluZygpLFxuICBwcmV2aW91c0Jsb2NraGFzaDogc3RyaW5nKCksXG4gIHBhcmVudFNsb3Q6IG51bWJlcigpLFxuICB0cmFuc2FjdGlvbnM6IGFycmF5KHR5cGUoe1xuICAgIHRyYW5zYWN0aW9uOiBDb25maXJtZWRUcmFuc2FjdGlvblJlc3VsdCxcbiAgICBtZXRhOiBudWxsYWJsZShDb25maXJtZWRUcmFuc2FjdGlvbk1ldGFSZXN1bHQpXG4gIH0pKSxcbiAgcmV3YXJkczogb3B0aW9uYWwoYXJyYXkoUmV3YXJkc1Jlc3VsdCkpLFxuICBibG9ja1RpbWU6IG51bGxhYmxlKG51bWJlcigpKVxufSkpKTtcblxuLyoqXG4gKiBFeHBlY3RlZCBKU09OIFJQQyByZXNwb25zZSBmb3IgdGhlIFwiZ2V0QmxvY2tcIiBtZXNzYWdlXG4gKi9cbmNvbnN0IEdldEJsb2NrU2lnbmF0dXJlc1JwY1Jlc3VsdCA9IGpzb25ScGNSZXN1bHQobnVsbGFibGUodHlwZSh7XG4gIGJsb2NraGFzaDogc3RyaW5nKCksXG4gIHByZXZpb3VzQmxvY2toYXNoOiBzdHJpbmcoKSxcbiAgcGFyZW50U2xvdDogbnVtYmVyKCksXG4gIHNpZ25hdHVyZXM6IGFycmF5KHN0cmluZygpKSxcbiAgYmxvY2tUaW1lOiBudWxsYWJsZShudW1iZXIoKSlcbn0pKSk7XG5cbi8qKlxuICogRXhwZWN0ZWQgSlNPTiBSUEMgcmVzcG9uc2UgZm9yIHRoZSBcImdldFRyYW5zYWN0aW9uXCIgbWVzc2FnZVxuICovXG5jb25zdCBHZXRUcmFuc2FjdGlvblJwY1Jlc3VsdCA9IGpzb25ScGNSZXN1bHQobnVsbGFibGUodHlwZSh7XG4gIHNsb3Q6IG51bWJlcigpLFxuICBtZXRhOiBudWxsYWJsZShDb25maXJtZWRUcmFuc2FjdGlvbk1ldGFSZXN1bHQpLFxuICBibG9ja1RpbWU6IG9wdGlvbmFsKG51bGxhYmxlKG51bWJlcigpKSksXG4gIHRyYW5zYWN0aW9uOiBDb25maXJtZWRUcmFuc2FjdGlvblJlc3VsdCxcbiAgdmVyc2lvbjogb3B0aW9uYWwoVHJhbnNhY3Rpb25WZXJzaW9uU3RydWN0KVxufSkpKTtcblxuLyoqXG4gKiBFeHBlY3RlZCBwYXJzZWQgSlNPTiBSUEMgcmVzcG9uc2UgZm9yIHRoZSBcImdldFRyYW5zYWN0aW9uXCIgbWVzc2FnZVxuICovXG5jb25zdCBHZXRQYXJzZWRUcmFuc2FjdGlvblJwY1Jlc3VsdCA9IGpzb25ScGNSZXN1bHQobnVsbGFibGUodHlwZSh7XG4gIHNsb3Q6IG51bWJlcigpLFxuICB0cmFuc2FjdGlvbjogUGFyc2VkQ29uZmlybWVkVHJhbnNhY3Rpb25SZXN1bHQsXG4gIG1ldGE6IG51bGxhYmxlKFBhcnNlZENvbmZpcm1lZFRyYW5zYWN0aW9uTWV0YVJlc3VsdCksXG4gIGJsb2NrVGltZTogb3B0aW9uYWwobnVsbGFibGUobnVtYmVyKCkpKSxcbiAgdmVyc2lvbjogb3B0aW9uYWwoVHJhbnNhY3Rpb25WZXJzaW9uU3RydWN0KVxufSkpKTtcblxuLyoqXG4gKiBFeHBlY3RlZCBKU09OIFJQQyByZXNwb25zZSBmb3IgdGhlIFwiZ2V0UmVjZW50QmxvY2toYXNoXCIgbWVzc2FnZVxuICpcbiAqIEBkZXByZWNhdGVkIERlcHJlY2F0ZWQgc2luY2UgU29sYW5hIHYxLjguMC4gUGxlYXNlIHVzZSB7QGxpbmsgR2V0TGF0ZXN0QmxvY2toYXNoUnBjUmVzdWx0fSBpbnN0ZWFkLlxuICovXG5jb25zdCBHZXRSZWNlbnRCbG9ja2hhc2hBbmRDb250ZXh0UnBjUmVzdWx0ID0ganNvblJwY1Jlc3VsdEFuZENvbnRleHQodHlwZSh7XG4gIGJsb2NraGFzaDogc3RyaW5nKCksXG4gIGZlZUNhbGN1bGF0b3I6IHR5cGUoe1xuICAgIGxhbXBvcnRzUGVyU2lnbmF0dXJlOiBudW1iZXIoKVxuICB9KVxufSkpO1xuXG4vKipcbiAqIEV4cGVjdGVkIEpTT04gUlBDIHJlc3BvbnNlIGZvciB0aGUgXCJnZXRMYXRlc3RCbG9ja2hhc2hcIiBtZXNzYWdlXG4gKi9cbmNvbnN0IEdldExhdGVzdEJsb2NraGFzaFJwY1Jlc3VsdCA9IGpzb25ScGNSZXN1bHRBbmRDb250ZXh0KHR5cGUoe1xuICBibG9ja2hhc2g6IHN0cmluZygpLFxuICBsYXN0VmFsaWRCbG9ja0hlaWdodDogbnVtYmVyKClcbn0pKTtcblxuLyoqXG4gKiBFeHBlY3RlZCBKU09OIFJQQyByZXNwb25zZSBmb3IgdGhlIFwiaXNCbG9ja2hhc2hWYWxpZFwiIG1lc3NhZ2VcbiAqL1xuY29uc3QgSXNCbG9ja2hhc2hWYWxpZFJwY1Jlc3VsdCA9IGpzb25ScGNSZXN1bHRBbmRDb250ZXh0KGJvb2xlYW4oKSk7XG5jb25zdCBQZXJmU2FtcGxlUmVzdWx0ID0gdHlwZSh7XG4gIHNsb3Q6IG51bWJlcigpLFxuICBudW1UcmFuc2FjdGlvbnM6IG51bWJlcigpLFxuICBudW1TbG90czogbnVtYmVyKCksXG4gIHNhbXBsZVBlcmlvZFNlY3M6IG51bWJlcigpXG59KTtcblxuLypcbiAqIEV4cGVjdGVkIEpTT04gUlBDIHJlc3BvbnNlIGZvciBcImdldFJlY2VudFBlcmZvcm1hbmNlU2FtcGxlc1wiIG1lc3NhZ2VcbiAqL1xuY29uc3QgR2V0UmVjZW50UGVyZm9ybWFuY2VTYW1wbGVzUnBjUmVzdWx0ID0ganNvblJwY1Jlc3VsdChhcnJheShQZXJmU2FtcGxlUmVzdWx0KSk7XG5cbi8qKlxuICogRXhwZWN0ZWQgSlNPTiBSUEMgcmVzcG9uc2UgZm9yIHRoZSBcImdldEZlZUNhbGN1bGF0b3JGb3JCbG9ja2hhc2hcIiBtZXNzYWdlXG4gKi9cbmNvbnN0IEdldEZlZUNhbGN1bGF0b3JScGNSZXN1bHQgPSBqc29uUnBjUmVzdWx0QW5kQ29udGV4dChudWxsYWJsZSh0eXBlKHtcbiAgZmVlQ2FsY3VsYXRvcjogdHlwZSh7XG4gICAgbGFtcG9ydHNQZXJTaWduYXR1cmU6IG51bWJlcigpXG4gIH0pXG59KSkpO1xuXG4vKipcbiAqIEV4cGVjdGVkIEpTT04gUlBDIHJlc3BvbnNlIGZvciB0aGUgXCJyZXF1ZXN0QWlyZHJvcFwiIG1lc3NhZ2VcbiAqL1xuY29uc3QgUmVxdWVzdEFpcmRyb3BScGNSZXN1bHQgPSBqc29uUnBjUmVzdWx0KHN0cmluZygpKTtcblxuLyoqXG4gKiBFeHBlY3RlZCBKU09OIFJQQyByZXNwb25zZSBmb3IgdGhlIFwic2VuZFRyYW5zYWN0aW9uXCIgbWVzc2FnZVxuICovXG5jb25zdCBTZW5kVHJhbnNhY3Rpb25ScGNSZXN1bHQgPSBqc29uUnBjUmVzdWx0KHN0cmluZygpKTtcblxuLyoqXG4gKiBJbmZvcm1hdGlvbiBhYm91dCB0aGUgbGF0ZXN0IHNsb3QgYmVpbmcgcHJvY2Vzc2VkIGJ5IGEgbm9kZVxuICovXG5cbi8qKlxuICogUGFyc2VkIGFjY291bnQgZGF0YVxuICovXG5cbi8qKlxuICogU3Rha2UgQWN0aXZhdGlvbiBkYXRhXG4gKi9cblxuLyoqXG4gKiBEYXRhIHNsaWNlIGFyZ3VtZW50IGZvciBnZXRQcm9ncmFtQWNjb3VudHNcbiAqL1xuXG4vKipcbiAqIE1lbW9yeSBjb21wYXJpc29uIGZpbHRlciBmb3IgZ2V0UHJvZ3JhbUFjY291bnRzXG4gKi9cblxuLyoqXG4gKiBEYXRhIHNpemUgY29tcGFyaXNvbiBmaWx0ZXIgZm9yIGdldFByb2dyYW1BY2NvdW50c1xuICovXG5cbi8qKlxuICogQSBmaWx0ZXIgb2JqZWN0IGZvciBnZXRQcm9ncmFtQWNjb3VudHNcbiAqL1xuXG4vKipcbiAqIENvbmZpZ3VyYXRpb24gb2JqZWN0IGZvciBnZXRQcm9ncmFtQWNjb3VudHMgcmVxdWVzdHNcbiAqL1xuXG4vKipcbiAqIENvbmZpZ3VyYXRpb24gb2JqZWN0IGZvciBnZXRQYXJzZWRQcm9ncmFtQWNjb3VudHNcbiAqL1xuXG4vKipcbiAqIENvbmZpZ3VyYXRpb24gb2JqZWN0IGZvciBnZXRNdWx0aXBsZUFjY291bnRzXG4gKi9cblxuLyoqXG4gKiBDb25maWd1cmF0aW9uIG9iamVjdCBmb3IgYGdldFN0YWtlQWN0aXZhdGlvbmBcbiAqL1xuXG4vKipcbiAqIENvbmZpZ3VyYXRpb24gb2JqZWN0IGZvciBgZ2V0U3Rha2VBY3RpdmF0aW9uYFxuICovXG5cbi8qKlxuICogQ29uZmlndXJhdGlvbiBvYmplY3QgZm9yIGBnZXRTdGFrZUFjdGl2YXRpb25gXG4gKi9cblxuLyoqXG4gKiBDb25maWd1cmF0aW9uIG9iamVjdCBmb3IgYGdldE5vbmNlYFxuICovXG5cbi8qKlxuICogQ29uZmlndXJhdGlvbiBvYmplY3QgZm9yIGBnZXROb25jZUFuZENvbnRleHRgXG4gKi9cblxuLyoqXG4gKiBJbmZvcm1hdGlvbiBkZXNjcmliaW5nIGFuIGFjY291bnRcbiAqL1xuXG4vKipcbiAqIEFjY291bnQgaW5mb3JtYXRpb24gaWRlbnRpZmllZCBieSBwdWJrZXlcbiAqL1xuXG4vKipcbiAqIENhbGxiYWNrIGZ1bmN0aW9uIGZvciBhY2NvdW50IGNoYW5nZSBub3RpZmljYXRpb25zXG4gKi9cblxuLyoqXG4gKiBDYWxsYmFjayBmdW5jdGlvbiBmb3IgcHJvZ3JhbSBhY2NvdW50IGNoYW5nZSBub3RpZmljYXRpb25zXG4gKi9cblxuLyoqXG4gKiBDYWxsYmFjayBmdW5jdGlvbiBmb3Igc2xvdCBjaGFuZ2Ugbm90aWZpY2F0aW9uc1xuICovXG5cbi8qKlxuICogQ2FsbGJhY2sgZnVuY3Rpb24gZm9yIHNsb3QgdXBkYXRlIG5vdGlmaWNhdGlvbnNcbiAqL1xuXG4vKipcbiAqIENhbGxiYWNrIGZ1bmN0aW9uIGZvciBzaWduYXR1cmUgc3RhdHVzIG5vdGlmaWNhdGlvbnNcbiAqL1xuXG4vKipcbiAqIFNpZ25hdHVyZSBzdGF0dXMgbm90aWZpY2F0aW9uIHdpdGggdHJhbnNhY3Rpb24gcmVzdWx0XG4gKi9cblxuLyoqXG4gKiBTaWduYXR1cmUgcmVjZWl2ZWQgbm90aWZpY2F0aW9uXG4gKi9cblxuLyoqXG4gKiBDYWxsYmFjayBmdW5jdGlvbiBmb3Igc2lnbmF0dXJlIG5vdGlmaWNhdGlvbnNcbiAqL1xuXG4vKipcbiAqIFNpZ25hdHVyZSBzdWJzY3JpcHRpb24gb3B0aW9uc1xuICovXG5cbi8qKlxuICogQ2FsbGJhY2sgZnVuY3Rpb24gZm9yIHJvb3QgY2hhbmdlIG5vdGlmaWNhdGlvbnNcbiAqL1xuXG4vKipcbiAqIEBpbnRlcm5hbFxuICovXG5jb25zdCBMb2dzUmVzdWx0ID0gdHlwZSh7XG4gIGVycjogVHJhbnNhY3Rpb25FcnJvclJlc3VsdCxcbiAgbG9nczogYXJyYXkoc3RyaW5nKCkpLFxuICBzaWduYXR1cmU6IHN0cmluZygpXG59KTtcblxuLyoqXG4gKiBMb2dzIHJlc3VsdC5cbiAqL1xuXG4vKipcbiAqIEV4cGVjdGVkIEpTT04gUlBDIHJlc3BvbnNlIGZvciB0aGUgXCJsb2dzTm90aWZpY2F0aW9uXCIgbWVzc2FnZS5cbiAqL1xuY29uc3QgTG9nc05vdGlmaWNhdGlvblJlc3VsdCA9IHR5cGUoe1xuICByZXN1bHQ6IG5vdGlmaWNhdGlvblJlc3VsdEFuZENvbnRleHQoTG9nc1Jlc3VsdCksXG4gIHN1YnNjcmlwdGlvbjogbnVtYmVyKClcbn0pO1xuXG4vKipcbiAqIEZpbHRlciBmb3IgbG9nIHN1YnNjcmlwdGlvbnMuXG4gKi9cblxuLyoqXG4gKiBDYWxsYmFjayBmdW5jdGlvbiBmb3IgbG9nIG5vdGlmaWNhdGlvbnMuXG4gKi9cblxuLyoqXG4gKiBTaWduYXR1cmUgcmVzdWx0XG4gKi9cblxuLyoqXG4gKiBUcmFuc2FjdGlvbiBlcnJvclxuICovXG5cbi8qKlxuICogVHJhbnNhY3Rpb24gY29uZmlybWF0aW9uIHN0YXR1c1xuICogPHByZT5cbiAqICAgJ3Byb2Nlc3NlZCc6IFRyYW5zYWN0aW9uIGxhbmRlZCBpbiBhIGJsb2NrIHdoaWNoIGhhcyByZWFjaGVkIDEgY29uZmlybWF0aW9uIGJ5IHRoZSBjb25uZWN0ZWQgbm9kZVxuICogICAnY29uZmlybWVkJzogVHJhbnNhY3Rpb24gbGFuZGVkIGluIGEgYmxvY2sgd2hpY2ggaGFzIHJlYWNoZWQgMSBjb25maXJtYXRpb24gYnkgdGhlIGNsdXN0ZXJcbiAqICAgJ2ZpbmFsaXplZCc6IFRyYW5zYWN0aW9uIGxhbmRlZCBpbiBhIGJsb2NrIHdoaWNoIGhhcyBiZWVuIGZpbmFsaXplZCBieSB0aGUgY2x1c3RlclxuICogPC9wcmU+XG4gKi9cblxuLyoqXG4gKiBTaWduYXR1cmUgc3RhdHVzXG4gKi9cblxuLyoqXG4gKiBBIGNvbmZpcm1lZCBzaWduYXR1cmUgd2l0aCBpdHMgc3RhdHVzXG4gKi9cblxuLyoqXG4gKiBBbiBvYmplY3QgZGVmaW5pbmcgaGVhZGVycyB0byBiZSBwYXNzZWQgdG8gdGhlIFJQQyBzZXJ2ZXJcbiAqL1xuXG4vKipcbiAqIFRoZSB0eXBlIG9mIHRoZSBKYXZhU2NyaXB0IGBmZXRjaCgpYCBBUElcbiAqL1xuXG4vKipcbiAqIEEgY2FsbGJhY2sgdXNlZCB0byBhdWdtZW50IHRoZSBvdXRnb2luZyBIVFRQIHJlcXVlc3RcbiAqL1xuXG4vKipcbiAqIENvbmZpZ3VyYXRpb24gZm9yIGluc3RhbnRpYXRpbmcgYSBDb25uZWN0aW9uXG4gKi9cblxuLyoqIEBpbnRlcm5hbCAqL1xuY29uc3QgQ09NTU9OX0hUVFBfSEVBREVSUyA9IHtcbiAgJ3NvbGFuYS1jbGllbnQnOiBganMvJHtcIjAuMC4wLWRldmVsb3BtZW50XCIgfWBcbn07XG5cbi8qKlxuICogQSBjb25uZWN0aW9uIHRvIGEgZnVsbG5vZGUgSlNPTiBSUEMgZW5kcG9pbnRcbiAqL1xuY2xhc3MgQ29ubmVjdGlvbiB7XG4gIC8qKlxuICAgKiBFc3RhYmxpc2ggYSBKU09OIFJQQyBjb25uZWN0aW9uXG4gICAqXG4gICAqIEBwYXJhbSBlbmRwb2ludCBVUkwgdG8gdGhlIGZ1bGxub2RlIEpTT04gUlBDIGVuZHBvaW50XG4gICAqIEBwYXJhbSBjb21taXRtZW50T3JDb25maWcgb3B0aW9uYWwgZGVmYXVsdCBjb21taXRtZW50IGxldmVsIG9yIG9wdGlvbmFsIENvbm5lY3Rpb25Db25maWcgY29uZmlndXJhdGlvbiBvYmplY3RcbiAgICovXG4gIGNvbnN0cnVjdG9yKGVuZHBvaW50LCBfY29tbWl0bWVudE9yQ29uZmlnKSB7XG4gICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgIHRoaXMuX2NvbW1pdG1lbnQgPSB2b2lkIDA7XG4gICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgIHRoaXMuX2NvbmZpcm1UcmFuc2FjdGlvbkluaXRpYWxUaW1lb3V0ID0gdm9pZCAwO1xuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICB0aGlzLl9ycGNFbmRwb2ludCA9IHZvaWQgMDtcbiAgICAvKiogQGludGVybmFsICovXG4gICAgdGhpcy5fcnBjV3NFbmRwb2ludCA9IHZvaWQgMDtcbiAgICAvKiogQGludGVybmFsICovXG4gICAgdGhpcy5fcnBjQ2xpZW50ID0gdm9pZCAwO1xuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICB0aGlzLl9ycGNSZXF1ZXN0ID0gdm9pZCAwO1xuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICB0aGlzLl9ycGNCYXRjaFJlcXVlc3QgPSB2b2lkIDA7XG4gICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgIHRoaXMuX3JwY1dlYlNvY2tldCA9IHZvaWQgMDtcbiAgICAvKiogQGludGVybmFsICovXG4gICAgdGhpcy5fcnBjV2ViU29ja2V0Q29ubmVjdGVkID0gZmFsc2U7XG4gICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgIHRoaXMuX3JwY1dlYlNvY2tldEhlYXJ0YmVhdCA9IG51bGw7XG4gICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgIHRoaXMuX3JwY1dlYlNvY2tldElkbGVUaW1lb3V0ID0gbnVsbDtcbiAgICAvKiogQGludGVybmFsXG4gICAgICogQSBudW1iZXIgdGhhdCB3ZSBpbmNyZW1lbnQgZXZlcnkgdGltZSBhbiBhY3RpdmUgY29ubmVjdGlvbiBjbG9zZXMuXG4gICAgICogVXNlZCB0byBkZXRlcm1pbmUgd2hldGhlciB0aGUgc2FtZSBzb2NrZXQgY29ubmVjdGlvbiB0aGF0IHdhcyBvcGVuXG4gICAgICogd2hlbiBhbiBhc3luYyBvcGVyYXRpb24gc3RhcnRlZCBpcyB0aGUgc2FtZSBvbmUgdGhhdCdzIGFjdGl2ZSB3aGVuXG4gICAgICogaXRzIGNvbnRpbnVhdGlvbiBmaXJlcy5cbiAgICAgKlxuICAgICAqL1xuICAgIHRoaXMuX3JwY1dlYlNvY2tldEdlbmVyYXRpb24gPSAwO1xuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICB0aGlzLl9kaXNhYmxlQmxvY2toYXNoQ2FjaGluZyA9IGZhbHNlO1xuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICB0aGlzLl9wb2xsaW5nQmxvY2toYXNoID0gZmFsc2U7XG4gICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgIHRoaXMuX2Jsb2NraGFzaEluZm8gPSB7XG4gICAgICBsYXRlc3RCbG9ja2hhc2g6IG51bGwsXG4gICAgICBsYXN0RmV0Y2g6IDAsXG4gICAgICB0cmFuc2FjdGlvblNpZ25hdHVyZXM6IFtdLFxuICAgICAgc2ltdWxhdGVkU2lnbmF0dXJlczogW11cbiAgICB9O1xuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICB0aGlzLl9uZXh0Q2xpZW50U3Vic2NyaXB0aW9uSWQgPSAwO1xuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICB0aGlzLl9zdWJzY3JpcHRpb25EaXNwb3NlRnVuY3Rpb25zQnlDbGllbnRTdWJzY3JpcHRpb25JZCA9IHt9O1xuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICB0aGlzLl9zdWJzY3JpcHRpb25IYXNoQnlDbGllbnRTdWJzY3JpcHRpb25JZCA9IHt9O1xuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICB0aGlzLl9zdWJzY3JpcHRpb25TdGF0ZUNoYW5nZUNhbGxiYWNrc0J5SGFzaCA9IHt9O1xuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICB0aGlzLl9zdWJzY3JpcHRpb25DYWxsYmFja3NCeVNlcnZlclN1YnNjcmlwdGlvbklkID0ge307XG4gICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgIHRoaXMuX3N1YnNjcmlwdGlvbnNCeUhhc2ggPSB7fTtcbiAgICAvKipcbiAgICAgKiBTcGVjaWFsIGNhc2UuXG4gICAgICogQWZ0ZXIgYSBzaWduYXR1cmUgaXMgcHJvY2Vzc2VkLCBSUENzIGF1dG9tYXRpY2FsbHkgZGlzcG9zZSBvZiB0aGVcbiAgICAgKiBzdWJzY3JpcHRpb24gb24gdGhlIHNlcnZlciBzaWRlLiBXZSBuZWVkIHRvIHRyYWNrIHdoaWNoIG9mIHRoZXNlXG4gICAgICogc3Vic2NyaXB0aW9ucyBoYXZlIGJlZW4gZGlzcG9zZWQgaW4gc3VjaCBhIHdheSwgc28gdGhhdCB3ZSBrbm93XG4gICAgICogd2hldGhlciB0aGUgY2xpZW50IGlzIGRlYWxpbmcgd2l0aCBhIG5vdC15ZXQtcHJvY2Vzc2VkIHNpZ25hdHVyZVxuICAgICAqIChpbiB3aGljaCBjYXNlIHdlIG11c3QgdGVhciBkb3duIHRoZSBzZXJ2ZXIgc3Vic2NyaXB0aW9uKSBvciBhblxuICAgICAqIGFscmVhZHktcHJvY2Vzc2VkIHNpZ25hdHVyZSAoaW4gd2hpY2ggY2FzZSB0aGUgY2xpZW50IGNhbiBzaW1wbHlcbiAgICAgKiBjbGVhciBvdXQgdGhlIHN1YnNjcmlwdGlvbiBsb2NhbGx5IHdpdGhvdXQgdGVsbGluZyB0aGUgc2VydmVyKS5cbiAgICAgKlxuICAgICAqIE5PVEU6IFRoZXJlIGlzIGEgcHJvcG9zYWwgdG8gZWxpbWluYXRlIHRoaXMgc3BlY2lhbCBjYXNlLCBoZXJlOlxuICAgICAqIGh0dHBzOi8vZ2l0aHViLmNvbS9zb2xhbmEtbGFicy9zb2xhbmEvaXNzdWVzLzE4ODkyXG4gICAgICovXG4gICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgIHRoaXMuX3N1YnNjcmlwdGlvbnNBdXRvRGlzcG9zZWRCeVJwYyA9IG5ldyBTZXQoKTtcbiAgICAvKlxuICAgICAqIFJldHVybnMgdGhlIGN1cnJlbnQgYmxvY2sgaGVpZ2h0IG9mIHRoZSBub2RlXG4gICAgICovXG4gICAgdGhpcy5nZXRCbG9ja0hlaWdodCA9ICgoKSA9PiB7XG4gICAgICBjb25zdCByZXF1ZXN0UHJvbWlzZXMgPSB7fTtcbiAgICAgIHJldHVybiBhc3luYyBjb21taXRtZW50T3JDb25maWcgPT4ge1xuICAgICAgICBjb25zdCB7XG4gICAgICAgICAgY29tbWl0bWVudCxcbiAgICAgICAgICBjb25maWdcbiAgICAgICAgfSA9IGV4dHJhY3RDb21taXRtZW50RnJvbUNvbmZpZyhjb21taXRtZW50T3JDb25maWcpO1xuICAgICAgICBjb25zdCBhcmdzID0gdGhpcy5fYnVpbGRBcmdzKFtdLCBjb21taXRtZW50LCB1bmRlZmluZWQgLyogZW5jb2RpbmcgKi8sIGNvbmZpZyk7XG4gICAgICAgIGNvbnN0IHJlcXVlc3RIYXNoID0gZmFzdFN0YWJsZVN0cmluZ2lmeSQxKGFyZ3MpO1xuICAgICAgICByZXF1ZXN0UHJvbWlzZXNbcmVxdWVzdEhhc2hdID0gcmVxdWVzdFByb21pc2VzW3JlcXVlc3RIYXNoXSA/PyAoYXN5bmMgKCkgPT4ge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCB1bnNhZmVSZXMgPSBhd2FpdCB0aGlzLl9ycGNSZXF1ZXN0KCdnZXRCbG9ja0hlaWdodCcsIGFyZ3MpO1xuICAgICAgICAgICAgY29uc3QgcmVzID0gY3JlYXRlKHVuc2FmZVJlcywganNvblJwY1Jlc3VsdChudW1iZXIoKSkpO1xuICAgICAgICAgICAgaWYgKCdlcnJvcicgaW4gcmVzKSB7XG4gICAgICAgICAgICAgIHRocm93IG5ldyBTb2xhbmFKU09OUlBDRXJyb3IocmVzLmVycm9yLCAnZmFpbGVkIHRvIGdldCBibG9jayBoZWlnaHQgaW5mb3JtYXRpb24nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXMucmVzdWx0O1xuICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICBkZWxldGUgcmVxdWVzdFByb21pc2VzW3JlcXVlc3RIYXNoXTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pKCk7XG4gICAgICAgIHJldHVybiBhd2FpdCByZXF1ZXN0UHJvbWlzZXNbcmVxdWVzdEhhc2hdO1xuICAgICAgfTtcbiAgICB9KSgpO1xuICAgIGxldCB3c0VuZHBvaW50O1xuICAgIGxldCBodHRwSGVhZGVycztcbiAgICBsZXQgZmV0Y2g7XG4gICAgbGV0IGZldGNoTWlkZGxld2FyZTtcbiAgICBsZXQgZGlzYWJsZVJldHJ5T25SYXRlTGltaXQ7XG4gICAgbGV0IGh0dHBBZ2VudDtcbiAgICBpZiAoX2NvbW1pdG1lbnRPckNvbmZpZyAmJiB0eXBlb2YgX2NvbW1pdG1lbnRPckNvbmZpZyA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHRoaXMuX2NvbW1pdG1lbnQgPSBfY29tbWl0bWVudE9yQ29uZmlnO1xuICAgIH0gZWxzZSBpZiAoX2NvbW1pdG1lbnRPckNvbmZpZykge1xuICAgICAgdGhpcy5fY29tbWl0bWVudCA9IF9jb21taXRtZW50T3JDb25maWcuY29tbWl0bWVudDtcbiAgICAgIHRoaXMuX2NvbmZpcm1UcmFuc2FjdGlvbkluaXRpYWxUaW1lb3V0ID0gX2NvbW1pdG1lbnRPckNvbmZpZy5jb25maXJtVHJhbnNhY3Rpb25Jbml0aWFsVGltZW91dDtcbiAgICAgIHdzRW5kcG9pbnQgPSBfY29tbWl0bWVudE9yQ29uZmlnLndzRW5kcG9pbnQ7XG4gICAgICBodHRwSGVhZGVycyA9IF9jb21taXRtZW50T3JDb25maWcuaHR0cEhlYWRlcnM7XG4gICAgICBmZXRjaCA9IF9jb21taXRtZW50T3JDb25maWcuZmV0Y2g7XG4gICAgICBmZXRjaE1pZGRsZXdhcmUgPSBfY29tbWl0bWVudE9yQ29uZmlnLmZldGNoTWlkZGxld2FyZTtcbiAgICAgIGRpc2FibGVSZXRyeU9uUmF0ZUxpbWl0ID0gX2NvbW1pdG1lbnRPckNvbmZpZy5kaXNhYmxlUmV0cnlPblJhdGVMaW1pdDtcbiAgICAgIGh0dHBBZ2VudCA9IF9jb21taXRtZW50T3JDb25maWcuaHR0cEFnZW50O1xuICAgIH1cbiAgICB0aGlzLl9ycGNFbmRwb2ludCA9IGFzc2VydEVuZHBvaW50VXJsKGVuZHBvaW50KTtcbiAgICB0aGlzLl9ycGNXc0VuZHBvaW50ID0gd3NFbmRwb2ludCB8fCBtYWtlV2Vic29ja2V0VXJsKGVuZHBvaW50KTtcbiAgICB0aGlzLl9ycGNDbGllbnQgPSBjcmVhdGVScGNDbGllbnQoZW5kcG9pbnQsIGh0dHBIZWFkZXJzLCBmZXRjaCwgZmV0Y2hNaWRkbGV3YXJlLCBkaXNhYmxlUmV0cnlPblJhdGVMaW1pdCwgaHR0cEFnZW50KTtcbiAgICB0aGlzLl9ycGNSZXF1ZXN0ID0gY3JlYXRlUnBjUmVxdWVzdCh0aGlzLl9ycGNDbGllbnQpO1xuICAgIHRoaXMuX3JwY0JhdGNoUmVxdWVzdCA9IGNyZWF0ZVJwY0JhdGNoUmVxdWVzdCh0aGlzLl9ycGNDbGllbnQpO1xuICAgIHRoaXMuX3JwY1dlYlNvY2tldCA9IG5ldyBScGNXZWJTb2NrZXRDbGllbnQodGhpcy5fcnBjV3NFbmRwb2ludCwge1xuICAgICAgYXV0b2Nvbm5lY3Q6IGZhbHNlLFxuICAgICAgbWF4X3JlY29ubmVjdHM6IEluZmluaXR5XG4gICAgfSk7XG4gICAgdGhpcy5fcnBjV2ViU29ja2V0Lm9uKCdvcGVuJywgdGhpcy5fd3NPbk9wZW4uYmluZCh0aGlzKSk7XG4gICAgdGhpcy5fcnBjV2ViU29ja2V0Lm9uKCdlcnJvcicsIHRoaXMuX3dzT25FcnJvci5iaW5kKHRoaXMpKTtcbiAgICB0aGlzLl9ycGNXZWJTb2NrZXQub24oJ2Nsb3NlJywgdGhpcy5fd3NPbkNsb3NlLmJpbmQodGhpcykpO1xuICAgIHRoaXMuX3JwY1dlYlNvY2tldC5vbignYWNjb3VudE5vdGlmaWNhdGlvbicsIHRoaXMuX3dzT25BY2NvdW50Tm90aWZpY2F0aW9uLmJpbmQodGhpcykpO1xuICAgIHRoaXMuX3JwY1dlYlNvY2tldC5vbigncHJvZ3JhbU5vdGlmaWNhdGlvbicsIHRoaXMuX3dzT25Qcm9ncmFtQWNjb3VudE5vdGlmaWNhdGlvbi5iaW5kKHRoaXMpKTtcbiAgICB0aGlzLl9ycGNXZWJTb2NrZXQub24oJ3Nsb3ROb3RpZmljYXRpb24nLCB0aGlzLl93c09uU2xvdE5vdGlmaWNhdGlvbi5iaW5kKHRoaXMpKTtcbiAgICB0aGlzLl9ycGNXZWJTb2NrZXQub24oJ3Nsb3RzVXBkYXRlc05vdGlmaWNhdGlvbicsIHRoaXMuX3dzT25TbG90VXBkYXRlc05vdGlmaWNhdGlvbi5iaW5kKHRoaXMpKTtcbiAgICB0aGlzLl9ycGNXZWJTb2NrZXQub24oJ3NpZ25hdHVyZU5vdGlmaWNhdGlvbicsIHRoaXMuX3dzT25TaWduYXR1cmVOb3RpZmljYXRpb24uYmluZCh0aGlzKSk7XG4gICAgdGhpcy5fcnBjV2ViU29ja2V0Lm9uKCdyb290Tm90aWZpY2F0aW9uJywgdGhpcy5fd3NPblJvb3ROb3RpZmljYXRpb24uYmluZCh0aGlzKSk7XG4gICAgdGhpcy5fcnBjV2ViU29ja2V0Lm9uKCdsb2dzTm90aWZpY2F0aW9uJywgdGhpcy5fd3NPbkxvZ3NOb3RpZmljYXRpb24uYmluZCh0aGlzKSk7XG4gIH1cblxuICAvKipcbiAgICogVGhlIGRlZmF1bHQgY29tbWl0bWVudCB1c2VkIGZvciByZXF1ZXN0c1xuICAgKi9cbiAgZ2V0IGNvbW1pdG1lbnQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2NvbW1pdG1lbnQ7XG4gIH1cblxuICAvKipcbiAgICogVGhlIFJQQyBlbmRwb2ludFxuICAgKi9cbiAgZ2V0IHJwY0VuZHBvaW50KCkge1xuICAgIHJldHVybiB0aGlzLl9ycGNFbmRwb2ludDtcbiAgfVxuXG4gIC8qKlxuICAgKiBGZXRjaCB0aGUgYmFsYW5jZSBmb3IgdGhlIHNwZWNpZmllZCBwdWJsaWMga2V5LCByZXR1cm4gd2l0aCBjb250ZXh0XG4gICAqL1xuICBhc3luYyBnZXRCYWxhbmNlQW5kQ29udGV4dChwdWJsaWNLZXksIGNvbW1pdG1lbnRPckNvbmZpZykge1xuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICBjb25zdCB7XG4gICAgICBjb21taXRtZW50LFxuICAgICAgY29uZmlnXG4gICAgfSA9IGV4dHJhY3RDb21taXRtZW50RnJvbUNvbmZpZyhjb21taXRtZW50T3JDb25maWcpO1xuICAgIGNvbnN0IGFyZ3MgPSB0aGlzLl9idWlsZEFyZ3MoW3B1YmxpY0tleS50b0Jhc2U1OCgpXSwgY29tbWl0bWVudCwgdW5kZWZpbmVkIC8qIGVuY29kaW5nICovLCBjb25maWcpO1xuICAgIGNvbnN0IHVuc2FmZVJlcyA9IGF3YWl0IHRoaXMuX3JwY1JlcXVlc3QoJ2dldEJhbGFuY2UnLCBhcmdzKTtcbiAgICBjb25zdCByZXMgPSBjcmVhdGUodW5zYWZlUmVzLCBqc29uUnBjUmVzdWx0QW5kQ29udGV4dChudW1iZXIoKSkpO1xuICAgIGlmICgnZXJyb3InIGluIHJlcykge1xuICAgICAgdGhyb3cgbmV3IFNvbGFuYUpTT05SUENFcnJvcihyZXMuZXJyb3IsIGBmYWlsZWQgdG8gZ2V0IGJhbGFuY2UgZm9yICR7cHVibGljS2V5LnRvQmFzZTU4KCl9YCk7XG4gICAgfVxuICAgIHJldHVybiByZXMucmVzdWx0O1xuICB9XG5cbiAgLyoqXG4gICAqIEZldGNoIHRoZSBiYWxhbmNlIGZvciB0aGUgc3BlY2lmaWVkIHB1YmxpYyBrZXlcbiAgICovXG4gIGFzeW5jIGdldEJhbGFuY2UocHVibGljS2V5LCBjb21taXRtZW50T3JDb25maWcpIHtcbiAgICByZXR1cm4gYXdhaXQgdGhpcy5nZXRCYWxhbmNlQW5kQ29udGV4dChwdWJsaWNLZXksIGNvbW1pdG1lbnRPckNvbmZpZykudGhlbih4ID0+IHgudmFsdWUpLmNhdGNoKGUgPT4ge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdmYWlsZWQgdG8gZ2V0IGJhbGFuY2Ugb2YgYWNjb3VudCAnICsgcHVibGljS2V5LnRvQmFzZTU4KCkgKyAnOiAnICsgZSk7XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogRmV0Y2ggdGhlIGVzdGltYXRlZCBwcm9kdWN0aW9uIHRpbWUgb2YgYSBibG9ja1xuICAgKi9cbiAgYXN5bmMgZ2V0QmxvY2tUaW1lKHNsb3QpIHtcbiAgICBjb25zdCB1bnNhZmVSZXMgPSBhd2FpdCB0aGlzLl9ycGNSZXF1ZXN0KCdnZXRCbG9ja1RpbWUnLCBbc2xvdF0pO1xuICAgIGNvbnN0IHJlcyA9IGNyZWF0ZSh1bnNhZmVSZXMsIGpzb25ScGNSZXN1bHQobnVsbGFibGUobnVtYmVyKCkpKSk7XG4gICAgaWYgKCdlcnJvcicgaW4gcmVzKSB7XG4gICAgICB0aHJvdyBuZXcgU29sYW5hSlNPTlJQQ0Vycm9yKHJlcy5lcnJvciwgYGZhaWxlZCB0byBnZXQgYmxvY2sgdGltZSBmb3Igc2xvdCAke3Nsb3R9YCk7XG4gICAgfVxuICAgIHJldHVybiByZXMucmVzdWx0O1xuICB9XG5cbiAgLyoqXG4gICAqIEZldGNoIHRoZSBsb3dlc3Qgc2xvdCB0aGF0IHRoZSBub2RlIGhhcyBpbmZvcm1hdGlvbiBhYm91dCBpbiBpdHMgbGVkZ2VyLlxuICAgKiBUaGlzIHZhbHVlIG1heSBpbmNyZWFzZSBvdmVyIHRpbWUgaWYgdGhlIG5vZGUgaXMgY29uZmlndXJlZCB0byBwdXJnZSBvbGRlciBsZWRnZXIgZGF0YVxuICAgKi9cbiAgYXN5bmMgZ2V0TWluaW11bUxlZGdlclNsb3QoKSB7XG4gICAgY29uc3QgdW5zYWZlUmVzID0gYXdhaXQgdGhpcy5fcnBjUmVxdWVzdCgnbWluaW11bUxlZGdlclNsb3QnLCBbXSk7XG4gICAgY29uc3QgcmVzID0gY3JlYXRlKHVuc2FmZVJlcywganNvblJwY1Jlc3VsdChudW1iZXIoKSkpO1xuICAgIGlmICgnZXJyb3InIGluIHJlcykge1xuICAgICAgdGhyb3cgbmV3IFNvbGFuYUpTT05SUENFcnJvcihyZXMuZXJyb3IsICdmYWlsZWQgdG8gZ2V0IG1pbmltdW0gbGVkZ2VyIHNsb3QnKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlcy5yZXN1bHQ7XG4gIH1cblxuICAvKipcbiAgICogRmV0Y2ggdGhlIHNsb3Qgb2YgdGhlIGxvd2VzdCBjb25maXJtZWQgYmxvY2sgdGhhdCBoYXMgbm90IGJlZW4gcHVyZ2VkIGZyb20gdGhlIGxlZGdlclxuICAgKi9cbiAgYXN5bmMgZ2V0Rmlyc3RBdmFpbGFibGVCbG9jaygpIHtcbiAgICBjb25zdCB1bnNhZmVSZXMgPSBhd2FpdCB0aGlzLl9ycGNSZXF1ZXN0KCdnZXRGaXJzdEF2YWlsYWJsZUJsb2NrJywgW10pO1xuICAgIGNvbnN0IHJlcyA9IGNyZWF0ZSh1bnNhZmVSZXMsIFNsb3RScGNSZXN1bHQpO1xuICAgIGlmICgnZXJyb3InIGluIHJlcykge1xuICAgICAgdGhyb3cgbmV3IFNvbGFuYUpTT05SUENFcnJvcihyZXMuZXJyb3IsICdmYWlsZWQgdG8gZ2V0IGZpcnN0IGF2YWlsYWJsZSBibG9jaycpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzLnJlc3VsdDtcbiAgfVxuXG4gIC8qKlxuICAgKiBGZXRjaCBpbmZvcm1hdGlvbiBhYm91dCB0aGUgY3VycmVudCBzdXBwbHlcbiAgICovXG4gIGFzeW5jIGdldFN1cHBseShjb25maWcpIHtcbiAgICBsZXQgY29uZmlnQXJnID0ge307XG4gICAgaWYgKHR5cGVvZiBjb25maWcgPT09ICdzdHJpbmcnKSB7XG4gICAgICBjb25maWdBcmcgPSB7XG4gICAgICAgIGNvbW1pdG1lbnQ6IGNvbmZpZ1xuICAgICAgfTtcbiAgICB9IGVsc2UgaWYgKGNvbmZpZykge1xuICAgICAgY29uZmlnQXJnID0ge1xuICAgICAgICAuLi5jb25maWcsXG4gICAgICAgIGNvbW1pdG1lbnQ6IGNvbmZpZyAmJiBjb25maWcuY29tbWl0bWVudCB8fCB0aGlzLmNvbW1pdG1lbnRcbiAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbmZpZ0FyZyA9IHtcbiAgICAgICAgY29tbWl0bWVudDogdGhpcy5jb21taXRtZW50XG4gICAgICB9O1xuICAgIH1cbiAgICBjb25zdCB1bnNhZmVSZXMgPSBhd2FpdCB0aGlzLl9ycGNSZXF1ZXN0KCdnZXRTdXBwbHknLCBbY29uZmlnQXJnXSk7XG4gICAgY29uc3QgcmVzID0gY3JlYXRlKHVuc2FmZVJlcywgR2V0U3VwcGx5UnBjUmVzdWx0KTtcbiAgICBpZiAoJ2Vycm9yJyBpbiByZXMpIHtcbiAgICAgIHRocm93IG5ldyBTb2xhbmFKU09OUlBDRXJyb3IocmVzLmVycm9yLCAnZmFpbGVkIHRvIGdldCBzdXBwbHknKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlcy5yZXN1bHQ7XG4gIH1cblxuICAvKipcbiAgICogRmV0Y2ggdGhlIGN1cnJlbnQgc3VwcGx5IG9mIGEgdG9rZW4gbWludFxuICAgKi9cbiAgYXN5bmMgZ2V0VG9rZW5TdXBwbHkodG9rZW5NaW50QWRkcmVzcywgY29tbWl0bWVudCkge1xuICAgIGNvbnN0IGFyZ3MgPSB0aGlzLl9idWlsZEFyZ3MoW3Rva2VuTWludEFkZHJlc3MudG9CYXNlNTgoKV0sIGNvbW1pdG1lbnQpO1xuICAgIGNvbnN0IHVuc2FmZVJlcyA9IGF3YWl0IHRoaXMuX3JwY1JlcXVlc3QoJ2dldFRva2VuU3VwcGx5JywgYXJncyk7XG4gICAgY29uc3QgcmVzID0gY3JlYXRlKHVuc2FmZVJlcywganNvblJwY1Jlc3VsdEFuZENvbnRleHQoVG9rZW5BbW91bnRSZXN1bHQpKTtcbiAgICBpZiAoJ2Vycm9yJyBpbiByZXMpIHtcbiAgICAgIHRocm93IG5ldyBTb2xhbmFKU09OUlBDRXJyb3IocmVzLmVycm9yLCAnZmFpbGVkIHRvIGdldCB0b2tlbiBzdXBwbHknKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlcy5yZXN1bHQ7XG4gIH1cblxuICAvKipcbiAgICogRmV0Y2ggdGhlIGN1cnJlbnQgYmFsYW5jZSBvZiBhIHRva2VuIGFjY291bnRcbiAgICovXG4gIGFzeW5jIGdldFRva2VuQWNjb3VudEJhbGFuY2UodG9rZW5BZGRyZXNzLCBjb21taXRtZW50KSB7XG4gICAgY29uc3QgYXJncyA9IHRoaXMuX2J1aWxkQXJncyhbdG9rZW5BZGRyZXNzLnRvQmFzZTU4KCldLCBjb21taXRtZW50KTtcbiAgICBjb25zdCB1bnNhZmVSZXMgPSBhd2FpdCB0aGlzLl9ycGNSZXF1ZXN0KCdnZXRUb2tlbkFjY291bnRCYWxhbmNlJywgYXJncyk7XG4gICAgY29uc3QgcmVzID0gY3JlYXRlKHVuc2FmZVJlcywganNvblJwY1Jlc3VsdEFuZENvbnRleHQoVG9rZW5BbW91bnRSZXN1bHQpKTtcbiAgICBpZiAoJ2Vycm9yJyBpbiByZXMpIHtcbiAgICAgIHRocm93IG5ldyBTb2xhbmFKU09OUlBDRXJyb3IocmVzLmVycm9yLCAnZmFpbGVkIHRvIGdldCB0b2tlbiBhY2NvdW50IGJhbGFuY2UnKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlcy5yZXN1bHQ7XG4gIH1cblxuICAvKipcbiAgICogRmV0Y2ggYWxsIHRoZSB0b2tlbiBhY2NvdW50cyBvd25lZCBieSB0aGUgc3BlY2lmaWVkIGFjY291bnRcbiAgICpcbiAgICogQHJldHVybiB7UHJvbWlzZTxScGNSZXNwb25zZUFuZENvbnRleHQ8R2V0UHJvZ3JhbUFjY291bnRzUmVzcG9uc2U+fVxuICAgKi9cbiAgYXN5bmMgZ2V0VG9rZW5BY2NvdW50c0J5T3duZXIob3duZXJBZGRyZXNzLCBmaWx0ZXIsIGNvbW1pdG1lbnRPckNvbmZpZykge1xuICAgIGNvbnN0IHtcbiAgICAgIGNvbW1pdG1lbnQsXG4gICAgICBjb25maWdcbiAgICB9ID0gZXh0cmFjdENvbW1pdG1lbnRGcm9tQ29uZmlnKGNvbW1pdG1lbnRPckNvbmZpZyk7XG4gICAgbGV0IF9hcmdzID0gW293bmVyQWRkcmVzcy50b0Jhc2U1OCgpXTtcbiAgICBpZiAoJ21pbnQnIGluIGZpbHRlcikge1xuICAgICAgX2FyZ3MucHVzaCh7XG4gICAgICAgIG1pbnQ6IGZpbHRlci5taW50LnRvQmFzZTU4KClcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBfYXJncy5wdXNoKHtcbiAgICAgICAgcHJvZ3JhbUlkOiBmaWx0ZXIucHJvZ3JhbUlkLnRvQmFzZTU4KClcbiAgICAgIH0pO1xuICAgIH1cbiAgICBjb25zdCBhcmdzID0gdGhpcy5fYnVpbGRBcmdzKF9hcmdzLCBjb21taXRtZW50LCAnYmFzZTY0JywgY29uZmlnKTtcbiAgICBjb25zdCB1bnNhZmVSZXMgPSBhd2FpdCB0aGlzLl9ycGNSZXF1ZXN0KCdnZXRUb2tlbkFjY291bnRzQnlPd25lcicsIGFyZ3MpO1xuICAgIGNvbnN0IHJlcyA9IGNyZWF0ZSh1bnNhZmVSZXMsIEdldFRva2VuQWNjb3VudHNCeU93bmVyKTtcbiAgICBpZiAoJ2Vycm9yJyBpbiByZXMpIHtcbiAgICAgIHRocm93IG5ldyBTb2xhbmFKU09OUlBDRXJyb3IocmVzLmVycm9yLCBgZmFpbGVkIHRvIGdldCB0b2tlbiBhY2NvdW50cyBvd25lZCBieSBhY2NvdW50ICR7b3duZXJBZGRyZXNzLnRvQmFzZTU4KCl9YCk7XG4gICAgfVxuICAgIHJldHVybiByZXMucmVzdWx0O1xuICB9XG5cbiAgLyoqXG4gICAqIEZldGNoIHBhcnNlZCB0b2tlbiBhY2NvdW50cyBvd25lZCBieSB0aGUgc3BlY2lmaWVkIGFjY291bnRcbiAgICpcbiAgICogQHJldHVybiB7UHJvbWlzZTxScGNSZXNwb25zZUFuZENvbnRleHQ8QXJyYXk8e3B1YmtleTogUHVibGljS2V5LCBhY2NvdW50OiBBY2NvdW50SW5mbzxQYXJzZWRBY2NvdW50RGF0YT59Pj4+fVxuICAgKi9cbiAgYXN5bmMgZ2V0UGFyc2VkVG9rZW5BY2NvdW50c0J5T3duZXIob3duZXJBZGRyZXNzLCBmaWx0ZXIsIGNvbW1pdG1lbnQpIHtcbiAgICBsZXQgX2FyZ3MgPSBbb3duZXJBZGRyZXNzLnRvQmFzZTU4KCldO1xuICAgIGlmICgnbWludCcgaW4gZmlsdGVyKSB7XG4gICAgICBfYXJncy5wdXNoKHtcbiAgICAgICAgbWludDogZmlsdGVyLm1pbnQudG9CYXNlNTgoKVxuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIF9hcmdzLnB1c2goe1xuICAgICAgICBwcm9ncmFtSWQ6IGZpbHRlci5wcm9ncmFtSWQudG9CYXNlNTgoKVxuICAgICAgfSk7XG4gICAgfVxuICAgIGNvbnN0IGFyZ3MgPSB0aGlzLl9idWlsZEFyZ3MoX2FyZ3MsIGNvbW1pdG1lbnQsICdqc29uUGFyc2VkJyk7XG4gICAgY29uc3QgdW5zYWZlUmVzID0gYXdhaXQgdGhpcy5fcnBjUmVxdWVzdCgnZ2V0VG9rZW5BY2NvdW50c0J5T3duZXInLCBhcmdzKTtcbiAgICBjb25zdCByZXMgPSBjcmVhdGUodW5zYWZlUmVzLCBHZXRQYXJzZWRUb2tlbkFjY291bnRzQnlPd25lcik7XG4gICAgaWYgKCdlcnJvcicgaW4gcmVzKSB7XG4gICAgICB0aHJvdyBuZXcgU29sYW5hSlNPTlJQQ0Vycm9yKHJlcy5lcnJvciwgYGZhaWxlZCB0byBnZXQgdG9rZW4gYWNjb3VudHMgb3duZWQgYnkgYWNjb3VudCAke293bmVyQWRkcmVzcy50b0Jhc2U1OCgpfWApO1xuICAgIH1cbiAgICByZXR1cm4gcmVzLnJlc3VsdDtcbiAgfVxuXG4gIC8qKlxuICAgKiBGZXRjaCB0aGUgMjAgbGFyZ2VzdCBhY2NvdW50cyB3aXRoIHRoZWlyIGN1cnJlbnQgYmFsYW5jZXNcbiAgICovXG4gIGFzeW5jIGdldExhcmdlc3RBY2NvdW50cyhjb25maWcpIHtcbiAgICBjb25zdCBhcmcgPSB7XG4gICAgICAuLi5jb25maWcsXG4gICAgICBjb21taXRtZW50OiBjb25maWcgJiYgY29uZmlnLmNvbW1pdG1lbnQgfHwgdGhpcy5jb21taXRtZW50XG4gICAgfTtcbiAgICBjb25zdCBhcmdzID0gYXJnLmZpbHRlciB8fCBhcmcuY29tbWl0bWVudCA/IFthcmddIDogW107XG4gICAgY29uc3QgdW5zYWZlUmVzID0gYXdhaXQgdGhpcy5fcnBjUmVxdWVzdCgnZ2V0TGFyZ2VzdEFjY291bnRzJywgYXJncyk7XG4gICAgY29uc3QgcmVzID0gY3JlYXRlKHVuc2FmZVJlcywgR2V0TGFyZ2VzdEFjY291bnRzUnBjUmVzdWx0KTtcbiAgICBpZiAoJ2Vycm9yJyBpbiByZXMpIHtcbiAgICAgIHRocm93IG5ldyBTb2xhbmFKU09OUlBDRXJyb3IocmVzLmVycm9yLCAnZmFpbGVkIHRvIGdldCBsYXJnZXN0IGFjY291bnRzJyk7XG4gICAgfVxuICAgIHJldHVybiByZXMucmVzdWx0O1xuICB9XG5cbiAgLyoqXG4gICAqIEZldGNoIHRoZSAyMCBsYXJnZXN0IHRva2VuIGFjY291bnRzIHdpdGggdGhlaXIgY3VycmVudCBiYWxhbmNlc1xuICAgKiBmb3IgYSBnaXZlbiBtaW50LlxuICAgKi9cbiAgYXN5bmMgZ2V0VG9rZW5MYXJnZXN0QWNjb3VudHMobWludEFkZHJlc3MsIGNvbW1pdG1lbnQpIHtcbiAgICBjb25zdCBhcmdzID0gdGhpcy5fYnVpbGRBcmdzKFttaW50QWRkcmVzcy50b0Jhc2U1OCgpXSwgY29tbWl0bWVudCk7XG4gICAgY29uc3QgdW5zYWZlUmVzID0gYXdhaXQgdGhpcy5fcnBjUmVxdWVzdCgnZ2V0VG9rZW5MYXJnZXN0QWNjb3VudHMnLCBhcmdzKTtcbiAgICBjb25zdCByZXMgPSBjcmVhdGUodW5zYWZlUmVzLCBHZXRUb2tlbkxhcmdlc3RBY2NvdW50c1Jlc3VsdCk7XG4gICAgaWYgKCdlcnJvcicgaW4gcmVzKSB7XG4gICAgICB0aHJvdyBuZXcgU29sYW5hSlNPTlJQQ0Vycm9yKHJlcy5lcnJvciwgJ2ZhaWxlZCB0byBnZXQgdG9rZW4gbGFyZ2VzdCBhY2NvdW50cycpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzLnJlc3VsdDtcbiAgfVxuXG4gIC8qKlxuICAgKiBGZXRjaCBhbGwgdGhlIGFjY291bnQgaW5mbyBmb3IgdGhlIHNwZWNpZmllZCBwdWJsaWMga2V5LCByZXR1cm4gd2l0aCBjb250ZXh0XG4gICAqL1xuICBhc3luYyBnZXRBY2NvdW50SW5mb0FuZENvbnRleHQocHVibGljS2V5LCBjb21taXRtZW50T3JDb25maWcpIHtcbiAgICBjb25zdCB7XG4gICAgICBjb21taXRtZW50LFxuICAgICAgY29uZmlnXG4gICAgfSA9IGV4dHJhY3RDb21taXRtZW50RnJvbUNvbmZpZyhjb21taXRtZW50T3JDb25maWcpO1xuICAgIGNvbnN0IGFyZ3MgPSB0aGlzLl9idWlsZEFyZ3MoW3B1YmxpY0tleS50b0Jhc2U1OCgpXSwgY29tbWl0bWVudCwgJ2Jhc2U2NCcsIGNvbmZpZyk7XG4gICAgY29uc3QgdW5zYWZlUmVzID0gYXdhaXQgdGhpcy5fcnBjUmVxdWVzdCgnZ2V0QWNjb3VudEluZm8nLCBhcmdzKTtcbiAgICBjb25zdCByZXMgPSBjcmVhdGUodW5zYWZlUmVzLCBqc29uUnBjUmVzdWx0QW5kQ29udGV4dChudWxsYWJsZShBY2NvdW50SW5mb1Jlc3VsdCkpKTtcbiAgICBpZiAoJ2Vycm9yJyBpbiByZXMpIHtcbiAgICAgIHRocm93IG5ldyBTb2xhbmFKU09OUlBDRXJyb3IocmVzLmVycm9yLCBgZmFpbGVkIHRvIGdldCBpbmZvIGFib3V0IGFjY291bnQgJHtwdWJsaWNLZXkudG9CYXNlNTgoKX1gKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlcy5yZXN1bHQ7XG4gIH1cblxuICAvKipcbiAgICogRmV0Y2ggcGFyc2VkIGFjY291bnQgaW5mbyBmb3IgdGhlIHNwZWNpZmllZCBwdWJsaWMga2V5XG4gICAqL1xuICBhc3luYyBnZXRQYXJzZWRBY2NvdW50SW5mbyhwdWJsaWNLZXksIGNvbW1pdG1lbnRPckNvbmZpZykge1xuICAgIGNvbnN0IHtcbiAgICAgIGNvbW1pdG1lbnQsXG4gICAgICBjb25maWdcbiAgICB9ID0gZXh0cmFjdENvbW1pdG1lbnRGcm9tQ29uZmlnKGNvbW1pdG1lbnRPckNvbmZpZyk7XG4gICAgY29uc3QgYXJncyA9IHRoaXMuX2J1aWxkQXJncyhbcHVibGljS2V5LnRvQmFzZTU4KCldLCBjb21taXRtZW50LCAnanNvblBhcnNlZCcsIGNvbmZpZyk7XG4gICAgY29uc3QgdW5zYWZlUmVzID0gYXdhaXQgdGhpcy5fcnBjUmVxdWVzdCgnZ2V0QWNjb3VudEluZm8nLCBhcmdzKTtcbiAgICBjb25zdCByZXMgPSBjcmVhdGUodW5zYWZlUmVzLCBqc29uUnBjUmVzdWx0QW5kQ29udGV4dChudWxsYWJsZShQYXJzZWRBY2NvdW50SW5mb1Jlc3VsdCkpKTtcbiAgICBpZiAoJ2Vycm9yJyBpbiByZXMpIHtcbiAgICAgIHRocm93IG5ldyBTb2xhbmFKU09OUlBDRXJyb3IocmVzLmVycm9yLCBgZmFpbGVkIHRvIGdldCBpbmZvIGFib3V0IGFjY291bnQgJHtwdWJsaWNLZXkudG9CYXNlNTgoKX1gKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlcy5yZXN1bHQ7XG4gIH1cblxuICAvKipcbiAgICogRmV0Y2ggYWxsIHRoZSBhY2NvdW50IGluZm8gZm9yIHRoZSBzcGVjaWZpZWQgcHVibGljIGtleVxuICAgKi9cbiAgYXN5bmMgZ2V0QWNjb3VudEluZm8ocHVibGljS2V5LCBjb21taXRtZW50T3JDb25maWcpIHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgcmVzID0gYXdhaXQgdGhpcy5nZXRBY2NvdW50SW5mb0FuZENvbnRleHQocHVibGljS2V5LCBjb21taXRtZW50T3JDb25maWcpO1xuICAgICAgcmV0dXJuIHJlcy52YWx1ZTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ZhaWxlZCB0byBnZXQgaW5mbyBhYm91dCBhY2NvdW50ICcgKyBwdWJsaWNLZXkudG9CYXNlNTgoKSArICc6ICcgKyBlKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogRmV0Y2ggYWxsIHRoZSBhY2NvdW50IGluZm8gZm9yIG11bHRpcGxlIGFjY291bnRzIHNwZWNpZmllZCBieSBhbiBhcnJheSBvZiBwdWJsaWMga2V5cywgcmV0dXJuIHdpdGggY29udGV4dFxuICAgKi9cbiAgYXN5bmMgZ2V0TXVsdGlwbGVQYXJzZWRBY2NvdW50cyhwdWJsaWNLZXlzLCByYXdDb25maWcpIHtcbiAgICBjb25zdCB7XG4gICAgICBjb21taXRtZW50LFxuICAgICAgY29uZmlnXG4gICAgfSA9IGV4dHJhY3RDb21taXRtZW50RnJvbUNvbmZpZyhyYXdDb25maWcpO1xuICAgIGNvbnN0IGtleXMgPSBwdWJsaWNLZXlzLm1hcChrZXkgPT4ga2V5LnRvQmFzZTU4KCkpO1xuICAgIGNvbnN0IGFyZ3MgPSB0aGlzLl9idWlsZEFyZ3MoW2tleXNdLCBjb21taXRtZW50LCAnanNvblBhcnNlZCcsIGNvbmZpZyk7XG4gICAgY29uc3QgdW5zYWZlUmVzID0gYXdhaXQgdGhpcy5fcnBjUmVxdWVzdCgnZ2V0TXVsdGlwbGVBY2NvdW50cycsIGFyZ3MpO1xuICAgIGNvbnN0IHJlcyA9IGNyZWF0ZSh1bnNhZmVSZXMsIGpzb25ScGNSZXN1bHRBbmRDb250ZXh0KGFycmF5KG51bGxhYmxlKFBhcnNlZEFjY291bnRJbmZvUmVzdWx0KSkpKTtcbiAgICBpZiAoJ2Vycm9yJyBpbiByZXMpIHtcbiAgICAgIHRocm93IG5ldyBTb2xhbmFKU09OUlBDRXJyb3IocmVzLmVycm9yLCBgZmFpbGVkIHRvIGdldCBpbmZvIGZvciBhY2NvdW50cyAke2tleXN9YCk7XG4gICAgfVxuICAgIHJldHVybiByZXMucmVzdWx0O1xuICB9XG5cbiAgLyoqXG4gICAqIEZldGNoIGFsbCB0aGUgYWNjb3VudCBpbmZvIGZvciBtdWx0aXBsZSBhY2NvdW50cyBzcGVjaWZpZWQgYnkgYW4gYXJyYXkgb2YgcHVibGljIGtleXMsIHJldHVybiB3aXRoIGNvbnRleHRcbiAgICovXG4gIGFzeW5jIGdldE11bHRpcGxlQWNjb3VudHNJbmZvQW5kQ29udGV4dChwdWJsaWNLZXlzLCBjb21taXRtZW50T3JDb25maWcpIHtcbiAgICBjb25zdCB7XG4gICAgICBjb21taXRtZW50LFxuICAgICAgY29uZmlnXG4gICAgfSA9IGV4dHJhY3RDb21taXRtZW50RnJvbUNvbmZpZyhjb21taXRtZW50T3JDb25maWcpO1xuICAgIGNvbnN0IGtleXMgPSBwdWJsaWNLZXlzLm1hcChrZXkgPT4ga2V5LnRvQmFzZTU4KCkpO1xuICAgIGNvbnN0IGFyZ3MgPSB0aGlzLl9idWlsZEFyZ3MoW2tleXNdLCBjb21taXRtZW50LCAnYmFzZTY0JywgY29uZmlnKTtcbiAgICBjb25zdCB1bnNhZmVSZXMgPSBhd2FpdCB0aGlzLl9ycGNSZXF1ZXN0KCdnZXRNdWx0aXBsZUFjY291bnRzJywgYXJncyk7XG4gICAgY29uc3QgcmVzID0gY3JlYXRlKHVuc2FmZVJlcywganNvblJwY1Jlc3VsdEFuZENvbnRleHQoYXJyYXkobnVsbGFibGUoQWNjb3VudEluZm9SZXN1bHQpKSkpO1xuICAgIGlmICgnZXJyb3InIGluIHJlcykge1xuICAgICAgdGhyb3cgbmV3IFNvbGFuYUpTT05SUENFcnJvcihyZXMuZXJyb3IsIGBmYWlsZWQgdG8gZ2V0IGluZm8gZm9yIGFjY291bnRzICR7a2V5c31gKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlcy5yZXN1bHQ7XG4gIH1cblxuICAvKipcbiAgICogRmV0Y2ggYWxsIHRoZSBhY2NvdW50IGluZm8gZm9yIG11bHRpcGxlIGFjY291bnRzIHNwZWNpZmllZCBieSBhbiBhcnJheSBvZiBwdWJsaWMga2V5c1xuICAgKi9cbiAgYXN5bmMgZ2V0TXVsdGlwbGVBY2NvdW50c0luZm8ocHVibGljS2V5cywgY29tbWl0bWVudE9yQ29uZmlnKSB7XG4gICAgY29uc3QgcmVzID0gYXdhaXQgdGhpcy5nZXRNdWx0aXBsZUFjY291bnRzSW5mb0FuZENvbnRleHQocHVibGljS2V5cywgY29tbWl0bWVudE9yQ29uZmlnKTtcbiAgICByZXR1cm4gcmVzLnZhbHVlO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgZXBvY2ggYWN0aXZhdGlvbiBpbmZvcm1hdGlvbiBmb3IgYSBzdGFrZSBhY2NvdW50IHRoYXQgaGFzIGJlZW4gZGVsZWdhdGVkXG4gICAqL1xuICBhc3luYyBnZXRTdGFrZUFjdGl2YXRpb24ocHVibGljS2V5LCBjb21taXRtZW50T3JDb25maWcsIGVwb2NoKSB7XG4gICAgY29uc3Qge1xuICAgICAgY29tbWl0bWVudCxcbiAgICAgIGNvbmZpZ1xuICAgIH0gPSBleHRyYWN0Q29tbWl0bWVudEZyb21Db25maWcoY29tbWl0bWVudE9yQ29uZmlnKTtcbiAgICBjb25zdCBhcmdzID0gdGhpcy5fYnVpbGRBcmdzKFtwdWJsaWNLZXkudG9CYXNlNTgoKV0sIGNvbW1pdG1lbnQsIHVuZGVmaW5lZCAvKiBlbmNvZGluZyAqLywge1xuICAgICAgLi4uY29uZmlnLFxuICAgICAgZXBvY2g6IGVwb2NoICE9IG51bGwgPyBlcG9jaCA6IGNvbmZpZz8uZXBvY2hcbiAgICB9KTtcbiAgICBjb25zdCB1bnNhZmVSZXMgPSBhd2FpdCB0aGlzLl9ycGNSZXF1ZXN0KCdnZXRTdGFrZUFjdGl2YXRpb24nLCBhcmdzKTtcbiAgICBjb25zdCByZXMgPSBjcmVhdGUodW5zYWZlUmVzLCBqc29uUnBjUmVzdWx0KFN0YWtlQWN0aXZhdGlvblJlc3VsdCkpO1xuICAgIGlmICgnZXJyb3InIGluIHJlcykge1xuICAgICAgdGhyb3cgbmV3IFNvbGFuYUpTT05SUENFcnJvcihyZXMuZXJyb3IsIGBmYWlsZWQgdG8gZ2V0IFN0YWtlIEFjdGl2YXRpb24gJHtwdWJsaWNLZXkudG9CYXNlNTgoKX1gKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlcy5yZXN1bHQ7XG4gIH1cblxuICAvKipcbiAgICogRmV0Y2ggYWxsIHRoZSBhY2NvdW50cyBvd25lZCBieSB0aGUgc3BlY2lmaWVkIHByb2dyYW0gaWRcbiAgICpcbiAgICogQHJldHVybiB7UHJvbWlzZTxBcnJheTx7cHVia2V5OiBQdWJsaWNLZXksIGFjY291bnQ6IEFjY291bnRJbmZvPEJ1ZmZlcj59Pj59XG4gICAqL1xuXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1kdXBlLWNsYXNzLW1lbWJlcnNcblxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tZHVwZS1jbGFzcy1tZW1iZXJzXG4gIGFzeW5jIGdldFByb2dyYW1BY2NvdW50cyhwcm9ncmFtSWQsIGNvbmZpZ09yQ29tbWl0bWVudCkge1xuICAgIGNvbnN0IHtcbiAgICAgIGNvbW1pdG1lbnQsXG4gICAgICBjb25maWdcbiAgICB9ID0gZXh0cmFjdENvbW1pdG1lbnRGcm9tQ29uZmlnKGNvbmZpZ09yQ29tbWl0bWVudCk7XG4gICAgY29uc3Qge1xuICAgICAgZW5jb2RpbmcsXG4gICAgICAuLi5jb25maWdXaXRob3V0RW5jb2RpbmdcbiAgICB9ID0gY29uZmlnIHx8IHt9O1xuICAgIGNvbnN0IGFyZ3MgPSB0aGlzLl9idWlsZEFyZ3MoW3Byb2dyYW1JZC50b0Jhc2U1OCgpXSwgY29tbWl0bWVudCwgZW5jb2RpbmcgfHwgJ2Jhc2U2NCcsIGNvbmZpZ1dpdGhvdXRFbmNvZGluZyk7XG4gICAgY29uc3QgdW5zYWZlUmVzID0gYXdhaXQgdGhpcy5fcnBjUmVxdWVzdCgnZ2V0UHJvZ3JhbUFjY291bnRzJywgYXJncyk7XG4gICAgY29uc3QgYmFzZVNjaGVtYSA9IGFycmF5KEtleWVkQWNjb3VudEluZm9SZXN1bHQpO1xuICAgIGNvbnN0IHJlcyA9IGNvbmZpZ1dpdGhvdXRFbmNvZGluZy53aXRoQ29udGV4dCA9PT0gdHJ1ZSA/IGNyZWF0ZSh1bnNhZmVSZXMsIGpzb25ScGNSZXN1bHRBbmRDb250ZXh0KGJhc2VTY2hlbWEpKSA6IGNyZWF0ZSh1bnNhZmVSZXMsIGpzb25ScGNSZXN1bHQoYmFzZVNjaGVtYSkpO1xuICAgIGlmICgnZXJyb3InIGluIHJlcykge1xuICAgICAgdGhyb3cgbmV3IFNvbGFuYUpTT05SUENFcnJvcihyZXMuZXJyb3IsIGBmYWlsZWQgdG8gZ2V0IGFjY291bnRzIG93bmVkIGJ5IHByb2dyYW0gJHtwcm9ncmFtSWQudG9CYXNlNTgoKX1gKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlcy5yZXN1bHQ7XG4gIH1cblxuICAvKipcbiAgICogRmV0Y2ggYW5kIHBhcnNlIGFsbCB0aGUgYWNjb3VudHMgb3duZWQgYnkgdGhlIHNwZWNpZmllZCBwcm9ncmFtIGlkXG4gICAqXG4gICAqIEByZXR1cm4ge1Byb21pc2U8QXJyYXk8e3B1YmtleTogUHVibGljS2V5LCBhY2NvdW50OiBBY2NvdW50SW5mbzxCdWZmZXIgfCBQYXJzZWRBY2NvdW50RGF0YT59Pj59XG4gICAqL1xuICBhc3luYyBnZXRQYXJzZWRQcm9ncmFtQWNjb3VudHMocHJvZ3JhbUlkLCBjb25maWdPckNvbW1pdG1lbnQpIHtcbiAgICBjb25zdCB7XG4gICAgICBjb21taXRtZW50LFxuICAgICAgY29uZmlnXG4gICAgfSA9IGV4dHJhY3RDb21taXRtZW50RnJvbUNvbmZpZyhjb25maWdPckNvbW1pdG1lbnQpO1xuICAgIGNvbnN0IGFyZ3MgPSB0aGlzLl9idWlsZEFyZ3MoW3Byb2dyYW1JZC50b0Jhc2U1OCgpXSwgY29tbWl0bWVudCwgJ2pzb25QYXJzZWQnLCBjb25maWcpO1xuICAgIGNvbnN0IHVuc2FmZVJlcyA9IGF3YWl0IHRoaXMuX3JwY1JlcXVlc3QoJ2dldFByb2dyYW1BY2NvdW50cycsIGFyZ3MpO1xuICAgIGNvbnN0IHJlcyA9IGNyZWF0ZSh1bnNhZmVSZXMsIGpzb25ScGNSZXN1bHQoYXJyYXkoS2V5ZWRQYXJzZWRBY2NvdW50SW5mb1Jlc3VsdCkpKTtcbiAgICBpZiAoJ2Vycm9yJyBpbiByZXMpIHtcbiAgICAgIHRocm93IG5ldyBTb2xhbmFKU09OUlBDRXJyb3IocmVzLmVycm9yLCBgZmFpbGVkIHRvIGdldCBhY2NvdW50cyBvd25lZCBieSBwcm9ncmFtICR7cHJvZ3JhbUlkLnRvQmFzZTU4KCl9YCk7XG4gICAgfVxuICAgIHJldHVybiByZXMucmVzdWx0O1xuICB9XG5cbiAgLyoqIEBkZXByZWNhdGVkIEluc3RlYWQsIGNhbGwgYGNvbmZpcm1UcmFuc2FjdGlvbmAgYW5kIHBhc3MgaW4ge0BsaW5rIFRyYW5zYWN0aW9uQ29uZmlybWF0aW9uU3RyYXRlZ3l9ICovXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1kdXBlLWNsYXNzLW1lbWJlcnNcblxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tZHVwZS1jbGFzcy1tZW1iZXJzXG4gIGFzeW5jIGNvbmZpcm1UcmFuc2FjdGlvbihzdHJhdGVneSwgY29tbWl0bWVudCkge1xuICAgIGxldCByYXdTaWduYXR1cmU7XG4gICAgaWYgKHR5cGVvZiBzdHJhdGVneSA9PSAnc3RyaW5nJykge1xuICAgICAgcmF3U2lnbmF0dXJlID0gc3RyYXRlZ3k7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IGNvbmZpZyA9IHN0cmF0ZWd5O1xuICAgICAgaWYgKGNvbmZpZy5hYm9ydFNpZ25hbD8uYWJvcnRlZCkge1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoY29uZmlnLmFib3J0U2lnbmFsLnJlYXNvbik7XG4gICAgICB9XG4gICAgICByYXdTaWduYXR1cmUgPSBjb25maWcuc2lnbmF0dXJlO1xuICAgIH1cbiAgICBsZXQgZGVjb2RlZFNpZ25hdHVyZTtcbiAgICB0cnkge1xuICAgICAgZGVjb2RlZFNpZ25hdHVyZSA9IGJzNTguZGVjb2RlKHJhd1NpZ25hdHVyZSk7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ3NpZ25hdHVyZSBtdXN0IGJlIGJhc2U1OCBlbmNvZGVkOiAnICsgcmF3U2lnbmF0dXJlKTtcbiAgICB9XG4gICAgYXNzZXJ0KGRlY29kZWRTaWduYXR1cmUubGVuZ3RoID09PSA2NCwgJ3NpZ25hdHVyZSBoYXMgaW52YWxpZCBsZW5ndGgnKTtcbiAgICBpZiAodHlwZW9mIHN0cmF0ZWd5ID09PSAnc3RyaW5nJykge1xuICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuY29uZmlybVRyYW5zYWN0aW9uVXNpbmdMZWdhY3lUaW1lb3V0U3RyYXRlZ3koe1xuICAgICAgICBjb21taXRtZW50OiBjb21taXRtZW50IHx8IHRoaXMuY29tbWl0bWVudCxcbiAgICAgICAgc2lnbmF0dXJlOiByYXdTaWduYXR1cmVcbiAgICAgIH0pO1xuICAgIH0gZWxzZSBpZiAoJ2xhc3RWYWxpZEJsb2NrSGVpZ2h0JyBpbiBzdHJhdGVneSkge1xuICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuY29uZmlybVRyYW5zYWN0aW9uVXNpbmdCbG9ja0hlaWdodEV4Y2VlZGFuY2VTdHJhdGVneSh7XG4gICAgICAgIGNvbW1pdG1lbnQ6IGNvbW1pdG1lbnQgfHwgdGhpcy5jb21taXRtZW50LFxuICAgICAgICBzdHJhdGVneVxuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBhd2FpdCB0aGlzLmNvbmZpcm1UcmFuc2FjdGlvblVzaW5nRHVyYWJsZU5vbmNlU3RyYXRlZ3koe1xuICAgICAgICBjb21taXRtZW50OiBjb21taXRtZW50IHx8IHRoaXMuY29tbWl0bWVudCxcbiAgICAgICAgc3RyYXRlZ3lcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuICBnZXRDYW5jZWxsYXRpb25Qcm9taXNlKHNpZ25hbCkge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgoXywgcmVqZWN0KSA9PiB7XG4gICAgICBpZiAoc2lnbmFsID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKHNpZ25hbC5hYm9ydGVkKSB7XG4gICAgICAgIHJlamVjdChzaWduYWwucmVhc29uKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNpZ25hbC5hZGRFdmVudExpc3RlbmVyKCdhYm9ydCcsICgpID0+IHtcbiAgICAgICAgICByZWplY3Qoc2lnbmFsLnJlYXNvbik7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIGdldFRyYW5zYWN0aW9uQ29uZmlybWF0aW9uUHJvbWlzZSh7XG4gICAgY29tbWl0bWVudCxcbiAgICBzaWduYXR1cmVcbiAgfSkge1xuICAgIGxldCBzaWduYXR1cmVTdWJzY3JpcHRpb25JZDtcbiAgICBsZXQgZGlzcG9zZVNpZ25hdHVyZVN1YnNjcmlwdGlvblN0YXRlQ2hhbmdlT2JzZXJ2ZXI7XG4gICAgbGV0IGRvbmUgPSBmYWxzZTtcbiAgICBjb25zdCBjb25maXJtYXRpb25Qcm9taXNlID0gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgdHJ5IHtcbiAgICAgICAgc2lnbmF0dXJlU3Vic2NyaXB0aW9uSWQgPSB0aGlzLm9uU2lnbmF0dXJlKHNpZ25hdHVyZSwgKHJlc3VsdCwgY29udGV4dCkgPT4ge1xuICAgICAgICAgIHNpZ25hdHVyZVN1YnNjcmlwdGlvbklkID0gdW5kZWZpbmVkO1xuICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0ge1xuICAgICAgICAgICAgY29udGV4dCxcbiAgICAgICAgICAgIHZhbHVlOiByZXN1bHRcbiAgICAgICAgICB9O1xuICAgICAgICAgIHJlc29sdmUoe1xuICAgICAgICAgICAgX190eXBlOiBUcmFuc2FjdGlvblN0YXR1cy5QUk9DRVNTRUQsXG4gICAgICAgICAgICByZXNwb25zZVxuICAgICAgICAgIH0pO1xuICAgICAgICB9LCBjb21taXRtZW50KTtcbiAgICAgICAgY29uc3Qgc3Vic2NyaXB0aW9uU2V0dXBQcm9taXNlID0gbmV3IFByb21pc2UocmVzb2x2ZVN1YnNjcmlwdGlvblNldHVwID0+IHtcbiAgICAgICAgICBpZiAoc2lnbmF0dXJlU3Vic2NyaXB0aW9uSWQgPT0gbnVsbCkge1xuICAgICAgICAgICAgcmVzb2x2ZVN1YnNjcmlwdGlvblNldHVwKCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGRpc3Bvc2VTaWduYXR1cmVTdWJzY3JpcHRpb25TdGF0ZUNoYW5nZU9ic2VydmVyID0gdGhpcy5fb25TdWJzY3JpcHRpb25TdGF0ZUNoYW5nZShzaWduYXR1cmVTdWJzY3JpcHRpb25JZCwgbmV4dFN0YXRlID0+IHtcbiAgICAgICAgICAgICAgaWYgKG5leHRTdGF0ZSA9PT0gJ3N1YnNjcmliZWQnKSB7XG4gICAgICAgICAgICAgICAgcmVzb2x2ZVN1YnNjcmlwdGlvblNldHVwKCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIChhc3luYyAoKSA9PiB7XG4gICAgICAgICAgYXdhaXQgc3Vic2NyaXB0aW9uU2V0dXBQcm9taXNlO1xuICAgICAgICAgIGlmIChkb25lKSByZXR1cm47XG4gICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLmdldFNpZ25hdHVyZVN0YXR1cyhzaWduYXR1cmUpO1xuICAgICAgICAgIGlmIChkb25lKSByZXR1cm47XG4gICAgICAgICAgaWYgKHJlc3BvbnNlID09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgY29uc3Qge1xuICAgICAgICAgICAgY29udGV4dCxcbiAgICAgICAgICAgIHZhbHVlXG4gICAgICAgICAgfSA9IHJlc3BvbnNlO1xuICAgICAgICAgIGlmICh2YWx1ZSA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICh2YWx1ZT8uZXJyKSB7XG4gICAgICAgICAgICByZWplY3QodmFsdWUuZXJyKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc3dpdGNoIChjb21taXRtZW50KSB7XG4gICAgICAgICAgICAgIGNhc2UgJ2NvbmZpcm1lZCc6XG4gICAgICAgICAgICAgIGNhc2UgJ3NpbmdsZSc6XG4gICAgICAgICAgICAgIGNhc2UgJ3NpbmdsZUdvc3NpcCc6XG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlLmNvbmZpcm1hdGlvblN0YXR1cyA9PT0gJ3Byb2Nlc3NlZCcpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBjYXNlICdmaW5hbGl6ZWQnOlxuICAgICAgICAgICAgICBjYXNlICdtYXgnOlxuICAgICAgICAgICAgICBjYXNlICdyb290JzpcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICBpZiAodmFsdWUuY29uZmlybWF0aW9uU3RhdHVzID09PSAncHJvY2Vzc2VkJyB8fCB2YWx1ZS5jb25maXJtYXRpb25TdGF0dXMgPT09ICdjb25maXJtZWQnKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgLy8gZXhoYXVzdCBlbnVtcyB0byBlbnN1cmUgZnVsbCBjb3ZlcmFnZVxuICAgICAgICAgICAgICBjYXNlICdwcm9jZXNzZWQnOlxuICAgICAgICAgICAgICBjYXNlICdyZWNlbnQnOlxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZG9uZSA9IHRydWU7XG4gICAgICAgICAgICByZXNvbHZlKHtcbiAgICAgICAgICAgICAgX190eXBlOiBUcmFuc2FjdGlvblN0YXR1cy5QUk9DRVNTRUQsXG4gICAgICAgICAgICAgIHJlc3BvbnNlOiB7XG4gICAgICAgICAgICAgICAgY29udGV4dCxcbiAgICAgICAgICAgICAgICB2YWx1ZVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pKCk7XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgcmVqZWN0KGVycik7XG4gICAgICB9XG4gICAgfSk7XG4gICAgY29uc3QgYWJvcnRDb25maXJtYXRpb24gPSAoKSA9PiB7XG4gICAgICBpZiAoZGlzcG9zZVNpZ25hdHVyZVN1YnNjcmlwdGlvblN0YXRlQ2hhbmdlT2JzZXJ2ZXIpIHtcbiAgICAgICAgZGlzcG9zZVNpZ25hdHVyZVN1YnNjcmlwdGlvblN0YXRlQ2hhbmdlT2JzZXJ2ZXIoKTtcbiAgICAgICAgZGlzcG9zZVNpZ25hdHVyZVN1YnNjcmlwdGlvblN0YXRlQ2hhbmdlT2JzZXJ2ZXIgPSB1bmRlZmluZWQ7XG4gICAgICB9XG4gICAgICBpZiAoc2lnbmF0dXJlU3Vic2NyaXB0aW9uSWQgIT0gbnVsbCkge1xuICAgICAgICB0aGlzLnJlbW92ZVNpZ25hdHVyZUxpc3RlbmVyKHNpZ25hdHVyZVN1YnNjcmlwdGlvbklkKTtcbiAgICAgICAgc2lnbmF0dXJlU3Vic2NyaXB0aW9uSWQgPSB1bmRlZmluZWQ7XG4gICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4ge1xuICAgICAgYWJvcnRDb25maXJtYXRpb24sXG4gICAgICBjb25maXJtYXRpb25Qcm9taXNlXG4gICAgfTtcbiAgfVxuICBhc3luYyBjb25maXJtVHJhbnNhY3Rpb25Vc2luZ0Jsb2NrSGVpZ2h0RXhjZWVkYW5jZVN0cmF0ZWd5KHtcbiAgICBjb21taXRtZW50LFxuICAgIHN0cmF0ZWd5OiB7XG4gICAgICBhYm9ydFNpZ25hbCxcbiAgICAgIGxhc3RWYWxpZEJsb2NrSGVpZ2h0LFxuICAgICAgc2lnbmF0dXJlXG4gICAgfVxuICB9KSB7XG4gICAgbGV0IGRvbmUgPSBmYWxzZTtcbiAgICBjb25zdCBleHBpcnlQcm9taXNlID0gbmV3IFByb21pc2UocmVzb2x2ZSA9PiB7XG4gICAgICBjb25zdCBjaGVja0Jsb2NrSGVpZ2h0ID0gYXN5bmMgKCkgPT4ge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGNvbnN0IGJsb2NrSGVpZ2h0ID0gYXdhaXQgdGhpcy5nZXRCbG9ja0hlaWdodChjb21taXRtZW50KTtcbiAgICAgICAgICByZXR1cm4gYmxvY2tIZWlnaHQ7XG4gICAgICAgIH0gY2F0Y2ggKF9lKSB7XG4gICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgKGFzeW5jICgpID0+IHtcbiAgICAgICAgbGV0IGN1cnJlbnRCbG9ja0hlaWdodCA9IGF3YWl0IGNoZWNrQmxvY2tIZWlnaHQoKTtcbiAgICAgICAgaWYgKGRvbmUpIHJldHVybjtcbiAgICAgICAgd2hpbGUgKGN1cnJlbnRCbG9ja0hlaWdodCA8PSBsYXN0VmFsaWRCbG9ja0hlaWdodCkge1xuICAgICAgICAgIGF3YWl0IHNsZWVwKDEwMDApO1xuICAgICAgICAgIGlmIChkb25lKSByZXR1cm47XG4gICAgICAgICAgY3VycmVudEJsb2NrSGVpZ2h0ID0gYXdhaXQgY2hlY2tCbG9ja0hlaWdodCgpO1xuICAgICAgICAgIGlmIChkb25lKSByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgcmVzb2x2ZSh7XG4gICAgICAgICAgX190eXBlOiBUcmFuc2FjdGlvblN0YXR1cy5CTE9DS0hFSUdIVF9FWENFRURFRFxuICAgICAgICB9KTtcbiAgICAgIH0pKCk7XG4gICAgfSk7XG4gICAgY29uc3Qge1xuICAgICAgYWJvcnRDb25maXJtYXRpb24sXG4gICAgICBjb25maXJtYXRpb25Qcm9taXNlXG4gICAgfSA9IHRoaXMuZ2V0VHJhbnNhY3Rpb25Db25maXJtYXRpb25Qcm9taXNlKHtcbiAgICAgIGNvbW1pdG1lbnQsXG4gICAgICBzaWduYXR1cmVcbiAgICB9KTtcbiAgICBjb25zdCBjYW5jZWxsYXRpb25Qcm9taXNlID0gdGhpcy5nZXRDYW5jZWxsYXRpb25Qcm9taXNlKGFib3J0U2lnbmFsKTtcbiAgICBsZXQgcmVzdWx0O1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBvdXRjb21lID0gYXdhaXQgUHJvbWlzZS5yYWNlKFtjYW5jZWxsYXRpb25Qcm9taXNlLCBjb25maXJtYXRpb25Qcm9taXNlLCBleHBpcnlQcm9taXNlXSk7XG4gICAgICBpZiAob3V0Y29tZS5fX3R5cGUgPT09IFRyYW5zYWN0aW9uU3RhdHVzLlBST0NFU1NFRCkge1xuICAgICAgICByZXN1bHQgPSBvdXRjb21lLnJlc3BvbnNlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IFRyYW5zYWN0aW9uRXhwaXJlZEJsb2NraGVpZ2h0RXhjZWVkZWRFcnJvcihzaWduYXR1cmUpO1xuICAgICAgfVxuICAgIH0gZmluYWxseSB7XG4gICAgICBkb25lID0gdHJ1ZTtcbiAgICAgIGFib3J0Q29uZmlybWF0aW9uKCk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbiAgYXN5bmMgY29uZmlybVRyYW5zYWN0aW9uVXNpbmdEdXJhYmxlTm9uY2VTdHJhdGVneSh7XG4gICAgY29tbWl0bWVudCxcbiAgICBzdHJhdGVneToge1xuICAgICAgYWJvcnRTaWduYWwsXG4gICAgICBtaW5Db250ZXh0U2xvdCxcbiAgICAgIG5vbmNlQWNjb3VudFB1YmtleSxcbiAgICAgIG5vbmNlVmFsdWUsXG4gICAgICBzaWduYXR1cmVcbiAgICB9XG4gIH0pIHtcbiAgICBsZXQgZG9uZSA9IGZhbHNlO1xuICAgIGNvbnN0IGV4cGlyeVByb21pc2UgPSBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHtcbiAgICAgIGxldCBjdXJyZW50Tm9uY2VWYWx1ZSA9IG5vbmNlVmFsdWU7XG4gICAgICBsZXQgbGFzdENoZWNrZWRTbG90ID0gbnVsbDtcbiAgICAgIGNvbnN0IGdldEN1cnJlbnROb25jZVZhbHVlID0gYXN5bmMgKCkgPT4ge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGNvbnN0IHtcbiAgICAgICAgICAgIGNvbnRleHQsXG4gICAgICAgICAgICB2YWx1ZTogbm9uY2VBY2NvdW50XG4gICAgICAgICAgfSA9IGF3YWl0IHRoaXMuZ2V0Tm9uY2VBbmRDb250ZXh0KG5vbmNlQWNjb3VudFB1YmtleSwge1xuICAgICAgICAgICAgY29tbWl0bWVudCxcbiAgICAgICAgICAgIG1pbkNvbnRleHRTbG90XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgbGFzdENoZWNrZWRTbG90ID0gY29udGV4dC5zbG90O1xuICAgICAgICAgIHJldHVybiBub25jZUFjY291bnQ/Lm5vbmNlO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgLy8gSWYgZm9yIHdoYXRldmVyIHJlYXNvbiB3ZSBjYW4ndCByZWFjaC9yZWFkIHRoZSBub25jZVxuICAgICAgICAgIC8vIGFjY291bnQsIGp1c3Qga2VlcCB1c2luZyB0aGUgbGFzdC1rbm93biB2YWx1ZS5cbiAgICAgICAgICByZXR1cm4gY3VycmVudE5vbmNlVmFsdWU7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICAoYXN5bmMgKCkgPT4ge1xuICAgICAgICBjdXJyZW50Tm9uY2VWYWx1ZSA9IGF3YWl0IGdldEN1cnJlbnROb25jZVZhbHVlKCk7XG4gICAgICAgIGlmIChkb25lKSByZXR1cm47XG4gICAgICAgIHdoaWxlICh0cnVlIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tY29uc3RhbnQtY29uZGl0aW9uXG4gICAgICAgICkge1xuICAgICAgICAgIGlmIChub25jZVZhbHVlICE9PSBjdXJyZW50Tm9uY2VWYWx1ZSkge1xuICAgICAgICAgICAgcmVzb2x2ZSh7XG4gICAgICAgICAgICAgIF9fdHlwZTogVHJhbnNhY3Rpb25TdGF0dXMuTk9OQ0VfSU5WQUxJRCxcbiAgICAgICAgICAgICAgc2xvdEluV2hpY2hOb25jZURpZEFkdmFuY2U6IGxhc3RDaGVja2VkU2xvdFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIGF3YWl0IHNsZWVwKDIwMDApO1xuICAgICAgICAgIGlmIChkb25lKSByZXR1cm47XG4gICAgICAgICAgY3VycmVudE5vbmNlVmFsdWUgPSBhd2FpdCBnZXRDdXJyZW50Tm9uY2VWYWx1ZSgpO1xuICAgICAgICAgIGlmIChkb25lKSByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIH0pKCk7XG4gICAgfSk7XG4gICAgY29uc3Qge1xuICAgICAgYWJvcnRDb25maXJtYXRpb24sXG4gICAgICBjb25maXJtYXRpb25Qcm9taXNlXG4gICAgfSA9IHRoaXMuZ2V0VHJhbnNhY3Rpb25Db25maXJtYXRpb25Qcm9taXNlKHtcbiAgICAgIGNvbW1pdG1lbnQsXG4gICAgICBzaWduYXR1cmVcbiAgICB9KTtcbiAgICBjb25zdCBjYW5jZWxsYXRpb25Qcm9taXNlID0gdGhpcy5nZXRDYW5jZWxsYXRpb25Qcm9taXNlKGFib3J0U2lnbmFsKTtcbiAgICBsZXQgcmVzdWx0O1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBvdXRjb21lID0gYXdhaXQgUHJvbWlzZS5yYWNlKFtjYW5jZWxsYXRpb25Qcm9taXNlLCBjb25maXJtYXRpb25Qcm9taXNlLCBleHBpcnlQcm9taXNlXSk7XG4gICAgICBpZiAob3V0Y29tZS5fX3R5cGUgPT09IFRyYW5zYWN0aW9uU3RhdHVzLlBST0NFU1NFRCkge1xuICAgICAgICByZXN1bHQgPSBvdXRjb21lLnJlc3BvbnNlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gRG91YmxlIGNoZWNrIHRoYXQgdGhlIHRyYW5zYWN0aW9uIGlzIGluZGVlZCB1bmNvbmZpcm1lZC5cbiAgICAgICAgbGV0IHNpZ25hdHVyZVN0YXR1cztcbiAgICAgICAgd2hpbGUgKHRydWUgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1jb25zdGFudC1jb25kaXRpb25cbiAgICAgICAgKSB7XG4gICAgICAgICAgY29uc3Qgc3RhdHVzID0gYXdhaXQgdGhpcy5nZXRTaWduYXR1cmVTdGF0dXMoc2lnbmF0dXJlKTtcbiAgICAgICAgICBpZiAoc3RhdHVzID09IG51bGwpIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoc3RhdHVzLmNvbnRleHQuc2xvdCA8IChvdXRjb21lLnNsb3RJbldoaWNoTm9uY2VEaWRBZHZhbmNlID8/IG1pbkNvbnRleHRTbG90KSkge1xuICAgICAgICAgICAgYXdhaXQgc2xlZXAoNDAwKTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBzaWduYXR1cmVTdGF0dXMgPSBzdGF0dXM7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNpZ25hdHVyZVN0YXR1cz8udmFsdWUpIHtcbiAgICAgICAgICBjb25zdCBjb21taXRtZW50Rm9yU3RhdHVzID0gY29tbWl0bWVudCB8fCAnZmluYWxpemVkJztcbiAgICAgICAgICBjb25zdCB7XG4gICAgICAgICAgICBjb25maXJtYXRpb25TdGF0dXNcbiAgICAgICAgICB9ID0gc2lnbmF0dXJlU3RhdHVzLnZhbHVlO1xuICAgICAgICAgIHN3aXRjaCAoY29tbWl0bWVudEZvclN0YXR1cykge1xuICAgICAgICAgICAgY2FzZSAncHJvY2Vzc2VkJzpcbiAgICAgICAgICAgIGNhc2UgJ3JlY2VudCc6XG4gICAgICAgICAgICAgIGlmIChjb25maXJtYXRpb25TdGF0dXMgIT09ICdwcm9jZXNzZWQnICYmIGNvbmZpcm1hdGlvblN0YXR1cyAhPT0gJ2NvbmZpcm1lZCcgJiYgY29uZmlybWF0aW9uU3RhdHVzICE9PSAnZmluYWxpemVkJykge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBUcmFuc2FjdGlvbkV4cGlyZWROb25jZUludmFsaWRFcnJvcihzaWduYXR1cmUpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnY29uZmlybWVkJzpcbiAgICAgICAgICAgIGNhc2UgJ3NpbmdsZSc6XG4gICAgICAgICAgICBjYXNlICdzaW5nbGVHb3NzaXAnOlxuICAgICAgICAgICAgICBpZiAoY29uZmlybWF0aW9uU3RhdHVzICE9PSAnY29uZmlybWVkJyAmJiBjb25maXJtYXRpb25TdGF0dXMgIT09ICdmaW5hbGl6ZWQnKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFRyYW5zYWN0aW9uRXhwaXJlZE5vbmNlSW52YWxpZEVycm9yKHNpZ25hdHVyZSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdmaW5hbGl6ZWQnOlxuICAgICAgICAgICAgY2FzZSAnbWF4JzpcbiAgICAgICAgICAgIGNhc2UgJ3Jvb3QnOlxuICAgICAgICAgICAgICBpZiAoY29uZmlybWF0aW9uU3RhdHVzICE9PSAnZmluYWxpemVkJykge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBUcmFuc2FjdGlvbkV4cGlyZWROb25jZUludmFsaWRFcnJvcihzaWduYXR1cmUpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgLy8gRXhoYXVzdGl2ZSBzd2l0Y2guXG4gICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW51c2VkLXZhcnNcbiAgICAgICAgICAgICAgKF8gPT4ge30pKGNvbW1pdG1lbnRGb3JTdGF0dXMpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXN1bHQgPSB7XG4gICAgICAgICAgICBjb250ZXh0OiBzaWduYXR1cmVTdGF0dXMuY29udGV4dCxcbiAgICAgICAgICAgIHZhbHVlOiB7XG4gICAgICAgICAgICAgIGVycjogc2lnbmF0dXJlU3RhdHVzLnZhbHVlLmVyclxuICAgICAgICAgICAgfVxuICAgICAgICAgIH07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFRyYW5zYWN0aW9uRXhwaXJlZE5vbmNlSW52YWxpZEVycm9yKHNpZ25hdHVyZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGZpbmFsbHkge1xuICAgICAgZG9uZSA9IHRydWU7XG4gICAgICBhYm9ydENvbmZpcm1hdGlvbigpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG4gIGFzeW5jIGNvbmZpcm1UcmFuc2FjdGlvblVzaW5nTGVnYWN5VGltZW91dFN0cmF0ZWd5KHtcbiAgICBjb21taXRtZW50LFxuICAgIHNpZ25hdHVyZVxuICB9KSB7XG4gICAgbGV0IHRpbWVvdXRJZDtcbiAgICBjb25zdCBleHBpcnlQcm9taXNlID0gbmV3IFByb21pc2UocmVzb2x2ZSA9PiB7XG4gICAgICBsZXQgdGltZW91dE1zID0gdGhpcy5fY29uZmlybVRyYW5zYWN0aW9uSW5pdGlhbFRpbWVvdXQgfHwgNjAgKiAxMDAwO1xuICAgICAgc3dpdGNoIChjb21taXRtZW50KSB7XG4gICAgICAgIGNhc2UgJ3Byb2Nlc3NlZCc6XG4gICAgICAgIGNhc2UgJ3JlY2VudCc6XG4gICAgICAgIGNhc2UgJ3NpbmdsZSc6XG4gICAgICAgIGNhc2UgJ2NvbmZpcm1lZCc6XG4gICAgICAgIGNhc2UgJ3NpbmdsZUdvc3NpcCc6XG4gICAgICAgICAge1xuICAgICAgICAgICAgdGltZW91dE1zID0gdGhpcy5fY29uZmlybVRyYW5zYWN0aW9uSW5pdGlhbFRpbWVvdXQgfHwgMzAgKiAxMDAwO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgfVxuICAgICAgdGltZW91dElkID0gc2V0VGltZW91dCgoKSA9PiByZXNvbHZlKHtcbiAgICAgICAgX190eXBlOiBUcmFuc2FjdGlvblN0YXR1cy5USU1FRF9PVVQsXG4gICAgICAgIHRpbWVvdXRNc1xuICAgICAgfSksIHRpbWVvdXRNcyk7XG4gICAgfSk7XG4gICAgY29uc3Qge1xuICAgICAgYWJvcnRDb25maXJtYXRpb24sXG4gICAgICBjb25maXJtYXRpb25Qcm9taXNlXG4gICAgfSA9IHRoaXMuZ2V0VHJhbnNhY3Rpb25Db25maXJtYXRpb25Qcm9taXNlKHtcbiAgICAgIGNvbW1pdG1lbnQsXG4gICAgICBzaWduYXR1cmVcbiAgICB9KTtcbiAgICBsZXQgcmVzdWx0O1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBvdXRjb21lID0gYXdhaXQgUHJvbWlzZS5yYWNlKFtjb25maXJtYXRpb25Qcm9taXNlLCBleHBpcnlQcm9taXNlXSk7XG4gICAgICBpZiAob3V0Y29tZS5fX3R5cGUgPT09IFRyYW5zYWN0aW9uU3RhdHVzLlBST0NFU1NFRCkge1xuICAgICAgICByZXN1bHQgPSBvdXRjb21lLnJlc3BvbnNlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IFRyYW5zYWN0aW9uRXhwaXJlZFRpbWVvdXRFcnJvcihzaWduYXR1cmUsIG91dGNvbWUudGltZW91dE1zIC8gMTAwMCk7XG4gICAgICB9XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0SWQpO1xuICAgICAgYWJvcnRDb25maXJtYXRpb24oKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gdGhlIGxpc3Qgb2Ygbm9kZXMgdGhhdCBhcmUgY3VycmVudGx5IHBhcnRpY2lwYXRpbmcgaW4gdGhlIGNsdXN0ZXJcbiAgICovXG4gIGFzeW5jIGdldENsdXN0ZXJOb2RlcygpIHtcbiAgICBjb25zdCB1bnNhZmVSZXMgPSBhd2FpdCB0aGlzLl9ycGNSZXF1ZXN0KCdnZXRDbHVzdGVyTm9kZXMnLCBbXSk7XG4gICAgY29uc3QgcmVzID0gY3JlYXRlKHVuc2FmZVJlcywganNvblJwY1Jlc3VsdChhcnJheShDb250YWN0SW5mb1Jlc3VsdCkpKTtcbiAgICBpZiAoJ2Vycm9yJyBpbiByZXMpIHtcbiAgICAgIHRocm93IG5ldyBTb2xhbmFKU09OUlBDRXJyb3IocmVzLmVycm9yLCAnZmFpbGVkIHRvIGdldCBjbHVzdGVyIG5vZGVzJyk7XG4gICAgfVxuICAgIHJldHVybiByZXMucmVzdWx0O1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiB0aGUgbGlzdCBvZiBub2RlcyB0aGF0IGFyZSBjdXJyZW50bHkgcGFydGljaXBhdGluZyBpbiB0aGUgY2x1c3RlclxuICAgKi9cbiAgYXN5bmMgZ2V0Vm90ZUFjY291bnRzKGNvbW1pdG1lbnQpIHtcbiAgICBjb25zdCBhcmdzID0gdGhpcy5fYnVpbGRBcmdzKFtdLCBjb21taXRtZW50KTtcbiAgICBjb25zdCB1bnNhZmVSZXMgPSBhd2FpdCB0aGlzLl9ycGNSZXF1ZXN0KCdnZXRWb3RlQWNjb3VudHMnLCBhcmdzKTtcbiAgICBjb25zdCByZXMgPSBjcmVhdGUodW5zYWZlUmVzLCBHZXRWb3RlQWNjb3VudHMpO1xuICAgIGlmICgnZXJyb3InIGluIHJlcykge1xuICAgICAgdGhyb3cgbmV3IFNvbGFuYUpTT05SUENFcnJvcihyZXMuZXJyb3IsICdmYWlsZWQgdG8gZ2V0IHZvdGUgYWNjb3VudHMnKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlcy5yZXN1bHQ7XG4gIH1cblxuICAvKipcbiAgICogRmV0Y2ggdGhlIGN1cnJlbnQgc2xvdCB0aGF0IHRoZSBub2RlIGlzIHByb2Nlc3NpbmdcbiAgICovXG4gIGFzeW5jIGdldFNsb3QoY29tbWl0bWVudE9yQ29uZmlnKSB7XG4gICAgY29uc3Qge1xuICAgICAgY29tbWl0bWVudCxcbiAgICAgIGNvbmZpZ1xuICAgIH0gPSBleHRyYWN0Q29tbWl0bWVudEZyb21Db25maWcoY29tbWl0bWVudE9yQ29uZmlnKTtcbiAgICBjb25zdCBhcmdzID0gdGhpcy5fYnVpbGRBcmdzKFtdLCBjb21taXRtZW50LCB1bmRlZmluZWQgLyogZW5jb2RpbmcgKi8sIGNvbmZpZyk7XG4gICAgY29uc3QgdW5zYWZlUmVzID0gYXdhaXQgdGhpcy5fcnBjUmVxdWVzdCgnZ2V0U2xvdCcsIGFyZ3MpO1xuICAgIGNvbnN0IHJlcyA9IGNyZWF0ZSh1bnNhZmVSZXMsIGpzb25ScGNSZXN1bHQobnVtYmVyKCkpKTtcbiAgICBpZiAoJ2Vycm9yJyBpbiByZXMpIHtcbiAgICAgIHRocm93IG5ldyBTb2xhbmFKU09OUlBDRXJyb3IocmVzLmVycm9yLCAnZmFpbGVkIHRvIGdldCBzbG90Jyk7XG4gICAgfVxuICAgIHJldHVybiByZXMucmVzdWx0O1xuICB9XG5cbiAgLyoqXG4gICAqIEZldGNoIHRoZSBjdXJyZW50IHNsb3QgbGVhZGVyIG9mIHRoZSBjbHVzdGVyXG4gICAqL1xuICBhc3luYyBnZXRTbG90TGVhZGVyKGNvbW1pdG1lbnRPckNvbmZpZykge1xuICAgIGNvbnN0IHtcbiAgICAgIGNvbW1pdG1lbnQsXG4gICAgICBjb25maWdcbiAgICB9ID0gZXh0cmFjdENvbW1pdG1lbnRGcm9tQ29uZmlnKGNvbW1pdG1lbnRPckNvbmZpZyk7XG4gICAgY29uc3QgYXJncyA9IHRoaXMuX2J1aWxkQXJncyhbXSwgY29tbWl0bWVudCwgdW5kZWZpbmVkIC8qIGVuY29kaW5nICovLCBjb25maWcpO1xuICAgIGNvbnN0IHVuc2FmZVJlcyA9IGF3YWl0IHRoaXMuX3JwY1JlcXVlc3QoJ2dldFNsb3RMZWFkZXInLCBhcmdzKTtcbiAgICBjb25zdCByZXMgPSBjcmVhdGUodW5zYWZlUmVzLCBqc29uUnBjUmVzdWx0KHN0cmluZygpKSk7XG4gICAgaWYgKCdlcnJvcicgaW4gcmVzKSB7XG4gICAgICB0aHJvdyBuZXcgU29sYW5hSlNPTlJQQ0Vycm9yKHJlcy5lcnJvciwgJ2ZhaWxlZCB0byBnZXQgc2xvdCBsZWFkZXInKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlcy5yZXN1bHQ7XG4gIH1cblxuICAvKipcbiAgICogRmV0Y2ggYGxpbWl0YCBudW1iZXIgb2Ygc2xvdCBsZWFkZXJzIHN0YXJ0aW5nIGZyb20gYHN0YXJ0U2xvdGBcbiAgICpcbiAgICogQHBhcmFtIHN0YXJ0U2xvdCBmZXRjaCBzbG90IGxlYWRlcnMgc3RhcnRpbmcgZnJvbSB0aGlzIHNsb3RcbiAgICogQHBhcmFtIGxpbWl0IG51bWJlciBvZiBzbG90IGxlYWRlcnMgdG8gcmV0dXJuXG4gICAqL1xuICBhc3luYyBnZXRTbG90TGVhZGVycyhzdGFydFNsb3QsIGxpbWl0KSB7XG4gICAgY29uc3QgYXJncyA9IFtzdGFydFNsb3QsIGxpbWl0XTtcbiAgICBjb25zdCB1bnNhZmVSZXMgPSBhd2FpdCB0aGlzLl9ycGNSZXF1ZXN0KCdnZXRTbG90TGVhZGVycycsIGFyZ3MpO1xuICAgIGNvbnN0IHJlcyA9IGNyZWF0ZSh1bnNhZmVSZXMsIGpzb25ScGNSZXN1bHQoYXJyYXkoUHVibGljS2V5RnJvbVN0cmluZykpKTtcbiAgICBpZiAoJ2Vycm9yJyBpbiByZXMpIHtcbiAgICAgIHRocm93IG5ldyBTb2xhbmFKU09OUlBDRXJyb3IocmVzLmVycm9yLCAnZmFpbGVkIHRvIGdldCBzbG90IGxlYWRlcnMnKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlcy5yZXN1bHQ7XG4gIH1cblxuICAvKipcbiAgICogRmV0Y2ggdGhlIGN1cnJlbnQgc3RhdHVzIG9mIGEgc2lnbmF0dXJlXG4gICAqL1xuICBhc3luYyBnZXRTaWduYXR1cmVTdGF0dXMoc2lnbmF0dXJlLCBjb25maWcpIHtcbiAgICBjb25zdCB7XG4gICAgICBjb250ZXh0LFxuICAgICAgdmFsdWU6IHZhbHVlc1xuICAgIH0gPSBhd2FpdCB0aGlzLmdldFNpZ25hdHVyZVN0YXR1c2VzKFtzaWduYXR1cmVdLCBjb25maWcpO1xuICAgIGFzc2VydCh2YWx1ZXMubGVuZ3RoID09PSAxKTtcbiAgICBjb25zdCB2YWx1ZSA9IHZhbHVlc1swXTtcbiAgICByZXR1cm4ge1xuICAgICAgY29udGV4dCxcbiAgICAgIHZhbHVlXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBGZXRjaCB0aGUgY3VycmVudCBzdGF0dXNlcyBvZiBhIGJhdGNoIG9mIHNpZ25hdHVyZXNcbiAgICovXG4gIGFzeW5jIGdldFNpZ25hdHVyZVN0YXR1c2VzKHNpZ25hdHVyZXMsIGNvbmZpZykge1xuICAgIGNvbnN0IHBhcmFtcyA9IFtzaWduYXR1cmVzXTtcbiAgICBpZiAoY29uZmlnKSB7XG4gICAgICBwYXJhbXMucHVzaChjb25maWcpO1xuICAgIH1cbiAgICBjb25zdCB1bnNhZmVSZXMgPSBhd2FpdCB0aGlzLl9ycGNSZXF1ZXN0KCdnZXRTaWduYXR1cmVTdGF0dXNlcycsIHBhcmFtcyk7XG4gICAgY29uc3QgcmVzID0gY3JlYXRlKHVuc2FmZVJlcywgR2V0U2lnbmF0dXJlU3RhdHVzZXNScGNSZXN1bHQpO1xuICAgIGlmICgnZXJyb3InIGluIHJlcykge1xuICAgICAgdGhyb3cgbmV3IFNvbGFuYUpTT05SUENFcnJvcihyZXMuZXJyb3IsICdmYWlsZWQgdG8gZ2V0IHNpZ25hdHVyZSBzdGF0dXMnKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlcy5yZXN1bHQ7XG4gIH1cblxuICAvKipcbiAgICogRmV0Y2ggdGhlIGN1cnJlbnQgdHJhbnNhY3Rpb24gY291bnQgb2YgdGhlIGNsdXN0ZXJcbiAgICovXG4gIGFzeW5jIGdldFRyYW5zYWN0aW9uQ291bnQoY29tbWl0bWVudE9yQ29uZmlnKSB7XG4gICAgY29uc3Qge1xuICAgICAgY29tbWl0bWVudCxcbiAgICAgIGNvbmZpZ1xuICAgIH0gPSBleHRyYWN0Q29tbWl0bWVudEZyb21Db25maWcoY29tbWl0bWVudE9yQ29uZmlnKTtcbiAgICBjb25zdCBhcmdzID0gdGhpcy5fYnVpbGRBcmdzKFtdLCBjb21taXRtZW50LCB1bmRlZmluZWQgLyogZW5jb2RpbmcgKi8sIGNvbmZpZyk7XG4gICAgY29uc3QgdW5zYWZlUmVzID0gYXdhaXQgdGhpcy5fcnBjUmVxdWVzdCgnZ2V0VHJhbnNhY3Rpb25Db3VudCcsIGFyZ3MpO1xuICAgIGNvbnN0IHJlcyA9IGNyZWF0ZSh1bnNhZmVSZXMsIGpzb25ScGNSZXN1bHQobnVtYmVyKCkpKTtcbiAgICBpZiAoJ2Vycm9yJyBpbiByZXMpIHtcbiAgICAgIHRocm93IG5ldyBTb2xhbmFKU09OUlBDRXJyb3IocmVzLmVycm9yLCAnZmFpbGVkIHRvIGdldCB0cmFuc2FjdGlvbiBjb3VudCcpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzLnJlc3VsdDtcbiAgfVxuXG4gIC8qKlxuICAgKiBGZXRjaCB0aGUgY3VycmVudCB0b3RhbCBjdXJyZW5jeSBzdXBwbHkgb2YgdGhlIGNsdXN0ZXIgaW4gbGFtcG9ydHNcbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgRGVwcmVjYXRlZCBzaW5jZSB2MS4yLjguIFBsZWFzZSB1c2Uge0BsaW5rIGdldFN1cHBseX0gaW5zdGVhZC5cbiAgICovXG4gIGFzeW5jIGdldFRvdGFsU3VwcGx5KGNvbW1pdG1lbnQpIHtcbiAgICBjb25zdCByZXN1bHQgPSBhd2FpdCB0aGlzLmdldFN1cHBseSh7XG4gICAgICBjb21taXRtZW50LFxuICAgICAgZXhjbHVkZU5vbkNpcmN1bGF0aW5nQWNjb3VudHNMaXN0OiB0cnVlXG4gICAgfSk7XG4gICAgcmV0dXJuIHJlc3VsdC52YWx1ZS50b3RhbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBGZXRjaCB0aGUgY2x1c3RlciBJbmZsYXRpb25Hb3Zlcm5vciBwYXJhbWV0ZXJzXG4gICAqL1xuICBhc3luYyBnZXRJbmZsYXRpb25Hb3Zlcm5vcihjb21taXRtZW50KSB7XG4gICAgY29uc3QgYXJncyA9IHRoaXMuX2J1aWxkQXJncyhbXSwgY29tbWl0bWVudCk7XG4gICAgY29uc3QgdW5zYWZlUmVzID0gYXdhaXQgdGhpcy5fcnBjUmVxdWVzdCgnZ2V0SW5mbGF0aW9uR292ZXJub3InLCBhcmdzKTtcbiAgICBjb25zdCByZXMgPSBjcmVhdGUodW5zYWZlUmVzLCBHZXRJbmZsYXRpb25Hb3Zlcm5vclJwY1Jlc3VsdCk7XG4gICAgaWYgKCdlcnJvcicgaW4gcmVzKSB7XG4gICAgICB0aHJvdyBuZXcgU29sYW5hSlNPTlJQQ0Vycm9yKHJlcy5lcnJvciwgJ2ZhaWxlZCB0byBnZXQgaW5mbGF0aW9uJyk7XG4gICAgfVxuICAgIHJldHVybiByZXMucmVzdWx0O1xuICB9XG5cbiAgLyoqXG4gICAqIEZldGNoIHRoZSBpbmZsYXRpb24gcmV3YXJkIGZvciBhIGxpc3Qgb2YgYWRkcmVzc2VzIGZvciBhbiBlcG9jaFxuICAgKi9cbiAgYXN5bmMgZ2V0SW5mbGF0aW9uUmV3YXJkKGFkZHJlc3NlcywgZXBvY2gsIGNvbW1pdG1lbnRPckNvbmZpZykge1xuICAgIGNvbnN0IHtcbiAgICAgIGNvbW1pdG1lbnQsXG4gICAgICBjb25maWdcbiAgICB9ID0gZXh0cmFjdENvbW1pdG1lbnRGcm9tQ29uZmlnKGNvbW1pdG1lbnRPckNvbmZpZyk7XG4gICAgY29uc3QgYXJncyA9IHRoaXMuX2J1aWxkQXJncyhbYWRkcmVzc2VzLm1hcChwdWJrZXkgPT4gcHVia2V5LnRvQmFzZTU4KCkpXSwgY29tbWl0bWVudCwgdW5kZWZpbmVkIC8qIGVuY29kaW5nICovLCB7XG4gICAgICAuLi5jb25maWcsXG4gICAgICBlcG9jaDogZXBvY2ggIT0gbnVsbCA/IGVwb2NoIDogY29uZmlnPy5lcG9jaFxuICAgIH0pO1xuICAgIGNvbnN0IHVuc2FmZVJlcyA9IGF3YWl0IHRoaXMuX3JwY1JlcXVlc3QoJ2dldEluZmxhdGlvblJld2FyZCcsIGFyZ3MpO1xuICAgIGNvbnN0IHJlcyA9IGNyZWF0ZSh1bnNhZmVSZXMsIEdldEluZmxhdGlvblJld2FyZFJlc3VsdCk7XG4gICAgaWYgKCdlcnJvcicgaW4gcmVzKSB7XG4gICAgICB0aHJvdyBuZXcgU29sYW5hSlNPTlJQQ0Vycm9yKHJlcy5lcnJvciwgJ2ZhaWxlZCB0byBnZXQgaW5mbGF0aW9uIHJld2FyZCcpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzLnJlc3VsdDtcbiAgfVxuXG4gIC8qKlxuICAgKiBGZXRjaCB0aGUgc3BlY2lmaWMgaW5mbGF0aW9uIHZhbHVlcyBmb3IgdGhlIGN1cnJlbnQgZXBvY2hcbiAgICovXG4gIGFzeW5jIGdldEluZmxhdGlvblJhdGUoKSB7XG4gICAgY29uc3QgdW5zYWZlUmVzID0gYXdhaXQgdGhpcy5fcnBjUmVxdWVzdCgnZ2V0SW5mbGF0aW9uUmF0ZScsIFtdKTtcbiAgICBjb25zdCByZXMgPSBjcmVhdGUodW5zYWZlUmVzLCBHZXRJbmZsYXRpb25SYXRlUnBjUmVzdWx0KTtcbiAgICBpZiAoJ2Vycm9yJyBpbiByZXMpIHtcbiAgICAgIHRocm93IG5ldyBTb2xhbmFKU09OUlBDRXJyb3IocmVzLmVycm9yLCAnZmFpbGVkIHRvIGdldCBpbmZsYXRpb24gcmF0ZScpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzLnJlc3VsdDtcbiAgfVxuXG4gIC8qKlxuICAgKiBGZXRjaCB0aGUgRXBvY2ggSW5mbyBwYXJhbWV0ZXJzXG4gICAqL1xuICBhc3luYyBnZXRFcG9jaEluZm8oY29tbWl0bWVudE9yQ29uZmlnKSB7XG4gICAgY29uc3Qge1xuICAgICAgY29tbWl0bWVudCxcbiAgICAgIGNvbmZpZ1xuICAgIH0gPSBleHRyYWN0Q29tbWl0bWVudEZyb21Db25maWcoY29tbWl0bWVudE9yQ29uZmlnKTtcbiAgICBjb25zdCBhcmdzID0gdGhpcy5fYnVpbGRBcmdzKFtdLCBjb21taXRtZW50LCB1bmRlZmluZWQgLyogZW5jb2RpbmcgKi8sIGNvbmZpZyk7XG4gICAgY29uc3QgdW5zYWZlUmVzID0gYXdhaXQgdGhpcy5fcnBjUmVxdWVzdCgnZ2V0RXBvY2hJbmZvJywgYXJncyk7XG4gICAgY29uc3QgcmVzID0gY3JlYXRlKHVuc2FmZVJlcywgR2V0RXBvY2hJbmZvUnBjUmVzdWx0KTtcbiAgICBpZiAoJ2Vycm9yJyBpbiByZXMpIHtcbiAgICAgIHRocm93IG5ldyBTb2xhbmFKU09OUlBDRXJyb3IocmVzLmVycm9yLCAnZmFpbGVkIHRvIGdldCBlcG9jaCBpbmZvJyk7XG4gICAgfVxuICAgIHJldHVybiByZXMucmVzdWx0O1xuICB9XG5cbiAgLyoqXG4gICAqIEZldGNoIHRoZSBFcG9jaCBTY2hlZHVsZSBwYXJhbWV0ZXJzXG4gICAqL1xuICBhc3luYyBnZXRFcG9jaFNjaGVkdWxlKCkge1xuICAgIGNvbnN0IHVuc2FmZVJlcyA9IGF3YWl0IHRoaXMuX3JwY1JlcXVlc3QoJ2dldEVwb2NoU2NoZWR1bGUnLCBbXSk7XG4gICAgY29uc3QgcmVzID0gY3JlYXRlKHVuc2FmZVJlcywgR2V0RXBvY2hTY2hlZHVsZVJwY1Jlc3VsdCk7XG4gICAgaWYgKCdlcnJvcicgaW4gcmVzKSB7XG4gICAgICB0aHJvdyBuZXcgU29sYW5hSlNPTlJQQ0Vycm9yKHJlcy5lcnJvciwgJ2ZhaWxlZCB0byBnZXQgZXBvY2ggc2NoZWR1bGUnKTtcbiAgICB9XG4gICAgY29uc3QgZXBvY2hTY2hlZHVsZSA9IHJlcy5yZXN1bHQ7XG4gICAgcmV0dXJuIG5ldyBFcG9jaFNjaGVkdWxlKGVwb2NoU2NoZWR1bGUuc2xvdHNQZXJFcG9jaCwgZXBvY2hTY2hlZHVsZS5sZWFkZXJTY2hlZHVsZVNsb3RPZmZzZXQsIGVwb2NoU2NoZWR1bGUud2FybXVwLCBlcG9jaFNjaGVkdWxlLmZpcnN0Tm9ybWFsRXBvY2gsIGVwb2NoU2NoZWR1bGUuZmlyc3ROb3JtYWxTbG90KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBGZXRjaCB0aGUgbGVhZGVyIHNjaGVkdWxlIGZvciB0aGUgY3VycmVudCBlcG9jaFxuICAgKiBAcmV0dXJuIHtQcm9taXNlPFJwY1Jlc3BvbnNlQW5kQ29udGV4dDxMZWFkZXJTY2hlZHVsZT4+fVxuICAgKi9cbiAgYXN5bmMgZ2V0TGVhZGVyU2NoZWR1bGUoKSB7XG4gICAgY29uc3QgdW5zYWZlUmVzID0gYXdhaXQgdGhpcy5fcnBjUmVxdWVzdCgnZ2V0TGVhZGVyU2NoZWR1bGUnLCBbXSk7XG4gICAgY29uc3QgcmVzID0gY3JlYXRlKHVuc2FmZVJlcywgR2V0TGVhZGVyU2NoZWR1bGVScGNSZXN1bHQpO1xuICAgIGlmICgnZXJyb3InIGluIHJlcykge1xuICAgICAgdGhyb3cgbmV3IFNvbGFuYUpTT05SUENFcnJvcihyZXMuZXJyb3IsICdmYWlsZWQgdG8gZ2V0IGxlYWRlciBzY2hlZHVsZScpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzLnJlc3VsdDtcbiAgfVxuXG4gIC8qKlxuICAgKiBGZXRjaCB0aGUgbWluaW11bSBiYWxhbmNlIG5lZWRlZCB0byBleGVtcHQgYW4gYWNjb3VudCBvZiBgZGF0YUxlbmd0aGBcbiAgICogc2l6ZSBmcm9tIHJlbnRcbiAgICovXG4gIGFzeW5jIGdldE1pbmltdW1CYWxhbmNlRm9yUmVudEV4ZW1wdGlvbihkYXRhTGVuZ3RoLCBjb21taXRtZW50KSB7XG4gICAgY29uc3QgYXJncyA9IHRoaXMuX2J1aWxkQXJncyhbZGF0YUxlbmd0aF0sIGNvbW1pdG1lbnQpO1xuICAgIGNvbnN0IHVuc2FmZVJlcyA9IGF3YWl0IHRoaXMuX3JwY1JlcXVlc3QoJ2dldE1pbmltdW1CYWxhbmNlRm9yUmVudEV4ZW1wdGlvbicsIGFyZ3MpO1xuICAgIGNvbnN0IHJlcyA9IGNyZWF0ZSh1bnNhZmVSZXMsIEdldE1pbmltdW1CYWxhbmNlRm9yUmVudEV4ZW1wdGlvblJwY1Jlc3VsdCk7XG4gICAgaWYgKCdlcnJvcicgaW4gcmVzKSB7XG4gICAgICBjb25zb2xlLndhcm4oJ1VuYWJsZSB0byBmZXRjaCBtaW5pbXVtIGJhbGFuY2UgZm9yIHJlbnQgZXhlbXB0aW9uJyk7XG4gICAgICByZXR1cm4gMDtcbiAgICB9XG4gICAgcmV0dXJuIHJlcy5yZXN1bHQ7XG4gIH1cblxuICAvKipcbiAgICogRmV0Y2ggYSByZWNlbnQgYmxvY2toYXNoIGZyb20gdGhlIGNsdXN0ZXIsIHJldHVybiB3aXRoIGNvbnRleHRcbiAgICogQHJldHVybiB7UHJvbWlzZTxScGNSZXNwb25zZUFuZENvbnRleHQ8e2Jsb2NraGFzaDogQmxvY2toYXNoLCBmZWVDYWxjdWxhdG9yOiBGZWVDYWxjdWxhdG9yfT4+fVxuICAgKlxuICAgKiBAZGVwcmVjYXRlZCBEZXByZWNhdGVkIHNpbmNlIFNvbGFuYSB2MS44LjAuIFBsZWFzZSB1c2Uge0BsaW5rIGdldExhdGVzdEJsb2NraGFzaH0gaW5zdGVhZC5cbiAgICovXG4gIGFzeW5jIGdldFJlY2VudEJsb2NraGFzaEFuZENvbnRleHQoY29tbWl0bWVudCkge1xuICAgIGNvbnN0IGFyZ3MgPSB0aGlzLl9idWlsZEFyZ3MoW10sIGNvbW1pdG1lbnQpO1xuICAgIGNvbnN0IHVuc2FmZVJlcyA9IGF3YWl0IHRoaXMuX3JwY1JlcXVlc3QoJ2dldFJlY2VudEJsb2NraGFzaCcsIGFyZ3MpO1xuICAgIGNvbnN0IHJlcyA9IGNyZWF0ZSh1bnNhZmVSZXMsIEdldFJlY2VudEJsb2NraGFzaEFuZENvbnRleHRScGNSZXN1bHQpO1xuICAgIGlmICgnZXJyb3InIGluIHJlcykge1xuICAgICAgdGhyb3cgbmV3IFNvbGFuYUpTT05SUENFcnJvcihyZXMuZXJyb3IsICdmYWlsZWQgdG8gZ2V0IHJlY2VudCBibG9ja2hhc2gnKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlcy5yZXN1bHQ7XG4gIH1cblxuICAvKipcbiAgICogRmV0Y2ggcmVjZW50IHBlcmZvcm1hbmNlIHNhbXBsZXNcbiAgICogQHJldHVybiB7UHJvbWlzZTxBcnJheTxQZXJmU2FtcGxlPj59XG4gICAqL1xuICBhc3luYyBnZXRSZWNlbnRQZXJmb3JtYW5jZVNhbXBsZXMobGltaXQpIHtcbiAgICBjb25zdCB1bnNhZmVSZXMgPSBhd2FpdCB0aGlzLl9ycGNSZXF1ZXN0KCdnZXRSZWNlbnRQZXJmb3JtYW5jZVNhbXBsZXMnLCBsaW1pdCA/IFtsaW1pdF0gOiBbXSk7XG4gICAgY29uc3QgcmVzID0gY3JlYXRlKHVuc2FmZVJlcywgR2V0UmVjZW50UGVyZm9ybWFuY2VTYW1wbGVzUnBjUmVzdWx0KTtcbiAgICBpZiAoJ2Vycm9yJyBpbiByZXMpIHtcbiAgICAgIHRocm93IG5ldyBTb2xhbmFKU09OUlBDRXJyb3IocmVzLmVycm9yLCAnZmFpbGVkIHRvIGdldCByZWNlbnQgcGVyZm9ybWFuY2Ugc2FtcGxlcycpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzLnJlc3VsdDtcbiAgfVxuXG4gIC8qKlxuICAgKiBGZXRjaCB0aGUgZmVlIGNhbGN1bGF0b3IgZm9yIGEgcmVjZW50IGJsb2NraGFzaCBmcm9tIHRoZSBjbHVzdGVyLCByZXR1cm4gd2l0aCBjb250ZXh0XG4gICAqXG4gICAqIEBkZXByZWNhdGVkIERlcHJlY2F0ZWQgc2luY2UgU29sYW5hIHYxLjguMC4gUGxlYXNlIHVzZSB7QGxpbmsgZ2V0RmVlRm9yTWVzc2FnZX0gaW5zdGVhZC5cbiAgICovXG4gIGFzeW5jIGdldEZlZUNhbGN1bGF0b3JGb3JCbG9ja2hhc2goYmxvY2toYXNoLCBjb21taXRtZW50KSB7XG4gICAgY29uc3QgYXJncyA9IHRoaXMuX2J1aWxkQXJncyhbYmxvY2toYXNoXSwgY29tbWl0bWVudCk7XG4gICAgY29uc3QgdW5zYWZlUmVzID0gYXdhaXQgdGhpcy5fcnBjUmVxdWVzdCgnZ2V0RmVlQ2FsY3VsYXRvckZvckJsb2NraGFzaCcsIGFyZ3MpO1xuICAgIGNvbnN0IHJlcyA9IGNyZWF0ZSh1bnNhZmVSZXMsIEdldEZlZUNhbGN1bGF0b3JScGNSZXN1bHQpO1xuICAgIGlmICgnZXJyb3InIGluIHJlcykge1xuICAgICAgdGhyb3cgbmV3IFNvbGFuYUpTT05SUENFcnJvcihyZXMuZXJyb3IsICdmYWlsZWQgdG8gZ2V0IGZlZSBjYWxjdWxhdG9yJyk7XG4gICAgfVxuICAgIGNvbnN0IHtcbiAgICAgIGNvbnRleHQsXG4gICAgICB2YWx1ZVxuICAgIH0gPSByZXMucmVzdWx0O1xuICAgIHJldHVybiB7XG4gICAgICBjb250ZXh0LFxuICAgICAgdmFsdWU6IHZhbHVlICE9PSBudWxsID8gdmFsdWUuZmVlQ2FsY3VsYXRvciA6IG51bGxcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIEZldGNoIHRoZSBmZWUgZm9yIGEgbWVzc2FnZSBmcm9tIHRoZSBjbHVzdGVyLCByZXR1cm4gd2l0aCBjb250ZXh0XG4gICAqL1xuICBhc3luYyBnZXRGZWVGb3JNZXNzYWdlKG1lc3NhZ2UsIGNvbW1pdG1lbnQpIHtcbiAgICBjb25zdCB3aXJlTWVzc2FnZSA9IHRvQnVmZmVyKG1lc3NhZ2Uuc2VyaWFsaXplKCkpLnRvU3RyaW5nKCdiYXNlNjQnKTtcbiAgICBjb25zdCBhcmdzID0gdGhpcy5fYnVpbGRBcmdzKFt3aXJlTWVzc2FnZV0sIGNvbW1pdG1lbnQpO1xuICAgIGNvbnN0IHVuc2FmZVJlcyA9IGF3YWl0IHRoaXMuX3JwY1JlcXVlc3QoJ2dldEZlZUZvck1lc3NhZ2UnLCBhcmdzKTtcbiAgICBjb25zdCByZXMgPSBjcmVhdGUodW5zYWZlUmVzLCBqc29uUnBjUmVzdWx0QW5kQ29udGV4dChudWxsYWJsZShudW1iZXIoKSkpKTtcbiAgICBpZiAoJ2Vycm9yJyBpbiByZXMpIHtcbiAgICAgIHRocm93IG5ldyBTb2xhbmFKU09OUlBDRXJyb3IocmVzLmVycm9yLCAnZmFpbGVkIHRvIGdldCBmZWUgZm9yIG1lc3NhZ2UnKTtcbiAgICB9XG4gICAgaWYgKHJlcy5yZXN1bHQgPT09IG51bGwpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBibG9ja2hhc2gnKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlcy5yZXN1bHQ7XG4gIH1cblxuICAvKipcbiAgICogRmV0Y2ggYSBsaXN0IG9mIHByaW9yaXRpemF0aW9uIGZlZXMgZnJvbSByZWNlbnQgYmxvY2tzLlxuICAgKi9cbiAgYXN5bmMgZ2V0UmVjZW50UHJpb3JpdGl6YXRpb25GZWVzKGNvbmZpZykge1xuICAgIGNvbnN0IGFjY291bnRzID0gY29uZmlnPy5sb2NrZWRXcml0YWJsZUFjY291bnRzPy5tYXAoa2V5ID0+IGtleS50b0Jhc2U1OCgpKTtcbiAgICBjb25zdCBhcmdzID0gYWNjb3VudHM/Lmxlbmd0aCA/IFthY2NvdW50c10gOiBbXTtcbiAgICBjb25zdCB1bnNhZmVSZXMgPSBhd2FpdCB0aGlzLl9ycGNSZXF1ZXN0KCdnZXRSZWNlbnRQcmlvcml0aXphdGlvbkZlZXMnLCBhcmdzKTtcbiAgICBjb25zdCByZXMgPSBjcmVhdGUodW5zYWZlUmVzLCBHZXRSZWNlbnRQcmlvcml0aXphdGlvbkZlZXNScGNSZXN1bHQpO1xuICAgIGlmICgnZXJyb3InIGluIHJlcykge1xuICAgICAgdGhyb3cgbmV3IFNvbGFuYUpTT05SUENFcnJvcihyZXMuZXJyb3IsICdmYWlsZWQgdG8gZ2V0IHJlY2VudCBwcmlvcml0aXphdGlvbiBmZWVzJyk7XG4gICAgfVxuICAgIHJldHVybiByZXMucmVzdWx0O1xuICB9XG4gIC8qKlxuICAgKiBGZXRjaCBhIHJlY2VudCBibG9ja2hhc2ggZnJvbSB0aGUgY2x1c3RlclxuICAgKiBAcmV0dXJuIHtQcm9taXNlPHtibG9ja2hhc2g6IEJsb2NraGFzaCwgZmVlQ2FsY3VsYXRvcjogRmVlQ2FsY3VsYXRvcn0+fVxuICAgKlxuICAgKiBAZGVwcmVjYXRlZCBEZXByZWNhdGVkIHNpbmNlIFNvbGFuYSB2MS44LjAuIFBsZWFzZSB1c2Uge0BsaW5rIGdldExhdGVzdEJsb2NraGFzaH0gaW5zdGVhZC5cbiAgICovXG4gIGFzeW5jIGdldFJlY2VudEJsb2NraGFzaChjb21taXRtZW50KSB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHJlcyA9IGF3YWl0IHRoaXMuZ2V0UmVjZW50QmxvY2toYXNoQW5kQ29udGV4dChjb21taXRtZW50KTtcbiAgICAgIHJldHVybiByZXMudmFsdWU7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdmYWlsZWQgdG8gZ2V0IHJlY2VudCBibG9ja2hhc2g6ICcgKyBlKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogRmV0Y2ggdGhlIGxhdGVzdCBibG9ja2hhc2ggZnJvbSB0aGUgY2x1c3RlclxuICAgKiBAcmV0dXJuIHtQcm9taXNlPEJsb2NraGFzaFdpdGhFeHBpcnlCbG9ja0hlaWdodD59XG4gICAqL1xuICBhc3luYyBnZXRMYXRlc3RCbG9ja2hhc2goY29tbWl0bWVudE9yQ29uZmlnKSB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHJlcyA9IGF3YWl0IHRoaXMuZ2V0TGF0ZXN0QmxvY2toYXNoQW5kQ29udGV4dChjb21taXRtZW50T3JDb25maWcpO1xuICAgICAgcmV0dXJuIHJlcy52YWx1ZTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ZhaWxlZCB0byBnZXQgcmVjZW50IGJsb2NraGFzaDogJyArIGUpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBGZXRjaCB0aGUgbGF0ZXN0IGJsb2NraGFzaCBmcm9tIHRoZSBjbHVzdGVyXG4gICAqIEByZXR1cm4ge1Byb21pc2U8QmxvY2toYXNoV2l0aEV4cGlyeUJsb2NrSGVpZ2h0Pn1cbiAgICovXG4gIGFzeW5jIGdldExhdGVzdEJsb2NraGFzaEFuZENvbnRleHQoY29tbWl0bWVudE9yQ29uZmlnKSB7XG4gICAgY29uc3Qge1xuICAgICAgY29tbWl0bWVudCxcbiAgICAgIGNvbmZpZ1xuICAgIH0gPSBleHRyYWN0Q29tbWl0bWVudEZyb21Db25maWcoY29tbWl0bWVudE9yQ29uZmlnKTtcbiAgICBjb25zdCBhcmdzID0gdGhpcy5fYnVpbGRBcmdzKFtdLCBjb21taXRtZW50LCB1bmRlZmluZWQgLyogZW5jb2RpbmcgKi8sIGNvbmZpZyk7XG4gICAgY29uc3QgdW5zYWZlUmVzID0gYXdhaXQgdGhpcy5fcnBjUmVxdWVzdCgnZ2V0TGF0ZXN0QmxvY2toYXNoJywgYXJncyk7XG4gICAgY29uc3QgcmVzID0gY3JlYXRlKHVuc2FmZVJlcywgR2V0TGF0ZXN0QmxvY2toYXNoUnBjUmVzdWx0KTtcbiAgICBpZiAoJ2Vycm9yJyBpbiByZXMpIHtcbiAgICAgIHRocm93IG5ldyBTb2xhbmFKU09OUlBDRXJyb3IocmVzLmVycm9yLCAnZmFpbGVkIHRvIGdldCBsYXRlc3QgYmxvY2toYXNoJyk7XG4gICAgfVxuICAgIHJldHVybiByZXMucmVzdWx0O1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgd2hldGhlciBhIGJsb2NraGFzaCBpcyBzdGlsbCB2YWxpZCBvciBub3RcbiAgICovXG4gIGFzeW5jIGlzQmxvY2toYXNoVmFsaWQoYmxvY2toYXNoLCByYXdDb25maWcpIHtcbiAgICBjb25zdCB7XG4gICAgICBjb21taXRtZW50LFxuICAgICAgY29uZmlnXG4gICAgfSA9IGV4dHJhY3RDb21taXRtZW50RnJvbUNvbmZpZyhyYXdDb25maWcpO1xuICAgIGNvbnN0IGFyZ3MgPSB0aGlzLl9idWlsZEFyZ3MoW2Jsb2NraGFzaF0sIGNvbW1pdG1lbnQsIHVuZGVmaW5lZCAvKiBlbmNvZGluZyAqLywgY29uZmlnKTtcbiAgICBjb25zdCB1bnNhZmVSZXMgPSBhd2FpdCB0aGlzLl9ycGNSZXF1ZXN0KCdpc0Jsb2NraGFzaFZhbGlkJywgYXJncyk7XG4gICAgY29uc3QgcmVzID0gY3JlYXRlKHVuc2FmZVJlcywgSXNCbG9ja2hhc2hWYWxpZFJwY1Jlc3VsdCk7XG4gICAgaWYgKCdlcnJvcicgaW4gcmVzKSB7XG4gICAgICB0aHJvdyBuZXcgU29sYW5hSlNPTlJQQ0Vycm9yKHJlcy5lcnJvciwgJ2ZhaWxlZCB0byBkZXRlcm1pbmUgaWYgdGhlIGJsb2NraGFzaCBgJyArIGJsb2NraGFzaCArICdgaXMgdmFsaWQnKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlcy5yZXN1bHQ7XG4gIH1cblxuICAvKipcbiAgICogRmV0Y2ggdGhlIG5vZGUgdmVyc2lvblxuICAgKi9cbiAgYXN5bmMgZ2V0VmVyc2lvbigpIHtcbiAgICBjb25zdCB1bnNhZmVSZXMgPSBhd2FpdCB0aGlzLl9ycGNSZXF1ZXN0KCdnZXRWZXJzaW9uJywgW10pO1xuICAgIGNvbnN0IHJlcyA9IGNyZWF0ZSh1bnNhZmVSZXMsIGpzb25ScGNSZXN1bHQoVmVyc2lvblJlc3VsdCkpO1xuICAgIGlmICgnZXJyb3InIGluIHJlcykge1xuICAgICAgdGhyb3cgbmV3IFNvbGFuYUpTT05SUENFcnJvcihyZXMuZXJyb3IsICdmYWlsZWQgdG8gZ2V0IHZlcnNpb24nKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlcy5yZXN1bHQ7XG4gIH1cblxuICAvKipcbiAgICogRmV0Y2ggdGhlIGdlbmVzaXMgaGFzaFxuICAgKi9cbiAgYXN5bmMgZ2V0R2VuZXNpc0hhc2goKSB7XG4gICAgY29uc3QgdW5zYWZlUmVzID0gYXdhaXQgdGhpcy5fcnBjUmVxdWVzdCgnZ2V0R2VuZXNpc0hhc2gnLCBbXSk7XG4gICAgY29uc3QgcmVzID0gY3JlYXRlKHVuc2FmZVJlcywganNvblJwY1Jlc3VsdChzdHJpbmcoKSkpO1xuICAgIGlmICgnZXJyb3InIGluIHJlcykge1xuICAgICAgdGhyb3cgbmV3IFNvbGFuYUpTT05SUENFcnJvcihyZXMuZXJyb3IsICdmYWlsZWQgdG8gZ2V0IGdlbmVzaXMgaGFzaCcpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzLnJlc3VsdDtcbiAgfVxuXG4gIC8qKlxuICAgKiBGZXRjaCBhIHByb2Nlc3NlZCBibG9jayBmcm9tIHRoZSBjbHVzdGVyLlxuICAgKlxuICAgKiBAZGVwcmVjYXRlZCBJbnN0ZWFkLCBjYWxsIGBnZXRCbG9ja2AgdXNpbmcgYSBgR2V0VmVyc2lvbmVkQmxvY2tDb25maWdgIGJ5XG4gICAqIHNldHRpbmcgdGhlIGBtYXhTdXBwb3J0ZWRUcmFuc2FjdGlvblZlcnNpb25gIHByb3BlcnR5LlxuICAgKi9cblxuICAvKipcbiAgICogQGRlcHJlY2F0ZWQgSW5zdGVhZCwgY2FsbCBgZ2V0QmxvY2tgIHVzaW5nIGEgYEdldFZlcnNpb25lZEJsb2NrQ29uZmlnYCBieVxuICAgKiBzZXR0aW5nIHRoZSBgbWF4U3VwcG9ydGVkVHJhbnNhY3Rpb25WZXJzaW9uYCBwcm9wZXJ0eS5cbiAgICovXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1kdXBlLWNsYXNzLW1lbWJlcnNcblxuICAvKipcbiAgICogQGRlcHJlY2F0ZWQgSW5zdGVhZCwgY2FsbCBgZ2V0QmxvY2tgIHVzaW5nIGEgYEdldFZlcnNpb25lZEJsb2NrQ29uZmlnYCBieVxuICAgKiBzZXR0aW5nIHRoZSBgbWF4U3VwcG9ydGVkVHJhbnNhY3Rpb25WZXJzaW9uYCBwcm9wZXJ0eS5cbiAgICovXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1kdXBlLWNsYXNzLW1lbWJlcnNcblxuICAvKipcbiAgICogRmV0Y2ggYSBwcm9jZXNzZWQgYmxvY2sgZnJvbSB0aGUgY2x1c3Rlci5cbiAgICovXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1kdXBlLWNsYXNzLW1lbWJlcnNcblxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tZHVwZS1jbGFzcy1tZW1iZXJzXG5cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWR1cGUtY2xhc3MtbWVtYmVyc1xuXG4gIC8qKlxuICAgKiBGZXRjaCBhIHByb2Nlc3NlZCBibG9jayBmcm9tIHRoZSBjbHVzdGVyLlxuICAgKi9cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWR1cGUtY2xhc3MtbWVtYmVyc1xuICBhc3luYyBnZXRCbG9jayhzbG90LCByYXdDb25maWcpIHtcbiAgICBjb25zdCB7XG4gICAgICBjb21taXRtZW50LFxuICAgICAgY29uZmlnXG4gICAgfSA9IGV4dHJhY3RDb21taXRtZW50RnJvbUNvbmZpZyhyYXdDb25maWcpO1xuICAgIGNvbnN0IGFyZ3MgPSB0aGlzLl9idWlsZEFyZ3NBdExlYXN0Q29uZmlybWVkKFtzbG90XSwgY29tbWl0bWVudCwgdW5kZWZpbmVkIC8qIGVuY29kaW5nICovLCBjb25maWcpO1xuICAgIGNvbnN0IHVuc2FmZVJlcyA9IGF3YWl0IHRoaXMuX3JwY1JlcXVlc3QoJ2dldEJsb2NrJywgYXJncyk7XG4gICAgdHJ5IHtcbiAgICAgIHN3aXRjaCAoY29uZmlnPy50cmFuc2FjdGlvbkRldGFpbHMpIHtcbiAgICAgICAgY2FzZSAnYWNjb3VudHMnOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGNvbnN0IHJlcyA9IGNyZWF0ZSh1bnNhZmVSZXMsIEdldEFjY291bnRzTW9kZUJsb2NrUnBjUmVzdWx0KTtcbiAgICAgICAgICAgIGlmICgnZXJyb3InIGluIHJlcykge1xuICAgICAgICAgICAgICB0aHJvdyByZXMuZXJyb3I7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVzLnJlc3VsdDtcbiAgICAgICAgICB9XG4gICAgICAgIGNhc2UgJ25vbmUnOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGNvbnN0IHJlcyA9IGNyZWF0ZSh1bnNhZmVSZXMsIEdldE5vbmVNb2RlQmxvY2tScGNSZXN1bHQpO1xuICAgICAgICAgICAgaWYgKCdlcnJvcicgaW4gcmVzKSB7XG4gICAgICAgICAgICAgIHRocm93IHJlcy5lcnJvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXMucmVzdWx0O1xuICAgICAgICAgIH1cbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICB7XG4gICAgICAgICAgICBjb25zdCByZXMgPSBjcmVhdGUodW5zYWZlUmVzLCBHZXRCbG9ja1JwY1Jlc3VsdCk7XG4gICAgICAgICAgICBpZiAoJ2Vycm9yJyBpbiByZXMpIHtcbiAgICAgICAgICAgICAgdGhyb3cgcmVzLmVycm9yO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3Qge1xuICAgICAgICAgICAgICByZXN1bHRcbiAgICAgICAgICAgIH0gPSByZXM7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0ID8ge1xuICAgICAgICAgICAgICAuLi5yZXN1bHQsXG4gICAgICAgICAgICAgIHRyYW5zYWN0aW9uczogcmVzdWx0LnRyYW5zYWN0aW9ucy5tYXAoKHtcbiAgICAgICAgICAgICAgICB0cmFuc2FjdGlvbixcbiAgICAgICAgICAgICAgICBtZXRhLFxuICAgICAgICAgICAgICAgIHZlcnNpb25cbiAgICAgICAgICAgICAgfSkgPT4gKHtcbiAgICAgICAgICAgICAgICBtZXRhLFxuICAgICAgICAgICAgICAgIHRyYW5zYWN0aW9uOiB7XG4gICAgICAgICAgICAgICAgICAuLi50cmFuc2FjdGlvbixcbiAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IHZlcnNpb25lZE1lc3NhZ2VGcm9tUmVzcG9uc2UodmVyc2lvbiwgdHJhbnNhY3Rpb24ubWVzc2FnZSlcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHZlcnNpb25cbiAgICAgICAgICAgICAgfSkpXG4gICAgICAgICAgICB9IDogbnVsbDtcbiAgICAgICAgICB9XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgdGhyb3cgbmV3IFNvbGFuYUpTT05SUENFcnJvcihlLCAnZmFpbGVkIHRvIGdldCBjb25maXJtZWQgYmxvY2snKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogRmV0Y2ggcGFyc2VkIHRyYW5zYWN0aW9uIGRldGFpbHMgZm9yIGEgY29uZmlybWVkIG9yIGZpbmFsaXplZCBibG9ja1xuICAgKi9cblxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tZHVwZS1jbGFzcy1tZW1iZXJzXG5cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWR1cGUtY2xhc3MtbWVtYmVyc1xuXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1kdXBlLWNsYXNzLW1lbWJlcnNcbiAgYXN5bmMgZ2V0UGFyc2VkQmxvY2soc2xvdCwgcmF3Q29uZmlnKSB7XG4gICAgY29uc3Qge1xuICAgICAgY29tbWl0bWVudCxcbiAgICAgIGNvbmZpZ1xuICAgIH0gPSBleHRyYWN0Q29tbWl0bWVudEZyb21Db25maWcocmF3Q29uZmlnKTtcbiAgICBjb25zdCBhcmdzID0gdGhpcy5fYnVpbGRBcmdzQXRMZWFzdENvbmZpcm1lZChbc2xvdF0sIGNvbW1pdG1lbnQsICdqc29uUGFyc2VkJywgY29uZmlnKTtcbiAgICBjb25zdCB1bnNhZmVSZXMgPSBhd2FpdCB0aGlzLl9ycGNSZXF1ZXN0KCdnZXRCbG9jaycsIGFyZ3MpO1xuICAgIHRyeSB7XG4gICAgICBzd2l0Y2ggKGNvbmZpZz8udHJhbnNhY3Rpb25EZXRhaWxzKSB7XG4gICAgICAgIGNhc2UgJ2FjY291bnRzJzpcbiAgICAgICAgICB7XG4gICAgICAgICAgICBjb25zdCByZXMgPSBjcmVhdGUodW5zYWZlUmVzLCBHZXRQYXJzZWRBY2NvdW50c01vZGVCbG9ja1JwY1Jlc3VsdCk7XG4gICAgICAgICAgICBpZiAoJ2Vycm9yJyBpbiByZXMpIHtcbiAgICAgICAgICAgICAgdGhyb3cgcmVzLmVycm9yO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlcy5yZXN1bHQ7XG4gICAgICAgICAgfVxuICAgICAgICBjYXNlICdub25lJzpcbiAgICAgICAgICB7XG4gICAgICAgICAgICBjb25zdCByZXMgPSBjcmVhdGUodW5zYWZlUmVzLCBHZXRQYXJzZWROb25lTW9kZUJsb2NrUnBjUmVzdWx0KTtcbiAgICAgICAgICAgIGlmICgnZXJyb3InIGluIHJlcykge1xuICAgICAgICAgICAgICB0aHJvdyByZXMuZXJyb3I7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVzLnJlc3VsdDtcbiAgICAgICAgICB9XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAge1xuICAgICAgICAgICAgY29uc3QgcmVzID0gY3JlYXRlKHVuc2FmZVJlcywgR2V0UGFyc2VkQmxvY2tScGNSZXN1bHQpO1xuICAgICAgICAgICAgaWYgKCdlcnJvcicgaW4gcmVzKSB7XG4gICAgICAgICAgICAgIHRocm93IHJlcy5lcnJvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXMucmVzdWx0O1xuICAgICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICB0aHJvdyBuZXcgU29sYW5hSlNPTlJQQ0Vycm9yKGUsICdmYWlsZWQgdG8gZ2V0IGJsb2NrJyk7XG4gICAgfVxuICB9XG4gIC8qXG4gICAqIFJldHVybnMgcmVjZW50IGJsb2NrIHByb2R1Y3Rpb24gaW5mb3JtYXRpb24gZnJvbSB0aGUgY3VycmVudCBvciBwcmV2aW91cyBlcG9jaFxuICAgKi9cbiAgYXN5bmMgZ2V0QmxvY2tQcm9kdWN0aW9uKGNvbmZpZ09yQ29tbWl0bWVudCkge1xuICAgIGxldCBleHRyYTtcbiAgICBsZXQgY29tbWl0bWVudDtcbiAgICBpZiAodHlwZW9mIGNvbmZpZ09yQ29tbWl0bWVudCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGNvbW1pdG1lbnQgPSBjb25maWdPckNvbW1pdG1lbnQ7XG4gICAgfSBlbHNlIGlmIChjb25maWdPckNvbW1pdG1lbnQpIHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgY29tbWl0bWVudDogYyxcbiAgICAgICAgLi4ucmVzdFxuICAgICAgfSA9IGNvbmZpZ09yQ29tbWl0bWVudDtcbiAgICAgIGNvbW1pdG1lbnQgPSBjO1xuICAgICAgZXh0cmEgPSByZXN0O1xuICAgIH1cbiAgICBjb25zdCBhcmdzID0gdGhpcy5fYnVpbGRBcmdzKFtdLCBjb21taXRtZW50LCAnYmFzZTY0JywgZXh0cmEpO1xuICAgIGNvbnN0IHVuc2FmZVJlcyA9IGF3YWl0IHRoaXMuX3JwY1JlcXVlc3QoJ2dldEJsb2NrUHJvZHVjdGlvbicsIGFyZ3MpO1xuICAgIGNvbnN0IHJlcyA9IGNyZWF0ZSh1bnNhZmVSZXMsIEJsb2NrUHJvZHVjdGlvblJlc3BvbnNlU3RydWN0KTtcbiAgICBpZiAoJ2Vycm9yJyBpbiByZXMpIHtcbiAgICAgIHRocm93IG5ldyBTb2xhbmFKU09OUlBDRXJyb3IocmVzLmVycm9yLCAnZmFpbGVkIHRvIGdldCBibG9jayBwcm9kdWN0aW9uIGluZm9ybWF0aW9uJyk7XG4gICAgfVxuICAgIHJldHVybiByZXMucmVzdWx0O1xuICB9XG5cbiAgLyoqXG4gICAqIEZldGNoIGEgY29uZmlybWVkIG9yIGZpbmFsaXplZCB0cmFuc2FjdGlvbiBmcm9tIHRoZSBjbHVzdGVyLlxuICAgKlxuICAgKiBAZGVwcmVjYXRlZCBJbnN0ZWFkLCBjYWxsIGBnZXRUcmFuc2FjdGlvbmAgdXNpbmcgYVxuICAgKiBgR2V0VmVyc2lvbmVkVHJhbnNhY3Rpb25Db25maWdgIGJ5IHNldHRpbmcgdGhlXG4gICAqIGBtYXhTdXBwb3J0ZWRUcmFuc2FjdGlvblZlcnNpb25gIHByb3BlcnR5LlxuICAgKi9cblxuICAvKipcbiAgICogRmV0Y2ggYSBjb25maXJtZWQgb3IgZmluYWxpemVkIHRyYW5zYWN0aW9uIGZyb20gdGhlIGNsdXN0ZXIuXG4gICAqL1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tZHVwZS1jbGFzcy1tZW1iZXJzXG5cbiAgLyoqXG4gICAqIEZldGNoIGEgY29uZmlybWVkIG9yIGZpbmFsaXplZCB0cmFuc2FjdGlvbiBmcm9tIHRoZSBjbHVzdGVyLlxuICAgKi9cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWR1cGUtY2xhc3MtbWVtYmVyc1xuICBhc3luYyBnZXRUcmFuc2FjdGlvbihzaWduYXR1cmUsIHJhd0NvbmZpZykge1xuICAgIGNvbnN0IHtcbiAgICAgIGNvbW1pdG1lbnQsXG4gICAgICBjb25maWdcbiAgICB9ID0gZXh0cmFjdENvbW1pdG1lbnRGcm9tQ29uZmlnKHJhd0NvbmZpZyk7XG4gICAgY29uc3QgYXJncyA9IHRoaXMuX2J1aWxkQXJnc0F0TGVhc3RDb25maXJtZWQoW3NpZ25hdHVyZV0sIGNvbW1pdG1lbnQsIHVuZGVmaW5lZCAvKiBlbmNvZGluZyAqLywgY29uZmlnKTtcbiAgICBjb25zdCB1bnNhZmVSZXMgPSBhd2FpdCB0aGlzLl9ycGNSZXF1ZXN0KCdnZXRUcmFuc2FjdGlvbicsIGFyZ3MpO1xuICAgIGNvbnN0IHJlcyA9IGNyZWF0ZSh1bnNhZmVSZXMsIEdldFRyYW5zYWN0aW9uUnBjUmVzdWx0KTtcbiAgICBpZiAoJ2Vycm9yJyBpbiByZXMpIHtcbiAgICAgIHRocm93IG5ldyBTb2xhbmFKU09OUlBDRXJyb3IocmVzLmVycm9yLCAnZmFpbGVkIHRvIGdldCB0cmFuc2FjdGlvbicpO1xuICAgIH1cbiAgICBjb25zdCByZXN1bHQgPSByZXMucmVzdWx0O1xuICAgIGlmICghcmVzdWx0KSByZXR1cm4gcmVzdWx0O1xuICAgIHJldHVybiB7XG4gICAgICAuLi5yZXN1bHQsXG4gICAgICB0cmFuc2FjdGlvbjoge1xuICAgICAgICAuLi5yZXN1bHQudHJhbnNhY3Rpb24sXG4gICAgICAgIG1lc3NhZ2U6IHZlcnNpb25lZE1lc3NhZ2VGcm9tUmVzcG9uc2UocmVzdWx0LnZlcnNpb24sIHJlc3VsdC50cmFuc2FjdGlvbi5tZXNzYWdlKVxuICAgICAgfVxuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogRmV0Y2ggcGFyc2VkIHRyYW5zYWN0aW9uIGRldGFpbHMgZm9yIGEgY29uZmlybWVkIG9yIGZpbmFsaXplZCB0cmFuc2FjdGlvblxuICAgKi9cbiAgYXN5bmMgZ2V0UGFyc2VkVHJhbnNhY3Rpb24oc2lnbmF0dXJlLCBjb21taXRtZW50T3JDb25maWcpIHtcbiAgICBjb25zdCB7XG4gICAgICBjb21taXRtZW50LFxuICAgICAgY29uZmlnXG4gICAgfSA9IGV4dHJhY3RDb21taXRtZW50RnJvbUNvbmZpZyhjb21taXRtZW50T3JDb25maWcpO1xuICAgIGNvbnN0IGFyZ3MgPSB0aGlzLl9idWlsZEFyZ3NBdExlYXN0Q29uZmlybWVkKFtzaWduYXR1cmVdLCBjb21taXRtZW50LCAnanNvblBhcnNlZCcsIGNvbmZpZyk7XG4gICAgY29uc3QgdW5zYWZlUmVzID0gYXdhaXQgdGhpcy5fcnBjUmVxdWVzdCgnZ2V0VHJhbnNhY3Rpb24nLCBhcmdzKTtcbiAgICBjb25zdCByZXMgPSBjcmVhdGUodW5zYWZlUmVzLCBHZXRQYXJzZWRUcmFuc2FjdGlvblJwY1Jlc3VsdCk7XG4gICAgaWYgKCdlcnJvcicgaW4gcmVzKSB7XG4gICAgICB0aHJvdyBuZXcgU29sYW5hSlNPTlJQQ0Vycm9yKHJlcy5lcnJvciwgJ2ZhaWxlZCB0byBnZXQgdHJhbnNhY3Rpb24nKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlcy5yZXN1bHQ7XG4gIH1cblxuICAvKipcbiAgICogRmV0Y2ggcGFyc2VkIHRyYW5zYWN0aW9uIGRldGFpbHMgZm9yIGEgYmF0Y2ggb2YgY29uZmlybWVkIHRyYW5zYWN0aW9uc1xuICAgKi9cbiAgYXN5bmMgZ2V0UGFyc2VkVHJhbnNhY3Rpb25zKHNpZ25hdHVyZXMsIGNvbW1pdG1lbnRPckNvbmZpZykge1xuICAgIGNvbnN0IHtcbiAgICAgIGNvbW1pdG1lbnQsXG4gICAgICBjb25maWdcbiAgICB9ID0gZXh0cmFjdENvbW1pdG1lbnRGcm9tQ29uZmlnKGNvbW1pdG1lbnRPckNvbmZpZyk7XG4gICAgY29uc3QgYmF0Y2ggPSBzaWduYXR1cmVzLm1hcChzaWduYXR1cmUgPT4ge1xuICAgICAgY29uc3QgYXJncyA9IHRoaXMuX2J1aWxkQXJnc0F0TGVhc3RDb25maXJtZWQoW3NpZ25hdHVyZV0sIGNvbW1pdG1lbnQsICdqc29uUGFyc2VkJywgY29uZmlnKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIG1ldGhvZE5hbWU6ICdnZXRUcmFuc2FjdGlvbicsXG4gICAgICAgIGFyZ3NcbiAgICAgIH07XG4gICAgfSk7XG4gICAgY29uc3QgdW5zYWZlUmVzID0gYXdhaXQgdGhpcy5fcnBjQmF0Y2hSZXF1ZXN0KGJhdGNoKTtcbiAgICBjb25zdCByZXMgPSB1bnNhZmVSZXMubWFwKHVuc2FmZVJlcyA9PiB7XG4gICAgICBjb25zdCByZXMgPSBjcmVhdGUodW5zYWZlUmVzLCBHZXRQYXJzZWRUcmFuc2FjdGlvblJwY1Jlc3VsdCk7XG4gICAgICBpZiAoJ2Vycm9yJyBpbiByZXMpIHtcbiAgICAgICAgdGhyb3cgbmV3IFNvbGFuYUpTT05SUENFcnJvcihyZXMuZXJyb3IsICdmYWlsZWQgdG8gZ2V0IHRyYW5zYWN0aW9ucycpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlcy5yZXN1bHQ7XG4gICAgfSk7XG4gICAgcmV0dXJuIHJlcztcbiAgfVxuXG4gIC8qKlxuICAgKiBGZXRjaCB0cmFuc2FjdGlvbiBkZXRhaWxzIGZvciBhIGJhdGNoIG9mIGNvbmZpcm1lZCB0cmFuc2FjdGlvbnMuXG4gICAqIFNpbWlsYXIgdG8ge0BsaW5rIGdldFBhcnNlZFRyYW5zYWN0aW9uc30gYnV0IHJldHVybnMgYSB7QGxpbmsgVHJhbnNhY3Rpb25SZXNwb25zZX0uXG4gICAqXG4gICAqIEBkZXByZWNhdGVkIEluc3RlYWQsIGNhbGwgYGdldFRyYW5zYWN0aW9uc2AgdXNpbmcgYVxuICAgKiBgR2V0VmVyc2lvbmVkVHJhbnNhY3Rpb25Db25maWdgIGJ5IHNldHRpbmcgdGhlXG4gICAqIGBtYXhTdXBwb3J0ZWRUcmFuc2FjdGlvblZlcnNpb25gIHByb3BlcnR5LlxuICAgKi9cblxuICAvKipcbiAgICogRmV0Y2ggdHJhbnNhY3Rpb24gZGV0YWlscyBmb3IgYSBiYXRjaCBvZiBjb25maXJtZWQgdHJhbnNhY3Rpb25zLlxuICAgKiBTaW1pbGFyIHRvIHtAbGluayBnZXRQYXJzZWRUcmFuc2FjdGlvbnN9IGJ1dCByZXR1cm5zIGEge0BsaW5rXG4gICAqIFZlcnNpb25lZFRyYW5zYWN0aW9uUmVzcG9uc2V9LlxuICAgKi9cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWR1cGUtY2xhc3MtbWVtYmVyc1xuXG4gIC8qKlxuICAgKiBGZXRjaCB0cmFuc2FjdGlvbiBkZXRhaWxzIGZvciBhIGJhdGNoIG9mIGNvbmZpcm1lZCB0cmFuc2FjdGlvbnMuXG4gICAqIFNpbWlsYXIgdG8ge0BsaW5rIGdldFBhcnNlZFRyYW5zYWN0aW9uc30gYnV0IHJldHVybnMgYSB7QGxpbmtcbiAgICogVmVyc2lvbmVkVHJhbnNhY3Rpb25SZXNwb25zZX0uXG4gICAqL1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tZHVwZS1jbGFzcy1tZW1iZXJzXG4gIGFzeW5jIGdldFRyYW5zYWN0aW9ucyhzaWduYXR1cmVzLCBjb21taXRtZW50T3JDb25maWcpIHtcbiAgICBjb25zdCB7XG4gICAgICBjb21taXRtZW50LFxuICAgICAgY29uZmlnXG4gICAgfSA9IGV4dHJhY3RDb21taXRtZW50RnJvbUNvbmZpZyhjb21taXRtZW50T3JDb25maWcpO1xuICAgIGNvbnN0IGJhdGNoID0gc2lnbmF0dXJlcy5tYXAoc2lnbmF0dXJlID0+IHtcbiAgICAgIGNvbnN0IGFyZ3MgPSB0aGlzLl9idWlsZEFyZ3NBdExlYXN0Q29uZmlybWVkKFtzaWduYXR1cmVdLCBjb21taXRtZW50LCB1bmRlZmluZWQgLyogZW5jb2RpbmcgKi8sIGNvbmZpZyk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBtZXRob2ROYW1lOiAnZ2V0VHJhbnNhY3Rpb24nLFxuICAgICAgICBhcmdzXG4gICAgICB9O1xuICAgIH0pO1xuICAgIGNvbnN0IHVuc2FmZVJlcyA9IGF3YWl0IHRoaXMuX3JwY0JhdGNoUmVxdWVzdChiYXRjaCk7XG4gICAgY29uc3QgcmVzID0gdW5zYWZlUmVzLm1hcCh1bnNhZmVSZXMgPT4ge1xuICAgICAgY29uc3QgcmVzID0gY3JlYXRlKHVuc2FmZVJlcywgR2V0VHJhbnNhY3Rpb25ScGNSZXN1bHQpO1xuICAgICAgaWYgKCdlcnJvcicgaW4gcmVzKSB7XG4gICAgICAgIHRocm93IG5ldyBTb2xhbmFKU09OUlBDRXJyb3IocmVzLmVycm9yLCAnZmFpbGVkIHRvIGdldCB0cmFuc2FjdGlvbnMnKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHJlc3VsdCA9IHJlcy5yZXN1bHQ7XG4gICAgICBpZiAoIXJlc3VsdCkgcmV0dXJuIHJlc3VsdDtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIC4uLnJlc3VsdCxcbiAgICAgICAgdHJhbnNhY3Rpb246IHtcbiAgICAgICAgICAuLi5yZXN1bHQudHJhbnNhY3Rpb24sXG4gICAgICAgICAgbWVzc2FnZTogdmVyc2lvbmVkTWVzc2FnZUZyb21SZXNwb25zZShyZXN1bHQudmVyc2lvbiwgcmVzdWx0LnRyYW5zYWN0aW9uLm1lc3NhZ2UpXG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfSk7XG4gICAgcmV0dXJuIHJlcztcbiAgfVxuXG4gIC8qKlxuICAgKiBGZXRjaCBhIGxpc3Qgb2YgVHJhbnNhY3Rpb25zIGFuZCB0cmFuc2FjdGlvbiBzdGF0dXNlcyBmcm9tIHRoZSBjbHVzdGVyXG4gICAqIGZvciBhIGNvbmZpcm1lZCBibG9jay5cbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgRGVwcmVjYXRlZCBzaW5jZSB2MS4xMy4wLiBQbGVhc2UgdXNlIHtAbGluayBnZXRCbG9ja30gaW5zdGVhZC5cbiAgICovXG4gIGFzeW5jIGdldENvbmZpcm1lZEJsb2NrKHNsb3QsIGNvbW1pdG1lbnQpIHtcbiAgICBjb25zdCBhcmdzID0gdGhpcy5fYnVpbGRBcmdzQXRMZWFzdENvbmZpcm1lZChbc2xvdF0sIGNvbW1pdG1lbnQpO1xuICAgIGNvbnN0IHVuc2FmZVJlcyA9IGF3YWl0IHRoaXMuX3JwY1JlcXVlc3QoJ2dldENvbmZpcm1lZEJsb2NrJywgYXJncyk7XG4gICAgY29uc3QgcmVzID0gY3JlYXRlKHVuc2FmZVJlcywgR2V0Q29uZmlybWVkQmxvY2tScGNSZXN1bHQpO1xuICAgIGlmICgnZXJyb3InIGluIHJlcykge1xuICAgICAgdGhyb3cgbmV3IFNvbGFuYUpTT05SUENFcnJvcihyZXMuZXJyb3IsICdmYWlsZWQgdG8gZ2V0IGNvbmZpcm1lZCBibG9jaycpO1xuICAgIH1cbiAgICBjb25zdCByZXN1bHQgPSByZXMucmVzdWx0O1xuICAgIGlmICghcmVzdWx0KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NvbmZpcm1lZCBibG9jayAnICsgc2xvdCArICcgbm90IGZvdW5kJyk7XG4gICAgfVxuICAgIGNvbnN0IGJsb2NrID0ge1xuICAgICAgLi4ucmVzdWx0LFxuICAgICAgdHJhbnNhY3Rpb25zOiByZXN1bHQudHJhbnNhY3Rpb25zLm1hcCgoe1xuICAgICAgICB0cmFuc2FjdGlvbixcbiAgICAgICAgbWV0YVxuICAgICAgfSkgPT4ge1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gbmV3IE1lc3NhZ2UodHJhbnNhY3Rpb24ubWVzc2FnZSk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgbWV0YSxcbiAgICAgICAgICB0cmFuc2FjdGlvbjoge1xuICAgICAgICAgICAgLi4udHJhbnNhY3Rpb24sXG4gICAgICAgICAgICBtZXNzYWdlXG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgfSlcbiAgICB9O1xuICAgIHJldHVybiB7XG4gICAgICAuLi5ibG9jayxcbiAgICAgIHRyYW5zYWN0aW9uczogYmxvY2sudHJhbnNhY3Rpb25zLm1hcCgoe1xuICAgICAgICB0cmFuc2FjdGlvbixcbiAgICAgICAgbWV0YVxuICAgICAgfSkgPT4ge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIG1ldGEsXG4gICAgICAgICAgdHJhbnNhY3Rpb246IFRyYW5zYWN0aW9uLnBvcHVsYXRlKHRyYW5zYWN0aW9uLm1lc3NhZ2UsIHRyYW5zYWN0aW9uLnNpZ25hdHVyZXMpXG4gICAgICAgIH07XG4gICAgICB9KVxuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogRmV0Y2ggY29uZmlybWVkIGJsb2NrcyBiZXR3ZWVuIHR3byBzbG90c1xuICAgKi9cbiAgYXN5bmMgZ2V0QmxvY2tzKHN0YXJ0U2xvdCwgZW5kU2xvdCwgY29tbWl0bWVudCkge1xuICAgIGNvbnN0IGFyZ3MgPSB0aGlzLl9idWlsZEFyZ3NBdExlYXN0Q29uZmlybWVkKGVuZFNsb3QgIT09IHVuZGVmaW5lZCA/IFtzdGFydFNsb3QsIGVuZFNsb3RdIDogW3N0YXJ0U2xvdF0sIGNvbW1pdG1lbnQpO1xuICAgIGNvbnN0IHVuc2FmZVJlcyA9IGF3YWl0IHRoaXMuX3JwY1JlcXVlc3QoJ2dldEJsb2NrcycsIGFyZ3MpO1xuICAgIGNvbnN0IHJlcyA9IGNyZWF0ZSh1bnNhZmVSZXMsIGpzb25ScGNSZXN1bHQoYXJyYXkobnVtYmVyKCkpKSk7XG4gICAgaWYgKCdlcnJvcicgaW4gcmVzKSB7XG4gICAgICB0aHJvdyBuZXcgU29sYW5hSlNPTlJQQ0Vycm9yKHJlcy5lcnJvciwgJ2ZhaWxlZCB0byBnZXQgYmxvY2tzJyk7XG4gICAgfVxuICAgIHJldHVybiByZXMucmVzdWx0O1xuICB9XG5cbiAgLyoqXG4gICAqIEZldGNoIGEgbGlzdCBvZiBTaWduYXR1cmVzIGZyb20gdGhlIGNsdXN0ZXIgZm9yIGEgYmxvY2ssIGV4Y2x1ZGluZyByZXdhcmRzXG4gICAqL1xuICBhc3luYyBnZXRCbG9ja1NpZ25hdHVyZXMoc2xvdCwgY29tbWl0bWVudCkge1xuICAgIGNvbnN0IGFyZ3MgPSB0aGlzLl9idWlsZEFyZ3NBdExlYXN0Q29uZmlybWVkKFtzbG90XSwgY29tbWl0bWVudCwgdW5kZWZpbmVkLCB7XG4gICAgICB0cmFuc2FjdGlvbkRldGFpbHM6ICdzaWduYXR1cmVzJyxcbiAgICAgIHJld2FyZHM6IGZhbHNlXG4gICAgfSk7XG4gICAgY29uc3QgdW5zYWZlUmVzID0gYXdhaXQgdGhpcy5fcnBjUmVxdWVzdCgnZ2V0QmxvY2snLCBhcmdzKTtcbiAgICBjb25zdCByZXMgPSBjcmVhdGUodW5zYWZlUmVzLCBHZXRCbG9ja1NpZ25hdHVyZXNScGNSZXN1bHQpO1xuICAgIGlmICgnZXJyb3InIGluIHJlcykge1xuICAgICAgdGhyb3cgbmV3IFNvbGFuYUpTT05SUENFcnJvcihyZXMuZXJyb3IsICdmYWlsZWQgdG8gZ2V0IGJsb2NrJyk7XG4gICAgfVxuICAgIGNvbnN0IHJlc3VsdCA9IHJlcy5yZXN1bHQ7XG4gICAgaWYgKCFyZXN1bHQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignQmxvY2sgJyArIHNsb3QgKyAnIG5vdCBmb3VuZCcpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgLyoqXG4gICAqIEZldGNoIGEgbGlzdCBvZiBTaWduYXR1cmVzIGZyb20gdGhlIGNsdXN0ZXIgZm9yIGEgY29uZmlybWVkIGJsb2NrLCBleGNsdWRpbmcgcmV3YXJkc1xuICAgKlxuICAgKiBAZGVwcmVjYXRlZCBEZXByZWNhdGVkIHNpbmNlIFNvbGFuYSB2MS44LjAuIFBsZWFzZSB1c2Uge0BsaW5rIGdldEJsb2NrU2lnbmF0dXJlc30gaW5zdGVhZC5cbiAgICovXG4gIGFzeW5jIGdldENvbmZpcm1lZEJsb2NrU2lnbmF0dXJlcyhzbG90LCBjb21taXRtZW50KSB7XG4gICAgY29uc3QgYXJncyA9IHRoaXMuX2J1aWxkQXJnc0F0TGVhc3RDb25maXJtZWQoW3Nsb3RdLCBjb21taXRtZW50LCB1bmRlZmluZWQsIHtcbiAgICAgIHRyYW5zYWN0aW9uRGV0YWlsczogJ3NpZ25hdHVyZXMnLFxuICAgICAgcmV3YXJkczogZmFsc2VcbiAgICB9KTtcbiAgICBjb25zdCB1bnNhZmVSZXMgPSBhd2FpdCB0aGlzLl9ycGNSZXF1ZXN0KCdnZXRDb25maXJtZWRCbG9jaycsIGFyZ3MpO1xuICAgIGNvbnN0IHJlcyA9IGNyZWF0ZSh1bnNhZmVSZXMsIEdldEJsb2NrU2lnbmF0dXJlc1JwY1Jlc3VsdCk7XG4gICAgaWYgKCdlcnJvcicgaW4gcmVzKSB7XG4gICAgICB0aHJvdyBuZXcgU29sYW5hSlNPTlJQQ0Vycm9yKHJlcy5lcnJvciwgJ2ZhaWxlZCB0byBnZXQgY29uZmlybWVkIGJsb2NrJyk7XG4gICAgfVxuICAgIGNvbnN0IHJlc3VsdCA9IHJlcy5yZXN1bHQ7XG4gICAgaWYgKCFyZXN1bHQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignQ29uZmlybWVkIGJsb2NrICcgKyBzbG90ICsgJyBub3QgZm91bmQnKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIC8qKlxuICAgKiBGZXRjaCBhIHRyYW5zYWN0aW9uIGRldGFpbHMgZm9yIGEgY29uZmlybWVkIHRyYW5zYWN0aW9uXG4gICAqXG4gICAqIEBkZXByZWNhdGVkIERlcHJlY2F0ZWQgc2luY2UgU29sYW5hIHYxLjguMC4gUGxlYXNlIHVzZSB7QGxpbmsgZ2V0VHJhbnNhY3Rpb259IGluc3RlYWQuXG4gICAqL1xuICBhc3luYyBnZXRDb25maXJtZWRUcmFuc2FjdGlvbihzaWduYXR1cmUsIGNvbW1pdG1lbnQpIHtcbiAgICBjb25zdCBhcmdzID0gdGhpcy5fYnVpbGRBcmdzQXRMZWFzdENvbmZpcm1lZChbc2lnbmF0dXJlXSwgY29tbWl0bWVudCk7XG4gICAgY29uc3QgdW5zYWZlUmVzID0gYXdhaXQgdGhpcy5fcnBjUmVxdWVzdCgnZ2V0Q29uZmlybWVkVHJhbnNhY3Rpb24nLCBhcmdzKTtcbiAgICBjb25zdCByZXMgPSBjcmVhdGUodW5zYWZlUmVzLCBHZXRUcmFuc2FjdGlvblJwY1Jlc3VsdCk7XG4gICAgaWYgKCdlcnJvcicgaW4gcmVzKSB7XG4gICAgICB0aHJvdyBuZXcgU29sYW5hSlNPTlJQQ0Vycm9yKHJlcy5lcnJvciwgJ2ZhaWxlZCB0byBnZXQgdHJhbnNhY3Rpb24nKTtcbiAgICB9XG4gICAgY29uc3QgcmVzdWx0ID0gcmVzLnJlc3VsdDtcbiAgICBpZiAoIXJlc3VsdCkgcmV0dXJuIHJlc3VsdDtcbiAgICBjb25zdCBtZXNzYWdlID0gbmV3IE1lc3NhZ2UocmVzdWx0LnRyYW5zYWN0aW9uLm1lc3NhZ2UpO1xuICAgIGNvbnN0IHNpZ25hdHVyZXMgPSByZXN1bHQudHJhbnNhY3Rpb24uc2lnbmF0dXJlcztcbiAgICByZXR1cm4ge1xuICAgICAgLi4ucmVzdWx0LFxuICAgICAgdHJhbnNhY3Rpb246IFRyYW5zYWN0aW9uLnBvcHVsYXRlKG1lc3NhZ2UsIHNpZ25hdHVyZXMpXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBGZXRjaCBwYXJzZWQgdHJhbnNhY3Rpb24gZGV0YWlscyBmb3IgYSBjb25maXJtZWQgdHJhbnNhY3Rpb25cbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgRGVwcmVjYXRlZCBzaW5jZSBTb2xhbmEgdjEuOC4wLiBQbGVhc2UgdXNlIHtAbGluayBnZXRQYXJzZWRUcmFuc2FjdGlvbn0gaW5zdGVhZC5cbiAgICovXG4gIGFzeW5jIGdldFBhcnNlZENvbmZpcm1lZFRyYW5zYWN0aW9uKHNpZ25hdHVyZSwgY29tbWl0bWVudCkge1xuICAgIGNvbnN0IGFyZ3MgPSB0aGlzLl9idWlsZEFyZ3NBdExlYXN0Q29uZmlybWVkKFtzaWduYXR1cmVdLCBjb21taXRtZW50LCAnanNvblBhcnNlZCcpO1xuICAgIGNvbnN0IHVuc2FmZVJlcyA9IGF3YWl0IHRoaXMuX3JwY1JlcXVlc3QoJ2dldENvbmZpcm1lZFRyYW5zYWN0aW9uJywgYXJncyk7XG4gICAgY29uc3QgcmVzID0gY3JlYXRlKHVuc2FmZVJlcywgR2V0UGFyc2VkVHJhbnNhY3Rpb25ScGNSZXN1bHQpO1xuICAgIGlmICgnZXJyb3InIGluIHJlcykge1xuICAgICAgdGhyb3cgbmV3IFNvbGFuYUpTT05SUENFcnJvcihyZXMuZXJyb3IsICdmYWlsZWQgdG8gZ2V0IGNvbmZpcm1lZCB0cmFuc2FjdGlvbicpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzLnJlc3VsdDtcbiAgfVxuXG4gIC8qKlxuICAgKiBGZXRjaCBwYXJzZWQgdHJhbnNhY3Rpb24gZGV0YWlscyBmb3IgYSBiYXRjaCBvZiBjb25maXJtZWQgdHJhbnNhY3Rpb25zXG4gICAqXG4gICAqIEBkZXByZWNhdGVkIERlcHJlY2F0ZWQgc2luY2UgU29sYW5hIHYxLjguMC4gUGxlYXNlIHVzZSB7QGxpbmsgZ2V0UGFyc2VkVHJhbnNhY3Rpb25zfSBpbnN0ZWFkLlxuICAgKi9cbiAgYXN5bmMgZ2V0UGFyc2VkQ29uZmlybWVkVHJhbnNhY3Rpb25zKHNpZ25hdHVyZXMsIGNvbW1pdG1lbnQpIHtcbiAgICBjb25zdCBiYXRjaCA9IHNpZ25hdHVyZXMubWFwKHNpZ25hdHVyZSA9PiB7XG4gICAgICBjb25zdCBhcmdzID0gdGhpcy5fYnVpbGRBcmdzQXRMZWFzdENvbmZpcm1lZChbc2lnbmF0dXJlXSwgY29tbWl0bWVudCwgJ2pzb25QYXJzZWQnKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIG1ldGhvZE5hbWU6ICdnZXRDb25maXJtZWRUcmFuc2FjdGlvbicsXG4gICAgICAgIGFyZ3NcbiAgICAgIH07XG4gICAgfSk7XG4gICAgY29uc3QgdW5zYWZlUmVzID0gYXdhaXQgdGhpcy5fcnBjQmF0Y2hSZXF1ZXN0KGJhdGNoKTtcbiAgICBjb25zdCByZXMgPSB1bnNhZmVSZXMubWFwKHVuc2FmZVJlcyA9PiB7XG4gICAgICBjb25zdCByZXMgPSBjcmVhdGUodW5zYWZlUmVzLCBHZXRQYXJzZWRUcmFuc2FjdGlvblJwY1Jlc3VsdCk7XG4gICAgICBpZiAoJ2Vycm9yJyBpbiByZXMpIHtcbiAgICAgICAgdGhyb3cgbmV3IFNvbGFuYUpTT05SUENFcnJvcihyZXMuZXJyb3IsICdmYWlsZWQgdG8gZ2V0IGNvbmZpcm1lZCB0cmFuc2FjdGlvbnMnKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXMucmVzdWx0O1xuICAgIH0pO1xuICAgIHJldHVybiByZXM7XG4gIH1cblxuICAvKipcbiAgICogRmV0Y2ggYSBsaXN0IG9mIGFsbCB0aGUgY29uZmlybWVkIHNpZ25hdHVyZXMgZm9yIHRyYW5zYWN0aW9ucyBpbnZvbHZpbmcgYW4gYWRkcmVzc1xuICAgKiB3aXRoaW4gYSBzcGVjaWZpZWQgc2xvdCByYW5nZS4gTWF4IHJhbmdlIGFsbG93ZWQgaXMgMTAsMDAwIHNsb3RzLlxuICAgKlxuICAgKiBAZGVwcmVjYXRlZCBEZXByZWNhdGVkIHNpbmNlIHYxLjMuIFBsZWFzZSB1c2Uge0BsaW5rIGdldENvbmZpcm1lZFNpZ25hdHVyZXNGb3JBZGRyZXNzMn0gaW5zdGVhZC5cbiAgICpcbiAgICogQHBhcmFtIGFkZHJlc3MgcXVlcmllZCBhZGRyZXNzXG4gICAqIEBwYXJhbSBzdGFydFNsb3Qgc3RhcnQgc2xvdCwgaW5jbHVzaXZlXG4gICAqIEBwYXJhbSBlbmRTbG90IGVuZCBzbG90LCBpbmNsdXNpdmVcbiAgICovXG4gIGFzeW5jIGdldENvbmZpcm1lZFNpZ25hdHVyZXNGb3JBZGRyZXNzKGFkZHJlc3MsIHN0YXJ0U2xvdCwgZW5kU2xvdCkge1xuICAgIGxldCBvcHRpb25zID0ge307XG4gICAgbGV0IGZpcnN0QXZhaWxhYmxlQmxvY2sgPSBhd2FpdCB0aGlzLmdldEZpcnN0QXZhaWxhYmxlQmxvY2soKTtcbiAgICB3aGlsZSAoISgndW50aWwnIGluIG9wdGlvbnMpKSB7XG4gICAgICBzdGFydFNsb3QtLTtcbiAgICAgIGlmIChzdGFydFNsb3QgPD0gMCB8fCBzdGFydFNsb3QgPCBmaXJzdEF2YWlsYWJsZUJsb2NrKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3QgYmxvY2sgPSBhd2FpdCB0aGlzLmdldENvbmZpcm1lZEJsb2NrU2lnbmF0dXJlcyhzdGFydFNsb3QsICdmaW5hbGl6ZWQnKTtcbiAgICAgICAgaWYgKGJsb2NrLnNpZ25hdHVyZXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgIG9wdGlvbnMudW50aWwgPSBibG9jay5zaWduYXR1cmVzW2Jsb2NrLnNpZ25hdHVyZXMubGVuZ3RoIC0gMV0udG9TdHJpbmcoKTtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIGlmIChlcnIgaW5zdGFuY2VvZiBFcnJvciAmJiBlcnIubWVzc2FnZS5pbmNsdWRlcygnc2tpcHBlZCcpKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGxldCBoaWdoZXN0Q29uZmlybWVkUm9vdCA9IGF3YWl0IHRoaXMuZ2V0U2xvdCgnZmluYWxpemVkJyk7XG4gICAgd2hpbGUgKCEoJ2JlZm9yZScgaW4gb3B0aW9ucykpIHtcbiAgICAgIGVuZFNsb3QrKztcbiAgICAgIGlmIChlbmRTbG90ID4gaGlnaGVzdENvbmZpcm1lZFJvb3QpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCBibG9jayA9IGF3YWl0IHRoaXMuZ2V0Q29uZmlybWVkQmxvY2tTaWduYXR1cmVzKGVuZFNsb3QpO1xuICAgICAgICBpZiAoYmxvY2suc2lnbmF0dXJlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgb3B0aW9ucy5iZWZvcmUgPSBibG9jay5zaWduYXR1cmVzW2Jsb2NrLnNpZ25hdHVyZXMubGVuZ3RoIC0gMV0udG9TdHJpbmcoKTtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIGlmIChlcnIgaW5zdGFuY2VvZiBFcnJvciAmJiBlcnIubWVzc2FnZS5pbmNsdWRlcygnc2tpcHBlZCcpKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IGNvbmZpcm1lZFNpZ25hdHVyZUluZm8gPSBhd2FpdCB0aGlzLmdldENvbmZpcm1lZFNpZ25hdHVyZXNGb3JBZGRyZXNzMihhZGRyZXNzLCBvcHRpb25zKTtcbiAgICByZXR1cm4gY29uZmlybWVkU2lnbmF0dXJlSW5mby5tYXAoaW5mbyA9PiBpbmZvLnNpZ25hdHVyZSk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBjb25maXJtZWQgc2lnbmF0dXJlcyBmb3IgdHJhbnNhY3Rpb25zIGludm9sdmluZyBhblxuICAgKiBhZGRyZXNzIGJhY2t3YXJkcyBpbiB0aW1lIGZyb20gdGhlIHByb3ZpZGVkIHNpZ25hdHVyZSBvciBtb3N0IHJlY2VudCBjb25maXJtZWQgYmxvY2tcbiAgICpcbiAgICpcbiAgICogQHBhcmFtIGFkZHJlc3MgcXVlcmllZCBhZGRyZXNzXG4gICAqIEBwYXJhbSBvcHRpb25zXG4gICAqL1xuICBhc3luYyBnZXRDb25maXJtZWRTaWduYXR1cmVzRm9yQWRkcmVzczIoYWRkcmVzcywgb3B0aW9ucywgY29tbWl0bWVudCkge1xuICAgIGNvbnN0IGFyZ3MgPSB0aGlzLl9idWlsZEFyZ3NBdExlYXN0Q29uZmlybWVkKFthZGRyZXNzLnRvQmFzZTU4KCldLCBjb21taXRtZW50LCB1bmRlZmluZWQsIG9wdGlvbnMpO1xuICAgIGNvbnN0IHVuc2FmZVJlcyA9IGF3YWl0IHRoaXMuX3JwY1JlcXVlc3QoJ2dldENvbmZpcm1lZFNpZ25hdHVyZXNGb3JBZGRyZXNzMicsIGFyZ3MpO1xuICAgIGNvbnN0IHJlcyA9IGNyZWF0ZSh1bnNhZmVSZXMsIEdldENvbmZpcm1lZFNpZ25hdHVyZXNGb3JBZGRyZXNzMlJwY1Jlc3VsdCk7XG4gICAgaWYgKCdlcnJvcicgaW4gcmVzKSB7XG4gICAgICB0aHJvdyBuZXcgU29sYW5hSlNPTlJQQ0Vycm9yKHJlcy5lcnJvciwgJ2ZhaWxlZCB0byBnZXQgY29uZmlybWVkIHNpZ25hdHVyZXMgZm9yIGFkZHJlc3MnKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlcy5yZXN1bHQ7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBjb25maXJtZWQgc2lnbmF0dXJlcyBmb3IgdHJhbnNhY3Rpb25zIGludm9sdmluZyBhblxuICAgKiBhZGRyZXNzIGJhY2t3YXJkcyBpbiB0aW1lIGZyb20gdGhlIHByb3ZpZGVkIHNpZ25hdHVyZSBvciBtb3N0IHJlY2VudCBjb25maXJtZWQgYmxvY2tcbiAgICpcbiAgICpcbiAgICogQHBhcmFtIGFkZHJlc3MgcXVlcmllZCBhZGRyZXNzXG4gICAqIEBwYXJhbSBvcHRpb25zXG4gICAqL1xuICBhc3luYyBnZXRTaWduYXR1cmVzRm9yQWRkcmVzcyhhZGRyZXNzLCBvcHRpb25zLCBjb21taXRtZW50KSB7XG4gICAgY29uc3QgYXJncyA9IHRoaXMuX2J1aWxkQXJnc0F0TGVhc3RDb25maXJtZWQoW2FkZHJlc3MudG9CYXNlNTgoKV0sIGNvbW1pdG1lbnQsIHVuZGVmaW5lZCwgb3B0aW9ucyk7XG4gICAgY29uc3QgdW5zYWZlUmVzID0gYXdhaXQgdGhpcy5fcnBjUmVxdWVzdCgnZ2V0U2lnbmF0dXJlc0ZvckFkZHJlc3MnLCBhcmdzKTtcbiAgICBjb25zdCByZXMgPSBjcmVhdGUodW5zYWZlUmVzLCBHZXRTaWduYXR1cmVzRm9yQWRkcmVzc1JwY1Jlc3VsdCk7XG4gICAgaWYgKCdlcnJvcicgaW4gcmVzKSB7XG4gICAgICB0aHJvdyBuZXcgU29sYW5hSlNPTlJQQ0Vycm9yKHJlcy5lcnJvciwgJ2ZhaWxlZCB0byBnZXQgc2lnbmF0dXJlcyBmb3IgYWRkcmVzcycpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzLnJlc3VsdDtcbiAgfVxuICBhc3luYyBnZXRBZGRyZXNzTG9va3VwVGFibGUoYWNjb3VudEtleSwgY29uZmlnKSB7XG4gICAgY29uc3Qge1xuICAgICAgY29udGV4dCxcbiAgICAgIHZhbHVlOiBhY2NvdW50SW5mb1xuICAgIH0gPSBhd2FpdCB0aGlzLmdldEFjY291bnRJbmZvQW5kQ29udGV4dChhY2NvdW50S2V5LCBjb25maWcpO1xuICAgIGxldCB2YWx1ZSA9IG51bGw7XG4gICAgaWYgKGFjY291bnRJbmZvICE9PSBudWxsKSB7XG4gICAgICB2YWx1ZSA9IG5ldyBBZGRyZXNzTG9va3VwVGFibGVBY2NvdW50KHtcbiAgICAgICAga2V5OiBhY2NvdW50S2V5LFxuICAgICAgICBzdGF0ZTogQWRkcmVzc0xvb2t1cFRhYmxlQWNjb3VudC5kZXNlcmlhbGl6ZShhY2NvdW50SW5mby5kYXRhKVxuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICBjb250ZXh0LFxuICAgICAgdmFsdWVcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIEZldGNoIHRoZSBjb250ZW50cyBvZiBhIE5vbmNlIGFjY291bnQgZnJvbSB0aGUgY2x1c3RlciwgcmV0dXJuIHdpdGggY29udGV4dFxuICAgKi9cbiAgYXN5bmMgZ2V0Tm9uY2VBbmRDb250ZXh0KG5vbmNlQWNjb3VudCwgY29tbWl0bWVudE9yQ29uZmlnKSB7XG4gICAgY29uc3Qge1xuICAgICAgY29udGV4dCxcbiAgICAgIHZhbHVlOiBhY2NvdW50SW5mb1xuICAgIH0gPSBhd2FpdCB0aGlzLmdldEFjY291bnRJbmZvQW5kQ29udGV4dChub25jZUFjY291bnQsIGNvbW1pdG1lbnRPckNvbmZpZyk7XG4gICAgbGV0IHZhbHVlID0gbnVsbDtcbiAgICBpZiAoYWNjb3VudEluZm8gIT09IG51bGwpIHtcbiAgICAgIHZhbHVlID0gTm9uY2VBY2NvdW50LmZyb21BY2NvdW50RGF0YShhY2NvdW50SW5mby5kYXRhKTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIGNvbnRleHQsXG4gICAgICB2YWx1ZVxuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogRmV0Y2ggdGhlIGNvbnRlbnRzIG9mIGEgTm9uY2UgYWNjb3VudCBmcm9tIHRoZSBjbHVzdGVyXG4gICAqL1xuICBhc3luYyBnZXROb25jZShub25jZUFjY291bnQsIGNvbW1pdG1lbnRPckNvbmZpZykge1xuICAgIHJldHVybiBhd2FpdCB0aGlzLmdldE5vbmNlQW5kQ29udGV4dChub25jZUFjY291bnQsIGNvbW1pdG1lbnRPckNvbmZpZykudGhlbih4ID0+IHgudmFsdWUpLmNhdGNoKGUgPT4ge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdmYWlsZWQgdG8gZ2V0IG5vbmNlIGZvciBhY2NvdW50ICcgKyBub25jZUFjY291bnQudG9CYXNlNTgoKSArICc6ICcgKyBlKTtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXF1ZXN0IGFuIGFsbG9jYXRpb24gb2YgbGFtcG9ydHMgdG8gdGhlIHNwZWNpZmllZCBhZGRyZXNzXG4gICAqXG4gICAqIGBgYHR5cGVzY3JpcHRcbiAgICogaW1wb3J0IHsgQ29ubmVjdGlvbiwgUHVibGljS2V5LCBMQU1QT1JUU19QRVJfU09MIH0gZnJvbSBcIkBzb2xhbmEvd2ViMy5qc1wiO1xuICAgKlxuICAgKiAoYXN5bmMgKCkgPT4ge1xuICAgKiAgIGNvbnN0IGNvbm5lY3Rpb24gPSBuZXcgQ29ubmVjdGlvbihcImh0dHBzOi8vYXBpLnRlc3RuZXQuc29sYW5hLmNvbVwiLCBcImNvbmZpcm1lZFwiKTtcbiAgICogICBjb25zdCBteUFkZHJlc3MgPSBuZXcgUHVibGljS2V5KFwiMm5yMWJIRlQ4Nlc5dEdueXZtWVc0dmNIS3NRQjNzVlFmbmRkYXN6NGtFeE1cIik7XG4gICAqICAgY29uc3Qgc2lnbmF0dXJlID0gYXdhaXQgY29ubmVjdGlvbi5yZXF1ZXN0QWlyZHJvcChteUFkZHJlc3MsIExBTVBPUlRTX1BFUl9TT0wpO1xuICAgKiAgIGF3YWl0IGNvbm5lY3Rpb24uY29uZmlybVRyYW5zYWN0aW9uKHNpZ25hdHVyZSk7XG4gICAqIH0pKCk7XG4gICAqIGBgYFxuICAgKi9cbiAgYXN5bmMgcmVxdWVzdEFpcmRyb3AodG8sIGxhbXBvcnRzKSB7XG4gICAgY29uc3QgdW5zYWZlUmVzID0gYXdhaXQgdGhpcy5fcnBjUmVxdWVzdCgncmVxdWVzdEFpcmRyb3AnLCBbdG8udG9CYXNlNTgoKSwgbGFtcG9ydHNdKTtcbiAgICBjb25zdCByZXMgPSBjcmVhdGUodW5zYWZlUmVzLCBSZXF1ZXN0QWlyZHJvcFJwY1Jlc3VsdCk7XG4gICAgaWYgKCdlcnJvcicgaW4gcmVzKSB7XG4gICAgICB0aHJvdyBuZXcgU29sYW5hSlNPTlJQQ0Vycm9yKHJlcy5lcnJvciwgYGFpcmRyb3AgdG8gJHt0by50b0Jhc2U1OCgpfSBmYWlsZWRgKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlcy5yZXN1bHQ7XG4gIH1cblxuICAvKipcbiAgICogQGludGVybmFsXG4gICAqL1xuICBhc3luYyBfYmxvY2toYXNoV2l0aEV4cGlyeUJsb2NrSGVpZ2h0KGRpc2FibGVDYWNoZSkge1xuICAgIGlmICghZGlzYWJsZUNhY2hlKSB7XG4gICAgICAvLyBXYWl0IGZvciBwb2xsaW5nIHRvIGZpbmlzaFxuICAgICAgd2hpbGUgKHRoaXMuX3BvbGxpbmdCbG9ja2hhc2gpIHtcbiAgICAgICAgYXdhaXQgc2xlZXAoMTAwKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHRpbWVTaW5jZUZldGNoID0gRGF0ZS5ub3coKSAtIHRoaXMuX2Jsb2NraGFzaEluZm8ubGFzdEZldGNoO1xuICAgICAgY29uc3QgZXhwaXJlZCA9IHRpbWVTaW5jZUZldGNoID49IEJMT0NLSEFTSF9DQUNIRV9USU1FT1VUX01TO1xuICAgICAgaWYgKHRoaXMuX2Jsb2NraGFzaEluZm8ubGF0ZXN0QmxvY2toYXNoICE9PSBudWxsICYmICFleHBpcmVkKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9ibG9ja2hhc2hJbmZvLmxhdGVzdEJsb2NraGFzaDtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGF3YWl0IHRoaXMuX3BvbGxOZXdCbG9ja2hhc2goKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIGFzeW5jIF9wb2xsTmV3QmxvY2toYXNoKCkge1xuICAgIHRoaXMuX3BvbGxpbmdCbG9ja2hhc2ggPSB0cnVlO1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBzdGFydFRpbWUgPSBEYXRlLm5vdygpO1xuICAgICAgY29uc3QgY2FjaGVkTGF0ZXN0QmxvY2toYXNoID0gdGhpcy5fYmxvY2toYXNoSW5mby5sYXRlc3RCbG9ja2hhc2g7XG4gICAgICBjb25zdCBjYWNoZWRCbG9ja2hhc2ggPSBjYWNoZWRMYXRlc3RCbG9ja2hhc2ggPyBjYWNoZWRMYXRlc3RCbG9ja2hhc2guYmxvY2toYXNoIDogbnVsbDtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgNTA7IGkrKykge1xuICAgICAgICBjb25zdCBsYXRlc3RCbG9ja2hhc2ggPSBhd2FpdCB0aGlzLmdldExhdGVzdEJsb2NraGFzaCgnZmluYWxpemVkJyk7XG4gICAgICAgIGlmIChjYWNoZWRCbG9ja2hhc2ggIT09IGxhdGVzdEJsb2NraGFzaC5ibG9ja2hhc2gpIHtcbiAgICAgICAgICB0aGlzLl9ibG9ja2hhc2hJbmZvID0ge1xuICAgICAgICAgICAgbGF0ZXN0QmxvY2toYXNoLFxuICAgICAgICAgICAgbGFzdEZldGNoOiBEYXRlLm5vdygpLFxuICAgICAgICAgICAgdHJhbnNhY3Rpb25TaWduYXR1cmVzOiBbXSxcbiAgICAgICAgICAgIHNpbXVsYXRlZFNpZ25hdHVyZXM6IFtdXG4gICAgICAgICAgfTtcbiAgICAgICAgICByZXR1cm4gbGF0ZXN0QmxvY2toYXNoO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gU2xlZXAgZm9yIGFwcHJveGltYXRlbHkgaGFsZiBhIHNsb3RcbiAgICAgICAgYXdhaXQgc2xlZXAoTVNfUEVSX1NMT1QgLyAyKTtcbiAgICAgIH1cbiAgICAgIHRocm93IG5ldyBFcnJvcihgVW5hYmxlIHRvIG9idGFpbiBhIG5ldyBibG9ja2hhc2ggYWZ0ZXIgJHtEYXRlLm5vdygpIC0gc3RhcnRUaW1lfW1zYCk7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIHRoaXMuX3BvbGxpbmdCbG9ja2hhc2ggPSBmYWxzZTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogZ2V0IHRoZSBzdGFrZSBtaW5pbXVtIGRlbGVnYXRpb25cbiAgICovXG4gIGFzeW5jIGdldFN0YWtlTWluaW11bURlbGVnYXRpb24oY29uZmlnKSB7XG4gICAgY29uc3Qge1xuICAgICAgY29tbWl0bWVudCxcbiAgICAgIGNvbmZpZzogY29uZmlnQXJnXG4gICAgfSA9IGV4dHJhY3RDb21taXRtZW50RnJvbUNvbmZpZyhjb25maWcpO1xuICAgIGNvbnN0IGFyZ3MgPSB0aGlzLl9idWlsZEFyZ3MoW10sIGNvbW1pdG1lbnQsICdiYXNlNjQnLCBjb25maWdBcmcpO1xuICAgIGNvbnN0IHVuc2FmZVJlcyA9IGF3YWl0IHRoaXMuX3JwY1JlcXVlc3QoJ2dldFN0YWtlTWluaW11bURlbGVnYXRpb24nLCBhcmdzKTtcbiAgICBjb25zdCByZXMgPSBjcmVhdGUodW5zYWZlUmVzLCBqc29uUnBjUmVzdWx0QW5kQ29udGV4dChudW1iZXIoKSkpO1xuICAgIGlmICgnZXJyb3InIGluIHJlcykge1xuICAgICAgdGhyb3cgbmV3IFNvbGFuYUpTT05SUENFcnJvcihyZXMuZXJyb3IsIGBmYWlsZWQgdG8gZ2V0IHN0YWtlIG1pbmltdW0gZGVsZWdhdGlvbmApO1xuICAgIH1cbiAgICByZXR1cm4gcmVzLnJlc3VsdDtcbiAgfVxuXG4gIC8qKlxuICAgKiBTaW11bGF0ZSBhIHRyYW5zYWN0aW9uXG4gICAqXG4gICAqIEBkZXByZWNhdGVkIEluc3RlYWQsIGNhbGwge0BsaW5rIHNpbXVsYXRlVHJhbnNhY3Rpb259IHdpdGgge0BsaW5rXG4gICAqIFZlcnNpb25lZFRyYW5zYWN0aW9ufSBhbmQge0BsaW5rIFNpbXVsYXRlVHJhbnNhY3Rpb25Db25maWd9IHBhcmFtZXRlcnNcbiAgICovXG5cbiAgLyoqXG4gICAqIFNpbXVsYXRlIGEgdHJhbnNhY3Rpb25cbiAgICovXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1kdXBlLWNsYXNzLW1lbWJlcnNcblxuICAvKipcbiAgICogU2ltdWxhdGUgYSB0cmFuc2FjdGlvblxuICAgKi9cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWR1cGUtY2xhc3MtbWVtYmVyc1xuICBhc3luYyBzaW11bGF0ZVRyYW5zYWN0aW9uKHRyYW5zYWN0aW9uT3JNZXNzYWdlLCBjb25maWdPclNpZ25lcnMsIGluY2x1ZGVBY2NvdW50cykge1xuICAgIGlmICgnbWVzc2FnZScgaW4gdHJhbnNhY3Rpb25Pck1lc3NhZ2UpIHtcbiAgICAgIGNvbnN0IHZlcnNpb25lZFR4ID0gdHJhbnNhY3Rpb25Pck1lc3NhZ2U7XG4gICAgICBjb25zdCB3aXJlVHJhbnNhY3Rpb24gPSB2ZXJzaW9uZWRUeC5zZXJpYWxpemUoKTtcbiAgICAgIGNvbnN0IGVuY29kZWRUcmFuc2FjdGlvbiA9IEJ1ZmZlci5mcm9tKHdpcmVUcmFuc2FjdGlvbikudG9TdHJpbmcoJ2Jhc2U2NCcpO1xuICAgICAgaWYgKEFycmF5LmlzQXJyYXkoY29uZmlnT3JTaWduZXJzKSB8fCBpbmNsdWRlQWNjb3VudHMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgYXJndW1lbnRzJyk7XG4gICAgICB9XG4gICAgICBjb25zdCBjb25maWcgPSBjb25maWdPclNpZ25lcnMgfHwge307XG4gICAgICBjb25maWcuZW5jb2RpbmcgPSAnYmFzZTY0JztcbiAgICAgIGlmICghKCdjb21taXRtZW50JyBpbiBjb25maWcpKSB7XG4gICAgICAgIGNvbmZpZy5jb21taXRtZW50ID0gdGhpcy5jb21taXRtZW50O1xuICAgICAgfVxuICAgICAgY29uc3QgYXJncyA9IFtlbmNvZGVkVHJhbnNhY3Rpb24sIGNvbmZpZ107XG4gICAgICBjb25zdCB1bnNhZmVSZXMgPSBhd2FpdCB0aGlzLl9ycGNSZXF1ZXN0KCdzaW11bGF0ZVRyYW5zYWN0aW9uJywgYXJncyk7XG4gICAgICBjb25zdCByZXMgPSBjcmVhdGUodW5zYWZlUmVzLCBTaW11bGF0ZWRUcmFuc2FjdGlvblJlc3BvbnNlU3RydWN0KTtcbiAgICAgIGlmICgnZXJyb3InIGluIHJlcykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ZhaWxlZCB0byBzaW11bGF0ZSB0cmFuc2FjdGlvbjogJyArIHJlcy5lcnJvci5tZXNzYWdlKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXMucmVzdWx0O1xuICAgIH1cbiAgICBsZXQgdHJhbnNhY3Rpb247XG4gICAgaWYgKHRyYW5zYWN0aW9uT3JNZXNzYWdlIGluc3RhbmNlb2YgVHJhbnNhY3Rpb24pIHtcbiAgICAgIGxldCBvcmlnaW5hbFR4ID0gdHJhbnNhY3Rpb25Pck1lc3NhZ2U7XG4gICAgICB0cmFuc2FjdGlvbiA9IG5ldyBUcmFuc2FjdGlvbigpO1xuICAgICAgdHJhbnNhY3Rpb24uZmVlUGF5ZXIgPSBvcmlnaW5hbFR4LmZlZVBheWVyO1xuICAgICAgdHJhbnNhY3Rpb24uaW5zdHJ1Y3Rpb25zID0gdHJhbnNhY3Rpb25Pck1lc3NhZ2UuaW5zdHJ1Y3Rpb25zO1xuICAgICAgdHJhbnNhY3Rpb24ubm9uY2VJbmZvID0gb3JpZ2luYWxUeC5ub25jZUluZm87XG4gICAgICB0cmFuc2FjdGlvbi5zaWduYXR1cmVzID0gb3JpZ2luYWxUeC5zaWduYXR1cmVzO1xuICAgIH0gZWxzZSB7XG4gICAgICB0cmFuc2FjdGlvbiA9IFRyYW5zYWN0aW9uLnBvcHVsYXRlKHRyYW5zYWN0aW9uT3JNZXNzYWdlKTtcbiAgICAgIC8vIEhBQ0s6IHRoaXMgZnVuY3Rpb24gcmVsaWVzIG9uIG11dGF0aW5nIHRoZSBwb3B1bGF0ZWQgdHJhbnNhY3Rpb25cbiAgICAgIHRyYW5zYWN0aW9uLl9tZXNzYWdlID0gdHJhbnNhY3Rpb24uX2pzb24gPSB1bmRlZmluZWQ7XG4gICAgfVxuICAgIGlmIChjb25maWdPclNpZ25lcnMgIT09IHVuZGVmaW5lZCAmJiAhQXJyYXkuaXNBcnJheShjb25maWdPclNpZ25lcnMpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgYXJndW1lbnRzJyk7XG4gICAgfVxuICAgIGNvbnN0IHNpZ25lcnMgPSBjb25maWdPclNpZ25lcnM7XG4gICAgaWYgKHRyYW5zYWN0aW9uLm5vbmNlSW5mbyAmJiBzaWduZXJzKSB7XG4gICAgICB0cmFuc2FjdGlvbi5zaWduKC4uLnNpZ25lcnMpO1xuICAgIH0gZWxzZSB7XG4gICAgICBsZXQgZGlzYWJsZUNhY2hlID0gdGhpcy5fZGlzYWJsZUJsb2NraGFzaENhY2hpbmc7XG4gICAgICBmb3IgKDs7KSB7XG4gICAgICAgIGNvbnN0IGxhdGVzdEJsb2NraGFzaCA9IGF3YWl0IHRoaXMuX2Jsb2NraGFzaFdpdGhFeHBpcnlCbG9ja0hlaWdodChkaXNhYmxlQ2FjaGUpO1xuICAgICAgICB0cmFuc2FjdGlvbi5sYXN0VmFsaWRCbG9ja0hlaWdodCA9IGxhdGVzdEJsb2NraGFzaC5sYXN0VmFsaWRCbG9ja0hlaWdodDtcbiAgICAgICAgdHJhbnNhY3Rpb24ucmVjZW50QmxvY2toYXNoID0gbGF0ZXN0QmxvY2toYXNoLmJsb2NraGFzaDtcbiAgICAgICAgaWYgKCFzaWduZXJzKSBicmVhaztcbiAgICAgICAgdHJhbnNhY3Rpb24uc2lnbiguLi5zaWduZXJzKTtcbiAgICAgICAgaWYgKCF0cmFuc2FjdGlvbi5zaWduYXR1cmUpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJyFzaWduYXR1cmUnKTsgLy8gc2hvdWxkIG5ldmVyIGhhcHBlblxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHNpZ25hdHVyZSA9IHRyYW5zYWN0aW9uLnNpZ25hdHVyZS50b1N0cmluZygnYmFzZTY0Jyk7XG4gICAgICAgIGlmICghdGhpcy5fYmxvY2toYXNoSW5mby5zaW11bGF0ZWRTaWduYXR1cmVzLmluY2x1ZGVzKHNpZ25hdHVyZSkgJiYgIXRoaXMuX2Jsb2NraGFzaEluZm8udHJhbnNhY3Rpb25TaWduYXR1cmVzLmluY2x1ZGVzKHNpZ25hdHVyZSkpIHtcbiAgICAgICAgICAvLyBUaGUgc2lnbmF0dXJlIG9mIHRoaXMgdHJhbnNhY3Rpb24gaGFzIG5vdCBiZWVuIHNlZW4gYmVmb3JlIHdpdGggdGhlXG4gICAgICAgICAgLy8gY3VycmVudCByZWNlbnRCbG9ja2hhc2gsIGFsbCBkb25lLiBMZXQncyBicmVha1xuICAgICAgICAgIHRoaXMuX2Jsb2NraGFzaEluZm8uc2ltdWxhdGVkU2lnbmF0dXJlcy5wdXNoKHNpZ25hdHVyZSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gVGhpcyB0cmFuc2FjdGlvbiB3b3VsZCBiZSB0cmVhdGVkIGFzIGR1cGxpY2F0ZSAoaXRzIGRlcml2ZWQgc2lnbmF0dXJlXG4gICAgICAgICAgLy8gbWF0Y2hlZCB0byBvbmUgb2YgYWxyZWFkeSByZWNvcmRlZCBzaWduYXR1cmVzKS5cbiAgICAgICAgICAvLyBTbywgd2UgbXVzdCBmZXRjaCBhIG5ldyBibG9ja2hhc2ggZm9yIGEgZGlmZmVyZW50IHNpZ25hdHVyZSBieSBkaXNhYmxpbmdcbiAgICAgICAgICAvLyBvdXIgY2FjaGUgbm90IHRvIHdhaXQgZm9yIHRoZSBjYWNoZSBleHBpcmF0aW9uIChCTE9DS0hBU0hfQ0FDSEVfVElNRU9VVF9NUykuXG4gICAgICAgICAgZGlzYWJsZUNhY2hlID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBtZXNzYWdlID0gdHJhbnNhY3Rpb24uX2NvbXBpbGUoKTtcbiAgICBjb25zdCBzaWduRGF0YSA9IG1lc3NhZ2Uuc2VyaWFsaXplKCk7XG4gICAgY29uc3Qgd2lyZVRyYW5zYWN0aW9uID0gdHJhbnNhY3Rpb24uX3NlcmlhbGl6ZShzaWduRGF0YSk7XG4gICAgY29uc3QgZW5jb2RlZFRyYW5zYWN0aW9uID0gd2lyZVRyYW5zYWN0aW9uLnRvU3RyaW5nKCdiYXNlNjQnKTtcbiAgICBjb25zdCBjb25maWcgPSB7XG4gICAgICBlbmNvZGluZzogJ2Jhc2U2NCcsXG4gICAgICBjb21taXRtZW50OiB0aGlzLmNvbW1pdG1lbnRcbiAgICB9O1xuICAgIGlmIChpbmNsdWRlQWNjb3VudHMpIHtcbiAgICAgIGNvbnN0IGFkZHJlc3NlcyA9IChBcnJheS5pc0FycmF5KGluY2x1ZGVBY2NvdW50cykgPyBpbmNsdWRlQWNjb3VudHMgOiBtZXNzYWdlLm5vblByb2dyYW1JZHMoKSkubWFwKGtleSA9PiBrZXkudG9CYXNlNTgoKSk7XG4gICAgICBjb25maWdbJ2FjY291bnRzJ10gPSB7XG4gICAgICAgIGVuY29kaW5nOiAnYmFzZTY0JyxcbiAgICAgICAgYWRkcmVzc2VzXG4gICAgICB9O1xuICAgIH1cbiAgICBpZiAoc2lnbmVycykge1xuICAgICAgY29uZmlnLnNpZ1ZlcmlmeSA9IHRydWU7XG4gICAgfVxuICAgIGNvbnN0IGFyZ3MgPSBbZW5jb2RlZFRyYW5zYWN0aW9uLCBjb25maWddO1xuICAgIGNvbnN0IHVuc2FmZVJlcyA9IGF3YWl0IHRoaXMuX3JwY1JlcXVlc3QoJ3NpbXVsYXRlVHJhbnNhY3Rpb24nLCBhcmdzKTtcbiAgICBjb25zdCByZXMgPSBjcmVhdGUodW5zYWZlUmVzLCBTaW11bGF0ZWRUcmFuc2FjdGlvblJlc3BvbnNlU3RydWN0KTtcbiAgICBpZiAoJ2Vycm9yJyBpbiByZXMpIHtcbiAgICAgIGxldCBsb2dzO1xuICAgICAgaWYgKCdkYXRhJyBpbiByZXMuZXJyb3IpIHtcbiAgICAgICAgbG9ncyA9IHJlcy5lcnJvci5kYXRhLmxvZ3M7XG4gICAgICAgIGlmIChsb2dzICYmIEFycmF5LmlzQXJyYXkobG9ncykpIHtcbiAgICAgICAgICBjb25zdCB0cmFjZUluZGVudCA9ICdcXG4gICAgJztcbiAgICAgICAgICBjb25zdCBsb2dUcmFjZSA9IHRyYWNlSW5kZW50ICsgbG9ncy5qb2luKHRyYWNlSW5kZW50KTtcbiAgICAgICAgICBjb25zb2xlLmVycm9yKHJlcy5lcnJvci5tZXNzYWdlLCBsb2dUcmFjZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHRocm93IG5ldyBTZW5kVHJhbnNhY3Rpb25FcnJvcignZmFpbGVkIHRvIHNpbXVsYXRlIHRyYW5zYWN0aW9uOiAnICsgcmVzLmVycm9yLm1lc3NhZ2UsIGxvZ3MpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzLnJlc3VsdDtcbiAgfVxuXG4gIC8qKlxuICAgKiBTaWduIGFuZCBzZW5kIGEgdHJhbnNhY3Rpb25cbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgSW5zdGVhZCwgY2FsbCB7QGxpbmsgc2VuZFRyYW5zYWN0aW9ufSB3aXRoIGEge0BsaW5rXG4gICAqIFZlcnNpb25lZFRyYW5zYWN0aW9ufVxuICAgKi9cblxuICAvKipcbiAgICogU2VuZCBhIHNpZ25lZCB0cmFuc2FjdGlvblxuICAgKi9cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWR1cGUtY2xhc3MtbWVtYmVyc1xuXG4gIC8qKlxuICAgKiBTaWduIGFuZCBzZW5kIGEgdHJhbnNhY3Rpb25cbiAgICovXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1kdXBlLWNsYXNzLW1lbWJlcnNcbiAgYXN5bmMgc2VuZFRyYW5zYWN0aW9uKHRyYW5zYWN0aW9uLCBzaWduZXJzT3JPcHRpb25zLCBvcHRpb25zKSB7XG4gICAgaWYgKCd2ZXJzaW9uJyBpbiB0cmFuc2FjdGlvbikge1xuICAgICAgaWYgKHNpZ25lcnNPck9wdGlvbnMgJiYgQXJyYXkuaXNBcnJheShzaWduZXJzT3JPcHRpb25zKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgYXJndW1lbnRzJyk7XG4gICAgICB9XG4gICAgICBjb25zdCB3aXJlVHJhbnNhY3Rpb24gPSB0cmFuc2FjdGlvbi5zZXJpYWxpemUoKTtcbiAgICAgIHJldHVybiBhd2FpdCB0aGlzLnNlbmRSYXdUcmFuc2FjdGlvbih3aXJlVHJhbnNhY3Rpb24sIHNpZ25lcnNPck9wdGlvbnMpO1xuICAgIH1cbiAgICBpZiAoc2lnbmVyc09yT3B0aW9ucyA9PT0gdW5kZWZpbmVkIHx8ICFBcnJheS5pc0FycmF5KHNpZ25lcnNPck9wdGlvbnMpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgYXJndW1lbnRzJyk7XG4gICAgfVxuICAgIGNvbnN0IHNpZ25lcnMgPSBzaWduZXJzT3JPcHRpb25zO1xuICAgIGlmICh0cmFuc2FjdGlvbi5ub25jZUluZm8pIHtcbiAgICAgIHRyYW5zYWN0aW9uLnNpZ24oLi4uc2lnbmVycyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGxldCBkaXNhYmxlQ2FjaGUgPSB0aGlzLl9kaXNhYmxlQmxvY2toYXNoQ2FjaGluZztcbiAgICAgIGZvciAoOzspIHtcbiAgICAgICAgY29uc3QgbGF0ZXN0QmxvY2toYXNoID0gYXdhaXQgdGhpcy5fYmxvY2toYXNoV2l0aEV4cGlyeUJsb2NrSGVpZ2h0KGRpc2FibGVDYWNoZSk7XG4gICAgICAgIHRyYW5zYWN0aW9uLmxhc3RWYWxpZEJsb2NrSGVpZ2h0ID0gbGF0ZXN0QmxvY2toYXNoLmxhc3RWYWxpZEJsb2NrSGVpZ2h0O1xuICAgICAgICB0cmFuc2FjdGlvbi5yZWNlbnRCbG9ja2hhc2ggPSBsYXRlc3RCbG9ja2hhc2guYmxvY2toYXNoO1xuICAgICAgICB0cmFuc2FjdGlvbi5zaWduKC4uLnNpZ25lcnMpO1xuICAgICAgICBpZiAoIXRyYW5zYWN0aW9uLnNpZ25hdHVyZSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignIXNpZ25hdHVyZScpOyAvLyBzaG91bGQgbmV2ZXIgaGFwcGVuXG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc2lnbmF0dXJlID0gdHJhbnNhY3Rpb24uc2lnbmF0dXJlLnRvU3RyaW5nKCdiYXNlNjQnKTtcbiAgICAgICAgaWYgKCF0aGlzLl9ibG9ja2hhc2hJbmZvLnRyYW5zYWN0aW9uU2lnbmF0dXJlcy5pbmNsdWRlcyhzaWduYXR1cmUpKSB7XG4gICAgICAgICAgLy8gVGhlIHNpZ25hdHVyZSBvZiB0aGlzIHRyYW5zYWN0aW9uIGhhcyBub3QgYmVlbiBzZWVuIGJlZm9yZSB3aXRoIHRoZVxuICAgICAgICAgIC8vIGN1cnJlbnQgcmVjZW50QmxvY2toYXNoLCBhbGwgZG9uZS4gTGV0J3MgYnJlYWtcbiAgICAgICAgICB0aGlzLl9ibG9ja2hhc2hJbmZvLnRyYW5zYWN0aW9uU2lnbmF0dXJlcy5wdXNoKHNpZ25hdHVyZSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gVGhpcyB0cmFuc2FjdGlvbiB3b3VsZCBiZSB0cmVhdGVkIGFzIGR1cGxpY2F0ZSAoaXRzIGRlcml2ZWQgc2lnbmF0dXJlXG4gICAgICAgICAgLy8gbWF0Y2hlZCB0byBvbmUgb2YgYWxyZWFkeSByZWNvcmRlZCBzaWduYXR1cmVzKS5cbiAgICAgICAgICAvLyBTbywgd2UgbXVzdCBmZXRjaCBhIG5ldyBibG9ja2hhc2ggZm9yIGEgZGlmZmVyZW50IHNpZ25hdHVyZSBieSBkaXNhYmxpbmdcbiAgICAgICAgICAvLyBvdXIgY2FjaGUgbm90IHRvIHdhaXQgZm9yIHRoZSBjYWNoZSBleHBpcmF0aW9uIChCTE9DS0hBU0hfQ0FDSEVfVElNRU9VVF9NUykuXG4gICAgICAgICAgZGlzYWJsZUNhY2hlID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCB3aXJlVHJhbnNhY3Rpb24gPSB0cmFuc2FjdGlvbi5zZXJpYWxpemUoKTtcbiAgICByZXR1cm4gYXdhaXQgdGhpcy5zZW5kUmF3VHJhbnNhY3Rpb24od2lyZVRyYW5zYWN0aW9uLCBvcHRpb25zKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZW5kIGEgdHJhbnNhY3Rpb24gdGhhdCBoYXMgYWxyZWFkeSBiZWVuIHNpZ25lZCBhbmQgc2VyaWFsaXplZCBpbnRvIHRoZVxuICAgKiB3aXJlIGZvcm1hdFxuICAgKi9cbiAgYXN5bmMgc2VuZFJhd1RyYW5zYWN0aW9uKHJhd1RyYW5zYWN0aW9uLCBvcHRpb25zKSB7XG4gICAgY29uc3QgZW5jb2RlZFRyYW5zYWN0aW9uID0gdG9CdWZmZXIocmF3VHJhbnNhY3Rpb24pLnRvU3RyaW5nKCdiYXNlNjQnKTtcbiAgICBjb25zdCByZXN1bHQgPSBhd2FpdCB0aGlzLnNlbmRFbmNvZGVkVHJhbnNhY3Rpb24oZW5jb2RlZFRyYW5zYWN0aW9uLCBvcHRpb25zKTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgLyoqXG4gICAqIFNlbmQgYSB0cmFuc2FjdGlvbiB0aGF0IGhhcyBhbHJlYWR5IGJlZW4gc2lnbmVkLCBzZXJpYWxpemVkIGludG8gdGhlXG4gICAqIHdpcmUgZm9ybWF0LCBhbmQgZW5jb2RlZCBhcyBhIGJhc2U2NCBzdHJpbmdcbiAgICovXG4gIGFzeW5jIHNlbmRFbmNvZGVkVHJhbnNhY3Rpb24oZW5jb2RlZFRyYW5zYWN0aW9uLCBvcHRpb25zKSB7XG4gICAgY29uc3QgY29uZmlnID0ge1xuICAgICAgZW5jb2Rpbmc6ICdiYXNlNjQnXG4gICAgfTtcbiAgICBjb25zdCBza2lwUHJlZmxpZ2h0ID0gb3B0aW9ucyAmJiBvcHRpb25zLnNraXBQcmVmbGlnaHQ7XG4gICAgY29uc3QgcHJlZmxpZ2h0Q29tbWl0bWVudCA9IHNraXBQcmVmbGlnaHQgPT09IHRydWUgPyAncHJvY2Vzc2VkJyAvLyBGSVhNRSBSZW1vdmUgd2hlbiBodHRwczovL2dpdGh1Yi5jb20vYW56YS14eXovYWdhdmUvcHVsbC80ODMgaXMgZGVwbG95ZWQuXG4gICAgOiBvcHRpb25zICYmIG9wdGlvbnMucHJlZmxpZ2h0Q29tbWl0bWVudCB8fCB0aGlzLmNvbW1pdG1lbnQ7XG4gICAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5tYXhSZXRyaWVzICE9IG51bGwpIHtcbiAgICAgIGNvbmZpZy5tYXhSZXRyaWVzID0gb3B0aW9ucy5tYXhSZXRyaWVzO1xuICAgIH1cbiAgICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLm1pbkNvbnRleHRTbG90ICE9IG51bGwpIHtcbiAgICAgIGNvbmZpZy5taW5Db250ZXh0U2xvdCA9IG9wdGlvbnMubWluQ29udGV4dFNsb3Q7XG4gICAgfVxuICAgIGlmIChza2lwUHJlZmxpZ2h0KSB7XG4gICAgICBjb25maWcuc2tpcFByZWZsaWdodCA9IHNraXBQcmVmbGlnaHQ7XG4gICAgfVxuICAgIGlmIChwcmVmbGlnaHRDb21taXRtZW50KSB7XG4gICAgICBjb25maWcucHJlZmxpZ2h0Q29tbWl0bWVudCA9IHByZWZsaWdodENvbW1pdG1lbnQ7XG4gICAgfVxuICAgIGNvbnN0IGFyZ3MgPSBbZW5jb2RlZFRyYW5zYWN0aW9uLCBjb25maWddO1xuICAgIGNvbnN0IHVuc2FmZVJlcyA9IGF3YWl0IHRoaXMuX3JwY1JlcXVlc3QoJ3NlbmRUcmFuc2FjdGlvbicsIGFyZ3MpO1xuICAgIGNvbnN0IHJlcyA9IGNyZWF0ZSh1bnNhZmVSZXMsIFNlbmRUcmFuc2FjdGlvblJwY1Jlc3VsdCk7XG4gICAgaWYgKCdlcnJvcicgaW4gcmVzKSB7XG4gICAgICBsZXQgbG9ncztcbiAgICAgIGlmICgnZGF0YScgaW4gcmVzLmVycm9yKSB7XG4gICAgICAgIGxvZ3MgPSByZXMuZXJyb3IuZGF0YS5sb2dzO1xuICAgICAgfVxuICAgICAgdGhyb3cgbmV3IFNlbmRUcmFuc2FjdGlvbkVycm9yKCdmYWlsZWQgdG8gc2VuZCB0cmFuc2FjdGlvbjogJyArIHJlcy5lcnJvci5tZXNzYWdlLCBsb2dzKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlcy5yZXN1bHQ7XG4gIH1cblxuICAvKipcbiAgICogQGludGVybmFsXG4gICAqL1xuICBfd3NPbk9wZW4oKSB7XG4gICAgdGhpcy5fcnBjV2ViU29ja2V0Q29ubmVjdGVkID0gdHJ1ZTtcbiAgICB0aGlzLl9ycGNXZWJTb2NrZXRIZWFydGJlYXQgPSBzZXRJbnRlcnZhbCgoKSA9PiB7XG4gICAgICAvLyBQaW5nIHNlcnZlciBldmVyeSA1cyB0byBwcmV2ZW50IGlkbGUgdGltZW91dHNcbiAgICAgIChhc3luYyAoKSA9PiB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgYXdhaXQgdGhpcy5fcnBjV2ViU29ja2V0Lm5vdGlmeSgncGluZycpO1xuICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1lbXB0eVxuICAgICAgICB9IGNhdGNoIHt9XG4gICAgICB9KSgpO1xuICAgIH0sIDUwMDApO1xuICAgIHRoaXMuX3VwZGF0ZVN1YnNjcmlwdGlvbnMoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIF93c09uRXJyb3IoZXJyKSB7XG4gICAgdGhpcy5fcnBjV2ViU29ja2V0Q29ubmVjdGVkID0gZmFsc2U7XG4gICAgY29uc29sZS5lcnJvcignd3MgZXJyb3I6JywgZXJyLm1lc3NhZ2UpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgX3dzT25DbG9zZShjb2RlKSB7XG4gICAgdGhpcy5fcnBjV2ViU29ja2V0Q29ubmVjdGVkID0gZmFsc2U7XG4gICAgdGhpcy5fcnBjV2ViU29ja2V0R2VuZXJhdGlvbiA9ICh0aGlzLl9ycGNXZWJTb2NrZXRHZW5lcmF0aW9uICsgMSkgJSBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUjtcbiAgICBpZiAodGhpcy5fcnBjV2ViU29ja2V0SWRsZVRpbWVvdXQpIHtcbiAgICAgIGNsZWFyVGltZW91dCh0aGlzLl9ycGNXZWJTb2NrZXRJZGxlVGltZW91dCk7XG4gICAgICB0aGlzLl9ycGNXZWJTb2NrZXRJZGxlVGltZW91dCA9IG51bGw7XG4gICAgfVxuICAgIGlmICh0aGlzLl9ycGNXZWJTb2NrZXRIZWFydGJlYXQpIHtcbiAgICAgIGNsZWFySW50ZXJ2YWwodGhpcy5fcnBjV2ViU29ja2V0SGVhcnRiZWF0KTtcbiAgICAgIHRoaXMuX3JwY1dlYlNvY2tldEhlYXJ0YmVhdCA9IG51bGw7XG4gICAgfVxuICAgIGlmIChjb2RlID09PSAxMDAwKSB7XG4gICAgICAvLyBleHBsaWNpdCBjbG9zZSwgY2hlY2sgaWYgYW55IHN1YnNjcmlwdGlvbnMgaGF2ZSBiZWVuIG1hZGUgc2luY2UgY2xvc2VcbiAgICAgIHRoaXMuX3VwZGF0ZVN1YnNjcmlwdGlvbnMoKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBpbXBsaWNpdCBjbG9zZSwgcHJlcGFyZSBzdWJzY3JpcHRpb25zIGZvciBhdXRvLXJlY29ubmVjdFxuICAgIHRoaXMuX3N1YnNjcmlwdGlvbkNhbGxiYWNrc0J5U2VydmVyU3Vic2NyaXB0aW9uSWQgPSB7fTtcbiAgICBPYmplY3QuZW50cmllcyh0aGlzLl9zdWJzY3JpcHRpb25zQnlIYXNoKS5mb3JFYWNoKChbaGFzaCwgc3Vic2NyaXB0aW9uXSkgPT4ge1xuICAgICAgdGhpcy5fc2V0U3Vic2NyaXB0aW9uKGhhc2gsIHtcbiAgICAgICAgLi4uc3Vic2NyaXB0aW9uLFxuICAgICAgICBzdGF0ZTogJ3BlbmRpbmcnXG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIF9zZXRTdWJzY3JpcHRpb24oaGFzaCwgbmV4dFN1YnNjcmlwdGlvbikge1xuICAgIGNvbnN0IHByZXZTdGF0ZSA9IHRoaXMuX3N1YnNjcmlwdGlvbnNCeUhhc2hbaGFzaF0/LnN0YXRlO1xuICAgIHRoaXMuX3N1YnNjcmlwdGlvbnNCeUhhc2hbaGFzaF0gPSBuZXh0U3Vic2NyaXB0aW9uO1xuICAgIGlmIChwcmV2U3RhdGUgIT09IG5leHRTdWJzY3JpcHRpb24uc3RhdGUpIHtcbiAgICAgIGNvbnN0IHN0YXRlQ2hhbmdlQ2FsbGJhY2tzID0gdGhpcy5fc3Vic2NyaXB0aW9uU3RhdGVDaGFuZ2VDYWxsYmFja3NCeUhhc2hbaGFzaF07XG4gICAgICBpZiAoc3RhdGVDaGFuZ2VDYWxsYmFja3MpIHtcbiAgICAgICAgc3RhdGVDaGFuZ2VDYWxsYmFja3MuZm9yRWFjaChjYiA9PiB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNiKG5leHRTdWJzY3JpcHRpb24uc3RhdGUpO1xuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWVtcHR5XG4gICAgICAgICAgfSBjYXRjaCB7fVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQGludGVybmFsXG4gICAqL1xuICBfb25TdWJzY3JpcHRpb25TdGF0ZUNoYW5nZShjbGllbnRTdWJzY3JpcHRpb25JZCwgY2FsbGJhY2spIHtcbiAgICBjb25zdCBoYXNoID0gdGhpcy5fc3Vic2NyaXB0aW9uSGFzaEJ5Q2xpZW50U3Vic2NyaXB0aW9uSWRbY2xpZW50U3Vic2NyaXB0aW9uSWRdO1xuICAgIGlmIChoYXNoID09IG51bGwpIHtcbiAgICAgIHJldHVybiAoKSA9PiB7fTtcbiAgICB9XG4gICAgY29uc3Qgc3RhdGVDaGFuZ2VDYWxsYmFja3MgPSB0aGlzLl9zdWJzY3JpcHRpb25TdGF0ZUNoYW5nZUNhbGxiYWNrc0J5SGFzaFtoYXNoXSB8fD0gbmV3IFNldCgpO1xuICAgIHN0YXRlQ2hhbmdlQ2FsbGJhY2tzLmFkZChjYWxsYmFjayk7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIHN0YXRlQ2hhbmdlQ2FsbGJhY2tzLmRlbGV0ZShjYWxsYmFjayk7XG4gICAgICBpZiAoc3RhdGVDaGFuZ2VDYWxsYmFja3Muc2l6ZSA9PT0gMCkge1xuICAgICAgICBkZWxldGUgdGhpcy5fc3Vic2NyaXB0aW9uU3RhdGVDaGFuZ2VDYWxsYmFja3NCeUhhc2hbaGFzaF07XG4gICAgICB9XG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIGFzeW5jIF91cGRhdGVTdWJzY3JpcHRpb25zKCkge1xuICAgIGlmIChPYmplY3Qua2V5cyh0aGlzLl9zdWJzY3JpcHRpb25zQnlIYXNoKS5sZW5ndGggPT09IDApIHtcbiAgICAgIGlmICh0aGlzLl9ycGNXZWJTb2NrZXRDb25uZWN0ZWQpIHtcbiAgICAgICAgdGhpcy5fcnBjV2ViU29ja2V0Q29ubmVjdGVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX3JwY1dlYlNvY2tldElkbGVUaW1lb3V0ID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgdGhpcy5fcnBjV2ViU29ja2V0SWRsZVRpbWVvdXQgPSBudWxsO1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICB0aGlzLl9ycGNXZWJTb2NrZXQuY2xvc2UoKTtcbiAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIC8vIHN3YWxsb3cgZXJyb3IgaWYgc29ja2V0IGhhcyBhbHJlYWR5IGJlZW4gY2xvc2VkLlxuICAgICAgICAgICAgaWYgKGVyciBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgICAgICAgIGNvbnNvbGUubG9nKGBFcnJvciB3aGVuIGNsb3Npbmcgc29ja2V0IGNvbm5lY3Rpb246ICR7ZXJyLm1lc3NhZ2V9YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9LCA1MDApO1xuICAgICAgfVxuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAodGhpcy5fcnBjV2ViU29ja2V0SWRsZVRpbWVvdXQgIT09IG51bGwpIHtcbiAgICAgIGNsZWFyVGltZW91dCh0aGlzLl9ycGNXZWJTb2NrZXRJZGxlVGltZW91dCk7XG4gICAgICB0aGlzLl9ycGNXZWJTb2NrZXRJZGxlVGltZW91dCA9IG51bGw7XG4gICAgICB0aGlzLl9ycGNXZWJTb2NrZXRDb25uZWN0ZWQgPSB0cnVlO1xuICAgIH1cbiAgICBpZiAoIXRoaXMuX3JwY1dlYlNvY2tldENvbm5lY3RlZCkge1xuICAgICAgdGhpcy5fcnBjV2ViU29ja2V0LmNvbm5lY3QoKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgYWN0aXZlV2ViU29ja2V0R2VuZXJhdGlvbiA9IHRoaXMuX3JwY1dlYlNvY2tldEdlbmVyYXRpb247XG4gICAgY29uc3QgaXNDdXJyZW50Q29ubmVjdGlvblN0aWxsQWN0aXZlID0gKCkgPT4ge1xuICAgICAgcmV0dXJuIGFjdGl2ZVdlYlNvY2tldEdlbmVyYXRpb24gPT09IHRoaXMuX3JwY1dlYlNvY2tldEdlbmVyYXRpb247XG4gICAgfTtcbiAgICBhd2FpdCBQcm9taXNlLmFsbChcbiAgICAvLyBEb24ndCBiZSB0ZW1wdGVkIHRvIGNoYW5nZSB0aGlzIHRvIGBPYmplY3QuZW50cmllc2AuIFdlIGNhbGxcbiAgICAvLyBgX3VwZGF0ZVN1YnNjcmlwdGlvbnNgIHJlY3Vyc2l2ZWx5IHdoZW4gcHJvY2Vzc2luZyB0aGUgc3RhdGUsXG4gICAgLy8gc28gaXQncyBpbXBvcnRhbnQgdGhhdCB3ZSBsb29rIHVwIHRoZSAqY3VycmVudCogdmVyc2lvbiBvZlxuICAgIC8vIGVhY2ggc3Vic2NyaXB0aW9uLCBldmVyeSB0aW1lIHdlIHByb2Nlc3MgYSBoYXNoLlxuICAgIE9iamVjdC5rZXlzKHRoaXMuX3N1YnNjcmlwdGlvbnNCeUhhc2gpLm1hcChhc3luYyBoYXNoID0+IHtcbiAgICAgIGNvbnN0IHN1YnNjcmlwdGlvbiA9IHRoaXMuX3N1YnNjcmlwdGlvbnNCeUhhc2hbaGFzaF07XG4gICAgICBpZiAoc3Vic2NyaXB0aW9uID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgLy8gVGhpcyBlbnRyeSBoYXMgc2luY2UgYmVlbiBkZWxldGVkLiBTa2lwLlxuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBzd2l0Y2ggKHN1YnNjcmlwdGlvbi5zdGF0ZSkge1xuICAgICAgICBjYXNlICdwZW5kaW5nJzpcbiAgICAgICAgY2FzZSAndW5zdWJzY3JpYmVkJzpcbiAgICAgICAgICBpZiAoc3Vic2NyaXB0aW9uLmNhbGxiYWNrcy5zaXplID09PSAwKSB7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFlvdSBjYW4gZW5kIHVwIGhlcmUgd2hlbjpcbiAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgKiAtIGEgc3Vic2NyaXB0aW9uIGhhcyByZWNlbnRseSB1bnN1YnNjcmliZWRcbiAgICAgICAgICAgICAqICAgd2l0aG91dCBoYXZpbmcgbmV3IGNhbGxiYWNrcyBhZGRlZCB0byBpdFxuICAgICAgICAgICAgICogICB3aGlsZSB0aGUgdW5zdWJzY3JpYmUgd2FzIGluIGZsaWdodCwgb3JcbiAgICAgICAgICAgICAqIC0gd2hlbiBhIHBlbmRpbmcgc3Vic2NyaXB0aW9uIGhhcyBpdHNcbiAgICAgICAgICAgICAqICAgbGlzdGVuZXJzIHJlbW92ZWQgYmVmb3JlIGEgcmVxdWVzdCB3YXNcbiAgICAgICAgICAgICAqICAgc2VudCB0byB0aGUgc2VydmVyLlxuICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAqIEJlaW5nIHRoYXQgbm9ib2R5IGlzIGludGVyZXN0ZWQgaW4gdGhpc1xuICAgICAgICAgICAgICogc3Vic2NyaXB0aW9uIGFueSBsb25nZXIsIGRlbGV0ZSBpdC5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgZGVsZXRlIHRoaXMuX3N1YnNjcmlwdGlvbnNCeUhhc2hbaGFzaF07XG4gICAgICAgICAgICBpZiAoc3Vic2NyaXB0aW9uLnN0YXRlID09PSAndW5zdWJzY3JpYmVkJykge1xuICAgICAgICAgICAgICBkZWxldGUgdGhpcy5fc3Vic2NyaXB0aW9uQ2FsbGJhY2tzQnlTZXJ2ZXJTdWJzY3JpcHRpb25JZFtzdWJzY3JpcHRpb24uc2VydmVyU3Vic2NyaXB0aW9uSWRdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYXdhaXQgdGhpcy5fdXBkYXRlU3Vic2NyaXB0aW9ucygpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICBhd2FpdCAoYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgY29uc3Qge1xuICAgICAgICAgICAgICBhcmdzLFxuICAgICAgICAgICAgICBtZXRob2RcbiAgICAgICAgICAgIH0gPSBzdWJzY3JpcHRpb247XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICB0aGlzLl9zZXRTdWJzY3JpcHRpb24oaGFzaCwge1xuICAgICAgICAgICAgICAgIC4uLnN1YnNjcmlwdGlvbixcbiAgICAgICAgICAgICAgICBzdGF0ZTogJ3N1YnNjcmliaW5nJ1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgY29uc3Qgc2VydmVyU3Vic2NyaXB0aW9uSWQgPSBhd2FpdCB0aGlzLl9ycGNXZWJTb2NrZXQuY2FsbChtZXRob2QsIGFyZ3MpO1xuICAgICAgICAgICAgICB0aGlzLl9zZXRTdWJzY3JpcHRpb24oaGFzaCwge1xuICAgICAgICAgICAgICAgIC4uLnN1YnNjcmlwdGlvbixcbiAgICAgICAgICAgICAgICBzZXJ2ZXJTdWJzY3JpcHRpb25JZCxcbiAgICAgICAgICAgICAgICBzdGF0ZTogJ3N1YnNjcmliZWQnXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICB0aGlzLl9zdWJzY3JpcHRpb25DYWxsYmFja3NCeVNlcnZlclN1YnNjcmlwdGlvbklkW3NlcnZlclN1YnNjcmlwdGlvbklkXSA9IHN1YnNjcmlwdGlvbi5jYWxsYmFja3M7XG4gICAgICAgICAgICAgIGF3YWl0IHRoaXMuX3VwZGF0ZVN1YnNjcmlwdGlvbnMoKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgaWYgKGUgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoYCR7bWV0aG9kfSBlcnJvciBmb3IgYXJndW1lbnRgLCBhcmdzLCBlLm1lc3NhZ2UpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmICghaXNDdXJyZW50Q29ubmVjdGlvblN0aWxsQWN0aXZlKCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgLy8gVE9ETzogTWF5YmUgYWRkIGFuICdlcnJvcmVkJyBzdGF0ZSBvciBhIHJldHJ5IGxpbWl0P1xuICAgICAgICAgICAgICB0aGlzLl9zZXRTdWJzY3JpcHRpb24oaGFzaCwge1xuICAgICAgICAgICAgICAgIC4uLnN1YnNjcmlwdGlvbixcbiAgICAgICAgICAgICAgICBzdGF0ZTogJ3BlbmRpbmcnXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICBhd2FpdCB0aGlzLl91cGRhdGVTdWJzY3JpcHRpb25zKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSkoKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnc3Vic2NyaWJlZCc6XG4gICAgICAgICAgaWYgKHN1YnNjcmlwdGlvbi5jYWxsYmFja3Muc2l6ZSA9PT0gMCkge1xuICAgICAgICAgICAgLy8gQnkgdGhlIHRpbWUgd2Ugc3VjY2Vzc2Z1bGx5IHNldCB1cCBhIHN1YnNjcmlwdGlvblxuICAgICAgICAgICAgLy8gd2l0aCB0aGUgc2VydmVyLCB0aGUgY2xpZW50IHN0b3BwZWQgY2FyaW5nIGFib3V0IGl0LlxuICAgICAgICAgICAgLy8gVGVhciBpdCBkb3duIG5vdy5cbiAgICAgICAgICAgIGF3YWl0IChhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICAgIGNvbnN0IHtcbiAgICAgICAgICAgICAgICBzZXJ2ZXJTdWJzY3JpcHRpb25JZCxcbiAgICAgICAgICAgICAgICB1bnN1YnNjcmliZU1ldGhvZFxuICAgICAgICAgICAgICB9ID0gc3Vic2NyaXB0aW9uO1xuICAgICAgICAgICAgICBpZiAodGhpcy5fc3Vic2NyaXB0aW9uc0F1dG9EaXNwb3NlZEJ5UnBjLmhhcyhzZXJ2ZXJTdWJzY3JpcHRpb25JZCkpIHtcbiAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgKiBTcGVjaWFsIGNhc2UuXG4gICAgICAgICAgICAgICAgICogSWYgd2UncmUgZGVhbGluZyB3aXRoIGEgc3Vic2NyaXB0aW9uIHRoYXQgaGFzIGJlZW4gYXV0by1cbiAgICAgICAgICAgICAgICAgKiBkaXNwb3NlZCBieSB0aGUgUlBDLCB0aGVuIHdlIGNhbiBza2lwIHRoZSBSUEMgY2FsbCB0b1xuICAgICAgICAgICAgICAgICAqIHRlYXIgZG93biB0aGUgc3Vic2NyaXB0aW9uIGhlcmUuXG4gICAgICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAgICAgKiBOT1RFOiBUaGVyZSBpcyBhIHByb3Bvc2FsIHRvIGVsaW1pbmF0ZSB0aGlzIHNwZWNpYWwgY2FzZSwgaGVyZTpcbiAgICAgICAgICAgICAgICAgKiBodHRwczovL2dpdGh1Yi5jb20vc29sYW5hLWxhYnMvc29sYW5hL2lzc3Vlcy8xODg5MlxuICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgIHRoaXMuX3N1YnNjcmlwdGlvbnNBdXRvRGlzcG9zZWRCeVJwYy5kZWxldGUoc2VydmVyU3Vic2NyaXB0aW9uSWQpO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuX3NldFN1YnNjcmlwdGlvbihoYXNoLCB7XG4gICAgICAgICAgICAgICAgICAuLi5zdWJzY3JpcHRpb24sXG4gICAgICAgICAgICAgICAgICBzdGF0ZTogJ3Vuc3Vic2NyaWJpbmcnXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgdGhpcy5fc2V0U3Vic2NyaXB0aW9uKGhhc2gsIHtcbiAgICAgICAgICAgICAgICAgIC4uLnN1YnNjcmlwdGlvbixcbiAgICAgICAgICAgICAgICAgIHN0YXRlOiAndW5zdWJzY3JpYmluZydcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5fcnBjV2ViU29ja2V0LmNhbGwodW5zdWJzY3JpYmVNZXRob2QsIFtzZXJ2ZXJTdWJzY3JpcHRpb25JZF0pO1xuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgIGlmIChlIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihgJHt1bnN1YnNjcmliZU1ldGhvZH0gZXJyb3I6YCwgZS5tZXNzYWdlKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIGlmICghaXNDdXJyZW50Q29ubmVjdGlvblN0aWxsQWN0aXZlKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgLy8gVE9ETzogTWF5YmUgYWRkIGFuICdlcnJvcmVkJyBzdGF0ZSBvciBhIHJldHJ5IGxpbWl0P1xuICAgICAgICAgICAgICAgICAgdGhpcy5fc2V0U3Vic2NyaXB0aW9uKGhhc2gsIHtcbiAgICAgICAgICAgICAgICAgICAgLi4uc3Vic2NyaXB0aW9uLFxuICAgICAgICAgICAgICAgICAgICBzdGF0ZTogJ3N1YnNjcmliZWQnXG4gICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMuX3VwZGF0ZVN1YnNjcmlwdGlvbnMoKTtcbiAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgdGhpcy5fc2V0U3Vic2NyaXB0aW9uKGhhc2gsIHtcbiAgICAgICAgICAgICAgICAuLi5zdWJzY3JpcHRpb24sXG4gICAgICAgICAgICAgICAgc3RhdGU6ICd1bnN1YnNjcmliZWQnXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICBhd2FpdCB0aGlzLl91cGRhdGVTdWJzY3JpcHRpb25zKCk7XG4gICAgICAgICAgICB9KSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9KSk7XG4gIH1cblxuICAvKipcbiAgICogQGludGVybmFsXG4gICAqL1xuICBfaGFuZGxlU2VydmVyTm90aWZpY2F0aW9uKHNlcnZlclN1YnNjcmlwdGlvbklkLCBjYWxsYmFja0FyZ3MpIHtcbiAgICBjb25zdCBjYWxsYmFja3MgPSB0aGlzLl9zdWJzY3JpcHRpb25DYWxsYmFja3NCeVNlcnZlclN1YnNjcmlwdGlvbklkW3NlcnZlclN1YnNjcmlwdGlvbklkXTtcbiAgICBpZiAoY2FsbGJhY2tzID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY2FsbGJhY2tzLmZvckVhY2goY2IgPT4ge1xuICAgICAgdHJ5IHtcbiAgICAgICAgY2IoXG4gICAgICAgIC8vIEkgZmFpbGVkIHRvIGZpbmQgYSB3YXkgdG8gY29udmluY2UgVHlwZVNjcmlwdCB0aGF0IGBjYmAgaXMgb2YgdHlwZVxuICAgICAgICAvLyBgVENhbGxiYWNrYCB3aGljaCBpcyBjZXJ0YWlubHkgY29tcGF0aWJsZSB3aXRoIGBQYXJhbWV0ZXJzPFRDYWxsYmFjaz5gLlxuICAgICAgICAvLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL21pY3Jvc29mdC9UeXBlU2NyaXB0L2lzc3Vlcy80NzYxNVxuICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgIC4uLmNhbGxiYWNrQXJncyk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoZSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogQGludGVybmFsXG4gICAqL1xuICBfd3NPbkFjY291bnROb3RpZmljYXRpb24obm90aWZpY2F0aW9uKSB7XG4gICAgY29uc3Qge1xuICAgICAgcmVzdWx0LFxuICAgICAgc3Vic2NyaXB0aW9uXG4gICAgfSA9IGNyZWF0ZShub3RpZmljYXRpb24sIEFjY291bnROb3RpZmljYXRpb25SZXN1bHQpO1xuICAgIHRoaXMuX2hhbmRsZVNlcnZlck5vdGlmaWNhdGlvbihzdWJzY3JpcHRpb24sIFtyZXN1bHQudmFsdWUsIHJlc3VsdC5jb250ZXh0XSk7XG4gIH1cblxuICAvKipcbiAgICogQGludGVybmFsXG4gICAqL1xuICBfbWFrZVN1YnNjcmlwdGlvbihzdWJzY3JpcHRpb25Db25maWcsXG4gIC8qKlxuICAgKiBXaGVuIHByZXBhcmluZyBgYXJnc2AgZm9yIGEgY2FsbCB0byBgX21ha2VTdWJzY3JpcHRpb25gLCBiZSBzdXJlXG4gICAqIHRvIGNhcmVmdWxseSBhcHBseSBhIGRlZmF1bHQgYGNvbW1pdG1lbnRgIHByb3BlcnR5LCBpZiBuZWNlc3NhcnkuXG4gICAqXG4gICAqIC0gSWYgdGhlIHVzZXIgc3VwcGxpZWQgYSBgY29tbWl0bWVudGAgdXNlIHRoYXQuXG4gICAqIC0gT3RoZXJ3aXNlLCBpZiB0aGUgYENvbm5lY3Rpb246OmNvbW1pdG1lbnRgIGlzIHNldCwgdXNlIHRoYXQuXG4gICAqIC0gT3RoZXJ3aXNlLCBzZXQgaXQgdG8gdGhlIFJQQyBzZXJ2ZXIgZGVmYXVsdDogYGZpbmFsaXplZGAuXG4gICAqXG4gICAqIFRoaXMgaXMgZXh0cmVtZWx5IGltcG9ydGFudCB0byBlbnN1cmUgdGhhdCB0aGVzZSB0d28gZnVuZGFtZW50YWxseVxuICAgKiBpZGVudGljYWwgc3Vic2NyaXB0aW9ucyBwcm9kdWNlIHRoZSBzYW1lIGlkZW50aWZ5aW5nIGhhc2g6XG4gICAqXG4gICAqIC0gQSBzdWJzY3JpcHRpb24gbWFkZSB3aXRob3V0IHNwZWNpZnlpbmcgYSBjb21taXRtZW50LlxuICAgKiAtIEEgc3Vic2NyaXB0aW9uIG1hZGUgd2hlcmUgdGhlIGNvbW1pdG1lbnQgc3BlY2lmaWVkIGlzIHRoZSBzYW1lXG4gICAqICAgYXMgdGhlIGRlZmF1bHQgYXBwbGllZCB0byB0aGUgc3Vic2NyaXB0aW9uIGFib3ZlLlxuICAgKlxuICAgKiBFeGFtcGxlOyB0aGVzZSB0d28gc3Vic2NyaXB0aW9ucyBtdXN0IHByb2R1Y2UgdGhlIHNhbWUgaGFzaDpcbiAgICpcbiAgICogLSBBbiBgYWNjb3VudFN1YnNjcmliZWAgc3Vic2NyaXB0aW9uIGZvciBgJ1BVQktFWSdgXG4gICAqIC0gQW4gYGFjY291bnRTdWJzY3JpYmVgIHN1YnNjcmlwdGlvbiBmb3IgYCdQVUJLRVknYCB3aXRoIGNvbW1pdG1lbnRcbiAgICogICBgJ2ZpbmFsaXplZCdgLlxuICAgKlxuICAgKiBTZWUgdGhlICdtYWtpbmcgYSBzdWJzY3JpcHRpb24gd2l0aCBkZWZhdWx0ZWQgcGFyYW1zIG9taXR0ZWQnIHRlc3RcbiAgICogaW4gYGNvbm5lY3Rpb24tc3Vic2NyaXB0aW9ucy50c2AgZm9yIG1vcmUuXG4gICAqL1xuICBhcmdzKSB7XG4gICAgY29uc3QgY2xpZW50U3Vic2NyaXB0aW9uSWQgPSB0aGlzLl9uZXh0Q2xpZW50U3Vic2NyaXB0aW9uSWQrKztcbiAgICBjb25zdCBoYXNoID0gZmFzdFN0YWJsZVN0cmluZ2lmeSQxKFtzdWJzY3JpcHRpb25Db25maWcubWV0aG9kLCBhcmdzXSk7XG4gICAgY29uc3QgZXhpc3RpbmdTdWJzY3JpcHRpb24gPSB0aGlzLl9zdWJzY3JpcHRpb25zQnlIYXNoW2hhc2hdO1xuICAgIGlmIChleGlzdGluZ1N1YnNjcmlwdGlvbiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aGlzLl9zdWJzY3JpcHRpb25zQnlIYXNoW2hhc2hdID0ge1xuICAgICAgICAuLi5zdWJzY3JpcHRpb25Db25maWcsXG4gICAgICAgIGFyZ3MsXG4gICAgICAgIGNhbGxiYWNrczogbmV3IFNldChbc3Vic2NyaXB0aW9uQ29uZmlnLmNhbGxiYWNrXSksXG4gICAgICAgIHN0YXRlOiAncGVuZGluZydcbiAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIGV4aXN0aW5nU3Vic2NyaXB0aW9uLmNhbGxiYWNrcy5hZGQoc3Vic2NyaXB0aW9uQ29uZmlnLmNhbGxiYWNrKTtcbiAgICB9XG4gICAgdGhpcy5fc3Vic2NyaXB0aW9uSGFzaEJ5Q2xpZW50U3Vic2NyaXB0aW9uSWRbY2xpZW50U3Vic2NyaXB0aW9uSWRdID0gaGFzaDtcbiAgICB0aGlzLl9zdWJzY3JpcHRpb25EaXNwb3NlRnVuY3Rpb25zQnlDbGllbnRTdWJzY3JpcHRpb25JZFtjbGllbnRTdWJzY3JpcHRpb25JZF0gPSBhc3luYyAoKSA9PiB7XG4gICAgICBkZWxldGUgdGhpcy5fc3Vic2NyaXB0aW9uRGlzcG9zZUZ1bmN0aW9uc0J5Q2xpZW50U3Vic2NyaXB0aW9uSWRbY2xpZW50U3Vic2NyaXB0aW9uSWRdO1xuICAgICAgZGVsZXRlIHRoaXMuX3N1YnNjcmlwdGlvbkhhc2hCeUNsaWVudFN1YnNjcmlwdGlvbklkW2NsaWVudFN1YnNjcmlwdGlvbklkXTtcbiAgICAgIGNvbnN0IHN1YnNjcmlwdGlvbiA9IHRoaXMuX3N1YnNjcmlwdGlvbnNCeUhhc2hbaGFzaF07XG4gICAgICBhc3NlcnQoc3Vic2NyaXB0aW9uICE9PSB1bmRlZmluZWQsIGBDb3VsZCBub3QgZmluZCBhIFxcYFN1YnNjcmlwdGlvblxcYCB3aGVuIHRlYXJpbmcgZG93biBjbGllbnQgc3Vic2NyaXB0aW9uICMke2NsaWVudFN1YnNjcmlwdGlvbklkfWApO1xuICAgICAgc3Vic2NyaXB0aW9uLmNhbGxiYWNrcy5kZWxldGUoc3Vic2NyaXB0aW9uQ29uZmlnLmNhbGxiYWNrKTtcbiAgICAgIGF3YWl0IHRoaXMuX3VwZGF0ZVN1YnNjcmlwdGlvbnMoKTtcbiAgICB9O1xuICAgIHRoaXMuX3VwZGF0ZVN1YnNjcmlwdGlvbnMoKTtcbiAgICByZXR1cm4gY2xpZW50U3Vic2NyaXB0aW9uSWQ7XG4gIH1cblxuICAvKipcbiAgICogUmVnaXN0ZXIgYSBjYWxsYmFjayB0byBiZSBpbnZva2VkIHdoZW5ldmVyIHRoZSBzcGVjaWZpZWQgYWNjb3VudCBjaGFuZ2VzXG4gICAqXG4gICAqIEBwYXJhbSBwdWJsaWNLZXkgUHVibGljIGtleSBvZiB0aGUgYWNjb3VudCB0byBtb25pdG9yXG4gICAqIEBwYXJhbSBjYWxsYmFjayBGdW5jdGlvbiB0byBpbnZva2Ugd2hlbmV2ZXIgdGhlIGFjY291bnQgaXMgY2hhbmdlZFxuICAgKiBAcGFyYW0gY29tbWl0bWVudCBTcGVjaWZ5IHRoZSBjb21taXRtZW50IGxldmVsIGFjY291bnQgY2hhbmdlcyBtdXN0IHJlYWNoIGJlZm9yZSBub3RpZmljYXRpb25cbiAgICogQHJldHVybiBzdWJzY3JpcHRpb24gaWRcbiAgICovXG4gIG9uQWNjb3VudENoYW5nZShwdWJsaWNLZXksIGNhbGxiYWNrLCBjb21taXRtZW50KSB7XG4gICAgY29uc3QgYXJncyA9IHRoaXMuX2J1aWxkQXJncyhbcHVibGljS2V5LnRvQmFzZTU4KCldLCBjb21taXRtZW50IHx8IHRoaXMuX2NvbW1pdG1lbnQgfHwgJ2ZpbmFsaXplZCcsXG4gICAgLy8gQXBwbHkgY29ubmVjdGlvbi9zZXJ2ZXIgZGVmYXVsdC5cbiAgICAnYmFzZTY0Jyk7XG4gICAgcmV0dXJuIHRoaXMuX21ha2VTdWJzY3JpcHRpb24oe1xuICAgICAgY2FsbGJhY2ssXG4gICAgICBtZXRob2Q6ICdhY2NvdW50U3Vic2NyaWJlJyxcbiAgICAgIHVuc3Vic2NyaWJlTWV0aG9kOiAnYWNjb3VudFVuc3Vic2NyaWJlJ1xuICAgIH0sIGFyZ3MpO1xuICB9XG5cbiAgLyoqXG4gICAqIERlcmVnaXN0ZXIgYW4gYWNjb3VudCBub3RpZmljYXRpb24gY2FsbGJhY2tcbiAgICpcbiAgICogQHBhcmFtIGNsaWVudFN1YnNjcmlwdGlvbklkIGNsaWVudCBzdWJzY3JpcHRpb24gaWQgdG8gZGVyZWdpc3RlclxuICAgKi9cbiAgYXN5bmMgcmVtb3ZlQWNjb3VudENoYW5nZUxpc3RlbmVyKGNsaWVudFN1YnNjcmlwdGlvbklkKSB7XG4gICAgYXdhaXQgdGhpcy5fdW5zdWJzY3JpYmVDbGllbnRTdWJzY3JpcHRpb24oY2xpZW50U3Vic2NyaXB0aW9uSWQsICdhY2NvdW50IGNoYW5nZScpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgX3dzT25Qcm9ncmFtQWNjb3VudE5vdGlmaWNhdGlvbihub3RpZmljYXRpb24pIHtcbiAgICBjb25zdCB7XG4gICAgICByZXN1bHQsXG4gICAgICBzdWJzY3JpcHRpb25cbiAgICB9ID0gY3JlYXRlKG5vdGlmaWNhdGlvbiwgUHJvZ3JhbUFjY291bnROb3RpZmljYXRpb25SZXN1bHQpO1xuICAgIHRoaXMuX2hhbmRsZVNlcnZlck5vdGlmaWNhdGlvbihzdWJzY3JpcHRpb24sIFt7XG4gICAgICBhY2NvdW50SWQ6IHJlc3VsdC52YWx1ZS5wdWJrZXksXG4gICAgICBhY2NvdW50SW5mbzogcmVzdWx0LnZhbHVlLmFjY291bnRcbiAgICB9LCByZXN1bHQuY29udGV4dF0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlZ2lzdGVyIGEgY2FsbGJhY2sgdG8gYmUgaW52b2tlZCB3aGVuZXZlciBhY2NvdW50cyBvd25lZCBieSB0aGVcbiAgICogc3BlY2lmaWVkIHByb2dyYW0gY2hhbmdlXG4gICAqXG4gICAqIEBwYXJhbSBwcm9ncmFtSWQgUHVibGljIGtleSBvZiB0aGUgcHJvZ3JhbSB0byBtb25pdG9yXG4gICAqIEBwYXJhbSBjYWxsYmFjayBGdW5jdGlvbiB0byBpbnZva2Ugd2hlbmV2ZXIgdGhlIGFjY291bnQgaXMgY2hhbmdlZFxuICAgKiBAcGFyYW0gY29tbWl0bWVudCBTcGVjaWZ5IHRoZSBjb21taXRtZW50IGxldmVsIGFjY291bnQgY2hhbmdlcyBtdXN0IHJlYWNoIGJlZm9yZSBub3RpZmljYXRpb25cbiAgICogQHBhcmFtIGZpbHRlcnMgVGhlIHByb2dyYW0gYWNjb3VudCBmaWx0ZXJzIHRvIHBhc3MgaW50byB0aGUgUlBDIG1ldGhvZFxuICAgKiBAcmV0dXJuIHN1YnNjcmlwdGlvbiBpZFxuICAgKi9cbiAgb25Qcm9ncmFtQWNjb3VudENoYW5nZShwcm9ncmFtSWQsIGNhbGxiYWNrLCBjb21taXRtZW50LCBmaWx0ZXJzKSB7XG4gICAgY29uc3QgYXJncyA9IHRoaXMuX2J1aWxkQXJncyhbcHJvZ3JhbUlkLnRvQmFzZTU4KCldLCBjb21taXRtZW50IHx8IHRoaXMuX2NvbW1pdG1lbnQgfHwgJ2ZpbmFsaXplZCcsXG4gICAgLy8gQXBwbHkgY29ubmVjdGlvbi9zZXJ2ZXIgZGVmYXVsdC5cbiAgICAnYmFzZTY0JyAvKiBlbmNvZGluZyAqLywgZmlsdGVycyA/IHtcbiAgICAgIGZpbHRlcnM6IGZpbHRlcnNcbiAgICB9IDogdW5kZWZpbmVkIC8qIGV4dHJhICovKTtcbiAgICByZXR1cm4gdGhpcy5fbWFrZVN1YnNjcmlwdGlvbih7XG4gICAgICBjYWxsYmFjayxcbiAgICAgIG1ldGhvZDogJ3Byb2dyYW1TdWJzY3JpYmUnLFxuICAgICAgdW5zdWJzY3JpYmVNZXRob2Q6ICdwcm9ncmFtVW5zdWJzY3JpYmUnXG4gICAgfSwgYXJncyk7XG4gIH1cblxuICAvKipcbiAgICogRGVyZWdpc3RlciBhbiBhY2NvdW50IG5vdGlmaWNhdGlvbiBjYWxsYmFja1xuICAgKlxuICAgKiBAcGFyYW0gY2xpZW50U3Vic2NyaXB0aW9uSWQgY2xpZW50IHN1YnNjcmlwdGlvbiBpZCB0byBkZXJlZ2lzdGVyXG4gICAqL1xuICBhc3luYyByZW1vdmVQcm9ncmFtQWNjb3VudENoYW5nZUxpc3RlbmVyKGNsaWVudFN1YnNjcmlwdGlvbklkKSB7XG4gICAgYXdhaXQgdGhpcy5fdW5zdWJzY3JpYmVDbGllbnRTdWJzY3JpcHRpb24oY2xpZW50U3Vic2NyaXB0aW9uSWQsICdwcm9ncmFtIGFjY291bnQgY2hhbmdlJyk7XG4gIH1cblxuICAvKipcbiAgICogUmVnaXN0ZXJzIGEgY2FsbGJhY2sgdG8gYmUgaW52b2tlZCB3aGVuZXZlciBsb2dzIGFyZSBlbWl0dGVkLlxuICAgKi9cbiAgb25Mb2dzKGZpbHRlciwgY2FsbGJhY2ssIGNvbW1pdG1lbnQpIHtcbiAgICBjb25zdCBhcmdzID0gdGhpcy5fYnVpbGRBcmdzKFt0eXBlb2YgZmlsdGVyID09PSAnb2JqZWN0JyA/IHtcbiAgICAgIG1lbnRpb25zOiBbZmlsdGVyLnRvU3RyaW5nKCldXG4gICAgfSA6IGZpbHRlcl0sIGNvbW1pdG1lbnQgfHwgdGhpcy5fY29tbWl0bWVudCB8fCAnZmluYWxpemVkJyAvLyBBcHBseSBjb25uZWN0aW9uL3NlcnZlciBkZWZhdWx0LlxuICAgICk7XG4gICAgcmV0dXJuIHRoaXMuX21ha2VTdWJzY3JpcHRpb24oe1xuICAgICAgY2FsbGJhY2ssXG4gICAgICBtZXRob2Q6ICdsb2dzU3Vic2NyaWJlJyxcbiAgICAgIHVuc3Vic2NyaWJlTWV0aG9kOiAnbG9nc1Vuc3Vic2NyaWJlJ1xuICAgIH0sIGFyZ3MpO1xuICB9XG5cbiAgLyoqXG4gICAqIERlcmVnaXN0ZXIgYSBsb2dzIGNhbGxiYWNrLlxuICAgKlxuICAgKiBAcGFyYW0gY2xpZW50U3Vic2NyaXB0aW9uSWQgY2xpZW50IHN1YnNjcmlwdGlvbiBpZCB0byBkZXJlZ2lzdGVyLlxuICAgKi9cbiAgYXN5bmMgcmVtb3ZlT25Mb2dzTGlzdGVuZXIoY2xpZW50U3Vic2NyaXB0aW9uSWQpIHtcbiAgICBhd2FpdCB0aGlzLl91bnN1YnNjcmliZUNsaWVudFN1YnNjcmlwdGlvbihjbGllbnRTdWJzY3JpcHRpb25JZCwgJ2xvZ3MnKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIF93c09uTG9nc05vdGlmaWNhdGlvbihub3RpZmljYXRpb24pIHtcbiAgICBjb25zdCB7XG4gICAgICByZXN1bHQsXG4gICAgICBzdWJzY3JpcHRpb25cbiAgICB9ID0gY3JlYXRlKG5vdGlmaWNhdGlvbiwgTG9nc05vdGlmaWNhdGlvblJlc3VsdCk7XG4gICAgdGhpcy5faGFuZGxlU2VydmVyTm90aWZpY2F0aW9uKHN1YnNjcmlwdGlvbiwgW3Jlc3VsdC52YWx1ZSwgcmVzdWx0LmNvbnRleHRdKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIF93c09uU2xvdE5vdGlmaWNhdGlvbihub3RpZmljYXRpb24pIHtcbiAgICBjb25zdCB7XG4gICAgICByZXN1bHQsXG4gICAgICBzdWJzY3JpcHRpb25cbiAgICB9ID0gY3JlYXRlKG5vdGlmaWNhdGlvbiwgU2xvdE5vdGlmaWNhdGlvblJlc3VsdCk7XG4gICAgdGhpcy5faGFuZGxlU2VydmVyTm90aWZpY2F0aW9uKHN1YnNjcmlwdGlvbiwgW3Jlc3VsdF0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlZ2lzdGVyIGEgY2FsbGJhY2sgdG8gYmUgaW52b2tlZCB1cG9uIHNsb3QgY2hhbmdlc1xuICAgKlxuICAgKiBAcGFyYW0gY2FsbGJhY2sgRnVuY3Rpb24gdG8gaW52b2tlIHdoZW5ldmVyIHRoZSBzbG90IGNoYW5nZXNcbiAgICogQHJldHVybiBzdWJzY3JpcHRpb24gaWRcbiAgICovXG4gIG9uU2xvdENoYW5nZShjYWxsYmFjaykge1xuICAgIHJldHVybiB0aGlzLl9tYWtlU3Vic2NyaXB0aW9uKHtcbiAgICAgIGNhbGxiYWNrLFxuICAgICAgbWV0aG9kOiAnc2xvdFN1YnNjcmliZScsXG4gICAgICB1bnN1YnNjcmliZU1ldGhvZDogJ3Nsb3RVbnN1YnNjcmliZSdcbiAgICB9LCBbXSAvKiBhcmdzICovKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZXJlZ2lzdGVyIGEgc2xvdCBub3RpZmljYXRpb24gY2FsbGJhY2tcbiAgICpcbiAgICogQHBhcmFtIGNsaWVudFN1YnNjcmlwdGlvbklkIGNsaWVudCBzdWJzY3JpcHRpb24gaWQgdG8gZGVyZWdpc3RlclxuICAgKi9cbiAgYXN5bmMgcmVtb3ZlU2xvdENoYW5nZUxpc3RlbmVyKGNsaWVudFN1YnNjcmlwdGlvbklkKSB7XG4gICAgYXdhaXQgdGhpcy5fdW5zdWJzY3JpYmVDbGllbnRTdWJzY3JpcHRpb24oY2xpZW50U3Vic2NyaXB0aW9uSWQsICdzbG90IGNoYW5nZScpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgX3dzT25TbG90VXBkYXRlc05vdGlmaWNhdGlvbihub3RpZmljYXRpb24pIHtcbiAgICBjb25zdCB7XG4gICAgICByZXN1bHQsXG4gICAgICBzdWJzY3JpcHRpb25cbiAgICB9ID0gY3JlYXRlKG5vdGlmaWNhdGlvbiwgU2xvdFVwZGF0ZU5vdGlmaWNhdGlvblJlc3VsdCk7XG4gICAgdGhpcy5faGFuZGxlU2VydmVyTm90aWZpY2F0aW9uKHN1YnNjcmlwdGlvbiwgW3Jlc3VsdF0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlZ2lzdGVyIGEgY2FsbGJhY2sgdG8gYmUgaW52b2tlZCB1cG9uIHNsb3QgdXBkYXRlcy4ge0BsaW5rIFNsb3RVcGRhdGV9J3NcbiAgICogbWF5IGJlIHVzZWZ1bCB0byB0cmFjayBsaXZlIHByb2dyZXNzIG9mIGEgY2x1c3Rlci5cbiAgICpcbiAgICogQHBhcmFtIGNhbGxiYWNrIEZ1bmN0aW9uIHRvIGludm9rZSB3aGVuZXZlciB0aGUgc2xvdCB1cGRhdGVzXG4gICAqIEByZXR1cm4gc3Vic2NyaXB0aW9uIGlkXG4gICAqL1xuICBvblNsb3RVcGRhdGUoY2FsbGJhY2spIHtcbiAgICByZXR1cm4gdGhpcy5fbWFrZVN1YnNjcmlwdGlvbih7XG4gICAgICBjYWxsYmFjayxcbiAgICAgIG1ldGhvZDogJ3Nsb3RzVXBkYXRlc1N1YnNjcmliZScsXG4gICAgICB1bnN1YnNjcmliZU1ldGhvZDogJ3Nsb3RzVXBkYXRlc1Vuc3Vic2NyaWJlJ1xuICAgIH0sIFtdIC8qIGFyZ3MgKi8pO1xuICB9XG5cbiAgLyoqXG4gICAqIERlcmVnaXN0ZXIgYSBzbG90IHVwZGF0ZSBub3RpZmljYXRpb24gY2FsbGJhY2tcbiAgICpcbiAgICogQHBhcmFtIGNsaWVudFN1YnNjcmlwdGlvbklkIGNsaWVudCBzdWJzY3JpcHRpb24gaWQgdG8gZGVyZWdpc3RlclxuICAgKi9cbiAgYXN5bmMgcmVtb3ZlU2xvdFVwZGF0ZUxpc3RlbmVyKGNsaWVudFN1YnNjcmlwdGlvbklkKSB7XG4gICAgYXdhaXQgdGhpcy5fdW5zdWJzY3JpYmVDbGllbnRTdWJzY3JpcHRpb24oY2xpZW50U3Vic2NyaXB0aW9uSWQsICdzbG90IHVwZGF0ZScpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cblxuICBhc3luYyBfdW5zdWJzY3JpYmVDbGllbnRTdWJzY3JpcHRpb24oY2xpZW50U3Vic2NyaXB0aW9uSWQsIHN1YnNjcmlwdGlvbk5hbWUpIHtcbiAgICBjb25zdCBkaXNwb3NlID0gdGhpcy5fc3Vic2NyaXB0aW9uRGlzcG9zZUZ1bmN0aW9uc0J5Q2xpZW50U3Vic2NyaXB0aW9uSWRbY2xpZW50U3Vic2NyaXB0aW9uSWRdO1xuICAgIGlmIChkaXNwb3NlKSB7XG4gICAgICBhd2FpdCBkaXNwb3NlKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnNvbGUud2FybignSWdub3JlZCB1bnN1YnNjcmliZSByZXF1ZXN0IGJlY2F1c2UgYW4gYWN0aXZlIHN1YnNjcmlwdGlvbiB3aXRoIGlkICcgKyBgXFxgJHtjbGllbnRTdWJzY3JpcHRpb25JZH1cXGAgZm9yICcke3N1YnNjcmlwdGlvbk5hbWV9JyBldmVudHMgYCArICdjb3VsZCBub3QgYmUgZm91bmQuJyk7XG4gICAgfVxuICB9XG4gIF9idWlsZEFyZ3MoYXJncywgb3ZlcnJpZGUsIGVuY29kaW5nLCBleHRyYSkge1xuICAgIGNvbnN0IGNvbW1pdG1lbnQgPSBvdmVycmlkZSB8fCB0aGlzLl9jb21taXRtZW50O1xuICAgIGlmIChjb21taXRtZW50IHx8IGVuY29kaW5nIHx8IGV4dHJhKSB7XG4gICAgICBsZXQgb3B0aW9ucyA9IHt9O1xuICAgICAgaWYgKGVuY29kaW5nKSB7XG4gICAgICAgIG9wdGlvbnMuZW5jb2RpbmcgPSBlbmNvZGluZztcbiAgICAgIH1cbiAgICAgIGlmIChjb21taXRtZW50KSB7XG4gICAgICAgIG9wdGlvbnMuY29tbWl0bWVudCA9IGNvbW1pdG1lbnQ7XG4gICAgICB9XG4gICAgICBpZiAoZXh0cmEpIHtcbiAgICAgICAgb3B0aW9ucyA9IE9iamVjdC5hc3NpZ24ob3B0aW9ucywgZXh0cmEpO1xuICAgICAgfVxuICAgICAgYXJncy5wdXNoKG9wdGlvbnMpO1xuICAgIH1cbiAgICByZXR1cm4gYXJncztcbiAgfVxuXG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIF9idWlsZEFyZ3NBdExlYXN0Q29uZmlybWVkKGFyZ3MsIG92ZXJyaWRlLCBlbmNvZGluZywgZXh0cmEpIHtcbiAgICBjb25zdCBjb21taXRtZW50ID0gb3ZlcnJpZGUgfHwgdGhpcy5fY29tbWl0bWVudDtcbiAgICBpZiAoY29tbWl0bWVudCAmJiAhWydjb25maXJtZWQnLCAnZmluYWxpemVkJ10uaW5jbHVkZXMoY29tbWl0bWVudCkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignVXNpbmcgQ29ubmVjdGlvbiB3aXRoIGRlZmF1bHQgY29tbWl0bWVudDogYCcgKyB0aGlzLl9jb21taXRtZW50ICsgJ2AsIGJ1dCBtZXRob2QgcmVxdWlyZXMgYXQgbGVhc3QgYGNvbmZpcm1lZGAnKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX2J1aWxkQXJncyhhcmdzLCBvdmVycmlkZSwgZW5jb2RpbmcsIGV4dHJhKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIF93c09uU2lnbmF0dXJlTm90aWZpY2F0aW9uKG5vdGlmaWNhdGlvbikge1xuICAgIGNvbnN0IHtcbiAgICAgIHJlc3VsdCxcbiAgICAgIHN1YnNjcmlwdGlvblxuICAgIH0gPSBjcmVhdGUobm90aWZpY2F0aW9uLCBTaWduYXR1cmVOb3RpZmljYXRpb25SZXN1bHQpO1xuICAgIGlmIChyZXN1bHQudmFsdWUgIT09ICdyZWNlaXZlZFNpZ25hdHVyZScpIHtcbiAgICAgIC8qKlxuICAgICAgICogU3BlY2lhbCBjYXNlLlxuICAgICAgICogQWZ0ZXIgYSBzaWduYXR1cmUgaXMgcHJvY2Vzc2VkLCBSUENzIGF1dG9tYXRpY2FsbHkgZGlzcG9zZSBvZiB0aGVcbiAgICAgICAqIHN1YnNjcmlwdGlvbiBvbiB0aGUgc2VydmVyIHNpZGUuIFdlIG5lZWQgdG8gdHJhY2sgd2hpY2ggb2YgdGhlc2VcbiAgICAgICAqIHN1YnNjcmlwdGlvbnMgaGF2ZSBiZWVuIGRpc3Bvc2VkIGluIHN1Y2ggYSB3YXksIHNvIHRoYXQgd2Uga25vd1xuICAgICAgICogd2hldGhlciB0aGUgY2xpZW50IGlzIGRlYWxpbmcgd2l0aCBhIG5vdC15ZXQtcHJvY2Vzc2VkIHNpZ25hdHVyZVxuICAgICAgICogKGluIHdoaWNoIGNhc2Ugd2UgbXVzdCB0ZWFyIGRvd24gdGhlIHNlcnZlciBzdWJzY3JpcHRpb24pIG9yIGFuXG4gICAgICAgKiBhbHJlYWR5LXByb2Nlc3NlZCBzaWduYXR1cmUgKGluIHdoaWNoIGNhc2UgdGhlIGNsaWVudCBjYW4gc2ltcGx5XG4gICAgICAgKiBjbGVhciBvdXQgdGhlIHN1YnNjcmlwdGlvbiBsb2NhbGx5IHdpdGhvdXQgdGVsbGluZyB0aGUgc2VydmVyKS5cbiAgICAgICAqXG4gICAgICAgKiBOT1RFOiBUaGVyZSBpcyBhIHByb3Bvc2FsIHRvIGVsaW1pbmF0ZSB0aGlzIHNwZWNpYWwgY2FzZSwgaGVyZTpcbiAgICAgICAqIGh0dHBzOi8vZ2l0aHViLmNvbS9zb2xhbmEtbGFicy9zb2xhbmEvaXNzdWVzLzE4ODkyXG4gICAgICAgKi9cbiAgICAgIHRoaXMuX3N1YnNjcmlwdGlvbnNBdXRvRGlzcG9zZWRCeVJwYy5hZGQoc3Vic2NyaXB0aW9uKTtcbiAgICB9XG4gICAgdGhpcy5faGFuZGxlU2VydmVyTm90aWZpY2F0aW9uKHN1YnNjcmlwdGlvbiwgcmVzdWx0LnZhbHVlID09PSAncmVjZWl2ZWRTaWduYXR1cmUnID8gW3tcbiAgICAgIHR5cGU6ICdyZWNlaXZlZCdcbiAgICB9LCByZXN1bHQuY29udGV4dF0gOiBbe1xuICAgICAgdHlwZTogJ3N0YXR1cycsXG4gICAgICByZXN1bHQ6IHJlc3VsdC52YWx1ZVxuICAgIH0sIHJlc3VsdC5jb250ZXh0XSk7XG4gIH1cblxuICAvKipcbiAgICogUmVnaXN0ZXIgYSBjYWxsYmFjayB0byBiZSBpbnZva2VkIHVwb24gc2lnbmF0dXJlIHVwZGF0ZXNcbiAgICpcbiAgICogQHBhcmFtIHNpZ25hdHVyZSBUcmFuc2FjdGlvbiBzaWduYXR1cmUgc3RyaW5nIGluIGJhc2UgNThcbiAgICogQHBhcmFtIGNhbGxiYWNrIEZ1bmN0aW9uIHRvIGludm9rZSBvbiBzaWduYXR1cmUgbm90aWZpY2F0aW9uc1xuICAgKiBAcGFyYW0gY29tbWl0bWVudCBTcGVjaWZ5IHRoZSBjb21taXRtZW50IGxldmVsIHNpZ25hdHVyZSBtdXN0IHJlYWNoIGJlZm9yZSBub3RpZmljYXRpb25cbiAgICogQHJldHVybiBzdWJzY3JpcHRpb24gaWRcbiAgICovXG4gIG9uU2lnbmF0dXJlKHNpZ25hdHVyZSwgY2FsbGJhY2ssIGNvbW1pdG1lbnQpIHtcbiAgICBjb25zdCBhcmdzID0gdGhpcy5fYnVpbGRBcmdzKFtzaWduYXR1cmVdLCBjb21taXRtZW50IHx8IHRoaXMuX2NvbW1pdG1lbnQgfHwgJ2ZpbmFsaXplZCcgLy8gQXBwbHkgY29ubmVjdGlvbi9zZXJ2ZXIgZGVmYXVsdC5cbiAgICApO1xuICAgIGNvbnN0IGNsaWVudFN1YnNjcmlwdGlvbklkID0gdGhpcy5fbWFrZVN1YnNjcmlwdGlvbih7XG4gICAgICBjYWxsYmFjazogKG5vdGlmaWNhdGlvbiwgY29udGV4dCkgPT4ge1xuICAgICAgICBpZiAobm90aWZpY2F0aW9uLnR5cGUgPT09ICdzdGF0dXMnKSB7XG4gICAgICAgICAgY2FsbGJhY2sobm90aWZpY2F0aW9uLnJlc3VsdCwgY29udGV4dCk7XG4gICAgICAgICAgLy8gU2lnbmF0dXJlcyBzdWJzY3JpcHRpb25zIGFyZSBhdXRvLXJlbW92ZWQgYnkgdGhlIFJQQyBzZXJ2aWNlXG4gICAgICAgICAgLy8gc28gbm8gbmVlZCB0byBleHBsaWNpdGx5IHNlbmQgYW4gdW5zdWJzY3JpYmUgbWVzc2FnZS5cbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgdGhpcy5yZW1vdmVTaWduYXR1cmVMaXN0ZW5lcihjbGllbnRTdWJzY3JpcHRpb25JZCk7XG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tZW1wdHlcbiAgICAgICAgICB9IGNhdGNoIChfZXJyKSB7XG4gICAgICAgICAgICAvLyBBbHJlYWR5IHJlbW92ZWQuXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgbWV0aG9kOiAnc2lnbmF0dXJlU3Vic2NyaWJlJyxcbiAgICAgIHVuc3Vic2NyaWJlTWV0aG9kOiAnc2lnbmF0dXJlVW5zdWJzY3JpYmUnXG4gICAgfSwgYXJncyk7XG4gICAgcmV0dXJuIGNsaWVudFN1YnNjcmlwdGlvbklkO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlZ2lzdGVyIGEgY2FsbGJhY2sgdG8gYmUgaW52b2tlZCB3aGVuIGEgdHJhbnNhY3Rpb24gaXNcbiAgICogcmVjZWl2ZWQgYW5kL29yIHByb2Nlc3NlZC5cbiAgICpcbiAgICogQHBhcmFtIHNpZ25hdHVyZSBUcmFuc2FjdGlvbiBzaWduYXR1cmUgc3RyaW5nIGluIGJhc2UgNThcbiAgICogQHBhcmFtIGNhbGxiYWNrIEZ1bmN0aW9uIHRvIGludm9rZSBvbiBzaWduYXR1cmUgbm90aWZpY2F0aW9uc1xuICAgKiBAcGFyYW0gb3B0aW9ucyBFbmFibGUgcmVjZWl2ZWQgbm90aWZpY2F0aW9ucyBhbmQgc2V0IHRoZSBjb21taXRtZW50XG4gICAqICAgbGV2ZWwgdGhhdCBzaWduYXR1cmUgbXVzdCByZWFjaCBiZWZvcmUgbm90aWZpY2F0aW9uXG4gICAqIEByZXR1cm4gc3Vic2NyaXB0aW9uIGlkXG4gICAqL1xuICBvblNpZ25hdHVyZVdpdGhPcHRpb25zKHNpZ25hdHVyZSwgY2FsbGJhY2ssIG9wdGlvbnMpIHtcbiAgICBjb25zdCB7XG4gICAgICBjb21taXRtZW50LFxuICAgICAgLi4uZXh0cmFcbiAgICB9ID0ge1xuICAgICAgLi4ub3B0aW9ucyxcbiAgICAgIGNvbW1pdG1lbnQ6IG9wdGlvbnMgJiYgb3B0aW9ucy5jb21taXRtZW50IHx8IHRoaXMuX2NvbW1pdG1lbnQgfHwgJ2ZpbmFsaXplZCcgLy8gQXBwbHkgY29ubmVjdGlvbi9zZXJ2ZXIgZGVmYXVsdC5cbiAgICB9O1xuICAgIGNvbnN0IGFyZ3MgPSB0aGlzLl9idWlsZEFyZ3MoW3NpZ25hdHVyZV0sIGNvbW1pdG1lbnQsIHVuZGVmaW5lZCAvKiBlbmNvZGluZyAqLywgZXh0cmEpO1xuICAgIGNvbnN0IGNsaWVudFN1YnNjcmlwdGlvbklkID0gdGhpcy5fbWFrZVN1YnNjcmlwdGlvbih7XG4gICAgICBjYWxsYmFjazogKG5vdGlmaWNhdGlvbiwgY29udGV4dCkgPT4ge1xuICAgICAgICBjYWxsYmFjayhub3RpZmljYXRpb24sIGNvbnRleHQpO1xuICAgICAgICAvLyBTaWduYXR1cmVzIHN1YnNjcmlwdGlvbnMgYXJlIGF1dG8tcmVtb3ZlZCBieSB0aGUgUlBDIHNlcnZpY2VcbiAgICAgICAgLy8gc28gbm8gbmVlZCB0byBleHBsaWNpdGx5IHNlbmQgYW4gdW5zdWJzY3JpYmUgbWVzc2FnZS5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICB0aGlzLnJlbW92ZVNpZ25hdHVyZUxpc3RlbmVyKGNsaWVudFN1YnNjcmlwdGlvbklkKTtcbiAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tZW1wdHlcbiAgICAgICAgfSBjYXRjaCAoX2Vycikge1xuICAgICAgICAgIC8vIEFscmVhZHkgcmVtb3ZlZC5cbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIG1ldGhvZDogJ3NpZ25hdHVyZVN1YnNjcmliZScsXG4gICAgICB1bnN1YnNjcmliZU1ldGhvZDogJ3NpZ25hdHVyZVVuc3Vic2NyaWJlJ1xuICAgIH0sIGFyZ3MpO1xuICAgIHJldHVybiBjbGllbnRTdWJzY3JpcHRpb25JZDtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZXJlZ2lzdGVyIGEgc2lnbmF0dXJlIG5vdGlmaWNhdGlvbiBjYWxsYmFja1xuICAgKlxuICAgKiBAcGFyYW0gY2xpZW50U3Vic2NyaXB0aW9uSWQgY2xpZW50IHN1YnNjcmlwdGlvbiBpZCB0byBkZXJlZ2lzdGVyXG4gICAqL1xuICBhc3luYyByZW1vdmVTaWduYXR1cmVMaXN0ZW5lcihjbGllbnRTdWJzY3JpcHRpb25JZCkge1xuICAgIGF3YWl0IHRoaXMuX3Vuc3Vic2NyaWJlQ2xpZW50U3Vic2NyaXB0aW9uKGNsaWVudFN1YnNjcmlwdGlvbklkLCAnc2lnbmF0dXJlIHJlc3VsdCcpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgX3dzT25Sb290Tm90aWZpY2F0aW9uKG5vdGlmaWNhdGlvbikge1xuICAgIGNvbnN0IHtcbiAgICAgIHJlc3VsdCxcbiAgICAgIHN1YnNjcmlwdGlvblxuICAgIH0gPSBjcmVhdGUobm90aWZpY2F0aW9uLCBSb290Tm90aWZpY2F0aW9uUmVzdWx0KTtcbiAgICB0aGlzLl9oYW5kbGVTZXJ2ZXJOb3RpZmljYXRpb24oc3Vic2NyaXB0aW9uLCBbcmVzdWx0XSk7XG4gIH1cblxuICAvKipcbiAgICogUmVnaXN0ZXIgYSBjYWxsYmFjayB0byBiZSBpbnZva2VkIHVwb24gcm9vdCBjaGFuZ2VzXG4gICAqXG4gICAqIEBwYXJhbSBjYWxsYmFjayBGdW5jdGlvbiB0byBpbnZva2Ugd2hlbmV2ZXIgdGhlIHJvb3QgY2hhbmdlc1xuICAgKiBAcmV0dXJuIHN1YnNjcmlwdGlvbiBpZFxuICAgKi9cbiAgb25Sb290Q2hhbmdlKGNhbGxiYWNrKSB7XG4gICAgcmV0dXJuIHRoaXMuX21ha2VTdWJzY3JpcHRpb24oe1xuICAgICAgY2FsbGJhY2ssXG4gICAgICBtZXRob2Q6ICdyb290U3Vic2NyaWJlJyxcbiAgICAgIHVuc3Vic2NyaWJlTWV0aG9kOiAncm9vdFVuc3Vic2NyaWJlJ1xuICAgIH0sIFtdIC8qIGFyZ3MgKi8pO1xuICB9XG5cbiAgLyoqXG4gICAqIERlcmVnaXN0ZXIgYSByb290IG5vdGlmaWNhdGlvbiBjYWxsYmFja1xuICAgKlxuICAgKiBAcGFyYW0gY2xpZW50U3Vic2NyaXB0aW9uSWQgY2xpZW50IHN1YnNjcmlwdGlvbiBpZCB0byBkZXJlZ2lzdGVyXG4gICAqL1xuICBhc3luYyByZW1vdmVSb290Q2hhbmdlTGlzdGVuZXIoY2xpZW50U3Vic2NyaXB0aW9uSWQpIHtcbiAgICBhd2FpdCB0aGlzLl91bnN1YnNjcmliZUNsaWVudFN1YnNjcmlwdGlvbihjbGllbnRTdWJzY3JpcHRpb25JZCwgJ3Jvb3QgY2hhbmdlJyk7XG4gIH1cbn1cblxuLyoqXG4gKiBLZXlwYWlyIHNpZ25lciBpbnRlcmZhY2VcbiAqL1xuXG4vKipcbiAqIEFuIGFjY291bnQga2V5cGFpciB1c2VkIGZvciBzaWduaW5nIHRyYW5zYWN0aW9ucy5cbiAqL1xuY2xhc3MgS2V5cGFpciB7XG4gIC8qKlxuICAgKiBDcmVhdGUgYSBuZXcga2V5cGFpciBpbnN0YW5jZS5cbiAgICogR2VuZXJhdGUgcmFuZG9tIGtleXBhaXIgaWYgbm8ge0BsaW5rIEVkMjU1MTlLZXlwYWlyfSBpcyBwcm92aWRlZC5cbiAgICpcbiAgICogQHBhcmFtIHtFZDI1NTE5S2V5cGFpcn0ga2V5cGFpciBlZDI1NTE5IGtleXBhaXJcbiAgICovXG4gIGNvbnN0cnVjdG9yKGtleXBhaXIpIHtcbiAgICB0aGlzLl9rZXlwYWlyID0gdm9pZCAwO1xuICAgIHRoaXMuX2tleXBhaXIgPSBrZXlwYWlyID8/IGdlbmVyYXRlS2V5cGFpcigpO1xuICB9XG5cbiAgLyoqXG4gICAqIEdlbmVyYXRlIGEgbmV3IHJhbmRvbSBrZXlwYWlyXG4gICAqXG4gICAqIEByZXR1cm5zIHtLZXlwYWlyfSBLZXlwYWlyXG4gICAqL1xuICBzdGF0aWMgZ2VuZXJhdGUoKSB7XG4gICAgcmV0dXJuIG5ldyBLZXlwYWlyKGdlbmVyYXRlS2V5cGFpcigpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGUgYSBrZXlwYWlyIGZyb20gYSByYXcgc2VjcmV0IGtleSBieXRlIGFycmF5LlxuICAgKlxuICAgKiBUaGlzIG1ldGhvZCBzaG91bGQgb25seSBiZSB1c2VkIHRvIHJlY3JlYXRlIGEga2V5cGFpciBmcm9tIGEgcHJldmlvdXNseVxuICAgKiBnZW5lcmF0ZWQgc2VjcmV0IGtleS4gR2VuZXJhdGluZyBrZXlwYWlycyBmcm9tIGEgcmFuZG9tIHNlZWQgc2hvdWxkIGJlIGRvbmVcbiAgICogd2l0aCB0aGUge0BsaW5rIEtleXBhaXIuZnJvbVNlZWR9IG1ldGhvZC5cbiAgICpcbiAgICogQHRocm93cyBlcnJvciBpZiB0aGUgcHJvdmlkZWQgc2VjcmV0IGtleSBpcyBpbnZhbGlkIGFuZCB2YWxpZGF0aW9uIGlzIG5vdCBza2lwcGVkLlxuICAgKlxuICAgKiBAcGFyYW0gc2VjcmV0S2V5IHNlY3JldCBrZXkgYnl0ZSBhcnJheVxuICAgKiBAcGFyYW0gb3B0aW9ucyBza2lwIHNlY3JldCBrZXkgdmFsaWRhdGlvblxuICAgKlxuICAgKiBAcmV0dXJucyB7S2V5cGFpcn0gS2V5cGFpclxuICAgKi9cbiAgc3RhdGljIGZyb21TZWNyZXRLZXkoc2VjcmV0S2V5LCBvcHRpb25zKSB7XG4gICAgaWYgKHNlY3JldEtleS5ieXRlTGVuZ3RoICE9PSA2NCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdiYWQgc2VjcmV0IGtleSBzaXplJyk7XG4gICAgfVxuICAgIGNvbnN0IHB1YmxpY0tleSA9IHNlY3JldEtleS5zbGljZSgzMiwgNjQpO1xuICAgIGlmICghb3B0aW9ucyB8fCAhb3B0aW9ucy5za2lwVmFsaWRhdGlvbikge1xuICAgICAgY29uc3QgcHJpdmF0ZVNjYWxhciA9IHNlY3JldEtleS5zbGljZSgwLCAzMik7XG4gICAgICBjb25zdCBjb21wdXRlZFB1YmxpY0tleSA9IGdldFB1YmxpY0tleShwcml2YXRlU2NhbGFyKTtcbiAgICAgIGZvciAobGV0IGlpID0gMDsgaWkgPCAzMjsgaWkrKykge1xuICAgICAgICBpZiAocHVibGljS2V5W2lpXSAhPT0gY29tcHV0ZWRQdWJsaWNLZXlbaWldKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdwcm92aWRlZCBzZWNyZXRLZXkgaXMgaW52YWxpZCcpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBuZXcgS2V5cGFpcih7XG4gICAgICBwdWJsaWNLZXksXG4gICAgICBzZWNyZXRLZXlcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZW5lcmF0ZSBhIGtleXBhaXIgZnJvbSBhIDMyIGJ5dGUgc2VlZC5cbiAgICpcbiAgICogQHBhcmFtIHNlZWQgc2VlZCBieXRlIGFycmF5XG4gICAqXG4gICAqIEByZXR1cm5zIHtLZXlwYWlyfSBLZXlwYWlyXG4gICAqL1xuICBzdGF0aWMgZnJvbVNlZWQoc2VlZCkge1xuICAgIGNvbnN0IHB1YmxpY0tleSA9IGdldFB1YmxpY0tleShzZWVkKTtcbiAgICBjb25zdCBzZWNyZXRLZXkgPSBuZXcgVWludDhBcnJheSg2NCk7XG4gICAgc2VjcmV0S2V5LnNldChzZWVkKTtcbiAgICBzZWNyZXRLZXkuc2V0KHB1YmxpY0tleSwgMzIpO1xuICAgIHJldHVybiBuZXcgS2V5cGFpcih7XG4gICAgICBwdWJsaWNLZXksXG4gICAgICBzZWNyZXRLZXlcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGUgcHVibGljIGtleSBmb3IgdGhpcyBrZXlwYWlyXG4gICAqXG4gICAqIEByZXR1cm5zIHtQdWJsaWNLZXl9IFB1YmxpY0tleVxuICAgKi9cbiAgZ2V0IHB1YmxpY0tleSgpIHtcbiAgICByZXR1cm4gbmV3IFB1YmxpY0tleSh0aGlzLl9rZXlwYWlyLnB1YmxpY0tleSk7XG4gIH1cblxuICAvKipcbiAgICogVGhlIHJhdyBzZWNyZXQga2V5IGZvciB0aGlzIGtleXBhaXJcbiAgICogQHJldHVybnMge1VpbnQ4QXJyYXl9IFNlY3JldCBrZXkgaW4gYW4gYXJyYXkgb2YgVWludDggYnl0ZXNcbiAgICovXG4gIGdldCBzZWNyZXRLZXkoKSB7XG4gICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KHRoaXMuX2tleXBhaXIuc2VjcmV0S2V5KTtcbiAgfVxufVxuXG4vKipcbiAqIEFuIGVudW1lcmF0aW9uIG9mIHZhbGlkIExvb2t1cFRhYmxlSW5zdHJ1Y3Rpb25UeXBlJ3NcbiAqL1xuXG4vKipcbiAqIEFuIGVudW1lcmF0aW9uIG9mIHZhbGlkIGFkZHJlc3MgbG9va3VwIHRhYmxlIEluc3RydWN0aW9uVHlwZSdzXG4gKiBAaW50ZXJuYWxcbiAqL1xuY29uc3QgTE9PS1VQX1RBQkxFX0lOU1RSVUNUSU9OX0xBWU9VVFMgPSBPYmplY3QuZnJlZXplKHtcbiAgQ3JlYXRlTG9va3VwVGFibGU6IHtcbiAgICBpbmRleDogMCxcbiAgICBsYXlvdXQ6IEJ1ZmZlckxheW91dC5zdHJ1Y3QoW0J1ZmZlckxheW91dC51MzIoJ2luc3RydWN0aW9uJyksIHU2NCgncmVjZW50U2xvdCcpLCBCdWZmZXJMYXlvdXQudTgoJ2J1bXBTZWVkJyldKVxuICB9LFxuICBGcmVlemVMb29rdXBUYWJsZToge1xuICAgIGluZGV4OiAxLFxuICAgIGxheW91dDogQnVmZmVyTGF5b3V0LnN0cnVjdChbQnVmZmVyTGF5b3V0LnUzMignaW5zdHJ1Y3Rpb24nKV0pXG4gIH0sXG4gIEV4dGVuZExvb2t1cFRhYmxlOiB7XG4gICAgaW5kZXg6IDIsXG4gICAgbGF5b3V0OiBCdWZmZXJMYXlvdXQuc3RydWN0KFtCdWZmZXJMYXlvdXQudTMyKCdpbnN0cnVjdGlvbicpLCB1NjQoKSwgQnVmZmVyTGF5b3V0LnNlcShwdWJsaWNLZXkoKSwgQnVmZmVyTGF5b3V0Lm9mZnNldChCdWZmZXJMYXlvdXQudTMyKCksIC04KSwgJ2FkZHJlc3NlcycpXSlcbiAgfSxcbiAgRGVhY3RpdmF0ZUxvb2t1cFRhYmxlOiB7XG4gICAgaW5kZXg6IDMsXG4gICAgbGF5b3V0OiBCdWZmZXJMYXlvdXQuc3RydWN0KFtCdWZmZXJMYXlvdXQudTMyKCdpbnN0cnVjdGlvbicpXSlcbiAgfSxcbiAgQ2xvc2VMb29rdXBUYWJsZToge1xuICAgIGluZGV4OiA0LFxuICAgIGxheW91dDogQnVmZmVyTGF5b3V0LnN0cnVjdChbQnVmZmVyTGF5b3V0LnUzMignaW5zdHJ1Y3Rpb24nKV0pXG4gIH1cbn0pO1xuY2xhc3MgQWRkcmVzc0xvb2t1cFRhYmxlSW5zdHJ1Y3Rpb24ge1xuICAvKipcbiAgICogQGludGVybmFsXG4gICAqL1xuICBjb25zdHJ1Y3RvcigpIHt9XG4gIHN0YXRpYyBkZWNvZGVJbnN0cnVjdGlvblR5cGUoaW5zdHJ1Y3Rpb24pIHtcbiAgICB0aGlzLmNoZWNrUHJvZ3JhbUlkKGluc3RydWN0aW9uLnByb2dyYW1JZCk7XG4gICAgY29uc3QgaW5zdHJ1Y3Rpb25UeXBlTGF5b3V0ID0gQnVmZmVyTGF5b3V0LnUzMignaW5zdHJ1Y3Rpb24nKTtcbiAgICBjb25zdCBpbmRleCA9IGluc3RydWN0aW9uVHlwZUxheW91dC5kZWNvZGUoaW5zdHJ1Y3Rpb24uZGF0YSk7XG4gICAgbGV0IHR5cGU7XG4gICAgZm9yIChjb25zdCBbbGF5b3V0VHlwZSwgbGF5b3V0XSBvZiBPYmplY3QuZW50cmllcyhMT09LVVBfVEFCTEVfSU5TVFJVQ1RJT05fTEFZT1VUUykpIHtcbiAgICAgIGlmIChsYXlvdXQuaW5kZXggPT0gaW5kZXgpIHtcbiAgICAgICAgdHlwZSA9IGxheW91dFR5cGU7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoIXR5cGUpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBJbnN0cnVjdGlvbi4gU2hvdWxkIGJlIGEgTG9va3VwVGFibGUgSW5zdHJ1Y3Rpb24nKTtcbiAgICB9XG4gICAgcmV0dXJuIHR5cGU7XG4gIH1cbiAgc3RhdGljIGRlY29kZUNyZWF0ZUxvb2t1cFRhYmxlKGluc3RydWN0aW9uKSB7XG4gICAgdGhpcy5jaGVja1Byb2dyYW1JZChpbnN0cnVjdGlvbi5wcm9ncmFtSWQpO1xuICAgIHRoaXMuY2hlY2tLZXlzTGVuZ3RoKGluc3RydWN0aW9uLmtleXMsIDQpO1xuICAgIGNvbnN0IHtcbiAgICAgIHJlY2VudFNsb3RcbiAgICB9ID0gZGVjb2RlRGF0YSQxKExPT0tVUF9UQUJMRV9JTlNUUlVDVElPTl9MQVlPVVRTLkNyZWF0ZUxvb2t1cFRhYmxlLCBpbnN0cnVjdGlvbi5kYXRhKTtcbiAgICByZXR1cm4ge1xuICAgICAgYXV0aG9yaXR5OiBpbnN0cnVjdGlvbi5rZXlzWzFdLnB1YmtleSxcbiAgICAgIHBheWVyOiBpbnN0cnVjdGlvbi5rZXlzWzJdLnB1YmtleSxcbiAgICAgIHJlY2VudFNsb3Q6IE51bWJlcihyZWNlbnRTbG90KVxuICAgIH07XG4gIH1cbiAgc3RhdGljIGRlY29kZUV4dGVuZExvb2t1cFRhYmxlKGluc3RydWN0aW9uKSB7XG4gICAgdGhpcy5jaGVja1Byb2dyYW1JZChpbnN0cnVjdGlvbi5wcm9ncmFtSWQpO1xuICAgIGlmIChpbnN0cnVjdGlvbi5rZXlzLmxlbmd0aCA8IDIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgaW52YWxpZCBpbnN0cnVjdGlvbjsgZm91bmQgJHtpbnN0cnVjdGlvbi5rZXlzLmxlbmd0aH0ga2V5cywgZXhwZWN0ZWQgYXQgbGVhc3QgMmApO1xuICAgIH1cbiAgICBjb25zdCB7XG4gICAgICBhZGRyZXNzZXNcbiAgICB9ID0gZGVjb2RlRGF0YSQxKExPT0tVUF9UQUJMRV9JTlNUUlVDVElPTl9MQVlPVVRTLkV4dGVuZExvb2t1cFRhYmxlLCBpbnN0cnVjdGlvbi5kYXRhKTtcbiAgICByZXR1cm4ge1xuICAgICAgbG9va3VwVGFibGU6IGluc3RydWN0aW9uLmtleXNbMF0ucHVia2V5LFxuICAgICAgYXV0aG9yaXR5OiBpbnN0cnVjdGlvbi5rZXlzWzFdLnB1YmtleSxcbiAgICAgIHBheWVyOiBpbnN0cnVjdGlvbi5rZXlzLmxlbmd0aCA+IDIgPyBpbnN0cnVjdGlvbi5rZXlzWzJdLnB1YmtleSA6IHVuZGVmaW5lZCxcbiAgICAgIGFkZHJlc3NlczogYWRkcmVzc2VzLm1hcChidWZmZXIgPT4gbmV3IFB1YmxpY0tleShidWZmZXIpKVxuICAgIH07XG4gIH1cbiAgc3RhdGljIGRlY29kZUNsb3NlTG9va3VwVGFibGUoaW5zdHJ1Y3Rpb24pIHtcbiAgICB0aGlzLmNoZWNrUHJvZ3JhbUlkKGluc3RydWN0aW9uLnByb2dyYW1JZCk7XG4gICAgdGhpcy5jaGVja0tleXNMZW5ndGgoaW5zdHJ1Y3Rpb24ua2V5cywgMyk7XG4gICAgcmV0dXJuIHtcbiAgICAgIGxvb2t1cFRhYmxlOiBpbnN0cnVjdGlvbi5rZXlzWzBdLnB1YmtleSxcbiAgICAgIGF1dGhvcml0eTogaW5zdHJ1Y3Rpb24ua2V5c1sxXS5wdWJrZXksXG4gICAgICByZWNpcGllbnQ6IGluc3RydWN0aW9uLmtleXNbMl0ucHVia2V5XG4gICAgfTtcbiAgfVxuICBzdGF0aWMgZGVjb2RlRnJlZXplTG9va3VwVGFibGUoaW5zdHJ1Y3Rpb24pIHtcbiAgICB0aGlzLmNoZWNrUHJvZ3JhbUlkKGluc3RydWN0aW9uLnByb2dyYW1JZCk7XG4gICAgdGhpcy5jaGVja0tleXNMZW5ndGgoaW5zdHJ1Y3Rpb24ua2V5cywgMik7XG4gICAgcmV0dXJuIHtcbiAgICAgIGxvb2t1cFRhYmxlOiBpbnN0cnVjdGlvbi5rZXlzWzBdLnB1YmtleSxcbiAgICAgIGF1dGhvcml0eTogaW5zdHJ1Y3Rpb24ua2V5c1sxXS5wdWJrZXlcbiAgICB9O1xuICB9XG4gIHN0YXRpYyBkZWNvZGVEZWFjdGl2YXRlTG9va3VwVGFibGUoaW5zdHJ1Y3Rpb24pIHtcbiAgICB0aGlzLmNoZWNrUHJvZ3JhbUlkKGluc3RydWN0aW9uLnByb2dyYW1JZCk7XG4gICAgdGhpcy5jaGVja0tleXNMZW5ndGgoaW5zdHJ1Y3Rpb24ua2V5cywgMik7XG4gICAgcmV0dXJuIHtcbiAgICAgIGxvb2t1cFRhYmxlOiBpbnN0cnVjdGlvbi5rZXlzWzBdLnB1YmtleSxcbiAgICAgIGF1dGhvcml0eTogaW5zdHJ1Y3Rpb24ua2V5c1sxXS5wdWJrZXlcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgc3RhdGljIGNoZWNrUHJvZ3JhbUlkKHByb2dyYW1JZCkge1xuICAgIGlmICghcHJvZ3JhbUlkLmVxdWFscyhBZGRyZXNzTG9va3VwVGFibGVQcm9ncmFtLnByb2dyYW1JZCkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBpbnN0cnVjdGlvbjsgcHJvZ3JhbUlkIGlzIG5vdCBBZGRyZXNzTG9va3VwVGFibGUgUHJvZ3JhbScpO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogQGludGVybmFsXG4gICAqL1xuICBzdGF0aWMgY2hlY2tLZXlzTGVuZ3RoKGtleXMsIGV4cGVjdGVkTGVuZ3RoKSB7XG4gICAgaWYgKGtleXMubGVuZ3RoIDwgZXhwZWN0ZWRMZW5ndGgpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgaW52YWxpZCBpbnN0cnVjdGlvbjsgZm91bmQgJHtrZXlzLmxlbmd0aH0ga2V5cywgZXhwZWN0ZWQgYXQgbGVhc3QgJHtleHBlY3RlZExlbmd0aH1gKTtcbiAgICB9XG4gIH1cbn1cbmNsYXNzIEFkZHJlc3NMb29rdXBUYWJsZVByb2dyYW0ge1xuICAvKipcbiAgICogQGludGVybmFsXG4gICAqL1xuICBjb25zdHJ1Y3RvcigpIHt9XG4gIHN0YXRpYyBjcmVhdGVMb29rdXBUYWJsZShwYXJhbXMpIHtcbiAgICBjb25zdCBbbG9va3VwVGFibGVBZGRyZXNzLCBidW1wU2VlZF0gPSBQdWJsaWNLZXkuZmluZFByb2dyYW1BZGRyZXNzU3luYyhbcGFyYW1zLmF1dGhvcml0eS50b0J1ZmZlcigpLCB0b0J1ZmZlckxFKEJpZ0ludChwYXJhbXMucmVjZW50U2xvdCksIDgpXSwgdGhpcy5wcm9ncmFtSWQpO1xuICAgIGNvbnN0IHR5cGUgPSBMT09LVVBfVEFCTEVfSU5TVFJVQ1RJT05fTEFZT1VUUy5DcmVhdGVMb29rdXBUYWJsZTtcbiAgICBjb25zdCBkYXRhID0gZW5jb2RlRGF0YSh0eXBlLCB7XG4gICAgICByZWNlbnRTbG90OiBCaWdJbnQocGFyYW1zLnJlY2VudFNsb3QpLFxuICAgICAgYnVtcFNlZWQ6IGJ1bXBTZWVkXG4gICAgfSk7XG4gICAgY29uc3Qga2V5cyA9IFt7XG4gICAgICBwdWJrZXk6IGxvb2t1cFRhYmxlQWRkcmVzcyxcbiAgICAgIGlzU2lnbmVyOiBmYWxzZSxcbiAgICAgIGlzV3JpdGFibGU6IHRydWVcbiAgICB9LCB7XG4gICAgICBwdWJrZXk6IHBhcmFtcy5hdXRob3JpdHksXG4gICAgICBpc1NpZ25lcjogdHJ1ZSxcbiAgICAgIGlzV3JpdGFibGU6IGZhbHNlXG4gICAgfSwge1xuICAgICAgcHVia2V5OiBwYXJhbXMucGF5ZXIsXG4gICAgICBpc1NpZ25lcjogdHJ1ZSxcbiAgICAgIGlzV3JpdGFibGU6IHRydWVcbiAgICB9LCB7XG4gICAgICBwdWJrZXk6IFN5c3RlbVByb2dyYW0ucHJvZ3JhbUlkLFxuICAgICAgaXNTaWduZXI6IGZhbHNlLFxuICAgICAgaXNXcml0YWJsZTogZmFsc2VcbiAgICB9XTtcbiAgICByZXR1cm4gW25ldyBUcmFuc2FjdGlvbkluc3RydWN0aW9uKHtcbiAgICAgIHByb2dyYW1JZDogdGhpcy5wcm9ncmFtSWQsXG4gICAgICBrZXlzOiBrZXlzLFxuICAgICAgZGF0YTogZGF0YVxuICAgIH0pLCBsb29rdXBUYWJsZUFkZHJlc3NdO1xuICB9XG4gIHN0YXRpYyBmcmVlemVMb29rdXBUYWJsZShwYXJhbXMpIHtcbiAgICBjb25zdCB0eXBlID0gTE9PS1VQX1RBQkxFX0lOU1RSVUNUSU9OX0xBWU9VVFMuRnJlZXplTG9va3VwVGFibGU7XG4gICAgY29uc3QgZGF0YSA9IGVuY29kZURhdGEodHlwZSk7XG4gICAgY29uc3Qga2V5cyA9IFt7XG4gICAgICBwdWJrZXk6IHBhcmFtcy5sb29rdXBUYWJsZSxcbiAgICAgIGlzU2lnbmVyOiBmYWxzZSxcbiAgICAgIGlzV3JpdGFibGU6IHRydWVcbiAgICB9LCB7XG4gICAgICBwdWJrZXk6IHBhcmFtcy5hdXRob3JpdHksXG4gICAgICBpc1NpZ25lcjogdHJ1ZSxcbiAgICAgIGlzV3JpdGFibGU6IGZhbHNlXG4gICAgfV07XG4gICAgcmV0dXJuIG5ldyBUcmFuc2FjdGlvbkluc3RydWN0aW9uKHtcbiAgICAgIHByb2dyYW1JZDogdGhpcy5wcm9ncmFtSWQsXG4gICAgICBrZXlzOiBrZXlzLFxuICAgICAgZGF0YTogZGF0YVxuICAgIH0pO1xuICB9XG4gIHN0YXRpYyBleHRlbmRMb29rdXBUYWJsZShwYXJhbXMpIHtcbiAgICBjb25zdCB0eXBlID0gTE9PS1VQX1RBQkxFX0lOU1RSVUNUSU9OX0xBWU9VVFMuRXh0ZW5kTG9va3VwVGFibGU7XG4gICAgY29uc3QgZGF0YSA9IGVuY29kZURhdGEodHlwZSwge1xuICAgICAgYWRkcmVzc2VzOiBwYXJhbXMuYWRkcmVzc2VzLm1hcChhZGRyID0+IGFkZHIudG9CeXRlcygpKVxuICAgIH0pO1xuICAgIGNvbnN0IGtleXMgPSBbe1xuICAgICAgcHVia2V5OiBwYXJhbXMubG9va3VwVGFibGUsXG4gICAgICBpc1NpZ25lcjogZmFsc2UsXG4gICAgICBpc1dyaXRhYmxlOiB0cnVlXG4gICAgfSwge1xuICAgICAgcHVia2V5OiBwYXJhbXMuYXV0aG9yaXR5LFxuICAgICAgaXNTaWduZXI6IHRydWUsXG4gICAgICBpc1dyaXRhYmxlOiBmYWxzZVxuICAgIH1dO1xuICAgIGlmIChwYXJhbXMucGF5ZXIpIHtcbiAgICAgIGtleXMucHVzaCh7XG4gICAgICAgIHB1YmtleTogcGFyYW1zLnBheWVyLFxuICAgICAgICBpc1NpZ25lcjogdHJ1ZSxcbiAgICAgICAgaXNXcml0YWJsZTogdHJ1ZVxuICAgICAgfSwge1xuICAgICAgICBwdWJrZXk6IFN5c3RlbVByb2dyYW0ucHJvZ3JhbUlkLFxuICAgICAgICBpc1NpZ25lcjogZmFsc2UsXG4gICAgICAgIGlzV3JpdGFibGU6IGZhbHNlXG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBUcmFuc2FjdGlvbkluc3RydWN0aW9uKHtcbiAgICAgIHByb2dyYW1JZDogdGhpcy5wcm9ncmFtSWQsXG4gICAgICBrZXlzOiBrZXlzLFxuICAgICAgZGF0YTogZGF0YVxuICAgIH0pO1xuICB9XG4gIHN0YXRpYyBkZWFjdGl2YXRlTG9va3VwVGFibGUocGFyYW1zKSB7XG4gICAgY29uc3QgdHlwZSA9IExPT0tVUF9UQUJMRV9JTlNUUlVDVElPTl9MQVlPVVRTLkRlYWN0aXZhdGVMb29rdXBUYWJsZTtcbiAgICBjb25zdCBkYXRhID0gZW5jb2RlRGF0YSh0eXBlKTtcbiAgICBjb25zdCBrZXlzID0gW3tcbiAgICAgIHB1YmtleTogcGFyYW1zLmxvb2t1cFRhYmxlLFxuICAgICAgaXNTaWduZXI6IGZhbHNlLFxuICAgICAgaXNXcml0YWJsZTogdHJ1ZVxuICAgIH0sIHtcbiAgICAgIHB1YmtleTogcGFyYW1zLmF1dGhvcml0eSxcbiAgICAgIGlzU2lnbmVyOiB0cnVlLFxuICAgICAgaXNXcml0YWJsZTogZmFsc2VcbiAgICB9XTtcbiAgICByZXR1cm4gbmV3IFRyYW5zYWN0aW9uSW5zdHJ1Y3Rpb24oe1xuICAgICAgcHJvZ3JhbUlkOiB0aGlzLnByb2dyYW1JZCxcbiAgICAgIGtleXM6IGtleXMsXG4gICAgICBkYXRhOiBkYXRhXG4gICAgfSk7XG4gIH1cbiAgc3RhdGljIGNsb3NlTG9va3VwVGFibGUocGFyYW1zKSB7XG4gICAgY29uc3QgdHlwZSA9IExPT0tVUF9UQUJMRV9JTlNUUlVDVElPTl9MQVlPVVRTLkNsb3NlTG9va3VwVGFibGU7XG4gICAgY29uc3QgZGF0YSA9IGVuY29kZURhdGEodHlwZSk7XG4gICAgY29uc3Qga2V5cyA9IFt7XG4gICAgICBwdWJrZXk6IHBhcmFtcy5sb29rdXBUYWJsZSxcbiAgICAgIGlzU2lnbmVyOiBmYWxzZSxcbiAgICAgIGlzV3JpdGFibGU6IHRydWVcbiAgICB9LCB7XG4gICAgICBwdWJrZXk6IHBhcmFtcy5hdXRob3JpdHksXG4gICAgICBpc1NpZ25lcjogdHJ1ZSxcbiAgICAgIGlzV3JpdGFibGU6IGZhbHNlXG4gICAgfSwge1xuICAgICAgcHVia2V5OiBwYXJhbXMucmVjaXBpZW50LFxuICAgICAgaXNTaWduZXI6IGZhbHNlLFxuICAgICAgaXNXcml0YWJsZTogdHJ1ZVxuICAgIH1dO1xuICAgIHJldHVybiBuZXcgVHJhbnNhY3Rpb25JbnN0cnVjdGlvbih7XG4gICAgICBwcm9ncmFtSWQ6IHRoaXMucHJvZ3JhbUlkLFxuICAgICAga2V5czoga2V5cyxcbiAgICAgIGRhdGE6IGRhdGFcbiAgICB9KTtcbiAgfVxufVxuQWRkcmVzc0xvb2t1cFRhYmxlUHJvZ3JhbS5wcm9ncmFtSWQgPSBuZXcgUHVibGljS2V5KCdBZGRyZXNzTG9va3VwVGFiMWUxMTExMTExMTExMTExMTExMTExMTExMTExJyk7XG5cbi8qKlxuICogQ29tcHV0ZSBCdWRnZXQgSW5zdHJ1Y3Rpb24gY2xhc3NcbiAqL1xuY2xhc3MgQ29tcHV0ZUJ1ZGdldEluc3RydWN0aW9uIHtcbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgY29uc3RydWN0b3IoKSB7fVxuXG4gIC8qKlxuICAgKiBEZWNvZGUgYSBjb21wdXRlIGJ1ZGdldCBpbnN0cnVjdGlvbiBhbmQgcmV0cmlldmUgdGhlIGluc3RydWN0aW9uIHR5cGUuXG4gICAqL1xuICBzdGF0aWMgZGVjb2RlSW5zdHJ1Y3Rpb25UeXBlKGluc3RydWN0aW9uKSB7XG4gICAgdGhpcy5jaGVja1Byb2dyYW1JZChpbnN0cnVjdGlvbi5wcm9ncmFtSWQpO1xuICAgIGNvbnN0IGluc3RydWN0aW9uVHlwZUxheW91dCA9IEJ1ZmZlckxheW91dC51OCgnaW5zdHJ1Y3Rpb24nKTtcbiAgICBjb25zdCB0eXBlSW5kZXggPSBpbnN0cnVjdGlvblR5cGVMYXlvdXQuZGVjb2RlKGluc3RydWN0aW9uLmRhdGEpO1xuICAgIGxldCB0eXBlO1xuICAgIGZvciAoY29uc3QgW2l4VHlwZSwgbGF5b3V0XSBvZiBPYmplY3QuZW50cmllcyhDT01QVVRFX0JVREdFVF9JTlNUUlVDVElPTl9MQVlPVVRTKSkge1xuICAgICAgaWYgKGxheW91dC5pbmRleCA9PSB0eXBlSW5kZXgpIHtcbiAgICAgICAgdHlwZSA9IGl4VHlwZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICghdHlwZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnN0cnVjdGlvbiB0eXBlIGluY29ycmVjdDsgbm90IGEgQ29tcHV0ZUJ1ZGdldEluc3RydWN0aW9uJyk7XG4gICAgfVxuICAgIHJldHVybiB0eXBlO1xuICB9XG5cbiAgLyoqXG4gICAqIERlY29kZSByZXF1ZXN0IHVuaXRzIGNvbXB1dGUgYnVkZ2V0IGluc3RydWN0aW9uIGFuZCByZXRyaWV2ZSB0aGUgaW5zdHJ1Y3Rpb24gcGFyYW1zLlxuICAgKi9cbiAgc3RhdGljIGRlY29kZVJlcXVlc3RVbml0cyhpbnN0cnVjdGlvbikge1xuICAgIHRoaXMuY2hlY2tQcm9ncmFtSWQoaW5zdHJ1Y3Rpb24ucHJvZ3JhbUlkKTtcbiAgICBjb25zdCB7XG4gICAgICB1bml0cyxcbiAgICAgIGFkZGl0aW9uYWxGZWVcbiAgICB9ID0gZGVjb2RlRGF0YSQxKENPTVBVVEVfQlVER0VUX0lOU1RSVUNUSU9OX0xBWU9VVFMuUmVxdWVzdFVuaXRzLCBpbnN0cnVjdGlvbi5kYXRhKTtcbiAgICByZXR1cm4ge1xuICAgICAgdW5pdHMsXG4gICAgICBhZGRpdGlvbmFsRmVlXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZWNvZGUgcmVxdWVzdCBoZWFwIGZyYW1lIGNvbXB1dGUgYnVkZ2V0IGluc3RydWN0aW9uIGFuZCByZXRyaWV2ZSB0aGUgaW5zdHJ1Y3Rpb24gcGFyYW1zLlxuICAgKi9cbiAgc3RhdGljIGRlY29kZVJlcXVlc3RIZWFwRnJhbWUoaW5zdHJ1Y3Rpb24pIHtcbiAgICB0aGlzLmNoZWNrUHJvZ3JhbUlkKGluc3RydWN0aW9uLnByb2dyYW1JZCk7XG4gICAgY29uc3Qge1xuICAgICAgYnl0ZXNcbiAgICB9ID0gZGVjb2RlRGF0YSQxKENPTVBVVEVfQlVER0VUX0lOU1RSVUNUSU9OX0xBWU9VVFMuUmVxdWVzdEhlYXBGcmFtZSwgaW5zdHJ1Y3Rpb24uZGF0YSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIGJ5dGVzXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZWNvZGUgc2V0IGNvbXB1dGUgdW5pdCBsaW1pdCBjb21wdXRlIGJ1ZGdldCBpbnN0cnVjdGlvbiBhbmQgcmV0cmlldmUgdGhlIGluc3RydWN0aW9uIHBhcmFtcy5cbiAgICovXG4gIHN0YXRpYyBkZWNvZGVTZXRDb21wdXRlVW5pdExpbWl0KGluc3RydWN0aW9uKSB7XG4gICAgdGhpcy5jaGVja1Byb2dyYW1JZChpbnN0cnVjdGlvbi5wcm9ncmFtSWQpO1xuICAgIGNvbnN0IHtcbiAgICAgIHVuaXRzXG4gICAgfSA9IGRlY29kZURhdGEkMShDT01QVVRFX0JVREdFVF9JTlNUUlVDVElPTl9MQVlPVVRTLlNldENvbXB1dGVVbml0TGltaXQsIGluc3RydWN0aW9uLmRhdGEpO1xuICAgIHJldHVybiB7XG4gICAgICB1bml0c1xuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogRGVjb2RlIHNldCBjb21wdXRlIHVuaXQgcHJpY2UgY29tcHV0ZSBidWRnZXQgaW5zdHJ1Y3Rpb24gYW5kIHJldHJpZXZlIHRoZSBpbnN0cnVjdGlvbiBwYXJhbXMuXG4gICAqL1xuICBzdGF0aWMgZGVjb2RlU2V0Q29tcHV0ZVVuaXRQcmljZShpbnN0cnVjdGlvbikge1xuICAgIHRoaXMuY2hlY2tQcm9ncmFtSWQoaW5zdHJ1Y3Rpb24ucHJvZ3JhbUlkKTtcbiAgICBjb25zdCB7XG4gICAgICBtaWNyb0xhbXBvcnRzXG4gICAgfSA9IGRlY29kZURhdGEkMShDT01QVVRFX0JVREdFVF9JTlNUUlVDVElPTl9MQVlPVVRTLlNldENvbXB1dGVVbml0UHJpY2UsIGluc3RydWN0aW9uLmRhdGEpO1xuICAgIHJldHVybiB7XG4gICAgICBtaWNyb0xhbXBvcnRzXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIHN0YXRpYyBjaGVja1Byb2dyYW1JZChwcm9ncmFtSWQpIHtcbiAgICBpZiAoIXByb2dyYW1JZC5lcXVhbHMoQ29tcHV0ZUJ1ZGdldFByb2dyYW0ucHJvZ3JhbUlkKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIGluc3RydWN0aW9uOyBwcm9ncmFtSWQgaXMgbm90IENvbXB1dGVCdWRnZXRQcm9ncmFtJyk7XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogQW4gZW51bWVyYXRpb24gb2YgdmFsaWQgQ29tcHV0ZUJ1ZGdldEluc3RydWN0aW9uVHlwZSdzXG4gKi9cblxuLyoqXG4gKiBSZXF1ZXN0IHVuaXRzIGluc3RydWN0aW9uIHBhcmFtc1xuICovXG5cbi8qKlxuICogUmVxdWVzdCBoZWFwIGZyYW1lIGluc3RydWN0aW9uIHBhcmFtc1xuICovXG5cbi8qKlxuICogU2V0IGNvbXB1dGUgdW5pdCBsaW1pdCBpbnN0cnVjdGlvbiBwYXJhbXNcbiAqL1xuXG4vKipcbiAqIFNldCBjb21wdXRlIHVuaXQgcHJpY2UgaW5zdHJ1Y3Rpb24gcGFyYW1zXG4gKi9cblxuLyoqXG4gKiBBbiBlbnVtZXJhdGlvbiBvZiB2YWxpZCBDb21wdXRlQnVkZ2V0IEluc3RydWN0aW9uVHlwZSdzXG4gKiBAaW50ZXJuYWxcbiAqL1xuY29uc3QgQ09NUFVURV9CVURHRVRfSU5TVFJVQ1RJT05fTEFZT1VUUyA9IE9iamVjdC5mcmVlemUoe1xuICBSZXF1ZXN0VW5pdHM6IHtcbiAgICBpbmRleDogMCxcbiAgICBsYXlvdXQ6IEJ1ZmZlckxheW91dC5zdHJ1Y3QoW0J1ZmZlckxheW91dC51OCgnaW5zdHJ1Y3Rpb24nKSwgQnVmZmVyTGF5b3V0LnUzMigndW5pdHMnKSwgQnVmZmVyTGF5b3V0LnUzMignYWRkaXRpb25hbEZlZScpXSlcbiAgfSxcbiAgUmVxdWVzdEhlYXBGcmFtZToge1xuICAgIGluZGV4OiAxLFxuICAgIGxheW91dDogQnVmZmVyTGF5b3V0LnN0cnVjdChbQnVmZmVyTGF5b3V0LnU4KCdpbnN0cnVjdGlvbicpLCBCdWZmZXJMYXlvdXQudTMyKCdieXRlcycpXSlcbiAgfSxcbiAgU2V0Q29tcHV0ZVVuaXRMaW1pdDoge1xuICAgIGluZGV4OiAyLFxuICAgIGxheW91dDogQnVmZmVyTGF5b3V0LnN0cnVjdChbQnVmZmVyTGF5b3V0LnU4KCdpbnN0cnVjdGlvbicpLCBCdWZmZXJMYXlvdXQudTMyKCd1bml0cycpXSlcbiAgfSxcbiAgU2V0Q29tcHV0ZVVuaXRQcmljZToge1xuICAgIGluZGV4OiAzLFxuICAgIGxheW91dDogQnVmZmVyTGF5b3V0LnN0cnVjdChbQnVmZmVyTGF5b3V0LnU4KCdpbnN0cnVjdGlvbicpLCB1NjQoJ21pY3JvTGFtcG9ydHMnKV0pXG4gIH1cbn0pO1xuXG4vKipcbiAqIEZhY3RvcnkgY2xhc3MgZm9yIHRyYW5zYWN0aW9uIGluc3RydWN0aW9ucyB0byBpbnRlcmFjdCB3aXRoIHRoZSBDb21wdXRlIEJ1ZGdldCBwcm9ncmFtXG4gKi9cbmNsYXNzIENvbXB1dGVCdWRnZXRQcm9ncmFtIHtcbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgY29uc3RydWN0b3IoKSB7fVxuXG4gIC8qKlxuICAgKiBQdWJsaWMga2V5IHRoYXQgaWRlbnRpZmllcyB0aGUgQ29tcHV0ZSBCdWRnZXQgcHJvZ3JhbVxuICAgKi9cblxuICAvKipcbiAgICogQGRlcHJlY2F0ZWQgSW5zdGVhZCwgY2FsbCB7QGxpbmsgc2V0Q29tcHV0ZVVuaXRMaW1pdH0gYW5kL29yIHtAbGluayBzZXRDb21wdXRlVW5pdFByaWNlfVxuICAgKi9cbiAgc3RhdGljIHJlcXVlc3RVbml0cyhwYXJhbXMpIHtcbiAgICBjb25zdCB0eXBlID0gQ09NUFVURV9CVURHRVRfSU5TVFJVQ1RJT05fTEFZT1VUUy5SZXF1ZXN0VW5pdHM7XG4gICAgY29uc3QgZGF0YSA9IGVuY29kZURhdGEodHlwZSwgcGFyYW1zKTtcbiAgICByZXR1cm4gbmV3IFRyYW5zYWN0aW9uSW5zdHJ1Y3Rpb24oe1xuICAgICAga2V5czogW10sXG4gICAgICBwcm9ncmFtSWQ6IHRoaXMucHJvZ3JhbUlkLFxuICAgICAgZGF0YVxuICAgIH0pO1xuICB9XG4gIHN0YXRpYyByZXF1ZXN0SGVhcEZyYW1lKHBhcmFtcykge1xuICAgIGNvbnN0IHR5cGUgPSBDT01QVVRFX0JVREdFVF9JTlNUUlVDVElPTl9MQVlPVVRTLlJlcXVlc3RIZWFwRnJhbWU7XG4gICAgY29uc3QgZGF0YSA9IGVuY29kZURhdGEodHlwZSwgcGFyYW1zKTtcbiAgICByZXR1cm4gbmV3IFRyYW5zYWN0aW9uSW5zdHJ1Y3Rpb24oe1xuICAgICAga2V5czogW10sXG4gICAgICBwcm9ncmFtSWQ6IHRoaXMucHJvZ3JhbUlkLFxuICAgICAgZGF0YVxuICAgIH0pO1xuICB9XG4gIHN0YXRpYyBzZXRDb21wdXRlVW5pdExpbWl0KHBhcmFtcykge1xuICAgIGNvbnN0IHR5cGUgPSBDT01QVVRFX0JVREdFVF9JTlNUUlVDVElPTl9MQVlPVVRTLlNldENvbXB1dGVVbml0TGltaXQ7XG4gICAgY29uc3QgZGF0YSA9IGVuY29kZURhdGEodHlwZSwgcGFyYW1zKTtcbiAgICByZXR1cm4gbmV3IFRyYW5zYWN0aW9uSW5zdHJ1Y3Rpb24oe1xuICAgICAga2V5czogW10sXG4gICAgICBwcm9ncmFtSWQ6IHRoaXMucHJvZ3JhbUlkLFxuICAgICAgZGF0YVxuICAgIH0pO1xuICB9XG4gIHN0YXRpYyBzZXRDb21wdXRlVW5pdFByaWNlKHBhcmFtcykge1xuICAgIGNvbnN0IHR5cGUgPSBDT01QVVRFX0JVREdFVF9JTlNUUlVDVElPTl9MQVlPVVRTLlNldENvbXB1dGVVbml0UHJpY2U7XG4gICAgY29uc3QgZGF0YSA9IGVuY29kZURhdGEodHlwZSwge1xuICAgICAgbWljcm9MYW1wb3J0czogQmlnSW50KHBhcmFtcy5taWNyb0xhbXBvcnRzKVxuICAgIH0pO1xuICAgIHJldHVybiBuZXcgVHJhbnNhY3Rpb25JbnN0cnVjdGlvbih7XG4gICAgICBrZXlzOiBbXSxcbiAgICAgIHByb2dyYW1JZDogdGhpcy5wcm9ncmFtSWQsXG4gICAgICBkYXRhXG4gICAgfSk7XG4gIH1cbn1cbkNvbXB1dGVCdWRnZXRQcm9ncmFtLnByb2dyYW1JZCA9IG5ldyBQdWJsaWNLZXkoJ0NvbXB1dGVCdWRnZXQxMTExMTExMTExMTExMTExMTExMTExMTExMTExMTEnKTtcblxuY29uc3QgUFJJVkFURV9LRVlfQllURVMkMSA9IDY0O1xuY29uc3QgUFVCTElDX0tFWV9CWVRFUyQxID0gMzI7XG5jb25zdCBTSUdOQVRVUkVfQllURVMgPSA2NDtcblxuLyoqXG4gKiBQYXJhbXMgZm9yIGNyZWF0aW5nIGFuIGVkMjU1MTkgaW5zdHJ1Y3Rpb24gdXNpbmcgYSBwdWJsaWMga2V5XG4gKi9cblxuLyoqXG4gKiBQYXJhbXMgZm9yIGNyZWF0aW5nIGFuIGVkMjU1MTkgaW5zdHJ1Y3Rpb24gdXNpbmcgYSBwcml2YXRlIGtleVxuICovXG5cbmNvbnN0IEVEMjU1MTlfSU5TVFJVQ1RJT05fTEFZT1VUID0gQnVmZmVyTGF5b3V0LnN0cnVjdChbQnVmZmVyTGF5b3V0LnU4KCdudW1TaWduYXR1cmVzJyksIEJ1ZmZlckxheW91dC51OCgncGFkZGluZycpLCBCdWZmZXJMYXlvdXQudTE2KCdzaWduYXR1cmVPZmZzZXQnKSwgQnVmZmVyTGF5b3V0LnUxNignc2lnbmF0dXJlSW5zdHJ1Y3Rpb25JbmRleCcpLCBCdWZmZXJMYXlvdXQudTE2KCdwdWJsaWNLZXlPZmZzZXQnKSwgQnVmZmVyTGF5b3V0LnUxNigncHVibGljS2V5SW5zdHJ1Y3Rpb25JbmRleCcpLCBCdWZmZXJMYXlvdXQudTE2KCdtZXNzYWdlRGF0YU9mZnNldCcpLCBCdWZmZXJMYXlvdXQudTE2KCdtZXNzYWdlRGF0YVNpemUnKSwgQnVmZmVyTGF5b3V0LnUxNignbWVzc2FnZUluc3RydWN0aW9uSW5kZXgnKV0pO1xuY2xhc3MgRWQyNTUxOVByb2dyYW0ge1xuICAvKipcbiAgICogQGludGVybmFsXG4gICAqL1xuICBjb25zdHJ1Y3RvcigpIHt9XG5cbiAgLyoqXG4gICAqIFB1YmxpYyBrZXkgdGhhdCBpZGVudGlmaWVzIHRoZSBlZDI1NTE5IHByb2dyYW1cbiAgICovXG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhbiBlZDI1NTE5IGluc3RydWN0aW9uIHdpdGggYSBwdWJsaWMga2V5IGFuZCBzaWduYXR1cmUuIFRoZVxuICAgKiBwdWJsaWMga2V5IG11c3QgYmUgYSBidWZmZXIgdGhhdCBpcyAzMiBieXRlcyBsb25nLCBhbmQgdGhlIHNpZ25hdHVyZVxuICAgKiBtdXN0IGJlIGEgYnVmZmVyIG9mIDY0IGJ5dGVzLlxuICAgKi9cbiAgc3RhdGljIGNyZWF0ZUluc3RydWN0aW9uV2l0aFB1YmxpY0tleShwYXJhbXMpIHtcbiAgICBjb25zdCB7XG4gICAgICBwdWJsaWNLZXksXG4gICAgICBtZXNzYWdlLFxuICAgICAgc2lnbmF0dXJlLFxuICAgICAgaW5zdHJ1Y3Rpb25JbmRleFxuICAgIH0gPSBwYXJhbXM7XG4gICAgYXNzZXJ0KHB1YmxpY0tleS5sZW5ndGggPT09IFBVQkxJQ19LRVlfQllURVMkMSwgYFB1YmxpYyBLZXkgbXVzdCBiZSAke1BVQkxJQ19LRVlfQllURVMkMX0gYnl0ZXMgYnV0IHJlY2VpdmVkICR7cHVibGljS2V5Lmxlbmd0aH0gYnl0ZXNgKTtcbiAgICBhc3NlcnQoc2lnbmF0dXJlLmxlbmd0aCA9PT0gU0lHTkFUVVJFX0JZVEVTLCBgU2lnbmF0dXJlIG11c3QgYmUgJHtTSUdOQVRVUkVfQllURVN9IGJ5dGVzIGJ1dCByZWNlaXZlZCAke3NpZ25hdHVyZS5sZW5ndGh9IGJ5dGVzYCk7XG4gICAgY29uc3QgcHVibGljS2V5T2Zmc2V0ID0gRUQyNTUxOV9JTlNUUlVDVElPTl9MQVlPVVQuc3BhbjtcbiAgICBjb25zdCBzaWduYXR1cmVPZmZzZXQgPSBwdWJsaWNLZXlPZmZzZXQgKyBwdWJsaWNLZXkubGVuZ3RoO1xuICAgIGNvbnN0IG1lc3NhZ2VEYXRhT2Zmc2V0ID0gc2lnbmF0dXJlT2Zmc2V0ICsgc2lnbmF0dXJlLmxlbmd0aDtcbiAgICBjb25zdCBudW1TaWduYXR1cmVzID0gMTtcbiAgICBjb25zdCBpbnN0cnVjdGlvbkRhdGEgPSBCdWZmZXIuYWxsb2MobWVzc2FnZURhdGFPZmZzZXQgKyBtZXNzYWdlLmxlbmd0aCk7XG4gICAgY29uc3QgaW5kZXggPSBpbnN0cnVjdGlvbkluZGV4ID09IG51bGwgPyAweGZmZmYgLy8gQW4gaW5kZXggb2YgYHUxNjo6TUFYYCBtYWtlcyBpdCBkZWZhdWx0IHRvIHRoZSBjdXJyZW50IGluc3RydWN0aW9uLlxuICAgIDogaW5zdHJ1Y3Rpb25JbmRleDtcbiAgICBFRDI1NTE5X0lOU1RSVUNUSU9OX0xBWU9VVC5lbmNvZGUoe1xuICAgICAgbnVtU2lnbmF0dXJlcyxcbiAgICAgIHBhZGRpbmc6IDAsXG4gICAgICBzaWduYXR1cmVPZmZzZXQsXG4gICAgICBzaWduYXR1cmVJbnN0cnVjdGlvbkluZGV4OiBpbmRleCxcbiAgICAgIHB1YmxpY0tleU9mZnNldCxcbiAgICAgIHB1YmxpY0tleUluc3RydWN0aW9uSW5kZXg6IGluZGV4LFxuICAgICAgbWVzc2FnZURhdGFPZmZzZXQsXG4gICAgICBtZXNzYWdlRGF0YVNpemU6IG1lc3NhZ2UubGVuZ3RoLFxuICAgICAgbWVzc2FnZUluc3RydWN0aW9uSW5kZXg6IGluZGV4XG4gICAgfSwgaW5zdHJ1Y3Rpb25EYXRhKTtcbiAgICBpbnN0cnVjdGlvbkRhdGEuZmlsbChwdWJsaWNLZXksIHB1YmxpY0tleU9mZnNldCk7XG4gICAgaW5zdHJ1Y3Rpb25EYXRhLmZpbGwoc2lnbmF0dXJlLCBzaWduYXR1cmVPZmZzZXQpO1xuICAgIGluc3RydWN0aW9uRGF0YS5maWxsKG1lc3NhZ2UsIG1lc3NhZ2VEYXRhT2Zmc2V0KTtcbiAgICByZXR1cm4gbmV3IFRyYW5zYWN0aW9uSW5zdHJ1Y3Rpb24oe1xuICAgICAga2V5czogW10sXG4gICAgICBwcm9ncmFtSWQ6IEVkMjU1MTlQcm9ncmFtLnByb2dyYW1JZCxcbiAgICAgIGRhdGE6IGluc3RydWN0aW9uRGF0YVxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhbiBlZDI1NTE5IGluc3RydWN0aW9uIHdpdGggYSBwcml2YXRlIGtleS4gVGhlIHByaXZhdGUga2V5XG4gICAqIG11c3QgYmUgYSBidWZmZXIgdGhhdCBpcyA2NCBieXRlcyBsb25nLlxuICAgKi9cbiAgc3RhdGljIGNyZWF0ZUluc3RydWN0aW9uV2l0aFByaXZhdGVLZXkocGFyYW1zKSB7XG4gICAgY29uc3Qge1xuICAgICAgcHJpdmF0ZUtleSxcbiAgICAgIG1lc3NhZ2UsXG4gICAgICBpbnN0cnVjdGlvbkluZGV4XG4gICAgfSA9IHBhcmFtcztcbiAgICBhc3NlcnQocHJpdmF0ZUtleS5sZW5ndGggPT09IFBSSVZBVEVfS0VZX0JZVEVTJDEsIGBQcml2YXRlIGtleSBtdXN0IGJlICR7UFJJVkFURV9LRVlfQllURVMkMX0gYnl0ZXMgYnV0IHJlY2VpdmVkICR7cHJpdmF0ZUtleS5sZW5ndGh9IGJ5dGVzYCk7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IGtleXBhaXIgPSBLZXlwYWlyLmZyb21TZWNyZXRLZXkocHJpdmF0ZUtleSk7XG4gICAgICBjb25zdCBwdWJsaWNLZXkgPSBrZXlwYWlyLnB1YmxpY0tleS50b0J5dGVzKCk7XG4gICAgICBjb25zdCBzaWduYXR1cmUgPSBzaWduKG1lc3NhZ2UsIGtleXBhaXIuc2VjcmV0S2V5KTtcbiAgICAgIHJldHVybiB0aGlzLmNyZWF0ZUluc3RydWN0aW9uV2l0aFB1YmxpY0tleSh7XG4gICAgICAgIHB1YmxpY0tleSxcbiAgICAgICAgbWVzc2FnZSxcbiAgICAgICAgc2lnbmF0dXJlLFxuICAgICAgICBpbnN0cnVjdGlvbkluZGV4XG4gICAgICB9KTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBFcnJvciBjcmVhdGluZyBpbnN0cnVjdGlvbjsgJHtlcnJvcn1gKTtcbiAgICB9XG4gIH1cbn1cbkVkMjU1MTlQcm9ncmFtLnByb2dyYW1JZCA9IG5ldyBQdWJsaWNLZXkoJ0VkMjU1MTlTaWdWZXJpZnkxMTExMTExMTExMTExMTExMTExMTExMTExMTEnKTtcblxuY29uc3QgZWNkc2FTaWduID0gKG1zZ0hhc2gsIHByaXZLZXkpID0+IHtcbiAgY29uc3Qgc2lnbmF0dXJlID0gc2VjcDI1NmsxLnNpZ24obXNnSGFzaCwgcHJpdktleSk7XG4gIHJldHVybiBbc2lnbmF0dXJlLnRvQ29tcGFjdFJhd0J5dGVzKCksIHNpZ25hdHVyZS5yZWNvdmVyeV07XG59O1xuc2VjcDI1NmsxLnV0aWxzLmlzVmFsaWRQcml2YXRlS2V5O1xuY29uc3QgcHVibGljS2V5Q3JlYXRlID0gc2VjcDI1NmsxLmdldFB1YmxpY0tleTtcblxuY29uc3QgUFJJVkFURV9LRVlfQllURVMgPSAzMjtcbmNvbnN0IEVUSEVSRVVNX0FERFJFU1NfQllURVMgPSAyMDtcbmNvbnN0IFBVQkxJQ19LRVlfQllURVMgPSA2NDtcbmNvbnN0IFNJR05BVFVSRV9PRkZTRVRTX1NFUklBTElaRURfU0laRSA9IDExO1xuXG4vKipcbiAqIFBhcmFtcyBmb3IgY3JlYXRpbmcgYW4gc2VjcDI1NmsxIGluc3RydWN0aW9uIHVzaW5nIGEgcHVibGljIGtleVxuICovXG5cbi8qKlxuICogUGFyYW1zIGZvciBjcmVhdGluZyBhbiBzZWNwMjU2azEgaW5zdHJ1Y3Rpb24gdXNpbmcgYW4gRXRoZXJldW0gYWRkcmVzc1xuICovXG5cbi8qKlxuICogUGFyYW1zIGZvciBjcmVhdGluZyBhbiBzZWNwMjU2azEgaW5zdHJ1Y3Rpb24gdXNpbmcgYSBwcml2YXRlIGtleVxuICovXG5cbmNvbnN0IFNFQ1AyNTZLMV9JTlNUUlVDVElPTl9MQVlPVVQgPSBCdWZmZXJMYXlvdXQuc3RydWN0KFtCdWZmZXJMYXlvdXQudTgoJ251bVNpZ25hdHVyZXMnKSwgQnVmZmVyTGF5b3V0LnUxNignc2lnbmF0dXJlT2Zmc2V0JyksIEJ1ZmZlckxheW91dC51OCgnc2lnbmF0dXJlSW5zdHJ1Y3Rpb25JbmRleCcpLCBCdWZmZXJMYXlvdXQudTE2KCdldGhBZGRyZXNzT2Zmc2V0JyksIEJ1ZmZlckxheW91dC51OCgnZXRoQWRkcmVzc0luc3RydWN0aW9uSW5kZXgnKSwgQnVmZmVyTGF5b3V0LnUxNignbWVzc2FnZURhdGFPZmZzZXQnKSwgQnVmZmVyTGF5b3V0LnUxNignbWVzc2FnZURhdGFTaXplJyksIEJ1ZmZlckxheW91dC51OCgnbWVzc2FnZUluc3RydWN0aW9uSW5kZXgnKSwgQnVmZmVyTGF5b3V0LmJsb2IoMjAsICdldGhBZGRyZXNzJyksIEJ1ZmZlckxheW91dC5ibG9iKDY0LCAnc2lnbmF0dXJlJyksIEJ1ZmZlckxheW91dC51OCgncmVjb3ZlcnlJZCcpXSk7XG5jbGFzcyBTZWNwMjU2azFQcm9ncmFtIHtcbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgY29uc3RydWN0b3IoKSB7fVxuXG4gIC8qKlxuICAgKiBQdWJsaWMga2V5IHRoYXQgaWRlbnRpZmllcyB0aGUgc2VjcDI1NmsxIHByb2dyYW1cbiAgICovXG5cbiAgLyoqXG4gICAqIENvbnN0cnVjdCBhbiBFdGhlcmV1bSBhZGRyZXNzIGZyb20gYSBzZWNwMjU2azEgcHVibGljIGtleSBidWZmZXIuXG4gICAqIEBwYXJhbSB7QnVmZmVyfSBwdWJsaWNLZXkgYSA2NCBieXRlIHNlY3AyNTZrMSBwdWJsaWMga2V5IGJ1ZmZlclxuICAgKi9cbiAgc3RhdGljIHB1YmxpY0tleVRvRXRoQWRkcmVzcyhwdWJsaWNLZXkpIHtcbiAgICBhc3NlcnQocHVibGljS2V5Lmxlbmd0aCA9PT0gUFVCTElDX0tFWV9CWVRFUywgYFB1YmxpYyBrZXkgbXVzdCBiZSAke1BVQkxJQ19LRVlfQllURVN9IGJ5dGVzIGJ1dCByZWNlaXZlZCAke3B1YmxpY0tleS5sZW5ndGh9IGJ5dGVzYCk7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBCdWZmZXIuZnJvbShrZWNjYWtfMjU2KHRvQnVmZmVyKHB1YmxpY0tleSkpKS5zbGljZSgtRVRIRVJFVU1fQUREUkVTU19CWVRFUyk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgRXJyb3IgY29uc3RydWN0aW5nIEV0aGVyZXVtIGFkZHJlc3M6ICR7ZXJyb3J9YCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhbiBzZWNwMjU2azEgaW5zdHJ1Y3Rpb24gd2l0aCBhIHB1YmxpYyBrZXkuIFRoZSBwdWJsaWMga2V5XG4gICAqIG11c3QgYmUgYSBidWZmZXIgdGhhdCBpcyA2NCBieXRlcyBsb25nLlxuICAgKi9cbiAgc3RhdGljIGNyZWF0ZUluc3RydWN0aW9uV2l0aFB1YmxpY0tleShwYXJhbXMpIHtcbiAgICBjb25zdCB7XG4gICAgICBwdWJsaWNLZXksXG4gICAgICBtZXNzYWdlLFxuICAgICAgc2lnbmF0dXJlLFxuICAgICAgcmVjb3ZlcnlJZCxcbiAgICAgIGluc3RydWN0aW9uSW5kZXhcbiAgICB9ID0gcGFyYW1zO1xuICAgIHJldHVybiBTZWNwMjU2azFQcm9ncmFtLmNyZWF0ZUluc3RydWN0aW9uV2l0aEV0aEFkZHJlc3Moe1xuICAgICAgZXRoQWRkcmVzczogU2VjcDI1NmsxUHJvZ3JhbS5wdWJsaWNLZXlUb0V0aEFkZHJlc3MocHVibGljS2V5KSxcbiAgICAgIG1lc3NhZ2UsXG4gICAgICBzaWduYXR1cmUsXG4gICAgICByZWNvdmVyeUlkLFxuICAgICAgaW5zdHJ1Y3Rpb25JbmRleFxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhbiBzZWNwMjU2azEgaW5zdHJ1Y3Rpb24gd2l0aCBhbiBFdGhlcmV1bSBhZGRyZXNzLiBUaGUgYWRkcmVzc1xuICAgKiBtdXN0IGJlIGEgaGV4IHN0cmluZyBvciBhIGJ1ZmZlciB0aGF0IGlzIDIwIGJ5dGVzIGxvbmcuXG4gICAqL1xuICBzdGF0aWMgY3JlYXRlSW5zdHJ1Y3Rpb25XaXRoRXRoQWRkcmVzcyhwYXJhbXMpIHtcbiAgICBjb25zdCB7XG4gICAgICBldGhBZGRyZXNzOiByYXdBZGRyZXNzLFxuICAgICAgbWVzc2FnZSxcbiAgICAgIHNpZ25hdHVyZSxcbiAgICAgIHJlY292ZXJ5SWQsXG4gICAgICBpbnN0cnVjdGlvbkluZGV4ID0gMFxuICAgIH0gPSBwYXJhbXM7XG4gICAgbGV0IGV0aEFkZHJlc3M7XG4gICAgaWYgKHR5cGVvZiByYXdBZGRyZXNzID09PSAnc3RyaW5nJykge1xuICAgICAgaWYgKHJhd0FkZHJlc3Muc3RhcnRzV2l0aCgnMHgnKSkge1xuICAgICAgICBldGhBZGRyZXNzID0gQnVmZmVyLmZyb20ocmF3QWRkcmVzcy5zdWJzdHIoMiksICdoZXgnKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGV0aEFkZHJlc3MgPSBCdWZmZXIuZnJvbShyYXdBZGRyZXNzLCAnaGV4Jyk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGV0aEFkZHJlc3MgPSByYXdBZGRyZXNzO1xuICAgIH1cbiAgICBhc3NlcnQoZXRoQWRkcmVzcy5sZW5ndGggPT09IEVUSEVSRVVNX0FERFJFU1NfQllURVMsIGBBZGRyZXNzIG11c3QgYmUgJHtFVEhFUkVVTV9BRERSRVNTX0JZVEVTfSBieXRlcyBidXQgcmVjZWl2ZWQgJHtldGhBZGRyZXNzLmxlbmd0aH0gYnl0ZXNgKTtcbiAgICBjb25zdCBkYXRhU3RhcnQgPSAxICsgU0lHTkFUVVJFX09GRlNFVFNfU0VSSUFMSVpFRF9TSVpFO1xuICAgIGNvbnN0IGV0aEFkZHJlc3NPZmZzZXQgPSBkYXRhU3RhcnQ7XG4gICAgY29uc3Qgc2lnbmF0dXJlT2Zmc2V0ID0gZGF0YVN0YXJ0ICsgZXRoQWRkcmVzcy5sZW5ndGg7XG4gICAgY29uc3QgbWVzc2FnZURhdGFPZmZzZXQgPSBzaWduYXR1cmVPZmZzZXQgKyBzaWduYXR1cmUubGVuZ3RoICsgMTtcbiAgICBjb25zdCBudW1TaWduYXR1cmVzID0gMTtcbiAgICBjb25zdCBpbnN0cnVjdGlvbkRhdGEgPSBCdWZmZXIuYWxsb2MoU0VDUDI1NksxX0lOU1RSVUNUSU9OX0xBWU9VVC5zcGFuICsgbWVzc2FnZS5sZW5ndGgpO1xuICAgIFNFQ1AyNTZLMV9JTlNUUlVDVElPTl9MQVlPVVQuZW5jb2RlKHtcbiAgICAgIG51bVNpZ25hdHVyZXMsXG4gICAgICBzaWduYXR1cmVPZmZzZXQsXG4gICAgICBzaWduYXR1cmVJbnN0cnVjdGlvbkluZGV4OiBpbnN0cnVjdGlvbkluZGV4LFxuICAgICAgZXRoQWRkcmVzc09mZnNldCxcbiAgICAgIGV0aEFkZHJlc3NJbnN0cnVjdGlvbkluZGV4OiBpbnN0cnVjdGlvbkluZGV4LFxuICAgICAgbWVzc2FnZURhdGFPZmZzZXQsXG4gICAgICBtZXNzYWdlRGF0YVNpemU6IG1lc3NhZ2UubGVuZ3RoLFxuICAgICAgbWVzc2FnZUluc3RydWN0aW9uSW5kZXg6IGluc3RydWN0aW9uSW5kZXgsXG4gICAgICBzaWduYXR1cmU6IHRvQnVmZmVyKHNpZ25hdHVyZSksXG4gICAgICBldGhBZGRyZXNzOiB0b0J1ZmZlcihldGhBZGRyZXNzKSxcbiAgICAgIHJlY292ZXJ5SWRcbiAgICB9LCBpbnN0cnVjdGlvbkRhdGEpO1xuICAgIGluc3RydWN0aW9uRGF0YS5maWxsKHRvQnVmZmVyKG1lc3NhZ2UpLCBTRUNQMjU2SzFfSU5TVFJVQ1RJT05fTEFZT1VULnNwYW4pO1xuICAgIHJldHVybiBuZXcgVHJhbnNhY3Rpb25JbnN0cnVjdGlvbih7XG4gICAgICBrZXlzOiBbXSxcbiAgICAgIHByb2dyYW1JZDogU2VjcDI1NmsxUHJvZ3JhbS5wcm9ncmFtSWQsXG4gICAgICBkYXRhOiBpbnN0cnVjdGlvbkRhdGFcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGUgYW4gc2VjcDI1NmsxIGluc3RydWN0aW9uIHdpdGggYSBwcml2YXRlIGtleS4gVGhlIHByaXZhdGUga2V5XG4gICAqIG11c3QgYmUgYSBidWZmZXIgdGhhdCBpcyAzMiBieXRlcyBsb25nLlxuICAgKi9cbiAgc3RhdGljIGNyZWF0ZUluc3RydWN0aW9uV2l0aFByaXZhdGVLZXkocGFyYW1zKSB7XG4gICAgY29uc3Qge1xuICAgICAgcHJpdmF0ZUtleTogcGtleSxcbiAgICAgIG1lc3NhZ2UsXG4gICAgICBpbnN0cnVjdGlvbkluZGV4XG4gICAgfSA9IHBhcmFtcztcbiAgICBhc3NlcnQocGtleS5sZW5ndGggPT09IFBSSVZBVEVfS0VZX0JZVEVTLCBgUHJpdmF0ZSBrZXkgbXVzdCBiZSAke1BSSVZBVEVfS0VZX0JZVEVTfSBieXRlcyBidXQgcmVjZWl2ZWQgJHtwa2V5Lmxlbmd0aH0gYnl0ZXNgKTtcbiAgICB0cnkge1xuICAgICAgY29uc3QgcHJpdmF0ZUtleSA9IHRvQnVmZmVyKHBrZXkpO1xuICAgICAgY29uc3QgcHVibGljS2V5ID0gcHVibGljS2V5Q3JlYXRlKHByaXZhdGVLZXksIGZhbHNlIC8qIGlzQ29tcHJlc3NlZCAqLykuc2xpY2UoMSk7IC8vIHRocm93IGF3YXkgbGVhZGluZyBieXRlXG4gICAgICBjb25zdCBtZXNzYWdlSGFzaCA9IEJ1ZmZlci5mcm9tKGtlY2Nha18yNTYodG9CdWZmZXIobWVzc2FnZSkpKTtcbiAgICAgIGNvbnN0IFtzaWduYXR1cmUsIHJlY292ZXJ5SWRdID0gZWNkc2FTaWduKG1lc3NhZ2VIYXNoLCBwcml2YXRlS2V5KTtcbiAgICAgIHJldHVybiB0aGlzLmNyZWF0ZUluc3RydWN0aW9uV2l0aFB1YmxpY0tleSh7XG4gICAgICAgIHB1YmxpY0tleSxcbiAgICAgICAgbWVzc2FnZSxcbiAgICAgICAgc2lnbmF0dXJlLFxuICAgICAgICByZWNvdmVyeUlkLFxuICAgICAgICBpbnN0cnVjdGlvbkluZGV4XG4gICAgICB9KTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBFcnJvciBjcmVhdGluZyBpbnN0cnVjdGlvbjsgJHtlcnJvcn1gKTtcbiAgICB9XG4gIH1cbn1cblNlY3AyNTZrMVByb2dyYW0ucHJvZ3JhbUlkID0gbmV3IFB1YmxpY0tleSgnS2VjY2FrU2VjcDI1NmsxMTExMTExMTExMTExMTExMTExMTExMTExMTExMScpO1xuXG52YXIgX0xvY2t1cDtcblxuLyoqXG4gKiBBZGRyZXNzIG9mIHRoZSBzdGFrZSBjb25maWcgYWNjb3VudCB3aGljaCBjb25maWd1cmVzIHRoZSByYXRlXG4gKiBvZiBzdGFrZSB3YXJtdXAgYW5kIGNvb2xkb3duIGFzIHdlbGwgYXMgdGhlIHNsYXNoaW5nIHBlbmFsdHkuXG4gKi9cbmNvbnN0IFNUQUtFX0NPTkZJR19JRCA9IG5ldyBQdWJsaWNLZXkoJ1N0YWtlQ29uZmlnMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTEnKTtcblxuLyoqXG4gKiBTdGFrZSBhY2NvdW50IGF1dGhvcml0eSBpbmZvXG4gKi9cbmNsYXNzIEF1dGhvcml6ZWQge1xuICAvKipcbiAgICogQ3JlYXRlIGEgbmV3IEF1dGhvcml6ZWQgb2JqZWN0XG4gICAqIEBwYXJhbSBzdGFrZXIgdGhlIHN0YWtlIGF1dGhvcml0eVxuICAgKiBAcGFyYW0gd2l0aGRyYXdlciB0aGUgd2l0aGRyYXcgYXV0aG9yaXR5XG4gICAqL1xuICBjb25zdHJ1Y3RvcihzdGFrZXIsIHdpdGhkcmF3ZXIpIHtcbiAgICAvKiogc3Rha2UgYXV0aG9yaXR5ICovXG4gICAgdGhpcy5zdGFrZXIgPSB2b2lkIDA7XG4gICAgLyoqIHdpdGhkcmF3IGF1dGhvcml0eSAqL1xuICAgIHRoaXMud2l0aGRyYXdlciA9IHZvaWQgMDtcbiAgICB0aGlzLnN0YWtlciA9IHN0YWtlcjtcbiAgICB0aGlzLndpdGhkcmF3ZXIgPSB3aXRoZHJhd2VyO1xuICB9XG59XG4vKipcbiAqIFN0YWtlIGFjY291bnQgbG9ja3VwIGluZm9cbiAqL1xuY2xhc3MgTG9ja3VwIHtcbiAgLyoqXG4gICAqIENyZWF0ZSBhIG5ldyBMb2NrdXAgb2JqZWN0XG4gICAqL1xuICBjb25zdHJ1Y3Rvcih1bml4VGltZXN0YW1wLCBlcG9jaCwgY3VzdG9kaWFuKSB7XG4gICAgLyoqIFVuaXggdGltZXN0YW1wIG9mIGxvY2t1cCBleHBpcmF0aW9uICovXG4gICAgdGhpcy51bml4VGltZXN0YW1wID0gdm9pZCAwO1xuICAgIC8qKiBFcG9jaCBvZiBsb2NrdXAgZXhwaXJhdGlvbiAqL1xuICAgIHRoaXMuZXBvY2ggPSB2b2lkIDA7XG4gICAgLyoqIExvY2t1cCBjdXN0b2RpYW4gYXV0aG9yaXR5ICovXG4gICAgdGhpcy5jdXN0b2RpYW4gPSB2b2lkIDA7XG4gICAgdGhpcy51bml4VGltZXN0YW1wID0gdW5peFRpbWVzdGFtcDtcbiAgICB0aGlzLmVwb2NoID0gZXBvY2g7XG4gICAgdGhpcy5jdXN0b2RpYW4gPSBjdXN0b2RpYW47XG4gIH1cblxuICAvKipcbiAgICogRGVmYXVsdCwgaW5hY3RpdmUgTG9ja3VwIHZhbHVlXG4gICAqL1xufVxuX0xvY2t1cCA9IExvY2t1cDtcbkxvY2t1cC5kZWZhdWx0ID0gbmV3IF9Mb2NrdXAoMCwgMCwgUHVibGljS2V5LmRlZmF1bHQpO1xuLyoqXG4gKiBDcmVhdGUgc3Rha2UgYWNjb3VudCB0cmFuc2FjdGlvbiBwYXJhbXNcbiAqL1xuLyoqXG4gKiBDcmVhdGUgc3Rha2UgYWNjb3VudCB3aXRoIHNlZWQgdHJhbnNhY3Rpb24gcGFyYW1zXG4gKi9cbi8qKlxuICogSW5pdGlhbGl6ZSBzdGFrZSBpbnN0cnVjdGlvbiBwYXJhbXNcbiAqL1xuLyoqXG4gKiBEZWxlZ2F0ZSBzdGFrZSBpbnN0cnVjdGlvbiBwYXJhbXNcbiAqL1xuLyoqXG4gKiBBdXRob3JpemUgc3Rha2UgaW5zdHJ1Y3Rpb24gcGFyYW1zXG4gKi9cbi8qKlxuICogQXV0aG9yaXplIHN0YWtlIGluc3RydWN0aW9uIHBhcmFtcyB1c2luZyBhIGRlcml2ZWQga2V5XG4gKi9cbi8qKlxuICogU3BsaXQgc3Rha2UgaW5zdHJ1Y3Rpb24gcGFyYW1zXG4gKi9cbi8qKlxuICogU3BsaXQgd2l0aCBzZWVkIHRyYW5zYWN0aW9uIHBhcmFtc1xuICovXG4vKipcbiAqIFdpdGhkcmF3IHN0YWtlIGluc3RydWN0aW9uIHBhcmFtc1xuICovXG4vKipcbiAqIERlYWN0aXZhdGUgc3Rha2UgaW5zdHJ1Y3Rpb24gcGFyYW1zXG4gKi9cbi8qKlxuICogTWVyZ2Ugc3Rha2UgaW5zdHJ1Y3Rpb24gcGFyYW1zXG4gKi9cbi8qKlxuICogU3Rha2UgSW5zdHJ1Y3Rpb24gY2xhc3NcbiAqL1xuY2xhc3MgU3Rha2VJbnN0cnVjdGlvbiB7XG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIGNvbnN0cnVjdG9yKCkge31cblxuICAvKipcbiAgICogRGVjb2RlIGEgc3Rha2UgaW5zdHJ1Y3Rpb24gYW5kIHJldHJpZXZlIHRoZSBpbnN0cnVjdGlvbiB0eXBlLlxuICAgKi9cbiAgc3RhdGljIGRlY29kZUluc3RydWN0aW9uVHlwZShpbnN0cnVjdGlvbikge1xuICAgIHRoaXMuY2hlY2tQcm9ncmFtSWQoaW5zdHJ1Y3Rpb24ucHJvZ3JhbUlkKTtcbiAgICBjb25zdCBpbnN0cnVjdGlvblR5cGVMYXlvdXQgPSBCdWZmZXJMYXlvdXQudTMyKCdpbnN0cnVjdGlvbicpO1xuICAgIGNvbnN0IHR5cGVJbmRleCA9IGluc3RydWN0aW9uVHlwZUxheW91dC5kZWNvZGUoaW5zdHJ1Y3Rpb24uZGF0YSk7XG4gICAgbGV0IHR5cGU7XG4gICAgZm9yIChjb25zdCBbaXhUeXBlLCBsYXlvdXRdIG9mIE9iamVjdC5lbnRyaWVzKFNUQUtFX0lOU1RSVUNUSU9OX0xBWU9VVFMpKSB7XG4gICAgICBpZiAobGF5b3V0LmluZGV4ID09IHR5cGVJbmRleCkge1xuICAgICAgICB0eXBlID0gaXhUeXBlO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKCF0eXBlKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0luc3RydWN0aW9uIHR5cGUgaW5jb3JyZWN0OyBub3QgYSBTdGFrZUluc3RydWN0aW9uJyk7XG4gICAgfVxuICAgIHJldHVybiB0eXBlO1xuICB9XG5cbiAgLyoqXG4gICAqIERlY29kZSBhIGluaXRpYWxpemUgc3Rha2UgaW5zdHJ1Y3Rpb24gYW5kIHJldHJpZXZlIHRoZSBpbnN0cnVjdGlvbiBwYXJhbXMuXG4gICAqL1xuICBzdGF0aWMgZGVjb2RlSW5pdGlhbGl6ZShpbnN0cnVjdGlvbikge1xuICAgIHRoaXMuY2hlY2tQcm9ncmFtSWQoaW5zdHJ1Y3Rpb24ucHJvZ3JhbUlkKTtcbiAgICB0aGlzLmNoZWNrS2V5TGVuZ3RoKGluc3RydWN0aW9uLmtleXMsIDIpO1xuICAgIGNvbnN0IHtcbiAgICAgIGF1dGhvcml6ZWQsXG4gICAgICBsb2NrdXBcbiAgICB9ID0gZGVjb2RlRGF0YSQxKFNUQUtFX0lOU1RSVUNUSU9OX0xBWU9VVFMuSW5pdGlhbGl6ZSwgaW5zdHJ1Y3Rpb24uZGF0YSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHN0YWtlUHVia2V5OiBpbnN0cnVjdGlvbi5rZXlzWzBdLnB1YmtleSxcbiAgICAgIGF1dGhvcml6ZWQ6IG5ldyBBdXRob3JpemVkKG5ldyBQdWJsaWNLZXkoYXV0aG9yaXplZC5zdGFrZXIpLCBuZXcgUHVibGljS2V5KGF1dGhvcml6ZWQud2l0aGRyYXdlcikpLFxuICAgICAgbG9ja3VwOiBuZXcgTG9ja3VwKGxvY2t1cC51bml4VGltZXN0YW1wLCBsb2NrdXAuZXBvY2gsIG5ldyBQdWJsaWNLZXkobG9ja3VwLmN1c3RvZGlhbikpXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZWNvZGUgYSBkZWxlZ2F0ZSBzdGFrZSBpbnN0cnVjdGlvbiBhbmQgcmV0cmlldmUgdGhlIGluc3RydWN0aW9uIHBhcmFtcy5cbiAgICovXG4gIHN0YXRpYyBkZWNvZGVEZWxlZ2F0ZShpbnN0cnVjdGlvbikge1xuICAgIHRoaXMuY2hlY2tQcm9ncmFtSWQoaW5zdHJ1Y3Rpb24ucHJvZ3JhbUlkKTtcbiAgICB0aGlzLmNoZWNrS2V5TGVuZ3RoKGluc3RydWN0aW9uLmtleXMsIDYpO1xuICAgIGRlY29kZURhdGEkMShTVEFLRV9JTlNUUlVDVElPTl9MQVlPVVRTLkRlbGVnYXRlLCBpbnN0cnVjdGlvbi5kYXRhKTtcbiAgICByZXR1cm4ge1xuICAgICAgc3Rha2VQdWJrZXk6IGluc3RydWN0aW9uLmtleXNbMF0ucHVia2V5LFxuICAgICAgdm90ZVB1YmtleTogaW5zdHJ1Y3Rpb24ua2V5c1sxXS5wdWJrZXksXG4gICAgICBhdXRob3JpemVkUHVia2V5OiBpbnN0cnVjdGlvbi5rZXlzWzVdLnB1YmtleVxuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogRGVjb2RlIGFuIGF1dGhvcml6ZSBzdGFrZSBpbnN0cnVjdGlvbiBhbmQgcmV0cmlldmUgdGhlIGluc3RydWN0aW9uIHBhcmFtcy5cbiAgICovXG4gIHN0YXRpYyBkZWNvZGVBdXRob3JpemUoaW5zdHJ1Y3Rpb24pIHtcbiAgICB0aGlzLmNoZWNrUHJvZ3JhbUlkKGluc3RydWN0aW9uLnByb2dyYW1JZCk7XG4gICAgdGhpcy5jaGVja0tleUxlbmd0aChpbnN0cnVjdGlvbi5rZXlzLCAzKTtcbiAgICBjb25zdCB7XG4gICAgICBuZXdBdXRob3JpemVkLFxuICAgICAgc3Rha2VBdXRob3JpemF0aW9uVHlwZVxuICAgIH0gPSBkZWNvZGVEYXRhJDEoU1RBS0VfSU5TVFJVQ1RJT05fTEFZT1VUUy5BdXRob3JpemUsIGluc3RydWN0aW9uLmRhdGEpO1xuICAgIGNvbnN0IG8gPSB7XG4gICAgICBzdGFrZVB1YmtleTogaW5zdHJ1Y3Rpb24ua2V5c1swXS5wdWJrZXksXG4gICAgICBhdXRob3JpemVkUHVia2V5OiBpbnN0cnVjdGlvbi5rZXlzWzJdLnB1YmtleSxcbiAgICAgIG5ld0F1dGhvcml6ZWRQdWJrZXk6IG5ldyBQdWJsaWNLZXkobmV3QXV0aG9yaXplZCksXG4gICAgICBzdGFrZUF1dGhvcml6YXRpb25UeXBlOiB7XG4gICAgICAgIGluZGV4OiBzdGFrZUF1dGhvcml6YXRpb25UeXBlXG4gICAgICB9XG4gICAgfTtcbiAgICBpZiAoaW5zdHJ1Y3Rpb24ua2V5cy5sZW5ndGggPiAzKSB7XG4gICAgICBvLmN1c3RvZGlhblB1YmtleSA9IGluc3RydWN0aW9uLmtleXNbM10ucHVia2V5O1xuICAgIH1cbiAgICByZXR1cm4gbztcbiAgfVxuXG4gIC8qKlxuICAgKiBEZWNvZGUgYW4gYXV0aG9yaXplLXdpdGgtc2VlZCBzdGFrZSBpbnN0cnVjdGlvbiBhbmQgcmV0cmlldmUgdGhlIGluc3RydWN0aW9uIHBhcmFtcy5cbiAgICovXG4gIHN0YXRpYyBkZWNvZGVBdXRob3JpemVXaXRoU2VlZChpbnN0cnVjdGlvbikge1xuICAgIHRoaXMuY2hlY2tQcm9ncmFtSWQoaW5zdHJ1Y3Rpb24ucHJvZ3JhbUlkKTtcbiAgICB0aGlzLmNoZWNrS2V5TGVuZ3RoKGluc3RydWN0aW9uLmtleXMsIDIpO1xuICAgIGNvbnN0IHtcbiAgICAgIG5ld0F1dGhvcml6ZWQsXG4gICAgICBzdGFrZUF1dGhvcml6YXRpb25UeXBlLFxuICAgICAgYXV0aG9yaXR5U2VlZCxcbiAgICAgIGF1dGhvcml0eU93bmVyXG4gICAgfSA9IGRlY29kZURhdGEkMShTVEFLRV9JTlNUUlVDVElPTl9MQVlPVVRTLkF1dGhvcml6ZVdpdGhTZWVkLCBpbnN0cnVjdGlvbi5kYXRhKTtcbiAgICBjb25zdCBvID0ge1xuICAgICAgc3Rha2VQdWJrZXk6IGluc3RydWN0aW9uLmtleXNbMF0ucHVia2V5LFxuICAgICAgYXV0aG9yaXR5QmFzZTogaW5zdHJ1Y3Rpb24ua2V5c1sxXS5wdWJrZXksXG4gICAgICBhdXRob3JpdHlTZWVkOiBhdXRob3JpdHlTZWVkLFxuICAgICAgYXV0aG9yaXR5T3duZXI6IG5ldyBQdWJsaWNLZXkoYXV0aG9yaXR5T3duZXIpLFxuICAgICAgbmV3QXV0aG9yaXplZFB1YmtleTogbmV3IFB1YmxpY0tleShuZXdBdXRob3JpemVkKSxcbiAgICAgIHN0YWtlQXV0aG9yaXphdGlvblR5cGU6IHtcbiAgICAgICAgaW5kZXg6IHN0YWtlQXV0aG9yaXphdGlvblR5cGVcbiAgICAgIH1cbiAgICB9O1xuICAgIGlmIChpbnN0cnVjdGlvbi5rZXlzLmxlbmd0aCA+IDMpIHtcbiAgICAgIG8uY3VzdG9kaWFuUHVia2V5ID0gaW5zdHJ1Y3Rpb24ua2V5c1szXS5wdWJrZXk7XG4gICAgfVxuICAgIHJldHVybiBvO1xuICB9XG5cbiAgLyoqXG4gICAqIERlY29kZSBhIHNwbGl0IHN0YWtlIGluc3RydWN0aW9uIGFuZCByZXRyaWV2ZSB0aGUgaW5zdHJ1Y3Rpb24gcGFyYW1zLlxuICAgKi9cbiAgc3RhdGljIGRlY29kZVNwbGl0KGluc3RydWN0aW9uKSB7XG4gICAgdGhpcy5jaGVja1Byb2dyYW1JZChpbnN0cnVjdGlvbi5wcm9ncmFtSWQpO1xuICAgIHRoaXMuY2hlY2tLZXlMZW5ndGgoaW5zdHJ1Y3Rpb24ua2V5cywgMyk7XG4gICAgY29uc3Qge1xuICAgICAgbGFtcG9ydHNcbiAgICB9ID0gZGVjb2RlRGF0YSQxKFNUQUtFX0lOU1RSVUNUSU9OX0xBWU9VVFMuU3BsaXQsIGluc3RydWN0aW9uLmRhdGEpO1xuICAgIHJldHVybiB7XG4gICAgICBzdGFrZVB1YmtleTogaW5zdHJ1Y3Rpb24ua2V5c1swXS5wdWJrZXksXG4gICAgICBzcGxpdFN0YWtlUHVia2V5OiBpbnN0cnVjdGlvbi5rZXlzWzFdLnB1YmtleSxcbiAgICAgIGF1dGhvcml6ZWRQdWJrZXk6IGluc3RydWN0aW9uLmtleXNbMl0ucHVia2V5LFxuICAgICAgbGFtcG9ydHNcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIERlY29kZSBhIG1lcmdlIHN0YWtlIGluc3RydWN0aW9uIGFuZCByZXRyaWV2ZSB0aGUgaW5zdHJ1Y3Rpb24gcGFyYW1zLlxuICAgKi9cbiAgc3RhdGljIGRlY29kZU1lcmdlKGluc3RydWN0aW9uKSB7XG4gICAgdGhpcy5jaGVja1Byb2dyYW1JZChpbnN0cnVjdGlvbi5wcm9ncmFtSWQpO1xuICAgIHRoaXMuY2hlY2tLZXlMZW5ndGgoaW5zdHJ1Y3Rpb24ua2V5cywgMyk7XG4gICAgZGVjb2RlRGF0YSQxKFNUQUtFX0lOU1RSVUNUSU9OX0xBWU9VVFMuTWVyZ2UsIGluc3RydWN0aW9uLmRhdGEpO1xuICAgIHJldHVybiB7XG4gICAgICBzdGFrZVB1YmtleTogaW5zdHJ1Y3Rpb24ua2V5c1swXS5wdWJrZXksXG4gICAgICBzb3VyY2VTdGFrZVB1YktleTogaW5zdHJ1Y3Rpb24ua2V5c1sxXS5wdWJrZXksXG4gICAgICBhdXRob3JpemVkUHVia2V5OiBpbnN0cnVjdGlvbi5rZXlzWzRdLnB1YmtleVxuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogRGVjb2RlIGEgd2l0aGRyYXcgc3Rha2UgaW5zdHJ1Y3Rpb24gYW5kIHJldHJpZXZlIHRoZSBpbnN0cnVjdGlvbiBwYXJhbXMuXG4gICAqL1xuICBzdGF0aWMgZGVjb2RlV2l0aGRyYXcoaW5zdHJ1Y3Rpb24pIHtcbiAgICB0aGlzLmNoZWNrUHJvZ3JhbUlkKGluc3RydWN0aW9uLnByb2dyYW1JZCk7XG4gICAgdGhpcy5jaGVja0tleUxlbmd0aChpbnN0cnVjdGlvbi5rZXlzLCA1KTtcbiAgICBjb25zdCB7XG4gICAgICBsYW1wb3J0c1xuICAgIH0gPSBkZWNvZGVEYXRhJDEoU1RBS0VfSU5TVFJVQ1RJT05fTEFZT1VUUy5XaXRoZHJhdywgaW5zdHJ1Y3Rpb24uZGF0YSk7XG4gICAgY29uc3QgbyA9IHtcbiAgICAgIHN0YWtlUHVia2V5OiBpbnN0cnVjdGlvbi5rZXlzWzBdLnB1YmtleSxcbiAgICAgIHRvUHVia2V5OiBpbnN0cnVjdGlvbi5rZXlzWzFdLnB1YmtleSxcbiAgICAgIGF1dGhvcml6ZWRQdWJrZXk6IGluc3RydWN0aW9uLmtleXNbNF0ucHVia2V5LFxuICAgICAgbGFtcG9ydHNcbiAgICB9O1xuICAgIGlmIChpbnN0cnVjdGlvbi5rZXlzLmxlbmd0aCA+IDUpIHtcbiAgICAgIG8uY3VzdG9kaWFuUHVia2V5ID0gaW5zdHJ1Y3Rpb24ua2V5c1s1XS5wdWJrZXk7XG4gICAgfVxuICAgIHJldHVybiBvO1xuICB9XG5cbiAgLyoqXG4gICAqIERlY29kZSBhIGRlYWN0aXZhdGUgc3Rha2UgaW5zdHJ1Y3Rpb24gYW5kIHJldHJpZXZlIHRoZSBpbnN0cnVjdGlvbiBwYXJhbXMuXG4gICAqL1xuICBzdGF0aWMgZGVjb2RlRGVhY3RpdmF0ZShpbnN0cnVjdGlvbikge1xuICAgIHRoaXMuY2hlY2tQcm9ncmFtSWQoaW5zdHJ1Y3Rpb24ucHJvZ3JhbUlkKTtcbiAgICB0aGlzLmNoZWNrS2V5TGVuZ3RoKGluc3RydWN0aW9uLmtleXMsIDMpO1xuICAgIGRlY29kZURhdGEkMShTVEFLRV9JTlNUUlVDVElPTl9MQVlPVVRTLkRlYWN0aXZhdGUsIGluc3RydWN0aW9uLmRhdGEpO1xuICAgIHJldHVybiB7XG4gICAgICBzdGFrZVB1YmtleTogaW5zdHJ1Y3Rpb24ua2V5c1swXS5wdWJrZXksXG4gICAgICBhdXRob3JpemVkUHVia2V5OiBpbnN0cnVjdGlvbi5rZXlzWzJdLnB1YmtleVxuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogQGludGVybmFsXG4gICAqL1xuICBzdGF0aWMgY2hlY2tQcm9ncmFtSWQocHJvZ3JhbUlkKSB7XG4gICAgaWYgKCFwcm9ncmFtSWQuZXF1YWxzKFN0YWtlUHJvZ3JhbS5wcm9ncmFtSWQpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgaW5zdHJ1Y3Rpb247IHByb2dyYW1JZCBpcyBub3QgU3Rha2VQcm9ncmFtJyk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgc3RhdGljIGNoZWNrS2V5TGVuZ3RoKGtleXMsIGV4cGVjdGVkTGVuZ3RoKSB7XG4gICAgaWYgKGtleXMubGVuZ3RoIDwgZXhwZWN0ZWRMZW5ndGgpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgaW52YWxpZCBpbnN0cnVjdGlvbjsgZm91bmQgJHtrZXlzLmxlbmd0aH0ga2V5cywgZXhwZWN0ZWQgYXQgbGVhc3QgJHtleHBlY3RlZExlbmd0aH1gKTtcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBBbiBlbnVtZXJhdGlvbiBvZiB2YWxpZCBTdGFrZUluc3RydWN0aW9uVHlwZSdzXG4gKi9cblxuLyoqXG4gKiBBbiBlbnVtZXJhdGlvbiBvZiB2YWxpZCBzdGFrZSBJbnN0cnVjdGlvblR5cGUnc1xuICogQGludGVybmFsXG4gKi9cbmNvbnN0IFNUQUtFX0lOU1RSVUNUSU9OX0xBWU9VVFMgPSBPYmplY3QuZnJlZXplKHtcbiAgSW5pdGlhbGl6ZToge1xuICAgIGluZGV4OiAwLFxuICAgIGxheW91dDogQnVmZmVyTGF5b3V0LnN0cnVjdChbQnVmZmVyTGF5b3V0LnUzMignaW5zdHJ1Y3Rpb24nKSwgYXV0aG9yaXplZCgpLCBsb2NrdXAoKV0pXG4gIH0sXG4gIEF1dGhvcml6ZToge1xuICAgIGluZGV4OiAxLFxuICAgIGxheW91dDogQnVmZmVyTGF5b3V0LnN0cnVjdChbQnVmZmVyTGF5b3V0LnUzMignaW5zdHJ1Y3Rpb24nKSwgcHVibGljS2V5KCduZXdBdXRob3JpemVkJyksIEJ1ZmZlckxheW91dC51MzIoJ3N0YWtlQXV0aG9yaXphdGlvblR5cGUnKV0pXG4gIH0sXG4gIERlbGVnYXRlOiB7XG4gICAgaW5kZXg6IDIsXG4gICAgbGF5b3V0OiBCdWZmZXJMYXlvdXQuc3RydWN0KFtCdWZmZXJMYXlvdXQudTMyKCdpbnN0cnVjdGlvbicpXSlcbiAgfSxcbiAgU3BsaXQ6IHtcbiAgICBpbmRleDogMyxcbiAgICBsYXlvdXQ6IEJ1ZmZlckxheW91dC5zdHJ1Y3QoW0J1ZmZlckxheW91dC51MzIoJ2luc3RydWN0aW9uJyksIEJ1ZmZlckxheW91dC5uczY0KCdsYW1wb3J0cycpXSlcbiAgfSxcbiAgV2l0aGRyYXc6IHtcbiAgICBpbmRleDogNCxcbiAgICBsYXlvdXQ6IEJ1ZmZlckxheW91dC5zdHJ1Y3QoW0J1ZmZlckxheW91dC51MzIoJ2luc3RydWN0aW9uJyksIEJ1ZmZlckxheW91dC5uczY0KCdsYW1wb3J0cycpXSlcbiAgfSxcbiAgRGVhY3RpdmF0ZToge1xuICAgIGluZGV4OiA1LFxuICAgIGxheW91dDogQnVmZmVyTGF5b3V0LnN0cnVjdChbQnVmZmVyTGF5b3V0LnUzMignaW5zdHJ1Y3Rpb24nKV0pXG4gIH0sXG4gIE1lcmdlOiB7XG4gICAgaW5kZXg6IDcsXG4gICAgbGF5b3V0OiBCdWZmZXJMYXlvdXQuc3RydWN0KFtCdWZmZXJMYXlvdXQudTMyKCdpbnN0cnVjdGlvbicpXSlcbiAgfSxcbiAgQXV0aG9yaXplV2l0aFNlZWQ6IHtcbiAgICBpbmRleDogOCxcbiAgICBsYXlvdXQ6IEJ1ZmZlckxheW91dC5zdHJ1Y3QoW0J1ZmZlckxheW91dC51MzIoJ2luc3RydWN0aW9uJyksIHB1YmxpY0tleSgnbmV3QXV0aG9yaXplZCcpLCBCdWZmZXJMYXlvdXQudTMyKCdzdGFrZUF1dGhvcml6YXRpb25UeXBlJyksIHJ1c3RTdHJpbmcoJ2F1dGhvcml0eVNlZWQnKSwgcHVibGljS2V5KCdhdXRob3JpdHlPd25lcicpXSlcbiAgfVxufSk7XG5cbi8qKlxuICogU3Rha2UgYXV0aG9yaXphdGlvbiB0eXBlXG4gKi9cblxuLyoqXG4gKiBBbiBlbnVtZXJhdGlvbiBvZiB2YWxpZCBTdGFrZUF1dGhvcml6YXRpb25MYXlvdXQnc1xuICovXG5jb25zdCBTdGFrZUF1dGhvcml6YXRpb25MYXlvdXQgPSBPYmplY3QuZnJlZXplKHtcbiAgU3Rha2VyOiB7XG4gICAgaW5kZXg6IDBcbiAgfSxcbiAgV2l0aGRyYXdlcjoge1xuICAgIGluZGV4OiAxXG4gIH1cbn0pO1xuXG4vKipcbiAqIEZhY3RvcnkgY2xhc3MgZm9yIHRyYW5zYWN0aW9ucyB0byBpbnRlcmFjdCB3aXRoIHRoZSBTdGFrZSBwcm9ncmFtXG4gKi9cbmNsYXNzIFN0YWtlUHJvZ3JhbSB7XG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIGNvbnN0cnVjdG9yKCkge31cblxuICAvKipcbiAgICogUHVibGljIGtleSB0aGF0IGlkZW50aWZpZXMgdGhlIFN0YWtlIHByb2dyYW1cbiAgICovXG5cbiAgLyoqXG4gICAqIEdlbmVyYXRlIGFuIEluaXRpYWxpemUgaW5zdHJ1Y3Rpb24gdG8gYWRkIHRvIGEgU3Rha2UgQ3JlYXRlIHRyYW5zYWN0aW9uXG4gICAqL1xuICBzdGF0aWMgaW5pdGlhbGl6ZShwYXJhbXMpIHtcbiAgICBjb25zdCB7XG4gICAgICBzdGFrZVB1YmtleSxcbiAgICAgIGF1dGhvcml6ZWQsXG4gICAgICBsb2NrdXA6IG1heWJlTG9ja3VwXG4gICAgfSA9IHBhcmFtcztcbiAgICBjb25zdCBsb2NrdXAgPSBtYXliZUxvY2t1cCB8fCBMb2NrdXAuZGVmYXVsdDtcbiAgICBjb25zdCB0eXBlID0gU1RBS0VfSU5TVFJVQ1RJT05fTEFZT1VUUy5Jbml0aWFsaXplO1xuICAgIGNvbnN0IGRhdGEgPSBlbmNvZGVEYXRhKHR5cGUsIHtcbiAgICAgIGF1dGhvcml6ZWQ6IHtcbiAgICAgICAgc3Rha2VyOiB0b0J1ZmZlcihhdXRob3JpemVkLnN0YWtlci50b0J1ZmZlcigpKSxcbiAgICAgICAgd2l0aGRyYXdlcjogdG9CdWZmZXIoYXV0aG9yaXplZC53aXRoZHJhd2VyLnRvQnVmZmVyKCkpXG4gICAgICB9LFxuICAgICAgbG9ja3VwOiB7XG4gICAgICAgIHVuaXhUaW1lc3RhbXA6IGxvY2t1cC51bml4VGltZXN0YW1wLFxuICAgICAgICBlcG9jaDogbG9ja3VwLmVwb2NoLFxuICAgICAgICBjdXN0b2RpYW46IHRvQnVmZmVyKGxvY2t1cC5jdXN0b2RpYW4udG9CdWZmZXIoKSlcbiAgICAgIH1cbiAgICB9KTtcbiAgICBjb25zdCBpbnN0cnVjdGlvbkRhdGEgPSB7XG4gICAgICBrZXlzOiBbe1xuICAgICAgICBwdWJrZXk6IHN0YWtlUHVia2V5LFxuICAgICAgICBpc1NpZ25lcjogZmFsc2UsXG4gICAgICAgIGlzV3JpdGFibGU6IHRydWVcbiAgICAgIH0sIHtcbiAgICAgICAgcHVia2V5OiBTWVNWQVJfUkVOVF9QVUJLRVksXG4gICAgICAgIGlzU2lnbmVyOiBmYWxzZSxcbiAgICAgICAgaXNXcml0YWJsZTogZmFsc2VcbiAgICAgIH1dLFxuICAgICAgcHJvZ3JhbUlkOiB0aGlzLnByb2dyYW1JZCxcbiAgICAgIGRhdGFcbiAgICB9O1xuICAgIHJldHVybiBuZXcgVHJhbnNhY3Rpb25JbnN0cnVjdGlvbihpbnN0cnVjdGlvbkRhdGEpO1xuICB9XG5cbiAgLyoqXG4gICAqIEdlbmVyYXRlIGEgVHJhbnNhY3Rpb24gdGhhdCBjcmVhdGVzIGEgbmV3IFN0YWtlIGFjY291bnQgYXRcbiAgICogICBhbiBhZGRyZXNzIGdlbmVyYXRlZCB3aXRoIGBmcm9tYCwgYSBzZWVkLCBhbmQgdGhlIFN0YWtlIHByb2dyYW1JZFxuICAgKi9cbiAgc3RhdGljIGNyZWF0ZUFjY291bnRXaXRoU2VlZChwYXJhbXMpIHtcbiAgICBjb25zdCB0cmFuc2FjdGlvbiA9IG5ldyBUcmFuc2FjdGlvbigpO1xuICAgIHRyYW5zYWN0aW9uLmFkZChTeXN0ZW1Qcm9ncmFtLmNyZWF0ZUFjY291bnRXaXRoU2VlZCh7XG4gICAgICBmcm9tUHVia2V5OiBwYXJhbXMuZnJvbVB1YmtleSxcbiAgICAgIG5ld0FjY291bnRQdWJrZXk6IHBhcmFtcy5zdGFrZVB1YmtleSxcbiAgICAgIGJhc2VQdWJrZXk6IHBhcmFtcy5iYXNlUHVia2V5LFxuICAgICAgc2VlZDogcGFyYW1zLnNlZWQsXG4gICAgICBsYW1wb3J0czogcGFyYW1zLmxhbXBvcnRzLFxuICAgICAgc3BhY2U6IHRoaXMuc3BhY2UsXG4gICAgICBwcm9ncmFtSWQ6IHRoaXMucHJvZ3JhbUlkXG4gICAgfSkpO1xuICAgIGNvbnN0IHtcbiAgICAgIHN0YWtlUHVia2V5LFxuICAgICAgYXV0aG9yaXplZCxcbiAgICAgIGxvY2t1cFxuICAgIH0gPSBwYXJhbXM7XG4gICAgcmV0dXJuIHRyYW5zYWN0aW9uLmFkZCh0aGlzLmluaXRpYWxpemUoe1xuICAgICAgc3Rha2VQdWJrZXksXG4gICAgICBhdXRob3JpemVkLFxuICAgICAgbG9ja3VwXG4gICAgfSkpO1xuICB9XG5cbiAgLyoqXG4gICAqIEdlbmVyYXRlIGEgVHJhbnNhY3Rpb24gdGhhdCBjcmVhdGVzIGEgbmV3IFN0YWtlIGFjY291bnRcbiAgICovXG4gIHN0YXRpYyBjcmVhdGVBY2NvdW50KHBhcmFtcykge1xuICAgIGNvbnN0IHRyYW5zYWN0aW9uID0gbmV3IFRyYW5zYWN0aW9uKCk7XG4gICAgdHJhbnNhY3Rpb24uYWRkKFN5c3RlbVByb2dyYW0uY3JlYXRlQWNjb3VudCh7XG4gICAgICBmcm9tUHVia2V5OiBwYXJhbXMuZnJvbVB1YmtleSxcbiAgICAgIG5ld0FjY291bnRQdWJrZXk6IHBhcmFtcy5zdGFrZVB1YmtleSxcbiAgICAgIGxhbXBvcnRzOiBwYXJhbXMubGFtcG9ydHMsXG4gICAgICBzcGFjZTogdGhpcy5zcGFjZSxcbiAgICAgIHByb2dyYW1JZDogdGhpcy5wcm9ncmFtSWRcbiAgICB9KSk7XG4gICAgY29uc3Qge1xuICAgICAgc3Rha2VQdWJrZXksXG4gICAgICBhdXRob3JpemVkLFxuICAgICAgbG9ja3VwXG4gICAgfSA9IHBhcmFtcztcbiAgICByZXR1cm4gdHJhbnNhY3Rpb24uYWRkKHRoaXMuaW5pdGlhbGl6ZSh7XG4gICAgICBzdGFrZVB1YmtleSxcbiAgICAgIGF1dGhvcml6ZWQsXG4gICAgICBsb2NrdXBcbiAgICB9KSk7XG4gIH1cblxuICAvKipcbiAgICogR2VuZXJhdGUgYSBUcmFuc2FjdGlvbiB0aGF0IGRlbGVnYXRlcyBTdGFrZSB0b2tlbnMgdG8gYSB2YWxpZGF0b3JcbiAgICogVm90ZSBQdWJsaWNLZXkuIFRoaXMgdHJhbnNhY3Rpb24gY2FuIGFsc28gYmUgdXNlZCB0byByZWRlbGVnYXRlIFN0YWtlXG4gICAqIHRvIGEgbmV3IHZhbGlkYXRvciBWb3RlIFB1YmxpY0tleS5cbiAgICovXG4gIHN0YXRpYyBkZWxlZ2F0ZShwYXJhbXMpIHtcbiAgICBjb25zdCB7XG4gICAgICBzdGFrZVB1YmtleSxcbiAgICAgIGF1dGhvcml6ZWRQdWJrZXksXG4gICAgICB2b3RlUHVia2V5XG4gICAgfSA9IHBhcmFtcztcbiAgICBjb25zdCB0eXBlID0gU1RBS0VfSU5TVFJVQ1RJT05fTEFZT1VUUy5EZWxlZ2F0ZTtcbiAgICBjb25zdCBkYXRhID0gZW5jb2RlRGF0YSh0eXBlKTtcbiAgICByZXR1cm4gbmV3IFRyYW5zYWN0aW9uKCkuYWRkKHtcbiAgICAgIGtleXM6IFt7XG4gICAgICAgIHB1YmtleTogc3Rha2VQdWJrZXksXG4gICAgICAgIGlzU2lnbmVyOiBmYWxzZSxcbiAgICAgICAgaXNXcml0YWJsZTogdHJ1ZVxuICAgICAgfSwge1xuICAgICAgICBwdWJrZXk6IHZvdGVQdWJrZXksXG4gICAgICAgIGlzU2lnbmVyOiBmYWxzZSxcbiAgICAgICAgaXNXcml0YWJsZTogZmFsc2VcbiAgICAgIH0sIHtcbiAgICAgICAgcHVia2V5OiBTWVNWQVJfQ0xPQ0tfUFVCS0VZLFxuICAgICAgICBpc1NpZ25lcjogZmFsc2UsXG4gICAgICAgIGlzV3JpdGFibGU6IGZhbHNlXG4gICAgICB9LCB7XG4gICAgICAgIHB1YmtleTogU1lTVkFSX1NUQUtFX0hJU1RPUllfUFVCS0VZLFxuICAgICAgICBpc1NpZ25lcjogZmFsc2UsXG4gICAgICAgIGlzV3JpdGFibGU6IGZhbHNlXG4gICAgICB9LCB7XG4gICAgICAgIHB1YmtleTogU1RBS0VfQ09ORklHX0lELFxuICAgICAgICBpc1NpZ25lcjogZmFsc2UsXG4gICAgICAgIGlzV3JpdGFibGU6IGZhbHNlXG4gICAgICB9LCB7XG4gICAgICAgIHB1YmtleTogYXV0aG9yaXplZFB1YmtleSxcbiAgICAgICAgaXNTaWduZXI6IHRydWUsXG4gICAgICAgIGlzV3JpdGFibGU6IGZhbHNlXG4gICAgICB9XSxcbiAgICAgIHByb2dyYW1JZDogdGhpcy5wcm9ncmFtSWQsXG4gICAgICBkYXRhXG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogR2VuZXJhdGUgYSBUcmFuc2FjdGlvbiB0aGF0IGF1dGhvcml6ZXMgYSBuZXcgUHVibGljS2V5IGFzIFN0YWtlclxuICAgKiBvciBXaXRoZHJhd2VyIG9uIHRoZSBTdGFrZSBhY2NvdW50LlxuICAgKi9cbiAgc3RhdGljIGF1dGhvcml6ZShwYXJhbXMpIHtcbiAgICBjb25zdCB7XG4gICAgICBzdGFrZVB1YmtleSxcbiAgICAgIGF1dGhvcml6ZWRQdWJrZXksXG4gICAgICBuZXdBdXRob3JpemVkUHVia2V5LFxuICAgICAgc3Rha2VBdXRob3JpemF0aW9uVHlwZSxcbiAgICAgIGN1c3RvZGlhblB1YmtleVxuICAgIH0gPSBwYXJhbXM7XG4gICAgY29uc3QgdHlwZSA9IFNUQUtFX0lOU1RSVUNUSU9OX0xBWU9VVFMuQXV0aG9yaXplO1xuICAgIGNvbnN0IGRhdGEgPSBlbmNvZGVEYXRhKHR5cGUsIHtcbiAgICAgIG5ld0F1dGhvcml6ZWQ6IHRvQnVmZmVyKG5ld0F1dGhvcml6ZWRQdWJrZXkudG9CdWZmZXIoKSksXG4gICAgICBzdGFrZUF1dGhvcml6YXRpb25UeXBlOiBzdGFrZUF1dGhvcml6YXRpb25UeXBlLmluZGV4XG4gICAgfSk7XG4gICAgY29uc3Qga2V5cyA9IFt7XG4gICAgICBwdWJrZXk6IHN0YWtlUHVia2V5LFxuICAgICAgaXNTaWduZXI6IGZhbHNlLFxuICAgICAgaXNXcml0YWJsZTogdHJ1ZVxuICAgIH0sIHtcbiAgICAgIHB1YmtleTogU1lTVkFSX0NMT0NLX1BVQktFWSxcbiAgICAgIGlzU2lnbmVyOiBmYWxzZSxcbiAgICAgIGlzV3JpdGFibGU6IHRydWVcbiAgICB9LCB7XG4gICAgICBwdWJrZXk6IGF1dGhvcml6ZWRQdWJrZXksXG4gICAgICBpc1NpZ25lcjogdHJ1ZSxcbiAgICAgIGlzV3JpdGFibGU6IGZhbHNlXG4gICAgfV07XG4gICAgaWYgKGN1c3RvZGlhblB1YmtleSkge1xuICAgICAga2V5cy5wdXNoKHtcbiAgICAgICAgcHVia2V5OiBjdXN0b2RpYW5QdWJrZXksXG4gICAgICAgIGlzU2lnbmVyOiB0cnVlLFxuICAgICAgICBpc1dyaXRhYmxlOiBmYWxzZVxuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBuZXcgVHJhbnNhY3Rpb24oKS5hZGQoe1xuICAgICAga2V5cyxcbiAgICAgIHByb2dyYW1JZDogdGhpcy5wcm9ncmFtSWQsXG4gICAgICBkYXRhXG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogR2VuZXJhdGUgYSBUcmFuc2FjdGlvbiB0aGF0IGF1dGhvcml6ZXMgYSBuZXcgUHVibGljS2V5IGFzIFN0YWtlclxuICAgKiBvciBXaXRoZHJhd2VyIG9uIHRoZSBTdGFrZSBhY2NvdW50LlxuICAgKi9cbiAgc3RhdGljIGF1dGhvcml6ZVdpdGhTZWVkKHBhcmFtcykge1xuICAgIGNvbnN0IHtcbiAgICAgIHN0YWtlUHVia2V5LFxuICAgICAgYXV0aG9yaXR5QmFzZSxcbiAgICAgIGF1dGhvcml0eVNlZWQsXG4gICAgICBhdXRob3JpdHlPd25lcixcbiAgICAgIG5ld0F1dGhvcml6ZWRQdWJrZXksXG4gICAgICBzdGFrZUF1dGhvcml6YXRpb25UeXBlLFxuICAgICAgY3VzdG9kaWFuUHVia2V5XG4gICAgfSA9IHBhcmFtcztcbiAgICBjb25zdCB0eXBlID0gU1RBS0VfSU5TVFJVQ1RJT05fTEFZT1VUUy5BdXRob3JpemVXaXRoU2VlZDtcbiAgICBjb25zdCBkYXRhID0gZW5jb2RlRGF0YSh0eXBlLCB7XG4gICAgICBuZXdBdXRob3JpemVkOiB0b0J1ZmZlcihuZXdBdXRob3JpemVkUHVia2V5LnRvQnVmZmVyKCkpLFxuICAgICAgc3Rha2VBdXRob3JpemF0aW9uVHlwZTogc3Rha2VBdXRob3JpemF0aW9uVHlwZS5pbmRleCxcbiAgICAgIGF1dGhvcml0eVNlZWQ6IGF1dGhvcml0eVNlZWQsXG4gICAgICBhdXRob3JpdHlPd25lcjogdG9CdWZmZXIoYXV0aG9yaXR5T3duZXIudG9CdWZmZXIoKSlcbiAgICB9KTtcbiAgICBjb25zdCBrZXlzID0gW3tcbiAgICAgIHB1YmtleTogc3Rha2VQdWJrZXksXG4gICAgICBpc1NpZ25lcjogZmFsc2UsXG4gICAgICBpc1dyaXRhYmxlOiB0cnVlXG4gICAgfSwge1xuICAgICAgcHVia2V5OiBhdXRob3JpdHlCYXNlLFxuICAgICAgaXNTaWduZXI6IHRydWUsXG4gICAgICBpc1dyaXRhYmxlOiBmYWxzZVxuICAgIH0sIHtcbiAgICAgIHB1YmtleTogU1lTVkFSX0NMT0NLX1BVQktFWSxcbiAgICAgIGlzU2lnbmVyOiBmYWxzZSxcbiAgICAgIGlzV3JpdGFibGU6IGZhbHNlXG4gICAgfV07XG4gICAgaWYgKGN1c3RvZGlhblB1YmtleSkge1xuICAgICAga2V5cy5wdXNoKHtcbiAgICAgICAgcHVia2V5OiBjdXN0b2RpYW5QdWJrZXksXG4gICAgICAgIGlzU2lnbmVyOiB0cnVlLFxuICAgICAgICBpc1dyaXRhYmxlOiBmYWxzZVxuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBuZXcgVHJhbnNhY3Rpb24oKS5hZGQoe1xuICAgICAga2V5cyxcbiAgICAgIHByb2dyYW1JZDogdGhpcy5wcm9ncmFtSWQsXG4gICAgICBkYXRhXG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogQGludGVybmFsXG4gICAqL1xuICBzdGF0aWMgc3BsaXRJbnN0cnVjdGlvbihwYXJhbXMpIHtcbiAgICBjb25zdCB7XG4gICAgICBzdGFrZVB1YmtleSxcbiAgICAgIGF1dGhvcml6ZWRQdWJrZXksXG4gICAgICBzcGxpdFN0YWtlUHVia2V5LFxuICAgICAgbGFtcG9ydHNcbiAgICB9ID0gcGFyYW1zO1xuICAgIGNvbnN0IHR5cGUgPSBTVEFLRV9JTlNUUlVDVElPTl9MQVlPVVRTLlNwbGl0O1xuICAgIGNvbnN0IGRhdGEgPSBlbmNvZGVEYXRhKHR5cGUsIHtcbiAgICAgIGxhbXBvcnRzXG4gICAgfSk7XG4gICAgcmV0dXJuIG5ldyBUcmFuc2FjdGlvbkluc3RydWN0aW9uKHtcbiAgICAgIGtleXM6IFt7XG4gICAgICAgIHB1YmtleTogc3Rha2VQdWJrZXksXG4gICAgICAgIGlzU2lnbmVyOiBmYWxzZSxcbiAgICAgICAgaXNXcml0YWJsZTogdHJ1ZVxuICAgICAgfSwge1xuICAgICAgICBwdWJrZXk6IHNwbGl0U3Rha2VQdWJrZXksXG4gICAgICAgIGlzU2lnbmVyOiBmYWxzZSxcbiAgICAgICAgaXNXcml0YWJsZTogdHJ1ZVxuICAgICAgfSwge1xuICAgICAgICBwdWJrZXk6IGF1dGhvcml6ZWRQdWJrZXksXG4gICAgICAgIGlzU2lnbmVyOiB0cnVlLFxuICAgICAgICBpc1dyaXRhYmxlOiBmYWxzZVxuICAgICAgfV0sXG4gICAgICBwcm9ncmFtSWQ6IHRoaXMucHJvZ3JhbUlkLFxuICAgICAgZGF0YVxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEdlbmVyYXRlIGEgVHJhbnNhY3Rpb24gdGhhdCBzcGxpdHMgU3Rha2UgdG9rZW5zIGludG8gYW5vdGhlciBzdGFrZSBhY2NvdW50XG4gICAqL1xuICBzdGF0aWMgc3BsaXQocGFyYW1zLFxuICAvLyBDb21wdXRlIHRoZSBjb3N0IG9mIGFsbG9jYXRpbmcgdGhlIG5ldyBzdGFrZSBhY2NvdW50IGluIGxhbXBvcnRzXG4gIHJlbnRFeGVtcHRSZXNlcnZlKSB7XG4gICAgY29uc3QgdHJhbnNhY3Rpb24gPSBuZXcgVHJhbnNhY3Rpb24oKTtcbiAgICB0cmFuc2FjdGlvbi5hZGQoU3lzdGVtUHJvZ3JhbS5jcmVhdGVBY2NvdW50KHtcbiAgICAgIGZyb21QdWJrZXk6IHBhcmFtcy5hdXRob3JpemVkUHVia2V5LFxuICAgICAgbmV3QWNjb3VudFB1YmtleTogcGFyYW1zLnNwbGl0U3Rha2VQdWJrZXksXG4gICAgICBsYW1wb3J0czogcmVudEV4ZW1wdFJlc2VydmUsXG4gICAgICBzcGFjZTogdGhpcy5zcGFjZSxcbiAgICAgIHByb2dyYW1JZDogdGhpcy5wcm9ncmFtSWRcbiAgICB9KSk7XG4gICAgcmV0dXJuIHRyYW5zYWN0aW9uLmFkZCh0aGlzLnNwbGl0SW5zdHJ1Y3Rpb24ocGFyYW1zKSk7XG4gIH1cblxuICAvKipcbiAgICogR2VuZXJhdGUgYSBUcmFuc2FjdGlvbiB0aGF0IHNwbGl0cyBTdGFrZSB0b2tlbnMgaW50byBhbm90aGVyIGFjY291bnRcbiAgICogZGVyaXZlZCBmcm9tIGEgYmFzZSBwdWJsaWMga2V5IGFuZCBzZWVkXG4gICAqL1xuICBzdGF0aWMgc3BsaXRXaXRoU2VlZChwYXJhbXMsXG4gIC8vIElmIHRoaXMgc3Rha2UgYWNjb3VudCBpcyBuZXcsIGNvbXB1dGUgdGhlIGNvc3Qgb2YgYWxsb2NhdGluZyBpdCBpbiBsYW1wb3J0c1xuICByZW50RXhlbXB0UmVzZXJ2ZSkge1xuICAgIGNvbnN0IHtcbiAgICAgIHN0YWtlUHVia2V5LFxuICAgICAgYXV0aG9yaXplZFB1YmtleSxcbiAgICAgIHNwbGl0U3Rha2VQdWJrZXksXG4gICAgICBiYXNlUHVia2V5LFxuICAgICAgc2VlZCxcbiAgICAgIGxhbXBvcnRzXG4gICAgfSA9IHBhcmFtcztcbiAgICBjb25zdCB0cmFuc2FjdGlvbiA9IG5ldyBUcmFuc2FjdGlvbigpO1xuICAgIHRyYW5zYWN0aW9uLmFkZChTeXN0ZW1Qcm9ncmFtLmFsbG9jYXRlKHtcbiAgICAgIGFjY291bnRQdWJrZXk6IHNwbGl0U3Rha2VQdWJrZXksXG4gICAgICBiYXNlUHVia2V5LFxuICAgICAgc2VlZCxcbiAgICAgIHNwYWNlOiB0aGlzLnNwYWNlLFxuICAgICAgcHJvZ3JhbUlkOiB0aGlzLnByb2dyYW1JZFxuICAgIH0pKTtcbiAgICBpZiAocmVudEV4ZW1wdFJlc2VydmUgJiYgcmVudEV4ZW1wdFJlc2VydmUgPiAwKSB7XG4gICAgICB0cmFuc2FjdGlvbi5hZGQoU3lzdGVtUHJvZ3JhbS50cmFuc2Zlcih7XG4gICAgICAgIGZyb21QdWJrZXk6IHBhcmFtcy5hdXRob3JpemVkUHVia2V5LFxuICAgICAgICB0b1B1YmtleTogc3BsaXRTdGFrZVB1YmtleSxcbiAgICAgICAgbGFtcG9ydHM6IHJlbnRFeGVtcHRSZXNlcnZlXG4gICAgICB9KSk7XG4gICAgfVxuICAgIHJldHVybiB0cmFuc2FjdGlvbi5hZGQodGhpcy5zcGxpdEluc3RydWN0aW9uKHtcbiAgICAgIHN0YWtlUHVia2V5LFxuICAgICAgYXV0aG9yaXplZFB1YmtleSxcbiAgICAgIHNwbGl0U3Rha2VQdWJrZXksXG4gICAgICBsYW1wb3J0c1xuICAgIH0pKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZW5lcmF0ZSBhIFRyYW5zYWN0aW9uIHRoYXQgbWVyZ2VzIFN0YWtlIGFjY291bnRzLlxuICAgKi9cbiAgc3RhdGljIG1lcmdlKHBhcmFtcykge1xuICAgIGNvbnN0IHtcbiAgICAgIHN0YWtlUHVia2V5LFxuICAgICAgc291cmNlU3Rha2VQdWJLZXksXG4gICAgICBhdXRob3JpemVkUHVia2V5XG4gICAgfSA9IHBhcmFtcztcbiAgICBjb25zdCB0eXBlID0gU1RBS0VfSU5TVFJVQ1RJT05fTEFZT1VUUy5NZXJnZTtcbiAgICBjb25zdCBkYXRhID0gZW5jb2RlRGF0YSh0eXBlKTtcbiAgICByZXR1cm4gbmV3IFRyYW5zYWN0aW9uKCkuYWRkKHtcbiAgICAgIGtleXM6IFt7XG4gICAgICAgIHB1YmtleTogc3Rha2VQdWJrZXksXG4gICAgICAgIGlzU2lnbmVyOiBmYWxzZSxcbiAgICAgICAgaXNXcml0YWJsZTogdHJ1ZVxuICAgICAgfSwge1xuICAgICAgICBwdWJrZXk6IHNvdXJjZVN0YWtlUHViS2V5LFxuICAgICAgICBpc1NpZ25lcjogZmFsc2UsXG4gICAgICAgIGlzV3JpdGFibGU6IHRydWVcbiAgICAgIH0sIHtcbiAgICAgICAgcHVia2V5OiBTWVNWQVJfQ0xPQ0tfUFVCS0VZLFxuICAgICAgICBpc1NpZ25lcjogZmFsc2UsXG4gICAgICAgIGlzV3JpdGFibGU6IGZhbHNlXG4gICAgICB9LCB7XG4gICAgICAgIHB1YmtleTogU1lTVkFSX1NUQUtFX0hJU1RPUllfUFVCS0VZLFxuICAgICAgICBpc1NpZ25lcjogZmFsc2UsXG4gICAgICAgIGlzV3JpdGFibGU6IGZhbHNlXG4gICAgICB9LCB7XG4gICAgICAgIHB1YmtleTogYXV0aG9yaXplZFB1YmtleSxcbiAgICAgICAgaXNTaWduZXI6IHRydWUsXG4gICAgICAgIGlzV3JpdGFibGU6IGZhbHNlXG4gICAgICB9XSxcbiAgICAgIHByb2dyYW1JZDogdGhpcy5wcm9ncmFtSWQsXG4gICAgICBkYXRhXG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogR2VuZXJhdGUgYSBUcmFuc2FjdGlvbiB0aGF0IHdpdGhkcmF3cyBkZWFjdGl2YXRlZCBTdGFrZSB0b2tlbnMuXG4gICAqL1xuICBzdGF0aWMgd2l0aGRyYXcocGFyYW1zKSB7XG4gICAgY29uc3Qge1xuICAgICAgc3Rha2VQdWJrZXksXG4gICAgICBhdXRob3JpemVkUHVia2V5LFxuICAgICAgdG9QdWJrZXksXG4gICAgICBsYW1wb3J0cyxcbiAgICAgIGN1c3RvZGlhblB1YmtleVxuICAgIH0gPSBwYXJhbXM7XG4gICAgY29uc3QgdHlwZSA9IFNUQUtFX0lOU1RSVUNUSU9OX0xBWU9VVFMuV2l0aGRyYXc7XG4gICAgY29uc3QgZGF0YSA9IGVuY29kZURhdGEodHlwZSwge1xuICAgICAgbGFtcG9ydHNcbiAgICB9KTtcbiAgICBjb25zdCBrZXlzID0gW3tcbiAgICAgIHB1YmtleTogc3Rha2VQdWJrZXksXG4gICAgICBpc1NpZ25lcjogZmFsc2UsXG4gICAgICBpc1dyaXRhYmxlOiB0cnVlXG4gICAgfSwge1xuICAgICAgcHVia2V5OiB0b1B1YmtleSxcbiAgICAgIGlzU2lnbmVyOiBmYWxzZSxcbiAgICAgIGlzV3JpdGFibGU6IHRydWVcbiAgICB9LCB7XG4gICAgICBwdWJrZXk6IFNZU1ZBUl9DTE9DS19QVUJLRVksXG4gICAgICBpc1NpZ25lcjogZmFsc2UsXG4gICAgICBpc1dyaXRhYmxlOiBmYWxzZVxuICAgIH0sIHtcbiAgICAgIHB1YmtleTogU1lTVkFSX1NUQUtFX0hJU1RPUllfUFVCS0VZLFxuICAgICAgaXNTaWduZXI6IGZhbHNlLFxuICAgICAgaXNXcml0YWJsZTogZmFsc2VcbiAgICB9LCB7XG4gICAgICBwdWJrZXk6IGF1dGhvcml6ZWRQdWJrZXksXG4gICAgICBpc1NpZ25lcjogdHJ1ZSxcbiAgICAgIGlzV3JpdGFibGU6IGZhbHNlXG4gICAgfV07XG4gICAgaWYgKGN1c3RvZGlhblB1YmtleSkge1xuICAgICAga2V5cy5wdXNoKHtcbiAgICAgICAgcHVia2V5OiBjdXN0b2RpYW5QdWJrZXksXG4gICAgICAgIGlzU2lnbmVyOiB0cnVlLFxuICAgICAgICBpc1dyaXRhYmxlOiBmYWxzZVxuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBuZXcgVHJhbnNhY3Rpb24oKS5hZGQoe1xuICAgICAga2V5cyxcbiAgICAgIHByb2dyYW1JZDogdGhpcy5wcm9ncmFtSWQsXG4gICAgICBkYXRhXG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogR2VuZXJhdGUgYSBUcmFuc2FjdGlvbiB0aGF0IGRlYWN0aXZhdGVzIFN0YWtlIHRva2Vucy5cbiAgICovXG4gIHN0YXRpYyBkZWFjdGl2YXRlKHBhcmFtcykge1xuICAgIGNvbnN0IHtcbiAgICAgIHN0YWtlUHVia2V5LFxuICAgICAgYXV0aG9yaXplZFB1YmtleVxuICAgIH0gPSBwYXJhbXM7XG4gICAgY29uc3QgdHlwZSA9IFNUQUtFX0lOU1RSVUNUSU9OX0xBWU9VVFMuRGVhY3RpdmF0ZTtcbiAgICBjb25zdCBkYXRhID0gZW5jb2RlRGF0YSh0eXBlKTtcbiAgICByZXR1cm4gbmV3IFRyYW5zYWN0aW9uKCkuYWRkKHtcbiAgICAgIGtleXM6IFt7XG4gICAgICAgIHB1YmtleTogc3Rha2VQdWJrZXksXG4gICAgICAgIGlzU2lnbmVyOiBmYWxzZSxcbiAgICAgICAgaXNXcml0YWJsZTogdHJ1ZVxuICAgICAgfSwge1xuICAgICAgICBwdWJrZXk6IFNZU1ZBUl9DTE9DS19QVUJLRVksXG4gICAgICAgIGlzU2lnbmVyOiBmYWxzZSxcbiAgICAgICAgaXNXcml0YWJsZTogZmFsc2VcbiAgICAgIH0sIHtcbiAgICAgICAgcHVia2V5OiBhdXRob3JpemVkUHVia2V5LFxuICAgICAgICBpc1NpZ25lcjogdHJ1ZSxcbiAgICAgICAgaXNXcml0YWJsZTogZmFsc2VcbiAgICAgIH1dLFxuICAgICAgcHJvZ3JhbUlkOiB0aGlzLnByb2dyYW1JZCxcbiAgICAgIGRhdGFcbiAgICB9KTtcbiAgfVxufVxuU3Rha2VQcm9ncmFtLnByb2dyYW1JZCA9IG5ldyBQdWJsaWNLZXkoJ1N0YWtlMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTEnKTtcbi8qKlxuICogTWF4IHNwYWNlIG9mIGEgU3Rha2UgYWNjb3VudFxuICpcbiAqIFRoaXMgaXMgZ2VuZXJhdGVkIGZyb20gdGhlIHNvbGFuYS1zdGFrZS1wcm9ncmFtIFN0YWtlU3RhdGUgc3RydWN0IGFzXG4gKiBgU3Rha2VTdGF0ZVYyOjpzaXplX29mKClgOlxuICogaHR0cHM6Ly9kb2NzLnJzL3NvbGFuYS1zdGFrZS1wcm9ncmFtL2xhdGVzdC9zb2xhbmFfc3Rha2VfcHJvZ3JhbS9zdGFrZV9zdGF0ZS9lbnVtLlN0YWtlU3RhdGVWMi5odG1sXG4gKi9cblN0YWtlUHJvZ3JhbS5zcGFjZSA9IDIwMDtcblxuLyoqXG4gKiBWb3RlIGFjY291bnQgaW5mb1xuICovXG5jbGFzcyBWb3RlSW5pdCB7XG4gIC8qKiBbMCwgMTAwXSAqL1xuXG4gIGNvbnN0cnVjdG9yKG5vZGVQdWJrZXksIGF1dGhvcml6ZWRWb3RlciwgYXV0aG9yaXplZFdpdGhkcmF3ZXIsIGNvbW1pc3Npb24pIHtcbiAgICB0aGlzLm5vZGVQdWJrZXkgPSB2b2lkIDA7XG4gICAgdGhpcy5hdXRob3JpemVkVm90ZXIgPSB2b2lkIDA7XG4gICAgdGhpcy5hdXRob3JpemVkV2l0aGRyYXdlciA9IHZvaWQgMDtcbiAgICB0aGlzLmNvbW1pc3Npb24gPSB2b2lkIDA7XG4gICAgdGhpcy5ub2RlUHVia2V5ID0gbm9kZVB1YmtleTtcbiAgICB0aGlzLmF1dGhvcml6ZWRWb3RlciA9IGF1dGhvcml6ZWRWb3RlcjtcbiAgICB0aGlzLmF1dGhvcml6ZWRXaXRoZHJhd2VyID0gYXV0aG9yaXplZFdpdGhkcmF3ZXI7XG4gICAgdGhpcy5jb21taXNzaW9uID0gY29tbWlzc2lvbjtcbiAgfVxufVxuXG4vKipcbiAqIENyZWF0ZSB2b3RlIGFjY291bnQgdHJhbnNhY3Rpb24gcGFyYW1zXG4gKi9cblxuLyoqXG4gKiBJbml0aWFsaXplQWNjb3VudCBpbnN0cnVjdGlvbiBwYXJhbXNcbiAqL1xuXG4vKipcbiAqIEF1dGhvcml6ZSBpbnN0cnVjdGlvbiBwYXJhbXNcbiAqL1xuXG4vKipcbiAqIEF1dGhvcml6ZVdpdGhTZWVkIGluc3RydWN0aW9uIHBhcmFtc1xuICovXG5cbi8qKlxuICogV2l0aGRyYXcgZnJvbSB2b3RlIGFjY291bnQgdHJhbnNhY3Rpb24gcGFyYW1zXG4gKi9cblxuLyoqXG4gKiBVcGRhdGUgdmFsaWRhdG9yIGlkZW50aXR5IChub2RlIHB1YmtleSkgdm90ZSBhY2NvdW50IGluc3RydWN0aW9uIHBhcmFtcy5cbiAqL1xuXG4vKipcbiAqIFZvdGUgSW5zdHJ1Y3Rpb24gY2xhc3NcbiAqL1xuY2xhc3MgVm90ZUluc3RydWN0aW9uIHtcbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgY29uc3RydWN0b3IoKSB7fVxuXG4gIC8qKlxuICAgKiBEZWNvZGUgYSB2b3RlIGluc3RydWN0aW9uIGFuZCByZXRyaWV2ZSB0aGUgaW5zdHJ1Y3Rpb24gdHlwZS5cbiAgICovXG4gIHN0YXRpYyBkZWNvZGVJbnN0cnVjdGlvblR5cGUoaW5zdHJ1Y3Rpb24pIHtcbiAgICB0aGlzLmNoZWNrUHJvZ3JhbUlkKGluc3RydWN0aW9uLnByb2dyYW1JZCk7XG4gICAgY29uc3QgaW5zdHJ1Y3Rpb25UeXBlTGF5b3V0ID0gQnVmZmVyTGF5b3V0LnUzMignaW5zdHJ1Y3Rpb24nKTtcbiAgICBjb25zdCB0eXBlSW5kZXggPSBpbnN0cnVjdGlvblR5cGVMYXlvdXQuZGVjb2RlKGluc3RydWN0aW9uLmRhdGEpO1xuICAgIGxldCB0eXBlO1xuICAgIGZvciAoY29uc3QgW2l4VHlwZSwgbGF5b3V0XSBvZiBPYmplY3QuZW50cmllcyhWT1RFX0lOU1RSVUNUSU9OX0xBWU9VVFMpKSB7XG4gICAgICBpZiAobGF5b3V0LmluZGV4ID09IHR5cGVJbmRleCkge1xuICAgICAgICB0eXBlID0gaXhUeXBlO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKCF0eXBlKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0luc3RydWN0aW9uIHR5cGUgaW5jb3JyZWN0OyBub3QgYSBWb3RlSW5zdHJ1Y3Rpb24nKTtcbiAgICB9XG4gICAgcmV0dXJuIHR5cGU7XG4gIH1cblxuICAvKipcbiAgICogRGVjb2RlIGFuIGluaXRpYWxpemUgdm90ZSBpbnN0cnVjdGlvbiBhbmQgcmV0cmlldmUgdGhlIGluc3RydWN0aW9uIHBhcmFtcy5cbiAgICovXG4gIHN0YXRpYyBkZWNvZGVJbml0aWFsaXplQWNjb3VudChpbnN0cnVjdGlvbikge1xuICAgIHRoaXMuY2hlY2tQcm9ncmFtSWQoaW5zdHJ1Y3Rpb24ucHJvZ3JhbUlkKTtcbiAgICB0aGlzLmNoZWNrS2V5TGVuZ3RoKGluc3RydWN0aW9uLmtleXMsIDQpO1xuICAgIGNvbnN0IHtcbiAgICAgIHZvdGVJbml0XG4gICAgfSA9IGRlY29kZURhdGEkMShWT1RFX0lOU1RSVUNUSU9OX0xBWU9VVFMuSW5pdGlhbGl6ZUFjY291bnQsIGluc3RydWN0aW9uLmRhdGEpO1xuICAgIHJldHVybiB7XG4gICAgICB2b3RlUHVia2V5OiBpbnN0cnVjdGlvbi5rZXlzWzBdLnB1YmtleSxcbiAgICAgIG5vZGVQdWJrZXk6IGluc3RydWN0aW9uLmtleXNbM10ucHVia2V5LFxuICAgICAgdm90ZUluaXQ6IG5ldyBWb3RlSW5pdChuZXcgUHVibGljS2V5KHZvdGVJbml0Lm5vZGVQdWJrZXkpLCBuZXcgUHVibGljS2V5KHZvdGVJbml0LmF1dGhvcml6ZWRWb3RlciksIG5ldyBQdWJsaWNLZXkodm90ZUluaXQuYXV0aG9yaXplZFdpdGhkcmF3ZXIpLCB2b3RlSW5pdC5jb21taXNzaW9uKVxuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogRGVjb2RlIGFuIGF1dGhvcml6ZSBpbnN0cnVjdGlvbiBhbmQgcmV0cmlldmUgdGhlIGluc3RydWN0aW9uIHBhcmFtcy5cbiAgICovXG4gIHN0YXRpYyBkZWNvZGVBdXRob3JpemUoaW5zdHJ1Y3Rpb24pIHtcbiAgICB0aGlzLmNoZWNrUHJvZ3JhbUlkKGluc3RydWN0aW9uLnByb2dyYW1JZCk7XG4gICAgdGhpcy5jaGVja0tleUxlbmd0aChpbnN0cnVjdGlvbi5rZXlzLCAzKTtcbiAgICBjb25zdCB7XG4gICAgICBuZXdBdXRob3JpemVkLFxuICAgICAgdm90ZUF1dGhvcml6YXRpb25UeXBlXG4gICAgfSA9IGRlY29kZURhdGEkMShWT1RFX0lOU1RSVUNUSU9OX0xBWU9VVFMuQXV0aG9yaXplLCBpbnN0cnVjdGlvbi5kYXRhKTtcbiAgICByZXR1cm4ge1xuICAgICAgdm90ZVB1YmtleTogaW5zdHJ1Y3Rpb24ua2V5c1swXS5wdWJrZXksXG4gICAgICBhdXRob3JpemVkUHVia2V5OiBpbnN0cnVjdGlvbi5rZXlzWzJdLnB1YmtleSxcbiAgICAgIG5ld0F1dGhvcml6ZWRQdWJrZXk6IG5ldyBQdWJsaWNLZXkobmV3QXV0aG9yaXplZCksXG4gICAgICB2b3RlQXV0aG9yaXphdGlvblR5cGU6IHtcbiAgICAgICAgaW5kZXg6IHZvdGVBdXRob3JpemF0aW9uVHlwZVxuICAgICAgfVxuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogRGVjb2RlIGFuIGF1dGhvcml6ZSBpbnN0cnVjdGlvbiBhbmQgcmV0cmlldmUgdGhlIGluc3RydWN0aW9uIHBhcmFtcy5cbiAgICovXG4gIHN0YXRpYyBkZWNvZGVBdXRob3JpemVXaXRoU2VlZChpbnN0cnVjdGlvbikge1xuICAgIHRoaXMuY2hlY2tQcm9ncmFtSWQoaW5zdHJ1Y3Rpb24ucHJvZ3JhbUlkKTtcbiAgICB0aGlzLmNoZWNrS2V5TGVuZ3RoKGluc3RydWN0aW9uLmtleXMsIDMpO1xuICAgIGNvbnN0IHtcbiAgICAgIHZvdGVBdXRob3JpemVXaXRoU2VlZEFyZ3M6IHtcbiAgICAgICAgY3VycmVudEF1dGhvcml0eURlcml2ZWRLZXlPd25lclB1YmtleSxcbiAgICAgICAgY3VycmVudEF1dGhvcml0eURlcml2ZWRLZXlTZWVkLFxuICAgICAgICBuZXdBdXRob3JpemVkLFxuICAgICAgICB2b3RlQXV0aG9yaXphdGlvblR5cGVcbiAgICAgIH1cbiAgICB9ID0gZGVjb2RlRGF0YSQxKFZPVEVfSU5TVFJVQ1RJT05fTEFZT1VUUy5BdXRob3JpemVXaXRoU2VlZCwgaW5zdHJ1Y3Rpb24uZGF0YSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIGN1cnJlbnRBdXRob3JpdHlEZXJpdmVkS2V5QmFzZVB1YmtleTogaW5zdHJ1Y3Rpb24ua2V5c1syXS5wdWJrZXksXG4gICAgICBjdXJyZW50QXV0aG9yaXR5RGVyaXZlZEtleU93bmVyUHVia2V5OiBuZXcgUHVibGljS2V5KGN1cnJlbnRBdXRob3JpdHlEZXJpdmVkS2V5T3duZXJQdWJrZXkpLFxuICAgICAgY3VycmVudEF1dGhvcml0eURlcml2ZWRLZXlTZWVkOiBjdXJyZW50QXV0aG9yaXR5RGVyaXZlZEtleVNlZWQsXG4gICAgICBuZXdBdXRob3JpemVkUHVia2V5OiBuZXcgUHVibGljS2V5KG5ld0F1dGhvcml6ZWQpLFxuICAgICAgdm90ZUF1dGhvcml6YXRpb25UeXBlOiB7XG4gICAgICAgIGluZGV4OiB2b3RlQXV0aG9yaXphdGlvblR5cGVcbiAgICAgIH0sXG4gICAgICB2b3RlUHVia2V5OiBpbnN0cnVjdGlvbi5rZXlzWzBdLnB1YmtleVxuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogRGVjb2RlIGEgd2l0aGRyYXcgaW5zdHJ1Y3Rpb24gYW5kIHJldHJpZXZlIHRoZSBpbnN0cnVjdGlvbiBwYXJhbXMuXG4gICAqL1xuICBzdGF0aWMgZGVjb2RlV2l0aGRyYXcoaW5zdHJ1Y3Rpb24pIHtcbiAgICB0aGlzLmNoZWNrUHJvZ3JhbUlkKGluc3RydWN0aW9uLnByb2dyYW1JZCk7XG4gICAgdGhpcy5jaGVja0tleUxlbmd0aChpbnN0cnVjdGlvbi5rZXlzLCAzKTtcbiAgICBjb25zdCB7XG4gICAgICBsYW1wb3J0c1xuICAgIH0gPSBkZWNvZGVEYXRhJDEoVk9URV9JTlNUUlVDVElPTl9MQVlPVVRTLldpdGhkcmF3LCBpbnN0cnVjdGlvbi5kYXRhKTtcbiAgICByZXR1cm4ge1xuICAgICAgdm90ZVB1YmtleTogaW5zdHJ1Y3Rpb24ua2V5c1swXS5wdWJrZXksXG4gICAgICBhdXRob3JpemVkV2l0aGRyYXdlclB1YmtleTogaW5zdHJ1Y3Rpb24ua2V5c1syXS5wdWJrZXksXG4gICAgICBsYW1wb3J0cyxcbiAgICAgIHRvUHVia2V5OiBpbnN0cnVjdGlvbi5rZXlzWzFdLnB1YmtleVxuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogQGludGVybmFsXG4gICAqL1xuICBzdGF0aWMgY2hlY2tQcm9ncmFtSWQocHJvZ3JhbUlkKSB7XG4gICAgaWYgKCFwcm9ncmFtSWQuZXF1YWxzKFZvdGVQcm9ncmFtLnByb2dyYW1JZCkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBpbnN0cnVjdGlvbjsgcHJvZ3JhbUlkIGlzIG5vdCBWb3RlUHJvZ3JhbScpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIHN0YXRpYyBjaGVja0tleUxlbmd0aChrZXlzLCBleHBlY3RlZExlbmd0aCkge1xuICAgIGlmIChrZXlzLmxlbmd0aCA8IGV4cGVjdGVkTGVuZ3RoKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYGludmFsaWQgaW5zdHJ1Y3Rpb247IGZvdW5kICR7a2V5cy5sZW5ndGh9IGtleXMsIGV4cGVjdGVkIGF0IGxlYXN0ICR7ZXhwZWN0ZWRMZW5ndGh9YCk7XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogQW4gZW51bWVyYXRpb24gb2YgdmFsaWQgVm90ZUluc3RydWN0aW9uVHlwZSdzXG4gKi9cblxuLyoqIEBpbnRlcm5hbCAqL1xuXG5jb25zdCBWT1RFX0lOU1RSVUNUSU9OX0xBWU9VVFMgPSBPYmplY3QuZnJlZXplKHtcbiAgSW5pdGlhbGl6ZUFjY291bnQ6IHtcbiAgICBpbmRleDogMCxcbiAgICBsYXlvdXQ6IEJ1ZmZlckxheW91dC5zdHJ1Y3QoW0J1ZmZlckxheW91dC51MzIoJ2luc3RydWN0aW9uJyksIHZvdGVJbml0KCldKVxuICB9LFxuICBBdXRob3JpemU6IHtcbiAgICBpbmRleDogMSxcbiAgICBsYXlvdXQ6IEJ1ZmZlckxheW91dC5zdHJ1Y3QoW0J1ZmZlckxheW91dC51MzIoJ2luc3RydWN0aW9uJyksIHB1YmxpY0tleSgnbmV3QXV0aG9yaXplZCcpLCBCdWZmZXJMYXlvdXQudTMyKCd2b3RlQXV0aG9yaXphdGlvblR5cGUnKV0pXG4gIH0sXG4gIFdpdGhkcmF3OiB7XG4gICAgaW5kZXg6IDMsXG4gICAgbGF5b3V0OiBCdWZmZXJMYXlvdXQuc3RydWN0KFtCdWZmZXJMYXlvdXQudTMyKCdpbnN0cnVjdGlvbicpLCBCdWZmZXJMYXlvdXQubnM2NCgnbGFtcG9ydHMnKV0pXG4gIH0sXG4gIFVwZGF0ZVZhbGlkYXRvcklkZW50aXR5OiB7XG4gICAgaW5kZXg6IDQsXG4gICAgbGF5b3V0OiBCdWZmZXJMYXlvdXQuc3RydWN0KFtCdWZmZXJMYXlvdXQudTMyKCdpbnN0cnVjdGlvbicpXSlcbiAgfSxcbiAgQXV0aG9yaXplV2l0aFNlZWQ6IHtcbiAgICBpbmRleDogMTAsXG4gICAgbGF5b3V0OiBCdWZmZXJMYXlvdXQuc3RydWN0KFtCdWZmZXJMYXlvdXQudTMyKCdpbnN0cnVjdGlvbicpLCB2b3RlQXV0aG9yaXplV2l0aFNlZWRBcmdzKCldKVxuICB9XG59KTtcblxuLyoqXG4gKiBWb3RlQXV0aG9yaXplIHR5cGVcbiAqL1xuXG4vKipcbiAqIEFuIGVudW1lcmF0aW9uIG9mIHZhbGlkIFZvdGVBdXRob3JpemF0aW9uIGxheW91dHMuXG4gKi9cbmNvbnN0IFZvdGVBdXRob3JpemF0aW9uTGF5b3V0ID0gT2JqZWN0LmZyZWV6ZSh7XG4gIFZvdGVyOiB7XG4gICAgaW5kZXg6IDBcbiAgfSxcbiAgV2l0aGRyYXdlcjoge1xuICAgIGluZGV4OiAxXG4gIH1cbn0pO1xuXG4vKipcbiAqIEZhY3RvcnkgY2xhc3MgZm9yIHRyYW5zYWN0aW9ucyB0byBpbnRlcmFjdCB3aXRoIHRoZSBWb3RlIHByb2dyYW1cbiAqL1xuY2xhc3MgVm90ZVByb2dyYW0ge1xuICAvKipcbiAgICogQGludGVybmFsXG4gICAqL1xuICBjb25zdHJ1Y3RvcigpIHt9XG5cbiAgLyoqXG4gICAqIFB1YmxpYyBrZXkgdGhhdCBpZGVudGlmaWVzIHRoZSBWb3RlIHByb2dyYW1cbiAgICovXG5cbiAgLyoqXG4gICAqIEdlbmVyYXRlIGFuIEluaXRpYWxpemUgaW5zdHJ1Y3Rpb24uXG4gICAqL1xuICBzdGF0aWMgaW5pdGlhbGl6ZUFjY291bnQocGFyYW1zKSB7XG4gICAgY29uc3Qge1xuICAgICAgdm90ZVB1YmtleSxcbiAgICAgIG5vZGVQdWJrZXksXG4gICAgICB2b3RlSW5pdFxuICAgIH0gPSBwYXJhbXM7XG4gICAgY29uc3QgdHlwZSA9IFZPVEVfSU5TVFJVQ1RJT05fTEFZT1VUUy5Jbml0aWFsaXplQWNjb3VudDtcbiAgICBjb25zdCBkYXRhID0gZW5jb2RlRGF0YSh0eXBlLCB7XG4gICAgICB2b3RlSW5pdDoge1xuICAgICAgICBub2RlUHVia2V5OiB0b0J1ZmZlcih2b3RlSW5pdC5ub2RlUHVia2V5LnRvQnVmZmVyKCkpLFxuICAgICAgICBhdXRob3JpemVkVm90ZXI6IHRvQnVmZmVyKHZvdGVJbml0LmF1dGhvcml6ZWRWb3Rlci50b0J1ZmZlcigpKSxcbiAgICAgICAgYXV0aG9yaXplZFdpdGhkcmF3ZXI6IHRvQnVmZmVyKHZvdGVJbml0LmF1dGhvcml6ZWRXaXRoZHJhd2VyLnRvQnVmZmVyKCkpLFxuICAgICAgICBjb21taXNzaW9uOiB2b3RlSW5pdC5jb21taXNzaW9uXG4gICAgICB9XG4gICAgfSk7XG4gICAgY29uc3QgaW5zdHJ1Y3Rpb25EYXRhID0ge1xuICAgICAga2V5czogW3tcbiAgICAgICAgcHVia2V5OiB2b3RlUHVia2V5LFxuICAgICAgICBpc1NpZ25lcjogZmFsc2UsXG4gICAgICAgIGlzV3JpdGFibGU6IHRydWVcbiAgICAgIH0sIHtcbiAgICAgICAgcHVia2V5OiBTWVNWQVJfUkVOVF9QVUJLRVksXG4gICAgICAgIGlzU2lnbmVyOiBmYWxzZSxcbiAgICAgICAgaXNXcml0YWJsZTogZmFsc2VcbiAgICAgIH0sIHtcbiAgICAgICAgcHVia2V5OiBTWVNWQVJfQ0xPQ0tfUFVCS0VZLFxuICAgICAgICBpc1NpZ25lcjogZmFsc2UsXG4gICAgICAgIGlzV3JpdGFibGU6IGZhbHNlXG4gICAgICB9LCB7XG4gICAgICAgIHB1YmtleTogbm9kZVB1YmtleSxcbiAgICAgICAgaXNTaWduZXI6IHRydWUsXG4gICAgICAgIGlzV3JpdGFibGU6IGZhbHNlXG4gICAgICB9XSxcbiAgICAgIHByb2dyYW1JZDogdGhpcy5wcm9ncmFtSWQsXG4gICAgICBkYXRhXG4gICAgfTtcbiAgICByZXR1cm4gbmV3IFRyYW5zYWN0aW9uSW5zdHJ1Y3Rpb24oaW5zdHJ1Y3Rpb25EYXRhKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZW5lcmF0ZSBhIHRyYW5zYWN0aW9uIHRoYXQgY3JlYXRlcyBhIG5ldyBWb3RlIGFjY291bnQuXG4gICAqL1xuICBzdGF0aWMgY3JlYXRlQWNjb3VudChwYXJhbXMpIHtcbiAgICBjb25zdCB0cmFuc2FjdGlvbiA9IG5ldyBUcmFuc2FjdGlvbigpO1xuICAgIHRyYW5zYWN0aW9uLmFkZChTeXN0ZW1Qcm9ncmFtLmNyZWF0ZUFjY291bnQoe1xuICAgICAgZnJvbVB1YmtleTogcGFyYW1zLmZyb21QdWJrZXksXG4gICAgICBuZXdBY2NvdW50UHVia2V5OiBwYXJhbXMudm90ZVB1YmtleSxcbiAgICAgIGxhbXBvcnRzOiBwYXJhbXMubGFtcG9ydHMsXG4gICAgICBzcGFjZTogdGhpcy5zcGFjZSxcbiAgICAgIHByb2dyYW1JZDogdGhpcy5wcm9ncmFtSWRcbiAgICB9KSk7XG4gICAgcmV0dXJuIHRyYW5zYWN0aW9uLmFkZCh0aGlzLmluaXRpYWxpemVBY2NvdW50KHtcbiAgICAgIHZvdGVQdWJrZXk6IHBhcmFtcy52b3RlUHVia2V5LFxuICAgICAgbm9kZVB1YmtleTogcGFyYW1zLnZvdGVJbml0Lm5vZGVQdWJrZXksXG4gICAgICB2b3RlSW5pdDogcGFyYW1zLnZvdGVJbml0XG4gICAgfSkpO1xuICB9XG5cbiAgLyoqXG4gICAqIEdlbmVyYXRlIGEgdHJhbnNhY3Rpb24gdGhhdCBhdXRob3JpemVzIGEgbmV3IFZvdGVyIG9yIFdpdGhkcmF3ZXIgb24gdGhlIFZvdGUgYWNjb3VudC5cbiAgICovXG4gIHN0YXRpYyBhdXRob3JpemUocGFyYW1zKSB7XG4gICAgY29uc3Qge1xuICAgICAgdm90ZVB1YmtleSxcbiAgICAgIGF1dGhvcml6ZWRQdWJrZXksXG4gICAgICBuZXdBdXRob3JpemVkUHVia2V5LFxuICAgICAgdm90ZUF1dGhvcml6YXRpb25UeXBlXG4gICAgfSA9IHBhcmFtcztcbiAgICBjb25zdCB0eXBlID0gVk9URV9JTlNUUlVDVElPTl9MQVlPVVRTLkF1dGhvcml6ZTtcbiAgICBjb25zdCBkYXRhID0gZW5jb2RlRGF0YSh0eXBlLCB7XG4gICAgICBuZXdBdXRob3JpemVkOiB0b0J1ZmZlcihuZXdBdXRob3JpemVkUHVia2V5LnRvQnVmZmVyKCkpLFxuICAgICAgdm90ZUF1dGhvcml6YXRpb25UeXBlOiB2b3RlQXV0aG9yaXphdGlvblR5cGUuaW5kZXhcbiAgICB9KTtcbiAgICBjb25zdCBrZXlzID0gW3tcbiAgICAgIHB1YmtleTogdm90ZVB1YmtleSxcbiAgICAgIGlzU2lnbmVyOiBmYWxzZSxcbiAgICAgIGlzV3JpdGFibGU6IHRydWVcbiAgICB9LCB7XG4gICAgICBwdWJrZXk6IFNZU1ZBUl9DTE9DS19QVUJLRVksXG4gICAgICBpc1NpZ25lcjogZmFsc2UsXG4gICAgICBpc1dyaXRhYmxlOiBmYWxzZVxuICAgIH0sIHtcbiAgICAgIHB1YmtleTogYXV0aG9yaXplZFB1YmtleSxcbiAgICAgIGlzU2lnbmVyOiB0cnVlLFxuICAgICAgaXNXcml0YWJsZTogZmFsc2VcbiAgICB9XTtcbiAgICByZXR1cm4gbmV3IFRyYW5zYWN0aW9uKCkuYWRkKHtcbiAgICAgIGtleXMsXG4gICAgICBwcm9ncmFtSWQ6IHRoaXMucHJvZ3JhbUlkLFxuICAgICAgZGF0YVxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEdlbmVyYXRlIGEgdHJhbnNhY3Rpb24gdGhhdCBhdXRob3JpemVzIGEgbmV3IFZvdGVyIG9yIFdpdGhkcmF3ZXIgb24gdGhlIFZvdGUgYWNjb3VudFxuICAgKiB3aGVyZSB0aGUgY3VycmVudCBWb3RlciBvciBXaXRoZHJhd2VyIGF1dGhvcml0eSBpcyBhIGRlcml2ZWQga2V5LlxuICAgKi9cbiAgc3RhdGljIGF1dGhvcml6ZVdpdGhTZWVkKHBhcmFtcykge1xuICAgIGNvbnN0IHtcbiAgICAgIGN1cnJlbnRBdXRob3JpdHlEZXJpdmVkS2V5QmFzZVB1YmtleSxcbiAgICAgIGN1cnJlbnRBdXRob3JpdHlEZXJpdmVkS2V5T3duZXJQdWJrZXksXG4gICAgICBjdXJyZW50QXV0aG9yaXR5RGVyaXZlZEtleVNlZWQsXG4gICAgICBuZXdBdXRob3JpemVkUHVia2V5LFxuICAgICAgdm90ZUF1dGhvcml6YXRpb25UeXBlLFxuICAgICAgdm90ZVB1YmtleVxuICAgIH0gPSBwYXJhbXM7XG4gICAgY29uc3QgdHlwZSA9IFZPVEVfSU5TVFJVQ1RJT05fTEFZT1VUUy5BdXRob3JpemVXaXRoU2VlZDtcbiAgICBjb25zdCBkYXRhID0gZW5jb2RlRGF0YSh0eXBlLCB7XG4gICAgICB2b3RlQXV0aG9yaXplV2l0aFNlZWRBcmdzOiB7XG4gICAgICAgIGN1cnJlbnRBdXRob3JpdHlEZXJpdmVkS2V5T3duZXJQdWJrZXk6IHRvQnVmZmVyKGN1cnJlbnRBdXRob3JpdHlEZXJpdmVkS2V5T3duZXJQdWJrZXkudG9CdWZmZXIoKSksXG4gICAgICAgIGN1cnJlbnRBdXRob3JpdHlEZXJpdmVkS2V5U2VlZDogY3VycmVudEF1dGhvcml0eURlcml2ZWRLZXlTZWVkLFxuICAgICAgICBuZXdBdXRob3JpemVkOiB0b0J1ZmZlcihuZXdBdXRob3JpemVkUHVia2V5LnRvQnVmZmVyKCkpLFxuICAgICAgICB2b3RlQXV0aG9yaXphdGlvblR5cGU6IHZvdGVBdXRob3JpemF0aW9uVHlwZS5pbmRleFxuICAgICAgfVxuICAgIH0pO1xuICAgIGNvbnN0IGtleXMgPSBbe1xuICAgICAgcHVia2V5OiB2b3RlUHVia2V5LFxuICAgICAgaXNTaWduZXI6IGZhbHNlLFxuICAgICAgaXNXcml0YWJsZTogdHJ1ZVxuICAgIH0sIHtcbiAgICAgIHB1YmtleTogU1lTVkFSX0NMT0NLX1BVQktFWSxcbiAgICAgIGlzU2lnbmVyOiBmYWxzZSxcbiAgICAgIGlzV3JpdGFibGU6IGZhbHNlXG4gICAgfSwge1xuICAgICAgcHVia2V5OiBjdXJyZW50QXV0aG9yaXR5RGVyaXZlZEtleUJhc2VQdWJrZXksXG4gICAgICBpc1NpZ25lcjogdHJ1ZSxcbiAgICAgIGlzV3JpdGFibGU6IGZhbHNlXG4gICAgfV07XG4gICAgcmV0dXJuIG5ldyBUcmFuc2FjdGlvbigpLmFkZCh7XG4gICAgICBrZXlzLFxuICAgICAgcHJvZ3JhbUlkOiB0aGlzLnByb2dyYW1JZCxcbiAgICAgIGRhdGFcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZW5lcmF0ZSBhIHRyYW5zYWN0aW9uIHRvIHdpdGhkcmF3IGZyb20gYSBWb3RlIGFjY291bnQuXG4gICAqL1xuICBzdGF0aWMgd2l0aGRyYXcocGFyYW1zKSB7XG4gICAgY29uc3Qge1xuICAgICAgdm90ZVB1YmtleSxcbiAgICAgIGF1dGhvcml6ZWRXaXRoZHJhd2VyUHVia2V5LFxuICAgICAgbGFtcG9ydHMsXG4gICAgICB0b1B1YmtleVxuICAgIH0gPSBwYXJhbXM7XG4gICAgY29uc3QgdHlwZSA9IFZPVEVfSU5TVFJVQ1RJT05fTEFZT1VUUy5XaXRoZHJhdztcbiAgICBjb25zdCBkYXRhID0gZW5jb2RlRGF0YSh0eXBlLCB7XG4gICAgICBsYW1wb3J0c1xuICAgIH0pO1xuICAgIGNvbnN0IGtleXMgPSBbe1xuICAgICAgcHVia2V5OiB2b3RlUHVia2V5LFxuICAgICAgaXNTaWduZXI6IGZhbHNlLFxuICAgICAgaXNXcml0YWJsZTogdHJ1ZVxuICAgIH0sIHtcbiAgICAgIHB1YmtleTogdG9QdWJrZXksXG4gICAgICBpc1NpZ25lcjogZmFsc2UsXG4gICAgICBpc1dyaXRhYmxlOiB0cnVlXG4gICAgfSwge1xuICAgICAgcHVia2V5OiBhdXRob3JpemVkV2l0aGRyYXdlclB1YmtleSxcbiAgICAgIGlzU2lnbmVyOiB0cnVlLFxuICAgICAgaXNXcml0YWJsZTogZmFsc2VcbiAgICB9XTtcbiAgICByZXR1cm4gbmV3IFRyYW5zYWN0aW9uKCkuYWRkKHtcbiAgICAgIGtleXMsXG4gICAgICBwcm9ncmFtSWQ6IHRoaXMucHJvZ3JhbUlkLFxuICAgICAgZGF0YVxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEdlbmVyYXRlIGEgdHJhbnNhY3Rpb24gdG8gd2l0aGRyYXcgc2FmZWx5IGZyb20gYSBWb3RlIGFjY291bnQuXG4gICAqXG4gICAqIFRoaXMgZnVuY3Rpb24gd2FzIGNyZWF0ZWQgYXMgYSBzYWZlZ3VhcmQgZm9yIHZvdGUgYWNjb3VudHMgcnVubmluZyB2YWxpZGF0b3JzLCBgc2FmZVdpdGhkcmF3YFxuICAgKiBjaGVja3MgdGhhdCB0aGUgd2l0aGRyYXcgYW1vdW50IHdpbGwgbm90IGV4Y2VlZCB0aGUgc3BlY2lmaWVkIGJhbGFuY2Ugd2hpbGUgbGVhdmluZyBlbm91Z2ggbGVmdFxuICAgKiB0byBjb3ZlciByZW50LiBJZiB5b3Ugd2lzaCB0byBjbG9zZSB0aGUgdm90ZSBhY2NvdW50IGJ5IHdpdGhkcmF3aW5nIHRoZSBmdWxsIGFtb3VudCwgY2FsbCB0aGVcbiAgICogYHdpdGhkcmF3YCBtZXRob2QgZGlyZWN0bHkuXG4gICAqL1xuICBzdGF0aWMgc2FmZVdpdGhkcmF3KHBhcmFtcywgY3VycmVudFZvdGVBY2NvdW50QmFsYW5jZSwgcmVudEV4ZW1wdE1pbmltdW0pIHtcbiAgICBpZiAocGFyYW1zLmxhbXBvcnRzID4gY3VycmVudFZvdGVBY2NvdW50QmFsYW5jZSAtIHJlbnRFeGVtcHRNaW5pbXVtKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1dpdGhkcmF3IHdpbGwgbGVhdmUgdm90ZSBhY2NvdW50IHdpdGggaW5zdWZmaWNpZW50IGZ1bmRzLicpO1xuICAgIH1cbiAgICByZXR1cm4gVm90ZVByb2dyYW0ud2l0aGRyYXcocGFyYW1zKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZW5lcmF0ZSBhIHRyYW5zYWN0aW9uIHRvIHVwZGF0ZSB0aGUgdmFsaWRhdG9yIGlkZW50aXR5IChub2RlIHB1YmtleSkgb2YgYSBWb3RlIGFjY291bnQuXG4gICAqL1xuICBzdGF0aWMgdXBkYXRlVmFsaWRhdG9ySWRlbnRpdHkocGFyYW1zKSB7XG4gICAgY29uc3Qge1xuICAgICAgdm90ZVB1YmtleSxcbiAgICAgIGF1dGhvcml6ZWRXaXRoZHJhd2VyUHVia2V5LFxuICAgICAgbm9kZVB1YmtleVxuICAgIH0gPSBwYXJhbXM7XG4gICAgY29uc3QgdHlwZSA9IFZPVEVfSU5TVFJVQ1RJT05fTEFZT1VUUy5VcGRhdGVWYWxpZGF0b3JJZGVudGl0eTtcbiAgICBjb25zdCBkYXRhID0gZW5jb2RlRGF0YSh0eXBlKTtcbiAgICBjb25zdCBrZXlzID0gW3tcbiAgICAgIHB1YmtleTogdm90ZVB1YmtleSxcbiAgICAgIGlzU2lnbmVyOiBmYWxzZSxcbiAgICAgIGlzV3JpdGFibGU6IHRydWVcbiAgICB9LCB7XG4gICAgICBwdWJrZXk6IG5vZGVQdWJrZXksXG4gICAgICBpc1NpZ25lcjogdHJ1ZSxcbiAgICAgIGlzV3JpdGFibGU6IGZhbHNlXG4gICAgfSwge1xuICAgICAgcHVia2V5OiBhdXRob3JpemVkV2l0aGRyYXdlclB1YmtleSxcbiAgICAgIGlzU2lnbmVyOiB0cnVlLFxuICAgICAgaXNXcml0YWJsZTogZmFsc2VcbiAgICB9XTtcbiAgICByZXR1cm4gbmV3IFRyYW5zYWN0aW9uKCkuYWRkKHtcbiAgICAgIGtleXMsXG4gICAgICBwcm9ncmFtSWQ6IHRoaXMucHJvZ3JhbUlkLFxuICAgICAgZGF0YVxuICAgIH0pO1xuICB9XG59XG5Wb3RlUHJvZ3JhbS5wcm9ncmFtSWQgPSBuZXcgUHVibGljS2V5KCdWb3RlMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExJyk7XG4vKipcbiAqIE1heCBzcGFjZSBvZiBhIFZvdGUgYWNjb3VudFxuICpcbiAqIFRoaXMgaXMgZ2VuZXJhdGVkIGZyb20gdGhlIHNvbGFuYS12b3RlLXByb2dyYW0gVm90ZVN0YXRlIHN0cnVjdCBhc1xuICogYFZvdGVTdGF0ZTo6c2l6ZV9vZigpYDpcbiAqIGh0dHBzOi8vZG9jcy5ycy9zb2xhbmEtdm90ZS1wcm9ncmFtLzEuOS41L3NvbGFuYV92b3RlX3Byb2dyYW0vdm90ZV9zdGF0ZS9zdHJ1Y3QuVm90ZVN0YXRlLmh0bWwjbWV0aG9kLnNpemVfb2ZcbiAqXG4gKiBLRUVQIElOIFNZTkMgV0lUSCBgVm90ZVN0YXRlOjpzaXplX29mKClgIGluIGh0dHBzOi8vZ2l0aHViLmNvbS9zb2xhbmEtbGFicy9zb2xhbmEvYmxvYi9hNDc0Y2IyNGI5MjM4ZjVlZGNjOTgyZjY1YzBiMzdkNGExMDQ2ZjdlL3Nkay9wcm9ncmFtL3NyYy92b3RlL3N0YXRlL21vZC5ycyNMMzQwLUwzNDJcbiAqL1xuVm90ZVByb2dyYW0uc3BhY2UgPSAzNzYyO1xuXG5jb25zdCBWQUxJREFUT1JfSU5GT19LRVkgPSBuZXcgUHVibGljS2V5KCdWYTFpZGF0b3IxbmZvMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExJyk7XG5cbi8qKlxuICogQGludGVybmFsXG4gKi9cblxuLyoqXG4gKiBJbmZvIHVzZWQgdG8gaWRlbnRpdHkgdmFsaWRhdG9ycy5cbiAqL1xuXG5jb25zdCBJbmZvU3RyaW5nID0gdHlwZSh7XG4gIG5hbWU6IHN0cmluZygpLFxuICB3ZWJzaXRlOiBvcHRpb25hbChzdHJpbmcoKSksXG4gIGRldGFpbHM6IG9wdGlvbmFsKHN0cmluZygpKSxcbiAga2V5YmFzZVVzZXJuYW1lOiBvcHRpb25hbChzdHJpbmcoKSlcbn0pO1xuXG4vKipcbiAqIFZhbGlkYXRvckluZm8gY2xhc3NcbiAqL1xuY2xhc3MgVmFsaWRhdG9ySW5mbyB7XG4gIC8qKlxuICAgKiBDb25zdHJ1Y3QgYSB2YWxpZCBWYWxpZGF0b3JJbmZvXG4gICAqXG4gICAqIEBwYXJhbSBrZXkgdmFsaWRhdG9yIHB1YmxpYyBrZXlcbiAgICogQHBhcmFtIGluZm8gdmFsaWRhdG9yIGluZm9ybWF0aW9uXG4gICAqL1xuICBjb25zdHJ1Y3RvcihrZXksIGluZm8pIHtcbiAgICAvKipcbiAgICAgKiB2YWxpZGF0b3IgcHVibGljIGtleVxuICAgICAqL1xuICAgIHRoaXMua2V5ID0gdm9pZCAwO1xuICAgIC8qKlxuICAgICAqIHZhbGlkYXRvciBpbmZvcm1hdGlvblxuICAgICAqL1xuICAgIHRoaXMuaW5mbyA9IHZvaWQgMDtcbiAgICB0aGlzLmtleSA9IGtleTtcbiAgICB0aGlzLmluZm8gPSBpbmZvO1xuICB9XG5cbiAgLyoqXG4gICAqIERlc2VyaWFsaXplIFZhbGlkYXRvckluZm8gZnJvbSB0aGUgY29uZmlnIGFjY291bnQgZGF0YS4gRXhhY3RseSB0d28gY29uZmlnXG4gICAqIGtleXMgYXJlIHJlcXVpcmVkIGluIHRoZSBkYXRhLlxuICAgKlxuICAgKiBAcGFyYW0gYnVmZmVyIGNvbmZpZyBhY2NvdW50IGRhdGFcbiAgICogQHJldHVybiBudWxsIGlmIGluZm8gd2FzIG5vdCBmb3VuZFxuICAgKi9cbiAgc3RhdGljIGZyb21Db25maWdEYXRhKGJ1ZmZlcikge1xuICAgIGxldCBieXRlQXJyYXkgPSBbLi4uYnVmZmVyXTtcbiAgICBjb25zdCBjb25maWdLZXlDb3VudCA9IGRlY29kZUxlbmd0aChieXRlQXJyYXkpO1xuICAgIGlmIChjb25maWdLZXlDb3VudCAhPT0gMikgcmV0dXJuIG51bGw7XG4gICAgY29uc3QgY29uZmlnS2V5cyA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgMjsgaSsrKSB7XG4gICAgICBjb25zdCBwdWJsaWNLZXkgPSBuZXcgUHVibGljS2V5KGd1YXJkZWRTcGxpY2UoYnl0ZUFycmF5LCAwLCBQVUJMSUNfS0VZX0xFTkdUSCkpO1xuICAgICAgY29uc3QgaXNTaWduZXIgPSBndWFyZGVkU2hpZnQoYnl0ZUFycmF5KSA9PT0gMTtcbiAgICAgIGNvbmZpZ0tleXMucHVzaCh7XG4gICAgICAgIHB1YmxpY0tleSxcbiAgICAgICAgaXNTaWduZXJcbiAgICAgIH0pO1xuICAgIH1cbiAgICBpZiAoY29uZmlnS2V5c1swXS5wdWJsaWNLZXkuZXF1YWxzKFZBTElEQVRPUl9JTkZPX0tFWSkpIHtcbiAgICAgIGlmIChjb25maWdLZXlzWzFdLmlzU2lnbmVyKSB7XG4gICAgICAgIGNvbnN0IHJhd0luZm8gPSBydXN0U3RyaW5nKCkuZGVjb2RlKEJ1ZmZlci5mcm9tKGJ5dGVBcnJheSkpO1xuICAgICAgICBjb25zdCBpbmZvID0gSlNPTi5wYXJzZShyYXdJbmZvKTtcbiAgICAgICAgYXNzZXJ0JDEoaW5mbywgSW5mb1N0cmluZyk7XG4gICAgICAgIHJldHVybiBuZXcgVmFsaWRhdG9ySW5mbyhjb25maWdLZXlzWzFdLnB1YmxpY0tleSwgaW5mbyk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9XG59XG5cbmNvbnN0IFZPVEVfUFJPR1JBTV9JRCA9IG5ldyBQdWJsaWNLZXkoJ1ZvdGUxMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTEnKTtcblxuLyoqXG4gKiBIaXN0b3J5IG9mIGhvdyBtYW55IGNyZWRpdHMgZWFybmVkIGJ5IHRoZSBlbmQgb2YgZWFjaCBlcG9jaFxuICovXG5cbi8qKlxuICogU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9zb2xhbmEtbGFicy9zb2xhbmEvYmxvYi84YTEyZWQwMjljZmEzOGQ0YTQ1NDAwOTE2YzI0NjNmYjgyYmJlYzhjL3Byb2dyYW1zL3ZvdGVfYXBpL3NyYy92b3RlX3N0YXRlLnJzI0w2OC1MODhcbiAqXG4gKiBAaW50ZXJuYWxcbiAqL1xuY29uc3QgVm90ZUFjY291bnRMYXlvdXQgPSBCdWZmZXJMYXlvdXQuc3RydWN0KFtwdWJsaWNLZXkoJ25vZGVQdWJrZXknKSwgcHVibGljS2V5KCdhdXRob3JpemVkV2l0aGRyYXdlcicpLCBCdWZmZXJMYXlvdXQudTgoJ2NvbW1pc3Npb24nKSwgQnVmZmVyTGF5b3V0Lm51NjQoKSxcbi8vIHZvdGVzLmxlbmd0aFxuQnVmZmVyTGF5b3V0LnNlcShCdWZmZXJMYXlvdXQuc3RydWN0KFtCdWZmZXJMYXlvdXQubnU2NCgnc2xvdCcpLCBCdWZmZXJMYXlvdXQudTMyKCdjb25maXJtYXRpb25Db3VudCcpXSksIEJ1ZmZlckxheW91dC5vZmZzZXQoQnVmZmVyTGF5b3V0LnUzMigpLCAtOCksICd2b3RlcycpLCBCdWZmZXJMYXlvdXQudTgoJ3Jvb3RTbG90VmFsaWQnKSwgQnVmZmVyTGF5b3V0Lm51NjQoJ3Jvb3RTbG90JyksIEJ1ZmZlckxheW91dC5udTY0KCksXG4vLyBhdXRob3JpemVkVm90ZXJzLmxlbmd0aFxuQnVmZmVyTGF5b3V0LnNlcShCdWZmZXJMYXlvdXQuc3RydWN0KFtCdWZmZXJMYXlvdXQubnU2NCgnZXBvY2gnKSwgcHVibGljS2V5KCdhdXRob3JpemVkVm90ZXInKV0pLCBCdWZmZXJMYXlvdXQub2Zmc2V0KEJ1ZmZlckxheW91dC51MzIoKSwgLTgpLCAnYXV0aG9yaXplZFZvdGVycycpLCBCdWZmZXJMYXlvdXQuc3RydWN0KFtCdWZmZXJMYXlvdXQuc2VxKEJ1ZmZlckxheW91dC5zdHJ1Y3QoW3B1YmxpY0tleSgnYXV0aG9yaXplZFB1YmtleScpLCBCdWZmZXJMYXlvdXQubnU2NCgnZXBvY2hPZkxhc3RBdXRob3JpemVkU3dpdGNoJyksIEJ1ZmZlckxheW91dC5udTY0KCd0YXJnZXRFcG9jaCcpXSksIDMyLCAnYnVmJyksIEJ1ZmZlckxheW91dC5udTY0KCdpZHgnKSwgQnVmZmVyTGF5b3V0LnU4KCdpc0VtcHR5JyldLCAncHJpb3JWb3RlcnMnKSwgQnVmZmVyTGF5b3V0Lm51NjQoKSxcbi8vIGVwb2NoQ3JlZGl0cy5sZW5ndGhcbkJ1ZmZlckxheW91dC5zZXEoQnVmZmVyTGF5b3V0LnN0cnVjdChbQnVmZmVyTGF5b3V0Lm51NjQoJ2Vwb2NoJyksIEJ1ZmZlckxheW91dC5udTY0KCdjcmVkaXRzJyksIEJ1ZmZlckxheW91dC5udTY0KCdwcmV2Q3JlZGl0cycpXSksIEJ1ZmZlckxheW91dC5vZmZzZXQoQnVmZmVyTGF5b3V0LnUzMigpLCAtOCksICdlcG9jaENyZWRpdHMnKSwgQnVmZmVyTGF5b3V0LnN0cnVjdChbQnVmZmVyTGF5b3V0Lm51NjQoJ3Nsb3QnKSwgQnVmZmVyTGF5b3V0Lm51NjQoJ3RpbWVzdGFtcCcpXSwgJ2xhc3RUaW1lc3RhbXAnKV0pO1xuLyoqXG4gKiBWb3RlQWNjb3VudCBjbGFzc1xuICovXG5jbGFzcyBWb3RlQWNjb3VudCB7XG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIGNvbnN0cnVjdG9yKGFyZ3MpIHtcbiAgICB0aGlzLm5vZGVQdWJrZXkgPSB2b2lkIDA7XG4gICAgdGhpcy5hdXRob3JpemVkV2l0aGRyYXdlciA9IHZvaWQgMDtcbiAgICB0aGlzLmNvbW1pc3Npb24gPSB2b2lkIDA7XG4gICAgdGhpcy5yb290U2xvdCA9IHZvaWQgMDtcbiAgICB0aGlzLnZvdGVzID0gdm9pZCAwO1xuICAgIHRoaXMuYXV0aG9yaXplZFZvdGVycyA9IHZvaWQgMDtcbiAgICB0aGlzLnByaW9yVm90ZXJzID0gdm9pZCAwO1xuICAgIHRoaXMuZXBvY2hDcmVkaXRzID0gdm9pZCAwO1xuICAgIHRoaXMubGFzdFRpbWVzdGFtcCA9IHZvaWQgMDtcbiAgICB0aGlzLm5vZGVQdWJrZXkgPSBhcmdzLm5vZGVQdWJrZXk7XG4gICAgdGhpcy5hdXRob3JpemVkV2l0aGRyYXdlciA9IGFyZ3MuYXV0aG9yaXplZFdpdGhkcmF3ZXI7XG4gICAgdGhpcy5jb21taXNzaW9uID0gYXJncy5jb21taXNzaW9uO1xuICAgIHRoaXMucm9vdFNsb3QgPSBhcmdzLnJvb3RTbG90O1xuICAgIHRoaXMudm90ZXMgPSBhcmdzLnZvdGVzO1xuICAgIHRoaXMuYXV0aG9yaXplZFZvdGVycyA9IGFyZ3MuYXV0aG9yaXplZFZvdGVycztcbiAgICB0aGlzLnByaW9yVm90ZXJzID0gYXJncy5wcmlvclZvdGVycztcbiAgICB0aGlzLmVwb2NoQ3JlZGl0cyA9IGFyZ3MuZXBvY2hDcmVkaXRzO1xuICAgIHRoaXMubGFzdFRpbWVzdGFtcCA9IGFyZ3MubGFzdFRpbWVzdGFtcDtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZXNlcmlhbGl6ZSBWb3RlQWNjb3VudCBmcm9tIHRoZSBhY2NvdW50IGRhdGEuXG4gICAqXG4gICAqIEBwYXJhbSBidWZmZXIgYWNjb3VudCBkYXRhXG4gICAqIEByZXR1cm4gVm90ZUFjY291bnRcbiAgICovXG4gIHN0YXRpYyBmcm9tQWNjb3VudERhdGEoYnVmZmVyKSB7XG4gICAgY29uc3QgdmVyc2lvbk9mZnNldCA9IDQ7XG4gICAgY29uc3QgdmEgPSBWb3RlQWNjb3VudExheW91dC5kZWNvZGUodG9CdWZmZXIoYnVmZmVyKSwgdmVyc2lvbk9mZnNldCk7XG4gICAgbGV0IHJvb3RTbG90ID0gdmEucm9vdFNsb3Q7XG4gICAgaWYgKCF2YS5yb290U2xvdFZhbGlkKSB7XG4gICAgICByb290U2xvdCA9IG51bGw7XG4gICAgfVxuICAgIHJldHVybiBuZXcgVm90ZUFjY291bnQoe1xuICAgICAgbm9kZVB1YmtleTogbmV3IFB1YmxpY0tleSh2YS5ub2RlUHVia2V5KSxcbiAgICAgIGF1dGhvcml6ZWRXaXRoZHJhd2VyOiBuZXcgUHVibGljS2V5KHZhLmF1dGhvcml6ZWRXaXRoZHJhd2VyKSxcbiAgICAgIGNvbW1pc3Npb246IHZhLmNvbW1pc3Npb24sXG4gICAgICB2b3RlczogdmEudm90ZXMsXG4gICAgICByb290U2xvdCxcbiAgICAgIGF1dGhvcml6ZWRWb3RlcnM6IHZhLmF1dGhvcml6ZWRWb3RlcnMubWFwKHBhcnNlQXV0aG9yaXplZFZvdGVyKSxcbiAgICAgIHByaW9yVm90ZXJzOiBnZXRQcmlvclZvdGVycyh2YS5wcmlvclZvdGVycyksXG4gICAgICBlcG9jaENyZWRpdHM6IHZhLmVwb2NoQ3JlZGl0cyxcbiAgICAgIGxhc3RUaW1lc3RhbXA6IHZhLmxhc3RUaW1lc3RhbXBcbiAgICB9KTtcbiAgfVxufVxuZnVuY3Rpb24gcGFyc2VBdXRob3JpemVkVm90ZXIoe1xuICBhdXRob3JpemVkVm90ZXIsXG4gIGVwb2NoXG59KSB7XG4gIHJldHVybiB7XG4gICAgZXBvY2gsXG4gICAgYXV0aG9yaXplZFZvdGVyOiBuZXcgUHVibGljS2V5KGF1dGhvcml6ZWRWb3RlcilcbiAgfTtcbn1cbmZ1bmN0aW9uIHBhcnNlUHJpb3JWb3RlcnMoe1xuICBhdXRob3JpemVkUHVia2V5LFxuICBlcG9jaE9mTGFzdEF1dGhvcml6ZWRTd2l0Y2gsXG4gIHRhcmdldEVwb2NoXG59KSB7XG4gIHJldHVybiB7XG4gICAgYXV0aG9yaXplZFB1YmtleTogbmV3IFB1YmxpY0tleShhdXRob3JpemVkUHVia2V5KSxcbiAgICBlcG9jaE9mTGFzdEF1dGhvcml6ZWRTd2l0Y2gsXG4gICAgdGFyZ2V0RXBvY2hcbiAgfTtcbn1cbmZ1bmN0aW9uIGdldFByaW9yVm90ZXJzKHtcbiAgYnVmLFxuICBpZHgsXG4gIGlzRW1wdHlcbn0pIHtcbiAgaWYgKGlzRW1wdHkpIHtcbiAgICByZXR1cm4gW107XG4gIH1cbiAgcmV0dXJuIFsuLi5idWYuc2xpY2UoaWR4ICsgMSkubWFwKHBhcnNlUHJpb3JWb3RlcnMpLCAuLi5idWYuc2xpY2UoMCwgaWR4KS5tYXAocGFyc2VQcmlvclZvdGVycyldO1xufVxuXG5jb25zdCBlbmRwb2ludCA9IHtcbiAgaHR0cDoge1xuICAgIGRldm5ldDogJ2h0dHA6Ly9hcGkuZGV2bmV0LnNvbGFuYS5jb20nLFxuICAgIHRlc3RuZXQ6ICdodHRwOi8vYXBpLnRlc3RuZXQuc29sYW5hLmNvbScsXG4gICAgJ21haW5uZXQtYmV0YSc6ICdodHRwOi8vYXBpLm1haW5uZXQtYmV0YS5zb2xhbmEuY29tLydcbiAgfSxcbiAgaHR0cHM6IHtcbiAgICBkZXZuZXQ6ICdodHRwczovL2FwaS5kZXZuZXQuc29sYW5hLmNvbScsXG4gICAgdGVzdG5ldDogJ2h0dHBzOi8vYXBpLnRlc3RuZXQuc29sYW5hLmNvbScsXG4gICAgJ21haW5uZXQtYmV0YSc6ICdodHRwczovL2FwaS5tYWlubmV0LWJldGEuc29sYW5hLmNvbS8nXG4gIH1cbn07XG4vKipcbiAqIFJldHJpZXZlcyB0aGUgUlBDIEFQSSBVUkwgZm9yIHRoZSBzcGVjaWZpZWQgY2x1c3RlclxuICogQHBhcmFtIHtDbHVzdGVyfSBbY2x1c3Rlcj1cImRldm5ldFwiXSAtIFRoZSBjbHVzdGVyIG5hbWUgb2YgdGhlIFJQQyBBUEkgVVJMIHRvIHVzZS4gUG9zc2libGUgb3B0aW9uczogJ2Rldm5ldCcgfCAndGVzdG5ldCcgfCAnbWFpbm5ldC1iZXRhJ1xuICogQHBhcmFtIHtib29sZWFufSBbdGxzPVwiaHR0cFwiXSAtIFVzZSBUTFMgd2hlbiBjb25uZWN0aW5nIHRvIGNsdXN0ZXIuXG4gKlxuICogQHJldHVybnMge3N0cmluZ30gVVJMIHN0cmluZyBvZiB0aGUgUlBDIGVuZHBvaW50XG4gKi9cbmZ1bmN0aW9uIGNsdXN0ZXJBcGlVcmwoY2x1c3RlciwgdGxzKSB7XG4gIGNvbnN0IGtleSA9IHRscyA9PT0gZmFsc2UgPyAnaHR0cCcgOiAnaHR0cHMnO1xuICBpZiAoIWNsdXN0ZXIpIHtcbiAgICByZXR1cm4gZW5kcG9pbnRba2V5XVsnZGV2bmV0J107XG4gIH1cbiAgY29uc3QgdXJsID0gZW5kcG9pbnRba2V5XVtjbHVzdGVyXTtcbiAgaWYgKCF1cmwpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYFVua25vd24gJHtrZXl9IGNsdXN0ZXI6ICR7Y2x1c3Rlcn1gKTtcbiAgfVxuICByZXR1cm4gdXJsO1xufVxuXG4vKipcbiAqIFNlbmQgYW5kIGNvbmZpcm0gYSByYXcgdHJhbnNhY3Rpb25cbiAqXG4gKiBJZiBgY29tbWl0bWVudGAgb3B0aW9uIGlzIG5vdCBzcGVjaWZpZWQsIGRlZmF1bHRzIHRvICdtYXgnIGNvbW1pdG1lbnQuXG4gKlxuICogQHBhcmFtIHtDb25uZWN0aW9ufSBjb25uZWN0aW9uXG4gKiBAcGFyYW0ge0J1ZmZlcn0gcmF3VHJhbnNhY3Rpb25cbiAqIEBwYXJhbSB7VHJhbnNhY3Rpb25Db25maXJtYXRpb25TdHJhdGVneX0gY29uZmlybWF0aW9uU3RyYXRlZ3lcbiAqIEBwYXJhbSB7Q29uZmlybU9wdGlvbnN9IFtvcHRpb25zXVxuICogQHJldHVybnMge1Byb21pc2U8VHJhbnNhY3Rpb25TaWduYXR1cmU+fVxuICovXG5cbi8qKlxuICogQGRlcHJlY2F0ZWQgQ2FsbGluZyBgc2VuZEFuZENvbmZpcm1SYXdUcmFuc2FjdGlvbigpYCB3aXRob3V0IGEgYGNvbmZpcm1hdGlvblN0cmF0ZWd5YFxuICogaXMgbm8gbG9uZ2VyIHN1cHBvcnRlZCBhbmQgd2lsbCBiZSByZW1vdmVkIGluIGEgZnV0dXJlIHZlcnNpb24uXG4gKi9cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1yZWRlY2xhcmVcblxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXJlZGVjbGFyZVxuYXN5bmMgZnVuY3Rpb24gc2VuZEFuZENvbmZpcm1SYXdUcmFuc2FjdGlvbihjb25uZWN0aW9uLCByYXdUcmFuc2FjdGlvbiwgY29uZmlybWF0aW9uU3RyYXRlZ3lPckNvbmZpcm1PcHRpb25zLCBtYXliZUNvbmZpcm1PcHRpb25zKSB7XG4gIGxldCBjb25maXJtYXRpb25TdHJhdGVneTtcbiAgbGV0IG9wdGlvbnM7XG4gIGlmIChjb25maXJtYXRpb25TdHJhdGVneU9yQ29uZmlybU9wdGlvbnMgJiYgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGNvbmZpcm1hdGlvblN0cmF0ZWd5T3JDb25maXJtT3B0aW9ucywgJ2xhc3RWYWxpZEJsb2NrSGVpZ2h0JykpIHtcbiAgICBjb25maXJtYXRpb25TdHJhdGVneSA9IGNvbmZpcm1hdGlvblN0cmF0ZWd5T3JDb25maXJtT3B0aW9ucztcbiAgICBvcHRpb25zID0gbWF5YmVDb25maXJtT3B0aW9ucztcbiAgfSBlbHNlIGlmIChjb25maXJtYXRpb25TdHJhdGVneU9yQ29uZmlybU9wdGlvbnMgJiYgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGNvbmZpcm1hdGlvblN0cmF0ZWd5T3JDb25maXJtT3B0aW9ucywgJ25vbmNlVmFsdWUnKSkge1xuICAgIGNvbmZpcm1hdGlvblN0cmF0ZWd5ID0gY29uZmlybWF0aW9uU3RyYXRlZ3lPckNvbmZpcm1PcHRpb25zO1xuICAgIG9wdGlvbnMgPSBtYXliZUNvbmZpcm1PcHRpb25zO1xuICB9IGVsc2Uge1xuICAgIG9wdGlvbnMgPSBjb25maXJtYXRpb25TdHJhdGVneU9yQ29uZmlybU9wdGlvbnM7XG4gIH1cbiAgY29uc3Qgc2VuZE9wdGlvbnMgPSBvcHRpb25zICYmIHtcbiAgICBza2lwUHJlZmxpZ2h0OiBvcHRpb25zLnNraXBQcmVmbGlnaHQsXG4gICAgcHJlZmxpZ2h0Q29tbWl0bWVudDogb3B0aW9ucy5wcmVmbGlnaHRDb21taXRtZW50IHx8IG9wdGlvbnMuY29tbWl0bWVudCxcbiAgICBtaW5Db250ZXh0U2xvdDogb3B0aW9ucy5taW5Db250ZXh0U2xvdFxuICB9O1xuICBjb25zdCBzaWduYXR1cmUgPSBhd2FpdCBjb25uZWN0aW9uLnNlbmRSYXdUcmFuc2FjdGlvbihyYXdUcmFuc2FjdGlvbiwgc2VuZE9wdGlvbnMpO1xuICBjb25zdCBjb21taXRtZW50ID0gb3B0aW9ucyAmJiBvcHRpb25zLmNvbW1pdG1lbnQ7XG4gIGNvbnN0IGNvbmZpcm1hdGlvblByb21pc2UgPSBjb25maXJtYXRpb25TdHJhdGVneSA/IGNvbm5lY3Rpb24uY29uZmlybVRyYW5zYWN0aW9uKGNvbmZpcm1hdGlvblN0cmF0ZWd5LCBjb21taXRtZW50KSA6IGNvbm5lY3Rpb24uY29uZmlybVRyYW5zYWN0aW9uKHNpZ25hdHVyZSwgY29tbWl0bWVudCk7XG4gIGNvbnN0IHN0YXR1cyA9IChhd2FpdCBjb25maXJtYXRpb25Qcm9taXNlKS52YWx1ZTtcbiAgaWYgKHN0YXR1cy5lcnIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYFJhdyB0cmFuc2FjdGlvbiAke3NpZ25hdHVyZX0gZmFpbGVkICgke0pTT04uc3RyaW5naWZ5KHN0YXR1cyl9KWApO1xuICB9XG4gIHJldHVybiBzaWduYXR1cmU7XG59XG5cbi8qKlxuICogVGhlcmUgYXJlIDEtYmlsbGlvbiBsYW1wb3J0cyBpbiBvbmUgU09MXG4gKi9cbmNvbnN0IExBTVBPUlRTX1BFUl9TT0wgPSAxMDAwMDAwMDAwO1xuXG5leHBvcnQgeyBBY2NvdW50LCBBZGRyZXNzTG9va3VwVGFibGVBY2NvdW50LCBBZGRyZXNzTG9va3VwVGFibGVJbnN0cnVjdGlvbiwgQWRkcmVzc0xvb2t1cFRhYmxlUHJvZ3JhbSwgQXV0aG9yaXplZCwgQkxPQ0tIQVNIX0NBQ0hFX1RJTUVPVVRfTVMsIEJQRl9MT0FERVJfREVQUkVDQVRFRF9QUk9HUkFNX0lELCBCUEZfTE9BREVSX1BST0dSQU1fSUQsIEJwZkxvYWRlciwgQ09NUFVURV9CVURHRVRfSU5TVFJVQ1RJT05fTEFZT1VUUywgQ29tcHV0ZUJ1ZGdldEluc3RydWN0aW9uLCBDb21wdXRlQnVkZ2V0UHJvZ3JhbSwgQ29ubmVjdGlvbiwgRWQyNTUxOVByb2dyYW0sIEVudW0sIEVwb2NoU2NoZWR1bGUsIEZlZUNhbGN1bGF0b3JMYXlvdXQsIEtleXBhaXIsIExBTVBPUlRTX1BFUl9TT0wsIExPT0tVUF9UQUJMRV9JTlNUUlVDVElPTl9MQVlPVVRTLCBMb2FkZXIsIExvY2t1cCwgTUFYX1NFRURfTEVOR1RILCBNZXNzYWdlLCBNZXNzYWdlQWNjb3VudEtleXMsIE1lc3NhZ2VWMCwgTk9OQ0VfQUNDT1VOVF9MRU5HVEgsIE5vbmNlQWNjb3VudCwgUEFDS0VUX0RBVEFfU0laRSwgUFVCTElDX0tFWV9MRU5HVEgsIFB1YmxpY0tleSwgU0lHTkFUVVJFX0xFTkdUSF9JTl9CWVRFUywgU09MQU5BX1NDSEVNQSwgU1RBS0VfQ09ORklHX0lELCBTVEFLRV9JTlNUUlVDVElPTl9MQVlPVVRTLCBTWVNURU1fSU5TVFJVQ1RJT05fTEFZT1VUUywgU1lTVkFSX0NMT0NLX1BVQktFWSwgU1lTVkFSX0VQT0NIX1NDSEVEVUxFX1BVQktFWSwgU1lTVkFSX0lOU1RSVUNUSU9OU19QVUJLRVksIFNZU1ZBUl9SRUNFTlRfQkxPQ0tIQVNIRVNfUFVCS0VZLCBTWVNWQVJfUkVOVF9QVUJLRVksIFNZU1ZBUl9SRVdBUkRTX1BVQktFWSwgU1lTVkFSX1NMT1RfSEFTSEVTX1BVQktFWSwgU1lTVkFSX1NMT1RfSElTVE9SWV9QVUJLRVksIFNZU1ZBUl9TVEFLRV9ISVNUT1JZX1BVQktFWSwgU2VjcDI1NmsxUHJvZ3JhbSwgU2VuZFRyYW5zYWN0aW9uRXJyb3IsIFNvbGFuYUpTT05SUENFcnJvciwgU29sYW5hSlNPTlJQQ0Vycm9yQ29kZSwgU3Rha2VBdXRob3JpemF0aW9uTGF5b3V0LCBTdGFrZUluc3RydWN0aW9uLCBTdGFrZVByb2dyYW0sIFN0cnVjdCwgU3lzdGVtSW5zdHJ1Y3Rpb24sIFN5c3RlbVByb2dyYW0sIFRyYW5zYWN0aW9uLCBUcmFuc2FjdGlvbkV4cGlyZWRCbG9ja2hlaWdodEV4Y2VlZGVkRXJyb3IsIFRyYW5zYWN0aW9uRXhwaXJlZE5vbmNlSW52YWxpZEVycm9yLCBUcmFuc2FjdGlvbkV4cGlyZWRUaW1lb3V0RXJyb3IsIFRyYW5zYWN0aW9uSW5zdHJ1Y3Rpb24sIFRyYW5zYWN0aW9uTWVzc2FnZSwgVHJhbnNhY3Rpb25TdGF0dXMsIFZBTElEQVRPUl9JTkZPX0tFWSwgVkVSU0lPTl9QUkVGSVhfTUFTSywgVk9URV9QUk9HUkFNX0lELCBWYWxpZGF0b3JJbmZvLCBWZXJzaW9uZWRNZXNzYWdlLCBWZXJzaW9uZWRUcmFuc2FjdGlvbiwgVm90ZUFjY291bnQsIFZvdGVBdXRob3JpemF0aW9uTGF5b3V0LCBWb3RlSW5pdCwgVm90ZUluc3RydWN0aW9uLCBWb3RlUHJvZ3JhbSwgY2x1c3RlckFwaVVybCwgc2VuZEFuZENvbmZpcm1SYXdUcmFuc2FjdGlvbiwgc2VuZEFuZENvbmZpcm1UcmFuc2FjdGlvbiB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguZXNtLmpzLm1hcFxuIl0sIm5hbWVzIjpbIkJ1ZmZlciIsImVkMjU1MTkiLCJCTiIsImJzNTgiLCJzaGEyNTYiLCJzZXJpYWxpemUiLCJkZXNlcmlhbGl6ZSIsImRlc2VyaWFsaXplVW5jaGVja2VkIiwiQnVmZmVyTGF5b3V0IiwiYmxvYiIsInRvQmlnSW50TEUiLCJ0b0J1ZmZlckxFIiwicmVxdWlyZSQkMCIsInJlcXVpcmUkJDAkMSIsInJlcXVpcmUkJDAkMiIsIkFnZW50IiwiQWdlbnQkMSIsImNvZXJjZSIsImluc3RhbmNlIiwic3RyaW5nIiwidHVwbGUiLCJsaXRlcmFsIiwidW5rbm93biIsInR5cGUiLCJudW1iZXIiLCJhcnJheSIsIm51bGxhYmxlIiwib3B0aW9uYWwiLCJib29sZWFuIiwicmVjb3JkIiwidW5pb24iLCJjcmVhdGUiLCJhbnkiLCJhc3NlcnQiLCJhc3NlcnQkMSIsIlJwY0NsaWVudCIsIm5vZGVGZXRjaCIsIlJwY1dlYlNvY2tldENvbW1vbkNsaWVudCIsIldlYnNvY2tldEZhY3RvcnkiLCJrZWNjYWtfMjU2Iiwic2VjcDI1NmsxIiwiZ2VuZXJhdGVQcml2YXRlS2V5IiwidXRpbHMiLCJyYW5kb21Qcml2YXRlS2V5IiwiZ2VuZXJhdGVLZXlwYWlyIiwicHJpdmF0ZVNjYWxhciIsInB1YmxpY0tleSIsImdldFB1YmxpY0tleSIsInNlY3JldEtleSIsIlVpbnQ4QXJyYXkiLCJzZXQiLCJpc09uQ3VydmUiLCJFeHRlbmRlZFBvaW50IiwiZnJvbUhleCIsInNpZ24iLCJtZXNzYWdlIiwic2xpY2UiLCJ2ZXJpZnkiLCJ0b0J1ZmZlciIsImFyciIsImlzQnVmZmVyIiwiZnJvbSIsImJ1ZmZlciIsImJ5dGVPZmZzZXQiLCJieXRlTGVuZ3RoIiwiU3RydWN0IiwiY29uc3RydWN0b3IiLCJwcm9wZXJ0aWVzIiwiT2JqZWN0IiwiYXNzaWduIiwiZW5jb2RlIiwiU09MQU5BX1NDSEVNQSIsImRlY29kZSIsImRhdGEiLCJkZWNvZGVVbmNoZWNrZWQiLCJFbnVtIiwiZW51bSIsImtleXMiLCJsZW5ndGgiLCJFcnJvciIsIm1hcCIsImtleSIsIk1hcCIsIl9QdWJsaWNLZXkiLCJNQVhfU0VFRF9MRU5HVEgiLCJQVUJMSUNfS0VZX0xFTkdUSCIsImlzUHVibGljS2V5RGF0YSIsInZhbHVlIiwiX2JuIiwidW5kZWZpbmVkIiwidW5pcXVlUHVibGljS2V5Q291bnRlciIsIlB1YmxpY0tleSIsImRlY29kZWQiLCJ1bmlxdWUiLCJlcXVhbHMiLCJlcSIsInRvQmFzZTU4IiwidG9CeXRlcyIsInRvSlNPTiIsImJ1ZiIsImIiLCJ0b0FycmF5TGlrZSIsInplcm9QYWQiLCJhbGxvYyIsImNvcHkiLCJTeW1ib2wiLCJ0b1N0cmluZ1RhZyIsInRvU3RyaW5nIiwiY3JlYXRlV2l0aFNlZWQiLCJmcm9tUHVibGljS2V5Iiwic2VlZCIsInByb2dyYW1JZCIsImNvbmNhdCIsInB1YmxpY0tleUJ5dGVzIiwiY3JlYXRlUHJvZ3JhbUFkZHJlc3NTeW5jIiwic2VlZHMiLCJmb3JFYWNoIiwiVHlwZUVycm9yIiwiY3JlYXRlUHJvZ3JhbUFkZHJlc3MiLCJmaW5kUHJvZ3JhbUFkZHJlc3NTeW5jIiwibm9uY2UiLCJhZGRyZXNzIiwic2VlZHNXaXRoTm9uY2UiLCJlcnIiLCJmaW5kUHJvZ3JhbUFkZHJlc3MiLCJwdWJrZXlEYXRhIiwicHVia2V5IiwiZGVmYXVsdCIsImtpbmQiLCJmaWVsZHMiLCJBY2NvdW50IiwiX3B1YmxpY0tleSIsIl9zZWNyZXRLZXkiLCJzZWNyZXRLZXlCdWZmZXIiLCJCUEZfTE9BREVSX0RFUFJFQ0FURURfUFJPR1JBTV9JRCIsIlBBQ0tFVF9EQVRBX1NJWkUiLCJWRVJTSU9OX1BSRUZJWF9NQVNLIiwiU0lHTkFUVVJFX0xFTkdUSF9JTl9CWVRFUyIsIlRyYW5zYWN0aW9uRXhwaXJlZEJsb2NraGVpZ2h0RXhjZWVkZWRFcnJvciIsInNpZ25hdHVyZSIsImRlZmluZVByb3BlcnR5IiwicHJvdG90eXBlIiwiVHJhbnNhY3Rpb25FeHBpcmVkVGltZW91dEVycm9yIiwidGltZW91dFNlY29uZHMiLCJ0b0ZpeGVkIiwiVHJhbnNhY3Rpb25FeHBpcmVkTm9uY2VJbnZhbGlkRXJyb3IiLCJNZXNzYWdlQWNjb3VudEtleXMiLCJzdGF0aWNBY2NvdW50S2V5cyIsImFjY291bnRLZXlzRnJvbUxvb2t1cHMiLCJrZXlTZWdtZW50cyIsInB1c2giLCJ3cml0YWJsZSIsInJlYWRvbmx5IiwiZ2V0IiwiaW5kZXgiLCJrZXlTZWdtZW50IiwiZmxhdCIsImNvbXBpbGVJbnN0cnVjdGlvbnMiLCJpbnN0cnVjdGlvbnMiLCJVOF9NQVgiLCJrZXlJbmRleE1hcCIsImZpbmRLZXlJbmRleCIsImtleUluZGV4IiwiaW5zdHJ1Y3Rpb24iLCJwcm9ncmFtSWRJbmRleCIsImFjY291bnRLZXlJbmRleGVzIiwibWV0YSIsInByb3BlcnR5IiwicnVzdFN0cmluZyIsInJzbCIsInN0cnVjdCIsInUzMiIsIm9mZnNldCIsIl9kZWNvZGUiLCJiaW5kIiwiX2VuY29kZSIsInJzbFNoaW0iLCJzdHIiLCJjaGFycyIsInNwYW4iLCJhdXRob3JpemVkIiwibG9ja3VwIiwibnM2NCIsInZvdGVJbml0IiwidTgiLCJ2b3RlQXV0aG9yaXplV2l0aFNlZWRBcmdzIiwiZ2V0QWxsb2MiLCJnZXRJdGVtQWxsb2MiLCJpdGVtIiwiZmllbGQiLCJBcnJheSIsImlzQXJyYXkiLCJlbGVtZW50TGF5b3V0IiwibGF5b3V0IiwiZGVjb2RlTGVuZ3RoIiwiYnl0ZXMiLCJsZW4iLCJzaXplIiwiZWxlbSIsInNoaWZ0IiwiZW5jb2RlTGVuZ3RoIiwicmVtX2xlbiIsImNvbmRpdGlvbiIsIkNvbXBpbGVkS2V5cyIsInBheWVyIiwia2V5TWV0YU1hcCIsImNvbXBpbGUiLCJnZXRPckluc2VydERlZmF1bHQiLCJrZXlNZXRhIiwiaXNTaWduZXIiLCJpc1dyaXRhYmxlIiwiaXNJbnZva2VkIiwicGF5ZXJLZXlNZXRhIiwiaXgiLCJhY2NvdW50TWV0YSIsImdldE1lc3NhZ2VDb21wb25lbnRzIiwibWFwRW50cmllcyIsImVudHJpZXMiLCJ3cml0YWJsZVNpZ25lcnMiLCJmaWx0ZXIiLCJyZWFkb25seVNpZ25lcnMiLCJ3cml0YWJsZU5vblNpZ25lcnMiLCJyZWFkb25seU5vblNpZ25lcnMiLCJoZWFkZXIiLCJudW1SZXF1aXJlZFNpZ25hdHVyZXMiLCJudW1SZWFkb25seVNpZ25lZEFjY291bnRzIiwibnVtUmVhZG9ubHlVbnNpZ25lZEFjY291bnRzIiwicGF5ZXJBZGRyZXNzIiwiZXh0cmFjdFRhYmxlTG9va3VwIiwibG9va3VwVGFibGUiLCJ3cml0YWJsZUluZGV4ZXMiLCJkcmFpbmVkV3JpdGFibGVLZXlzIiwiZHJhaW5LZXlzRm91bmRJbkxvb2t1cFRhYmxlIiwic3RhdGUiLCJhZGRyZXNzZXMiLCJyZWFkb25seUluZGV4ZXMiLCJkcmFpbmVkUmVhZG9ubHlLZXlzIiwiYWNjb3VudEtleSIsImxvb2t1cFRhYmxlRW50cmllcyIsImtleU1ldGFGaWx0ZXIiLCJsb29rdXBUYWJsZUluZGV4ZXMiLCJkcmFpbmVkS2V5cyIsImxvb2t1cFRhYmxlSW5kZXgiLCJmaW5kSW5kZXgiLCJlbnRyeSIsImRlbGV0ZSIsIkVORF9PRl9CVUZGRVJfRVJST1JfTUVTU0FHRSIsImd1YXJkZWRTaGlmdCIsImJ5dGVBcnJheSIsImd1YXJkZWRTcGxpY2UiLCJhcmdzIiwic3RhcnQiLCJzcGxpY2UiLCJNZXNzYWdlIiwiYWNjb3VudEtleXMiLCJyZWNlbnRCbG9ja2hhc2giLCJpbmRleFRvUHJvZ3JhbUlkcyIsImFjY291bnQiLCJ2ZXJzaW9uIiwiY29tcGlsZWRJbnN0cnVjdGlvbnMiLCJhY2NvdW50cyIsImFkZHJlc3NUYWJsZUxvb2t1cHMiLCJnZXRBY2NvdW50S2V5cyIsImNvbXBpbGVkS2V5cyIsInBheWVyS2V5IiwiaXNBY2NvdW50U2lnbmVyIiwiaXNBY2NvdW50V3JpdGFibGUiLCJudW1TaWduZWRBY2NvdW50cyIsInVuc2lnbmVkQWNjb3VudEluZGV4IiwibnVtVW5zaWduZWRBY2NvdW50cyIsIm51bVdyaXRhYmxlVW5zaWduZWRBY2NvdW50cyIsIm51bVdyaXRhYmxlU2lnbmVkQWNjb3VudHMiLCJpc1Byb2dyYW1JZCIsImhhcyIsInByb2dyYW1JZHMiLCJ2YWx1ZXMiLCJub25Qcm9ncmFtSWRzIiwiXyIsIm51bUtleXMiLCJrZXlDb3VudCIsImtleUluZGljZXNDb3VudCIsImRhdGFDb3VudCIsImtleUluZGljZXMiLCJkYXRhTGVuZ3RoIiwiaW5zdHJ1Y3Rpb25Db3VudCIsImluc3RydWN0aW9uQnVmZmVyIiwiaW5zdHJ1Y3Rpb25CdWZmZXJMZW5ndGgiLCJpbnN0cnVjdGlvbkxheW91dCIsInNlcSIsInNpZ25EYXRhTGF5b3V0IiwidHJhbnNhY3Rpb24iLCJzaWduRGF0YSIsImFjY291bnRDb3VudCIsImkiLCJkYXRhU2xpY2UiLCJtZXNzYWdlQXJncyIsIk1lc3NhZ2VWMCIsIm51bUFjY291bnRLZXlzRnJvbUxvb2t1cHMiLCJjb3VudCIsImxvb2t1cCIsImFkZHJlc3NMb29rdXBUYWJsZUFjY291bnRzIiwicmVzb2x2ZUFkZHJlc3NUYWJsZUxvb2t1cHMiLCJudW1TdGF0aWNBY2NvdW50S2V5cyIsImxvb2t1cEFjY291bnRLZXlzSW5kZXgiLCJudW1Xcml0YWJsZUxvb2t1cEFjY291bnRLZXlzIiwicmVkdWNlIiwidGFibGVMb29rdXAiLCJ0YWJsZUFjY291bnQiLCJmaW5kIiwibG9va3VwVGFibGVBY2NvdW50cyIsImV4dHJhY3RSZXN1bHQiLCJhZGRyZXNzVGFibGVMb29rdXAiLCJlbmNvZGVkU3RhdGljQWNjb3VudEtleXNMZW5ndGgiLCJzZXJpYWxpemVkSW5zdHJ1Y3Rpb25zIiwic2VyaWFsaXplSW5zdHJ1Y3Rpb25zIiwiZW5jb2RlZEluc3RydWN0aW9uc0xlbmd0aCIsInNlcmlhbGl6ZWRBZGRyZXNzVGFibGVMb29rdXBzIiwic2VyaWFsaXplQWRkcmVzc1RhYmxlTG9va3VwcyIsImVuY29kZWRBZGRyZXNzVGFibGVMb29rdXBzTGVuZ3RoIiwibWVzc2FnZUxheW91dCIsInNlcmlhbGl6ZWRNZXNzYWdlIiwiTUVTU0FHRV9WRVJTSU9OXzBfUFJFRklYIiwic2VyaWFsaXplZE1lc3NhZ2VMZW5ndGgiLCJwcmVmaXgiLCJzdGF0aWNBY2NvdW50S2V5c0xlbmd0aCIsImluc3RydWN0aW9uc0xlbmd0aCIsImFkZHJlc3NUYWJsZUxvb2t1cHNMZW5ndGgiLCJzZXJpYWxpemVkTGVuZ3RoIiwiZW5jb2RlZEFjY291bnRLZXlJbmRleGVzTGVuZ3RoIiwiZW5jb2RlZERhdGFMZW5ndGgiLCJlbmNvZGVkV3JpdGFibGVJbmRleGVzTGVuZ3RoIiwiZW5jb2RlZFJlYWRvbmx5SW5kZXhlc0xlbmd0aCIsImFkZHJlc3NUYWJsZUxvb2t1cExheW91dCIsIm1hc2tlZFByZWZpeCIsImFjY291bnRLZXlJbmRleGVzTGVuZ3RoIiwiYWRkcmVzc1RhYmxlTG9va3Vwc0NvdW50Iiwid3JpdGFibGVJbmRleGVzTGVuZ3RoIiwicmVhZG9ubHlJbmRleGVzTGVuZ3RoIiwiVmVyc2lvbmVkTWVzc2FnZSIsImRlc2VyaWFsaXplTWVzc2FnZVZlcnNpb24iLCJUcmFuc2FjdGlvblN0YXR1cyIsIkRFRkFVTFRfU0lHTkFUVVJFIiwiZmlsbCIsIlRyYW5zYWN0aW9uSW5zdHJ1Y3Rpb24iLCJvcHRzIiwiVHJhbnNhY3Rpb24iLCJzaWduYXR1cmVzIiwiZmVlUGF5ZXIiLCJsYXN0VmFsaWRCbG9ja0hlaWdodCIsIm5vbmNlSW5mbyIsIm1pbk5vbmNlQ29udGV4dFNsb3QiLCJfbWVzc2FnZSIsIl9qc29uIiwiaGFzT3duUHJvcGVydHkiLCJjYWxsIiwibWluQ29udGV4dFNsb3QiLCJibG9ja2hhc2giLCJub25jZUluc3RydWN0aW9uIiwic2lnbmVycyIsImFkZCIsIml0ZW1zIiwiY29tcGlsZU1lc3NhZ2UiLCJKU09OIiwic3RyaW5naWZ5IiwiY29uc29sZSIsIndhcm4iLCJhY2NvdW50TWV0YXMiLCJpbmNsdWRlcyIsInVuaXF1ZU1ldGFzIiwicHVia2V5U3RyaW5nIiwidW5pcXVlSW5kZXgiLCJ4Iiwic29ydCIsInkiLCJvcHRpb25zIiwibG9jYWxlTWF0Y2hlciIsInVzYWdlIiwic2Vuc2l0aXZpdHkiLCJpZ25vcmVQdW5jdHVhdGlvbiIsIm51bWVyaWMiLCJjYXNlRmlyc3QiLCJsb2NhbGVDb21wYXJlIiwiZmVlUGF5ZXJJbmRleCIsInBheWVyTWV0YSIsInVuc2hpZnQiLCJzaWduZWRLZXlzIiwidW5zaWduZWRLZXlzIiwiaW5kZXhPZiIsIl9jb21waWxlIiwidmFsaWQiLCJldmVyeSIsInBhaXIiLCJzZXJpYWxpemVNZXNzYWdlIiwiZ2V0RXN0aW1hdGVkRmVlIiwiY29ubmVjdGlvbiIsImdldEZlZUZvck1lc3NhZ2UiLCJzZXRTaWduZXJzIiwic2VlbiIsIlNldCIsInVuaXF1ZVNpZ25lcnMiLCJzaWduZXIiLCJfcGFydGlhbFNpZ24iLCJwYXJ0aWFsU2lnbiIsIl9hZGRTaWduYXR1cmUiLCJhZGRTaWduYXR1cmUiLCJzaWdwYWlyIiwidmVyaWZ5U2lnbmF0dXJlcyIsInJlcXVpcmVBbGxTaWduYXR1cmVzIiwic2lnbmF0dXJlRXJyb3JzIiwiX2dldE1lc3NhZ2VTaWduZWRuZXNzRXJyb3JzIiwiZXJyb3JzIiwibWlzc2luZyIsImludmFsaWQiLCJjb25maWciLCJzaWdFcnJvcnMiLCJlcnJvck1lc3NhZ2UiLCJwIiwiam9pbiIsIl9zZXJpYWxpemUiLCJzaWduYXR1cmVDb3VudCIsInRyYW5zYWN0aW9uTGVuZ3RoIiwid2lyZVRyYW5zYWN0aW9uIiwia2V5T2JqIiwicG9wdWxhdGUiLCJzaWdQdWJrZXlQYWlyIiwic29tZSIsIlRyYW5zYWN0aW9uTWVzc2FnZSIsImRlY29tcGlsZSIsImNvbXBpbGVkSXgiLCJjb21waWxlVG9MZWdhY3lNZXNzYWdlIiwiY29tcGlsZVRvVjBNZXNzYWdlIiwiVmVyc2lvbmVkVHJhbnNhY3Rpb24iLCJkZWZhdWx0U2lnbmF0dXJlcyIsImVuY29kZWRTaWduYXR1cmVzTGVuZ3RoIiwidHJhbnNhY3Rpb25MYXlvdXQiLCJzZXJpYWxpemVkVHJhbnNhY3Rpb24iLCJzZXJpYWxpemVkVHJhbnNhY3Rpb25MZW5ndGgiLCJzaWduYXR1cmVzTGVuZ3RoIiwibWVzc2FnZURhdGEiLCJzaWduZXJQdWJrZXlzIiwic2lnbmVySW5kZXgiLCJOVU1fVElDS1NfUEVSX1NFQ09ORCIsIkRFRkFVTFRfVElDS1NfUEVSX1NMT1QiLCJOVU1fU0xPVFNfUEVSX1NFQ09ORCIsIk1TX1BFUl9TTE9UIiwiU1lTVkFSX0NMT0NLX1BVQktFWSIsIlNZU1ZBUl9FUE9DSF9TQ0hFRFVMRV9QVUJLRVkiLCJTWVNWQVJfSU5TVFJVQ1RJT05TX1BVQktFWSIsIlNZU1ZBUl9SRUNFTlRfQkxPQ0tIQVNIRVNfUFVCS0VZIiwiU1lTVkFSX1JFTlRfUFVCS0VZIiwiU1lTVkFSX1JFV0FSRFNfUFVCS0VZIiwiU1lTVkFSX1NMT1RfSEFTSEVTX1BVQktFWSIsIlNZU1ZBUl9TTE9UX0hJU1RPUllfUFVCS0VZIiwiU1lTVkFSX1NUQUtFX0hJU1RPUllfUFVCS0VZIiwic2VuZEFuZENvbmZpcm1UcmFuc2FjdGlvbiIsInNlbmRPcHRpb25zIiwic2tpcFByZWZsaWdodCIsInByZWZsaWdodENvbW1pdG1lbnQiLCJjb21taXRtZW50IiwibWF4UmV0cmllcyIsInNlbmRUcmFuc2FjdGlvbiIsInN0YXR1cyIsImNvbmZpcm1UcmFuc2FjdGlvbiIsImFib3J0U2lnbmFsIiwibm9uY2VBY2NvdW50UHVia2V5Iiwibm9uY2VWYWx1ZSIsInNsZWVwIiwibXMiLCJQcm9taXNlIiwicmVzb2x2ZSIsInNldFRpbWVvdXQiLCJlbmNvZGVEYXRhIiwiYWxsb2NMZW5ndGgiLCJsYXlvdXRGaWVsZHMiLCJkZWNvZGVEYXRhJDEiLCJGZWVDYWxjdWxhdG9yTGF5b3V0IiwibnU2NCIsIk5vbmNlQWNjb3VudExheW91dCIsIk5PTkNFX0FDQ09VTlRfTEVOR1RIIiwiTm9uY2VBY2NvdW50IiwiYXV0aG9yaXplZFB1YmtleSIsImZlZUNhbGN1bGF0b3IiLCJmcm9tQWNjb3VudERhdGEiLCJub25jZUFjY291bnQiLCJlbmNvZGVEZWNvZGUiLCJiaWdJbnQiLCJiaWdJbnRMYXlvdXQiLCJzcmMiLCJ1NjQiLCJTeXN0ZW1JbnN0cnVjdGlvbiIsImRlY29kZUluc3RydWN0aW9uVHlwZSIsImNoZWNrUHJvZ3JhbUlkIiwiaW5zdHJ1Y3Rpb25UeXBlTGF5b3V0IiwidHlwZUluZGV4IiwiaXhUeXBlIiwiU1lTVEVNX0lOU1RSVUNUSU9OX0xBWU9VVFMiLCJkZWNvZGVDcmVhdGVBY2NvdW50IiwiY2hlY2tLZXlMZW5ndGgiLCJsYW1wb3J0cyIsInNwYWNlIiwiQ3JlYXRlIiwiZnJvbVB1YmtleSIsIm5ld0FjY291bnRQdWJrZXkiLCJkZWNvZGVUcmFuc2ZlciIsIlRyYW5zZmVyIiwidG9QdWJrZXkiLCJkZWNvZGVUcmFuc2ZlcldpdGhTZWVkIiwiVHJhbnNmZXJXaXRoU2VlZCIsImJhc2VQdWJrZXkiLCJkZWNvZGVBbGxvY2F0ZSIsIkFsbG9jYXRlIiwiYWNjb3VudFB1YmtleSIsImRlY29kZUFsbG9jYXRlV2l0aFNlZWQiLCJiYXNlIiwiQWxsb2NhdGVXaXRoU2VlZCIsImRlY29kZUFzc2lnbiIsIkFzc2lnbiIsImRlY29kZUFzc2lnbldpdGhTZWVkIiwiQXNzaWduV2l0aFNlZWQiLCJkZWNvZGVDcmVhdGVXaXRoU2VlZCIsIkNyZWF0ZVdpdGhTZWVkIiwiZGVjb2RlTm9uY2VJbml0aWFsaXplIiwiSW5pdGlhbGl6ZU5vbmNlQWNjb3VudCIsIm5vbmNlUHVia2V5IiwiZGVjb2RlTm9uY2VBZHZhbmNlIiwiQWR2YW5jZU5vbmNlQWNjb3VudCIsImRlY29kZU5vbmNlV2l0aGRyYXciLCJXaXRoZHJhd05vbmNlQWNjb3VudCIsImRlY29kZU5vbmNlQXV0aG9yaXplIiwiQXV0aG9yaXplTm9uY2VBY2NvdW50IiwibmV3QXV0aG9yaXplZFB1YmtleSIsIlN5c3RlbVByb2dyYW0iLCJleHBlY3RlZExlbmd0aCIsImZyZWV6ZSIsIlVwZ3JhZGVOb25jZUFjY291bnQiLCJjcmVhdGVBY2NvdW50IiwicGFyYW1zIiwidHJhbnNmZXIiLCJCaWdJbnQiLCJjcmVhdGVBY2NvdW50V2l0aFNlZWQiLCJjcmVhdGVOb25jZUFjY291bnQiLCJpbml0UGFyYW1zIiwibm9uY2VJbml0aWFsaXplIiwiaW5zdHJ1Y3Rpb25EYXRhIiwibm9uY2VBZHZhbmNlIiwibm9uY2VXaXRoZHJhdyIsIm5vbmNlQXV0aG9yaXplIiwiYWxsb2NhdGUiLCJDSFVOS19TSVpFIiwiTG9hZGVyIiwiZ2V0TWluTnVtU2lnbmF0dXJlcyIsIk1hdGgiLCJjZWlsIiwiY2h1bmtTaXplIiwibG9hZCIsInByb2dyYW0iLCJiYWxhbmNlTmVlZGVkIiwiZ2V0TWluaW11bUJhbGFuY2VGb3JSZW50RXhlbXB0aW9uIiwicHJvZ3JhbUluZm8iLCJnZXRBY2NvdW50SW5mbyIsImV4ZWN1dGFibGUiLCJlcnJvciIsIm93bmVyIiwiZGF0YUxheW91dCIsInRyYW5zYWN0aW9ucyIsImJ5dGVzTGVuZ3RoIiwiYnl0ZXNMZW5ndGhQYWRkaW5nIiwiX3JwY0VuZHBvaW50IiwiUkVRVUVTVFNfUEVSX1NFQ09ORCIsImFsbCIsImRlcGxveUNvbW1pdG1lbnQiLCJmaW5hbGl6ZVNpZ25hdHVyZSIsImNvbnRleHQiLCJjdXJyZW50U2xvdCIsImdldFNsb3QiLCJzbG90Iiwicm91bmQiLCJCUEZfTE9BREVSX1BST0dSQU1fSUQiLCJCcGZMb2FkZXIiLCJlbGYiLCJsb2FkZXJQcm9ncmFtSWQiLCJnZXREZWZhdWx0RXhwb3J0RnJvbUNqcyIsIl9fZXNNb2R1bGUiLCJhZ2VudGtlZXBhbGl2ZSIsImV4cG9ydHMiLCJzIiwibSIsImgiLCJkIiwidyIsIm1zJDIiLCJ2YWwiLCJwYXJzZSIsImlzRmluaXRlIiwibG9uZyIsImZtdExvbmciLCJmbXRTaG9ydCIsIlN0cmluZyIsIm1hdGNoIiwiZXhlYyIsIm4iLCJwYXJzZUZsb2F0IiwidG9Mb3dlckNhc2UiLCJtc0FicyIsImFicyIsInBsdXJhbCIsIm5hbWUiLCJpc1BsdXJhbCIsInV0aWwiLCJtcyQxIiwiaHVtYW5pemVNcyIsInQiLCJyIiwiZm9ybWF0Iiwic3RhY2siLCJjb25zdGFudHMiLCJDVVJSRU5UX0lEIiwiQ1JFQVRFX0lEIiwiSU5JVF9TT0NLRVQiLCJDUkVBVEVfSFRUUFNfQ09OTkVDVElPTiIsIlNPQ0tFVF9DUkVBVEVEX1RJTUUiLCJTT0NLRVRfTkFNRSIsIlNPQ0tFVF9SRVFVRVNUX0NPVU5UIiwiU09DS0VUX1JFUVVFU1RfRklOSVNIRURfQ09VTlQiLCJPcmlnaW5hbEFnZW50IiwiZGVidWciLCJkZWJ1Z2xvZyIsIklOSVRfU09DS0VUJDEiLCJkZWZhdWx0VGltZW91dExpc3RlbmVyQ291bnQiLCJtYWpvclZlcnNpb24iLCJwYXJzZUludCIsInByb2Nlc3MiLCJzcGxpdCIsInN1YnN0cmluZyIsImRlcHJlY2F0ZSIsImxvZyIsImtlZXBBbGl2ZSIsImZyZWVTb2NrZXRUaW1lb3V0Iiwia2VlcEFsaXZlVGltZW91dCIsImZyZWVTb2NrZXRLZWVwQWxpdmVUaW1lb3V0IiwidGltZW91dCIsIm1heCIsInNvY2tldEFjdGl2ZVRUTCIsImNyZWF0ZVNvY2tldENvdW50IiwiY3JlYXRlU29ja2V0Q291bnRMYXN0Q2hlY2siLCJjcmVhdGVTb2NrZXRFcnJvckNvdW50IiwiY3JlYXRlU29ja2V0RXJyb3JDb3VudExhc3RDaGVjayIsImNsb3NlU29ja2V0Q291bnQiLCJjbG9zZVNvY2tldENvdW50TGFzdENoZWNrIiwiZXJyb3JTb2NrZXRDb3VudCIsImVycm9yU29ja2V0Q291bnRMYXN0Q2hlY2siLCJyZXF1ZXN0Q291bnQiLCJyZXF1ZXN0Q291bnRMYXN0Q2hlY2siLCJ0aW1lb3V0U29ja2V0Q291bnQiLCJ0aW1lb3V0U29ja2V0Q291bnRMYXN0Q2hlY2siLCJvbiIsInNvY2tldCIsImNhbGNTb2NrZXRUaW1lb3V0IiwiYWxpdmVUaW1lIiwiRGF0ZSIsIm5vdyIsImRpZmYiLCJjdXN0b21GcmVlU29ja2V0VGltZW91dCIsImtlZXBTb2NrZXRBbGl2ZSIsInJlc3VsdCIsImN1c3RvbVRpbWVvdXQiLCJyZXVzZVNvY2tldCIsInJlcSIsInJldXNlZFNvY2tldCIsImFnZW50VGltZW91dCIsImdldFNvY2tldFRpbWVvdXQiLCJpZCIsIk51bWJlciIsIk1BWF9TQUZFX0lOVEVHRVIiLCJzZXROb0RlbGF5IiwiX2FnZW50S2V5IiwiaW5zdGFsbExpc3RlbmVycyIsImNyZWF0ZUNvbm5lY3Rpb24iLCJvbmNyZWF0ZSIsImNhbGxlZCIsIm9uTmV3Q3JlYXRlIiwibmV3U29ja2V0Iiwic3RhdHVzQ2hhbmdlZCIsImNoYW5nZWQiLCJnZXRDdXJyZW50U3RhdHVzIiwiZnJlZVNvY2tldHMiLCJpbnNwZWN0Iiwic29ja2V0cyIsInJlcXVlc3RzIiwiX2lkbGVUaW1lb3V0IiwiYWdlbnQiLCJvbkZyZWUiLCJfaHR0cE1lc3NhZ2UiLCJnZXROYW1lIiwib25DbG9zZSIsImlzRXJyb3IiLCJvblRpbWVvdXQiLCJsaXN0ZW5lckNvdW50IiwibGlzdGVuZXJzIiwicmVxVGltZW91dExpc3RlbmVyQ291bnQiLCJlbmFibGVkIiwiZiIsImRlc3Ryb3kiLCJyZW1vdmVTb2NrZXQiLCJjb2RlIiwib25FcnJvciIsInJlbW92ZUxpc3RlbmVyIiwiZW1pdCIsIm9uUmVtb3ZlIiwib2JqIiwicmVzIiwiT3JpZ2luYWxIdHRwc0FnZW50IiwiSHR0cEFnZW50IiwiSHR0cHNBZ2VudCQxIiwiSHR0cHNBZ2VudCIsImRlZmF1bHRQb3J0IiwicHJvdG9jb2wiLCJtYXhDYWNoZWRTZXNzaW9ucyIsIl9zZXNzaW9uQ2FjaGUiLCJsaXN0IiwibWV0aG9kIiwiaHR0cHNfYWdlbnQiLCJhZ2VudGtlZXBhbGl2ZUV4cG9ydHMiLCJIdHRwS2VlcEFsaXZlQWdlbnQiLCJvYmpUb1N0cmluZyIsIm9iaktleXMiLCJpc0FycmF5UHJvcCIsInByb3BWYWwiLCJ0b1N0ciIsImZhc3RTdGFibGVTdHJpbmdpZnkiLCJyZXR1cm5WYWwiLCJmYXN0U3RhYmxlU3RyaW5naWZ5JDEiLCJNSU5JTVVNX1NMT1RfUEVSX0VQT0NIIiwidHJhaWxpbmdaZXJvcyIsIm5leHRQb3dlck9mVHdvIiwiRXBvY2hTY2hlZHVsZSIsInNsb3RzUGVyRXBvY2giLCJsZWFkZXJTY2hlZHVsZVNsb3RPZmZzZXQiLCJ3YXJtdXAiLCJmaXJzdE5vcm1hbEVwb2NoIiwiZmlyc3ROb3JtYWxTbG90IiwiZ2V0RXBvY2giLCJnZXRFcG9jaEFuZFNsb3RJbmRleCIsImVwb2NoIiwiZXBvY2hMZW4iLCJnZXRTbG90c0luRXBvY2giLCJzbG90SW5kZXgiLCJub3JtYWxTbG90SW5kZXgiLCJub3JtYWxFcG9jaEluZGV4IiwiZmxvb3IiLCJnZXRGaXJzdFNsb3RJbkVwb2NoIiwicG93IiwiZ2V0TGFzdFNsb3RJbkVwb2NoIiwiU2VuZFRyYW5zYWN0aW9uRXJyb3IiLCJsb2dzIiwiU29sYW5hSlNPTlJQQ0Vycm9yQ29kZSIsIkpTT05fUlBDX1NFUlZFUl9FUlJPUl9CTE9DS19DTEVBTkVEX1VQIiwiSlNPTl9SUENfU0VSVkVSX0VSUk9SX1NFTkRfVFJBTlNBQ1RJT05fUFJFRkxJR0hUX0ZBSUxVUkUiLCJKU09OX1JQQ19TRVJWRVJfRVJST1JfVFJBTlNBQ1RJT05fU0lHTkFUVVJFX1ZFUklGSUNBVElPTl9GQUlMVVJFIiwiSlNPTl9SUENfU0VSVkVSX0VSUk9SX0JMT0NLX05PVF9BVkFJTEFCTEUiLCJKU09OX1JQQ19TRVJWRVJfRVJST1JfTk9ERV9VTkhFQUxUSFkiLCJKU09OX1JQQ19TRVJWRVJfRVJST1JfVFJBTlNBQ1RJT05fUFJFQ09NUElMRV9WRVJJRklDQVRJT05fRkFJTFVSRSIsIkpTT05fUlBDX1NFUlZFUl9FUlJPUl9TTE9UX1NLSVBQRUQiLCJKU09OX1JQQ19TRVJWRVJfRVJST1JfTk9fU05BUFNIT1QiLCJKU09OX1JQQ19TRVJWRVJfRVJST1JfTE9OR19URVJNX1NUT1JBR0VfU0xPVF9TS0lQUEVEIiwiSlNPTl9SUENfU0VSVkVSX0VSUk9SX0tFWV9FWENMVURFRF9GUk9NX1NFQ09OREFSWV9JTkRFWCIsIkpTT05fUlBDX1NFUlZFUl9FUlJPUl9UUkFOU0FDVElPTl9ISVNUT1JZX05PVF9BVkFJTEFCTEUiLCJKU09OX1JQQ19TQ0FOX0VSUk9SIiwiSlNPTl9SUENfU0VSVkVSX0VSUk9SX1RSQU5TQUNUSU9OX1NJR05BVFVSRV9MRU5fTUlTTUFUQ0giLCJKU09OX1JQQ19TRVJWRVJfRVJST1JfQkxPQ0tfU1RBVFVTX05PVF9BVkFJTEFCTEVfWUVUIiwiSlNPTl9SUENfU0VSVkVSX0VSUk9SX1VOU1VQUE9SVEVEX1RSQU5TQUNUSU9OX1ZFUlNJT04iLCJKU09OX1JQQ19TRVJWRVJfRVJST1JfTUlOX0NPTlRFWFRfU0xPVF9OT1RfUkVBQ0hFRCIsIlNvbGFuYUpTT05SUENFcnJvciIsImN1c3RvbU1lc3NhZ2UiLCJmZXRjaEltcGwiLCJnbG9iYWxUaGlzIiwiZmV0Y2giLCJpbnB1dCIsImluaXQiLCJwcm9jZXNzZWRJbnB1dCIsIlJwY1dlYlNvY2tldENsaWVudCIsImdlbmVyYXRlX3JlcXVlc3RfaWQiLCJ3ZWJTb2NrZXRGYWN0b3J5IiwidXJsIiwicnBjIiwiYXV0b2Nvbm5lY3QiLCJtYXhfcmVjb25uZWN0cyIsInJlY29ubmVjdCIsInJlY29ubmVjdF9pbnRlcnZhbCIsInVuZGVybHlpbmdTb2NrZXQiLCJyZWFkeVN0YXRlIiwicmVqZWN0Iiwibm90aWZ5IiwiZGVjb2RlRGF0YSIsIkxPT0tVUF9UQUJMRV9NRVRBX1NJWkUiLCJBZGRyZXNzTG9va3VwVGFibGVBY2NvdW50IiwiaXNBY3RpdmUiLCJVNjRfTUFYIiwiZGVhY3RpdmF0aW9uU2xvdCIsImFjY291bnREYXRhIiwiTG9va3VwVGFibGVNZXRhTGF5b3V0Iiwic2VyaWFsaXplZEFkZHJlc3Nlc0xlbiIsIm51bVNlcmlhbGl6ZWRBZGRyZXNzZXMiLCJsYXN0RXh0ZW5kZWRTbG90IiwibGFzdEV4dGVuZGVkU2xvdFN0YXJ0SW5kZXgiLCJsYXN0RXh0ZW5kZWRTdGFydEluZGV4IiwiYXV0aG9yaXR5IiwiVVJMX1JFIiwibWFrZVdlYnNvY2tldFVybCIsImVuZHBvaW50IiwibWF0Y2hlcyIsImhvc3Rpc2giLCJwb3J0V2l0aENvbG9uIiwicmVzdCIsInN0YXJ0c1dpdGgiLCJzdGFydFBvcnQiLCJ3ZWJzb2NrZXRQb3J0IiwiUHVibGljS2V5RnJvbVN0cmluZyIsIlJhd0FjY291bnREYXRhUmVzdWx0IiwiQnVmZmVyRnJvbVJhd0FjY291bnREYXRhIiwiQkxPQ0tIQVNIX0NBQ0hFX1RJTUVPVVRfTVMiLCJhc3NlcnRFbmRwb2ludFVybCIsInB1dGF0aXZlVXJsIiwidGVzdCIsImV4dHJhY3RDb21taXRtZW50RnJvbUNvbmZpZyIsImNvbW1pdG1lbnRPckNvbmZpZyIsInNwZWNpZmllZENvbW1pdG1lbnQiLCJzcGVjaWZpZWRDb25maWciLCJjcmVhdGVScGNSZXN1bHQiLCJqc29ucnBjIiwiVW5rbm93blJwY1Jlc3VsdCIsImpzb25ScGNSZXN1bHQiLCJzY2hlbWEiLCJqc29uUnBjUmVzdWx0QW5kQ29udGV4dCIsIm5vdGlmaWNhdGlvblJlc3VsdEFuZENvbnRleHQiLCJ2ZXJzaW9uZWRNZXNzYWdlRnJvbVJlc3BvbnNlIiwicmVzcG9uc2UiLCJHZXRJbmZsYXRpb25Hb3Zlcm5vclJlc3VsdCIsImZvdW5kYXRpb24iLCJmb3VuZGF0aW9uVGVybSIsImluaXRpYWwiLCJ0YXBlciIsInRlcm1pbmFsIiwiR2V0SW5mbGF0aW9uUmV3YXJkUmVzdWx0IiwiZWZmZWN0aXZlU2xvdCIsImFtb3VudCIsInBvc3RCYWxhbmNlIiwiY29tbWlzc2lvbiIsIkdldFJlY2VudFByaW9yaXRpemF0aW9uRmVlc1Jlc3VsdCIsInByaW9yaXRpemF0aW9uRmVlIiwiR2V0SW5mbGF0aW9uUmF0ZVJlc3VsdCIsInRvdGFsIiwidmFsaWRhdG9yIiwiR2V0RXBvY2hJbmZvUmVzdWx0Iiwic2xvdHNJbkVwb2NoIiwiYWJzb2x1dGVTbG90IiwiYmxvY2tIZWlnaHQiLCJ0cmFuc2FjdGlvbkNvdW50IiwiR2V0RXBvY2hTY2hlZHVsZVJlc3VsdCIsIkdldExlYWRlclNjaGVkdWxlUmVzdWx0IiwiVHJhbnNhY3Rpb25FcnJvclJlc3VsdCIsIlNpZ25hdHVyZVN0YXR1c1Jlc3VsdCIsIlNpZ25hdHVyZVJlY2VpdmVkUmVzdWx0IiwiVmVyc2lvblJlc3VsdCIsIlNpbXVsYXRlZFRyYW5zYWN0aW9uUmVzcG9uc2VTdHJ1Y3QiLCJyZW50RXBvY2giLCJ1bml0c0NvbnN1bWVkIiwicmV0dXJuRGF0YSIsIkJsb2NrUHJvZHVjdGlvblJlc3BvbnNlU3RydWN0IiwiYnlJZGVudGl0eSIsInJhbmdlIiwiZmlyc3RTbG90IiwibGFzdFNsb3QiLCJjcmVhdGVScGNDbGllbnQiLCJodHRwSGVhZGVycyIsImN1c3RvbUZldGNoIiwiZmV0Y2hNaWRkbGV3YXJlIiwiZGlzYWJsZVJldHJ5T25SYXRlTGltaXQiLCJodHRwQWdlbnQiLCJhZ2VudE9wdGlvbnMiLCJtYXhTb2NrZXRzIiwiaXNIdHRwcyIsImZldGNoV2l0aE1pZGRsZXdhcmUiLCJpbmZvIiwibW9kaWZpZWRGZXRjaEFyZ3MiLCJtb2RpZmllZEluZm8iLCJtb2RpZmllZEluaXQiLCJjbGllbnRCcm93c2VyIiwicmVxdWVzdCIsImNhbGxiYWNrIiwiYm9keSIsImhlYWRlcnMiLCJDT01NT05fSFRUUF9IRUFERVJTIiwidG9vX21hbnlfcmVxdWVzdHNfcmV0cmllcyIsIndhaXRUaW1lIiwic3RhdHVzVGV4dCIsInRleHQiLCJvayIsImNyZWF0ZVJwY1JlcXVlc3QiLCJjbGllbnQiLCJjcmVhdGVScGNCYXRjaFJlcXVlc3QiLCJiYXRjaCIsIm1ldGhvZE5hbWUiLCJHZXRJbmZsYXRpb25Hb3Zlcm5vclJwY1Jlc3VsdCIsIkdldEluZmxhdGlvblJhdGVScGNSZXN1bHQiLCJHZXRSZWNlbnRQcmlvcml0aXphdGlvbkZlZXNScGNSZXN1bHQiLCJHZXRFcG9jaEluZm9ScGNSZXN1bHQiLCJHZXRFcG9jaFNjaGVkdWxlUnBjUmVzdWx0IiwiR2V0TGVhZGVyU2NoZWR1bGVScGNSZXN1bHQiLCJTbG90UnBjUmVzdWx0IiwiR2V0U3VwcGx5UnBjUmVzdWx0IiwiY2lyY3VsYXRpbmciLCJub25DaXJjdWxhdGluZyIsIm5vbkNpcmN1bGF0aW5nQWNjb3VudHMiLCJUb2tlbkFtb3VudFJlc3VsdCIsInVpQW1vdW50IiwiZGVjaW1hbHMiLCJ1aUFtb3VudFN0cmluZyIsIkdldFRva2VuTGFyZ2VzdEFjY291bnRzUmVzdWx0IiwiR2V0VG9rZW5BY2NvdW50c0J5T3duZXIiLCJQYXJzZWRBY2NvdW50RGF0YVJlc3VsdCIsInBhcnNlZCIsIkdldFBhcnNlZFRva2VuQWNjb3VudHNCeU93bmVyIiwiR2V0TGFyZ2VzdEFjY291bnRzUnBjUmVzdWx0IiwiQWNjb3VudEluZm9SZXN1bHQiLCJLZXllZEFjY291bnRJbmZvUmVzdWx0IiwiUGFyc2VkT3JSYXdBY2NvdW50RGF0YSIsIlBhcnNlZEFjY291bnRJbmZvUmVzdWx0IiwiS2V5ZWRQYXJzZWRBY2NvdW50SW5mb1Jlc3VsdCIsIlN0YWtlQWN0aXZhdGlvblJlc3VsdCIsImFjdGl2ZSIsImluYWN0aXZlIiwiR2V0Q29uZmlybWVkU2lnbmF0dXJlc0ZvckFkZHJlc3MyUnBjUmVzdWx0IiwibWVtbyIsImJsb2NrVGltZSIsIkdldFNpZ25hdHVyZXNGb3JBZGRyZXNzUnBjUmVzdWx0IiwiQWNjb3VudE5vdGlmaWNhdGlvblJlc3VsdCIsInN1YnNjcmlwdGlvbiIsIlByb2dyYW1BY2NvdW50SW5mb1Jlc3VsdCIsIlByb2dyYW1BY2NvdW50Tm90aWZpY2F0aW9uUmVzdWx0IiwiU2xvdEluZm9SZXN1bHQiLCJwYXJlbnQiLCJyb290IiwiU2xvdE5vdGlmaWNhdGlvblJlc3VsdCIsIlNsb3RVcGRhdGVSZXN1bHQiLCJ0aW1lc3RhbXAiLCJzdGF0cyIsIm51bVRyYW5zYWN0aW9uRW50cmllcyIsIm51bVN1Y2Nlc3NmdWxUcmFuc2FjdGlvbnMiLCJudW1GYWlsZWRUcmFuc2FjdGlvbnMiLCJtYXhUcmFuc2FjdGlvbnNQZXJFbnRyeSIsIlNsb3RVcGRhdGVOb3RpZmljYXRpb25SZXN1bHQiLCJTaWduYXR1cmVOb3RpZmljYXRpb25SZXN1bHQiLCJSb290Tm90aWZpY2F0aW9uUmVzdWx0IiwiQ29udGFjdEluZm9SZXN1bHQiLCJnb3NzaXAiLCJ0cHUiLCJWb3RlQWNjb3VudEluZm9SZXN1bHQiLCJ2b3RlUHVia2V5Iiwibm9kZVB1YmtleSIsImFjdGl2YXRlZFN0YWtlIiwiZXBvY2hWb3RlQWNjb3VudCIsImVwb2NoQ3JlZGl0cyIsImxhc3RWb3RlIiwicm9vdFNsb3QiLCJHZXRWb3RlQWNjb3VudHMiLCJjdXJyZW50IiwiZGVsaW5xdWVudCIsIkNvbmZpcm1hdGlvblN0YXR1cyIsIlNpZ25hdHVyZVN0YXR1c1Jlc3BvbnNlIiwiY29uZmlybWF0aW9ucyIsImNvbmZpcm1hdGlvblN0YXR1cyIsIkdldFNpZ25hdHVyZVN0YXR1c2VzUnBjUmVzdWx0IiwiR2V0TWluaW11bUJhbGFuY2VGb3JSZW50RXhlbXB0aW9uUnBjUmVzdWx0IiwiQWRkcmVzc1RhYmxlTG9va3VwU3RydWN0IiwiQ29uZmlybWVkVHJhbnNhY3Rpb25SZXN1bHQiLCJBbm5vdGF0ZWRBY2NvdW50S2V5Iiwic291cmNlIiwiQ29uZmlybWVkVHJhbnNhY3Rpb25BY2NvdW50c01vZGVSZXN1bHQiLCJQYXJzZWRJbnN0cnVjdGlvblJlc3VsdCIsIlJhd0luc3RydWN0aW9uUmVzdWx0IiwiSW5zdHJ1Y3Rpb25SZXN1bHQiLCJVbmtub3duSW5zdHJ1Y3Rpb25SZXN1bHQiLCJQYXJzZWRPclJhd0luc3RydWN0aW9uIiwiUGFyc2VkQ29uZmlybWVkVHJhbnNhY3Rpb25SZXN1bHQiLCJUb2tlbkJhbGFuY2VSZXN1bHQiLCJhY2NvdW50SW5kZXgiLCJtaW50IiwidWlUb2tlbkFtb3VudCIsIkxvYWRlZEFkZHJlc3Nlc1Jlc3VsdCIsIkNvbmZpcm1lZFRyYW5zYWN0aW9uTWV0YVJlc3VsdCIsImZlZSIsImlubmVySW5zdHJ1Y3Rpb25zIiwicHJlQmFsYW5jZXMiLCJwb3N0QmFsYW5jZXMiLCJsb2dNZXNzYWdlcyIsInByZVRva2VuQmFsYW5jZXMiLCJwb3N0VG9rZW5CYWxhbmNlcyIsImxvYWRlZEFkZHJlc3NlcyIsImNvbXB1dGVVbml0c0NvbnN1bWVkIiwiUGFyc2VkQ29uZmlybWVkVHJhbnNhY3Rpb25NZXRhUmVzdWx0IiwiVHJhbnNhY3Rpb25WZXJzaW9uU3RydWN0IiwiUmV3YXJkc1Jlc3VsdCIsInJld2FyZFR5cGUiLCJHZXRCbG9ja1JwY1Jlc3VsdCIsInByZXZpb3VzQmxvY2toYXNoIiwicGFyZW50U2xvdCIsInJld2FyZHMiLCJHZXROb25lTW9kZUJsb2NrUnBjUmVzdWx0IiwiR2V0QWNjb3VudHNNb2RlQmxvY2tScGNSZXN1bHQiLCJHZXRQYXJzZWRCbG9ja1JwY1Jlc3VsdCIsIkdldFBhcnNlZEFjY291bnRzTW9kZUJsb2NrUnBjUmVzdWx0IiwiR2V0UGFyc2VkTm9uZU1vZGVCbG9ja1JwY1Jlc3VsdCIsIkdldENvbmZpcm1lZEJsb2NrUnBjUmVzdWx0IiwiR2V0QmxvY2tTaWduYXR1cmVzUnBjUmVzdWx0IiwiR2V0VHJhbnNhY3Rpb25ScGNSZXN1bHQiLCJHZXRQYXJzZWRUcmFuc2FjdGlvblJwY1Jlc3VsdCIsIkdldFJlY2VudEJsb2NraGFzaEFuZENvbnRleHRScGNSZXN1bHQiLCJsYW1wb3J0c1BlclNpZ25hdHVyZSIsIkdldExhdGVzdEJsb2NraGFzaFJwY1Jlc3VsdCIsIklzQmxvY2toYXNoVmFsaWRScGNSZXN1bHQiLCJQZXJmU2FtcGxlUmVzdWx0IiwibnVtVHJhbnNhY3Rpb25zIiwibnVtU2xvdHMiLCJzYW1wbGVQZXJpb2RTZWNzIiwiR2V0UmVjZW50UGVyZm9ybWFuY2VTYW1wbGVzUnBjUmVzdWx0IiwiR2V0RmVlQ2FsY3VsYXRvclJwY1Jlc3VsdCIsIlJlcXVlc3RBaXJkcm9wUnBjUmVzdWx0IiwiU2VuZFRyYW5zYWN0aW9uUnBjUmVzdWx0IiwiTG9nc1Jlc3VsdCIsIkxvZ3NOb3RpZmljYXRpb25SZXN1bHQiLCJDb25uZWN0aW9uIiwiX2NvbW1pdG1lbnRPckNvbmZpZyIsIl9jb21taXRtZW50IiwiX2NvbmZpcm1UcmFuc2FjdGlvbkluaXRpYWxUaW1lb3V0IiwiX3JwY1dzRW5kcG9pbnQiLCJfcnBjQ2xpZW50IiwiX3JwY1JlcXVlc3QiLCJfcnBjQmF0Y2hSZXF1ZXN0IiwiX3JwY1dlYlNvY2tldCIsIl9ycGNXZWJTb2NrZXRDb25uZWN0ZWQiLCJfcnBjV2ViU29ja2V0SGVhcnRiZWF0IiwiX3JwY1dlYlNvY2tldElkbGVUaW1lb3V0IiwiX3JwY1dlYlNvY2tldEdlbmVyYXRpb24iLCJfZGlzYWJsZUJsb2NraGFzaENhY2hpbmciLCJfcG9sbGluZ0Jsb2NraGFzaCIsIl9ibG9ja2hhc2hJbmZvIiwibGF0ZXN0QmxvY2toYXNoIiwibGFzdEZldGNoIiwidHJhbnNhY3Rpb25TaWduYXR1cmVzIiwic2ltdWxhdGVkU2lnbmF0dXJlcyIsIl9uZXh0Q2xpZW50U3Vic2NyaXB0aW9uSWQiLCJfc3Vic2NyaXB0aW9uRGlzcG9zZUZ1bmN0aW9uc0J5Q2xpZW50U3Vic2NyaXB0aW9uSWQiLCJfc3Vic2NyaXB0aW9uSGFzaEJ5Q2xpZW50U3Vic2NyaXB0aW9uSWQiLCJfc3Vic2NyaXB0aW9uU3RhdGVDaGFuZ2VDYWxsYmFja3NCeUhhc2giLCJfc3Vic2NyaXB0aW9uQ2FsbGJhY2tzQnlTZXJ2ZXJTdWJzY3JpcHRpb25JZCIsIl9zdWJzY3JpcHRpb25zQnlIYXNoIiwiX3N1YnNjcmlwdGlvbnNBdXRvRGlzcG9zZWRCeVJwYyIsImdldEJsb2NrSGVpZ2h0IiwicmVxdWVzdFByb21pc2VzIiwiX2J1aWxkQXJncyIsInJlcXVlc3RIYXNoIiwidW5zYWZlUmVzIiwid3NFbmRwb2ludCIsImNvbmZpcm1UcmFuc2FjdGlvbkluaXRpYWxUaW1lb3V0IiwiSW5maW5pdHkiLCJfd3NPbk9wZW4iLCJfd3NPbkVycm9yIiwiX3dzT25DbG9zZSIsIl93c09uQWNjb3VudE5vdGlmaWNhdGlvbiIsIl93c09uUHJvZ3JhbUFjY291bnROb3RpZmljYXRpb24iLCJfd3NPblNsb3ROb3RpZmljYXRpb24iLCJfd3NPblNsb3RVcGRhdGVzTm90aWZpY2F0aW9uIiwiX3dzT25TaWduYXR1cmVOb3RpZmljYXRpb24iLCJfd3NPblJvb3ROb3RpZmljYXRpb24iLCJfd3NPbkxvZ3NOb3RpZmljYXRpb24iLCJycGNFbmRwb2ludCIsImdldEJhbGFuY2VBbmRDb250ZXh0IiwiZ2V0QmFsYW5jZSIsInRoZW4iLCJjYXRjaCIsImUiLCJnZXRCbG9ja1RpbWUiLCJnZXRNaW5pbXVtTGVkZ2VyU2xvdCIsImdldEZpcnN0QXZhaWxhYmxlQmxvY2siLCJnZXRTdXBwbHkiLCJjb25maWdBcmciLCJnZXRUb2tlblN1cHBseSIsInRva2VuTWludEFkZHJlc3MiLCJnZXRUb2tlbkFjY291bnRCYWxhbmNlIiwidG9rZW5BZGRyZXNzIiwiZ2V0VG9rZW5BY2NvdW50c0J5T3duZXIiLCJvd25lckFkZHJlc3MiLCJfYXJncyIsImdldFBhcnNlZFRva2VuQWNjb3VudHNCeU93bmVyIiwiZ2V0TGFyZ2VzdEFjY291bnRzIiwiYXJnIiwiZ2V0VG9rZW5MYXJnZXN0QWNjb3VudHMiLCJtaW50QWRkcmVzcyIsImdldEFjY291bnRJbmZvQW5kQ29udGV4dCIsImdldFBhcnNlZEFjY291bnRJbmZvIiwiZ2V0TXVsdGlwbGVQYXJzZWRBY2NvdW50cyIsInB1YmxpY0tleXMiLCJyYXdDb25maWciLCJnZXRNdWx0aXBsZUFjY291bnRzSW5mb0FuZENvbnRleHQiLCJnZXRNdWx0aXBsZUFjY291bnRzSW5mbyIsImdldFN0YWtlQWN0aXZhdGlvbiIsImdldFByb2dyYW1BY2NvdW50cyIsImNvbmZpZ09yQ29tbWl0bWVudCIsImVuY29kaW5nIiwiY29uZmlnV2l0aG91dEVuY29kaW5nIiwiYmFzZVNjaGVtYSIsIndpdGhDb250ZXh0IiwiZ2V0UGFyc2VkUHJvZ3JhbUFjY291bnRzIiwic3RyYXRlZ3kiLCJyYXdTaWduYXR1cmUiLCJhYm9ydGVkIiwicmVhc29uIiwiZGVjb2RlZFNpZ25hdHVyZSIsImNvbmZpcm1UcmFuc2FjdGlvblVzaW5nTGVnYWN5VGltZW91dFN0cmF0ZWd5IiwiY29uZmlybVRyYW5zYWN0aW9uVXNpbmdCbG9ja0hlaWdodEV4Y2VlZGFuY2VTdHJhdGVneSIsImNvbmZpcm1UcmFuc2FjdGlvblVzaW5nRHVyYWJsZU5vbmNlU3RyYXRlZ3kiLCJnZXRDYW5jZWxsYXRpb25Qcm9taXNlIiwic2lnbmFsIiwiYWRkRXZlbnRMaXN0ZW5lciIsImdldFRyYW5zYWN0aW9uQ29uZmlybWF0aW9uUHJvbWlzZSIsInNpZ25hdHVyZVN1YnNjcmlwdGlvbklkIiwiZGlzcG9zZVNpZ25hdHVyZVN1YnNjcmlwdGlvblN0YXRlQ2hhbmdlT2JzZXJ2ZXIiLCJkb25lIiwiY29uZmlybWF0aW9uUHJvbWlzZSIsIm9uU2lnbmF0dXJlIiwiX190eXBlIiwiUFJPQ0VTU0VEIiwic3Vic2NyaXB0aW9uU2V0dXBQcm9taXNlIiwicmVzb2x2ZVN1YnNjcmlwdGlvblNldHVwIiwiX29uU3Vic2NyaXB0aW9uU3RhdGVDaGFuZ2UiLCJuZXh0U3RhdGUiLCJnZXRTaWduYXR1cmVTdGF0dXMiLCJhYm9ydENvbmZpcm1hdGlvbiIsInJlbW92ZVNpZ25hdHVyZUxpc3RlbmVyIiwiZXhwaXJ5UHJvbWlzZSIsImNoZWNrQmxvY2tIZWlnaHQiLCJfZSIsImN1cnJlbnRCbG9ja0hlaWdodCIsIkJMT0NLSEVJR0hUX0VYQ0VFREVEIiwiY2FuY2VsbGF0aW9uUHJvbWlzZSIsIm91dGNvbWUiLCJyYWNlIiwiY3VycmVudE5vbmNlVmFsdWUiLCJsYXN0Q2hlY2tlZFNsb3QiLCJnZXRDdXJyZW50Tm9uY2VWYWx1ZSIsImdldE5vbmNlQW5kQ29udGV4dCIsIk5PTkNFX0lOVkFMSUQiLCJzbG90SW5XaGljaE5vbmNlRGlkQWR2YW5jZSIsInNpZ25hdHVyZVN0YXR1cyIsImNvbW1pdG1lbnRGb3JTdGF0dXMiLCJ0aW1lb3V0SWQiLCJ0aW1lb3V0TXMiLCJUSU1FRF9PVVQiLCJjbGVhclRpbWVvdXQiLCJnZXRDbHVzdGVyTm9kZXMiLCJnZXRWb3RlQWNjb3VudHMiLCJnZXRTbG90TGVhZGVyIiwiZ2V0U2xvdExlYWRlcnMiLCJzdGFydFNsb3QiLCJsaW1pdCIsImdldFNpZ25hdHVyZVN0YXR1c2VzIiwiZ2V0VHJhbnNhY3Rpb25Db3VudCIsImdldFRvdGFsU3VwcGx5IiwiZXhjbHVkZU5vbkNpcmN1bGF0aW5nQWNjb3VudHNMaXN0IiwiZ2V0SW5mbGF0aW9uR292ZXJub3IiLCJnZXRJbmZsYXRpb25SZXdhcmQiLCJnZXRJbmZsYXRpb25SYXRlIiwiZ2V0RXBvY2hJbmZvIiwiZ2V0RXBvY2hTY2hlZHVsZSIsImVwb2NoU2NoZWR1bGUiLCJnZXRMZWFkZXJTY2hlZHVsZSIsImdldFJlY2VudEJsb2NraGFzaEFuZENvbnRleHQiLCJnZXRSZWNlbnRQZXJmb3JtYW5jZVNhbXBsZXMiLCJnZXRGZWVDYWxjdWxhdG9yRm9yQmxvY2toYXNoIiwid2lyZU1lc3NhZ2UiLCJnZXRSZWNlbnRQcmlvcml0aXphdGlvbkZlZXMiLCJsb2NrZWRXcml0YWJsZUFjY291bnRzIiwiZ2V0UmVjZW50QmxvY2toYXNoIiwiZ2V0TGF0ZXN0QmxvY2toYXNoIiwiZ2V0TGF0ZXN0QmxvY2toYXNoQW5kQ29udGV4dCIsImlzQmxvY2toYXNoVmFsaWQiLCJnZXRWZXJzaW9uIiwiZ2V0R2VuZXNpc0hhc2giLCJnZXRCbG9jayIsIl9idWlsZEFyZ3NBdExlYXN0Q29uZmlybWVkIiwidHJhbnNhY3Rpb25EZXRhaWxzIiwiZ2V0UGFyc2VkQmxvY2siLCJnZXRCbG9ja1Byb2R1Y3Rpb24iLCJleHRyYSIsImMiLCJnZXRUcmFuc2FjdGlvbiIsImdldFBhcnNlZFRyYW5zYWN0aW9uIiwiZ2V0UGFyc2VkVHJhbnNhY3Rpb25zIiwiZ2V0VHJhbnNhY3Rpb25zIiwiZ2V0Q29uZmlybWVkQmxvY2siLCJibG9jayIsImdldEJsb2NrcyIsImVuZFNsb3QiLCJnZXRCbG9ja1NpZ25hdHVyZXMiLCJnZXRDb25maXJtZWRCbG9ja1NpZ25hdHVyZXMiLCJnZXRDb25maXJtZWRUcmFuc2FjdGlvbiIsImdldFBhcnNlZENvbmZpcm1lZFRyYW5zYWN0aW9uIiwiZ2V0UGFyc2VkQ29uZmlybWVkVHJhbnNhY3Rpb25zIiwiZ2V0Q29uZmlybWVkU2lnbmF0dXJlc0ZvckFkZHJlc3MiLCJmaXJzdEF2YWlsYWJsZUJsb2NrIiwidW50aWwiLCJoaWdoZXN0Q29uZmlybWVkUm9vdCIsImJlZm9yZSIsImNvbmZpcm1lZFNpZ25hdHVyZUluZm8iLCJnZXRDb25maXJtZWRTaWduYXR1cmVzRm9yQWRkcmVzczIiLCJnZXRTaWduYXR1cmVzRm9yQWRkcmVzcyIsImdldEFkZHJlc3NMb29rdXBUYWJsZSIsImFjY291bnRJbmZvIiwiZ2V0Tm9uY2UiLCJyZXF1ZXN0QWlyZHJvcCIsInRvIiwiX2Jsb2NraGFzaFdpdGhFeHBpcnlCbG9ja0hlaWdodCIsImRpc2FibGVDYWNoZSIsInRpbWVTaW5jZUZldGNoIiwiZXhwaXJlZCIsIl9wb2xsTmV3QmxvY2toYXNoIiwic3RhcnRUaW1lIiwiY2FjaGVkTGF0ZXN0QmxvY2toYXNoIiwiY2FjaGVkQmxvY2toYXNoIiwiZ2V0U3Rha2VNaW5pbXVtRGVsZWdhdGlvbiIsInNpbXVsYXRlVHJhbnNhY3Rpb24iLCJ0cmFuc2FjdGlvbk9yTWVzc2FnZSIsImNvbmZpZ09yU2lnbmVycyIsImluY2x1ZGVBY2NvdW50cyIsInZlcnNpb25lZFR4IiwiZW5jb2RlZFRyYW5zYWN0aW9uIiwib3JpZ2luYWxUeCIsInNpZ1ZlcmlmeSIsInRyYWNlSW5kZW50IiwibG9nVHJhY2UiLCJzaWduZXJzT3JPcHRpb25zIiwic2VuZFJhd1RyYW5zYWN0aW9uIiwicmF3VHJhbnNhY3Rpb24iLCJzZW5kRW5jb2RlZFRyYW5zYWN0aW9uIiwic2V0SW50ZXJ2YWwiLCJfdXBkYXRlU3Vic2NyaXB0aW9ucyIsImNsZWFySW50ZXJ2YWwiLCJoYXNoIiwiX3NldFN1YnNjcmlwdGlvbiIsIm5leHRTdWJzY3JpcHRpb24iLCJwcmV2U3RhdGUiLCJzdGF0ZUNoYW5nZUNhbGxiYWNrcyIsImNiIiwiY2xpZW50U3Vic2NyaXB0aW9uSWQiLCJjbG9zZSIsImNvbm5lY3QiLCJhY3RpdmVXZWJTb2NrZXRHZW5lcmF0aW9uIiwiaXNDdXJyZW50Q29ubmVjdGlvblN0aWxsQWN0aXZlIiwiY2FsbGJhY2tzIiwic2VydmVyU3Vic2NyaXB0aW9uSWQiLCJ1bnN1YnNjcmliZU1ldGhvZCIsIl9oYW5kbGVTZXJ2ZXJOb3RpZmljYXRpb24iLCJjYWxsYmFja0FyZ3MiLCJub3RpZmljYXRpb24iLCJfbWFrZVN1YnNjcmlwdGlvbiIsInN1YnNjcmlwdGlvbkNvbmZpZyIsImV4aXN0aW5nU3Vic2NyaXB0aW9uIiwib25BY2NvdW50Q2hhbmdlIiwicmVtb3ZlQWNjb3VudENoYW5nZUxpc3RlbmVyIiwiX3Vuc3Vic2NyaWJlQ2xpZW50U3Vic2NyaXB0aW9uIiwiYWNjb3VudElkIiwib25Qcm9ncmFtQWNjb3VudENoYW5nZSIsImZpbHRlcnMiLCJyZW1vdmVQcm9ncmFtQWNjb3VudENoYW5nZUxpc3RlbmVyIiwib25Mb2dzIiwibWVudGlvbnMiLCJyZW1vdmVPbkxvZ3NMaXN0ZW5lciIsIm9uU2xvdENoYW5nZSIsInJlbW92ZVNsb3RDaGFuZ2VMaXN0ZW5lciIsIm9uU2xvdFVwZGF0ZSIsInJlbW92ZVNsb3RVcGRhdGVMaXN0ZW5lciIsInN1YnNjcmlwdGlvbk5hbWUiLCJkaXNwb3NlIiwib3ZlcnJpZGUiLCJfZXJyIiwib25TaWduYXR1cmVXaXRoT3B0aW9ucyIsIm9uUm9vdENoYW5nZSIsInJlbW92ZVJvb3RDaGFuZ2VMaXN0ZW5lciIsIktleXBhaXIiLCJrZXlwYWlyIiwiX2tleXBhaXIiLCJnZW5lcmF0ZSIsImZyb21TZWNyZXRLZXkiLCJza2lwVmFsaWRhdGlvbiIsImNvbXB1dGVkUHVibGljS2V5IiwiaWkiLCJmcm9tU2VlZCIsIkxPT0tVUF9UQUJMRV9JTlNUUlVDVElPTl9MQVlPVVRTIiwiQ3JlYXRlTG9va3VwVGFibGUiLCJGcmVlemVMb29rdXBUYWJsZSIsIkV4dGVuZExvb2t1cFRhYmxlIiwiRGVhY3RpdmF0ZUxvb2t1cFRhYmxlIiwiQ2xvc2VMb29rdXBUYWJsZSIsIkFkZHJlc3NMb29rdXBUYWJsZUluc3RydWN0aW9uIiwibGF5b3V0VHlwZSIsImRlY29kZUNyZWF0ZUxvb2t1cFRhYmxlIiwiY2hlY2tLZXlzTGVuZ3RoIiwicmVjZW50U2xvdCIsImRlY29kZUV4dGVuZExvb2t1cFRhYmxlIiwiZGVjb2RlQ2xvc2VMb29rdXBUYWJsZSIsInJlY2lwaWVudCIsImRlY29kZUZyZWV6ZUxvb2t1cFRhYmxlIiwiZGVjb2RlRGVhY3RpdmF0ZUxvb2t1cFRhYmxlIiwiQWRkcmVzc0xvb2t1cFRhYmxlUHJvZ3JhbSIsImNyZWF0ZUxvb2t1cFRhYmxlIiwibG9va3VwVGFibGVBZGRyZXNzIiwiYnVtcFNlZWQiLCJmcmVlemVMb29rdXBUYWJsZSIsImV4dGVuZExvb2t1cFRhYmxlIiwiYWRkciIsImRlYWN0aXZhdGVMb29rdXBUYWJsZSIsImNsb3NlTG9va3VwVGFibGUiLCJDb21wdXRlQnVkZ2V0SW5zdHJ1Y3Rpb24iLCJDT01QVVRFX0JVREdFVF9JTlNUUlVDVElPTl9MQVlPVVRTIiwiZGVjb2RlUmVxdWVzdFVuaXRzIiwidW5pdHMiLCJhZGRpdGlvbmFsRmVlIiwiUmVxdWVzdFVuaXRzIiwiZGVjb2RlUmVxdWVzdEhlYXBGcmFtZSIsIlJlcXVlc3RIZWFwRnJhbWUiLCJkZWNvZGVTZXRDb21wdXRlVW5pdExpbWl0IiwiU2V0Q29tcHV0ZVVuaXRMaW1pdCIsImRlY29kZVNldENvbXB1dGVVbml0UHJpY2UiLCJtaWNyb0xhbXBvcnRzIiwiU2V0Q29tcHV0ZVVuaXRQcmljZSIsIkNvbXB1dGVCdWRnZXRQcm9ncmFtIiwicmVxdWVzdFVuaXRzIiwicmVxdWVzdEhlYXBGcmFtZSIsInNldENvbXB1dGVVbml0TGltaXQiLCJzZXRDb21wdXRlVW5pdFByaWNlIiwiUFJJVkFURV9LRVlfQllURVMkMSIsIlBVQkxJQ19LRVlfQllURVMkMSIsIlNJR05BVFVSRV9CWVRFUyIsIkVEMjU1MTlfSU5TVFJVQ1RJT05fTEFZT1VUIiwidTE2IiwiRWQyNTUxOVByb2dyYW0iLCJjcmVhdGVJbnN0cnVjdGlvbldpdGhQdWJsaWNLZXkiLCJpbnN0cnVjdGlvbkluZGV4IiwicHVibGljS2V5T2Zmc2V0Iiwic2lnbmF0dXJlT2Zmc2V0IiwibWVzc2FnZURhdGFPZmZzZXQiLCJudW1TaWduYXR1cmVzIiwicGFkZGluZyIsInNpZ25hdHVyZUluc3RydWN0aW9uSW5kZXgiLCJwdWJsaWNLZXlJbnN0cnVjdGlvbkluZGV4IiwibWVzc2FnZURhdGFTaXplIiwibWVzc2FnZUluc3RydWN0aW9uSW5kZXgiLCJjcmVhdGVJbnN0cnVjdGlvbldpdGhQcml2YXRlS2V5IiwicHJpdmF0ZUtleSIsImVjZHNhU2lnbiIsIm1zZ0hhc2giLCJwcml2S2V5IiwidG9Db21wYWN0UmF3Qnl0ZXMiLCJyZWNvdmVyeSIsImlzVmFsaWRQcml2YXRlS2V5IiwicHVibGljS2V5Q3JlYXRlIiwiUFJJVkFURV9LRVlfQllURVMiLCJFVEhFUkVVTV9BRERSRVNTX0JZVEVTIiwiUFVCTElDX0tFWV9CWVRFUyIsIlNJR05BVFVSRV9PRkZTRVRTX1NFUklBTElaRURfU0laRSIsIlNFQ1AyNTZLMV9JTlNUUlVDVElPTl9MQVlPVVQiLCJTZWNwMjU2azFQcm9ncmFtIiwicHVibGljS2V5VG9FdGhBZGRyZXNzIiwicmVjb3ZlcnlJZCIsImNyZWF0ZUluc3RydWN0aW9uV2l0aEV0aEFkZHJlc3MiLCJldGhBZGRyZXNzIiwicmF3QWRkcmVzcyIsInN1YnN0ciIsImRhdGFTdGFydCIsImV0aEFkZHJlc3NPZmZzZXQiLCJldGhBZGRyZXNzSW5zdHJ1Y3Rpb25JbmRleCIsInBrZXkiLCJtZXNzYWdlSGFzaCIsIl9Mb2NrdXAiLCJTVEFLRV9DT05GSUdfSUQiLCJBdXRob3JpemVkIiwic3Rha2VyIiwid2l0aGRyYXdlciIsIkxvY2t1cCIsInVuaXhUaW1lc3RhbXAiLCJjdXN0b2RpYW4iLCJTdGFrZUluc3RydWN0aW9uIiwiU1RBS0VfSU5TVFJVQ1RJT05fTEFZT1VUUyIsImRlY29kZUluaXRpYWxpemUiLCJJbml0aWFsaXplIiwic3Rha2VQdWJrZXkiLCJkZWNvZGVEZWxlZ2F0ZSIsIkRlbGVnYXRlIiwiZGVjb2RlQXV0aG9yaXplIiwibmV3QXV0aG9yaXplZCIsInN0YWtlQXV0aG9yaXphdGlvblR5cGUiLCJBdXRob3JpemUiLCJvIiwiY3VzdG9kaWFuUHVia2V5IiwiZGVjb2RlQXV0aG9yaXplV2l0aFNlZWQiLCJhdXRob3JpdHlTZWVkIiwiYXV0aG9yaXR5T3duZXIiLCJBdXRob3JpemVXaXRoU2VlZCIsImF1dGhvcml0eUJhc2UiLCJkZWNvZGVTcGxpdCIsIlNwbGl0Iiwic3BsaXRTdGFrZVB1YmtleSIsImRlY29kZU1lcmdlIiwiTWVyZ2UiLCJzb3VyY2VTdGFrZVB1YktleSIsImRlY29kZVdpdGhkcmF3IiwiV2l0aGRyYXciLCJkZWNvZGVEZWFjdGl2YXRlIiwiRGVhY3RpdmF0ZSIsIlN0YWtlUHJvZ3JhbSIsIlN0YWtlQXV0aG9yaXphdGlvbkxheW91dCIsIlN0YWtlciIsIldpdGhkcmF3ZXIiLCJpbml0aWFsaXplIiwibWF5YmVMb2NrdXAiLCJkZWxlZ2F0ZSIsImF1dGhvcml6ZSIsImF1dGhvcml6ZVdpdGhTZWVkIiwic3BsaXRJbnN0cnVjdGlvbiIsInJlbnRFeGVtcHRSZXNlcnZlIiwic3BsaXRXaXRoU2VlZCIsIm1lcmdlIiwid2l0aGRyYXciLCJkZWFjdGl2YXRlIiwiVm90ZUluaXQiLCJhdXRob3JpemVkVm90ZXIiLCJhdXRob3JpemVkV2l0aGRyYXdlciIsIlZvdGVJbnN0cnVjdGlvbiIsIlZPVEVfSU5TVFJVQ1RJT05fTEFZT1VUUyIsImRlY29kZUluaXRpYWxpemVBY2NvdW50IiwiSW5pdGlhbGl6ZUFjY291bnQiLCJ2b3RlQXV0aG9yaXphdGlvblR5cGUiLCJjdXJyZW50QXV0aG9yaXR5RGVyaXZlZEtleU93bmVyUHVia2V5IiwiY3VycmVudEF1dGhvcml0eURlcml2ZWRLZXlTZWVkIiwiY3VycmVudEF1dGhvcml0eURlcml2ZWRLZXlCYXNlUHVia2V5IiwiYXV0aG9yaXplZFdpdGhkcmF3ZXJQdWJrZXkiLCJWb3RlUHJvZ3JhbSIsIlVwZGF0ZVZhbGlkYXRvcklkZW50aXR5IiwiVm90ZUF1dGhvcml6YXRpb25MYXlvdXQiLCJWb3RlciIsImluaXRpYWxpemVBY2NvdW50Iiwic2FmZVdpdGhkcmF3IiwiY3VycmVudFZvdGVBY2NvdW50QmFsYW5jZSIsInJlbnRFeGVtcHRNaW5pbXVtIiwidXBkYXRlVmFsaWRhdG9ySWRlbnRpdHkiLCJWQUxJREFUT1JfSU5GT19LRVkiLCJJbmZvU3RyaW5nIiwid2Vic2l0ZSIsImRldGFpbHMiLCJrZXliYXNlVXNlcm5hbWUiLCJWYWxpZGF0b3JJbmZvIiwiZnJvbUNvbmZpZ0RhdGEiLCJjb25maWdLZXlDb3VudCIsImNvbmZpZ0tleXMiLCJyYXdJbmZvIiwiVk9URV9QUk9HUkFNX0lEIiwiVm90ZUFjY291bnRMYXlvdXQiLCJWb3RlQWNjb3VudCIsInZvdGVzIiwiYXV0aG9yaXplZFZvdGVycyIsInByaW9yVm90ZXJzIiwibGFzdFRpbWVzdGFtcCIsInZlcnNpb25PZmZzZXQiLCJ2YSIsInJvb3RTbG90VmFsaWQiLCJwYXJzZUF1dGhvcml6ZWRWb3RlciIsImdldFByaW9yVm90ZXJzIiwicGFyc2VQcmlvclZvdGVycyIsImVwb2NoT2ZMYXN0QXV0aG9yaXplZFN3aXRjaCIsInRhcmdldEVwb2NoIiwiaWR4IiwiaXNFbXB0eSIsImh0dHAiLCJkZXZuZXQiLCJ0ZXN0bmV0IiwiaHR0cHMiLCJjbHVzdGVyQXBpVXJsIiwiY2x1c3RlciIsInRscyIsInNlbmRBbmRDb25maXJtUmF3VHJhbnNhY3Rpb24iLCJjb25maXJtYXRpb25TdHJhdGVneU9yQ29uZmlybU9wdGlvbnMiLCJtYXliZUNvbmZpcm1PcHRpb25zIiwiY29uZmlybWF0aW9uU3RyYXRlZ3kiLCJMQU1QT1JUU19QRVJfU09MIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/../anchor/node_modules/@solana/web3.js/lib/index.esm.js\n");

/***/ }),

/***/ "(ssr)/../node_modules/@solana/buffer-layout/lib/Layout.js":
/*!***********************************************************!*\
  !*** ../node_modules/@solana/buffer-layout/lib/Layout.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("/* The MIT License (MIT)\n *\n * Copyright 2015-2018 Peter A. Bigot\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n */ /**\n * Support for translating between Uint8Array instances and JavaScript\n * native types.\n *\n * {@link module:Layout~Layout|Layout} is the basis of a class\n * hierarchy that associates property names with sequences of encoded\n * bytes.\n *\n * Layouts are supported for these scalar (numeric) types:\n * * {@link module:Layout~UInt|Unsigned integers in little-endian\n *   format} with {@link module:Layout.u8|8-bit}, {@link\n *   module:Layout.u16|16-bit}, {@link module:Layout.u24|24-bit},\n *   {@link module:Layout.u32|32-bit}, {@link\n *   module:Layout.u40|40-bit}, and {@link module:Layout.u48|48-bit}\n *   representation ranges;\n * * {@link module:Layout~UIntBE|Unsigned integers in big-endian\n *   format} with {@link module:Layout.u16be|16-bit}, {@link\n *   module:Layout.u24be|24-bit}, {@link module:Layout.u32be|32-bit},\n *   {@link module:Layout.u40be|40-bit}, and {@link\n *   module:Layout.u48be|48-bit} representation ranges;\n * * {@link module:Layout~Int|Signed integers in little-endian\n *   format} with {@link module:Layout.s8|8-bit}, {@link\n *   module:Layout.s16|16-bit}, {@link module:Layout.s24|24-bit},\n *   {@link module:Layout.s32|32-bit}, {@link\n *   module:Layout.s40|40-bit}, and {@link module:Layout.s48|48-bit}\n *   representation ranges;\n * * {@link module:Layout~IntBE|Signed integers in big-endian format}\n *   with {@link module:Layout.s16be|16-bit}, {@link\n *   module:Layout.s24be|24-bit}, {@link module:Layout.s32be|32-bit},\n *   {@link module:Layout.s40be|40-bit}, and {@link\n *   module:Layout.s48be|48-bit} representation ranges;\n * * 64-bit integral values that decode to an exact (if magnitude is\n *   less than 2^53) or nearby integral Number in {@link\n *   module:Layout.nu64|unsigned little-endian}, {@link\n *   module:Layout.nu64be|unsigned big-endian}, {@link\n *   module:Layout.ns64|signed little-endian}, and {@link\n *   module:Layout.ns64be|unsigned big-endian} encodings;\n * * 32-bit floating point values with {@link\n *   module:Layout.f32|little-endian} and {@link\n *   module:Layout.f32be|big-endian} representations;\n * * 64-bit floating point values with {@link\n *   module:Layout.f64|little-endian} and {@link\n *   module:Layout.f64be|big-endian} representations;\n * * {@link module:Layout.const|Constants} that take no space in the\n *   encoded expression.\n *\n * and for these aggregate types:\n * * {@link module:Layout.seq|Sequence}s of instances of a {@link\n *   module:Layout~Layout|Layout}, with JavaScript representation as\n *   an Array and constant or data-dependent {@link\n *   module:Layout~Sequence#count|length};\n * * {@link module:Layout.struct|Structure}s that aggregate a\n *   heterogeneous sequence of {@link module:Layout~Layout|Layout}\n *   instances, with JavaScript representation as an Object;\n * * {@link module:Layout.union|Union}s that support multiple {@link\n *   module:Layout~VariantLayout|variant layouts} over a fixed\n *   (padded) or variable (not padded) span of bytes, using an\n *   unsigned integer at the start of the data or a separate {@link\n *   module:Layout.unionLayoutDiscriminator|layout element} to\n *   determine which layout to use when interpreting the buffer\n *   contents;\n * * {@link module:Layout.bits|BitStructure}s that contain a sequence\n *   of individual {@link\n *   module:Layout~BitStructure#addField|BitField}s packed into an 8,\n *   16, 24, or 32-bit unsigned integer starting at the least- or\n *   most-significant bit;\n * * {@link module:Layout.cstr|C strings} of varying length;\n * * {@link module:Layout.blob|Blobs} of fixed- or variable-{@link\n *   module:Layout~Blob#length|length} raw data.\n *\n * All {@link module:Layout~Layout|Layout} instances are immutable\n * after construction, to prevent internal state from becoming\n * inconsistent.\n *\n * @local Layout\n * @local ExternalLayout\n * @local GreedyCount\n * @local OffsetLayout\n * @local UInt\n * @local UIntBE\n * @local Int\n * @local IntBE\n * @local NearUInt64\n * @local NearUInt64BE\n * @local NearInt64\n * @local NearInt64BE\n * @local Float\n * @local FloatBE\n * @local Double\n * @local DoubleBE\n * @local Sequence\n * @local Structure\n * @local UnionDiscriminator\n * @local UnionLayoutDiscriminator\n * @local Union\n * @local VariantLayout\n * @local BitStructure\n * @local BitField\n * @local Boolean\n * @local Blob\n * @local CString\n * @local Constant\n * @local bindConstructorLayout\n * @module Layout\n * @license MIT\n * @author Peter A. Bigot\n * @see {@link https://github.com/pabigot/buffer-layout|buffer-layout on GitHub}\n */ \nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.s16 = exports.s8 = exports.nu64be = exports.u48be = exports.u40be = exports.u32be = exports.u24be = exports.u16be = exports.nu64 = exports.u48 = exports.u40 = exports.u32 = exports.u24 = exports.u16 = exports.u8 = exports.offset = exports.greedy = exports.Constant = exports.UTF8 = exports.CString = exports.Blob = exports.Boolean = exports.BitField = exports.BitStructure = exports.VariantLayout = exports.Union = exports.UnionLayoutDiscriminator = exports.UnionDiscriminator = exports.Structure = exports.Sequence = exports.DoubleBE = exports.Double = exports.FloatBE = exports.Float = exports.NearInt64BE = exports.NearInt64 = exports.NearUInt64BE = exports.NearUInt64 = exports.IntBE = exports.Int = exports.UIntBE = exports.UInt = exports.OffsetLayout = exports.GreedyCount = exports.ExternalLayout = exports.bindConstructorLayout = exports.nameWithProperty = exports.Layout = exports.uint8ArrayToBuffer = exports.checkUint8Array = void 0;\nexports.constant = exports.utf8 = exports.cstr = exports.blob = exports.unionLayoutDiscriminator = exports.union = exports.seq = exports.bits = exports.struct = exports.f64be = exports.f64 = exports.f32be = exports.f32 = exports.ns64be = exports.s48be = exports.s40be = exports.s32be = exports.s24be = exports.s16be = exports.ns64 = exports.s48 = exports.s40 = exports.s32 = exports.s24 = void 0;\nconst buffer_1 = __webpack_require__(/*! buffer */ \"buffer\");\n/* Check if a value is a Uint8Array.\n *\n * @ignore */ function checkUint8Array(b) {\n    if (!(b instanceof Uint8Array)) {\n        throw new TypeError(\"b must be a Uint8Array\");\n    }\n}\nexports.checkUint8Array = checkUint8Array;\n/* Create a Buffer instance from a Uint8Array.\n *\n * @ignore */ function uint8ArrayToBuffer(b) {\n    checkUint8Array(b);\n    return buffer_1.Buffer.from(b.buffer, b.byteOffset, b.length);\n}\nexports.uint8ArrayToBuffer = uint8ArrayToBuffer;\n/**\n * Base class for layout objects.\n *\n * **NOTE** This is an abstract base class; you can create instances\n * if it amuses you, but they won't support the {@link\n * Layout#encode|encode} or {@link Layout#decode|decode} functions.\n *\n * @param {Number} span - Initializer for {@link Layout#span|span}.  The\n * parameter must be an integer; a negative value signifies that the\n * span is {@link Layout#getSpan|value-specific}.\n *\n * @param {string} [property] - Initializer for {@link\n * Layout#property|property}.\n *\n * @abstract\n */ class Layout {\n    constructor(span, property){\n        if (!Number.isInteger(span)) {\n            throw new TypeError(\"span must be an integer\");\n        }\n        /** The span of the layout in bytes.\n         *\n         * Positive values are generally expected.\n         *\n         * Zero will only appear in {@link Constant}s and in {@link\n         * Sequence}s where the {@link Sequence#count|count} is zero.\n         *\n         * A negative value indicates that the span is value-specific, and\n         * must be obtained using {@link Layout#getSpan|getSpan}. */ this.span = span;\n        /** The property name used when this layout is represented in an\n         * Object.\n         *\n         * Used only for layouts that {@link Layout#decode|decode} to Object\n         * instances.  If left undefined the span of the unnamed layout will\n         * be treated as padding: it will not be mutated by {@link\n         * Layout#encode|encode} nor represented as a property in the\n         * decoded Object. */ this.property = property;\n    }\n    /** Function to create an Object into which decoded properties will\n     * be written.\n     *\n     * Used only for layouts that {@link Layout#decode|decode} to Object\n     * instances, which means:\n     * * {@link Structure}\n     * * {@link Union}\n     * * {@link VariantLayout}\n     * * {@link BitStructure}\n     *\n     * If left undefined the JavaScript representation of these layouts\n     * will be Object instances.\n     *\n     * See {@link bindConstructorLayout}.\n     */ makeDestinationObject() {\n        return {};\n    }\n    /**\n     * Calculate the span of a specific instance of a layout.\n     *\n     * @param {Uint8Array} b - the buffer that contains an encoded instance.\n     *\n     * @param {Number} [offset] - the offset at which the encoded instance\n     * starts.  If absent a zero offset is inferred.\n     *\n     * @return {Number} - the number of bytes covered by the layout\n     * instance.  If this method is not overridden in a subclass the\n     * definition-time constant {@link Layout#span|span} will be\n     * returned.\n     *\n     * @throws {RangeError} - if the length of the value cannot be\n     * determined.\n     */ getSpan(b, offset) {\n        if (0 > this.span) {\n            throw new RangeError(\"indeterminate span\");\n        }\n        return this.span;\n    }\n    /**\n     * Replicate the layout using a new property.\n     *\n     * This function must be used to get a structurally-equivalent layout\n     * with a different name since all {@link Layout} instances are\n     * immutable.\n     *\n     * **NOTE** This is a shallow copy.  All fields except {@link\n     * Layout#property|property} are strictly equal to the origin layout.\n     *\n     * @param {String} property - the value for {@link\n     * Layout#property|property} in the replica.\n     *\n     * @returns {Layout} - the copy with {@link Layout#property|property}\n     * set to `property`.\n     */ replicate(property) {\n        const rv = Object.create(this.constructor.prototype);\n        Object.assign(rv, this);\n        rv.property = property;\n        return rv;\n    }\n    /**\n     * Create an object from layout properties and an array of values.\n     *\n     * **NOTE** This function returns `undefined` if invoked on a layout\n     * that does not return its value as an Object.  Objects are\n     * returned for things that are a {@link Structure}, which includes\n     * {@link VariantLayout|variant layouts} if they are structures, and\n     * excludes {@link Union}s.  If you want this feature for a union\n     * you must use {@link Union.getVariant|getVariant} to select the\n     * desired layout.\n     *\n     * @param {Array} values - an array of values that correspond to the\n     * default order for properties.  As with {@link Layout#decode|decode}\n     * layout elements that have no property name are skipped when\n     * iterating over the array values.  Only the top-level properties are\n     * assigned; arguments are not assigned to properties of contained\n     * layouts.  Any unused values are ignored.\n     *\n     * @return {(Object|undefined)}\n     */ fromArray(values) {\n        return undefined;\n    }\n}\nexports.Layout = Layout;\n/* Provide text that carries a name (such as for a function that will\n * be throwing an error) annotated with the property of a given layout\n * (such as one for which the value was unacceptable).\n *\n * @ignore */ function nameWithProperty(name, lo) {\n    if (lo.property) {\n        return name + \"[\" + lo.property + \"]\";\n    }\n    return name;\n}\nexports.nameWithProperty = nameWithProperty;\n/**\n * Augment a class so that instances can be encoded/decoded using a\n * given layout.\n *\n * Calling this function couples `Class` with `layout` in several ways:\n *\n * * `Class.layout_` becomes a static member property equal to `layout`;\n * * `layout.boundConstructor_` becomes a static member property equal\n *    to `Class`;\n * * The {@link Layout#makeDestinationObject|makeDestinationObject()}\n *   property of `layout` is set to a function that returns a `new\n *   Class()`;\n * * `Class.decode(b, offset)` becomes a static member function that\n *   delegates to {@link Layout#decode|layout.decode}.  The\n *   synthesized function may be captured and extended.\n * * `Class.prototype.encode(b, offset)` provides an instance member\n *   function that delegates to {@link Layout#encode|layout.encode}\n *   with `src` set to `this`.  The synthesized function may be\n *   captured and extended, but when the extension is invoked `this`\n *   must be explicitly bound to the instance.\n *\n * @param {class} Class - a JavaScript class with a nullary\n * constructor.\n *\n * @param {Layout} layout - the {@link Layout} instance used to encode\n * instances of `Class`.\n */ // `Class` must be a constructor Function, but the assignment of a `layout_` property to it makes it difficult to type\n// eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types\nfunction bindConstructorLayout(Class, layout) {\n    if (\"function\" !== typeof Class) {\n        throw new TypeError(\"Class must be constructor\");\n    }\n    if (Object.prototype.hasOwnProperty.call(Class, \"layout_\")) {\n        throw new Error(\"Class is already bound to a layout\");\n    }\n    if (!(layout && layout instanceof Layout)) {\n        throw new TypeError(\"layout must be a Layout\");\n    }\n    if (Object.prototype.hasOwnProperty.call(layout, \"boundConstructor_\")) {\n        throw new Error(\"layout is already bound to a constructor\");\n    }\n    Class.layout_ = layout;\n    layout.boundConstructor_ = Class;\n    layout.makeDestinationObject = ()=>new Class();\n    Object.defineProperty(Class.prototype, \"encode\", {\n        value (b, offset) {\n            return layout.encode(this, b, offset);\n        },\n        writable: true\n    });\n    Object.defineProperty(Class, \"decode\", {\n        value (b, offset) {\n            return layout.decode(b, offset);\n        },\n        writable: true\n    });\n}\nexports.bindConstructorLayout = bindConstructorLayout;\n/**\n * An object that behaves like a layout but does not consume space\n * within its containing layout.\n *\n * This is primarily used to obtain metadata about a member, such as a\n * {@link OffsetLayout} that can provide data about a {@link\n * Layout#getSpan|value-specific span}.\n *\n * **NOTE** This is an abstract base class; you can create instances\n * if it amuses you, but they won't support {@link\n * ExternalLayout#isCount|isCount} or other {@link Layout} functions.\n *\n * @param {Number} span - initializer for {@link Layout#span|span}.\n * The parameter can range from 1 through 6.\n *\n * @param {string} [property] - initializer for {@link\n * Layout#property|property}.\n *\n * @abstract\n * @augments {Layout}\n */ class ExternalLayout extends Layout {\n    /**\n     * Return `true` iff the external layout decodes to an unsigned\n     * integer layout.\n     *\n     * In that case it can be used as the source of {@link\n     * Sequence#count|Sequence counts}, {@link Blob#length|Blob lengths},\n     * or as {@link UnionLayoutDiscriminator#layout|external union\n     * discriminators}.\n     *\n     * @abstract\n     */ isCount() {\n        throw new Error(\"ExternalLayout is abstract\");\n    }\n}\nexports.ExternalLayout = ExternalLayout;\n/**\n * An {@link ExternalLayout} that determines its {@link\n * Layout#decode|value} based on offset into and length of the buffer\n * on which it is invoked.\n *\n * *Factory*: {@link module:Layout.greedy|greedy}\n *\n * @param {Number} [elementSpan] - initializer for {@link\n * GreedyCount#elementSpan|elementSpan}.\n *\n * @param {string} [property] - initializer for {@link\n * Layout#property|property}.\n *\n * @augments {ExternalLayout}\n */ class GreedyCount extends ExternalLayout {\n    constructor(elementSpan = 1, property){\n        if (!Number.isInteger(elementSpan) || 0 >= elementSpan) {\n            throw new TypeError(\"elementSpan must be a (positive) integer\");\n        }\n        super(-1, property);\n        /** The layout for individual elements of the sequence.  The value\n         * must be a positive integer.  If not provided, the value will be\n         * 1. */ this.elementSpan = elementSpan;\n    }\n    /** @override */ isCount() {\n        return true;\n    }\n    /** @override */ decode(b, offset = 0) {\n        checkUint8Array(b);\n        const rem = b.length - offset;\n        return Math.floor(rem / this.elementSpan);\n    }\n    /** @override */ encode(src, b, offset) {\n        return 0;\n    }\n}\nexports.GreedyCount = GreedyCount;\n/**\n * An {@link ExternalLayout} that supports accessing a {@link Layout}\n * at a fixed offset from the start of another Layout.  The offset may\n * be before, within, or after the base layout.\n *\n * *Factory*: {@link module:Layout.offset|offset}\n *\n * @param {Layout} layout - initializer for {@link\n * OffsetLayout#layout|layout}, modulo `property`.\n *\n * @param {Number} [offset] - Initializes {@link\n * OffsetLayout#offset|offset}.  Defaults to zero.\n *\n * @param {string} [property] - Optional new property name for a\n * {@link Layout#replicate| replica} of `layout` to be used as {@link\n * OffsetLayout#layout|layout}.  If not provided the `layout` is used\n * unchanged.\n *\n * @augments {Layout}\n */ class OffsetLayout extends ExternalLayout {\n    constructor(layout, offset = 0, property){\n        if (!(layout instanceof Layout)) {\n            throw new TypeError(\"layout must be a Layout\");\n        }\n        if (!Number.isInteger(offset)) {\n            throw new TypeError(\"offset must be integer or undefined\");\n        }\n        super(layout.span, property || layout.property);\n        /** The subordinated layout. */ this.layout = layout;\n        /** The location of {@link OffsetLayout#layout} relative to the\n         * start of another layout.\n         *\n         * The value may be positive or negative, but an error will thrown\n         * if at the point of use it goes outside the span of the Uint8Array\n         * being accessed.  */ this.offset = offset;\n    }\n    /** @override */ isCount() {\n        return this.layout instanceof UInt || this.layout instanceof UIntBE;\n    }\n    /** @override */ decode(b, offset = 0) {\n        return this.layout.decode(b, offset + this.offset);\n    }\n    /** @override */ encode(src, b, offset = 0) {\n        return this.layout.encode(src, b, offset + this.offset);\n    }\n}\nexports.OffsetLayout = OffsetLayout;\n/**\n * Represent an unsigned integer in little-endian format.\n *\n * *Factory*: {@link module:Layout.u8|u8}, {@link\n *  module:Layout.u16|u16}, {@link module:Layout.u24|u24}, {@link\n *  module:Layout.u32|u32}, {@link module:Layout.u40|u40}, {@link\n *  module:Layout.u48|u48}\n *\n * @param {Number} span - initializer for {@link Layout#span|span}.\n * The parameter can range from 1 through 6.\n *\n * @param {string} [property] - initializer for {@link\n * Layout#property|property}.\n *\n * @augments {Layout}\n */ class UInt extends Layout {\n    constructor(span, property){\n        super(span, property);\n        if (6 < this.span) {\n            throw new RangeError(\"span must not exceed 6 bytes\");\n        }\n    }\n    /** @override */ decode(b, offset = 0) {\n        return uint8ArrayToBuffer(b).readUIntLE(offset, this.span);\n    }\n    /** @override */ encode(src, b, offset = 0) {\n        uint8ArrayToBuffer(b).writeUIntLE(src, offset, this.span);\n        return this.span;\n    }\n}\nexports.UInt = UInt;\n/**\n * Represent an unsigned integer in big-endian format.\n *\n * *Factory*: {@link module:Layout.u8be|u8be}, {@link\n * module:Layout.u16be|u16be}, {@link module:Layout.u24be|u24be},\n * {@link module:Layout.u32be|u32be}, {@link\n * module:Layout.u40be|u40be}, {@link module:Layout.u48be|u48be}\n *\n * @param {Number} span - initializer for {@link Layout#span|span}.\n * The parameter can range from 1 through 6.\n *\n * @param {string} [property] - initializer for {@link\n * Layout#property|property}.\n *\n * @augments {Layout}\n */ class UIntBE extends Layout {\n    constructor(span, property){\n        super(span, property);\n        if (6 < this.span) {\n            throw new RangeError(\"span must not exceed 6 bytes\");\n        }\n    }\n    /** @override */ decode(b, offset = 0) {\n        return uint8ArrayToBuffer(b).readUIntBE(offset, this.span);\n    }\n    /** @override */ encode(src, b, offset = 0) {\n        uint8ArrayToBuffer(b).writeUIntBE(src, offset, this.span);\n        return this.span;\n    }\n}\nexports.UIntBE = UIntBE;\n/**\n * Represent a signed integer in little-endian format.\n *\n * *Factory*: {@link module:Layout.s8|s8}, {@link\n *  module:Layout.s16|s16}, {@link module:Layout.s24|s24}, {@link\n *  module:Layout.s32|s32}, {@link module:Layout.s40|s40}, {@link\n *  module:Layout.s48|s48}\n *\n * @param {Number} span - initializer for {@link Layout#span|span}.\n * The parameter can range from 1 through 6.\n *\n * @param {string} [property] - initializer for {@link\n * Layout#property|property}.\n *\n * @augments {Layout}\n */ class Int extends Layout {\n    constructor(span, property){\n        super(span, property);\n        if (6 < this.span) {\n            throw new RangeError(\"span must not exceed 6 bytes\");\n        }\n    }\n    /** @override */ decode(b, offset = 0) {\n        return uint8ArrayToBuffer(b).readIntLE(offset, this.span);\n    }\n    /** @override */ encode(src, b, offset = 0) {\n        uint8ArrayToBuffer(b).writeIntLE(src, offset, this.span);\n        return this.span;\n    }\n}\nexports.Int = Int;\n/**\n * Represent a signed integer in big-endian format.\n *\n * *Factory*: {@link module:Layout.s8be|s8be}, {@link\n * module:Layout.s16be|s16be}, {@link module:Layout.s24be|s24be},\n * {@link module:Layout.s32be|s32be}, {@link\n * module:Layout.s40be|s40be}, {@link module:Layout.s48be|s48be}\n *\n * @param {Number} span - initializer for {@link Layout#span|span}.\n * The parameter can range from 1 through 6.\n *\n * @param {string} [property] - initializer for {@link\n * Layout#property|property}.\n *\n * @augments {Layout}\n */ class IntBE extends Layout {\n    constructor(span, property){\n        super(span, property);\n        if (6 < this.span) {\n            throw new RangeError(\"span must not exceed 6 bytes\");\n        }\n    }\n    /** @override */ decode(b, offset = 0) {\n        return uint8ArrayToBuffer(b).readIntBE(offset, this.span);\n    }\n    /** @override */ encode(src, b, offset = 0) {\n        uint8ArrayToBuffer(b).writeIntBE(src, offset, this.span);\n        return this.span;\n    }\n}\nexports.IntBE = IntBE;\nconst V2E32 = Math.pow(2, 32);\n/* True modulus high and low 32-bit words, where low word is always\n * non-negative. */ function divmodInt64(src) {\n    const hi32 = Math.floor(src / V2E32);\n    const lo32 = src - hi32 * V2E32;\n    return {\n        hi32,\n        lo32\n    };\n}\n/* Reconstruct Number from quotient and non-negative remainder */ function roundedInt64(hi32, lo32) {\n    return hi32 * V2E32 + lo32;\n}\n/**\n * Represent an unsigned 64-bit integer in little-endian format when\n * encoded and as a near integral JavaScript Number when decoded.\n *\n * *Factory*: {@link module:Layout.nu64|nu64}\n *\n * **NOTE** Values with magnitude greater than 2^52 may not decode to\n * the exact value of the encoded representation.\n *\n * @augments {Layout}\n */ class NearUInt64 extends Layout {\n    constructor(property){\n        super(8, property);\n    }\n    /** @override */ decode(b, offset = 0) {\n        const buffer = uint8ArrayToBuffer(b);\n        const lo32 = buffer.readUInt32LE(offset);\n        const hi32 = buffer.readUInt32LE(offset + 4);\n        return roundedInt64(hi32, lo32);\n    }\n    /** @override */ encode(src, b, offset = 0) {\n        const split = divmodInt64(src);\n        const buffer = uint8ArrayToBuffer(b);\n        buffer.writeUInt32LE(split.lo32, offset);\n        buffer.writeUInt32LE(split.hi32, offset + 4);\n        return 8;\n    }\n}\nexports.NearUInt64 = NearUInt64;\n/**\n * Represent an unsigned 64-bit integer in big-endian format when\n * encoded and as a near integral JavaScript Number when decoded.\n *\n * *Factory*: {@link module:Layout.nu64be|nu64be}\n *\n * **NOTE** Values with magnitude greater than 2^52 may not decode to\n * the exact value of the encoded representation.\n *\n * @augments {Layout}\n */ class NearUInt64BE extends Layout {\n    constructor(property){\n        super(8, property);\n    }\n    /** @override */ decode(b, offset = 0) {\n        const buffer = uint8ArrayToBuffer(b);\n        const hi32 = buffer.readUInt32BE(offset);\n        const lo32 = buffer.readUInt32BE(offset + 4);\n        return roundedInt64(hi32, lo32);\n    }\n    /** @override */ encode(src, b, offset = 0) {\n        const split = divmodInt64(src);\n        const buffer = uint8ArrayToBuffer(b);\n        buffer.writeUInt32BE(split.hi32, offset);\n        buffer.writeUInt32BE(split.lo32, offset + 4);\n        return 8;\n    }\n}\nexports.NearUInt64BE = NearUInt64BE;\n/**\n * Represent a signed 64-bit integer in little-endian format when\n * encoded and as a near integral JavaScript Number when decoded.\n *\n * *Factory*: {@link module:Layout.ns64|ns64}\n *\n * **NOTE** Values with magnitude greater than 2^52 may not decode to\n * the exact value of the encoded representation.\n *\n * @augments {Layout}\n */ class NearInt64 extends Layout {\n    constructor(property){\n        super(8, property);\n    }\n    /** @override */ decode(b, offset = 0) {\n        const buffer = uint8ArrayToBuffer(b);\n        const lo32 = buffer.readUInt32LE(offset);\n        const hi32 = buffer.readInt32LE(offset + 4);\n        return roundedInt64(hi32, lo32);\n    }\n    /** @override */ encode(src, b, offset = 0) {\n        const split = divmodInt64(src);\n        const buffer = uint8ArrayToBuffer(b);\n        buffer.writeUInt32LE(split.lo32, offset);\n        buffer.writeInt32LE(split.hi32, offset + 4);\n        return 8;\n    }\n}\nexports.NearInt64 = NearInt64;\n/**\n * Represent a signed 64-bit integer in big-endian format when\n * encoded and as a near integral JavaScript Number when decoded.\n *\n * *Factory*: {@link module:Layout.ns64be|ns64be}\n *\n * **NOTE** Values with magnitude greater than 2^52 may not decode to\n * the exact value of the encoded representation.\n *\n * @augments {Layout}\n */ class NearInt64BE extends Layout {\n    constructor(property){\n        super(8, property);\n    }\n    /** @override */ decode(b, offset = 0) {\n        const buffer = uint8ArrayToBuffer(b);\n        const hi32 = buffer.readInt32BE(offset);\n        const lo32 = buffer.readUInt32BE(offset + 4);\n        return roundedInt64(hi32, lo32);\n    }\n    /** @override */ encode(src, b, offset = 0) {\n        const split = divmodInt64(src);\n        const buffer = uint8ArrayToBuffer(b);\n        buffer.writeInt32BE(split.hi32, offset);\n        buffer.writeUInt32BE(split.lo32, offset + 4);\n        return 8;\n    }\n}\nexports.NearInt64BE = NearInt64BE;\n/**\n * Represent a 32-bit floating point number in little-endian format.\n *\n * *Factory*: {@link module:Layout.f32|f32}\n *\n * @param {string} [property] - initializer for {@link\n * Layout#property|property}.\n *\n * @augments {Layout}\n */ class Float extends Layout {\n    constructor(property){\n        super(4, property);\n    }\n    /** @override */ decode(b, offset = 0) {\n        return uint8ArrayToBuffer(b).readFloatLE(offset);\n    }\n    /** @override */ encode(src, b, offset = 0) {\n        uint8ArrayToBuffer(b).writeFloatLE(src, offset);\n        return 4;\n    }\n}\nexports.Float = Float;\n/**\n * Represent a 32-bit floating point number in big-endian format.\n *\n * *Factory*: {@link module:Layout.f32be|f32be}\n *\n * @param {string} [property] - initializer for {@link\n * Layout#property|property}.\n *\n * @augments {Layout}\n */ class FloatBE extends Layout {\n    constructor(property){\n        super(4, property);\n    }\n    /** @override */ decode(b, offset = 0) {\n        return uint8ArrayToBuffer(b).readFloatBE(offset);\n    }\n    /** @override */ encode(src, b, offset = 0) {\n        uint8ArrayToBuffer(b).writeFloatBE(src, offset);\n        return 4;\n    }\n}\nexports.FloatBE = FloatBE;\n/**\n * Represent a 64-bit floating point number in little-endian format.\n *\n * *Factory*: {@link module:Layout.f64|f64}\n *\n * @param {string} [property] - initializer for {@link\n * Layout#property|property}.\n *\n * @augments {Layout}\n */ class Double extends Layout {\n    constructor(property){\n        super(8, property);\n    }\n    /** @override */ decode(b, offset = 0) {\n        return uint8ArrayToBuffer(b).readDoubleLE(offset);\n    }\n    /** @override */ encode(src, b, offset = 0) {\n        uint8ArrayToBuffer(b).writeDoubleLE(src, offset);\n        return 8;\n    }\n}\nexports.Double = Double;\n/**\n * Represent a 64-bit floating point number in big-endian format.\n *\n * *Factory*: {@link module:Layout.f64be|f64be}\n *\n * @param {string} [property] - initializer for {@link\n * Layout#property|property}.\n *\n * @augments {Layout}\n */ class DoubleBE extends Layout {\n    constructor(property){\n        super(8, property);\n    }\n    /** @override */ decode(b, offset = 0) {\n        return uint8ArrayToBuffer(b).readDoubleBE(offset);\n    }\n    /** @override */ encode(src, b, offset = 0) {\n        uint8ArrayToBuffer(b).writeDoubleBE(src, offset);\n        return 8;\n    }\n}\nexports.DoubleBE = DoubleBE;\n/**\n * Represent a contiguous sequence of a specific layout as an Array.\n *\n * *Factory*: {@link module:Layout.seq|seq}\n *\n * @param {Layout} elementLayout - initializer for {@link\n * Sequence#elementLayout|elementLayout}.\n *\n * @param {(Number|ExternalLayout)} count - initializer for {@link\n * Sequence#count|count}.  The parameter must be either a positive\n * integer or an instance of {@link ExternalLayout}.\n *\n * @param {string} [property] - initializer for {@link\n * Layout#property|property}.\n *\n * @augments {Layout}\n */ class Sequence extends Layout {\n    constructor(elementLayout, count, property){\n        if (!(elementLayout instanceof Layout)) {\n            throw new TypeError(\"elementLayout must be a Layout\");\n        }\n        if (!(count instanceof ExternalLayout && count.isCount() || Number.isInteger(count) && 0 <= count)) {\n            throw new TypeError(\"count must be non-negative integer \" + \"or an unsigned integer ExternalLayout\");\n        }\n        let span = -1;\n        if (!(count instanceof ExternalLayout) && 0 < elementLayout.span) {\n            span = count * elementLayout.span;\n        }\n        super(span, property);\n        /** The layout for individual elements of the sequence. */ this.elementLayout = elementLayout;\n        /** The number of elements in the sequence.\n         *\n         * This will be either a non-negative integer or an instance of\n         * {@link ExternalLayout} for which {@link\n         * ExternalLayout#isCount|isCount()} is `true`. */ this.count = count;\n    }\n    /** @override */ getSpan(b, offset = 0) {\n        if (0 <= this.span) {\n            return this.span;\n        }\n        let span = 0;\n        let count = this.count;\n        if (count instanceof ExternalLayout) {\n            count = count.decode(b, offset);\n        }\n        if (0 < this.elementLayout.span) {\n            span = count * this.elementLayout.span;\n        } else {\n            let idx = 0;\n            while(idx < count){\n                span += this.elementLayout.getSpan(b, offset + span);\n                ++idx;\n            }\n        }\n        return span;\n    }\n    /** @override */ decode(b, offset = 0) {\n        const rv = [];\n        let i = 0;\n        let count = this.count;\n        if (count instanceof ExternalLayout) {\n            count = count.decode(b, offset);\n        }\n        while(i < count){\n            rv.push(this.elementLayout.decode(b, offset));\n            offset += this.elementLayout.getSpan(b, offset);\n            i += 1;\n        }\n        return rv;\n    }\n    /** Implement {@link Layout#encode|encode} for {@link Sequence}.\n     *\n     * **NOTE** If `src` is shorter than {@link Sequence#count|count} then\n     * the unused space in the buffer is left unchanged.  If `src` is\n     * longer than {@link Sequence#count|count} the unneeded elements are\n     * ignored.\n     *\n     * **NOTE** If {@link Layout#count|count} is an instance of {@link\n     * ExternalLayout} then the length of `src` will be encoded as the\n     * count after `src` is encoded. */ encode(src, b, offset = 0) {\n        const elo = this.elementLayout;\n        const span = src.reduce((span, v)=>{\n            return span + elo.encode(v, b, offset + span);\n        }, 0);\n        if (this.count instanceof ExternalLayout) {\n            this.count.encode(src.length, b, offset);\n        }\n        return span;\n    }\n}\nexports.Sequence = Sequence;\n/**\n * Represent a contiguous sequence of arbitrary layout elements as an\n * Object.\n *\n * *Factory*: {@link module:Layout.struct|struct}\n *\n * **NOTE** The {@link Layout#span|span} of the structure is variable\n * if any layout in {@link Structure#fields|fields} has a variable\n * span.  When {@link Layout#encode|encoding} we must have a value for\n * all variable-length fields, or we wouldn't be able to figure out\n * how much space to use for storage.  We can only identify the value\n * for a field when it has a {@link Layout#property|property}.  As\n * such, although a structure may contain both unnamed fields and\n * variable-length fields, it cannot contain an unnamed\n * variable-length field.\n *\n * @param {Layout[]} fields - initializer for {@link\n * Structure#fields|fields}.  An error is raised if this contains a\n * variable-length field for which a {@link Layout#property|property}\n * is not defined.\n *\n * @param {string} [property] - initializer for {@link\n * Layout#property|property}.\n *\n * @param {Boolean} [decodePrefixes] - initializer for {@link\n * Structure#decodePrefixes|property}.\n *\n * @throws {Error} - if `fields` contains an unnamed variable-length\n * layout.\n *\n * @augments {Layout}\n */ class Structure extends Layout {\n    constructor(fields, property, decodePrefixes){\n        if (!(Array.isArray(fields) && fields.reduce((acc, v)=>acc && v instanceof Layout, true))) {\n            throw new TypeError(\"fields must be array of Layout instances\");\n        }\n        if (\"boolean\" === typeof property && undefined === decodePrefixes) {\n            decodePrefixes = property;\n            property = undefined;\n        }\n        /* Verify absence of unnamed variable-length fields. */ for (const fd of fields){\n            if (0 > fd.span && undefined === fd.property) {\n                throw new Error(\"fields cannot contain unnamed variable-length layout\");\n            }\n        }\n        let span = -1;\n        try {\n            span = fields.reduce((span, fd)=>span + fd.getSpan(), 0);\n        } catch (e) {\n        // ignore error\n        }\n        super(span, property);\n        /** The sequence of {@link Layout} values that comprise the\n         * structure.\n         *\n         * The individual elements need not be the same type, and may be\n         * either scalar or aggregate layouts.  If a member layout leaves\n         * its {@link Layout#property|property} undefined the\n         * corresponding region of the buffer associated with the element\n         * will not be mutated.\n         *\n         * @type {Layout[]} */ this.fields = fields;\n        /** Control behavior of {@link Layout#decode|decode()} given short\n         * buffers.\n         *\n         * In some situations a structure many be extended with additional\n         * fields over time, with older installations providing only a\n         * prefix of the full structure.  If this property is `true`\n         * decoding will accept those buffers and leave subsequent fields\n         * undefined, as long as the buffer ends at a field boundary.\n         * Defaults to `false`. */ this.decodePrefixes = !!decodePrefixes;\n    }\n    /** @override */ getSpan(b, offset = 0) {\n        if (0 <= this.span) {\n            return this.span;\n        }\n        let span = 0;\n        try {\n            span = this.fields.reduce((span, fd)=>{\n                const fsp = fd.getSpan(b, offset);\n                offset += fsp;\n                return span + fsp;\n            }, 0);\n        } catch (e) {\n            throw new RangeError(\"indeterminate span\");\n        }\n        return span;\n    }\n    /** @override */ decode(b, offset = 0) {\n        checkUint8Array(b);\n        const dest = this.makeDestinationObject();\n        for (const fd of this.fields){\n            if (undefined !== fd.property) {\n                dest[fd.property] = fd.decode(b, offset);\n            }\n            offset += fd.getSpan(b, offset);\n            if (this.decodePrefixes && b.length === offset) {\n                break;\n            }\n        }\n        return dest;\n    }\n    /** Implement {@link Layout#encode|encode} for {@link Structure}.\n     *\n     * If `src` is missing a property for a member with a defined {@link\n     * Layout#property|property} the corresponding region of the buffer is\n     * left unmodified. */ encode(src, b, offset = 0) {\n        const firstOffset = offset;\n        let lastOffset = 0;\n        let lastWrote = 0;\n        for (const fd of this.fields){\n            let span = fd.span;\n            lastWrote = 0 < span ? span : 0;\n            if (undefined !== fd.property) {\n                const fv = src[fd.property];\n                if (undefined !== fv) {\n                    lastWrote = fd.encode(fv, b, offset);\n                    if (0 > span) {\n                        /* Read the as-encoded span, which is not necessarily the\n                         * same as what we wrote. */ span = fd.getSpan(b, offset);\n                    }\n                }\n            }\n            lastOffset = offset;\n            offset += span;\n        }\n        /* Use (lastOffset + lastWrote) instead of offset because the last\n         * item may have had a dynamic length and we don't want to include\n         * the padding between it and the end of the space reserved for\n         * it. */ return lastOffset + lastWrote - firstOffset;\n    }\n    /** @override */ fromArray(values) {\n        const dest = this.makeDestinationObject();\n        for (const fd of this.fields){\n            if (undefined !== fd.property && 0 < values.length) {\n                dest[fd.property] = values.shift();\n            }\n        }\n        return dest;\n    }\n    /**\n     * Get access to the layout of a given property.\n     *\n     * @param {String} property - the structure member of interest.\n     *\n     * @return {Layout} - the layout associated with `property`, or\n     * undefined if there is no such property.\n     */ layoutFor(property) {\n        if (\"string\" !== typeof property) {\n            throw new TypeError(\"property must be string\");\n        }\n        for (const fd of this.fields){\n            if (fd.property === property) {\n                return fd;\n            }\n        }\n        return undefined;\n    }\n    /**\n     * Get the offset of a structure member.\n     *\n     * @param {String} property - the structure member of interest.\n     *\n     * @return {Number} - the offset in bytes to the start of `property`\n     * within the structure, or undefined if `property` is not a field\n     * within the structure.  If the property is a member but follows a\n     * variable-length structure member a negative number will be\n     * returned.\n     */ offsetOf(property) {\n        if (\"string\" !== typeof property) {\n            throw new TypeError(\"property must be string\");\n        }\n        let offset = 0;\n        for (const fd of this.fields){\n            if (fd.property === property) {\n                return offset;\n            }\n            if (0 > fd.span) {\n                offset = -1;\n            } else if (0 <= offset) {\n                offset += fd.span;\n            }\n        }\n        return undefined;\n    }\n}\nexports.Structure = Structure;\n/**\n * An object that can provide a {@link\n * Union#discriminator|discriminator} API for {@link Union}.\n *\n * **NOTE** This is an abstract base class; you can create instances\n * if it amuses you, but they won't support the {@link\n * UnionDiscriminator#encode|encode} or {@link\n * UnionDiscriminator#decode|decode} functions.\n *\n * @param {string} [property] - Default for {@link\n * UnionDiscriminator#property|property}.\n *\n * @abstract\n */ class UnionDiscriminator {\n    constructor(property){\n        /** The {@link Layout#property|property} to be used when the\n         * discriminator is referenced in isolation (generally when {@link\n         * Union#decode|Union decode} cannot delegate to a specific\n         * variant). */ this.property = property;\n    }\n    /** Analog to {@link Layout#decode|Layout decode} for union discriminators.\n     *\n     * The implementation of this method need not reference the buffer if\n     * variant information is available through other means. */ decode(b, offset) {\n        throw new Error(\"UnionDiscriminator is abstract\");\n    }\n    /** Analog to {@link Layout#decode|Layout encode} for union discriminators.\n     *\n     * The implementation of this method need not store the value if\n     * variant information is maintained through other means. */ encode(src, b, offset) {\n        throw new Error(\"UnionDiscriminator is abstract\");\n    }\n}\nexports.UnionDiscriminator = UnionDiscriminator;\n/**\n * An object that can provide a {@link\n * UnionDiscriminator|discriminator API} for {@link Union} using an\n * unsigned integral {@link Layout} instance located either inside or\n * outside the union.\n *\n * @param {ExternalLayout} layout - initializes {@link\n * UnionLayoutDiscriminator#layout|layout}.  Must satisfy {@link\n * ExternalLayout#isCount|isCount()}.\n *\n * @param {string} [property] - Default for {@link\n * UnionDiscriminator#property|property}, superseding the property\n * from `layout`, but defaulting to `variant` if neither `property`\n * nor layout provide a property name.\n *\n * @augments {UnionDiscriminator}\n */ class UnionLayoutDiscriminator extends UnionDiscriminator {\n    constructor(layout, property){\n        if (!(layout instanceof ExternalLayout && layout.isCount())) {\n            throw new TypeError(\"layout must be an unsigned integer ExternalLayout\");\n        }\n        super(property || layout.property || \"variant\");\n        /** The {@link ExternalLayout} used to access the discriminator\n         * value. */ this.layout = layout;\n    }\n    /** Delegate decoding to {@link UnionLayoutDiscriminator#layout|layout}. */ decode(b, offset) {\n        return this.layout.decode(b, offset);\n    }\n    /** Delegate encoding to {@link UnionLayoutDiscriminator#layout|layout}. */ encode(src, b, offset) {\n        return this.layout.encode(src, b, offset);\n    }\n}\nexports.UnionLayoutDiscriminator = UnionLayoutDiscriminator;\n/**\n * Represent any number of span-compatible layouts.\n *\n * *Factory*: {@link module:Layout.union|union}\n *\n * If the union has a {@link Union#defaultLayout|default layout} that\n * layout must have a non-negative {@link Layout#span|span}.  The span\n * of a fixed-span union includes its {@link\n * Union#discriminator|discriminator} if the variant is a {@link\n * Union#usesPrefixDiscriminator|prefix of the union}, plus the span\n * of its {@link Union#defaultLayout|default layout}.\n *\n * If the union does not have a default layout then the encoded span\n * of the union depends on the encoded span of its variant (which may\n * be fixed or variable).\n *\n * {@link VariantLayout#layout|Variant layout}s are added through\n * {@link Union#addVariant|addVariant}.  If the union has a default\n * layout, the span of the {@link VariantLayout#layout|layout\n * contained by the variant} must not exceed the span of the {@link\n * Union#defaultLayout|default layout} (minus the span of a {@link\n * Union#usesPrefixDiscriminator|prefix disriminator}, if used).  The\n * span of the variant will equal the span of the union itself.\n *\n * The variant for a buffer can only be identified from the {@link\n * Union#discriminator|discriminator} {@link\n * UnionDiscriminator#property|property} (in the case of the {@link\n * Union#defaultLayout|default layout}), or by using {@link\n * Union#getVariant|getVariant} and examining the resulting {@link\n * VariantLayout} instance.\n *\n * A variant compatible with a JavaScript object can be identified\n * using {@link Union#getSourceVariant|getSourceVariant}.\n *\n * @param {(UnionDiscriminator|ExternalLayout|Layout)} discr - How to\n * identify the layout used to interpret the union contents.  The\n * parameter must be an instance of {@link UnionDiscriminator}, an\n * {@link ExternalLayout} that satisfies {@link\n * ExternalLayout#isCount|isCount()}, or {@link UInt} (or {@link\n * UIntBE}).  When a non-external layout element is passed the layout\n * appears at the start of the union.  In all cases the (synthesized)\n * {@link UnionDiscriminator} instance is recorded as {@link\n * Union#discriminator|discriminator}.\n *\n * @param {(Layout|null)} defaultLayout - initializer for {@link\n * Union#defaultLayout|defaultLayout}.  If absent defaults to `null`.\n * If `null` there is no default layout: the union has data-dependent\n * length and attempts to decode or encode unrecognized variants will\n * throw an exception.  A {@link Layout} instance must have a\n * non-negative {@link Layout#span|span}, and if it lacks a {@link\n * Layout#property|property} the {@link\n * Union#defaultLayout|defaultLayout} will be a {@link\n * Layout#replicate|replica} with property `content`.\n *\n * @param {string} [property] - initializer for {@link\n * Layout#property|property}.\n *\n * @augments {Layout}\n */ class Union extends Layout {\n    constructor(discr, defaultLayout, property){\n        let discriminator;\n        if (discr instanceof UInt || discr instanceof UIntBE) {\n            discriminator = new UnionLayoutDiscriminator(new OffsetLayout(discr));\n        } else if (discr instanceof ExternalLayout && discr.isCount()) {\n            discriminator = new UnionLayoutDiscriminator(discr);\n        } else if (!(discr instanceof UnionDiscriminator)) {\n            throw new TypeError(\"discr must be a UnionDiscriminator \" + \"or an unsigned integer layout\");\n        } else {\n            discriminator = discr;\n        }\n        if (undefined === defaultLayout) {\n            defaultLayout = null;\n        }\n        if (!(null === defaultLayout || defaultLayout instanceof Layout)) {\n            throw new TypeError(\"defaultLayout must be null or a Layout\");\n        }\n        if (null !== defaultLayout) {\n            if (0 > defaultLayout.span) {\n                throw new Error(\"defaultLayout must have constant span\");\n            }\n            if (undefined === defaultLayout.property) {\n                defaultLayout = defaultLayout.replicate(\"content\");\n            }\n        }\n        /* The union span can be estimated only if there's a default\n         * layout.  The union spans its default layout, plus any prefix\n         * variant layout.  By construction both layouts, if present, have\n         * non-negative span. */ let span = -1;\n        if (defaultLayout) {\n            span = defaultLayout.span;\n            if (0 <= span && (discr instanceof UInt || discr instanceof UIntBE)) {\n                span += discriminator.layout.span;\n            }\n        }\n        super(span, property);\n        /** The interface for the discriminator value in isolation.\n         *\n         * This a {@link UnionDiscriminator} either passed to the\n         * constructor or synthesized from the `discr` constructor\n         * argument.  {@link\n         * Union#usesPrefixDiscriminator|usesPrefixDiscriminator} will be\n         * `true` iff the `discr` parameter was a non-offset {@link\n         * Layout} instance. */ this.discriminator = discriminator;\n        /** `true` if the {@link Union#discriminator|discriminator} is the\n         * first field in the union.\n         *\n         * If `false` the discriminator is obtained from somewhere\n         * else. */ this.usesPrefixDiscriminator = discr instanceof UInt || discr instanceof UIntBE;\n        /** The layout for non-discriminator content when the value of the\n         * discriminator is not recognized.\n         *\n         * This is the value passed to the constructor.  It is\n         * structurally equivalent to the second component of {@link\n         * Union#layout|layout} but may have a different property\n         * name. */ this.defaultLayout = defaultLayout;\n        /** A registry of allowed variants.\n         *\n         * The keys are unsigned integers which should be compatible with\n         * {@link Union.discriminator|discriminator}.  The property value\n         * is the corresponding {@link VariantLayout} instances assigned\n         * to this union by {@link Union#addVariant|addVariant}.\n         *\n         * **NOTE** The registry remains mutable so that variants can be\n         * {@link Union#addVariant|added} at any time.  Users should not\n         * manipulate the content of this property. */ this.registry = {};\n        /* Private variable used when invoking getSourceVariant */ let boundGetSourceVariant = this.defaultGetSourceVariant.bind(this);\n        /** Function to infer the variant selected by a source object.\n         *\n         * Defaults to {@link\n         * Union#defaultGetSourceVariant|defaultGetSourceVariant} but may\n         * be overridden using {@link\n         * Union#configGetSourceVariant|configGetSourceVariant}.\n         *\n         * @param {Object} src - as with {@link\n         * Union#defaultGetSourceVariant|defaultGetSourceVariant}.\n         *\n         * @returns {(undefined|VariantLayout)} The default variant\n         * (`undefined`) or first registered variant that uses a property\n         * available in `src`. */ this.getSourceVariant = function(src) {\n            return boundGetSourceVariant(src);\n        };\n        /** Function to override the implementation of {@link\n         * Union#getSourceVariant|getSourceVariant}.\n         *\n         * Use this if the desired variant cannot be identified using the\n         * algorithm of {@link\n         * Union#defaultGetSourceVariant|defaultGetSourceVariant}.\n         *\n         * **NOTE** The provided function will be invoked bound to this\n         * Union instance, providing local access to {@link\n         * Union#registry|registry}.\n         *\n         * @param {Function} gsv - a function that follows the API of\n         * {@link Union#defaultGetSourceVariant|defaultGetSourceVariant}. */ this.configGetSourceVariant = function(gsv) {\n            boundGetSourceVariant = gsv.bind(this);\n        };\n    }\n    /** @override */ getSpan(b, offset = 0) {\n        if (0 <= this.span) {\n            return this.span;\n        }\n        /* Default layouts always have non-negative span, so we don't have\n         * one and we have to recognize the variant which will in turn\n         * determine the span. */ const vlo = this.getVariant(b, offset);\n        if (!vlo) {\n            throw new Error(\"unable to determine span for unrecognized variant\");\n        }\n        return vlo.getSpan(b, offset);\n    }\n    /**\n     * Method to infer a registered Union variant compatible with `src`.\n     *\n     * The first satisfied rule in the following sequence defines the\n     * return value:\n     * * If `src` has properties matching the Union discriminator and\n     *   the default layout, `undefined` is returned regardless of the\n     *   value of the discriminator property (this ensures the default\n     *   layout will be used);\n     * * If `src` has a property matching the Union discriminator, the\n     *   value of the discriminator identifies a registered variant, and\n     *   either (a) the variant has no layout, or (b) `src` has the\n     *   variant's property, then the variant is returned (because the\n     *   source satisfies the constraints of the variant it identifies);\n     * * If `src` does not have a property matching the Union\n     *   discriminator, but does have a property matching a registered\n     *   variant, then the variant is returned (because the source\n     *   matches a variant without an explicit conflict);\n     * * An error is thrown (because we either can't identify a variant,\n     *   or we were explicitly told the variant but can't satisfy it).\n     *\n     * @param {Object} src - an object presumed to be compatible with\n     * the content of the Union.\n     *\n     * @return {(undefined|VariantLayout)} - as described above.\n     *\n     * @throws {Error} - if `src` cannot be associated with a default or\n     * registered variant.\n     */ defaultGetSourceVariant(src) {\n        if (Object.prototype.hasOwnProperty.call(src, this.discriminator.property)) {\n            if (this.defaultLayout && this.defaultLayout.property && Object.prototype.hasOwnProperty.call(src, this.defaultLayout.property)) {\n                return undefined;\n            }\n            const vlo = this.registry[src[this.discriminator.property]];\n            if (vlo && (!vlo.layout || vlo.property && Object.prototype.hasOwnProperty.call(src, vlo.property))) {\n                return vlo;\n            }\n        } else {\n            for(const tag in this.registry){\n                const vlo = this.registry[tag];\n                if (vlo.property && Object.prototype.hasOwnProperty.call(src, vlo.property)) {\n                    return vlo;\n                }\n            }\n        }\n        throw new Error(\"unable to infer src variant\");\n    }\n    /** Implement {@link Layout#decode|decode} for {@link Union}.\n     *\n     * If the variant is {@link Union#addVariant|registered} the return\n     * value is an instance of that variant, with no explicit\n     * discriminator.  Otherwise the {@link Union#defaultLayout|default\n     * layout} is used to decode the content. */ decode(b, offset = 0) {\n        let dest;\n        const dlo = this.discriminator;\n        const discr = dlo.decode(b, offset);\n        const clo = this.registry[discr];\n        if (undefined === clo) {\n            const defaultLayout = this.defaultLayout;\n            let contentOffset = 0;\n            if (this.usesPrefixDiscriminator) {\n                contentOffset = dlo.layout.span;\n            }\n            dest = this.makeDestinationObject();\n            dest[dlo.property] = discr;\n            // defaultLayout.property can be undefined, but this is allowed by buffer-layout\n            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n            dest[defaultLayout.property] = defaultLayout.decode(b, offset + contentOffset);\n        } else {\n            dest = clo.decode(b, offset);\n        }\n        return dest;\n    }\n    /** Implement {@link Layout#encode|encode} for {@link Union}.\n     *\n     * This API assumes the `src` object is consistent with the union's\n     * {@link Union#defaultLayout|default layout}.  To encode variants\n     * use the appropriate variant-specific {@link VariantLayout#encode}\n     * method. */ encode(src, b, offset = 0) {\n        const vlo = this.getSourceVariant(src);\n        if (undefined === vlo) {\n            const dlo = this.discriminator;\n            // this.defaultLayout is not undefined when vlo is undefined\n            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n            const clo = this.defaultLayout;\n            let contentOffset = 0;\n            if (this.usesPrefixDiscriminator) {\n                contentOffset = dlo.layout.span;\n            }\n            dlo.encode(src[dlo.property], b, offset);\n            // clo.property is not undefined when vlo is undefined\n            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n            return contentOffset + clo.encode(src[clo.property], b, offset + contentOffset);\n        }\n        return vlo.encode(src, b, offset);\n    }\n    /** Register a new variant structure within a union.  The newly\n     * created variant is returned.\n     *\n     * @param {Number} variant - initializer for {@link\n     * VariantLayout#variant|variant}.\n     *\n     * @param {Layout} layout - initializer for {@link\n     * VariantLayout#layout|layout}.\n     *\n     * @param {String} property - initializer for {@link\n     * Layout#property|property}.\n     *\n     * @return {VariantLayout} */ addVariant(variant, layout, property) {\n        const rv = new VariantLayout(this, variant, layout, property);\n        this.registry[variant] = rv;\n        return rv;\n    }\n    /**\n     * Get the layout associated with a registered variant.\n     *\n     * If `vb` does not produce a registered variant the function returns\n     * `undefined`.\n     *\n     * @param {(Number|Uint8Array)} vb - either the variant number, or a\n     * buffer from which the discriminator is to be read.\n     *\n     * @param {Number} offset - offset into `vb` for the start of the\n     * union.  Used only when `vb` is an instance of {Uint8Array}.\n     *\n     * @return {({VariantLayout}|undefined)}\n     */ getVariant(vb, offset = 0) {\n        let variant;\n        if (vb instanceof Uint8Array) {\n            variant = this.discriminator.decode(vb, offset);\n        } else {\n            variant = vb;\n        }\n        return this.registry[variant];\n    }\n}\nexports.Union = Union;\n/**\n * Represent a specific variant within a containing union.\n *\n * **NOTE** The {@link Layout#span|span} of the variant may include\n * the span of the {@link Union#discriminator|discriminator} used to\n * identify it, but values read and written using the variant strictly\n * conform to the content of {@link VariantLayout#layout|layout}.\n *\n * **NOTE** User code should not invoke this constructor directly.  Use\n * the union {@link Union#addVariant|addVariant} helper method.\n *\n * @param {Union} union - initializer for {@link\n * VariantLayout#union|union}.\n *\n * @param {Number} variant - initializer for {@link\n * VariantLayout#variant|variant}.\n *\n * @param {Layout} [layout] - initializer for {@link\n * VariantLayout#layout|layout}.  If absent the variant carries no\n * data.\n *\n * @param {String} [property] - initializer for {@link\n * Layout#property|property}.  Unlike many other layouts, variant\n * layouts normally include a property name so they can be identified\n * within their containing {@link Union}.  The property identifier may\n * be absent only if `layout` is is absent.\n *\n * @augments {Layout}\n */ class VariantLayout extends Layout {\n    constructor(union, variant, layout, property){\n        if (!(union instanceof Union)) {\n            throw new TypeError(\"union must be a Union\");\n        }\n        if (!Number.isInteger(variant) || 0 > variant) {\n            throw new TypeError(\"variant must be a (non-negative) integer\");\n        }\n        if (\"string\" === typeof layout && undefined === property) {\n            property = layout;\n            layout = null;\n        }\n        if (layout) {\n            if (!(layout instanceof Layout)) {\n                throw new TypeError(\"layout must be a Layout\");\n            }\n            if (null !== union.defaultLayout && 0 <= layout.span && layout.span > union.defaultLayout.span) {\n                throw new Error(\"variant span exceeds span of containing union\");\n            }\n            if (\"string\" !== typeof property) {\n                throw new TypeError(\"variant must have a String property\");\n            }\n        }\n        let span = union.span;\n        if (0 > union.span) {\n            span = layout ? layout.span : 0;\n            if (0 <= span && union.usesPrefixDiscriminator) {\n                span += union.discriminator.layout.span;\n            }\n        }\n        super(span, property);\n        /** The {@link Union} to which this variant belongs. */ this.union = union;\n        /** The unsigned integral value identifying this variant within\n         * the {@link Union#discriminator|discriminator} of the containing\n         * union. */ this.variant = variant;\n        /** The {@link Layout} to be used when reading/writing the\n         * non-discriminator part of the {@link\n         * VariantLayout#union|union}.  If `null` the variant carries no\n         * data. */ this.layout = layout || null;\n    }\n    /** @override */ getSpan(b, offset = 0) {\n        if (0 <= this.span) {\n            /* Will be equal to the containing union span if that is not\n             * variable. */ return this.span;\n        }\n        let contentOffset = 0;\n        if (this.union.usesPrefixDiscriminator) {\n            contentOffset = this.union.discriminator.layout.span;\n        }\n        /* Span is defined solely by the variant (and prefix discriminator) */ let span = 0;\n        if (this.layout) {\n            span = this.layout.getSpan(b, offset + contentOffset);\n        }\n        return contentOffset + span;\n    }\n    /** @override */ decode(b, offset = 0) {\n        const dest = this.makeDestinationObject();\n        if (this !== this.union.getVariant(b, offset)) {\n            throw new Error(\"variant mismatch\");\n        }\n        let contentOffset = 0;\n        if (this.union.usesPrefixDiscriminator) {\n            contentOffset = this.union.discriminator.layout.span;\n        }\n        if (this.layout) {\n            dest[this.property] = this.layout.decode(b, offset + contentOffset);\n        } else if (this.property) {\n            dest[this.property] = true;\n        } else if (this.union.usesPrefixDiscriminator) {\n            dest[this.union.discriminator.property] = this.variant;\n        }\n        return dest;\n    }\n    /** @override */ encode(src, b, offset = 0) {\n        let contentOffset = 0;\n        if (this.union.usesPrefixDiscriminator) {\n            contentOffset = this.union.discriminator.layout.span;\n        }\n        if (this.layout && !Object.prototype.hasOwnProperty.call(src, this.property)) {\n            throw new TypeError(\"variant lacks property \" + this.property);\n        }\n        this.union.discriminator.encode(this.variant, b, offset);\n        let span = contentOffset;\n        if (this.layout) {\n            this.layout.encode(src[this.property], b, offset + contentOffset);\n            span += this.layout.getSpan(b, offset + contentOffset);\n            if (0 <= this.union.span && span > this.union.span) {\n                throw new Error(\"encoded variant overruns containing union\");\n            }\n        }\n        return span;\n    }\n    /** Delegate {@link Layout#fromArray|fromArray} to {@link\n     * VariantLayout#layout|layout}. */ fromArray(values) {\n        if (this.layout) {\n            return this.layout.fromArray(values);\n        }\n        return undefined;\n    }\n}\nexports.VariantLayout = VariantLayout;\n/** JavaScript chose to define bitwise operations as operating on\n * signed 32-bit values in 2's complement form, meaning any integer\n * with bit 31 set is going to look negative.  For right shifts that's\n * not a problem, because `>>>` is a logical shift, but for every\n * other bitwise operator we have to compensate for possible negative\n * results. */ function fixBitwiseResult(v) {\n    if (0 > v) {\n        v += 0x100000000;\n    }\n    return v;\n}\n/**\n * Contain a sequence of bit fields as an unsigned integer.\n *\n * *Factory*: {@link module:Layout.bits|bits}\n *\n * This is a container element; within it there are {@link BitField}\n * instances that provide the extracted properties.  The container\n * simply defines the aggregate representation and its bit ordering.\n * The representation is an object containing properties with numeric\n * or {@link Boolean} values.\n *\n * {@link BitField}s are added with the {@link\n * BitStructure#addField|addField} and {@link\n * BitStructure#addBoolean|addBoolean} methods.\n\n * @param {Layout} word - initializer for {@link\n * BitStructure#word|word}.  The parameter must be an instance of\n * {@link UInt} (or {@link UIntBE}) that is no more than 4 bytes wide.\n *\n * @param {bool} [msb] - `true` if the bit numbering starts at the\n * most significant bit of the containing word; `false` (default) if\n * it starts at the least significant bit of the containing word.  If\n * the parameter at this position is a string and `property` is\n * `undefined` the value of this argument will instead be used as the\n * value of `property`.\n *\n * @param {string} [property] - initializer for {@link\n * Layout#property|property}.\n *\n * @augments {Layout}\n */ class BitStructure extends Layout {\n    constructor(word, msb, property){\n        if (!(word instanceof UInt || word instanceof UIntBE)) {\n            throw new TypeError(\"word must be a UInt or UIntBE layout\");\n        }\n        if (\"string\" === typeof msb && undefined === property) {\n            property = msb;\n            msb = false;\n        }\n        if (4 < word.span) {\n            throw new RangeError(\"word cannot exceed 32 bits\");\n        }\n        super(word.span, property);\n        /** The layout used for the packed value.  {@link BitField}\n         * instances are packed sequentially depending on {@link\n         * BitStructure#msb|msb}. */ this.word = word;\n        /** Whether the bit sequences are packed starting at the most\n         * significant bit growing down (`true`), or the least significant\n         * bit growing up (`false`).\n         *\n         * **NOTE** Regardless of this value, the least significant bit of\n         * any {@link BitField} value is the least significant bit of the\n         * corresponding section of the packed value. */ this.msb = !!msb;\n        /** The sequence of {@link BitField} layouts that comprise the\n         * packed structure.\n         *\n         * **NOTE** The array remains mutable to allow fields to be {@link\n         * BitStructure#addField|added} after construction.  Users should\n         * not manipulate the content of this property.*/ this.fields = [];\n        /* Storage for the value.  Capture a variable instead of using an\n         * instance property because we don't want anything to change the\n         * value without going through the mutator. */ let value = 0;\n        this._packedSetValue = function(v) {\n            value = fixBitwiseResult(v);\n            return this;\n        };\n        this._packedGetValue = function() {\n            return value;\n        };\n    }\n    /** @override */ decode(b, offset = 0) {\n        const dest = this.makeDestinationObject();\n        const value = this.word.decode(b, offset);\n        this._packedSetValue(value);\n        for (const fd of this.fields){\n            if (undefined !== fd.property) {\n                dest[fd.property] = fd.decode(b);\n            }\n        }\n        return dest;\n    }\n    /** Implement {@link Layout#encode|encode} for {@link BitStructure}.\n     *\n     * If `src` is missing a property for a member with a defined {@link\n     * Layout#property|property} the corresponding region of the packed\n     * value is left unmodified.  Unused bits are also left unmodified. */ encode(src, b, offset = 0) {\n        const value = this.word.decode(b, offset);\n        this._packedSetValue(value);\n        for (const fd of this.fields){\n            if (undefined !== fd.property) {\n                const fv = src[fd.property];\n                if (undefined !== fv) {\n                    fd.encode(fv);\n                }\n            }\n        }\n        return this.word.encode(this._packedGetValue(), b, offset);\n    }\n    /** Register a new bitfield with a containing bit structure.  The\n     * resulting bitfield is returned.\n     *\n     * @param {Number} bits - initializer for {@link BitField#bits|bits}.\n     *\n     * @param {string} property - initializer for {@link\n     * Layout#property|property}.\n     *\n     * @return {BitField} */ addField(bits, property) {\n        const bf = new BitField(this, bits, property);\n        this.fields.push(bf);\n        return bf;\n    }\n    /** As with {@link BitStructure#addField|addField} for single-bit\n     * fields with `boolean` value representation.\n     *\n     * @param {string} property - initializer for {@link\n     * Layout#property|property}.\n     *\n     * @return {Boolean} */ // `Boolean` conflicts with the native primitive type\n    // eslint-disable-next-line @typescript-eslint/ban-types\n    addBoolean(property) {\n        // This is my Boolean, not the Javascript one.\n        const bf = new Boolean(this, property);\n        this.fields.push(bf);\n        return bf;\n    }\n    /**\n     * Get access to the bit field for a given property.\n     *\n     * @param {String} property - the bit field of interest.\n     *\n     * @return {BitField} - the field associated with `property`, or\n     * undefined if there is no such property.\n     */ fieldFor(property) {\n        if (\"string\" !== typeof property) {\n            throw new TypeError(\"property must be string\");\n        }\n        for (const fd of this.fields){\n            if (fd.property === property) {\n                return fd;\n            }\n        }\n        return undefined;\n    }\n}\nexports.BitStructure = BitStructure;\n/**\n * Represent a sequence of bits within a {@link BitStructure}.\n *\n * All bit field values are represented as unsigned integers.\n *\n * **NOTE** User code should not invoke this constructor directly.\n * Use the container {@link BitStructure#addField|addField} helper\n * method.\n *\n * **NOTE** BitField instances are not instances of {@link Layout}\n * since {@link Layout#span|span} measures 8-bit units.\n *\n * @param {BitStructure} container - initializer for {@link\n * BitField#container|container}.\n *\n * @param {Number} bits - initializer for {@link BitField#bits|bits}.\n *\n * @param {string} [property] - initializer for {@link\n * Layout#property|property}.\n */ class BitField {\n    constructor(container, bits, property){\n        if (!(container instanceof BitStructure)) {\n            throw new TypeError(\"container must be a BitStructure\");\n        }\n        if (!Number.isInteger(bits) || 0 >= bits) {\n            throw new TypeError(\"bits must be positive integer\");\n        }\n        const totalBits = 8 * container.span;\n        const usedBits = container.fields.reduce((sum, fd)=>sum + fd.bits, 0);\n        if (bits + usedBits > totalBits) {\n            throw new Error(\"bits too long for span remainder (\" + (totalBits - usedBits) + \" of \" + totalBits + \" remain)\");\n        }\n        /** The {@link BitStructure} instance to which this bit field\n         * belongs. */ this.container = container;\n        /** The span of this value in bits. */ this.bits = bits;\n        /** A mask of {@link BitField#bits|bits} bits isolating value bits\n         * that fit within the field.\n         *\n         * That is, it masks a value that has not yet been shifted into\n         * position within its containing packed integer. */ this.valueMask = (1 << bits) - 1;\n        if (32 === bits) {\n            this.valueMask = 0xFFFFFFFF;\n        }\n        /** The offset of the value within the containing packed unsigned\n         * integer.  The least significant bit of the packed value is at\n         * offset zero, regardless of bit ordering used. */ this.start = usedBits;\n        if (this.container.msb) {\n            this.start = totalBits - usedBits - bits;\n        }\n        /** A mask of {@link BitField#bits|bits} isolating the field value\n         * within the containing packed unsigned integer. */ this.wordMask = fixBitwiseResult(this.valueMask << this.start);\n        /** The property name used when this bitfield is represented in an\n         * Object.\n         *\n         * Intended to be functionally equivalent to {@link\n         * Layout#property}.\n         *\n         * If left undefined the corresponding span of bits will be\n         * treated as padding: it will not be mutated by {@link\n         * Layout#encode|encode} nor represented as a property in the\n         * decoded Object. */ this.property = property;\n    }\n    /** Store a value into the corresponding subsequence of the containing\n     * bit field. */ decode(b, offset) {\n        const word = this.container._packedGetValue();\n        const wordValue = fixBitwiseResult(word & this.wordMask);\n        const value = wordValue >>> this.start;\n        return value;\n    }\n    /** Store a value into the corresponding subsequence of the containing\n     * bit field.\n     *\n     * **NOTE** This is not a specialization of {@link\n     * Layout#encode|Layout.encode} and there is no return value. */ encode(value) {\n        if (\"number\" !== typeof value || !Number.isInteger(value) || value !== fixBitwiseResult(value & this.valueMask)) {\n            throw new TypeError(nameWithProperty(\"BitField.encode\", this) + \" value must be integer not exceeding \" + this.valueMask);\n        }\n        const word = this.container._packedGetValue();\n        const wordValue = fixBitwiseResult(value << this.start);\n        this.container._packedSetValue(fixBitwiseResult(word & ~this.wordMask) | wordValue);\n    }\n}\nexports.BitField = BitField;\n/**\n * Represent a single bit within a {@link BitStructure} as a\n * JavaScript boolean.\n *\n * **NOTE** User code should not invoke this constructor directly.\n * Use the container {@link BitStructure#addBoolean|addBoolean} helper\n * method.\n *\n * @param {BitStructure} container - initializer for {@link\n * BitField#container|container}.\n *\n * @param {string} [property] - initializer for {@link\n * Layout#property|property}.\n *\n * @augments {BitField}\n */ /* eslint-disable no-extend-native */ class Boolean extends BitField {\n    constructor(container, property){\n        super(container, 1, property);\n    }\n    /** Override {@link BitField#decode|decode} for {@link Boolean|Boolean}.\n     *\n     * @returns {boolean} */ decode(b, offset) {\n        return !!super.decode(b, offset);\n    }\n    /** @override */ encode(value) {\n        if (\"boolean\" === typeof value) {\n            // BitField requires integer values\n            value = +value;\n        }\n        super.encode(value);\n    }\n}\nexports.Boolean = Boolean;\n/* eslint-enable no-extend-native */ /**\n * Contain a fixed-length block of arbitrary data, represented as a\n * Uint8Array.\n *\n * *Factory*: {@link module:Layout.blob|blob}\n *\n * @param {(Number|ExternalLayout)} length - initializes {@link\n * Blob#length|length}.\n *\n * @param {String} [property] - initializer for {@link\n * Layout#property|property}.\n *\n * @augments {Layout}\n */ class Blob extends Layout {\n    constructor(length, property){\n        if (!(length instanceof ExternalLayout && length.isCount() || Number.isInteger(length) && 0 <= length)) {\n            throw new TypeError(\"length must be positive integer \" + \"or an unsigned integer ExternalLayout\");\n        }\n        let span = -1;\n        if (!(length instanceof ExternalLayout)) {\n            span = length;\n        }\n        super(span, property);\n        /** The number of bytes in the blob.\n         *\n         * This may be a non-negative integer, or an instance of {@link\n         * ExternalLayout} that satisfies {@link\n         * ExternalLayout#isCount|isCount()}. */ this.length = length;\n    }\n    /** @override */ getSpan(b, offset) {\n        let span = this.span;\n        if (0 > span) {\n            span = this.length.decode(b, offset);\n        }\n        return span;\n    }\n    /** @override */ decode(b, offset = 0) {\n        let span = this.span;\n        if (0 > span) {\n            span = this.length.decode(b, offset);\n        }\n        return uint8ArrayToBuffer(b).slice(offset, offset + span);\n    }\n    /** Implement {@link Layout#encode|encode} for {@link Blob}.\n     *\n     * **NOTE** If {@link Layout#count|count} is an instance of {@link\n     * ExternalLayout} then the length of `src` will be encoded as the\n     * count after `src` is encoded. */ encode(src, b, offset) {\n        let span = this.length;\n        if (this.length instanceof ExternalLayout) {\n            span = src.length;\n        }\n        if (!(src instanceof Uint8Array && span === src.length)) {\n            throw new TypeError(nameWithProperty(\"Blob.encode\", this) + \" requires (length \" + span + \") Uint8Array as src\");\n        }\n        if (offset + span > b.length) {\n            throw new RangeError(\"encoding overruns Uint8Array\");\n        }\n        const srcBuffer = uint8ArrayToBuffer(src);\n        uint8ArrayToBuffer(b).write(srcBuffer.toString(\"hex\"), offset, span, \"hex\");\n        if (this.length instanceof ExternalLayout) {\n            this.length.encode(span, b, offset);\n        }\n        return span;\n    }\n}\nexports.Blob = Blob;\n/**\n * Contain a `NUL`-terminated UTF8 string.\n *\n * *Factory*: {@link module:Layout.cstr|cstr}\n *\n * **NOTE** Any UTF8 string that incorporates a zero-valued byte will\n * not be correctly decoded by this layout.\n *\n * @param {String} [property] - initializer for {@link\n * Layout#property|property}.\n *\n * @augments {Layout}\n */ class CString extends Layout {\n    constructor(property){\n        super(-1, property);\n    }\n    /** @override */ getSpan(b, offset = 0) {\n        checkUint8Array(b);\n        let idx = offset;\n        while(idx < b.length && 0 !== b[idx]){\n            idx += 1;\n        }\n        return 1 + idx - offset;\n    }\n    /** @override */ decode(b, offset = 0) {\n        const span = this.getSpan(b, offset);\n        return uint8ArrayToBuffer(b).slice(offset, offset + span - 1).toString(\"utf-8\");\n    }\n    /** @override */ encode(src, b, offset = 0) {\n        /* Must force this to a string, lest it be a number and the\n         * \"utf8-encoding\" below actually allocate a buffer of length\n         * src */ if (\"string\" !== typeof src) {\n            src = String(src);\n        }\n        const srcb = buffer_1.Buffer.from(src, \"utf8\");\n        const span = srcb.length;\n        if (offset + span > b.length) {\n            throw new RangeError(\"encoding overruns Buffer\");\n        }\n        const buffer = uint8ArrayToBuffer(b);\n        srcb.copy(buffer, offset);\n        buffer[offset + span] = 0;\n        return span + 1;\n    }\n}\nexports.CString = CString;\n/**\n * Contain a UTF8 string with implicit length.\n *\n * *Factory*: {@link module:Layout.utf8|utf8}\n *\n * **NOTE** Because the length is implicit in the size of the buffer\n * this layout should be used only in isolation, or in a situation\n * where the length can be expressed by operating on a slice of the\n * containing buffer.\n *\n * @param {Number} [maxSpan] - the maximum length allowed for encoded\n * string content.  If not provided there is no bound on the allowed\n * content.\n *\n * @param {String} [property] - initializer for {@link\n * Layout#property|property}.\n *\n * @augments {Layout}\n */ class UTF8 extends Layout {\n    constructor(maxSpan, property){\n        if (\"string\" === typeof maxSpan && undefined === property) {\n            property = maxSpan;\n            maxSpan = undefined;\n        }\n        if (undefined === maxSpan) {\n            maxSpan = -1;\n        } else if (!Number.isInteger(maxSpan)) {\n            throw new TypeError(\"maxSpan must be an integer\");\n        }\n        super(-1, property);\n        /** The maximum span of the layout in bytes.\n         *\n         * Positive values are generally expected.  Zero is abnormal.\n         * Attempts to encode or decode a value that exceeds this length\n         * will throw a `RangeError`.\n         *\n         * A negative value indicates that there is no bound on the length\n         * of the content. */ this.maxSpan = maxSpan;\n    }\n    /** @override */ getSpan(b, offset = 0) {\n        checkUint8Array(b);\n        return b.length - offset;\n    }\n    /** @override */ decode(b, offset = 0) {\n        const span = this.getSpan(b, offset);\n        if (0 <= this.maxSpan && this.maxSpan < span) {\n            throw new RangeError(\"text length exceeds maxSpan\");\n        }\n        return uint8ArrayToBuffer(b).slice(offset, offset + span).toString(\"utf-8\");\n    }\n    /** @override */ encode(src, b, offset = 0) {\n        /* Must force this to a string, lest it be a number and the\n         * \"utf8-encoding\" below actually allocate a buffer of length\n         * src */ if (\"string\" !== typeof src) {\n            src = String(src);\n        }\n        const srcb = buffer_1.Buffer.from(src, \"utf8\");\n        const span = srcb.length;\n        if (0 <= this.maxSpan && this.maxSpan < span) {\n            throw new RangeError(\"text length exceeds maxSpan\");\n        }\n        if (offset + span > b.length) {\n            throw new RangeError(\"encoding overruns Buffer\");\n        }\n        srcb.copy(uint8ArrayToBuffer(b), offset);\n        return span;\n    }\n}\nexports.UTF8 = UTF8;\n/**\n * Contain a constant value.\n *\n * This layout may be used in cases where a JavaScript value can be\n * inferred without an expression in the binary encoding.  An example\n * would be a {@link VariantLayout|variant layout} where the content\n * is implied by the union {@link Union#discriminator|discriminator}.\n *\n * @param {Object|Number|String} value - initializer for {@link\n * Constant#value|value}.  If the value is an object (or array) and\n * the application intends the object to remain unchanged regardless\n * of what is done to values decoded by this layout, the value should\n * be frozen prior passing it to this constructor.\n *\n * @param {String} [property] - initializer for {@link\n * Layout#property|property}.\n *\n * @augments {Layout}\n */ class Constant extends Layout {\n    constructor(value, property){\n        super(0, property);\n        /** The value produced by this constant when the layout is {@link\n         * Constant#decode|decoded}.\n         *\n         * Any JavaScript value including `null` and `undefined` is\n         * permitted.\n         *\n         * **WARNING** If `value` passed in the constructor was not\n         * frozen, it is possible for users of decoded values to change\n         * the content of the value. */ this.value = value;\n    }\n    /** @override */ decode(b, offset) {\n        return this.value;\n    }\n    /** @override */ encode(src, b, offset) {\n        /* Constants take no space */ return 0;\n    }\n}\nexports.Constant = Constant;\n/** Factory for {@link GreedyCount}. */ exports.greedy = (elementSpan, property)=>new GreedyCount(elementSpan, property);\n/** Factory for {@link OffsetLayout}. */ exports.offset = (layout, offset, property)=>new OffsetLayout(layout, offset, property);\n/** Factory for {@link UInt|unsigned int layouts} spanning one\n * byte. */ exports.u8 = (property)=>new UInt(1, property);\n/** Factory for {@link UInt|little-endian unsigned int layouts}\n * spanning two bytes. */ exports.u16 = (property)=>new UInt(2, property);\n/** Factory for {@link UInt|little-endian unsigned int layouts}\n * spanning three bytes. */ exports.u24 = (property)=>new UInt(3, property);\n/** Factory for {@link UInt|little-endian unsigned int layouts}\n * spanning four bytes. */ exports.u32 = (property)=>new UInt(4, property);\n/** Factory for {@link UInt|little-endian unsigned int layouts}\n * spanning five bytes. */ exports.u40 = (property)=>new UInt(5, property);\n/** Factory for {@link UInt|little-endian unsigned int layouts}\n * spanning six bytes. */ exports.u48 = (property)=>new UInt(6, property);\n/** Factory for {@link NearUInt64|little-endian unsigned int\n * layouts} interpreted as Numbers. */ exports.nu64 = (property)=>new NearUInt64(property);\n/** Factory for {@link UInt|big-endian unsigned int layouts}\n * spanning two bytes. */ exports.u16be = (property)=>new UIntBE(2, property);\n/** Factory for {@link UInt|big-endian unsigned int layouts}\n * spanning three bytes. */ exports.u24be = (property)=>new UIntBE(3, property);\n/** Factory for {@link UInt|big-endian unsigned int layouts}\n * spanning four bytes. */ exports.u32be = (property)=>new UIntBE(4, property);\n/** Factory for {@link UInt|big-endian unsigned int layouts}\n * spanning five bytes. */ exports.u40be = (property)=>new UIntBE(5, property);\n/** Factory for {@link UInt|big-endian unsigned int layouts}\n * spanning six bytes. */ exports.u48be = (property)=>new UIntBE(6, property);\n/** Factory for {@link NearUInt64BE|big-endian unsigned int\n * layouts} interpreted as Numbers. */ exports.nu64be = (property)=>new NearUInt64BE(property);\n/** Factory for {@link Int|signed int layouts} spanning one\n * byte. */ exports.s8 = (property)=>new Int(1, property);\n/** Factory for {@link Int|little-endian signed int layouts}\n * spanning two bytes. */ exports.s16 = (property)=>new Int(2, property);\n/** Factory for {@link Int|little-endian signed int layouts}\n * spanning three bytes. */ exports.s24 = (property)=>new Int(3, property);\n/** Factory for {@link Int|little-endian signed int layouts}\n * spanning four bytes. */ exports.s32 = (property)=>new Int(4, property);\n/** Factory for {@link Int|little-endian signed int layouts}\n * spanning five bytes. */ exports.s40 = (property)=>new Int(5, property);\n/** Factory for {@link Int|little-endian signed int layouts}\n * spanning six bytes. */ exports.s48 = (property)=>new Int(6, property);\n/** Factory for {@link NearInt64|little-endian signed int layouts}\n * interpreted as Numbers. */ exports.ns64 = (property)=>new NearInt64(property);\n/** Factory for {@link Int|big-endian signed int layouts}\n * spanning two bytes. */ exports.s16be = (property)=>new IntBE(2, property);\n/** Factory for {@link Int|big-endian signed int layouts}\n * spanning three bytes. */ exports.s24be = (property)=>new IntBE(3, property);\n/** Factory for {@link Int|big-endian signed int layouts}\n * spanning four bytes. */ exports.s32be = (property)=>new IntBE(4, property);\n/** Factory for {@link Int|big-endian signed int layouts}\n * spanning five bytes. */ exports.s40be = (property)=>new IntBE(5, property);\n/** Factory for {@link Int|big-endian signed int layouts}\n * spanning six bytes. */ exports.s48be = (property)=>new IntBE(6, property);\n/** Factory for {@link NearInt64BE|big-endian signed int layouts}\n * interpreted as Numbers. */ exports.ns64be = (property)=>new NearInt64BE(property);\n/** Factory for {@link Float|little-endian 32-bit floating point} values. */ exports.f32 = (property)=>new Float(property);\n/** Factory for {@link FloatBE|big-endian 32-bit floating point} values. */ exports.f32be = (property)=>new FloatBE(property);\n/** Factory for {@link Double|little-endian 64-bit floating point} values. */ exports.f64 = (property)=>new Double(property);\n/** Factory for {@link DoubleBE|big-endian 64-bit floating point} values. */ exports.f64be = (property)=>new DoubleBE(property);\n/** Factory for {@link Structure} values. */ exports.struct = (fields, property, decodePrefixes)=>new Structure(fields, property, decodePrefixes);\n/** Factory for {@link BitStructure} values. */ exports.bits = (word, msb, property)=>new BitStructure(word, msb, property);\n/** Factory for {@link Sequence} values. */ exports.seq = (elementLayout, count, property)=>new Sequence(elementLayout, count, property);\n/** Factory for {@link Union} values. */ exports.union = (discr, defaultLayout, property)=>new Union(discr, defaultLayout, property);\n/** Factory for {@link UnionLayoutDiscriminator} values. */ exports.unionLayoutDiscriminator = (layout, property)=>new UnionLayoutDiscriminator(layout, property);\n/** Factory for {@link Blob} values. */ exports.blob = (length, property)=>new Blob(length, property);\n/** Factory for {@link CString} values. */ exports.cstr = (property)=>new CString(property);\n/** Factory for {@link UTF8} values. */ exports.utf8 = (maxSpan, property)=>new UTF8(maxSpan, property);\n/** Factory for {@link Constant} values. */ exports.constant = (value, property)=>new Constant(value, property); //# sourceMappingURL=Layout.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL0Bzb2xhbmEvYnVmZmVyLWxheW91dC9saWIvTGF5b3V0LmpzIiwibWFwcGluZ3MiOiJBQUFBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Q0FxQkMsR0FDRDs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Q0EyR0MsR0FDRDtBQUNBQSw4Q0FBNkM7SUFBRUcsT0FBTztBQUFLLENBQUMsRUFBQztBQUM3REQsV0FBVyxHQUFHQSxVQUFVLEdBQUdBLGNBQWMsR0FBR0EsYUFBYSxHQUFHQSxhQUFhLEdBQUdBLGFBQWEsR0FBR0EsYUFBYSxHQUFHQSxhQUFhLEdBQUdBLFlBQVksR0FBR0EsV0FBVyxHQUFHQSxXQUFXLEdBQUdBLFdBQVcsR0FBR0EsV0FBVyxHQUFHQSxXQUFXLEdBQUdBLFVBQVUsR0FBR0EsY0FBYyxHQUFHQSxjQUFjLEdBQUdBLGdCQUFnQixHQUFHQSxZQUFZLEdBQUdBLGVBQWUsR0FBR0EsWUFBWSxHQUFHQSxlQUFlLEdBQUdBLGdCQUFnQixHQUFHQSxvQkFBb0IsR0FBR0EscUJBQXFCLEdBQUdBLGFBQWEsR0FBR0EsZ0NBQWdDLEdBQUdBLDBCQUEwQixHQUFHQSxpQkFBaUIsR0FBR0EsZ0JBQWdCLEdBQUdBLGdCQUFnQixHQUFHQSxjQUFjLEdBQUdBLGVBQWUsR0FBR0EsYUFBYSxHQUFHQSxtQkFBbUIsR0FBR0EsaUJBQWlCLEdBQUdBLG9CQUFvQixHQUFHQSxrQkFBa0IsR0FBR0EsYUFBYSxHQUFHQSxXQUFXLEdBQUdBLGNBQWMsR0FBR0EsWUFBWSxHQUFHQSxvQkFBb0IsR0FBR0EsbUJBQW1CLEdBQUdBLHNCQUFzQixHQUFHQSw2QkFBNkIsR0FBR0Esd0JBQXdCLEdBQUdBLGNBQWMsR0FBR0EsMEJBQTBCLEdBQUdBLHVCQUF1QixHQUFHLEtBQUs7QUFDdDdCQSxnQkFBZ0Is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O0FBQ3pELHlDQUF5QyxHQUN6Q3hGLGdCQUFnQixHQUFJLENBQUNDLE9BQU91RixXQUFhLElBQUlyRSxTQUFTbEIsT0FBT3VGLFdBQzdELGtDQUFrQyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvQHNvbGFuYS9idWZmZXItbGF5b3V0L2xpYi9MYXlvdXQuanM/ODFiNyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiBUaGUgTUlUIExpY2Vuc2UgKE1JVClcbiAqXG4gKiBDb3B5cmlnaHQgMjAxNS0yMDE4IFBldGVyIEEuIEJpZ290XG4gKlxuICogUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxuICogb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuICogaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xuICogdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuICogY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG4gKiBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuICpcbiAqIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXG4gKiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbiAqXG4gKiBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG4gKiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbiAqIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuICogQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuICogTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbiAqIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU5cbiAqIFRIRSBTT0ZUV0FSRS5cbiAqL1xuLyoqXG4gKiBTdXBwb3J0IGZvciB0cmFuc2xhdGluZyBiZXR3ZWVuIFVpbnQ4QXJyYXkgaW5zdGFuY2VzIGFuZCBKYXZhU2NyaXB0XG4gKiBuYXRpdmUgdHlwZXMuXG4gKlxuICoge0BsaW5rIG1vZHVsZTpMYXlvdXR+TGF5b3V0fExheW91dH0gaXMgdGhlIGJhc2lzIG9mIGEgY2xhc3NcbiAqIGhpZXJhcmNoeSB0aGF0IGFzc29jaWF0ZXMgcHJvcGVydHkgbmFtZXMgd2l0aCBzZXF1ZW5jZXMgb2YgZW5jb2RlZFxuICogYnl0ZXMuXG4gKlxuICogTGF5b3V0cyBhcmUgc3VwcG9ydGVkIGZvciB0aGVzZSBzY2FsYXIgKG51bWVyaWMpIHR5cGVzOlxuICogKiB7QGxpbmsgbW9kdWxlOkxheW91dH5VSW50fFVuc2lnbmVkIGludGVnZXJzIGluIGxpdHRsZS1lbmRpYW5cbiAqICAgZm9ybWF0fSB3aXRoIHtAbGluayBtb2R1bGU6TGF5b3V0LnU4fDgtYml0fSwge0BsaW5rXG4gKiAgIG1vZHVsZTpMYXlvdXQudTE2fDE2LWJpdH0sIHtAbGluayBtb2R1bGU6TGF5b3V0LnUyNHwyNC1iaXR9LFxuICogICB7QGxpbmsgbW9kdWxlOkxheW91dC51MzJ8MzItYml0fSwge0BsaW5rXG4gKiAgIG1vZHVsZTpMYXlvdXQudTQwfDQwLWJpdH0sIGFuZCB7QGxpbmsgbW9kdWxlOkxheW91dC51NDh8NDgtYml0fVxuICogICByZXByZXNlbnRhdGlvbiByYW5nZXM7XG4gKiAqIHtAbGluayBtb2R1bGU6TGF5b3V0flVJbnRCRXxVbnNpZ25lZCBpbnRlZ2VycyBpbiBiaWctZW5kaWFuXG4gKiAgIGZvcm1hdH0gd2l0aCB7QGxpbmsgbW9kdWxlOkxheW91dC51MTZiZXwxNi1iaXR9LCB7QGxpbmtcbiAqICAgbW9kdWxlOkxheW91dC51MjRiZXwyNC1iaXR9LCB7QGxpbmsgbW9kdWxlOkxheW91dC51MzJiZXwzMi1iaXR9LFxuICogICB7QGxpbmsgbW9kdWxlOkxheW91dC51NDBiZXw0MC1iaXR9LCBhbmQge0BsaW5rXG4gKiAgIG1vZHVsZTpMYXlvdXQudTQ4YmV8NDgtYml0fSByZXByZXNlbnRhdGlvbiByYW5nZXM7XG4gKiAqIHtAbGluayBtb2R1bGU6TGF5b3V0fkludHxTaWduZWQgaW50ZWdlcnMgaW4gbGl0dGxlLWVuZGlhblxuICogICBmb3JtYXR9IHdpdGgge0BsaW5rIG1vZHVsZTpMYXlvdXQuczh8OC1iaXR9LCB7QGxpbmtcbiAqICAgbW9kdWxlOkxheW91dC5zMTZ8MTYtYml0fSwge0BsaW5rIG1vZHVsZTpMYXlvdXQuczI0fDI0LWJpdH0sXG4gKiAgIHtAbGluayBtb2R1bGU6TGF5b3V0LnMzMnwzMi1iaXR9LCB7QGxpbmtcbiAqICAgbW9kdWxlOkxheW91dC5zNDB8NDAtYml0fSwgYW5kIHtAbGluayBtb2R1bGU6TGF5b3V0LnM0OHw0OC1iaXR9XG4gKiAgIHJlcHJlc2VudGF0aW9uIHJhbmdlcztcbiAqICoge0BsaW5rIG1vZHVsZTpMYXlvdXR+SW50QkV8U2lnbmVkIGludGVnZXJzIGluIGJpZy1lbmRpYW4gZm9ybWF0fVxuICogICB3aXRoIHtAbGluayBtb2R1bGU6TGF5b3V0LnMxNmJlfDE2LWJpdH0sIHtAbGlua1xuICogICBtb2R1bGU6TGF5b3V0LnMyNGJlfDI0LWJpdH0sIHtAbGluayBtb2R1bGU6TGF5b3V0LnMzMmJlfDMyLWJpdH0sXG4gKiAgIHtAbGluayBtb2R1bGU6TGF5b3V0LnM0MGJlfDQwLWJpdH0sIGFuZCB7QGxpbmtcbiAqICAgbW9kdWxlOkxheW91dC5zNDhiZXw0OC1iaXR9IHJlcHJlc2VudGF0aW9uIHJhbmdlcztcbiAqICogNjQtYml0IGludGVncmFsIHZhbHVlcyB0aGF0IGRlY29kZSB0byBhbiBleGFjdCAoaWYgbWFnbml0dWRlIGlzXG4gKiAgIGxlc3MgdGhhbiAyXjUzKSBvciBuZWFyYnkgaW50ZWdyYWwgTnVtYmVyIGluIHtAbGlua1xuICogICBtb2R1bGU6TGF5b3V0Lm51NjR8dW5zaWduZWQgbGl0dGxlLWVuZGlhbn0sIHtAbGlua1xuICogICBtb2R1bGU6TGF5b3V0Lm51NjRiZXx1bnNpZ25lZCBiaWctZW5kaWFufSwge0BsaW5rXG4gKiAgIG1vZHVsZTpMYXlvdXQubnM2NHxzaWduZWQgbGl0dGxlLWVuZGlhbn0sIGFuZCB7QGxpbmtcbiAqICAgbW9kdWxlOkxheW91dC5uczY0YmV8dW5zaWduZWQgYmlnLWVuZGlhbn0gZW5jb2RpbmdzO1xuICogKiAzMi1iaXQgZmxvYXRpbmcgcG9pbnQgdmFsdWVzIHdpdGgge0BsaW5rXG4gKiAgIG1vZHVsZTpMYXlvdXQuZjMyfGxpdHRsZS1lbmRpYW59IGFuZCB7QGxpbmtcbiAqICAgbW9kdWxlOkxheW91dC5mMzJiZXxiaWctZW5kaWFufSByZXByZXNlbnRhdGlvbnM7XG4gKiAqIDY0LWJpdCBmbG9hdGluZyBwb2ludCB2YWx1ZXMgd2l0aCB7QGxpbmtcbiAqICAgbW9kdWxlOkxheW91dC5mNjR8bGl0dGxlLWVuZGlhbn0gYW5kIHtAbGlua1xuICogICBtb2R1bGU6TGF5b3V0LmY2NGJlfGJpZy1lbmRpYW59IHJlcHJlc2VudGF0aW9ucztcbiAqICoge0BsaW5rIG1vZHVsZTpMYXlvdXQuY29uc3R8Q29uc3RhbnRzfSB0aGF0IHRha2Ugbm8gc3BhY2UgaW4gdGhlXG4gKiAgIGVuY29kZWQgZXhwcmVzc2lvbi5cbiAqXG4gKiBhbmQgZm9yIHRoZXNlIGFnZ3JlZ2F0ZSB0eXBlczpcbiAqICoge0BsaW5rIG1vZHVsZTpMYXlvdXQuc2VxfFNlcXVlbmNlfXMgb2YgaW5zdGFuY2VzIG9mIGEge0BsaW5rXG4gKiAgIG1vZHVsZTpMYXlvdXR+TGF5b3V0fExheW91dH0sIHdpdGggSmF2YVNjcmlwdCByZXByZXNlbnRhdGlvbiBhc1xuICogICBhbiBBcnJheSBhbmQgY29uc3RhbnQgb3IgZGF0YS1kZXBlbmRlbnQge0BsaW5rXG4gKiAgIG1vZHVsZTpMYXlvdXR+U2VxdWVuY2UjY291bnR8bGVuZ3RofTtcbiAqICoge0BsaW5rIG1vZHVsZTpMYXlvdXQuc3RydWN0fFN0cnVjdHVyZX1zIHRoYXQgYWdncmVnYXRlIGFcbiAqICAgaGV0ZXJvZ2VuZW91cyBzZXF1ZW5jZSBvZiB7QGxpbmsgbW9kdWxlOkxheW91dH5MYXlvdXR8TGF5b3V0fVxuICogICBpbnN0YW5jZXMsIHdpdGggSmF2YVNjcmlwdCByZXByZXNlbnRhdGlvbiBhcyBhbiBPYmplY3Q7XG4gKiAqIHtAbGluayBtb2R1bGU6TGF5b3V0LnVuaW9ufFVuaW9ufXMgdGhhdCBzdXBwb3J0IG11bHRpcGxlIHtAbGlua1xuICogICBtb2R1bGU6TGF5b3V0flZhcmlhbnRMYXlvdXR8dmFyaWFudCBsYXlvdXRzfSBvdmVyIGEgZml4ZWRcbiAqICAgKHBhZGRlZCkgb3IgdmFyaWFibGUgKG5vdCBwYWRkZWQpIHNwYW4gb2YgYnl0ZXMsIHVzaW5nIGFuXG4gKiAgIHVuc2lnbmVkIGludGVnZXIgYXQgdGhlIHN0YXJ0IG9mIHRoZSBkYXRhIG9yIGEgc2VwYXJhdGUge0BsaW5rXG4gKiAgIG1vZHVsZTpMYXlvdXQudW5pb25MYXlvdXREaXNjcmltaW5hdG9yfGxheW91dCBlbGVtZW50fSB0b1xuICogICBkZXRlcm1pbmUgd2hpY2ggbGF5b3V0IHRvIHVzZSB3aGVuIGludGVycHJldGluZyB0aGUgYnVmZmVyXG4gKiAgIGNvbnRlbnRzO1xuICogKiB7QGxpbmsgbW9kdWxlOkxheW91dC5iaXRzfEJpdFN0cnVjdHVyZX1zIHRoYXQgY29udGFpbiBhIHNlcXVlbmNlXG4gKiAgIG9mIGluZGl2aWR1YWwge0BsaW5rXG4gKiAgIG1vZHVsZTpMYXlvdXR+Qml0U3RydWN0dXJlI2FkZEZpZWxkfEJpdEZpZWxkfXMgcGFja2VkIGludG8gYW4gOCxcbiAqICAgMTYsIDI0LCBvciAzMi1iaXQgdW5zaWduZWQgaW50ZWdlciBzdGFydGluZyBhdCB0aGUgbGVhc3QtIG9yXG4gKiAgIG1vc3Qtc2lnbmlmaWNhbnQgYml0O1xuICogKiB7QGxpbmsgbW9kdWxlOkxheW91dC5jc3RyfEMgc3RyaW5nc30gb2YgdmFyeWluZyBsZW5ndGg7XG4gKiAqIHtAbGluayBtb2R1bGU6TGF5b3V0LmJsb2J8QmxvYnN9IG9mIGZpeGVkLSBvciB2YXJpYWJsZS17QGxpbmtcbiAqICAgbW9kdWxlOkxheW91dH5CbG9iI2xlbmd0aHxsZW5ndGh9IHJhdyBkYXRhLlxuICpcbiAqIEFsbCB7QGxpbmsgbW9kdWxlOkxheW91dH5MYXlvdXR8TGF5b3V0fSBpbnN0YW5jZXMgYXJlIGltbXV0YWJsZVxuICogYWZ0ZXIgY29uc3RydWN0aW9uLCB0byBwcmV2ZW50IGludGVybmFsIHN0YXRlIGZyb20gYmVjb21pbmdcbiAqIGluY29uc2lzdGVudC5cbiAqXG4gKiBAbG9jYWwgTGF5b3V0XG4gKiBAbG9jYWwgRXh0ZXJuYWxMYXlvdXRcbiAqIEBsb2NhbCBHcmVlZHlDb3VudFxuICogQGxvY2FsIE9mZnNldExheW91dFxuICogQGxvY2FsIFVJbnRcbiAqIEBsb2NhbCBVSW50QkVcbiAqIEBsb2NhbCBJbnRcbiAqIEBsb2NhbCBJbnRCRVxuICogQGxvY2FsIE5lYXJVSW50NjRcbiAqIEBsb2NhbCBOZWFyVUludDY0QkVcbiAqIEBsb2NhbCBOZWFySW50NjRcbiAqIEBsb2NhbCBOZWFySW50NjRCRVxuICogQGxvY2FsIEZsb2F0XG4gKiBAbG9jYWwgRmxvYXRCRVxuICogQGxvY2FsIERvdWJsZVxuICogQGxvY2FsIERvdWJsZUJFXG4gKiBAbG9jYWwgU2VxdWVuY2VcbiAqIEBsb2NhbCBTdHJ1Y3R1cmVcbiAqIEBsb2NhbCBVbmlvbkRpc2NyaW1pbmF0b3JcbiAqIEBsb2NhbCBVbmlvbkxheW91dERpc2NyaW1pbmF0b3JcbiAqIEBsb2NhbCBVbmlvblxuICogQGxvY2FsIFZhcmlhbnRMYXlvdXRcbiAqIEBsb2NhbCBCaXRTdHJ1Y3R1cmVcbiAqIEBsb2NhbCBCaXRGaWVsZFxuICogQGxvY2FsIEJvb2xlYW5cbiAqIEBsb2NhbCBCbG9iXG4gKiBAbG9jYWwgQ1N0cmluZ1xuICogQGxvY2FsIENvbnN0YW50XG4gKiBAbG9jYWwgYmluZENvbnN0cnVjdG9yTGF5b3V0XG4gKiBAbW9kdWxlIExheW91dFxuICogQGxpY2Vuc2UgTUlUXG4gKiBAYXV0aG9yIFBldGVyIEEuIEJpZ290XG4gKiBAc2VlIHtAbGluayBodHRwczovL2dpdGh1Yi5jb20vcGFiaWdvdC9idWZmZXItbGF5b3V0fGJ1ZmZlci1sYXlvdXQgb24gR2l0SHVifVxuICovXG4ndXNlIHN0cmljdCc7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLnMxNiA9IGV4cG9ydHMuczggPSBleHBvcnRzLm51NjRiZSA9IGV4cG9ydHMudTQ4YmUgPSBleHBvcnRzLnU0MGJlID0gZXhwb3J0cy51MzJiZSA9IGV4cG9ydHMudTI0YmUgPSBleHBvcnRzLnUxNmJlID0gZXhwb3J0cy5udTY0ID0gZXhwb3J0cy51NDggPSBleHBvcnRzLnU0MCA9IGV4cG9ydHMudTMyID0gZXhwb3J0cy51MjQgPSBleHBvcnRzLnUxNiA9IGV4cG9ydHMudTggPSBleHBvcnRzLm9mZnNldCA9IGV4cG9ydHMuZ3JlZWR5ID0gZXhwb3J0cy5Db25zdGFudCA9IGV4cG9ydHMuVVRGOCA9IGV4cG9ydHMuQ1N0cmluZyA9IGV4cG9ydHMuQmxvYiA9IGV4cG9ydHMuQm9vbGVhbiA9IGV4cG9ydHMuQml0RmllbGQgPSBleHBvcnRzLkJpdFN0cnVjdHVyZSA9IGV4cG9ydHMuVmFyaWFudExheW91dCA9IGV4cG9ydHMuVW5pb24gPSBleHBvcnRzLlVuaW9uTGF5b3V0RGlzY3JpbWluYXRvciA9IGV4cG9ydHMuVW5pb25EaXNjcmltaW5hdG9yID0gZXhwb3J0cy5TdHJ1Y3R1cmUgPSBleHBvcnRzLlNlcXVlbmNlID0gZXhwb3J0cy5Eb3VibGVCRSA9IGV4cG9ydHMuRG91YmxlID0gZXhwb3J0cy5GbG9hdEJFID0gZXhwb3J0cy5GbG9hdCA9IGV4cG9ydHMuTmVhckludDY0QkUgPSBleHBvcnRzLk5lYXJJbnQ2NCA9IGV4cG9ydHMuTmVhclVJbnQ2NEJFID0gZXhwb3J0cy5OZWFyVUludDY0ID0gZXhwb3J0cy5JbnRCRSA9IGV4cG9ydHMuSW50ID0gZXhwb3J0cy5VSW50QkUgPSBleHBvcnRzLlVJbnQgPSBleHBvcnRzLk9mZnNldExheW91dCA9IGV4cG9ydHMuR3JlZWR5Q291bnQgPSBleHBvcnRzLkV4dGVybmFsTGF5b3V0ID0gZXhwb3J0cy5iaW5kQ29uc3RydWN0b3JMYXlvdXQgPSBleHBvcnRzLm5hbWVXaXRoUHJvcGVydHkgPSBleHBvcnRzLkxheW91dCA9IGV4cG9ydHMudWludDhBcnJheVRvQnVmZmVyID0gZXhwb3J0cy5jaGVja1VpbnQ4QXJyYXkgPSB2b2lkIDA7XG5leHBvcnRzLmNvbnN0YW50ID0gZXhwb3J0cy51dGY4ID0gZXhwb3J0cy5jc3RyID0gZXhwb3J0cy5ibG9iID0gZXhwb3J0cy51bmlvbkxheW91dERpc2NyaW1pbmF0b3IgPSBleHBvcnRzLnVuaW9uID0gZXhwb3J0cy5zZXEgPSBleHBvcnRzLmJpdHMgPSBleHBvcnRzLnN0cnVjdCA9IGV4cG9ydHMuZjY0YmUgPSBleHBvcnRzLmY2NCA9IGV4cG9ydHMuZjMyYmUgPSBleHBvcnRzLmYzMiA9IGV4cG9ydHMubnM2NGJlID0gZXhwb3J0cy5zNDhiZSA9IGV4cG9ydHMuczQwYmUgPSBleHBvcnRzLnMzMmJlID0gZXhwb3J0cy5zMjRiZSA9IGV4cG9ydHMuczE2YmUgPSBleHBvcnRzLm5zNjQgPSBleHBvcnRzLnM0OCA9IGV4cG9ydHMuczQwID0gZXhwb3J0cy5zMzIgPSBleHBvcnRzLnMyNCA9IHZvaWQgMDtcbmNvbnN0IGJ1ZmZlcl8xID0gcmVxdWlyZShcImJ1ZmZlclwiKTtcbi8qIENoZWNrIGlmIGEgdmFsdWUgaXMgYSBVaW50OEFycmF5LlxuICpcbiAqIEBpZ25vcmUgKi9cbmZ1bmN0aW9uIGNoZWNrVWludDhBcnJheShiKSB7XG4gICAgaWYgKCEoYiBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2IgbXVzdCBiZSBhIFVpbnQ4QXJyYXknKTtcbiAgICB9XG59XG5leHBvcnRzLmNoZWNrVWludDhBcnJheSA9IGNoZWNrVWludDhBcnJheTtcbi8qIENyZWF0ZSBhIEJ1ZmZlciBpbnN0YW5jZSBmcm9tIGEgVWludDhBcnJheS5cbiAqXG4gKiBAaWdub3JlICovXG5mdW5jdGlvbiB1aW50OEFycmF5VG9CdWZmZXIoYikge1xuICAgIGNoZWNrVWludDhBcnJheShiKTtcbiAgICByZXR1cm4gYnVmZmVyXzEuQnVmZmVyLmZyb20oYi5idWZmZXIsIGIuYnl0ZU9mZnNldCwgYi5sZW5ndGgpO1xufVxuZXhwb3J0cy51aW50OEFycmF5VG9CdWZmZXIgPSB1aW50OEFycmF5VG9CdWZmZXI7XG4vKipcbiAqIEJhc2UgY2xhc3MgZm9yIGxheW91dCBvYmplY3RzLlxuICpcbiAqICoqTk9URSoqIFRoaXMgaXMgYW4gYWJzdHJhY3QgYmFzZSBjbGFzczsgeW91IGNhbiBjcmVhdGUgaW5zdGFuY2VzXG4gKiBpZiBpdCBhbXVzZXMgeW91LCBidXQgdGhleSB3b24ndCBzdXBwb3J0IHRoZSB7QGxpbmtcbiAqIExheW91dCNlbmNvZGV8ZW5jb2RlfSBvciB7QGxpbmsgTGF5b3V0I2RlY29kZXxkZWNvZGV9IGZ1bmN0aW9ucy5cbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gc3BhbiAtIEluaXRpYWxpemVyIGZvciB7QGxpbmsgTGF5b3V0I3NwYW58c3Bhbn0uICBUaGVcbiAqIHBhcmFtZXRlciBtdXN0IGJlIGFuIGludGVnZXI7IGEgbmVnYXRpdmUgdmFsdWUgc2lnbmlmaWVzIHRoYXQgdGhlXG4gKiBzcGFuIGlzIHtAbGluayBMYXlvdXQjZ2V0U3Bhbnx2YWx1ZS1zcGVjaWZpY30uXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IFtwcm9wZXJ0eV0gLSBJbml0aWFsaXplciBmb3Ige0BsaW5rXG4gKiBMYXlvdXQjcHJvcGVydHl8cHJvcGVydHl9LlxuICpcbiAqIEBhYnN0cmFjdFxuICovXG5jbGFzcyBMYXlvdXQge1xuICAgIGNvbnN0cnVjdG9yKHNwYW4sIHByb3BlcnR5KSB7XG4gICAgICAgIGlmICghTnVtYmVyLmlzSW50ZWdlcihzcGFuKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignc3BhbiBtdXN0IGJlIGFuIGludGVnZXInKTtcbiAgICAgICAgfVxuICAgICAgICAvKiogVGhlIHNwYW4gb2YgdGhlIGxheW91dCBpbiBieXRlcy5cbiAgICAgICAgICpcbiAgICAgICAgICogUG9zaXRpdmUgdmFsdWVzIGFyZSBnZW5lcmFsbHkgZXhwZWN0ZWQuXG4gICAgICAgICAqXG4gICAgICAgICAqIFplcm8gd2lsbCBvbmx5IGFwcGVhciBpbiB7QGxpbmsgQ29uc3RhbnR9cyBhbmQgaW4ge0BsaW5rXG4gICAgICAgICAqIFNlcXVlbmNlfXMgd2hlcmUgdGhlIHtAbGluayBTZXF1ZW5jZSNjb3VudHxjb3VudH0gaXMgemVyby5cbiAgICAgICAgICpcbiAgICAgICAgICogQSBuZWdhdGl2ZSB2YWx1ZSBpbmRpY2F0ZXMgdGhhdCB0aGUgc3BhbiBpcyB2YWx1ZS1zcGVjaWZpYywgYW5kXG4gICAgICAgICAqIG11c3QgYmUgb2J0YWluZWQgdXNpbmcge0BsaW5rIExheW91dCNnZXRTcGFufGdldFNwYW59LiAqL1xuICAgICAgICB0aGlzLnNwYW4gPSBzcGFuO1xuICAgICAgICAvKiogVGhlIHByb3BlcnR5IG5hbWUgdXNlZCB3aGVuIHRoaXMgbGF5b3V0IGlzIHJlcHJlc2VudGVkIGluIGFuXG4gICAgICAgICAqIE9iamVjdC5cbiAgICAgICAgICpcbiAgICAgICAgICogVXNlZCBvbmx5IGZvciBsYXlvdXRzIHRoYXQge0BsaW5rIExheW91dCNkZWNvZGV8ZGVjb2RlfSB0byBPYmplY3RcbiAgICAgICAgICogaW5zdGFuY2VzLiAgSWYgbGVmdCB1bmRlZmluZWQgdGhlIHNwYW4gb2YgdGhlIHVubmFtZWQgbGF5b3V0IHdpbGxcbiAgICAgICAgICogYmUgdHJlYXRlZCBhcyBwYWRkaW5nOiBpdCB3aWxsIG5vdCBiZSBtdXRhdGVkIGJ5IHtAbGlua1xuICAgICAgICAgKiBMYXlvdXQjZW5jb2RlfGVuY29kZX0gbm9yIHJlcHJlc2VudGVkIGFzIGEgcHJvcGVydHkgaW4gdGhlXG4gICAgICAgICAqIGRlY29kZWQgT2JqZWN0LiAqL1xuICAgICAgICB0aGlzLnByb3BlcnR5ID0gcHJvcGVydHk7XG4gICAgfVxuICAgIC8qKiBGdW5jdGlvbiB0byBjcmVhdGUgYW4gT2JqZWN0IGludG8gd2hpY2ggZGVjb2RlZCBwcm9wZXJ0aWVzIHdpbGxcbiAgICAgKiBiZSB3cml0dGVuLlxuICAgICAqXG4gICAgICogVXNlZCBvbmx5IGZvciBsYXlvdXRzIHRoYXQge0BsaW5rIExheW91dCNkZWNvZGV8ZGVjb2RlfSB0byBPYmplY3RcbiAgICAgKiBpbnN0YW5jZXMsIHdoaWNoIG1lYW5zOlxuICAgICAqICoge0BsaW5rIFN0cnVjdHVyZX1cbiAgICAgKiAqIHtAbGluayBVbmlvbn1cbiAgICAgKiAqIHtAbGluayBWYXJpYW50TGF5b3V0fVxuICAgICAqICoge0BsaW5rIEJpdFN0cnVjdHVyZX1cbiAgICAgKlxuICAgICAqIElmIGxlZnQgdW5kZWZpbmVkIHRoZSBKYXZhU2NyaXB0IHJlcHJlc2VudGF0aW9uIG9mIHRoZXNlIGxheW91dHNcbiAgICAgKiB3aWxsIGJlIE9iamVjdCBpbnN0YW5jZXMuXG4gICAgICpcbiAgICAgKiBTZWUge0BsaW5rIGJpbmRDb25zdHJ1Y3RvckxheW91dH0uXG4gICAgICovXG4gICAgbWFrZURlc3RpbmF0aW9uT2JqZWN0KCkge1xuICAgICAgICByZXR1cm4ge307XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENhbGN1bGF0ZSB0aGUgc3BhbiBvZiBhIHNwZWNpZmljIGluc3RhbmNlIG9mIGEgbGF5b3V0LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtVaW50OEFycmF5fSBiIC0gdGhlIGJ1ZmZlciB0aGF0IGNvbnRhaW5zIGFuIGVuY29kZWQgaW5zdGFuY2UuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW29mZnNldF0gLSB0aGUgb2Zmc2V0IGF0IHdoaWNoIHRoZSBlbmNvZGVkIGluc3RhbmNlXG4gICAgICogc3RhcnRzLiAgSWYgYWJzZW50IGEgemVybyBvZmZzZXQgaXMgaW5mZXJyZWQuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHtOdW1iZXJ9IC0gdGhlIG51bWJlciBvZiBieXRlcyBjb3ZlcmVkIGJ5IHRoZSBsYXlvdXRcbiAgICAgKiBpbnN0YW5jZS4gIElmIHRoaXMgbWV0aG9kIGlzIG5vdCBvdmVycmlkZGVuIGluIGEgc3ViY2xhc3MgdGhlXG4gICAgICogZGVmaW5pdGlvbi10aW1lIGNvbnN0YW50IHtAbGluayBMYXlvdXQjc3BhbnxzcGFufSB3aWxsIGJlXG4gICAgICogcmV0dXJuZWQuXG4gICAgICpcbiAgICAgKiBAdGhyb3dzIHtSYW5nZUVycm9yfSAtIGlmIHRoZSBsZW5ndGggb2YgdGhlIHZhbHVlIGNhbm5vdCBiZVxuICAgICAqIGRldGVybWluZWQuXG4gICAgICovXG4gICAgZ2V0U3BhbihiLCBvZmZzZXQpIHtcbiAgICAgICAgaWYgKDAgPiB0aGlzLnNwYW4pIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdpbmRldGVybWluYXRlIHNwYW4nKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5zcGFuO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXBsaWNhdGUgdGhlIGxheW91dCB1c2luZyBhIG5ldyBwcm9wZXJ0eS5cbiAgICAgKlxuICAgICAqIFRoaXMgZnVuY3Rpb24gbXVzdCBiZSB1c2VkIHRvIGdldCBhIHN0cnVjdHVyYWxseS1lcXVpdmFsZW50IGxheW91dFxuICAgICAqIHdpdGggYSBkaWZmZXJlbnQgbmFtZSBzaW5jZSBhbGwge0BsaW5rIExheW91dH0gaW5zdGFuY2VzIGFyZVxuICAgICAqIGltbXV0YWJsZS5cbiAgICAgKlxuICAgICAqICoqTk9URSoqIFRoaXMgaXMgYSBzaGFsbG93IGNvcHkuICBBbGwgZmllbGRzIGV4Y2VwdCB7QGxpbmtcbiAgICAgKiBMYXlvdXQjcHJvcGVydHl8cHJvcGVydHl9IGFyZSBzdHJpY3RseSBlcXVhbCB0byB0aGUgb3JpZ2luIGxheW91dC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBwcm9wZXJ0eSAtIHRoZSB2YWx1ZSBmb3Ige0BsaW5rXG4gICAgICogTGF5b3V0I3Byb3BlcnR5fHByb3BlcnR5fSBpbiB0aGUgcmVwbGljYS5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtMYXlvdXR9IC0gdGhlIGNvcHkgd2l0aCB7QGxpbmsgTGF5b3V0I3Byb3BlcnR5fHByb3BlcnR5fVxuICAgICAqIHNldCB0byBgcHJvcGVydHlgLlxuICAgICAqL1xuICAgIHJlcGxpY2F0ZShwcm9wZXJ0eSkge1xuICAgICAgICBjb25zdCBydiA9IE9iamVjdC5jcmVhdGUodGhpcy5jb25zdHJ1Y3Rvci5wcm90b3R5cGUpO1xuICAgICAgICBPYmplY3QuYXNzaWduKHJ2LCB0aGlzKTtcbiAgICAgICAgcnYucHJvcGVydHkgPSBwcm9wZXJ0eTtcbiAgICAgICAgcmV0dXJuIHJ2O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYW4gb2JqZWN0IGZyb20gbGF5b3V0IHByb3BlcnRpZXMgYW5kIGFuIGFycmF5IG9mIHZhbHVlcy5cbiAgICAgKlxuICAgICAqICoqTk9URSoqIFRoaXMgZnVuY3Rpb24gcmV0dXJucyBgdW5kZWZpbmVkYCBpZiBpbnZva2VkIG9uIGEgbGF5b3V0XG4gICAgICogdGhhdCBkb2VzIG5vdCByZXR1cm4gaXRzIHZhbHVlIGFzIGFuIE9iamVjdC4gIE9iamVjdHMgYXJlXG4gICAgICogcmV0dXJuZWQgZm9yIHRoaW5ncyB0aGF0IGFyZSBhIHtAbGluayBTdHJ1Y3R1cmV9LCB3aGljaCBpbmNsdWRlc1xuICAgICAqIHtAbGluayBWYXJpYW50TGF5b3V0fHZhcmlhbnQgbGF5b3V0c30gaWYgdGhleSBhcmUgc3RydWN0dXJlcywgYW5kXG4gICAgICogZXhjbHVkZXMge0BsaW5rIFVuaW9ufXMuICBJZiB5b3Ugd2FudCB0aGlzIGZlYXR1cmUgZm9yIGEgdW5pb25cbiAgICAgKiB5b3UgbXVzdCB1c2Uge0BsaW5rIFVuaW9uLmdldFZhcmlhbnR8Z2V0VmFyaWFudH0gdG8gc2VsZWN0IHRoZVxuICAgICAqIGRlc2lyZWQgbGF5b3V0LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtBcnJheX0gdmFsdWVzIC0gYW4gYXJyYXkgb2YgdmFsdWVzIHRoYXQgY29ycmVzcG9uZCB0byB0aGVcbiAgICAgKiBkZWZhdWx0IG9yZGVyIGZvciBwcm9wZXJ0aWVzLiAgQXMgd2l0aCB7QGxpbmsgTGF5b3V0I2RlY29kZXxkZWNvZGV9XG4gICAgICogbGF5b3V0IGVsZW1lbnRzIHRoYXQgaGF2ZSBubyBwcm9wZXJ0eSBuYW1lIGFyZSBza2lwcGVkIHdoZW5cbiAgICAgKiBpdGVyYXRpbmcgb3ZlciB0aGUgYXJyYXkgdmFsdWVzLiAgT25seSB0aGUgdG9wLWxldmVsIHByb3BlcnRpZXMgYXJlXG4gICAgICogYXNzaWduZWQ7IGFyZ3VtZW50cyBhcmUgbm90IGFzc2lnbmVkIHRvIHByb3BlcnRpZXMgb2YgY29udGFpbmVkXG4gICAgICogbGF5b3V0cy4gIEFueSB1bnVzZWQgdmFsdWVzIGFyZSBpZ25vcmVkLlxuICAgICAqXG4gICAgICogQHJldHVybiB7KE9iamVjdHx1bmRlZmluZWQpfVxuICAgICAqL1xuICAgIGZyb21BcnJheSh2YWx1ZXMpIHtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG59XG5leHBvcnRzLkxheW91dCA9IExheW91dDtcbi8qIFByb3ZpZGUgdGV4dCB0aGF0IGNhcnJpZXMgYSBuYW1lIChzdWNoIGFzIGZvciBhIGZ1bmN0aW9uIHRoYXQgd2lsbFxuICogYmUgdGhyb3dpbmcgYW4gZXJyb3IpIGFubm90YXRlZCB3aXRoIHRoZSBwcm9wZXJ0eSBvZiBhIGdpdmVuIGxheW91dFxuICogKHN1Y2ggYXMgb25lIGZvciB3aGljaCB0aGUgdmFsdWUgd2FzIHVuYWNjZXB0YWJsZSkuXG4gKlxuICogQGlnbm9yZSAqL1xuZnVuY3Rpb24gbmFtZVdpdGhQcm9wZXJ0eShuYW1lLCBsbykge1xuICAgIGlmIChsby5wcm9wZXJ0eSkge1xuICAgICAgICByZXR1cm4gbmFtZSArICdbJyArIGxvLnByb3BlcnR5ICsgJ10nO1xuICAgIH1cbiAgICByZXR1cm4gbmFtZTtcbn1cbmV4cG9ydHMubmFtZVdpdGhQcm9wZXJ0eSA9IG5hbWVXaXRoUHJvcGVydHk7XG4vKipcbiAqIEF1Z21lbnQgYSBjbGFzcyBzbyB0aGF0IGluc3RhbmNlcyBjYW4gYmUgZW5jb2RlZC9kZWNvZGVkIHVzaW5nIGFcbiAqIGdpdmVuIGxheW91dC5cbiAqXG4gKiBDYWxsaW5nIHRoaXMgZnVuY3Rpb24gY291cGxlcyBgQ2xhc3NgIHdpdGggYGxheW91dGAgaW4gc2V2ZXJhbCB3YXlzOlxuICpcbiAqICogYENsYXNzLmxheW91dF9gIGJlY29tZXMgYSBzdGF0aWMgbWVtYmVyIHByb3BlcnR5IGVxdWFsIHRvIGBsYXlvdXRgO1xuICogKiBgbGF5b3V0LmJvdW5kQ29uc3RydWN0b3JfYCBiZWNvbWVzIGEgc3RhdGljIG1lbWJlciBwcm9wZXJ0eSBlcXVhbFxuICogICAgdG8gYENsYXNzYDtcbiAqICogVGhlIHtAbGluayBMYXlvdXQjbWFrZURlc3RpbmF0aW9uT2JqZWN0fG1ha2VEZXN0aW5hdGlvbk9iamVjdCgpfVxuICogICBwcm9wZXJ0eSBvZiBgbGF5b3V0YCBpcyBzZXQgdG8gYSBmdW5jdGlvbiB0aGF0IHJldHVybnMgYSBgbmV3XG4gKiAgIENsYXNzKClgO1xuICogKiBgQ2xhc3MuZGVjb2RlKGIsIG9mZnNldClgIGJlY29tZXMgYSBzdGF0aWMgbWVtYmVyIGZ1bmN0aW9uIHRoYXRcbiAqICAgZGVsZWdhdGVzIHRvIHtAbGluayBMYXlvdXQjZGVjb2RlfGxheW91dC5kZWNvZGV9LiAgVGhlXG4gKiAgIHN5bnRoZXNpemVkIGZ1bmN0aW9uIG1heSBiZSBjYXB0dXJlZCBhbmQgZXh0ZW5kZWQuXG4gKiAqIGBDbGFzcy5wcm90b3R5cGUuZW5jb2RlKGIsIG9mZnNldClgIHByb3ZpZGVzIGFuIGluc3RhbmNlIG1lbWJlclxuICogICBmdW5jdGlvbiB0aGF0IGRlbGVnYXRlcyB0byB7QGxpbmsgTGF5b3V0I2VuY29kZXxsYXlvdXQuZW5jb2RlfVxuICogICB3aXRoIGBzcmNgIHNldCB0byBgdGhpc2AuICBUaGUgc3ludGhlc2l6ZWQgZnVuY3Rpb24gbWF5IGJlXG4gKiAgIGNhcHR1cmVkIGFuZCBleHRlbmRlZCwgYnV0IHdoZW4gdGhlIGV4dGVuc2lvbiBpcyBpbnZva2VkIGB0aGlzYFxuICogICBtdXN0IGJlIGV4cGxpY2l0bHkgYm91bmQgdG8gdGhlIGluc3RhbmNlLlxuICpcbiAqIEBwYXJhbSB7Y2xhc3N9IENsYXNzIC0gYSBKYXZhU2NyaXB0IGNsYXNzIHdpdGggYSBudWxsYXJ5XG4gKiBjb25zdHJ1Y3Rvci5cbiAqXG4gKiBAcGFyYW0ge0xheW91dH0gbGF5b3V0IC0gdGhlIHtAbGluayBMYXlvdXR9IGluc3RhbmNlIHVzZWQgdG8gZW5jb2RlXG4gKiBpbnN0YW5jZXMgb2YgYENsYXNzYC5cbiAqL1xuLy8gYENsYXNzYCBtdXN0IGJlIGEgY29uc3RydWN0b3IgRnVuY3Rpb24sIGJ1dCB0aGUgYXNzaWdubWVudCBvZiBhIGBsYXlvdXRfYCBwcm9wZXJ0eSB0byBpdCBtYWtlcyBpdCBkaWZmaWN1bHQgdG8gdHlwZVxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9leHBsaWNpdC1tb2R1bGUtYm91bmRhcnktdHlwZXNcbmZ1bmN0aW9uIGJpbmRDb25zdHJ1Y3RvckxheW91dChDbGFzcywgbGF5b3V0KSB7XG4gICAgaWYgKCdmdW5jdGlvbicgIT09IHR5cGVvZiBDbGFzcykge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdDbGFzcyBtdXN0IGJlIGNvbnN0cnVjdG9yJyk7XG4gICAgfVxuICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoQ2xhc3MsICdsYXlvdXRfJykpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDbGFzcyBpcyBhbHJlYWR5IGJvdW5kIHRvIGEgbGF5b3V0Jyk7XG4gICAgfVxuICAgIGlmICghKGxheW91dCAmJiAobGF5b3V0IGluc3RhbmNlb2YgTGF5b3V0KSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignbGF5b3V0IG11c3QgYmUgYSBMYXlvdXQnKTtcbiAgICB9XG4gICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChsYXlvdXQsICdib3VuZENvbnN0cnVjdG9yXycpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignbGF5b3V0IGlzIGFscmVhZHkgYm91bmQgdG8gYSBjb25zdHJ1Y3RvcicpO1xuICAgIH1cbiAgICBDbGFzcy5sYXlvdXRfID0gbGF5b3V0O1xuICAgIGxheW91dC5ib3VuZENvbnN0cnVjdG9yXyA9IENsYXNzO1xuICAgIGxheW91dC5tYWtlRGVzdGluYXRpb25PYmplY3QgPSAoKCkgPT4gbmV3IENsYXNzKCkpO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShDbGFzcy5wcm90b3R5cGUsICdlbmNvZGUnLCB7XG4gICAgICAgIHZhbHVlKGIsIG9mZnNldCkge1xuICAgICAgICAgICAgcmV0dXJuIGxheW91dC5lbmNvZGUodGhpcywgYiwgb2Zmc2V0KTtcbiAgICAgICAgfSxcbiAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KENsYXNzLCAnZGVjb2RlJywge1xuICAgICAgICB2YWx1ZShiLCBvZmZzZXQpIHtcbiAgICAgICAgICAgIHJldHVybiBsYXlvdXQuZGVjb2RlKGIsIG9mZnNldCk7XG4gICAgICAgIH0sXG4gICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgIH0pO1xufVxuZXhwb3J0cy5iaW5kQ29uc3RydWN0b3JMYXlvdXQgPSBiaW5kQ29uc3RydWN0b3JMYXlvdXQ7XG4vKipcbiAqIEFuIG9iamVjdCB0aGF0IGJlaGF2ZXMgbGlrZSBhIGxheW91dCBidXQgZG9lcyBub3QgY29uc3VtZSBzcGFjZVxuICogd2l0aGluIGl0cyBjb250YWluaW5nIGxheW91dC5cbiAqXG4gKiBUaGlzIGlzIHByaW1hcmlseSB1c2VkIHRvIG9idGFpbiBtZXRhZGF0YSBhYm91dCBhIG1lbWJlciwgc3VjaCBhcyBhXG4gKiB7QGxpbmsgT2Zmc2V0TGF5b3V0fSB0aGF0IGNhbiBwcm92aWRlIGRhdGEgYWJvdXQgYSB7QGxpbmtcbiAqIExheW91dCNnZXRTcGFufHZhbHVlLXNwZWNpZmljIHNwYW59LlxuICpcbiAqICoqTk9URSoqIFRoaXMgaXMgYW4gYWJzdHJhY3QgYmFzZSBjbGFzczsgeW91IGNhbiBjcmVhdGUgaW5zdGFuY2VzXG4gKiBpZiBpdCBhbXVzZXMgeW91LCBidXQgdGhleSB3b24ndCBzdXBwb3J0IHtAbGlua1xuICogRXh0ZXJuYWxMYXlvdXQjaXNDb3VudHxpc0NvdW50fSBvciBvdGhlciB7QGxpbmsgTGF5b3V0fSBmdW5jdGlvbnMuXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IHNwYW4gLSBpbml0aWFsaXplciBmb3Ige0BsaW5rIExheW91dCNzcGFufHNwYW59LlxuICogVGhlIHBhcmFtZXRlciBjYW4gcmFuZ2UgZnJvbSAxIHRocm91Z2ggNi5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gW3Byb3BlcnR5XSAtIGluaXRpYWxpemVyIGZvciB7QGxpbmtcbiAqIExheW91dCNwcm9wZXJ0eXxwcm9wZXJ0eX0uXG4gKlxuICogQGFic3RyYWN0XG4gKiBAYXVnbWVudHMge0xheW91dH1cbiAqL1xuY2xhc3MgRXh0ZXJuYWxMYXlvdXQgZXh0ZW5kcyBMYXlvdXQge1xuICAgIC8qKlxuICAgICAqIFJldHVybiBgdHJ1ZWAgaWZmIHRoZSBleHRlcm5hbCBsYXlvdXQgZGVjb2RlcyB0byBhbiB1bnNpZ25lZFxuICAgICAqIGludGVnZXIgbGF5b3V0LlxuICAgICAqXG4gICAgICogSW4gdGhhdCBjYXNlIGl0IGNhbiBiZSB1c2VkIGFzIHRoZSBzb3VyY2Ugb2Yge0BsaW5rXG4gICAgICogU2VxdWVuY2UjY291bnR8U2VxdWVuY2UgY291bnRzfSwge0BsaW5rIEJsb2IjbGVuZ3RofEJsb2IgbGVuZ3Roc30sXG4gICAgICogb3IgYXMge0BsaW5rIFVuaW9uTGF5b3V0RGlzY3JpbWluYXRvciNsYXlvdXR8ZXh0ZXJuYWwgdW5pb25cbiAgICAgKiBkaXNjcmltaW5hdG9yc30uXG4gICAgICpcbiAgICAgKiBAYWJzdHJhY3RcbiAgICAgKi9cbiAgICBpc0NvdW50KCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0V4dGVybmFsTGF5b3V0IGlzIGFic3RyYWN0Jyk7XG4gICAgfVxufVxuZXhwb3J0cy5FeHRlcm5hbExheW91dCA9IEV4dGVybmFsTGF5b3V0O1xuLyoqXG4gKiBBbiB7QGxpbmsgRXh0ZXJuYWxMYXlvdXR9IHRoYXQgZGV0ZXJtaW5lcyBpdHMge0BsaW5rXG4gKiBMYXlvdXQjZGVjb2RlfHZhbHVlfSBiYXNlZCBvbiBvZmZzZXQgaW50byBhbmQgbGVuZ3RoIG9mIHRoZSBidWZmZXJcbiAqIG9uIHdoaWNoIGl0IGlzIGludm9rZWQuXG4gKlxuICogKkZhY3RvcnkqOiB7QGxpbmsgbW9kdWxlOkxheW91dC5ncmVlZHl8Z3JlZWR5fVxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSBbZWxlbWVudFNwYW5dIC0gaW5pdGlhbGl6ZXIgZm9yIHtAbGlua1xuICogR3JlZWR5Q291bnQjZWxlbWVudFNwYW58ZWxlbWVudFNwYW59LlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBbcHJvcGVydHldIC0gaW5pdGlhbGl6ZXIgZm9yIHtAbGlua1xuICogTGF5b3V0I3Byb3BlcnR5fHByb3BlcnR5fS5cbiAqXG4gKiBAYXVnbWVudHMge0V4dGVybmFsTGF5b3V0fVxuICovXG5jbGFzcyBHcmVlZHlDb3VudCBleHRlbmRzIEV4dGVybmFsTGF5b3V0IHtcbiAgICBjb25zdHJ1Y3RvcihlbGVtZW50U3BhbiA9IDEsIHByb3BlcnR5KSB7XG4gICAgICAgIGlmICgoIU51bWJlci5pc0ludGVnZXIoZWxlbWVudFNwYW4pKSB8fCAoMCA+PSBlbGVtZW50U3BhbikpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2VsZW1lbnRTcGFuIG11c3QgYmUgYSAocG9zaXRpdmUpIGludGVnZXInKTtcbiAgICAgICAgfVxuICAgICAgICBzdXBlcigtMSwgcHJvcGVydHkpO1xuICAgICAgICAvKiogVGhlIGxheW91dCBmb3IgaW5kaXZpZHVhbCBlbGVtZW50cyBvZiB0aGUgc2VxdWVuY2UuICBUaGUgdmFsdWVcbiAgICAgICAgICogbXVzdCBiZSBhIHBvc2l0aXZlIGludGVnZXIuICBJZiBub3QgcHJvdmlkZWQsIHRoZSB2YWx1ZSB3aWxsIGJlXG4gICAgICAgICAqIDEuICovXG4gICAgICAgIHRoaXMuZWxlbWVudFNwYW4gPSBlbGVtZW50U3BhbjtcbiAgICB9XG4gICAgLyoqIEBvdmVycmlkZSAqL1xuICAgIGlzQ291bnQoKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICAvKiogQG92ZXJyaWRlICovXG4gICAgZGVjb2RlKGIsIG9mZnNldCA9IDApIHtcbiAgICAgICAgY2hlY2tVaW50OEFycmF5KGIpO1xuICAgICAgICBjb25zdCByZW0gPSBiLmxlbmd0aCAtIG9mZnNldDtcbiAgICAgICAgcmV0dXJuIE1hdGguZmxvb3IocmVtIC8gdGhpcy5lbGVtZW50U3Bhbik7XG4gICAgfVxuICAgIC8qKiBAb3ZlcnJpZGUgKi9cbiAgICBlbmNvZGUoc3JjLCBiLCBvZmZzZXQpIHtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgfVxufVxuZXhwb3J0cy5HcmVlZHlDb3VudCA9IEdyZWVkeUNvdW50O1xuLyoqXG4gKiBBbiB7QGxpbmsgRXh0ZXJuYWxMYXlvdXR9IHRoYXQgc3VwcG9ydHMgYWNjZXNzaW5nIGEge0BsaW5rIExheW91dH1cbiAqIGF0IGEgZml4ZWQgb2Zmc2V0IGZyb20gdGhlIHN0YXJ0IG9mIGFub3RoZXIgTGF5b3V0LiAgVGhlIG9mZnNldCBtYXlcbiAqIGJlIGJlZm9yZSwgd2l0aGluLCBvciBhZnRlciB0aGUgYmFzZSBsYXlvdXQuXG4gKlxuICogKkZhY3RvcnkqOiB7QGxpbmsgbW9kdWxlOkxheW91dC5vZmZzZXR8b2Zmc2V0fVxuICpcbiAqIEBwYXJhbSB7TGF5b3V0fSBsYXlvdXQgLSBpbml0aWFsaXplciBmb3Ige0BsaW5rXG4gKiBPZmZzZXRMYXlvdXQjbGF5b3V0fGxheW91dH0sIG1vZHVsbyBgcHJvcGVydHlgLlxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSBbb2Zmc2V0XSAtIEluaXRpYWxpemVzIHtAbGlua1xuICogT2Zmc2V0TGF5b3V0I29mZnNldHxvZmZzZXR9LiAgRGVmYXVsdHMgdG8gemVyby5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gW3Byb3BlcnR5XSAtIE9wdGlvbmFsIG5ldyBwcm9wZXJ0eSBuYW1lIGZvciBhXG4gKiB7QGxpbmsgTGF5b3V0I3JlcGxpY2F0ZXwgcmVwbGljYX0gb2YgYGxheW91dGAgdG8gYmUgdXNlZCBhcyB7QGxpbmtcbiAqIE9mZnNldExheW91dCNsYXlvdXR8bGF5b3V0fS4gIElmIG5vdCBwcm92aWRlZCB0aGUgYGxheW91dGAgaXMgdXNlZFxuICogdW5jaGFuZ2VkLlxuICpcbiAqIEBhdWdtZW50cyB7TGF5b3V0fVxuICovXG5jbGFzcyBPZmZzZXRMYXlvdXQgZXh0ZW5kcyBFeHRlcm5hbExheW91dCB7XG4gICAgY29uc3RydWN0b3IobGF5b3V0LCBvZmZzZXQgPSAwLCBwcm9wZXJ0eSkge1xuICAgICAgICBpZiAoIShsYXlvdXQgaW5zdGFuY2VvZiBMYXlvdXQpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdsYXlvdXQgbXVzdCBiZSBhIExheW91dCcpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghTnVtYmVyLmlzSW50ZWdlcihvZmZzZXQpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdvZmZzZXQgbXVzdCBiZSBpbnRlZ2VyIG9yIHVuZGVmaW5lZCcpO1xuICAgICAgICB9XG4gICAgICAgIHN1cGVyKGxheW91dC5zcGFuLCBwcm9wZXJ0eSB8fCBsYXlvdXQucHJvcGVydHkpO1xuICAgICAgICAvKiogVGhlIHN1Ym9yZGluYXRlZCBsYXlvdXQuICovXG4gICAgICAgIHRoaXMubGF5b3V0ID0gbGF5b3V0O1xuICAgICAgICAvKiogVGhlIGxvY2F0aW9uIG9mIHtAbGluayBPZmZzZXRMYXlvdXQjbGF5b3V0fSByZWxhdGl2ZSB0byB0aGVcbiAgICAgICAgICogc3RhcnQgb2YgYW5vdGhlciBsYXlvdXQuXG4gICAgICAgICAqXG4gICAgICAgICAqIFRoZSB2YWx1ZSBtYXkgYmUgcG9zaXRpdmUgb3IgbmVnYXRpdmUsIGJ1dCBhbiBlcnJvciB3aWxsIHRocm93blxuICAgICAgICAgKiBpZiBhdCB0aGUgcG9pbnQgb2YgdXNlIGl0IGdvZXMgb3V0c2lkZSB0aGUgc3BhbiBvZiB0aGUgVWludDhBcnJheVxuICAgICAgICAgKiBiZWluZyBhY2Nlc3NlZC4gICovXG4gICAgICAgIHRoaXMub2Zmc2V0ID0gb2Zmc2V0O1xuICAgIH1cbiAgICAvKiogQG92ZXJyaWRlICovXG4gICAgaXNDb3VudCgpIHtcbiAgICAgICAgcmV0dXJuICgodGhpcy5sYXlvdXQgaW5zdGFuY2VvZiBVSW50KVxuICAgICAgICAgICAgfHwgKHRoaXMubGF5b3V0IGluc3RhbmNlb2YgVUludEJFKSk7XG4gICAgfVxuICAgIC8qKiBAb3ZlcnJpZGUgKi9cbiAgICBkZWNvZGUoYiwgb2Zmc2V0ID0gMCkge1xuICAgICAgICByZXR1cm4gdGhpcy5sYXlvdXQuZGVjb2RlKGIsIG9mZnNldCArIHRoaXMub2Zmc2V0KTtcbiAgICB9XG4gICAgLyoqIEBvdmVycmlkZSAqL1xuICAgIGVuY29kZShzcmMsIGIsIG9mZnNldCA9IDApIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubGF5b3V0LmVuY29kZShzcmMsIGIsIG9mZnNldCArIHRoaXMub2Zmc2V0KTtcbiAgICB9XG59XG5leHBvcnRzLk9mZnNldExheW91dCA9IE9mZnNldExheW91dDtcbi8qKlxuICogUmVwcmVzZW50IGFuIHVuc2lnbmVkIGludGVnZXIgaW4gbGl0dGxlLWVuZGlhbiBmb3JtYXQuXG4gKlxuICogKkZhY3RvcnkqOiB7QGxpbmsgbW9kdWxlOkxheW91dC51OHx1OH0sIHtAbGlua1xuICogIG1vZHVsZTpMYXlvdXQudTE2fHUxNn0sIHtAbGluayBtb2R1bGU6TGF5b3V0LnUyNHx1MjR9LCB7QGxpbmtcbiAqICBtb2R1bGU6TGF5b3V0LnUzMnx1MzJ9LCB7QGxpbmsgbW9kdWxlOkxheW91dC51NDB8dTQwfSwge0BsaW5rXG4gKiAgbW9kdWxlOkxheW91dC51NDh8dTQ4fVxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSBzcGFuIC0gaW5pdGlhbGl6ZXIgZm9yIHtAbGluayBMYXlvdXQjc3BhbnxzcGFufS5cbiAqIFRoZSBwYXJhbWV0ZXIgY2FuIHJhbmdlIGZyb20gMSB0aHJvdWdoIDYuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IFtwcm9wZXJ0eV0gLSBpbml0aWFsaXplciBmb3Ige0BsaW5rXG4gKiBMYXlvdXQjcHJvcGVydHl8cHJvcGVydHl9LlxuICpcbiAqIEBhdWdtZW50cyB7TGF5b3V0fVxuICovXG5jbGFzcyBVSW50IGV4dGVuZHMgTGF5b3V0IHtcbiAgICBjb25zdHJ1Y3RvcihzcGFuLCBwcm9wZXJ0eSkge1xuICAgICAgICBzdXBlcihzcGFuLCBwcm9wZXJ0eSk7XG4gICAgICAgIGlmICg2IDwgdGhpcy5zcGFuKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignc3BhbiBtdXN0IG5vdCBleGNlZWQgNiBieXRlcycpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKiBAb3ZlcnJpZGUgKi9cbiAgICBkZWNvZGUoYiwgb2Zmc2V0ID0gMCkge1xuICAgICAgICByZXR1cm4gdWludDhBcnJheVRvQnVmZmVyKGIpLnJlYWRVSW50TEUob2Zmc2V0LCB0aGlzLnNwYW4pO1xuICAgIH1cbiAgICAvKiogQG92ZXJyaWRlICovXG4gICAgZW5jb2RlKHNyYywgYiwgb2Zmc2V0ID0gMCkge1xuICAgICAgICB1aW50OEFycmF5VG9CdWZmZXIoYikud3JpdGVVSW50TEUoc3JjLCBvZmZzZXQsIHRoaXMuc3Bhbik7XG4gICAgICAgIHJldHVybiB0aGlzLnNwYW47XG4gICAgfVxufVxuZXhwb3J0cy5VSW50ID0gVUludDtcbi8qKlxuICogUmVwcmVzZW50IGFuIHVuc2lnbmVkIGludGVnZXIgaW4gYmlnLWVuZGlhbiBmb3JtYXQuXG4gKlxuICogKkZhY3RvcnkqOiB7QGxpbmsgbW9kdWxlOkxheW91dC51OGJlfHU4YmV9LCB7QGxpbmtcbiAqIG1vZHVsZTpMYXlvdXQudTE2YmV8dTE2YmV9LCB7QGxpbmsgbW9kdWxlOkxheW91dC51MjRiZXx1MjRiZX0sXG4gKiB7QGxpbmsgbW9kdWxlOkxheW91dC51MzJiZXx1MzJiZX0sIHtAbGlua1xuICogbW9kdWxlOkxheW91dC51NDBiZXx1NDBiZX0sIHtAbGluayBtb2R1bGU6TGF5b3V0LnU0OGJlfHU0OGJlfVxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSBzcGFuIC0gaW5pdGlhbGl6ZXIgZm9yIHtAbGluayBMYXlvdXQjc3BhbnxzcGFufS5cbiAqIFRoZSBwYXJhbWV0ZXIgY2FuIHJhbmdlIGZyb20gMSB0aHJvdWdoIDYuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IFtwcm9wZXJ0eV0gLSBpbml0aWFsaXplciBmb3Ige0BsaW5rXG4gKiBMYXlvdXQjcHJvcGVydHl8cHJvcGVydHl9LlxuICpcbiAqIEBhdWdtZW50cyB7TGF5b3V0fVxuICovXG5jbGFzcyBVSW50QkUgZXh0ZW5kcyBMYXlvdXQge1xuICAgIGNvbnN0cnVjdG9yKHNwYW4sIHByb3BlcnR5KSB7XG4gICAgICAgIHN1cGVyKHNwYW4sIHByb3BlcnR5KTtcbiAgICAgICAgaWYgKDYgPCB0aGlzLnNwYW4pIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdzcGFuIG11c3Qgbm90IGV4Y2VlZCA2IGJ5dGVzJyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqIEBvdmVycmlkZSAqL1xuICAgIGRlY29kZShiLCBvZmZzZXQgPSAwKSB7XG4gICAgICAgIHJldHVybiB1aW50OEFycmF5VG9CdWZmZXIoYikucmVhZFVJbnRCRShvZmZzZXQsIHRoaXMuc3Bhbik7XG4gICAgfVxuICAgIC8qKiBAb3ZlcnJpZGUgKi9cbiAgICBlbmNvZGUoc3JjLCBiLCBvZmZzZXQgPSAwKSB7XG4gICAgICAgIHVpbnQ4QXJyYXlUb0J1ZmZlcihiKS53cml0ZVVJbnRCRShzcmMsIG9mZnNldCwgdGhpcy5zcGFuKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3BhbjtcbiAgICB9XG59XG5leHBvcnRzLlVJbnRCRSA9IFVJbnRCRTtcbi8qKlxuICogUmVwcmVzZW50IGEgc2lnbmVkIGludGVnZXIgaW4gbGl0dGxlLWVuZGlhbiBmb3JtYXQuXG4gKlxuICogKkZhY3RvcnkqOiB7QGxpbmsgbW9kdWxlOkxheW91dC5zOHxzOH0sIHtAbGlua1xuICogIG1vZHVsZTpMYXlvdXQuczE2fHMxNn0sIHtAbGluayBtb2R1bGU6TGF5b3V0LnMyNHxzMjR9LCB7QGxpbmtcbiAqICBtb2R1bGU6TGF5b3V0LnMzMnxzMzJ9LCB7QGxpbmsgbW9kdWxlOkxheW91dC5zNDB8czQwfSwge0BsaW5rXG4gKiAgbW9kdWxlOkxheW91dC5zNDh8czQ4fVxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSBzcGFuIC0gaW5pdGlhbGl6ZXIgZm9yIHtAbGluayBMYXlvdXQjc3BhbnxzcGFufS5cbiAqIFRoZSBwYXJhbWV0ZXIgY2FuIHJhbmdlIGZyb20gMSB0aHJvdWdoIDYuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IFtwcm9wZXJ0eV0gLSBpbml0aWFsaXplciBmb3Ige0BsaW5rXG4gKiBMYXlvdXQjcHJvcGVydHl8cHJvcGVydHl9LlxuICpcbiAqIEBhdWdtZW50cyB7TGF5b3V0fVxuICovXG5jbGFzcyBJbnQgZXh0ZW5kcyBMYXlvdXQge1xuICAgIGNvbnN0cnVjdG9yKHNwYW4sIHByb3BlcnR5KSB7XG4gICAgICAgIHN1cGVyKHNwYW4sIHByb3BlcnR5KTtcbiAgICAgICAgaWYgKDYgPCB0aGlzLnNwYW4pIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdzcGFuIG11c3Qgbm90IGV4Y2VlZCA2IGJ5dGVzJyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqIEBvdmVycmlkZSAqL1xuICAgIGRlY29kZShiLCBvZmZzZXQgPSAwKSB7XG4gICAgICAgIHJldHVybiB1aW50OEFycmF5VG9CdWZmZXIoYikucmVhZEludExFKG9mZnNldCwgdGhpcy5zcGFuKTtcbiAgICB9XG4gICAgLyoqIEBvdmVycmlkZSAqL1xuICAgIGVuY29kZShzcmMsIGIsIG9mZnNldCA9IDApIHtcbiAgICAgICAgdWludDhBcnJheVRvQnVmZmVyKGIpLndyaXRlSW50TEUoc3JjLCBvZmZzZXQsIHRoaXMuc3Bhbik7XG4gICAgICAgIHJldHVybiB0aGlzLnNwYW47XG4gICAgfVxufVxuZXhwb3J0cy5JbnQgPSBJbnQ7XG4vKipcbiAqIFJlcHJlc2VudCBhIHNpZ25lZCBpbnRlZ2VyIGluIGJpZy1lbmRpYW4gZm9ybWF0LlxuICpcbiAqICpGYWN0b3J5Kjoge0BsaW5rIG1vZHVsZTpMYXlvdXQuczhiZXxzOGJlfSwge0BsaW5rXG4gKiBtb2R1bGU6TGF5b3V0LnMxNmJlfHMxNmJlfSwge0BsaW5rIG1vZHVsZTpMYXlvdXQuczI0YmV8czI0YmV9LFxuICoge0BsaW5rIG1vZHVsZTpMYXlvdXQuczMyYmV8czMyYmV9LCB7QGxpbmtcbiAqIG1vZHVsZTpMYXlvdXQuczQwYmV8czQwYmV9LCB7QGxpbmsgbW9kdWxlOkxheW91dC5zNDhiZXxzNDhiZX1cbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gc3BhbiAtIGluaXRpYWxpemVyIGZvciB7QGxpbmsgTGF5b3V0I3NwYW58c3Bhbn0uXG4gKiBUaGUgcGFyYW1ldGVyIGNhbiByYW5nZSBmcm9tIDEgdGhyb3VnaCA2LlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBbcHJvcGVydHldIC0gaW5pdGlhbGl6ZXIgZm9yIHtAbGlua1xuICogTGF5b3V0I3Byb3BlcnR5fHByb3BlcnR5fS5cbiAqXG4gKiBAYXVnbWVudHMge0xheW91dH1cbiAqL1xuY2xhc3MgSW50QkUgZXh0ZW5kcyBMYXlvdXQge1xuICAgIGNvbnN0cnVjdG9yKHNwYW4sIHByb3BlcnR5KSB7XG4gICAgICAgIHN1cGVyKHNwYW4sIHByb3BlcnR5KTtcbiAgICAgICAgaWYgKDYgPCB0aGlzLnNwYW4pIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdzcGFuIG11c3Qgbm90IGV4Y2VlZCA2IGJ5dGVzJyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqIEBvdmVycmlkZSAqL1xuICAgIGRlY29kZShiLCBvZmZzZXQgPSAwKSB7XG4gICAgICAgIHJldHVybiB1aW50OEFycmF5VG9CdWZmZXIoYikucmVhZEludEJFKG9mZnNldCwgdGhpcy5zcGFuKTtcbiAgICB9XG4gICAgLyoqIEBvdmVycmlkZSAqL1xuICAgIGVuY29kZShzcmMsIGIsIG9mZnNldCA9IDApIHtcbiAgICAgICAgdWludDhBcnJheVRvQnVmZmVyKGIpLndyaXRlSW50QkUoc3JjLCBvZmZzZXQsIHRoaXMuc3Bhbik7XG4gICAgICAgIHJldHVybiB0aGlzLnNwYW47XG4gICAgfVxufVxuZXhwb3J0cy5JbnRCRSA9IEludEJFO1xuY29uc3QgVjJFMzIgPSBNYXRoLnBvdygyLCAzMik7XG4vKiBUcnVlIG1vZHVsdXMgaGlnaCBhbmQgbG93IDMyLWJpdCB3b3Jkcywgd2hlcmUgbG93IHdvcmQgaXMgYWx3YXlzXG4gKiBub24tbmVnYXRpdmUuICovXG5mdW5jdGlvbiBkaXZtb2RJbnQ2NChzcmMpIHtcbiAgICBjb25zdCBoaTMyID0gTWF0aC5mbG9vcihzcmMgLyBWMkUzMik7XG4gICAgY29uc3QgbG8zMiA9IHNyYyAtIChoaTMyICogVjJFMzIpO1xuICAgIHJldHVybiB7IGhpMzIsIGxvMzIgfTtcbn1cbi8qIFJlY29uc3RydWN0IE51bWJlciBmcm9tIHF1b3RpZW50IGFuZCBub24tbmVnYXRpdmUgcmVtYWluZGVyICovXG5mdW5jdGlvbiByb3VuZGVkSW50NjQoaGkzMiwgbG8zMikge1xuICAgIHJldHVybiBoaTMyICogVjJFMzIgKyBsbzMyO1xufVxuLyoqXG4gKiBSZXByZXNlbnQgYW4gdW5zaWduZWQgNjQtYml0IGludGVnZXIgaW4gbGl0dGxlLWVuZGlhbiBmb3JtYXQgd2hlblxuICogZW5jb2RlZCBhbmQgYXMgYSBuZWFyIGludGVncmFsIEphdmFTY3JpcHQgTnVtYmVyIHdoZW4gZGVjb2RlZC5cbiAqXG4gKiAqRmFjdG9yeSo6IHtAbGluayBtb2R1bGU6TGF5b3V0Lm51NjR8bnU2NH1cbiAqXG4gKiAqKk5PVEUqKiBWYWx1ZXMgd2l0aCBtYWduaXR1ZGUgZ3JlYXRlciB0aGFuIDJeNTIgbWF5IG5vdCBkZWNvZGUgdG9cbiAqIHRoZSBleGFjdCB2YWx1ZSBvZiB0aGUgZW5jb2RlZCByZXByZXNlbnRhdGlvbi5cbiAqXG4gKiBAYXVnbWVudHMge0xheW91dH1cbiAqL1xuY2xhc3MgTmVhclVJbnQ2NCBleHRlbmRzIExheW91dCB7XG4gICAgY29uc3RydWN0b3IocHJvcGVydHkpIHtcbiAgICAgICAgc3VwZXIoOCwgcHJvcGVydHkpO1xuICAgIH1cbiAgICAvKiogQG92ZXJyaWRlICovXG4gICAgZGVjb2RlKGIsIG9mZnNldCA9IDApIHtcbiAgICAgICAgY29uc3QgYnVmZmVyID0gdWludDhBcnJheVRvQnVmZmVyKGIpO1xuICAgICAgICBjb25zdCBsbzMyID0gYnVmZmVyLnJlYWRVSW50MzJMRShvZmZzZXQpO1xuICAgICAgICBjb25zdCBoaTMyID0gYnVmZmVyLnJlYWRVSW50MzJMRShvZmZzZXQgKyA0KTtcbiAgICAgICAgcmV0dXJuIHJvdW5kZWRJbnQ2NChoaTMyLCBsbzMyKTtcbiAgICB9XG4gICAgLyoqIEBvdmVycmlkZSAqL1xuICAgIGVuY29kZShzcmMsIGIsIG9mZnNldCA9IDApIHtcbiAgICAgICAgY29uc3Qgc3BsaXQgPSBkaXZtb2RJbnQ2NChzcmMpO1xuICAgICAgICBjb25zdCBidWZmZXIgPSB1aW50OEFycmF5VG9CdWZmZXIoYik7XG4gICAgICAgIGJ1ZmZlci53cml0ZVVJbnQzMkxFKHNwbGl0LmxvMzIsIG9mZnNldCk7XG4gICAgICAgIGJ1ZmZlci53cml0ZVVJbnQzMkxFKHNwbGl0LmhpMzIsIG9mZnNldCArIDQpO1xuICAgICAgICByZXR1cm4gODtcbiAgICB9XG59XG5leHBvcnRzLk5lYXJVSW50NjQgPSBOZWFyVUludDY0O1xuLyoqXG4gKiBSZXByZXNlbnQgYW4gdW5zaWduZWQgNjQtYml0IGludGVnZXIgaW4gYmlnLWVuZGlhbiBmb3JtYXQgd2hlblxuICogZW5jb2RlZCBhbmQgYXMgYSBuZWFyIGludGVncmFsIEphdmFTY3JpcHQgTnVtYmVyIHdoZW4gZGVjb2RlZC5cbiAqXG4gKiAqRmFjdG9yeSo6IHtAbGluayBtb2R1bGU6TGF5b3V0Lm51NjRiZXxudTY0YmV9XG4gKlxuICogKipOT1RFKiogVmFsdWVzIHdpdGggbWFnbml0dWRlIGdyZWF0ZXIgdGhhbiAyXjUyIG1heSBub3QgZGVjb2RlIHRvXG4gKiB0aGUgZXhhY3QgdmFsdWUgb2YgdGhlIGVuY29kZWQgcmVwcmVzZW50YXRpb24uXG4gKlxuICogQGF1Z21lbnRzIHtMYXlvdXR9XG4gKi9cbmNsYXNzIE5lYXJVSW50NjRCRSBleHRlbmRzIExheW91dCB7XG4gICAgY29uc3RydWN0b3IocHJvcGVydHkpIHtcbiAgICAgICAgc3VwZXIoOCwgcHJvcGVydHkpO1xuICAgIH1cbiAgICAvKiogQG92ZXJyaWRlICovXG4gICAgZGVjb2RlKGIsIG9mZnNldCA9IDApIHtcbiAgICAgICAgY29uc3QgYnVmZmVyID0gdWludDhBcnJheVRvQnVmZmVyKGIpO1xuICAgICAgICBjb25zdCBoaTMyID0gYnVmZmVyLnJlYWRVSW50MzJCRShvZmZzZXQpO1xuICAgICAgICBjb25zdCBsbzMyID0gYnVmZmVyLnJlYWRVSW50MzJCRShvZmZzZXQgKyA0KTtcbiAgICAgICAgcmV0dXJuIHJvdW5kZWRJbnQ2NChoaTMyLCBsbzMyKTtcbiAgICB9XG4gICAgLyoqIEBvdmVycmlkZSAqL1xuICAgIGVuY29kZShzcmMsIGIsIG9mZnNldCA9IDApIHtcbiAgICAgICAgY29uc3Qgc3BsaXQgPSBkaXZtb2RJbnQ2NChzcmMpO1xuICAgICAgICBjb25zdCBidWZmZXIgPSB1aW50OEFycmF5VG9CdWZmZXIoYik7XG4gICAgICAgIGJ1ZmZlci53cml0ZVVJbnQzMkJFKHNwbGl0LmhpMzIsIG9mZnNldCk7XG4gICAgICAgIGJ1ZmZlci53cml0ZVVJbnQzMkJFKHNwbGl0LmxvMzIsIG9mZnNldCArIDQpO1xuICAgICAgICByZXR1cm4gODtcbiAgICB9XG59XG5leHBvcnRzLk5lYXJVSW50NjRCRSA9IE5lYXJVSW50NjRCRTtcbi8qKlxuICogUmVwcmVzZW50IGEgc2lnbmVkIDY0LWJpdCBpbnRlZ2VyIGluIGxpdHRsZS1lbmRpYW4gZm9ybWF0IHdoZW5cbiAqIGVuY29kZWQgYW5kIGFzIGEgbmVhciBpbnRlZ3JhbCBKYXZhU2NyaXB0IE51bWJlciB3aGVuIGRlY29kZWQuXG4gKlxuICogKkZhY3RvcnkqOiB7QGxpbmsgbW9kdWxlOkxheW91dC5uczY0fG5zNjR9XG4gKlxuICogKipOT1RFKiogVmFsdWVzIHdpdGggbWFnbml0dWRlIGdyZWF0ZXIgdGhhbiAyXjUyIG1heSBub3QgZGVjb2RlIHRvXG4gKiB0aGUgZXhhY3QgdmFsdWUgb2YgdGhlIGVuY29kZWQgcmVwcmVzZW50YXRpb24uXG4gKlxuICogQGF1Z21lbnRzIHtMYXlvdXR9XG4gKi9cbmNsYXNzIE5lYXJJbnQ2NCBleHRlbmRzIExheW91dCB7XG4gICAgY29uc3RydWN0b3IocHJvcGVydHkpIHtcbiAgICAgICAgc3VwZXIoOCwgcHJvcGVydHkpO1xuICAgIH1cbiAgICAvKiogQG92ZXJyaWRlICovXG4gICAgZGVjb2RlKGIsIG9mZnNldCA9IDApIHtcbiAgICAgICAgY29uc3QgYnVmZmVyID0gdWludDhBcnJheVRvQnVmZmVyKGIpO1xuICAgICAgICBjb25zdCBsbzMyID0gYnVmZmVyLnJlYWRVSW50MzJMRShvZmZzZXQpO1xuICAgICAgICBjb25zdCBoaTMyID0gYnVmZmVyLnJlYWRJbnQzMkxFKG9mZnNldCArIDQpO1xuICAgICAgICByZXR1cm4gcm91bmRlZEludDY0KGhpMzIsIGxvMzIpO1xuICAgIH1cbiAgICAvKiogQG92ZXJyaWRlICovXG4gICAgZW5jb2RlKHNyYywgYiwgb2Zmc2V0ID0gMCkge1xuICAgICAgICBjb25zdCBzcGxpdCA9IGRpdm1vZEludDY0KHNyYyk7XG4gICAgICAgIGNvbnN0IGJ1ZmZlciA9IHVpbnQ4QXJyYXlUb0J1ZmZlcihiKTtcbiAgICAgICAgYnVmZmVyLndyaXRlVUludDMyTEUoc3BsaXQubG8zMiwgb2Zmc2V0KTtcbiAgICAgICAgYnVmZmVyLndyaXRlSW50MzJMRShzcGxpdC5oaTMyLCBvZmZzZXQgKyA0KTtcbiAgICAgICAgcmV0dXJuIDg7XG4gICAgfVxufVxuZXhwb3J0cy5OZWFySW50NjQgPSBOZWFySW50NjQ7XG4vKipcbiAqIFJlcHJlc2VudCBhIHNpZ25lZCA2NC1iaXQgaW50ZWdlciBpbiBiaWctZW5kaWFuIGZvcm1hdCB3aGVuXG4gKiBlbmNvZGVkIGFuZCBhcyBhIG5lYXIgaW50ZWdyYWwgSmF2YVNjcmlwdCBOdW1iZXIgd2hlbiBkZWNvZGVkLlxuICpcbiAqICpGYWN0b3J5Kjoge0BsaW5rIG1vZHVsZTpMYXlvdXQubnM2NGJlfG5zNjRiZX1cbiAqXG4gKiAqKk5PVEUqKiBWYWx1ZXMgd2l0aCBtYWduaXR1ZGUgZ3JlYXRlciB0aGFuIDJeNTIgbWF5IG5vdCBkZWNvZGUgdG9cbiAqIHRoZSBleGFjdCB2YWx1ZSBvZiB0aGUgZW5jb2RlZCByZXByZXNlbnRhdGlvbi5cbiAqXG4gKiBAYXVnbWVudHMge0xheW91dH1cbiAqL1xuY2xhc3MgTmVhckludDY0QkUgZXh0ZW5kcyBMYXlvdXQge1xuICAgIGNvbnN0cnVjdG9yKHByb3BlcnR5KSB7XG4gICAgICAgIHN1cGVyKDgsIHByb3BlcnR5KTtcbiAgICB9XG4gICAgLyoqIEBvdmVycmlkZSAqL1xuICAgIGRlY29kZShiLCBvZmZzZXQgPSAwKSB7XG4gICAgICAgIGNvbnN0IGJ1ZmZlciA9IHVpbnQ4QXJyYXlUb0J1ZmZlcihiKTtcbiAgICAgICAgY29uc3QgaGkzMiA9IGJ1ZmZlci5yZWFkSW50MzJCRShvZmZzZXQpO1xuICAgICAgICBjb25zdCBsbzMyID0gYnVmZmVyLnJlYWRVSW50MzJCRShvZmZzZXQgKyA0KTtcbiAgICAgICAgcmV0dXJuIHJvdW5kZWRJbnQ2NChoaTMyLCBsbzMyKTtcbiAgICB9XG4gICAgLyoqIEBvdmVycmlkZSAqL1xuICAgIGVuY29kZShzcmMsIGIsIG9mZnNldCA9IDApIHtcbiAgICAgICAgY29uc3Qgc3BsaXQgPSBkaXZtb2RJbnQ2NChzcmMpO1xuICAgICAgICBjb25zdCBidWZmZXIgPSB1aW50OEFycmF5VG9CdWZmZXIoYik7XG4gICAgICAgIGJ1ZmZlci53cml0ZUludDMyQkUoc3BsaXQuaGkzMiwgb2Zmc2V0KTtcbiAgICAgICAgYnVmZmVyLndyaXRlVUludDMyQkUoc3BsaXQubG8zMiwgb2Zmc2V0ICsgNCk7XG4gICAgICAgIHJldHVybiA4O1xuICAgIH1cbn1cbmV4cG9ydHMuTmVhckludDY0QkUgPSBOZWFySW50NjRCRTtcbi8qKlxuICogUmVwcmVzZW50IGEgMzItYml0IGZsb2F0aW5nIHBvaW50IG51bWJlciBpbiBsaXR0bGUtZW5kaWFuIGZvcm1hdC5cbiAqXG4gKiAqRmFjdG9yeSo6IHtAbGluayBtb2R1bGU6TGF5b3V0LmYzMnxmMzJ9XG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IFtwcm9wZXJ0eV0gLSBpbml0aWFsaXplciBmb3Ige0BsaW5rXG4gKiBMYXlvdXQjcHJvcGVydHl8cHJvcGVydHl9LlxuICpcbiAqIEBhdWdtZW50cyB7TGF5b3V0fVxuICovXG5jbGFzcyBGbG9hdCBleHRlbmRzIExheW91dCB7XG4gICAgY29uc3RydWN0b3IocHJvcGVydHkpIHtcbiAgICAgICAgc3VwZXIoNCwgcHJvcGVydHkpO1xuICAgIH1cbiAgICAvKiogQG92ZXJyaWRlICovXG4gICAgZGVjb2RlKGIsIG9mZnNldCA9IDApIHtcbiAgICAgICAgcmV0dXJuIHVpbnQ4QXJyYXlUb0J1ZmZlcihiKS5yZWFkRmxvYXRMRShvZmZzZXQpO1xuICAgIH1cbiAgICAvKiogQG92ZXJyaWRlICovXG4gICAgZW5jb2RlKHNyYywgYiwgb2Zmc2V0ID0gMCkge1xuICAgICAgICB1aW50OEFycmF5VG9CdWZmZXIoYikud3JpdGVGbG9hdExFKHNyYywgb2Zmc2V0KTtcbiAgICAgICAgcmV0dXJuIDQ7XG4gICAgfVxufVxuZXhwb3J0cy5GbG9hdCA9IEZsb2F0O1xuLyoqXG4gKiBSZXByZXNlbnQgYSAzMi1iaXQgZmxvYXRpbmcgcG9pbnQgbnVtYmVyIGluIGJpZy1lbmRpYW4gZm9ybWF0LlxuICpcbiAqICpGYWN0b3J5Kjoge0BsaW5rIG1vZHVsZTpMYXlvdXQuZjMyYmV8ZjMyYmV9XG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IFtwcm9wZXJ0eV0gLSBpbml0aWFsaXplciBmb3Ige0BsaW5rXG4gKiBMYXlvdXQjcHJvcGVydHl8cHJvcGVydHl9LlxuICpcbiAqIEBhdWdtZW50cyB7TGF5b3V0fVxuICovXG5jbGFzcyBGbG9hdEJFIGV4dGVuZHMgTGF5b3V0IHtcbiAgICBjb25zdHJ1Y3Rvcihwcm9wZXJ0eSkge1xuICAgICAgICBzdXBlcig0LCBwcm9wZXJ0eSk7XG4gICAgfVxuICAgIC8qKiBAb3ZlcnJpZGUgKi9cbiAgICBkZWNvZGUoYiwgb2Zmc2V0ID0gMCkge1xuICAgICAgICByZXR1cm4gdWludDhBcnJheVRvQnVmZmVyKGIpLnJlYWRGbG9hdEJFKG9mZnNldCk7XG4gICAgfVxuICAgIC8qKiBAb3ZlcnJpZGUgKi9cbiAgICBlbmNvZGUoc3JjLCBiLCBvZmZzZXQgPSAwKSB7XG4gICAgICAgIHVpbnQ4QXJyYXlUb0J1ZmZlcihiKS53cml0ZUZsb2F0QkUoc3JjLCBvZmZzZXQpO1xuICAgICAgICByZXR1cm4gNDtcbiAgICB9XG59XG5leHBvcnRzLkZsb2F0QkUgPSBGbG9hdEJFO1xuLyoqXG4gKiBSZXByZXNlbnQgYSA2NC1iaXQgZmxvYXRpbmcgcG9pbnQgbnVtYmVyIGluIGxpdHRsZS1lbmRpYW4gZm9ybWF0LlxuICpcbiAqICpGYWN0b3J5Kjoge0BsaW5rIG1vZHVsZTpMYXlvdXQuZjY0fGY2NH1cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gW3Byb3BlcnR5XSAtIGluaXRpYWxpemVyIGZvciB7QGxpbmtcbiAqIExheW91dCNwcm9wZXJ0eXxwcm9wZXJ0eX0uXG4gKlxuICogQGF1Z21lbnRzIHtMYXlvdXR9XG4gKi9cbmNsYXNzIERvdWJsZSBleHRlbmRzIExheW91dCB7XG4gICAgY29uc3RydWN0b3IocHJvcGVydHkpIHtcbiAgICAgICAgc3VwZXIoOCwgcHJvcGVydHkpO1xuICAgIH1cbiAgICAvKiogQG92ZXJyaWRlICovXG4gICAgZGVjb2RlKGIsIG9mZnNldCA9IDApIHtcbiAgICAgICAgcmV0dXJuIHVpbnQ4QXJyYXlUb0J1ZmZlcihiKS5yZWFkRG91YmxlTEUob2Zmc2V0KTtcbiAgICB9XG4gICAgLyoqIEBvdmVycmlkZSAqL1xuICAgIGVuY29kZShzcmMsIGIsIG9mZnNldCA9IDApIHtcbiAgICAgICAgdWludDhBcnJheVRvQnVmZmVyKGIpLndyaXRlRG91YmxlTEUoc3JjLCBvZmZzZXQpO1xuICAgICAgICByZXR1cm4gODtcbiAgICB9XG59XG5leHBvcnRzLkRvdWJsZSA9IERvdWJsZTtcbi8qKlxuICogUmVwcmVzZW50IGEgNjQtYml0IGZsb2F0aW5nIHBvaW50IG51bWJlciBpbiBiaWctZW5kaWFuIGZvcm1hdC5cbiAqXG4gKiAqRmFjdG9yeSo6IHtAbGluayBtb2R1bGU6TGF5b3V0LmY2NGJlfGY2NGJlfVxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBbcHJvcGVydHldIC0gaW5pdGlhbGl6ZXIgZm9yIHtAbGlua1xuICogTGF5b3V0I3Byb3BlcnR5fHByb3BlcnR5fS5cbiAqXG4gKiBAYXVnbWVudHMge0xheW91dH1cbiAqL1xuY2xhc3MgRG91YmxlQkUgZXh0ZW5kcyBMYXlvdXQge1xuICAgIGNvbnN0cnVjdG9yKHByb3BlcnR5KSB7XG4gICAgICAgIHN1cGVyKDgsIHByb3BlcnR5KTtcbiAgICB9XG4gICAgLyoqIEBvdmVycmlkZSAqL1xuICAgIGRlY29kZShiLCBvZmZzZXQgPSAwKSB7XG4gICAgICAgIHJldHVybiB1aW50OEFycmF5VG9CdWZmZXIoYikucmVhZERvdWJsZUJFKG9mZnNldCk7XG4gICAgfVxuICAgIC8qKiBAb3ZlcnJpZGUgKi9cbiAgICBlbmNvZGUoc3JjLCBiLCBvZmZzZXQgPSAwKSB7XG4gICAgICAgIHVpbnQ4QXJyYXlUb0J1ZmZlcihiKS53cml0ZURvdWJsZUJFKHNyYywgb2Zmc2V0KTtcbiAgICAgICAgcmV0dXJuIDg7XG4gICAgfVxufVxuZXhwb3J0cy5Eb3VibGVCRSA9IERvdWJsZUJFO1xuLyoqXG4gKiBSZXByZXNlbnQgYSBjb250aWd1b3VzIHNlcXVlbmNlIG9mIGEgc3BlY2lmaWMgbGF5b3V0IGFzIGFuIEFycmF5LlxuICpcbiAqICpGYWN0b3J5Kjoge0BsaW5rIG1vZHVsZTpMYXlvdXQuc2VxfHNlcX1cbiAqXG4gKiBAcGFyYW0ge0xheW91dH0gZWxlbWVudExheW91dCAtIGluaXRpYWxpemVyIGZvciB7QGxpbmtcbiAqIFNlcXVlbmNlI2VsZW1lbnRMYXlvdXR8ZWxlbWVudExheW91dH0uXG4gKlxuICogQHBhcmFtIHsoTnVtYmVyfEV4dGVybmFsTGF5b3V0KX0gY291bnQgLSBpbml0aWFsaXplciBmb3Ige0BsaW5rXG4gKiBTZXF1ZW5jZSNjb3VudHxjb3VudH0uICBUaGUgcGFyYW1ldGVyIG11c3QgYmUgZWl0aGVyIGEgcG9zaXRpdmVcbiAqIGludGVnZXIgb3IgYW4gaW5zdGFuY2Ugb2Yge0BsaW5rIEV4dGVybmFsTGF5b3V0fS5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gW3Byb3BlcnR5XSAtIGluaXRpYWxpemVyIGZvciB7QGxpbmtcbiAqIExheW91dCNwcm9wZXJ0eXxwcm9wZXJ0eX0uXG4gKlxuICogQGF1Z21lbnRzIHtMYXlvdXR9XG4gKi9cbmNsYXNzIFNlcXVlbmNlIGV4dGVuZHMgTGF5b3V0IHtcbiAgICBjb25zdHJ1Y3RvcihlbGVtZW50TGF5b3V0LCBjb3VudCwgcHJvcGVydHkpIHtcbiAgICAgICAgaWYgKCEoZWxlbWVudExheW91dCBpbnN0YW5jZW9mIExheW91dCkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2VsZW1lbnRMYXlvdXQgbXVzdCBiZSBhIExheW91dCcpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghKCgoY291bnQgaW5zdGFuY2VvZiBFeHRlcm5hbExheW91dCkgJiYgY291bnQuaXNDb3VudCgpKVxuICAgICAgICAgICAgfHwgKE51bWJlci5pc0ludGVnZXIoY291bnQpICYmICgwIDw9IGNvdW50KSkpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdjb3VudCBtdXN0IGJlIG5vbi1uZWdhdGl2ZSBpbnRlZ2VyICdcbiAgICAgICAgICAgICAgICArICdvciBhbiB1bnNpZ25lZCBpbnRlZ2VyIEV4dGVybmFsTGF5b3V0Jyk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHNwYW4gPSAtMTtcbiAgICAgICAgaWYgKCghKGNvdW50IGluc3RhbmNlb2YgRXh0ZXJuYWxMYXlvdXQpKVxuICAgICAgICAgICAgJiYgKDAgPCBlbGVtZW50TGF5b3V0LnNwYW4pKSB7XG4gICAgICAgICAgICBzcGFuID0gY291bnQgKiBlbGVtZW50TGF5b3V0LnNwYW47XG4gICAgICAgIH1cbiAgICAgICAgc3VwZXIoc3BhbiwgcHJvcGVydHkpO1xuICAgICAgICAvKiogVGhlIGxheW91dCBmb3IgaW5kaXZpZHVhbCBlbGVtZW50cyBvZiB0aGUgc2VxdWVuY2UuICovXG4gICAgICAgIHRoaXMuZWxlbWVudExheW91dCA9IGVsZW1lbnRMYXlvdXQ7XG4gICAgICAgIC8qKiBUaGUgbnVtYmVyIG9mIGVsZW1lbnRzIGluIHRoZSBzZXF1ZW5jZS5cbiAgICAgICAgICpcbiAgICAgICAgICogVGhpcyB3aWxsIGJlIGVpdGhlciBhIG5vbi1uZWdhdGl2ZSBpbnRlZ2VyIG9yIGFuIGluc3RhbmNlIG9mXG4gICAgICAgICAqIHtAbGluayBFeHRlcm5hbExheW91dH0gZm9yIHdoaWNoIHtAbGlua1xuICAgICAgICAgKiBFeHRlcm5hbExheW91dCNpc0NvdW50fGlzQ291bnQoKX0gaXMgYHRydWVgLiAqL1xuICAgICAgICB0aGlzLmNvdW50ID0gY291bnQ7XG4gICAgfVxuICAgIC8qKiBAb3ZlcnJpZGUgKi9cbiAgICBnZXRTcGFuKGIsIG9mZnNldCA9IDApIHtcbiAgICAgICAgaWYgKDAgPD0gdGhpcy5zcGFuKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zcGFuO1xuICAgICAgICB9XG4gICAgICAgIGxldCBzcGFuID0gMDtcbiAgICAgICAgbGV0IGNvdW50ID0gdGhpcy5jb3VudDtcbiAgICAgICAgaWYgKGNvdW50IGluc3RhbmNlb2YgRXh0ZXJuYWxMYXlvdXQpIHtcbiAgICAgICAgICAgIGNvdW50ID0gY291bnQuZGVjb2RlKGIsIG9mZnNldCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKDAgPCB0aGlzLmVsZW1lbnRMYXlvdXQuc3Bhbikge1xuICAgICAgICAgICAgc3BhbiA9IGNvdW50ICogdGhpcy5lbGVtZW50TGF5b3V0LnNwYW47XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBsZXQgaWR4ID0gMDtcbiAgICAgICAgICAgIHdoaWxlIChpZHggPCBjb3VudCkge1xuICAgICAgICAgICAgICAgIHNwYW4gKz0gdGhpcy5lbGVtZW50TGF5b3V0LmdldFNwYW4oYiwgb2Zmc2V0ICsgc3Bhbik7XG4gICAgICAgICAgICAgICAgKytpZHg7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHNwYW47XG4gICAgfVxuICAgIC8qKiBAb3ZlcnJpZGUgKi9cbiAgICBkZWNvZGUoYiwgb2Zmc2V0ID0gMCkge1xuICAgICAgICBjb25zdCBydiA9IFtdO1xuICAgICAgICBsZXQgaSA9IDA7XG4gICAgICAgIGxldCBjb3VudCA9IHRoaXMuY291bnQ7XG4gICAgICAgIGlmIChjb3VudCBpbnN0YW5jZW9mIEV4dGVybmFsTGF5b3V0KSB7XG4gICAgICAgICAgICBjb3VudCA9IGNvdW50LmRlY29kZShiLCBvZmZzZXQpO1xuICAgICAgICB9XG4gICAgICAgIHdoaWxlIChpIDwgY291bnQpIHtcbiAgICAgICAgICAgIHJ2LnB1c2godGhpcy5lbGVtZW50TGF5b3V0LmRlY29kZShiLCBvZmZzZXQpKTtcbiAgICAgICAgICAgIG9mZnNldCArPSB0aGlzLmVsZW1lbnRMYXlvdXQuZ2V0U3BhbihiLCBvZmZzZXQpO1xuICAgICAgICAgICAgaSArPSAxO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBydjtcbiAgICB9XG4gICAgLyoqIEltcGxlbWVudCB7QGxpbmsgTGF5b3V0I2VuY29kZXxlbmNvZGV9IGZvciB7QGxpbmsgU2VxdWVuY2V9LlxuICAgICAqXG4gICAgICogKipOT1RFKiogSWYgYHNyY2AgaXMgc2hvcnRlciB0aGFuIHtAbGluayBTZXF1ZW5jZSNjb3VudHxjb3VudH0gdGhlblxuICAgICAqIHRoZSB1bnVzZWQgc3BhY2UgaW4gdGhlIGJ1ZmZlciBpcyBsZWZ0IHVuY2hhbmdlZC4gIElmIGBzcmNgIGlzXG4gICAgICogbG9uZ2VyIHRoYW4ge0BsaW5rIFNlcXVlbmNlI2NvdW50fGNvdW50fSB0aGUgdW5uZWVkZWQgZWxlbWVudHMgYXJlXG4gICAgICogaWdub3JlZC5cbiAgICAgKlxuICAgICAqICoqTk9URSoqIElmIHtAbGluayBMYXlvdXQjY291bnR8Y291bnR9IGlzIGFuIGluc3RhbmNlIG9mIHtAbGlua1xuICAgICAqIEV4dGVybmFsTGF5b3V0fSB0aGVuIHRoZSBsZW5ndGggb2YgYHNyY2Agd2lsbCBiZSBlbmNvZGVkIGFzIHRoZVxuICAgICAqIGNvdW50IGFmdGVyIGBzcmNgIGlzIGVuY29kZWQuICovXG4gICAgZW5jb2RlKHNyYywgYiwgb2Zmc2V0ID0gMCkge1xuICAgICAgICBjb25zdCBlbG8gPSB0aGlzLmVsZW1lbnRMYXlvdXQ7XG4gICAgICAgIGNvbnN0IHNwYW4gPSBzcmMucmVkdWNlKChzcGFuLCB2KSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gc3BhbiArIGVsby5lbmNvZGUodiwgYiwgb2Zmc2V0ICsgc3Bhbik7XG4gICAgICAgIH0sIDApO1xuICAgICAgICBpZiAodGhpcy5jb3VudCBpbnN0YW5jZW9mIEV4dGVybmFsTGF5b3V0KSB7XG4gICAgICAgICAgICB0aGlzLmNvdW50LmVuY29kZShzcmMubGVuZ3RoLCBiLCBvZmZzZXQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzcGFuO1xuICAgIH1cbn1cbmV4cG9ydHMuU2VxdWVuY2UgPSBTZXF1ZW5jZTtcbi8qKlxuICogUmVwcmVzZW50IGEgY29udGlndW91cyBzZXF1ZW5jZSBvZiBhcmJpdHJhcnkgbGF5b3V0IGVsZW1lbnRzIGFzIGFuXG4gKiBPYmplY3QuXG4gKlxuICogKkZhY3RvcnkqOiB7QGxpbmsgbW9kdWxlOkxheW91dC5zdHJ1Y3R8c3RydWN0fVxuICpcbiAqICoqTk9URSoqIFRoZSB7QGxpbmsgTGF5b3V0I3NwYW58c3Bhbn0gb2YgdGhlIHN0cnVjdHVyZSBpcyB2YXJpYWJsZVxuICogaWYgYW55IGxheW91dCBpbiB7QGxpbmsgU3RydWN0dXJlI2ZpZWxkc3xmaWVsZHN9IGhhcyBhIHZhcmlhYmxlXG4gKiBzcGFuLiAgV2hlbiB7QGxpbmsgTGF5b3V0I2VuY29kZXxlbmNvZGluZ30gd2UgbXVzdCBoYXZlIGEgdmFsdWUgZm9yXG4gKiBhbGwgdmFyaWFibGUtbGVuZ3RoIGZpZWxkcywgb3Igd2Ugd291bGRuJ3QgYmUgYWJsZSB0byBmaWd1cmUgb3V0XG4gKiBob3cgbXVjaCBzcGFjZSB0byB1c2UgZm9yIHN0b3JhZ2UuICBXZSBjYW4gb25seSBpZGVudGlmeSB0aGUgdmFsdWVcbiAqIGZvciBhIGZpZWxkIHdoZW4gaXQgaGFzIGEge0BsaW5rIExheW91dCNwcm9wZXJ0eXxwcm9wZXJ0eX0uICBBc1xuICogc3VjaCwgYWx0aG91Z2ggYSBzdHJ1Y3R1cmUgbWF5IGNvbnRhaW4gYm90aCB1bm5hbWVkIGZpZWxkcyBhbmRcbiAqIHZhcmlhYmxlLWxlbmd0aCBmaWVsZHMsIGl0IGNhbm5vdCBjb250YWluIGFuIHVubmFtZWRcbiAqIHZhcmlhYmxlLWxlbmd0aCBmaWVsZC5cbiAqXG4gKiBAcGFyYW0ge0xheW91dFtdfSBmaWVsZHMgLSBpbml0aWFsaXplciBmb3Ige0BsaW5rXG4gKiBTdHJ1Y3R1cmUjZmllbGRzfGZpZWxkc30uICBBbiBlcnJvciBpcyByYWlzZWQgaWYgdGhpcyBjb250YWlucyBhXG4gKiB2YXJpYWJsZS1sZW5ndGggZmllbGQgZm9yIHdoaWNoIGEge0BsaW5rIExheW91dCNwcm9wZXJ0eXxwcm9wZXJ0eX1cbiAqIGlzIG5vdCBkZWZpbmVkLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBbcHJvcGVydHldIC0gaW5pdGlhbGl6ZXIgZm9yIHtAbGlua1xuICogTGF5b3V0I3Byb3BlcnR5fHByb3BlcnR5fS5cbiAqXG4gKiBAcGFyYW0ge0Jvb2xlYW59IFtkZWNvZGVQcmVmaXhlc10gLSBpbml0aWFsaXplciBmb3Ige0BsaW5rXG4gKiBTdHJ1Y3R1cmUjZGVjb2RlUHJlZml4ZXN8cHJvcGVydHl9LlxuICpcbiAqIEB0aHJvd3Mge0Vycm9yfSAtIGlmIGBmaWVsZHNgIGNvbnRhaW5zIGFuIHVubmFtZWQgdmFyaWFibGUtbGVuZ3RoXG4gKiBsYXlvdXQuXG4gKlxuICogQGF1Z21lbnRzIHtMYXlvdXR9XG4gKi9cbmNsYXNzIFN0cnVjdHVyZSBleHRlbmRzIExheW91dCB7XG4gICAgY29uc3RydWN0b3IoZmllbGRzLCBwcm9wZXJ0eSwgZGVjb2RlUHJlZml4ZXMpIHtcbiAgICAgICAgaWYgKCEoQXJyYXkuaXNBcnJheShmaWVsZHMpXG4gICAgICAgICAgICAmJiBmaWVsZHMucmVkdWNlKChhY2MsIHYpID0+IGFjYyAmJiAodiBpbnN0YW5jZW9mIExheW91dCksIHRydWUpKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignZmllbGRzIG11c3QgYmUgYXJyYXkgb2YgTGF5b3V0IGluc3RhbmNlcycpO1xuICAgICAgICB9XG4gICAgICAgIGlmICgoJ2Jvb2xlYW4nID09PSB0eXBlb2YgcHJvcGVydHkpXG4gICAgICAgICAgICAmJiAodW5kZWZpbmVkID09PSBkZWNvZGVQcmVmaXhlcykpIHtcbiAgICAgICAgICAgIGRlY29kZVByZWZpeGVzID0gcHJvcGVydHk7XG4gICAgICAgICAgICBwcm9wZXJ0eSA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICAvKiBWZXJpZnkgYWJzZW5jZSBvZiB1bm5hbWVkIHZhcmlhYmxlLWxlbmd0aCBmaWVsZHMuICovXG4gICAgICAgIGZvciAoY29uc3QgZmQgb2YgZmllbGRzKSB7XG4gICAgICAgICAgICBpZiAoKDAgPiBmZC5zcGFuKVxuICAgICAgICAgICAgICAgICYmICh1bmRlZmluZWQgPT09IGZkLnByb3BlcnR5KSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignZmllbGRzIGNhbm5vdCBjb250YWluIHVubmFtZWQgdmFyaWFibGUtbGVuZ3RoIGxheW91dCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGxldCBzcGFuID0gLTE7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBzcGFuID0gZmllbGRzLnJlZHVjZSgoc3BhbiwgZmQpID0+IHNwYW4gKyBmZC5nZXRTcGFuKCksIDApO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAvLyBpZ25vcmUgZXJyb3JcbiAgICAgICAgfVxuICAgICAgICBzdXBlcihzcGFuLCBwcm9wZXJ0eSk7XG4gICAgICAgIC8qKiBUaGUgc2VxdWVuY2Ugb2Yge0BsaW5rIExheW91dH0gdmFsdWVzIHRoYXQgY29tcHJpc2UgdGhlXG4gICAgICAgICAqIHN0cnVjdHVyZS5cbiAgICAgICAgICpcbiAgICAgICAgICogVGhlIGluZGl2aWR1YWwgZWxlbWVudHMgbmVlZCBub3QgYmUgdGhlIHNhbWUgdHlwZSwgYW5kIG1heSBiZVxuICAgICAgICAgKiBlaXRoZXIgc2NhbGFyIG9yIGFnZ3JlZ2F0ZSBsYXlvdXRzLiAgSWYgYSBtZW1iZXIgbGF5b3V0IGxlYXZlc1xuICAgICAgICAgKiBpdHMge0BsaW5rIExheW91dCNwcm9wZXJ0eXxwcm9wZXJ0eX0gdW5kZWZpbmVkIHRoZVxuICAgICAgICAgKiBjb3JyZXNwb25kaW5nIHJlZ2lvbiBvZiB0aGUgYnVmZmVyIGFzc29jaWF0ZWQgd2l0aCB0aGUgZWxlbWVudFxuICAgICAgICAgKiB3aWxsIG5vdCBiZSBtdXRhdGVkLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAdHlwZSB7TGF5b3V0W119ICovXG4gICAgICAgIHRoaXMuZmllbGRzID0gZmllbGRzO1xuICAgICAgICAvKiogQ29udHJvbCBiZWhhdmlvciBvZiB7QGxpbmsgTGF5b3V0I2RlY29kZXxkZWNvZGUoKX0gZ2l2ZW4gc2hvcnRcbiAgICAgICAgICogYnVmZmVycy5cbiAgICAgICAgICpcbiAgICAgICAgICogSW4gc29tZSBzaXR1YXRpb25zIGEgc3RydWN0dXJlIG1hbnkgYmUgZXh0ZW5kZWQgd2l0aCBhZGRpdGlvbmFsXG4gICAgICAgICAqIGZpZWxkcyBvdmVyIHRpbWUsIHdpdGggb2xkZXIgaW5zdGFsbGF0aW9ucyBwcm92aWRpbmcgb25seSBhXG4gICAgICAgICAqIHByZWZpeCBvZiB0aGUgZnVsbCBzdHJ1Y3R1cmUuICBJZiB0aGlzIHByb3BlcnR5IGlzIGB0cnVlYFxuICAgICAgICAgKiBkZWNvZGluZyB3aWxsIGFjY2VwdCB0aG9zZSBidWZmZXJzIGFuZCBsZWF2ZSBzdWJzZXF1ZW50IGZpZWxkc1xuICAgICAgICAgKiB1bmRlZmluZWQsIGFzIGxvbmcgYXMgdGhlIGJ1ZmZlciBlbmRzIGF0IGEgZmllbGQgYm91bmRhcnkuXG4gICAgICAgICAqIERlZmF1bHRzIHRvIGBmYWxzZWAuICovXG4gICAgICAgIHRoaXMuZGVjb2RlUHJlZml4ZXMgPSAhIWRlY29kZVByZWZpeGVzO1xuICAgIH1cbiAgICAvKiogQG92ZXJyaWRlICovXG4gICAgZ2V0U3BhbihiLCBvZmZzZXQgPSAwKSB7XG4gICAgICAgIGlmICgwIDw9IHRoaXMuc3Bhbikge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc3BhbjtcbiAgICAgICAgfVxuICAgICAgICBsZXQgc3BhbiA9IDA7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBzcGFuID0gdGhpcy5maWVsZHMucmVkdWNlKChzcGFuLCBmZCkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IGZzcCA9IGZkLmdldFNwYW4oYiwgb2Zmc2V0KTtcbiAgICAgICAgICAgICAgICBvZmZzZXQgKz0gZnNwO1xuICAgICAgICAgICAgICAgIHJldHVybiBzcGFuICsgZnNwO1xuICAgICAgICAgICAgfSwgMCk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdpbmRldGVybWluYXRlIHNwYW4nKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3BhbjtcbiAgICB9XG4gICAgLyoqIEBvdmVycmlkZSAqL1xuICAgIGRlY29kZShiLCBvZmZzZXQgPSAwKSB7XG4gICAgICAgIGNoZWNrVWludDhBcnJheShiKTtcbiAgICAgICAgY29uc3QgZGVzdCA9IHRoaXMubWFrZURlc3RpbmF0aW9uT2JqZWN0KCk7XG4gICAgICAgIGZvciAoY29uc3QgZmQgb2YgdGhpcy5maWVsZHMpIHtcbiAgICAgICAgICAgIGlmICh1bmRlZmluZWQgIT09IGZkLnByb3BlcnR5KSB7XG4gICAgICAgICAgICAgICAgZGVzdFtmZC5wcm9wZXJ0eV0gPSBmZC5kZWNvZGUoYiwgb2Zmc2V0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG9mZnNldCArPSBmZC5nZXRTcGFuKGIsIG9mZnNldCk7XG4gICAgICAgICAgICBpZiAodGhpcy5kZWNvZGVQcmVmaXhlc1xuICAgICAgICAgICAgICAgICYmIChiLmxlbmd0aCA9PT0gb2Zmc2V0KSkge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkZXN0O1xuICAgIH1cbiAgICAvKiogSW1wbGVtZW50IHtAbGluayBMYXlvdXQjZW5jb2RlfGVuY29kZX0gZm9yIHtAbGluayBTdHJ1Y3R1cmV9LlxuICAgICAqXG4gICAgICogSWYgYHNyY2AgaXMgbWlzc2luZyBhIHByb3BlcnR5IGZvciBhIG1lbWJlciB3aXRoIGEgZGVmaW5lZCB7QGxpbmtcbiAgICAgKiBMYXlvdXQjcHJvcGVydHl8cHJvcGVydHl9IHRoZSBjb3JyZXNwb25kaW5nIHJlZ2lvbiBvZiB0aGUgYnVmZmVyIGlzXG4gICAgICogbGVmdCB1bm1vZGlmaWVkLiAqL1xuICAgIGVuY29kZShzcmMsIGIsIG9mZnNldCA9IDApIHtcbiAgICAgICAgY29uc3QgZmlyc3RPZmZzZXQgPSBvZmZzZXQ7XG4gICAgICAgIGxldCBsYXN0T2Zmc2V0ID0gMDtcbiAgICAgICAgbGV0IGxhc3RXcm90ZSA9IDA7XG4gICAgICAgIGZvciAoY29uc3QgZmQgb2YgdGhpcy5maWVsZHMpIHtcbiAgICAgICAgICAgIGxldCBzcGFuID0gZmQuc3BhbjtcbiAgICAgICAgICAgIGxhc3RXcm90ZSA9ICgwIDwgc3BhbikgPyBzcGFuIDogMDtcbiAgICAgICAgICAgIGlmICh1bmRlZmluZWQgIT09IGZkLnByb3BlcnR5KSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZnYgPSBzcmNbZmQucHJvcGVydHldO1xuICAgICAgICAgICAgICAgIGlmICh1bmRlZmluZWQgIT09IGZ2KSB7XG4gICAgICAgICAgICAgICAgICAgIGxhc3RXcm90ZSA9IGZkLmVuY29kZShmdiwgYiwgb2Zmc2V0KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKDAgPiBzcGFuKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvKiBSZWFkIHRoZSBhcy1lbmNvZGVkIHNwYW4sIHdoaWNoIGlzIG5vdCBuZWNlc3NhcmlseSB0aGVcbiAgICAgICAgICAgICAgICAgICAgICAgICAqIHNhbWUgYXMgd2hhdCB3ZSB3cm90ZS4gKi9cbiAgICAgICAgICAgICAgICAgICAgICAgIHNwYW4gPSBmZC5nZXRTcGFuKGIsIG9mZnNldCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsYXN0T2Zmc2V0ID0gb2Zmc2V0O1xuICAgICAgICAgICAgb2Zmc2V0ICs9IHNwYW47XG4gICAgICAgIH1cbiAgICAgICAgLyogVXNlIChsYXN0T2Zmc2V0ICsgbGFzdFdyb3RlKSBpbnN0ZWFkIG9mIG9mZnNldCBiZWNhdXNlIHRoZSBsYXN0XG4gICAgICAgICAqIGl0ZW0gbWF5IGhhdmUgaGFkIGEgZHluYW1pYyBsZW5ndGggYW5kIHdlIGRvbid0IHdhbnQgdG8gaW5jbHVkZVxuICAgICAgICAgKiB0aGUgcGFkZGluZyBiZXR3ZWVuIGl0IGFuZCB0aGUgZW5kIG9mIHRoZSBzcGFjZSByZXNlcnZlZCBmb3JcbiAgICAgICAgICogaXQuICovXG4gICAgICAgIHJldHVybiAobGFzdE9mZnNldCArIGxhc3RXcm90ZSkgLSBmaXJzdE9mZnNldDtcbiAgICB9XG4gICAgLyoqIEBvdmVycmlkZSAqL1xuICAgIGZyb21BcnJheSh2YWx1ZXMpIHtcbiAgICAgICAgY29uc3QgZGVzdCA9IHRoaXMubWFrZURlc3RpbmF0aW9uT2JqZWN0KCk7XG4gICAgICAgIGZvciAoY29uc3QgZmQgb2YgdGhpcy5maWVsZHMpIHtcbiAgICAgICAgICAgIGlmICgodW5kZWZpbmVkICE9PSBmZC5wcm9wZXJ0eSlcbiAgICAgICAgICAgICAgICAmJiAoMCA8IHZhbHVlcy5sZW5ndGgpKSB7XG4gICAgICAgICAgICAgICAgZGVzdFtmZC5wcm9wZXJ0eV0gPSB2YWx1ZXMuc2hpZnQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZGVzdDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IGFjY2VzcyB0byB0aGUgbGF5b3V0IG9mIGEgZ2l2ZW4gcHJvcGVydHkuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gcHJvcGVydHkgLSB0aGUgc3RydWN0dXJlIG1lbWJlciBvZiBpbnRlcmVzdC5cbiAgICAgKlxuICAgICAqIEByZXR1cm4ge0xheW91dH0gLSB0aGUgbGF5b3V0IGFzc29jaWF0ZWQgd2l0aCBgcHJvcGVydHlgLCBvclxuICAgICAqIHVuZGVmaW5lZCBpZiB0aGVyZSBpcyBubyBzdWNoIHByb3BlcnR5LlxuICAgICAqL1xuICAgIGxheW91dEZvcihwcm9wZXJ0eSkge1xuICAgICAgICBpZiAoJ3N0cmluZycgIT09IHR5cGVvZiBwcm9wZXJ0eSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcigncHJvcGVydHkgbXVzdCBiZSBzdHJpbmcnKTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGNvbnN0IGZkIG9mIHRoaXMuZmllbGRzKSB7XG4gICAgICAgICAgICBpZiAoZmQucHJvcGVydHkgPT09IHByb3BlcnR5KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZkO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgb2Zmc2V0IG9mIGEgc3RydWN0dXJlIG1lbWJlci5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBwcm9wZXJ0eSAtIHRoZSBzdHJ1Y3R1cmUgbWVtYmVyIG9mIGludGVyZXN0LlxuICAgICAqXG4gICAgICogQHJldHVybiB7TnVtYmVyfSAtIHRoZSBvZmZzZXQgaW4gYnl0ZXMgdG8gdGhlIHN0YXJ0IG9mIGBwcm9wZXJ0eWBcbiAgICAgKiB3aXRoaW4gdGhlIHN0cnVjdHVyZSwgb3IgdW5kZWZpbmVkIGlmIGBwcm9wZXJ0eWAgaXMgbm90IGEgZmllbGRcbiAgICAgKiB3aXRoaW4gdGhlIHN0cnVjdHVyZS4gIElmIHRoZSBwcm9wZXJ0eSBpcyBhIG1lbWJlciBidXQgZm9sbG93cyBhXG4gICAgICogdmFyaWFibGUtbGVuZ3RoIHN0cnVjdHVyZSBtZW1iZXIgYSBuZWdhdGl2ZSBudW1iZXIgd2lsbCBiZVxuICAgICAqIHJldHVybmVkLlxuICAgICAqL1xuICAgIG9mZnNldE9mKHByb3BlcnR5KSB7XG4gICAgICAgIGlmICgnc3RyaW5nJyAhPT0gdHlwZW9mIHByb3BlcnR5KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdwcm9wZXJ0eSBtdXN0IGJlIHN0cmluZycpO1xuICAgICAgICB9XG4gICAgICAgIGxldCBvZmZzZXQgPSAwO1xuICAgICAgICBmb3IgKGNvbnN0IGZkIG9mIHRoaXMuZmllbGRzKSB7XG4gICAgICAgICAgICBpZiAoZmQucHJvcGVydHkgPT09IHByb3BlcnR5KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG9mZnNldDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICgwID4gZmQuc3Bhbikge1xuICAgICAgICAgICAgICAgIG9mZnNldCA9IC0xO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoMCA8PSBvZmZzZXQpIHtcbiAgICAgICAgICAgICAgICBvZmZzZXQgKz0gZmQuc3BhbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbn1cbmV4cG9ydHMuU3RydWN0dXJlID0gU3RydWN0dXJlO1xuLyoqXG4gKiBBbiBvYmplY3QgdGhhdCBjYW4gcHJvdmlkZSBhIHtAbGlua1xuICogVW5pb24jZGlzY3JpbWluYXRvcnxkaXNjcmltaW5hdG9yfSBBUEkgZm9yIHtAbGluayBVbmlvbn0uXG4gKlxuICogKipOT1RFKiogVGhpcyBpcyBhbiBhYnN0cmFjdCBiYXNlIGNsYXNzOyB5b3UgY2FuIGNyZWF0ZSBpbnN0YW5jZXNcbiAqIGlmIGl0IGFtdXNlcyB5b3UsIGJ1dCB0aGV5IHdvbid0IHN1cHBvcnQgdGhlIHtAbGlua1xuICogVW5pb25EaXNjcmltaW5hdG9yI2VuY29kZXxlbmNvZGV9IG9yIHtAbGlua1xuICogVW5pb25EaXNjcmltaW5hdG9yI2RlY29kZXxkZWNvZGV9IGZ1bmN0aW9ucy5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gW3Byb3BlcnR5XSAtIERlZmF1bHQgZm9yIHtAbGlua1xuICogVW5pb25EaXNjcmltaW5hdG9yI3Byb3BlcnR5fHByb3BlcnR5fS5cbiAqXG4gKiBAYWJzdHJhY3RcbiAqL1xuY2xhc3MgVW5pb25EaXNjcmltaW5hdG9yIHtcbiAgICBjb25zdHJ1Y3Rvcihwcm9wZXJ0eSkge1xuICAgICAgICAvKiogVGhlIHtAbGluayBMYXlvdXQjcHJvcGVydHl8cHJvcGVydHl9IHRvIGJlIHVzZWQgd2hlbiB0aGVcbiAgICAgICAgICogZGlzY3JpbWluYXRvciBpcyByZWZlcmVuY2VkIGluIGlzb2xhdGlvbiAoZ2VuZXJhbGx5IHdoZW4ge0BsaW5rXG4gICAgICAgICAqIFVuaW9uI2RlY29kZXxVbmlvbiBkZWNvZGV9IGNhbm5vdCBkZWxlZ2F0ZSB0byBhIHNwZWNpZmljXG4gICAgICAgICAqIHZhcmlhbnQpLiAqL1xuICAgICAgICB0aGlzLnByb3BlcnR5ID0gcHJvcGVydHk7XG4gICAgfVxuICAgIC8qKiBBbmFsb2cgdG8ge0BsaW5rIExheW91dCNkZWNvZGV8TGF5b3V0IGRlY29kZX0gZm9yIHVuaW9uIGRpc2NyaW1pbmF0b3JzLlxuICAgICAqXG4gICAgICogVGhlIGltcGxlbWVudGF0aW9uIG9mIHRoaXMgbWV0aG9kIG5lZWQgbm90IHJlZmVyZW5jZSB0aGUgYnVmZmVyIGlmXG4gICAgICogdmFyaWFudCBpbmZvcm1hdGlvbiBpcyBhdmFpbGFibGUgdGhyb3VnaCBvdGhlciBtZWFucy4gKi9cbiAgICBkZWNvZGUoYiwgb2Zmc2V0KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignVW5pb25EaXNjcmltaW5hdG9yIGlzIGFic3RyYWN0Jyk7XG4gICAgfVxuICAgIC8qKiBBbmFsb2cgdG8ge0BsaW5rIExheW91dCNkZWNvZGV8TGF5b3V0IGVuY29kZX0gZm9yIHVuaW9uIGRpc2NyaW1pbmF0b3JzLlxuICAgICAqXG4gICAgICogVGhlIGltcGxlbWVudGF0aW9uIG9mIHRoaXMgbWV0aG9kIG5lZWQgbm90IHN0b3JlIHRoZSB2YWx1ZSBpZlxuICAgICAqIHZhcmlhbnQgaW5mb3JtYXRpb24gaXMgbWFpbnRhaW5lZCB0aHJvdWdoIG90aGVyIG1lYW5zLiAqL1xuICAgIGVuY29kZShzcmMsIGIsIG9mZnNldCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1VuaW9uRGlzY3JpbWluYXRvciBpcyBhYnN0cmFjdCcpO1xuICAgIH1cbn1cbmV4cG9ydHMuVW5pb25EaXNjcmltaW5hdG9yID0gVW5pb25EaXNjcmltaW5hdG9yO1xuLyoqXG4gKiBBbiBvYmplY3QgdGhhdCBjYW4gcHJvdmlkZSBhIHtAbGlua1xuICogVW5pb25EaXNjcmltaW5hdG9yfGRpc2NyaW1pbmF0b3IgQVBJfSBmb3Ige0BsaW5rIFVuaW9ufSB1c2luZyBhblxuICogdW5zaWduZWQgaW50ZWdyYWwge0BsaW5rIExheW91dH0gaW5zdGFuY2UgbG9jYXRlZCBlaXRoZXIgaW5zaWRlIG9yXG4gKiBvdXRzaWRlIHRoZSB1bmlvbi5cbiAqXG4gKiBAcGFyYW0ge0V4dGVybmFsTGF5b3V0fSBsYXlvdXQgLSBpbml0aWFsaXplcyB7QGxpbmtcbiAqIFVuaW9uTGF5b3V0RGlzY3JpbWluYXRvciNsYXlvdXR8bGF5b3V0fS4gIE11c3Qgc2F0aXNmeSB7QGxpbmtcbiAqIEV4dGVybmFsTGF5b3V0I2lzQ291bnR8aXNDb3VudCgpfS5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gW3Byb3BlcnR5XSAtIERlZmF1bHQgZm9yIHtAbGlua1xuICogVW5pb25EaXNjcmltaW5hdG9yI3Byb3BlcnR5fHByb3BlcnR5fSwgc3VwZXJzZWRpbmcgdGhlIHByb3BlcnR5XG4gKiBmcm9tIGBsYXlvdXRgLCBidXQgZGVmYXVsdGluZyB0byBgdmFyaWFudGAgaWYgbmVpdGhlciBgcHJvcGVydHlgXG4gKiBub3IgbGF5b3V0IHByb3ZpZGUgYSBwcm9wZXJ0eSBuYW1lLlxuICpcbiAqIEBhdWdtZW50cyB7VW5pb25EaXNjcmltaW5hdG9yfVxuICovXG5jbGFzcyBVbmlvbkxheW91dERpc2NyaW1pbmF0b3IgZXh0ZW5kcyBVbmlvbkRpc2NyaW1pbmF0b3Ige1xuICAgIGNvbnN0cnVjdG9yKGxheW91dCwgcHJvcGVydHkpIHtcbiAgICAgICAgaWYgKCEoKGxheW91dCBpbnN0YW5jZW9mIEV4dGVybmFsTGF5b3V0KVxuICAgICAgICAgICAgJiYgbGF5b3V0LmlzQ291bnQoKSkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2xheW91dCBtdXN0IGJlIGFuIHVuc2lnbmVkIGludGVnZXIgRXh0ZXJuYWxMYXlvdXQnKTtcbiAgICAgICAgfVxuICAgICAgICBzdXBlcihwcm9wZXJ0eSB8fCBsYXlvdXQucHJvcGVydHkgfHwgJ3ZhcmlhbnQnKTtcbiAgICAgICAgLyoqIFRoZSB7QGxpbmsgRXh0ZXJuYWxMYXlvdXR9IHVzZWQgdG8gYWNjZXNzIHRoZSBkaXNjcmltaW5hdG9yXG4gICAgICAgICAqIHZhbHVlLiAqL1xuICAgICAgICB0aGlzLmxheW91dCA9IGxheW91dDtcbiAgICB9XG4gICAgLyoqIERlbGVnYXRlIGRlY29kaW5nIHRvIHtAbGluayBVbmlvbkxheW91dERpc2NyaW1pbmF0b3IjbGF5b3V0fGxheW91dH0uICovXG4gICAgZGVjb2RlKGIsIG9mZnNldCkge1xuICAgICAgICByZXR1cm4gdGhpcy5sYXlvdXQuZGVjb2RlKGIsIG9mZnNldCk7XG4gICAgfVxuICAgIC8qKiBEZWxlZ2F0ZSBlbmNvZGluZyB0byB7QGxpbmsgVW5pb25MYXlvdXREaXNjcmltaW5hdG9yI2xheW91dHxsYXlvdXR9LiAqL1xuICAgIGVuY29kZShzcmMsIGIsIG9mZnNldCkge1xuICAgICAgICByZXR1cm4gdGhpcy5sYXlvdXQuZW5jb2RlKHNyYywgYiwgb2Zmc2V0KTtcbiAgICB9XG59XG5leHBvcnRzLlVuaW9uTGF5b3V0RGlzY3JpbWluYXRvciA9IFVuaW9uTGF5b3V0RGlzY3JpbWluYXRvcjtcbi8qKlxuICogUmVwcmVzZW50IGFueSBudW1iZXIgb2Ygc3Bhbi1jb21wYXRpYmxlIGxheW91dHMuXG4gKlxuICogKkZhY3RvcnkqOiB7QGxpbmsgbW9kdWxlOkxheW91dC51bmlvbnx1bmlvbn1cbiAqXG4gKiBJZiB0aGUgdW5pb24gaGFzIGEge0BsaW5rIFVuaW9uI2RlZmF1bHRMYXlvdXR8ZGVmYXVsdCBsYXlvdXR9IHRoYXRcbiAqIGxheW91dCBtdXN0IGhhdmUgYSBub24tbmVnYXRpdmUge0BsaW5rIExheW91dCNzcGFufHNwYW59LiAgVGhlIHNwYW5cbiAqIG9mIGEgZml4ZWQtc3BhbiB1bmlvbiBpbmNsdWRlcyBpdHMge0BsaW5rXG4gKiBVbmlvbiNkaXNjcmltaW5hdG9yfGRpc2NyaW1pbmF0b3J9IGlmIHRoZSB2YXJpYW50IGlzIGEge0BsaW5rXG4gKiBVbmlvbiN1c2VzUHJlZml4RGlzY3JpbWluYXRvcnxwcmVmaXggb2YgdGhlIHVuaW9ufSwgcGx1cyB0aGUgc3BhblxuICogb2YgaXRzIHtAbGluayBVbmlvbiNkZWZhdWx0TGF5b3V0fGRlZmF1bHQgbGF5b3V0fS5cbiAqXG4gKiBJZiB0aGUgdW5pb24gZG9lcyBub3QgaGF2ZSBhIGRlZmF1bHQgbGF5b3V0IHRoZW4gdGhlIGVuY29kZWQgc3BhblxuICogb2YgdGhlIHVuaW9uIGRlcGVuZHMgb24gdGhlIGVuY29kZWQgc3BhbiBvZiBpdHMgdmFyaWFudCAod2hpY2ggbWF5XG4gKiBiZSBmaXhlZCBvciB2YXJpYWJsZSkuXG4gKlxuICoge0BsaW5rIFZhcmlhbnRMYXlvdXQjbGF5b3V0fFZhcmlhbnQgbGF5b3V0fXMgYXJlIGFkZGVkIHRocm91Z2hcbiAqIHtAbGluayBVbmlvbiNhZGRWYXJpYW50fGFkZFZhcmlhbnR9LiAgSWYgdGhlIHVuaW9uIGhhcyBhIGRlZmF1bHRcbiAqIGxheW91dCwgdGhlIHNwYW4gb2YgdGhlIHtAbGluayBWYXJpYW50TGF5b3V0I2xheW91dHxsYXlvdXRcbiAqIGNvbnRhaW5lZCBieSB0aGUgdmFyaWFudH0gbXVzdCBub3QgZXhjZWVkIHRoZSBzcGFuIG9mIHRoZSB7QGxpbmtcbiAqIFVuaW9uI2RlZmF1bHRMYXlvdXR8ZGVmYXVsdCBsYXlvdXR9IChtaW51cyB0aGUgc3BhbiBvZiBhIHtAbGlua1xuICogVW5pb24jdXNlc1ByZWZpeERpc2NyaW1pbmF0b3J8cHJlZml4IGRpc3JpbWluYXRvcn0sIGlmIHVzZWQpLiAgVGhlXG4gKiBzcGFuIG9mIHRoZSB2YXJpYW50IHdpbGwgZXF1YWwgdGhlIHNwYW4gb2YgdGhlIHVuaW9uIGl0c2VsZi5cbiAqXG4gKiBUaGUgdmFyaWFudCBmb3IgYSBidWZmZXIgY2FuIG9ubHkgYmUgaWRlbnRpZmllZCBmcm9tIHRoZSB7QGxpbmtcbiAqIFVuaW9uI2Rpc2NyaW1pbmF0b3J8ZGlzY3JpbWluYXRvcn0ge0BsaW5rXG4gKiBVbmlvbkRpc2NyaW1pbmF0b3IjcHJvcGVydHl8cHJvcGVydHl9IChpbiB0aGUgY2FzZSBvZiB0aGUge0BsaW5rXG4gKiBVbmlvbiNkZWZhdWx0TGF5b3V0fGRlZmF1bHQgbGF5b3V0fSksIG9yIGJ5IHVzaW5nIHtAbGlua1xuICogVW5pb24jZ2V0VmFyaWFudHxnZXRWYXJpYW50fSBhbmQgZXhhbWluaW5nIHRoZSByZXN1bHRpbmcge0BsaW5rXG4gKiBWYXJpYW50TGF5b3V0fSBpbnN0YW5jZS5cbiAqXG4gKiBBIHZhcmlhbnQgY29tcGF0aWJsZSB3aXRoIGEgSmF2YVNjcmlwdCBvYmplY3QgY2FuIGJlIGlkZW50aWZpZWRcbiAqIHVzaW5nIHtAbGluayBVbmlvbiNnZXRTb3VyY2VWYXJpYW50fGdldFNvdXJjZVZhcmlhbnR9LlxuICpcbiAqIEBwYXJhbSB7KFVuaW9uRGlzY3JpbWluYXRvcnxFeHRlcm5hbExheW91dHxMYXlvdXQpfSBkaXNjciAtIEhvdyB0b1xuICogaWRlbnRpZnkgdGhlIGxheW91dCB1c2VkIHRvIGludGVycHJldCB0aGUgdW5pb24gY29udGVudHMuICBUaGVcbiAqIHBhcmFtZXRlciBtdXN0IGJlIGFuIGluc3RhbmNlIG9mIHtAbGluayBVbmlvbkRpc2NyaW1pbmF0b3J9LCBhblxuICoge0BsaW5rIEV4dGVybmFsTGF5b3V0fSB0aGF0IHNhdGlzZmllcyB7QGxpbmtcbiAqIEV4dGVybmFsTGF5b3V0I2lzQ291bnR8aXNDb3VudCgpfSwgb3Ige0BsaW5rIFVJbnR9IChvciB7QGxpbmtcbiAqIFVJbnRCRX0pLiAgV2hlbiBhIG5vbi1leHRlcm5hbCBsYXlvdXQgZWxlbWVudCBpcyBwYXNzZWQgdGhlIGxheW91dFxuICogYXBwZWFycyBhdCB0aGUgc3RhcnQgb2YgdGhlIHVuaW9uLiAgSW4gYWxsIGNhc2VzIHRoZSAoc3ludGhlc2l6ZWQpXG4gKiB7QGxpbmsgVW5pb25EaXNjcmltaW5hdG9yfSBpbnN0YW5jZSBpcyByZWNvcmRlZCBhcyB7QGxpbmtcbiAqIFVuaW9uI2Rpc2NyaW1pbmF0b3J8ZGlzY3JpbWluYXRvcn0uXG4gKlxuICogQHBhcmFtIHsoTGF5b3V0fG51bGwpfSBkZWZhdWx0TGF5b3V0IC0gaW5pdGlhbGl6ZXIgZm9yIHtAbGlua1xuICogVW5pb24jZGVmYXVsdExheW91dHxkZWZhdWx0TGF5b3V0fS4gIElmIGFic2VudCBkZWZhdWx0cyB0byBgbnVsbGAuXG4gKiBJZiBgbnVsbGAgdGhlcmUgaXMgbm8gZGVmYXVsdCBsYXlvdXQ6IHRoZSB1bmlvbiBoYXMgZGF0YS1kZXBlbmRlbnRcbiAqIGxlbmd0aCBhbmQgYXR0ZW1wdHMgdG8gZGVjb2RlIG9yIGVuY29kZSB1bnJlY29nbml6ZWQgdmFyaWFudHMgd2lsbFxuICogdGhyb3cgYW4gZXhjZXB0aW9uLiAgQSB7QGxpbmsgTGF5b3V0fSBpbnN0YW5jZSBtdXN0IGhhdmUgYVxuICogbm9uLW5lZ2F0aXZlIHtAbGluayBMYXlvdXQjc3BhbnxzcGFufSwgYW5kIGlmIGl0IGxhY2tzIGEge0BsaW5rXG4gKiBMYXlvdXQjcHJvcGVydHl8cHJvcGVydHl9IHRoZSB7QGxpbmtcbiAqIFVuaW9uI2RlZmF1bHRMYXlvdXR8ZGVmYXVsdExheW91dH0gd2lsbCBiZSBhIHtAbGlua1xuICogTGF5b3V0I3JlcGxpY2F0ZXxyZXBsaWNhfSB3aXRoIHByb3BlcnR5IGBjb250ZW50YC5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gW3Byb3BlcnR5XSAtIGluaXRpYWxpemVyIGZvciB7QGxpbmtcbiAqIExheW91dCNwcm9wZXJ0eXxwcm9wZXJ0eX0uXG4gKlxuICogQGF1Z21lbnRzIHtMYXlvdXR9XG4gKi9cbmNsYXNzIFVuaW9uIGV4dGVuZHMgTGF5b3V0IHtcbiAgICBjb25zdHJ1Y3RvcihkaXNjciwgZGVmYXVsdExheW91dCwgcHJvcGVydHkpIHtcbiAgICAgICAgbGV0IGRpc2NyaW1pbmF0b3I7XG4gICAgICAgIGlmICgoZGlzY3IgaW5zdGFuY2VvZiBVSW50KVxuICAgICAgICAgICAgfHwgKGRpc2NyIGluc3RhbmNlb2YgVUludEJFKSkge1xuICAgICAgICAgICAgZGlzY3JpbWluYXRvciA9IG5ldyBVbmlvbkxheW91dERpc2NyaW1pbmF0b3IobmV3IE9mZnNldExheW91dChkaXNjcikpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKChkaXNjciBpbnN0YW5jZW9mIEV4dGVybmFsTGF5b3V0KVxuICAgICAgICAgICAgJiYgZGlzY3IuaXNDb3VudCgpKSB7XG4gICAgICAgICAgICBkaXNjcmltaW5hdG9yID0gbmV3IFVuaW9uTGF5b3V0RGlzY3JpbWluYXRvcihkaXNjcik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoIShkaXNjciBpbnN0YW5jZW9mIFVuaW9uRGlzY3JpbWluYXRvcikpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2Rpc2NyIG11c3QgYmUgYSBVbmlvbkRpc2NyaW1pbmF0b3IgJ1xuICAgICAgICAgICAgICAgICsgJ29yIGFuIHVuc2lnbmVkIGludGVnZXIgbGF5b3V0Jyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBkaXNjcmltaW5hdG9yID0gZGlzY3I7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHVuZGVmaW5lZCA9PT0gZGVmYXVsdExheW91dCkge1xuICAgICAgICAgICAgZGVmYXVsdExheW91dCA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCEoKG51bGwgPT09IGRlZmF1bHRMYXlvdXQpXG4gICAgICAgICAgICB8fCAoZGVmYXVsdExheW91dCBpbnN0YW5jZW9mIExheW91dCkpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdkZWZhdWx0TGF5b3V0IG11c3QgYmUgbnVsbCBvciBhIExheW91dCcpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChudWxsICE9PSBkZWZhdWx0TGF5b3V0KSB7XG4gICAgICAgICAgICBpZiAoMCA+IGRlZmF1bHRMYXlvdXQuc3Bhbikge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignZGVmYXVsdExheW91dCBtdXN0IGhhdmUgY29uc3RhbnQgc3BhbicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHVuZGVmaW5lZCA9PT0gZGVmYXVsdExheW91dC5wcm9wZXJ0eSkge1xuICAgICAgICAgICAgICAgIGRlZmF1bHRMYXlvdXQgPSBkZWZhdWx0TGF5b3V0LnJlcGxpY2F0ZSgnY29udGVudCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8qIFRoZSB1bmlvbiBzcGFuIGNhbiBiZSBlc3RpbWF0ZWQgb25seSBpZiB0aGVyZSdzIGEgZGVmYXVsdFxuICAgICAgICAgKiBsYXlvdXQuICBUaGUgdW5pb24gc3BhbnMgaXRzIGRlZmF1bHQgbGF5b3V0LCBwbHVzIGFueSBwcmVmaXhcbiAgICAgICAgICogdmFyaWFudCBsYXlvdXQuICBCeSBjb25zdHJ1Y3Rpb24gYm90aCBsYXlvdXRzLCBpZiBwcmVzZW50LCBoYXZlXG4gICAgICAgICAqIG5vbi1uZWdhdGl2ZSBzcGFuLiAqL1xuICAgICAgICBsZXQgc3BhbiA9IC0xO1xuICAgICAgICBpZiAoZGVmYXVsdExheW91dCkge1xuICAgICAgICAgICAgc3BhbiA9IGRlZmF1bHRMYXlvdXQuc3BhbjtcbiAgICAgICAgICAgIGlmICgoMCA8PSBzcGFuKSAmJiAoKGRpc2NyIGluc3RhbmNlb2YgVUludClcbiAgICAgICAgICAgICAgICB8fCAoZGlzY3IgaW5zdGFuY2VvZiBVSW50QkUpKSkge1xuICAgICAgICAgICAgICAgIHNwYW4gKz0gZGlzY3JpbWluYXRvci5sYXlvdXQuc3BhbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBzdXBlcihzcGFuLCBwcm9wZXJ0eSk7XG4gICAgICAgIC8qKiBUaGUgaW50ZXJmYWNlIGZvciB0aGUgZGlzY3JpbWluYXRvciB2YWx1ZSBpbiBpc29sYXRpb24uXG4gICAgICAgICAqXG4gICAgICAgICAqIFRoaXMgYSB7QGxpbmsgVW5pb25EaXNjcmltaW5hdG9yfSBlaXRoZXIgcGFzc2VkIHRvIHRoZVxuICAgICAgICAgKiBjb25zdHJ1Y3RvciBvciBzeW50aGVzaXplZCBmcm9tIHRoZSBgZGlzY3JgIGNvbnN0cnVjdG9yXG4gICAgICAgICAqIGFyZ3VtZW50LiAge0BsaW5rXG4gICAgICAgICAqIFVuaW9uI3VzZXNQcmVmaXhEaXNjcmltaW5hdG9yfHVzZXNQcmVmaXhEaXNjcmltaW5hdG9yfSB3aWxsIGJlXG4gICAgICAgICAqIGB0cnVlYCBpZmYgdGhlIGBkaXNjcmAgcGFyYW1ldGVyIHdhcyBhIG5vbi1vZmZzZXQge0BsaW5rXG4gICAgICAgICAqIExheW91dH0gaW5zdGFuY2UuICovXG4gICAgICAgIHRoaXMuZGlzY3JpbWluYXRvciA9IGRpc2NyaW1pbmF0b3I7XG4gICAgICAgIC8qKiBgdHJ1ZWAgaWYgdGhlIHtAbGluayBVbmlvbiNkaXNjcmltaW5hdG9yfGRpc2NyaW1pbmF0b3J9IGlzIHRoZVxuICAgICAgICAgKiBmaXJzdCBmaWVsZCBpbiB0aGUgdW5pb24uXG4gICAgICAgICAqXG4gICAgICAgICAqIElmIGBmYWxzZWAgdGhlIGRpc2NyaW1pbmF0b3IgaXMgb2J0YWluZWQgZnJvbSBzb21ld2hlcmVcbiAgICAgICAgICogZWxzZS4gKi9cbiAgICAgICAgdGhpcy51c2VzUHJlZml4RGlzY3JpbWluYXRvciA9IChkaXNjciBpbnN0YW5jZW9mIFVJbnQpXG4gICAgICAgICAgICB8fCAoZGlzY3IgaW5zdGFuY2VvZiBVSW50QkUpO1xuICAgICAgICAvKiogVGhlIGxheW91dCBmb3Igbm9uLWRpc2NyaW1pbmF0b3IgY29udGVudCB3aGVuIHRoZSB2YWx1ZSBvZiB0aGVcbiAgICAgICAgICogZGlzY3JpbWluYXRvciBpcyBub3QgcmVjb2duaXplZC5cbiAgICAgICAgICpcbiAgICAgICAgICogVGhpcyBpcyB0aGUgdmFsdWUgcGFzc2VkIHRvIHRoZSBjb25zdHJ1Y3Rvci4gIEl0IGlzXG4gICAgICAgICAqIHN0cnVjdHVyYWxseSBlcXVpdmFsZW50IHRvIHRoZSBzZWNvbmQgY29tcG9uZW50IG9mIHtAbGlua1xuICAgICAgICAgKiBVbmlvbiNsYXlvdXR8bGF5b3V0fSBidXQgbWF5IGhhdmUgYSBkaWZmZXJlbnQgcHJvcGVydHlcbiAgICAgICAgICogbmFtZS4gKi9cbiAgICAgICAgdGhpcy5kZWZhdWx0TGF5b3V0ID0gZGVmYXVsdExheW91dDtcbiAgICAgICAgLyoqIEEgcmVnaXN0cnkgb2YgYWxsb3dlZCB2YXJpYW50cy5cbiAgICAgICAgICpcbiAgICAgICAgICogVGhlIGtleXMgYXJlIHVuc2lnbmVkIGludGVnZXJzIHdoaWNoIHNob3VsZCBiZSBjb21wYXRpYmxlIHdpdGhcbiAgICAgICAgICoge0BsaW5rIFVuaW9uLmRpc2NyaW1pbmF0b3J8ZGlzY3JpbWluYXRvcn0uICBUaGUgcHJvcGVydHkgdmFsdWVcbiAgICAgICAgICogaXMgdGhlIGNvcnJlc3BvbmRpbmcge0BsaW5rIFZhcmlhbnRMYXlvdXR9IGluc3RhbmNlcyBhc3NpZ25lZFxuICAgICAgICAgKiB0byB0aGlzIHVuaW9uIGJ5IHtAbGluayBVbmlvbiNhZGRWYXJpYW50fGFkZFZhcmlhbnR9LlxuICAgICAgICAgKlxuICAgICAgICAgKiAqKk5PVEUqKiBUaGUgcmVnaXN0cnkgcmVtYWlucyBtdXRhYmxlIHNvIHRoYXQgdmFyaWFudHMgY2FuIGJlXG4gICAgICAgICAqIHtAbGluayBVbmlvbiNhZGRWYXJpYW50fGFkZGVkfSBhdCBhbnkgdGltZS4gIFVzZXJzIHNob3VsZCBub3RcbiAgICAgICAgICogbWFuaXB1bGF0ZSB0aGUgY29udGVudCBvZiB0aGlzIHByb3BlcnR5LiAqL1xuICAgICAgICB0aGlzLnJlZ2lzdHJ5ID0ge307XG4gICAgICAgIC8qIFByaXZhdGUgdmFyaWFibGUgdXNlZCB3aGVuIGludm9raW5nIGdldFNvdXJjZVZhcmlhbnQgKi9cbiAgICAgICAgbGV0IGJvdW5kR2V0U291cmNlVmFyaWFudCA9IHRoaXMuZGVmYXVsdEdldFNvdXJjZVZhcmlhbnQuYmluZCh0aGlzKTtcbiAgICAgICAgLyoqIEZ1bmN0aW9uIHRvIGluZmVyIHRoZSB2YXJpYW50IHNlbGVjdGVkIGJ5IGEgc291cmNlIG9iamVjdC5cbiAgICAgICAgICpcbiAgICAgICAgICogRGVmYXVsdHMgdG8ge0BsaW5rXG4gICAgICAgICAqIFVuaW9uI2RlZmF1bHRHZXRTb3VyY2VWYXJpYW50fGRlZmF1bHRHZXRTb3VyY2VWYXJpYW50fSBidXQgbWF5XG4gICAgICAgICAqIGJlIG92ZXJyaWRkZW4gdXNpbmcge0BsaW5rXG4gICAgICAgICAqIFVuaW9uI2NvbmZpZ0dldFNvdXJjZVZhcmlhbnR8Y29uZmlnR2V0U291cmNlVmFyaWFudH0uXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBzcmMgLSBhcyB3aXRoIHtAbGlua1xuICAgICAgICAgKiBVbmlvbiNkZWZhdWx0R2V0U291cmNlVmFyaWFudHxkZWZhdWx0R2V0U291cmNlVmFyaWFudH0uXG4gICAgICAgICAqXG4gICAgICAgICAqIEByZXR1cm5zIHsodW5kZWZpbmVkfFZhcmlhbnRMYXlvdXQpfSBUaGUgZGVmYXVsdCB2YXJpYW50XG4gICAgICAgICAqIChgdW5kZWZpbmVkYCkgb3IgZmlyc3QgcmVnaXN0ZXJlZCB2YXJpYW50IHRoYXQgdXNlcyBhIHByb3BlcnR5XG4gICAgICAgICAqIGF2YWlsYWJsZSBpbiBgc3JjYC4gKi9cbiAgICAgICAgdGhpcy5nZXRTb3VyY2VWYXJpYW50ID0gZnVuY3Rpb24gKHNyYykge1xuICAgICAgICAgICAgcmV0dXJuIGJvdW5kR2V0U291cmNlVmFyaWFudChzcmMpO1xuICAgICAgICB9O1xuICAgICAgICAvKiogRnVuY3Rpb24gdG8gb3ZlcnJpZGUgdGhlIGltcGxlbWVudGF0aW9uIG9mIHtAbGlua1xuICAgICAgICAgKiBVbmlvbiNnZXRTb3VyY2VWYXJpYW50fGdldFNvdXJjZVZhcmlhbnR9LlxuICAgICAgICAgKlxuICAgICAgICAgKiBVc2UgdGhpcyBpZiB0aGUgZGVzaXJlZCB2YXJpYW50IGNhbm5vdCBiZSBpZGVudGlmaWVkIHVzaW5nIHRoZVxuICAgICAgICAgKiBhbGdvcml0aG0gb2Yge0BsaW5rXG4gICAgICAgICAqIFVuaW9uI2RlZmF1bHRHZXRTb3VyY2VWYXJpYW50fGRlZmF1bHRHZXRTb3VyY2VWYXJpYW50fS5cbiAgICAgICAgICpcbiAgICAgICAgICogKipOT1RFKiogVGhlIHByb3ZpZGVkIGZ1bmN0aW9uIHdpbGwgYmUgaW52b2tlZCBib3VuZCB0byB0aGlzXG4gICAgICAgICAqIFVuaW9uIGluc3RhbmNlLCBwcm92aWRpbmcgbG9jYWwgYWNjZXNzIHRvIHtAbGlua1xuICAgICAgICAgKiBVbmlvbiNyZWdpc3RyeXxyZWdpc3RyeX0uXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGdzdiAtIGEgZnVuY3Rpb24gdGhhdCBmb2xsb3dzIHRoZSBBUEkgb2ZcbiAgICAgICAgICoge0BsaW5rIFVuaW9uI2RlZmF1bHRHZXRTb3VyY2VWYXJpYW50fGRlZmF1bHRHZXRTb3VyY2VWYXJpYW50fS4gKi9cbiAgICAgICAgdGhpcy5jb25maWdHZXRTb3VyY2VWYXJpYW50ID0gZnVuY3Rpb24gKGdzdikge1xuICAgICAgICAgICAgYm91bmRHZXRTb3VyY2VWYXJpYW50ID0gZ3N2LmJpbmQodGhpcyk7XG4gICAgICAgIH07XG4gICAgfVxuICAgIC8qKiBAb3ZlcnJpZGUgKi9cbiAgICBnZXRTcGFuKGIsIG9mZnNldCA9IDApIHtcbiAgICAgICAgaWYgKDAgPD0gdGhpcy5zcGFuKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zcGFuO1xuICAgICAgICB9XG4gICAgICAgIC8qIERlZmF1bHQgbGF5b3V0cyBhbHdheXMgaGF2ZSBub24tbmVnYXRpdmUgc3Bhbiwgc28gd2UgZG9uJ3QgaGF2ZVxuICAgICAgICAgKiBvbmUgYW5kIHdlIGhhdmUgdG8gcmVjb2duaXplIHRoZSB2YXJpYW50IHdoaWNoIHdpbGwgaW4gdHVyblxuICAgICAgICAgKiBkZXRlcm1pbmUgdGhlIHNwYW4uICovXG4gICAgICAgIGNvbnN0IHZsbyA9IHRoaXMuZ2V0VmFyaWFudChiLCBvZmZzZXQpO1xuICAgICAgICBpZiAoIXZsbykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd1bmFibGUgdG8gZGV0ZXJtaW5lIHNwYW4gZm9yIHVucmVjb2duaXplZCB2YXJpYW50Jyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHZsby5nZXRTcGFuKGIsIG9mZnNldCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE1ldGhvZCB0byBpbmZlciBhIHJlZ2lzdGVyZWQgVW5pb24gdmFyaWFudCBjb21wYXRpYmxlIHdpdGggYHNyY2AuXG4gICAgICpcbiAgICAgKiBUaGUgZmlyc3Qgc2F0aXNmaWVkIHJ1bGUgaW4gdGhlIGZvbGxvd2luZyBzZXF1ZW5jZSBkZWZpbmVzIHRoZVxuICAgICAqIHJldHVybiB2YWx1ZTpcbiAgICAgKiAqIElmIGBzcmNgIGhhcyBwcm9wZXJ0aWVzIG1hdGNoaW5nIHRoZSBVbmlvbiBkaXNjcmltaW5hdG9yIGFuZFxuICAgICAqICAgdGhlIGRlZmF1bHQgbGF5b3V0LCBgdW5kZWZpbmVkYCBpcyByZXR1cm5lZCByZWdhcmRsZXNzIG9mIHRoZVxuICAgICAqICAgdmFsdWUgb2YgdGhlIGRpc2NyaW1pbmF0b3IgcHJvcGVydHkgKHRoaXMgZW5zdXJlcyB0aGUgZGVmYXVsdFxuICAgICAqICAgbGF5b3V0IHdpbGwgYmUgdXNlZCk7XG4gICAgICogKiBJZiBgc3JjYCBoYXMgYSBwcm9wZXJ0eSBtYXRjaGluZyB0aGUgVW5pb24gZGlzY3JpbWluYXRvciwgdGhlXG4gICAgICogICB2YWx1ZSBvZiB0aGUgZGlzY3JpbWluYXRvciBpZGVudGlmaWVzIGEgcmVnaXN0ZXJlZCB2YXJpYW50LCBhbmRcbiAgICAgKiAgIGVpdGhlciAoYSkgdGhlIHZhcmlhbnQgaGFzIG5vIGxheW91dCwgb3IgKGIpIGBzcmNgIGhhcyB0aGVcbiAgICAgKiAgIHZhcmlhbnQncyBwcm9wZXJ0eSwgdGhlbiB0aGUgdmFyaWFudCBpcyByZXR1cm5lZCAoYmVjYXVzZSB0aGVcbiAgICAgKiAgIHNvdXJjZSBzYXRpc2ZpZXMgdGhlIGNvbnN0cmFpbnRzIG9mIHRoZSB2YXJpYW50IGl0IGlkZW50aWZpZXMpO1xuICAgICAqICogSWYgYHNyY2AgZG9lcyBub3QgaGF2ZSBhIHByb3BlcnR5IG1hdGNoaW5nIHRoZSBVbmlvblxuICAgICAqICAgZGlzY3JpbWluYXRvciwgYnV0IGRvZXMgaGF2ZSBhIHByb3BlcnR5IG1hdGNoaW5nIGEgcmVnaXN0ZXJlZFxuICAgICAqICAgdmFyaWFudCwgdGhlbiB0aGUgdmFyaWFudCBpcyByZXR1cm5lZCAoYmVjYXVzZSB0aGUgc291cmNlXG4gICAgICogICBtYXRjaGVzIGEgdmFyaWFudCB3aXRob3V0IGFuIGV4cGxpY2l0IGNvbmZsaWN0KTtcbiAgICAgKiAqIEFuIGVycm9yIGlzIHRocm93biAoYmVjYXVzZSB3ZSBlaXRoZXIgY2FuJ3QgaWRlbnRpZnkgYSB2YXJpYW50LFxuICAgICAqICAgb3Igd2Ugd2VyZSBleHBsaWNpdGx5IHRvbGQgdGhlIHZhcmlhbnQgYnV0IGNhbid0IHNhdGlzZnkgaXQpLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHNyYyAtIGFuIG9iamVjdCBwcmVzdW1lZCB0byBiZSBjb21wYXRpYmxlIHdpdGhcbiAgICAgKiB0aGUgY29udGVudCBvZiB0aGUgVW5pb24uXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHsodW5kZWZpbmVkfFZhcmlhbnRMYXlvdXQpfSAtIGFzIGRlc2NyaWJlZCBhYm92ZS5cbiAgICAgKlxuICAgICAqIEB0aHJvd3Mge0Vycm9yfSAtIGlmIGBzcmNgIGNhbm5vdCBiZSBhc3NvY2lhdGVkIHdpdGggYSBkZWZhdWx0IG9yXG4gICAgICogcmVnaXN0ZXJlZCB2YXJpYW50LlxuICAgICAqL1xuICAgIGRlZmF1bHRHZXRTb3VyY2VWYXJpYW50KHNyYykge1xuICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNyYywgdGhpcy5kaXNjcmltaW5hdG9yLnByb3BlcnR5KSkge1xuICAgICAgICAgICAgaWYgKHRoaXMuZGVmYXVsdExheW91dCAmJiB0aGlzLmRlZmF1bHRMYXlvdXQucHJvcGVydHlcbiAgICAgICAgICAgICAgICAmJiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc3JjLCB0aGlzLmRlZmF1bHRMYXlvdXQucHJvcGVydHkpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHZsbyA9IHRoaXMucmVnaXN0cnlbc3JjW3RoaXMuZGlzY3JpbWluYXRvci5wcm9wZXJ0eV1dO1xuICAgICAgICAgICAgaWYgKHZsb1xuICAgICAgICAgICAgICAgICYmICgoIXZsby5sYXlvdXQpXG4gICAgICAgICAgICAgICAgICAgIHx8ICh2bG8ucHJvcGVydHkgJiYgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNyYywgdmxvLnByb3BlcnR5KSkpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHZsbztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgdGFnIGluIHRoaXMucmVnaXN0cnkpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB2bG8gPSB0aGlzLnJlZ2lzdHJ5W3RhZ107XG4gICAgICAgICAgICAgICAgaWYgKHZsby5wcm9wZXJ0eSAmJiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc3JjLCB2bG8ucHJvcGVydHkpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB2bG87XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRocm93IG5ldyBFcnJvcigndW5hYmxlIHRvIGluZmVyIHNyYyB2YXJpYW50Jyk7XG4gICAgfVxuICAgIC8qKiBJbXBsZW1lbnQge0BsaW5rIExheW91dCNkZWNvZGV8ZGVjb2RlfSBmb3Ige0BsaW5rIFVuaW9ufS5cbiAgICAgKlxuICAgICAqIElmIHRoZSB2YXJpYW50IGlzIHtAbGluayBVbmlvbiNhZGRWYXJpYW50fHJlZ2lzdGVyZWR9IHRoZSByZXR1cm5cbiAgICAgKiB2YWx1ZSBpcyBhbiBpbnN0YW5jZSBvZiB0aGF0IHZhcmlhbnQsIHdpdGggbm8gZXhwbGljaXRcbiAgICAgKiBkaXNjcmltaW5hdG9yLiAgT3RoZXJ3aXNlIHRoZSB7QGxpbmsgVW5pb24jZGVmYXVsdExheW91dHxkZWZhdWx0XG4gICAgICogbGF5b3V0fSBpcyB1c2VkIHRvIGRlY29kZSB0aGUgY29udGVudC4gKi9cbiAgICBkZWNvZGUoYiwgb2Zmc2V0ID0gMCkge1xuICAgICAgICBsZXQgZGVzdDtcbiAgICAgICAgY29uc3QgZGxvID0gdGhpcy5kaXNjcmltaW5hdG9yO1xuICAgICAgICBjb25zdCBkaXNjciA9IGRsby5kZWNvZGUoYiwgb2Zmc2V0KTtcbiAgICAgICAgY29uc3QgY2xvID0gdGhpcy5yZWdpc3RyeVtkaXNjcl07XG4gICAgICAgIGlmICh1bmRlZmluZWQgPT09IGNsbykge1xuICAgICAgICAgICAgY29uc3QgZGVmYXVsdExheW91dCA9IHRoaXMuZGVmYXVsdExheW91dDtcbiAgICAgICAgICAgIGxldCBjb250ZW50T2Zmc2V0ID0gMDtcbiAgICAgICAgICAgIGlmICh0aGlzLnVzZXNQcmVmaXhEaXNjcmltaW5hdG9yKSB7XG4gICAgICAgICAgICAgICAgY29udGVudE9mZnNldCA9IGRsby5sYXlvdXQuc3BhbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRlc3QgPSB0aGlzLm1ha2VEZXN0aW5hdGlvbk9iamVjdCgpO1xuICAgICAgICAgICAgZGVzdFtkbG8ucHJvcGVydHldID0gZGlzY3I7XG4gICAgICAgICAgICAvLyBkZWZhdWx0TGF5b3V0LnByb3BlcnR5IGNhbiBiZSB1bmRlZmluZWQsIGJ1dCB0aGlzIGlzIGFsbG93ZWQgYnkgYnVmZmVyLWxheW91dFxuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1ub24tbnVsbC1hc3NlcnRpb25cbiAgICAgICAgICAgIGRlc3RbZGVmYXVsdExheW91dC5wcm9wZXJ0eV0gPSBkZWZhdWx0TGF5b3V0LmRlY29kZShiLCBvZmZzZXQgKyBjb250ZW50T2Zmc2V0KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGRlc3QgPSBjbG8uZGVjb2RlKGIsIG9mZnNldCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGRlc3Q7XG4gICAgfVxuICAgIC8qKiBJbXBsZW1lbnQge0BsaW5rIExheW91dCNlbmNvZGV8ZW5jb2RlfSBmb3Ige0BsaW5rIFVuaW9ufS5cbiAgICAgKlxuICAgICAqIFRoaXMgQVBJIGFzc3VtZXMgdGhlIGBzcmNgIG9iamVjdCBpcyBjb25zaXN0ZW50IHdpdGggdGhlIHVuaW9uJ3NcbiAgICAgKiB7QGxpbmsgVW5pb24jZGVmYXVsdExheW91dHxkZWZhdWx0IGxheW91dH0uICBUbyBlbmNvZGUgdmFyaWFudHNcbiAgICAgKiB1c2UgdGhlIGFwcHJvcHJpYXRlIHZhcmlhbnQtc3BlY2lmaWMge0BsaW5rIFZhcmlhbnRMYXlvdXQjZW5jb2RlfVxuICAgICAqIG1ldGhvZC4gKi9cbiAgICBlbmNvZGUoc3JjLCBiLCBvZmZzZXQgPSAwKSB7XG4gICAgICAgIGNvbnN0IHZsbyA9IHRoaXMuZ2V0U291cmNlVmFyaWFudChzcmMpO1xuICAgICAgICBpZiAodW5kZWZpbmVkID09PSB2bG8pIHtcbiAgICAgICAgICAgIGNvbnN0IGRsbyA9IHRoaXMuZGlzY3JpbWluYXRvcjtcbiAgICAgICAgICAgIC8vIHRoaXMuZGVmYXVsdExheW91dCBpcyBub3QgdW5kZWZpbmVkIHdoZW4gdmxvIGlzIHVuZGVmaW5lZFxuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1ub24tbnVsbC1hc3NlcnRpb25cbiAgICAgICAgICAgIGNvbnN0IGNsbyA9IHRoaXMuZGVmYXVsdExheW91dDtcbiAgICAgICAgICAgIGxldCBjb250ZW50T2Zmc2V0ID0gMDtcbiAgICAgICAgICAgIGlmICh0aGlzLnVzZXNQcmVmaXhEaXNjcmltaW5hdG9yKSB7XG4gICAgICAgICAgICAgICAgY29udGVudE9mZnNldCA9IGRsby5sYXlvdXQuc3BhbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRsby5lbmNvZGUoc3JjW2Rsby5wcm9wZXJ0eV0sIGIsIG9mZnNldCk7XG4gICAgICAgICAgICAvLyBjbG8ucHJvcGVydHkgaXMgbm90IHVuZGVmaW5lZCB3aGVuIHZsbyBpcyB1bmRlZmluZWRcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tbm9uLW51bGwtYXNzZXJ0aW9uXG4gICAgICAgICAgICByZXR1cm4gY29udGVudE9mZnNldCArIGNsby5lbmNvZGUoc3JjW2Nsby5wcm9wZXJ0eV0sIGIsIG9mZnNldCArIGNvbnRlbnRPZmZzZXQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2bG8uZW5jb2RlKHNyYywgYiwgb2Zmc2V0KTtcbiAgICB9XG4gICAgLyoqIFJlZ2lzdGVyIGEgbmV3IHZhcmlhbnQgc3RydWN0dXJlIHdpdGhpbiBhIHVuaW9uLiAgVGhlIG5ld2x5XG4gICAgICogY3JlYXRlZCB2YXJpYW50IGlzIHJldHVybmVkLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHZhcmlhbnQgLSBpbml0aWFsaXplciBmb3Ige0BsaW5rXG4gICAgICogVmFyaWFudExheW91dCN2YXJpYW50fHZhcmlhbnR9LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtMYXlvdXR9IGxheW91dCAtIGluaXRpYWxpemVyIGZvciB7QGxpbmtcbiAgICAgKiBWYXJpYW50TGF5b3V0I2xheW91dHxsYXlvdXR9LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHByb3BlcnR5IC0gaW5pdGlhbGl6ZXIgZm9yIHtAbGlua1xuICAgICAqIExheW91dCNwcm9wZXJ0eXxwcm9wZXJ0eX0uXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHtWYXJpYW50TGF5b3V0fSAqL1xuICAgIGFkZFZhcmlhbnQodmFyaWFudCwgbGF5b3V0LCBwcm9wZXJ0eSkge1xuICAgICAgICBjb25zdCBydiA9IG5ldyBWYXJpYW50TGF5b3V0KHRoaXMsIHZhcmlhbnQsIGxheW91dCwgcHJvcGVydHkpO1xuICAgICAgICB0aGlzLnJlZ2lzdHJ5W3ZhcmlhbnRdID0gcnY7XG4gICAgICAgIHJldHVybiBydjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBsYXlvdXQgYXNzb2NpYXRlZCB3aXRoIGEgcmVnaXN0ZXJlZCB2YXJpYW50LlxuICAgICAqXG4gICAgICogSWYgYHZiYCBkb2VzIG5vdCBwcm9kdWNlIGEgcmVnaXN0ZXJlZCB2YXJpYW50IHRoZSBmdW5jdGlvbiByZXR1cm5zXG4gICAgICogYHVuZGVmaW5lZGAuXG4gICAgICpcbiAgICAgKiBAcGFyYW0geyhOdW1iZXJ8VWludDhBcnJheSl9IHZiIC0gZWl0aGVyIHRoZSB2YXJpYW50IG51bWJlciwgb3IgYVxuICAgICAqIGJ1ZmZlciBmcm9tIHdoaWNoIHRoZSBkaXNjcmltaW5hdG9yIGlzIHRvIGJlIHJlYWQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gb2Zmc2V0IC0gb2Zmc2V0IGludG8gYHZiYCBmb3IgdGhlIHN0YXJ0IG9mIHRoZVxuICAgICAqIHVuaW9uLiAgVXNlZCBvbmx5IHdoZW4gYHZiYCBpcyBhbiBpbnN0YW5jZSBvZiB7VWludDhBcnJheX0uXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHsoe1ZhcmlhbnRMYXlvdXR9fHVuZGVmaW5lZCl9XG4gICAgICovXG4gICAgZ2V0VmFyaWFudCh2Yiwgb2Zmc2V0ID0gMCkge1xuICAgICAgICBsZXQgdmFyaWFudDtcbiAgICAgICAgaWYgKHZiIGluc3RhbmNlb2YgVWludDhBcnJheSkge1xuICAgICAgICAgICAgdmFyaWFudCA9IHRoaXMuZGlzY3JpbWluYXRvci5kZWNvZGUodmIsIG9mZnNldCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB2YXJpYW50ID0gdmI7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMucmVnaXN0cnlbdmFyaWFudF07XG4gICAgfVxufVxuZXhwb3J0cy5VbmlvbiA9IFVuaW9uO1xuLyoqXG4gKiBSZXByZXNlbnQgYSBzcGVjaWZpYyB2YXJpYW50IHdpdGhpbiBhIGNvbnRhaW5pbmcgdW5pb24uXG4gKlxuICogKipOT1RFKiogVGhlIHtAbGluayBMYXlvdXQjc3BhbnxzcGFufSBvZiB0aGUgdmFyaWFudCBtYXkgaW5jbHVkZVxuICogdGhlIHNwYW4gb2YgdGhlIHtAbGluayBVbmlvbiNkaXNjcmltaW5hdG9yfGRpc2NyaW1pbmF0b3J9IHVzZWQgdG9cbiAqIGlkZW50aWZ5IGl0LCBidXQgdmFsdWVzIHJlYWQgYW5kIHdyaXR0ZW4gdXNpbmcgdGhlIHZhcmlhbnQgc3RyaWN0bHlcbiAqIGNvbmZvcm0gdG8gdGhlIGNvbnRlbnQgb2Yge0BsaW5rIFZhcmlhbnRMYXlvdXQjbGF5b3V0fGxheW91dH0uXG4gKlxuICogKipOT1RFKiogVXNlciBjb2RlIHNob3VsZCBub3QgaW52b2tlIHRoaXMgY29uc3RydWN0b3IgZGlyZWN0bHkuICBVc2VcbiAqIHRoZSB1bmlvbiB7QGxpbmsgVW5pb24jYWRkVmFyaWFudHxhZGRWYXJpYW50fSBoZWxwZXIgbWV0aG9kLlxuICpcbiAqIEBwYXJhbSB7VW5pb259IHVuaW9uIC0gaW5pdGlhbGl6ZXIgZm9yIHtAbGlua1xuICogVmFyaWFudExheW91dCN1bmlvbnx1bmlvbn0uXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IHZhcmlhbnQgLSBpbml0aWFsaXplciBmb3Ige0BsaW5rXG4gKiBWYXJpYW50TGF5b3V0I3ZhcmlhbnR8dmFyaWFudH0uXG4gKlxuICogQHBhcmFtIHtMYXlvdXR9IFtsYXlvdXRdIC0gaW5pdGlhbGl6ZXIgZm9yIHtAbGlua1xuICogVmFyaWFudExheW91dCNsYXlvdXR8bGF5b3V0fS4gIElmIGFic2VudCB0aGUgdmFyaWFudCBjYXJyaWVzIG5vXG4gKiBkYXRhLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBbcHJvcGVydHldIC0gaW5pdGlhbGl6ZXIgZm9yIHtAbGlua1xuICogTGF5b3V0I3Byb3BlcnR5fHByb3BlcnR5fS4gIFVubGlrZSBtYW55IG90aGVyIGxheW91dHMsIHZhcmlhbnRcbiAqIGxheW91dHMgbm9ybWFsbHkgaW5jbHVkZSBhIHByb3BlcnR5IG5hbWUgc28gdGhleSBjYW4gYmUgaWRlbnRpZmllZFxuICogd2l0aGluIHRoZWlyIGNvbnRhaW5pbmcge0BsaW5rIFVuaW9ufS4gIFRoZSBwcm9wZXJ0eSBpZGVudGlmaWVyIG1heVxuICogYmUgYWJzZW50IG9ubHkgaWYgYGxheW91dGAgaXMgaXMgYWJzZW50LlxuICpcbiAqIEBhdWdtZW50cyB7TGF5b3V0fVxuICovXG5jbGFzcyBWYXJpYW50TGF5b3V0IGV4dGVuZHMgTGF5b3V0IHtcbiAgICBjb25zdHJ1Y3Rvcih1bmlvbiwgdmFyaWFudCwgbGF5b3V0LCBwcm9wZXJ0eSkge1xuICAgICAgICBpZiAoISh1bmlvbiBpbnN0YW5jZW9mIFVuaW9uKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcigndW5pb24gbXVzdCBiZSBhIFVuaW9uJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCghTnVtYmVyLmlzSW50ZWdlcih2YXJpYW50KSkgfHwgKDAgPiB2YXJpYW50KSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcigndmFyaWFudCBtdXN0IGJlIGEgKG5vbi1uZWdhdGl2ZSkgaW50ZWdlcicpO1xuICAgICAgICB9XG4gICAgICAgIGlmICgoJ3N0cmluZycgPT09IHR5cGVvZiBsYXlvdXQpXG4gICAgICAgICAgICAmJiAodW5kZWZpbmVkID09PSBwcm9wZXJ0eSkpIHtcbiAgICAgICAgICAgIHByb3BlcnR5ID0gbGF5b3V0O1xuICAgICAgICAgICAgbGF5b3V0ID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBpZiAobGF5b3V0KSB7XG4gICAgICAgICAgICBpZiAoIShsYXlvdXQgaW5zdGFuY2VvZiBMYXlvdXQpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignbGF5b3V0IG11c3QgYmUgYSBMYXlvdXQnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICgobnVsbCAhPT0gdW5pb24uZGVmYXVsdExheW91dClcbiAgICAgICAgICAgICAgICAmJiAoMCA8PSBsYXlvdXQuc3BhbilcbiAgICAgICAgICAgICAgICAmJiAobGF5b3V0LnNwYW4gPiB1bmlvbi5kZWZhdWx0TGF5b3V0LnNwYW4pKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd2YXJpYW50IHNwYW4gZXhjZWVkcyBzcGFuIG9mIGNvbnRhaW5pbmcgdW5pb24nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICgnc3RyaW5nJyAhPT0gdHlwZW9mIHByb3BlcnR5KSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcigndmFyaWFudCBtdXN0IGhhdmUgYSBTdHJpbmcgcHJvcGVydHknKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBsZXQgc3BhbiA9IHVuaW9uLnNwYW47XG4gICAgICAgIGlmICgwID4gdW5pb24uc3Bhbikge1xuICAgICAgICAgICAgc3BhbiA9IGxheW91dCA/IGxheW91dC5zcGFuIDogMDtcbiAgICAgICAgICAgIGlmICgoMCA8PSBzcGFuKSAmJiB1bmlvbi51c2VzUHJlZml4RGlzY3JpbWluYXRvcikge1xuICAgICAgICAgICAgICAgIHNwYW4gKz0gdW5pb24uZGlzY3JpbWluYXRvci5sYXlvdXQuc3BhbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBzdXBlcihzcGFuLCBwcm9wZXJ0eSk7XG4gICAgICAgIC8qKiBUaGUge0BsaW5rIFVuaW9ufSB0byB3aGljaCB0aGlzIHZhcmlhbnQgYmVsb25ncy4gKi9cbiAgICAgICAgdGhpcy51bmlvbiA9IHVuaW9uO1xuICAgICAgICAvKiogVGhlIHVuc2lnbmVkIGludGVncmFsIHZhbHVlIGlkZW50aWZ5aW5nIHRoaXMgdmFyaWFudCB3aXRoaW5cbiAgICAgICAgICogdGhlIHtAbGluayBVbmlvbiNkaXNjcmltaW5hdG9yfGRpc2NyaW1pbmF0b3J9IG9mIHRoZSBjb250YWluaW5nXG4gICAgICAgICAqIHVuaW9uLiAqL1xuICAgICAgICB0aGlzLnZhcmlhbnQgPSB2YXJpYW50O1xuICAgICAgICAvKiogVGhlIHtAbGluayBMYXlvdXR9IHRvIGJlIHVzZWQgd2hlbiByZWFkaW5nL3dyaXRpbmcgdGhlXG4gICAgICAgICAqIG5vbi1kaXNjcmltaW5hdG9yIHBhcnQgb2YgdGhlIHtAbGlua1xuICAgICAgICAgKiBWYXJpYW50TGF5b3V0I3VuaW9ufHVuaW9ufS4gIElmIGBudWxsYCB0aGUgdmFyaWFudCBjYXJyaWVzIG5vXG4gICAgICAgICAqIGRhdGEuICovXG4gICAgICAgIHRoaXMubGF5b3V0ID0gbGF5b3V0IHx8IG51bGw7XG4gICAgfVxuICAgIC8qKiBAb3ZlcnJpZGUgKi9cbiAgICBnZXRTcGFuKGIsIG9mZnNldCA9IDApIHtcbiAgICAgICAgaWYgKDAgPD0gdGhpcy5zcGFuKSB7XG4gICAgICAgICAgICAvKiBXaWxsIGJlIGVxdWFsIHRvIHRoZSBjb250YWluaW5nIHVuaW9uIHNwYW4gaWYgdGhhdCBpcyBub3RcbiAgICAgICAgICAgICAqIHZhcmlhYmxlLiAqL1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc3BhbjtcbiAgICAgICAgfVxuICAgICAgICBsZXQgY29udGVudE9mZnNldCA9IDA7XG4gICAgICAgIGlmICh0aGlzLnVuaW9uLnVzZXNQcmVmaXhEaXNjcmltaW5hdG9yKSB7XG4gICAgICAgICAgICBjb250ZW50T2Zmc2V0ID0gdGhpcy51bmlvbi5kaXNjcmltaW5hdG9yLmxheW91dC5zcGFuO1xuICAgICAgICB9XG4gICAgICAgIC8qIFNwYW4gaXMgZGVmaW5lZCBzb2xlbHkgYnkgdGhlIHZhcmlhbnQgKGFuZCBwcmVmaXggZGlzY3JpbWluYXRvcikgKi9cbiAgICAgICAgbGV0IHNwYW4gPSAwO1xuICAgICAgICBpZiAodGhpcy5sYXlvdXQpIHtcbiAgICAgICAgICAgIHNwYW4gPSB0aGlzLmxheW91dC5nZXRTcGFuKGIsIG9mZnNldCArIGNvbnRlbnRPZmZzZXQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjb250ZW50T2Zmc2V0ICsgc3BhbjtcbiAgICB9XG4gICAgLyoqIEBvdmVycmlkZSAqL1xuICAgIGRlY29kZShiLCBvZmZzZXQgPSAwKSB7XG4gICAgICAgIGNvbnN0IGRlc3QgPSB0aGlzLm1ha2VEZXN0aW5hdGlvbk9iamVjdCgpO1xuICAgICAgICBpZiAodGhpcyAhPT0gdGhpcy51bmlvbi5nZXRWYXJpYW50KGIsIG9mZnNldCkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigndmFyaWFudCBtaXNtYXRjaCcpO1xuICAgICAgICB9XG4gICAgICAgIGxldCBjb250ZW50T2Zmc2V0ID0gMDtcbiAgICAgICAgaWYgKHRoaXMudW5pb24udXNlc1ByZWZpeERpc2NyaW1pbmF0b3IpIHtcbiAgICAgICAgICAgIGNvbnRlbnRPZmZzZXQgPSB0aGlzLnVuaW9uLmRpc2NyaW1pbmF0b3IubGF5b3V0LnNwYW47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMubGF5b3V0KSB7XG4gICAgICAgICAgICBkZXN0W3RoaXMucHJvcGVydHldID0gdGhpcy5sYXlvdXQuZGVjb2RlKGIsIG9mZnNldCArIGNvbnRlbnRPZmZzZXQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMucHJvcGVydHkpIHtcbiAgICAgICAgICAgIGRlc3RbdGhpcy5wcm9wZXJ0eV0gPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMudW5pb24udXNlc1ByZWZpeERpc2NyaW1pbmF0b3IpIHtcbiAgICAgICAgICAgIGRlc3RbdGhpcy51bmlvbi5kaXNjcmltaW5hdG9yLnByb3BlcnR5XSA9IHRoaXMudmFyaWFudDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZGVzdDtcbiAgICB9XG4gICAgLyoqIEBvdmVycmlkZSAqL1xuICAgIGVuY29kZShzcmMsIGIsIG9mZnNldCA9IDApIHtcbiAgICAgICAgbGV0IGNvbnRlbnRPZmZzZXQgPSAwO1xuICAgICAgICBpZiAodGhpcy51bmlvbi51c2VzUHJlZml4RGlzY3JpbWluYXRvcikge1xuICAgICAgICAgICAgY29udGVudE9mZnNldCA9IHRoaXMudW5pb24uZGlzY3JpbWluYXRvci5sYXlvdXQuc3BhbjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5sYXlvdXRcbiAgICAgICAgICAgICYmICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNyYywgdGhpcy5wcm9wZXJ0eSkpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCd2YXJpYW50IGxhY2tzIHByb3BlcnR5ICcgKyB0aGlzLnByb3BlcnR5KTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnVuaW9uLmRpc2NyaW1pbmF0b3IuZW5jb2RlKHRoaXMudmFyaWFudCwgYiwgb2Zmc2V0KTtcbiAgICAgICAgbGV0IHNwYW4gPSBjb250ZW50T2Zmc2V0O1xuICAgICAgICBpZiAodGhpcy5sYXlvdXQpIHtcbiAgICAgICAgICAgIHRoaXMubGF5b3V0LmVuY29kZShzcmNbdGhpcy5wcm9wZXJ0eV0sIGIsIG9mZnNldCArIGNvbnRlbnRPZmZzZXQpO1xuICAgICAgICAgICAgc3BhbiArPSB0aGlzLmxheW91dC5nZXRTcGFuKGIsIG9mZnNldCArIGNvbnRlbnRPZmZzZXQpO1xuICAgICAgICAgICAgaWYgKCgwIDw9IHRoaXMudW5pb24uc3BhbilcbiAgICAgICAgICAgICAgICAmJiAoc3BhbiA+IHRoaXMudW5pb24uc3BhbikpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2VuY29kZWQgdmFyaWFudCBvdmVycnVucyBjb250YWluaW5nIHVuaW9uJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHNwYW47XG4gICAgfVxuICAgIC8qKiBEZWxlZ2F0ZSB7QGxpbmsgTGF5b3V0I2Zyb21BcnJheXxmcm9tQXJyYXl9IHRvIHtAbGlua1xuICAgICAqIFZhcmlhbnRMYXlvdXQjbGF5b3V0fGxheW91dH0uICovXG4gICAgZnJvbUFycmF5KHZhbHVlcykge1xuICAgICAgICBpZiAodGhpcy5sYXlvdXQpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmxheW91dC5mcm9tQXJyYXkodmFsdWVzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbn1cbmV4cG9ydHMuVmFyaWFudExheW91dCA9IFZhcmlhbnRMYXlvdXQ7XG4vKiogSmF2YVNjcmlwdCBjaG9zZSB0byBkZWZpbmUgYml0d2lzZSBvcGVyYXRpb25zIGFzIG9wZXJhdGluZyBvblxuICogc2lnbmVkIDMyLWJpdCB2YWx1ZXMgaW4gMidzIGNvbXBsZW1lbnQgZm9ybSwgbWVhbmluZyBhbnkgaW50ZWdlclxuICogd2l0aCBiaXQgMzEgc2V0IGlzIGdvaW5nIHRvIGxvb2sgbmVnYXRpdmUuICBGb3IgcmlnaHQgc2hpZnRzIHRoYXQnc1xuICogbm90IGEgcHJvYmxlbSwgYmVjYXVzZSBgPj4+YCBpcyBhIGxvZ2ljYWwgc2hpZnQsIGJ1dCBmb3IgZXZlcnlcbiAqIG90aGVyIGJpdHdpc2Ugb3BlcmF0b3Igd2UgaGF2ZSB0byBjb21wZW5zYXRlIGZvciBwb3NzaWJsZSBuZWdhdGl2ZVxuICogcmVzdWx0cy4gKi9cbmZ1bmN0aW9uIGZpeEJpdHdpc2VSZXN1bHQodikge1xuICAgIGlmICgwID4gdikge1xuICAgICAgICB2ICs9IDB4MTAwMDAwMDAwO1xuICAgIH1cbiAgICByZXR1cm4gdjtcbn1cbi8qKlxuICogQ29udGFpbiBhIHNlcXVlbmNlIG9mIGJpdCBmaWVsZHMgYXMgYW4gdW5zaWduZWQgaW50ZWdlci5cbiAqXG4gKiAqRmFjdG9yeSo6IHtAbGluayBtb2R1bGU6TGF5b3V0LmJpdHN8Yml0c31cbiAqXG4gKiBUaGlzIGlzIGEgY29udGFpbmVyIGVsZW1lbnQ7IHdpdGhpbiBpdCB0aGVyZSBhcmUge0BsaW5rIEJpdEZpZWxkfVxuICogaW5zdGFuY2VzIHRoYXQgcHJvdmlkZSB0aGUgZXh0cmFjdGVkIHByb3BlcnRpZXMuICBUaGUgY29udGFpbmVyXG4gKiBzaW1wbHkgZGVmaW5lcyB0aGUgYWdncmVnYXRlIHJlcHJlc2VudGF0aW9uIGFuZCBpdHMgYml0IG9yZGVyaW5nLlxuICogVGhlIHJlcHJlc2VudGF0aW9uIGlzIGFuIG9iamVjdCBjb250YWluaW5nIHByb3BlcnRpZXMgd2l0aCBudW1lcmljXG4gKiBvciB7QGxpbmsgQm9vbGVhbn0gdmFsdWVzLlxuICpcbiAqIHtAbGluayBCaXRGaWVsZH1zIGFyZSBhZGRlZCB3aXRoIHRoZSB7QGxpbmtcbiAqIEJpdFN0cnVjdHVyZSNhZGRGaWVsZHxhZGRGaWVsZH0gYW5kIHtAbGlua1xuICogQml0U3RydWN0dXJlI2FkZEJvb2xlYW58YWRkQm9vbGVhbn0gbWV0aG9kcy5cblxuICogQHBhcmFtIHtMYXlvdXR9IHdvcmQgLSBpbml0aWFsaXplciBmb3Ige0BsaW5rXG4gKiBCaXRTdHJ1Y3R1cmUjd29yZHx3b3JkfS4gIFRoZSBwYXJhbWV0ZXIgbXVzdCBiZSBhbiBpbnN0YW5jZSBvZlxuICoge0BsaW5rIFVJbnR9IChvciB7QGxpbmsgVUludEJFfSkgdGhhdCBpcyBubyBtb3JlIHRoYW4gNCBieXRlcyB3aWRlLlxuICpcbiAqIEBwYXJhbSB7Ym9vbH0gW21zYl0gLSBgdHJ1ZWAgaWYgdGhlIGJpdCBudW1iZXJpbmcgc3RhcnRzIGF0IHRoZVxuICogbW9zdCBzaWduaWZpY2FudCBiaXQgb2YgdGhlIGNvbnRhaW5pbmcgd29yZDsgYGZhbHNlYCAoZGVmYXVsdCkgaWZcbiAqIGl0IHN0YXJ0cyBhdCB0aGUgbGVhc3Qgc2lnbmlmaWNhbnQgYml0IG9mIHRoZSBjb250YWluaW5nIHdvcmQuICBJZlxuICogdGhlIHBhcmFtZXRlciBhdCB0aGlzIHBvc2l0aW9uIGlzIGEgc3RyaW5nIGFuZCBgcHJvcGVydHlgIGlzXG4gKiBgdW5kZWZpbmVkYCB0aGUgdmFsdWUgb2YgdGhpcyBhcmd1bWVudCB3aWxsIGluc3RlYWQgYmUgdXNlZCBhcyB0aGVcbiAqIHZhbHVlIG9mIGBwcm9wZXJ0eWAuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IFtwcm9wZXJ0eV0gLSBpbml0aWFsaXplciBmb3Ige0BsaW5rXG4gKiBMYXlvdXQjcHJvcGVydHl8cHJvcGVydHl9LlxuICpcbiAqIEBhdWdtZW50cyB7TGF5b3V0fVxuICovXG5jbGFzcyBCaXRTdHJ1Y3R1cmUgZXh0ZW5kcyBMYXlvdXQge1xuICAgIGNvbnN0cnVjdG9yKHdvcmQsIG1zYiwgcHJvcGVydHkpIHtcbiAgICAgICAgaWYgKCEoKHdvcmQgaW5zdGFuY2VvZiBVSW50KVxuICAgICAgICAgICAgfHwgKHdvcmQgaW5zdGFuY2VvZiBVSW50QkUpKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignd29yZCBtdXN0IGJlIGEgVUludCBvciBVSW50QkUgbGF5b3V0Jyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCgnc3RyaW5nJyA9PT0gdHlwZW9mIG1zYilcbiAgICAgICAgICAgICYmICh1bmRlZmluZWQgPT09IHByb3BlcnR5KSkge1xuICAgICAgICAgICAgcHJvcGVydHkgPSBtc2I7XG4gICAgICAgICAgICBtc2IgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoNCA8IHdvcmQuc3Bhbikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ3dvcmQgY2Fubm90IGV4Y2VlZCAzMiBiaXRzJyk7XG4gICAgICAgIH1cbiAgICAgICAgc3VwZXIod29yZC5zcGFuLCBwcm9wZXJ0eSk7XG4gICAgICAgIC8qKiBUaGUgbGF5b3V0IHVzZWQgZm9yIHRoZSBwYWNrZWQgdmFsdWUuICB7QGxpbmsgQml0RmllbGR9XG4gICAgICAgICAqIGluc3RhbmNlcyBhcmUgcGFja2VkIHNlcXVlbnRpYWxseSBkZXBlbmRpbmcgb24ge0BsaW5rXG4gICAgICAgICAqIEJpdFN0cnVjdHVyZSNtc2J8bXNifS4gKi9cbiAgICAgICAgdGhpcy53b3JkID0gd29yZDtcbiAgICAgICAgLyoqIFdoZXRoZXIgdGhlIGJpdCBzZXF1ZW5jZXMgYXJlIHBhY2tlZCBzdGFydGluZyBhdCB0aGUgbW9zdFxuICAgICAgICAgKiBzaWduaWZpY2FudCBiaXQgZ3Jvd2luZyBkb3duIChgdHJ1ZWApLCBvciB0aGUgbGVhc3Qgc2lnbmlmaWNhbnRcbiAgICAgICAgICogYml0IGdyb3dpbmcgdXAgKGBmYWxzZWApLlxuICAgICAgICAgKlxuICAgICAgICAgKiAqKk5PVEUqKiBSZWdhcmRsZXNzIG9mIHRoaXMgdmFsdWUsIHRoZSBsZWFzdCBzaWduaWZpY2FudCBiaXQgb2ZcbiAgICAgICAgICogYW55IHtAbGluayBCaXRGaWVsZH0gdmFsdWUgaXMgdGhlIGxlYXN0IHNpZ25pZmljYW50IGJpdCBvZiB0aGVcbiAgICAgICAgICogY29ycmVzcG9uZGluZyBzZWN0aW9uIG9mIHRoZSBwYWNrZWQgdmFsdWUuICovXG4gICAgICAgIHRoaXMubXNiID0gISFtc2I7XG4gICAgICAgIC8qKiBUaGUgc2VxdWVuY2Ugb2Yge0BsaW5rIEJpdEZpZWxkfSBsYXlvdXRzIHRoYXQgY29tcHJpc2UgdGhlXG4gICAgICAgICAqIHBhY2tlZCBzdHJ1Y3R1cmUuXG4gICAgICAgICAqXG4gICAgICAgICAqICoqTk9URSoqIFRoZSBhcnJheSByZW1haW5zIG11dGFibGUgdG8gYWxsb3cgZmllbGRzIHRvIGJlIHtAbGlua1xuICAgICAgICAgKiBCaXRTdHJ1Y3R1cmUjYWRkRmllbGR8YWRkZWR9IGFmdGVyIGNvbnN0cnVjdGlvbi4gIFVzZXJzIHNob3VsZFxuICAgICAgICAgKiBub3QgbWFuaXB1bGF0ZSB0aGUgY29udGVudCBvZiB0aGlzIHByb3BlcnR5LiovXG4gICAgICAgIHRoaXMuZmllbGRzID0gW107XG4gICAgICAgIC8qIFN0b3JhZ2UgZm9yIHRoZSB2YWx1ZS4gIENhcHR1cmUgYSB2YXJpYWJsZSBpbnN0ZWFkIG9mIHVzaW5nIGFuXG4gICAgICAgICAqIGluc3RhbmNlIHByb3BlcnR5IGJlY2F1c2Ugd2UgZG9uJ3Qgd2FudCBhbnl0aGluZyB0byBjaGFuZ2UgdGhlXG4gICAgICAgICAqIHZhbHVlIHdpdGhvdXQgZ29pbmcgdGhyb3VnaCB0aGUgbXV0YXRvci4gKi9cbiAgICAgICAgbGV0IHZhbHVlID0gMDtcbiAgICAgICAgdGhpcy5fcGFja2VkU2V0VmFsdWUgPSBmdW5jdGlvbiAodikge1xuICAgICAgICAgICAgdmFsdWUgPSBmaXhCaXR3aXNlUmVzdWx0KHYpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuX3BhY2tlZEdldFZhbHVlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICB9O1xuICAgIH1cbiAgICAvKiogQG92ZXJyaWRlICovXG4gICAgZGVjb2RlKGIsIG9mZnNldCA9IDApIHtcbiAgICAgICAgY29uc3QgZGVzdCA9IHRoaXMubWFrZURlc3RpbmF0aW9uT2JqZWN0KCk7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gdGhpcy53b3JkLmRlY29kZShiLCBvZmZzZXQpO1xuICAgICAgICB0aGlzLl9wYWNrZWRTZXRWYWx1ZSh2YWx1ZSk7XG4gICAgICAgIGZvciAoY29uc3QgZmQgb2YgdGhpcy5maWVsZHMpIHtcbiAgICAgICAgICAgIGlmICh1bmRlZmluZWQgIT09IGZkLnByb3BlcnR5KSB7XG4gICAgICAgICAgICAgICAgZGVzdFtmZC5wcm9wZXJ0eV0gPSBmZC5kZWNvZGUoYik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGRlc3Q7XG4gICAgfVxuICAgIC8qKiBJbXBsZW1lbnQge0BsaW5rIExheW91dCNlbmNvZGV8ZW5jb2RlfSBmb3Ige0BsaW5rIEJpdFN0cnVjdHVyZX0uXG4gICAgICpcbiAgICAgKiBJZiBgc3JjYCBpcyBtaXNzaW5nIGEgcHJvcGVydHkgZm9yIGEgbWVtYmVyIHdpdGggYSBkZWZpbmVkIHtAbGlua1xuICAgICAqIExheW91dCNwcm9wZXJ0eXxwcm9wZXJ0eX0gdGhlIGNvcnJlc3BvbmRpbmcgcmVnaW9uIG9mIHRoZSBwYWNrZWRcbiAgICAgKiB2YWx1ZSBpcyBsZWZ0IHVubW9kaWZpZWQuICBVbnVzZWQgYml0cyBhcmUgYWxzbyBsZWZ0IHVubW9kaWZpZWQuICovXG4gICAgZW5jb2RlKHNyYywgYiwgb2Zmc2V0ID0gMCkge1xuICAgICAgICBjb25zdCB2YWx1ZSA9IHRoaXMud29yZC5kZWNvZGUoYiwgb2Zmc2V0KTtcbiAgICAgICAgdGhpcy5fcGFja2VkU2V0VmFsdWUodmFsdWUpO1xuICAgICAgICBmb3IgKGNvbnN0IGZkIG9mIHRoaXMuZmllbGRzKSB7XG4gICAgICAgICAgICBpZiAodW5kZWZpbmVkICE9PSBmZC5wcm9wZXJ0eSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGZ2ID0gc3JjW2ZkLnByb3BlcnR5XTtcbiAgICAgICAgICAgICAgICBpZiAodW5kZWZpbmVkICE9PSBmdikge1xuICAgICAgICAgICAgICAgICAgICBmZC5lbmNvZGUoZnYpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy53b3JkLmVuY29kZSh0aGlzLl9wYWNrZWRHZXRWYWx1ZSgpLCBiLCBvZmZzZXQpO1xuICAgIH1cbiAgICAvKiogUmVnaXN0ZXIgYSBuZXcgYml0ZmllbGQgd2l0aCBhIGNvbnRhaW5pbmcgYml0IHN0cnVjdHVyZS4gIFRoZVxuICAgICAqIHJlc3VsdGluZyBiaXRmaWVsZCBpcyByZXR1cm5lZC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBiaXRzIC0gaW5pdGlhbGl6ZXIgZm9yIHtAbGluayBCaXRGaWVsZCNiaXRzfGJpdHN9LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHByb3BlcnR5IC0gaW5pdGlhbGl6ZXIgZm9yIHtAbGlua1xuICAgICAqIExheW91dCNwcm9wZXJ0eXxwcm9wZXJ0eX0uXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHtCaXRGaWVsZH0gKi9cbiAgICBhZGRGaWVsZChiaXRzLCBwcm9wZXJ0eSkge1xuICAgICAgICBjb25zdCBiZiA9IG5ldyBCaXRGaWVsZCh0aGlzLCBiaXRzLCBwcm9wZXJ0eSk7XG4gICAgICAgIHRoaXMuZmllbGRzLnB1c2goYmYpO1xuICAgICAgICByZXR1cm4gYmY7XG4gICAgfVxuICAgIC8qKiBBcyB3aXRoIHtAbGluayBCaXRTdHJ1Y3R1cmUjYWRkRmllbGR8YWRkRmllbGR9IGZvciBzaW5nbGUtYml0XG4gICAgICogZmllbGRzIHdpdGggYGJvb2xlYW5gIHZhbHVlIHJlcHJlc2VudGF0aW9uLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHByb3BlcnR5IC0gaW5pdGlhbGl6ZXIgZm9yIHtAbGlua1xuICAgICAqIExheW91dCNwcm9wZXJ0eXxwcm9wZXJ0eX0uXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHtCb29sZWFufSAqL1xuICAgIC8vIGBCb29sZWFuYCBjb25mbGljdHMgd2l0aCB0aGUgbmF0aXZlIHByaW1pdGl2ZSB0eXBlXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9iYW4tdHlwZXNcbiAgICBhZGRCb29sZWFuKHByb3BlcnR5KSB7XG4gICAgICAgIC8vIFRoaXMgaXMgbXkgQm9vbGVhbiwgbm90IHRoZSBKYXZhc2NyaXB0IG9uZS5cbiAgICAgICAgY29uc3QgYmYgPSBuZXcgQm9vbGVhbih0aGlzLCBwcm9wZXJ0eSk7XG4gICAgICAgIHRoaXMuZmllbGRzLnB1c2goYmYpO1xuICAgICAgICByZXR1cm4gYmY7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCBhY2Nlc3MgdG8gdGhlIGJpdCBmaWVsZCBmb3IgYSBnaXZlbiBwcm9wZXJ0eS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBwcm9wZXJ0eSAtIHRoZSBiaXQgZmllbGQgb2YgaW50ZXJlc3QuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHtCaXRGaWVsZH0gLSB0aGUgZmllbGQgYXNzb2NpYXRlZCB3aXRoIGBwcm9wZXJ0eWAsIG9yXG4gICAgICogdW5kZWZpbmVkIGlmIHRoZXJlIGlzIG5vIHN1Y2ggcHJvcGVydHkuXG4gICAgICovXG4gICAgZmllbGRGb3IocHJvcGVydHkpIHtcbiAgICAgICAgaWYgKCdzdHJpbmcnICE9PSB0eXBlb2YgcHJvcGVydHkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ3Byb3BlcnR5IG11c3QgYmUgc3RyaW5nJyk7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChjb25zdCBmZCBvZiB0aGlzLmZpZWxkcykge1xuICAgICAgICAgICAgaWYgKGZkLnByb3BlcnR5ID09PSBwcm9wZXJ0eSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbn1cbmV4cG9ydHMuQml0U3RydWN0dXJlID0gQml0U3RydWN0dXJlO1xuLyoqXG4gKiBSZXByZXNlbnQgYSBzZXF1ZW5jZSBvZiBiaXRzIHdpdGhpbiBhIHtAbGluayBCaXRTdHJ1Y3R1cmV9LlxuICpcbiAqIEFsbCBiaXQgZmllbGQgdmFsdWVzIGFyZSByZXByZXNlbnRlZCBhcyB1bnNpZ25lZCBpbnRlZ2Vycy5cbiAqXG4gKiAqKk5PVEUqKiBVc2VyIGNvZGUgc2hvdWxkIG5vdCBpbnZva2UgdGhpcyBjb25zdHJ1Y3RvciBkaXJlY3RseS5cbiAqIFVzZSB0aGUgY29udGFpbmVyIHtAbGluayBCaXRTdHJ1Y3R1cmUjYWRkRmllbGR8YWRkRmllbGR9IGhlbHBlclxuICogbWV0aG9kLlxuICpcbiAqICoqTk9URSoqIEJpdEZpZWxkIGluc3RhbmNlcyBhcmUgbm90IGluc3RhbmNlcyBvZiB7QGxpbmsgTGF5b3V0fVxuICogc2luY2Uge0BsaW5rIExheW91dCNzcGFufHNwYW59IG1lYXN1cmVzIDgtYml0IHVuaXRzLlxuICpcbiAqIEBwYXJhbSB7Qml0U3RydWN0dXJlfSBjb250YWluZXIgLSBpbml0aWFsaXplciBmb3Ige0BsaW5rXG4gKiBCaXRGaWVsZCNjb250YWluZXJ8Y29udGFpbmVyfS5cbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gYml0cyAtIGluaXRpYWxpemVyIGZvciB7QGxpbmsgQml0RmllbGQjYml0c3xiaXRzfS5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gW3Byb3BlcnR5XSAtIGluaXRpYWxpemVyIGZvciB7QGxpbmtcbiAqIExheW91dCNwcm9wZXJ0eXxwcm9wZXJ0eX0uXG4gKi9cbmNsYXNzIEJpdEZpZWxkIHtcbiAgICBjb25zdHJ1Y3Rvcihjb250YWluZXIsIGJpdHMsIHByb3BlcnR5KSB7XG4gICAgICAgIGlmICghKGNvbnRhaW5lciBpbnN0YW5jZW9mIEJpdFN0cnVjdHVyZSkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2NvbnRhaW5lciBtdXN0IGJlIGEgQml0U3RydWN0dXJlJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCghTnVtYmVyLmlzSW50ZWdlcihiaXRzKSkgfHwgKDAgPj0gYml0cykpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2JpdHMgbXVzdCBiZSBwb3NpdGl2ZSBpbnRlZ2VyJyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdG90YWxCaXRzID0gOCAqIGNvbnRhaW5lci5zcGFuO1xuICAgICAgICBjb25zdCB1c2VkQml0cyA9IGNvbnRhaW5lci5maWVsZHMucmVkdWNlKChzdW0sIGZkKSA9PiBzdW0gKyBmZC5iaXRzLCAwKTtcbiAgICAgICAgaWYgKChiaXRzICsgdXNlZEJpdHMpID4gdG90YWxCaXRzKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2JpdHMgdG9vIGxvbmcgZm9yIHNwYW4gcmVtYWluZGVyICgnXG4gICAgICAgICAgICAgICAgKyAodG90YWxCaXRzIC0gdXNlZEJpdHMpICsgJyBvZiAnXG4gICAgICAgICAgICAgICAgKyB0b3RhbEJpdHMgKyAnIHJlbWFpbiknKTtcbiAgICAgICAgfVxuICAgICAgICAvKiogVGhlIHtAbGluayBCaXRTdHJ1Y3R1cmV9IGluc3RhbmNlIHRvIHdoaWNoIHRoaXMgYml0IGZpZWxkXG4gICAgICAgICAqIGJlbG9uZ3MuICovXG4gICAgICAgIHRoaXMuY29udGFpbmVyID0gY29udGFpbmVyO1xuICAgICAgICAvKiogVGhlIHNwYW4gb2YgdGhpcyB2YWx1ZSBpbiBiaXRzLiAqL1xuICAgICAgICB0aGlzLmJpdHMgPSBiaXRzO1xuICAgICAgICAvKiogQSBtYXNrIG9mIHtAbGluayBCaXRGaWVsZCNiaXRzfGJpdHN9IGJpdHMgaXNvbGF0aW5nIHZhbHVlIGJpdHNcbiAgICAgICAgICogdGhhdCBmaXQgd2l0aGluIHRoZSBmaWVsZC5cbiAgICAgICAgICpcbiAgICAgICAgICogVGhhdCBpcywgaXQgbWFza3MgYSB2YWx1ZSB0aGF0IGhhcyBub3QgeWV0IGJlZW4gc2hpZnRlZCBpbnRvXG4gICAgICAgICAqIHBvc2l0aW9uIHdpdGhpbiBpdHMgY29udGFpbmluZyBwYWNrZWQgaW50ZWdlci4gKi9cbiAgICAgICAgdGhpcy52YWx1ZU1hc2sgPSAoMSA8PCBiaXRzKSAtIDE7XG4gICAgICAgIGlmICgzMiA9PT0gYml0cykgeyAvLyBzaGlmdGVkIHZhbHVlIG91dCBvZiByYW5nZVxuICAgICAgICAgICAgdGhpcy52YWx1ZU1hc2sgPSAweEZGRkZGRkZGO1xuICAgICAgICB9XG4gICAgICAgIC8qKiBUaGUgb2Zmc2V0IG9mIHRoZSB2YWx1ZSB3aXRoaW4gdGhlIGNvbnRhaW5pbmcgcGFja2VkIHVuc2lnbmVkXG4gICAgICAgICAqIGludGVnZXIuICBUaGUgbGVhc3Qgc2lnbmlmaWNhbnQgYml0IG9mIHRoZSBwYWNrZWQgdmFsdWUgaXMgYXRcbiAgICAgICAgICogb2Zmc2V0IHplcm8sIHJlZ2FyZGxlc3Mgb2YgYml0IG9yZGVyaW5nIHVzZWQuICovXG4gICAgICAgIHRoaXMuc3RhcnQgPSB1c2VkQml0cztcbiAgICAgICAgaWYgKHRoaXMuY29udGFpbmVyLm1zYikge1xuICAgICAgICAgICAgdGhpcy5zdGFydCA9IHRvdGFsQml0cyAtIHVzZWRCaXRzIC0gYml0cztcbiAgICAgICAgfVxuICAgICAgICAvKiogQSBtYXNrIG9mIHtAbGluayBCaXRGaWVsZCNiaXRzfGJpdHN9IGlzb2xhdGluZyB0aGUgZmllbGQgdmFsdWVcbiAgICAgICAgICogd2l0aGluIHRoZSBjb250YWluaW5nIHBhY2tlZCB1bnNpZ25lZCBpbnRlZ2VyLiAqL1xuICAgICAgICB0aGlzLndvcmRNYXNrID0gZml4Qml0d2lzZVJlc3VsdCh0aGlzLnZhbHVlTWFzayA8PCB0aGlzLnN0YXJ0KTtcbiAgICAgICAgLyoqIFRoZSBwcm9wZXJ0eSBuYW1lIHVzZWQgd2hlbiB0aGlzIGJpdGZpZWxkIGlzIHJlcHJlc2VudGVkIGluIGFuXG4gICAgICAgICAqIE9iamVjdC5cbiAgICAgICAgICpcbiAgICAgICAgICogSW50ZW5kZWQgdG8gYmUgZnVuY3Rpb25hbGx5IGVxdWl2YWxlbnQgdG8ge0BsaW5rXG4gICAgICAgICAqIExheW91dCNwcm9wZXJ0eX0uXG4gICAgICAgICAqXG4gICAgICAgICAqIElmIGxlZnQgdW5kZWZpbmVkIHRoZSBjb3JyZXNwb25kaW5nIHNwYW4gb2YgYml0cyB3aWxsIGJlXG4gICAgICAgICAqIHRyZWF0ZWQgYXMgcGFkZGluZzogaXQgd2lsbCBub3QgYmUgbXV0YXRlZCBieSB7QGxpbmtcbiAgICAgICAgICogTGF5b3V0I2VuY29kZXxlbmNvZGV9IG5vciByZXByZXNlbnRlZCBhcyBhIHByb3BlcnR5IGluIHRoZVxuICAgICAgICAgKiBkZWNvZGVkIE9iamVjdC4gKi9cbiAgICAgICAgdGhpcy5wcm9wZXJ0eSA9IHByb3BlcnR5O1xuICAgIH1cbiAgICAvKiogU3RvcmUgYSB2YWx1ZSBpbnRvIHRoZSBjb3JyZXNwb25kaW5nIHN1YnNlcXVlbmNlIG9mIHRoZSBjb250YWluaW5nXG4gICAgICogYml0IGZpZWxkLiAqL1xuICAgIGRlY29kZShiLCBvZmZzZXQpIHtcbiAgICAgICAgY29uc3Qgd29yZCA9IHRoaXMuY29udGFpbmVyLl9wYWNrZWRHZXRWYWx1ZSgpO1xuICAgICAgICBjb25zdCB3b3JkVmFsdWUgPSBmaXhCaXR3aXNlUmVzdWx0KHdvcmQgJiB0aGlzLndvcmRNYXNrKTtcbiAgICAgICAgY29uc3QgdmFsdWUgPSB3b3JkVmFsdWUgPj4+IHRoaXMuc3RhcnQ7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG4gICAgLyoqIFN0b3JlIGEgdmFsdWUgaW50byB0aGUgY29ycmVzcG9uZGluZyBzdWJzZXF1ZW5jZSBvZiB0aGUgY29udGFpbmluZ1xuICAgICAqIGJpdCBmaWVsZC5cbiAgICAgKlxuICAgICAqICoqTk9URSoqIFRoaXMgaXMgbm90IGEgc3BlY2lhbGl6YXRpb24gb2Yge0BsaW5rXG4gICAgICogTGF5b3V0I2VuY29kZXxMYXlvdXQuZW5jb2RlfSBhbmQgdGhlcmUgaXMgbm8gcmV0dXJuIHZhbHVlLiAqL1xuICAgIGVuY29kZSh2YWx1ZSkge1xuICAgICAgICBpZiAoJ251bWJlcicgIT09IHR5cGVvZiB2YWx1ZVxuICAgICAgICAgICAgfHwgIU51bWJlci5pc0ludGVnZXIodmFsdWUpXG4gICAgICAgICAgICB8fCAodmFsdWUgIT09IGZpeEJpdHdpc2VSZXN1bHQodmFsdWUgJiB0aGlzLnZhbHVlTWFzaykpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKG5hbWVXaXRoUHJvcGVydHkoJ0JpdEZpZWxkLmVuY29kZScsIHRoaXMpXG4gICAgICAgICAgICAgICAgKyAnIHZhbHVlIG11c3QgYmUgaW50ZWdlciBub3QgZXhjZWVkaW5nICcgKyB0aGlzLnZhbHVlTWFzayk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgd29yZCA9IHRoaXMuY29udGFpbmVyLl9wYWNrZWRHZXRWYWx1ZSgpO1xuICAgICAgICBjb25zdCB3b3JkVmFsdWUgPSBmaXhCaXR3aXNlUmVzdWx0KHZhbHVlIDw8IHRoaXMuc3RhcnQpO1xuICAgICAgICB0aGlzLmNvbnRhaW5lci5fcGFja2VkU2V0VmFsdWUoZml4Qml0d2lzZVJlc3VsdCh3b3JkICYgfnRoaXMud29yZE1hc2spXG4gICAgICAgICAgICB8IHdvcmRWYWx1ZSk7XG4gICAgfVxufVxuZXhwb3J0cy5CaXRGaWVsZCA9IEJpdEZpZWxkO1xuLyoqXG4gKiBSZXByZXNlbnQgYSBzaW5nbGUgYml0IHdpdGhpbiBhIHtAbGluayBCaXRTdHJ1Y3R1cmV9IGFzIGFcbiAqIEphdmFTY3JpcHQgYm9vbGVhbi5cbiAqXG4gKiAqKk5PVEUqKiBVc2VyIGNvZGUgc2hvdWxkIG5vdCBpbnZva2UgdGhpcyBjb25zdHJ1Y3RvciBkaXJlY3RseS5cbiAqIFVzZSB0aGUgY29udGFpbmVyIHtAbGluayBCaXRTdHJ1Y3R1cmUjYWRkQm9vbGVhbnxhZGRCb29sZWFufSBoZWxwZXJcbiAqIG1ldGhvZC5cbiAqXG4gKiBAcGFyYW0ge0JpdFN0cnVjdHVyZX0gY29udGFpbmVyIC0gaW5pdGlhbGl6ZXIgZm9yIHtAbGlua1xuICogQml0RmllbGQjY29udGFpbmVyfGNvbnRhaW5lcn0uXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IFtwcm9wZXJ0eV0gLSBpbml0aWFsaXplciBmb3Ige0BsaW5rXG4gKiBMYXlvdXQjcHJvcGVydHl8cHJvcGVydHl9LlxuICpcbiAqIEBhdWdtZW50cyB7Qml0RmllbGR9XG4gKi9cbi8qIGVzbGludC1kaXNhYmxlIG5vLWV4dGVuZC1uYXRpdmUgKi9cbmNsYXNzIEJvb2xlYW4gZXh0ZW5kcyBCaXRGaWVsZCB7XG4gICAgY29uc3RydWN0b3IoY29udGFpbmVyLCBwcm9wZXJ0eSkge1xuICAgICAgICBzdXBlcihjb250YWluZXIsIDEsIHByb3BlcnR5KTtcbiAgICB9XG4gICAgLyoqIE92ZXJyaWRlIHtAbGluayBCaXRGaWVsZCNkZWNvZGV8ZGVjb2RlfSBmb3Ige0BsaW5rIEJvb2xlYW58Qm9vbGVhbn0uXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gKi9cbiAgICBkZWNvZGUoYiwgb2Zmc2V0KSB7XG4gICAgICAgIHJldHVybiAhIXN1cGVyLmRlY29kZShiLCBvZmZzZXQpO1xuICAgIH1cbiAgICAvKiogQG92ZXJyaWRlICovXG4gICAgZW5jb2RlKHZhbHVlKSB7XG4gICAgICAgIGlmICgnYm9vbGVhbicgPT09IHR5cGVvZiB2YWx1ZSkge1xuICAgICAgICAgICAgLy8gQml0RmllbGQgcmVxdWlyZXMgaW50ZWdlciB2YWx1ZXNcbiAgICAgICAgICAgIHZhbHVlID0gK3ZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIHN1cGVyLmVuY29kZSh2YWx1ZSk7XG4gICAgfVxufVxuZXhwb3J0cy5Cb29sZWFuID0gQm9vbGVhbjtcbi8qIGVzbGludC1lbmFibGUgbm8tZXh0ZW5kLW5hdGl2ZSAqL1xuLyoqXG4gKiBDb250YWluIGEgZml4ZWQtbGVuZ3RoIGJsb2NrIG9mIGFyYml0cmFyeSBkYXRhLCByZXByZXNlbnRlZCBhcyBhXG4gKiBVaW50OEFycmF5LlxuICpcbiAqICpGYWN0b3J5Kjoge0BsaW5rIG1vZHVsZTpMYXlvdXQuYmxvYnxibG9ifVxuICpcbiAqIEBwYXJhbSB7KE51bWJlcnxFeHRlcm5hbExheW91dCl9IGxlbmd0aCAtIGluaXRpYWxpemVzIHtAbGlua1xuICogQmxvYiNsZW5ndGh8bGVuZ3RofS5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gW3Byb3BlcnR5XSAtIGluaXRpYWxpemVyIGZvciB7QGxpbmtcbiAqIExheW91dCNwcm9wZXJ0eXxwcm9wZXJ0eX0uXG4gKlxuICogQGF1Z21lbnRzIHtMYXlvdXR9XG4gKi9cbmNsYXNzIEJsb2IgZXh0ZW5kcyBMYXlvdXQge1xuICAgIGNvbnN0cnVjdG9yKGxlbmd0aCwgcHJvcGVydHkpIHtcbiAgICAgICAgaWYgKCEoKChsZW5ndGggaW5zdGFuY2VvZiBFeHRlcm5hbExheW91dCkgJiYgbGVuZ3RoLmlzQ291bnQoKSlcbiAgICAgICAgICAgIHx8IChOdW1iZXIuaXNJbnRlZ2VyKGxlbmd0aCkgJiYgKDAgPD0gbGVuZ3RoKSkpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdsZW5ndGggbXVzdCBiZSBwb3NpdGl2ZSBpbnRlZ2VyICdcbiAgICAgICAgICAgICAgICArICdvciBhbiB1bnNpZ25lZCBpbnRlZ2VyIEV4dGVybmFsTGF5b3V0Jyk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHNwYW4gPSAtMTtcbiAgICAgICAgaWYgKCEobGVuZ3RoIGluc3RhbmNlb2YgRXh0ZXJuYWxMYXlvdXQpKSB7XG4gICAgICAgICAgICBzcGFuID0gbGVuZ3RoO1xuICAgICAgICB9XG4gICAgICAgIHN1cGVyKHNwYW4sIHByb3BlcnR5KTtcbiAgICAgICAgLyoqIFRoZSBudW1iZXIgb2YgYnl0ZXMgaW4gdGhlIGJsb2IuXG4gICAgICAgICAqXG4gICAgICAgICAqIFRoaXMgbWF5IGJlIGEgbm9uLW5lZ2F0aXZlIGludGVnZXIsIG9yIGFuIGluc3RhbmNlIG9mIHtAbGlua1xuICAgICAgICAgKiBFeHRlcm5hbExheW91dH0gdGhhdCBzYXRpc2ZpZXMge0BsaW5rXG4gICAgICAgICAqIEV4dGVybmFsTGF5b3V0I2lzQ291bnR8aXNDb3VudCgpfS4gKi9cbiAgICAgICAgdGhpcy5sZW5ndGggPSBsZW5ndGg7XG4gICAgfVxuICAgIC8qKiBAb3ZlcnJpZGUgKi9cbiAgICBnZXRTcGFuKGIsIG9mZnNldCkge1xuICAgICAgICBsZXQgc3BhbiA9IHRoaXMuc3BhbjtcbiAgICAgICAgaWYgKDAgPiBzcGFuKSB7XG4gICAgICAgICAgICBzcGFuID0gdGhpcy5sZW5ndGguZGVjb2RlKGIsIG9mZnNldCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHNwYW47XG4gICAgfVxuICAgIC8qKiBAb3ZlcnJpZGUgKi9cbiAgICBkZWNvZGUoYiwgb2Zmc2V0ID0gMCkge1xuICAgICAgICBsZXQgc3BhbiA9IHRoaXMuc3BhbjtcbiAgICAgICAgaWYgKDAgPiBzcGFuKSB7XG4gICAgICAgICAgICBzcGFuID0gdGhpcy5sZW5ndGguZGVjb2RlKGIsIG9mZnNldCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHVpbnQ4QXJyYXlUb0J1ZmZlcihiKS5zbGljZShvZmZzZXQsIG9mZnNldCArIHNwYW4pO1xuICAgIH1cbiAgICAvKiogSW1wbGVtZW50IHtAbGluayBMYXlvdXQjZW5jb2RlfGVuY29kZX0gZm9yIHtAbGluayBCbG9ifS5cbiAgICAgKlxuICAgICAqICoqTk9URSoqIElmIHtAbGluayBMYXlvdXQjY291bnR8Y291bnR9IGlzIGFuIGluc3RhbmNlIG9mIHtAbGlua1xuICAgICAqIEV4dGVybmFsTGF5b3V0fSB0aGVuIHRoZSBsZW5ndGggb2YgYHNyY2Agd2lsbCBiZSBlbmNvZGVkIGFzIHRoZVxuICAgICAqIGNvdW50IGFmdGVyIGBzcmNgIGlzIGVuY29kZWQuICovXG4gICAgZW5jb2RlKHNyYywgYiwgb2Zmc2V0KSB7XG4gICAgICAgIGxldCBzcGFuID0gdGhpcy5sZW5ndGg7XG4gICAgICAgIGlmICh0aGlzLmxlbmd0aCBpbnN0YW5jZW9mIEV4dGVybmFsTGF5b3V0KSB7XG4gICAgICAgICAgICBzcGFuID0gc3JjLmxlbmd0aDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIShzcmMgaW5zdGFuY2VvZiBVaW50OEFycmF5ICYmIHNwYW4gPT09IHNyYy5sZW5ndGgpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKG5hbWVXaXRoUHJvcGVydHkoJ0Jsb2IuZW5jb2RlJywgdGhpcylcbiAgICAgICAgICAgICAgICArICcgcmVxdWlyZXMgKGxlbmd0aCAnICsgc3BhbiArICcpIFVpbnQ4QXJyYXkgYXMgc3JjJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKChvZmZzZXQgKyBzcGFuKSA+IGIubGVuZ3RoKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignZW5jb2Rpbmcgb3ZlcnJ1bnMgVWludDhBcnJheScpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHNyY0J1ZmZlciA9IHVpbnQ4QXJyYXlUb0J1ZmZlcihzcmMpO1xuICAgICAgICB1aW50OEFycmF5VG9CdWZmZXIoYikud3JpdGUoc3JjQnVmZmVyLnRvU3RyaW5nKCdoZXgnKSwgb2Zmc2V0LCBzcGFuLCAnaGV4Jyk7XG4gICAgICAgIGlmICh0aGlzLmxlbmd0aCBpbnN0YW5jZW9mIEV4dGVybmFsTGF5b3V0KSB7XG4gICAgICAgICAgICB0aGlzLmxlbmd0aC5lbmNvZGUoc3BhbiwgYiwgb2Zmc2V0KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3BhbjtcbiAgICB9XG59XG5leHBvcnRzLkJsb2IgPSBCbG9iO1xuLyoqXG4gKiBDb250YWluIGEgYE5VTGAtdGVybWluYXRlZCBVVEY4IHN0cmluZy5cbiAqXG4gKiAqRmFjdG9yeSo6IHtAbGluayBtb2R1bGU6TGF5b3V0LmNzdHJ8Y3N0cn1cbiAqXG4gKiAqKk5PVEUqKiBBbnkgVVRGOCBzdHJpbmcgdGhhdCBpbmNvcnBvcmF0ZXMgYSB6ZXJvLXZhbHVlZCBieXRlIHdpbGxcbiAqIG5vdCBiZSBjb3JyZWN0bHkgZGVjb2RlZCBieSB0aGlzIGxheW91dC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gW3Byb3BlcnR5XSAtIGluaXRpYWxpemVyIGZvciB7QGxpbmtcbiAqIExheW91dCNwcm9wZXJ0eXxwcm9wZXJ0eX0uXG4gKlxuICogQGF1Z21lbnRzIHtMYXlvdXR9XG4gKi9cbmNsYXNzIENTdHJpbmcgZXh0ZW5kcyBMYXlvdXQge1xuICAgIGNvbnN0cnVjdG9yKHByb3BlcnR5KSB7XG4gICAgICAgIHN1cGVyKC0xLCBwcm9wZXJ0eSk7XG4gICAgfVxuICAgIC8qKiBAb3ZlcnJpZGUgKi9cbiAgICBnZXRTcGFuKGIsIG9mZnNldCA9IDApIHtcbiAgICAgICAgY2hlY2tVaW50OEFycmF5KGIpO1xuICAgICAgICBsZXQgaWR4ID0gb2Zmc2V0O1xuICAgICAgICB3aGlsZSAoKGlkeCA8IGIubGVuZ3RoKSAmJiAoMCAhPT0gYltpZHhdKSkge1xuICAgICAgICAgICAgaWR4ICs9IDE7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIDEgKyBpZHggLSBvZmZzZXQ7XG4gICAgfVxuICAgIC8qKiBAb3ZlcnJpZGUgKi9cbiAgICBkZWNvZGUoYiwgb2Zmc2V0ID0gMCkge1xuICAgICAgICBjb25zdCBzcGFuID0gdGhpcy5nZXRTcGFuKGIsIG9mZnNldCk7XG4gICAgICAgIHJldHVybiB1aW50OEFycmF5VG9CdWZmZXIoYikuc2xpY2Uob2Zmc2V0LCBvZmZzZXQgKyBzcGFuIC0gMSkudG9TdHJpbmcoJ3V0Zi04Jyk7XG4gICAgfVxuICAgIC8qKiBAb3ZlcnJpZGUgKi9cbiAgICBlbmNvZGUoc3JjLCBiLCBvZmZzZXQgPSAwKSB7XG4gICAgICAgIC8qIE11c3QgZm9yY2UgdGhpcyB0byBhIHN0cmluZywgbGVzdCBpdCBiZSBhIG51bWJlciBhbmQgdGhlXG4gICAgICAgICAqIFwidXRmOC1lbmNvZGluZ1wiIGJlbG93IGFjdHVhbGx5IGFsbG9jYXRlIGEgYnVmZmVyIG9mIGxlbmd0aFxuICAgICAgICAgKiBzcmMgKi9cbiAgICAgICAgaWYgKCdzdHJpbmcnICE9PSB0eXBlb2Ygc3JjKSB7XG4gICAgICAgICAgICBzcmMgPSBTdHJpbmcoc3JjKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzcmNiID0gYnVmZmVyXzEuQnVmZmVyLmZyb20oc3JjLCAndXRmOCcpO1xuICAgICAgICBjb25zdCBzcGFuID0gc3JjYi5sZW5ndGg7XG4gICAgICAgIGlmICgob2Zmc2V0ICsgc3BhbikgPiBiLmxlbmd0aCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ2VuY29kaW5nIG92ZXJydW5zIEJ1ZmZlcicpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGJ1ZmZlciA9IHVpbnQ4QXJyYXlUb0J1ZmZlcihiKTtcbiAgICAgICAgc3JjYi5jb3B5KGJ1ZmZlciwgb2Zmc2V0KTtcbiAgICAgICAgYnVmZmVyW29mZnNldCArIHNwYW5dID0gMDtcbiAgICAgICAgcmV0dXJuIHNwYW4gKyAxO1xuICAgIH1cbn1cbmV4cG9ydHMuQ1N0cmluZyA9IENTdHJpbmc7XG4vKipcbiAqIENvbnRhaW4gYSBVVEY4IHN0cmluZyB3aXRoIGltcGxpY2l0IGxlbmd0aC5cbiAqXG4gKiAqRmFjdG9yeSo6IHtAbGluayBtb2R1bGU6TGF5b3V0LnV0Zjh8dXRmOH1cbiAqXG4gKiAqKk5PVEUqKiBCZWNhdXNlIHRoZSBsZW5ndGggaXMgaW1wbGljaXQgaW4gdGhlIHNpemUgb2YgdGhlIGJ1ZmZlclxuICogdGhpcyBsYXlvdXQgc2hvdWxkIGJlIHVzZWQgb25seSBpbiBpc29sYXRpb24sIG9yIGluIGEgc2l0dWF0aW9uXG4gKiB3aGVyZSB0aGUgbGVuZ3RoIGNhbiBiZSBleHByZXNzZWQgYnkgb3BlcmF0aW5nIG9uIGEgc2xpY2Ugb2YgdGhlXG4gKiBjb250YWluaW5nIGJ1ZmZlci5cbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gW21heFNwYW5dIC0gdGhlIG1heGltdW0gbGVuZ3RoIGFsbG93ZWQgZm9yIGVuY29kZWRcbiAqIHN0cmluZyBjb250ZW50LiAgSWYgbm90IHByb3ZpZGVkIHRoZXJlIGlzIG5vIGJvdW5kIG9uIHRoZSBhbGxvd2VkXG4gKiBjb250ZW50LlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBbcHJvcGVydHldIC0gaW5pdGlhbGl6ZXIgZm9yIHtAbGlua1xuICogTGF5b3V0I3Byb3BlcnR5fHByb3BlcnR5fS5cbiAqXG4gKiBAYXVnbWVudHMge0xheW91dH1cbiAqL1xuY2xhc3MgVVRGOCBleHRlbmRzIExheW91dCB7XG4gICAgY29uc3RydWN0b3IobWF4U3BhbiwgcHJvcGVydHkpIHtcbiAgICAgICAgaWYgKCgnc3RyaW5nJyA9PT0gdHlwZW9mIG1heFNwYW4pICYmICh1bmRlZmluZWQgPT09IHByb3BlcnR5KSkge1xuICAgICAgICAgICAgcHJvcGVydHkgPSBtYXhTcGFuO1xuICAgICAgICAgICAgbWF4U3BhbiA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodW5kZWZpbmVkID09PSBtYXhTcGFuKSB7XG4gICAgICAgICAgICBtYXhTcGFuID0gLTE7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoIU51bWJlci5pc0ludGVnZXIobWF4U3BhbikpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ21heFNwYW4gbXVzdCBiZSBhbiBpbnRlZ2VyJyk7XG4gICAgICAgIH1cbiAgICAgICAgc3VwZXIoLTEsIHByb3BlcnR5KTtcbiAgICAgICAgLyoqIFRoZSBtYXhpbXVtIHNwYW4gb2YgdGhlIGxheW91dCBpbiBieXRlcy5cbiAgICAgICAgICpcbiAgICAgICAgICogUG9zaXRpdmUgdmFsdWVzIGFyZSBnZW5lcmFsbHkgZXhwZWN0ZWQuICBaZXJvIGlzIGFibm9ybWFsLlxuICAgICAgICAgKiBBdHRlbXB0cyB0byBlbmNvZGUgb3IgZGVjb2RlIGEgdmFsdWUgdGhhdCBleGNlZWRzIHRoaXMgbGVuZ3RoXG4gICAgICAgICAqIHdpbGwgdGhyb3cgYSBgUmFuZ2VFcnJvcmAuXG4gICAgICAgICAqXG4gICAgICAgICAqIEEgbmVnYXRpdmUgdmFsdWUgaW5kaWNhdGVzIHRoYXQgdGhlcmUgaXMgbm8gYm91bmQgb24gdGhlIGxlbmd0aFxuICAgICAgICAgKiBvZiB0aGUgY29udGVudC4gKi9cbiAgICAgICAgdGhpcy5tYXhTcGFuID0gbWF4U3BhbjtcbiAgICB9XG4gICAgLyoqIEBvdmVycmlkZSAqL1xuICAgIGdldFNwYW4oYiwgb2Zmc2V0ID0gMCkge1xuICAgICAgICBjaGVja1VpbnQ4QXJyYXkoYik7XG4gICAgICAgIHJldHVybiBiLmxlbmd0aCAtIG9mZnNldDtcbiAgICB9XG4gICAgLyoqIEBvdmVycmlkZSAqL1xuICAgIGRlY29kZShiLCBvZmZzZXQgPSAwKSB7XG4gICAgICAgIGNvbnN0IHNwYW4gPSB0aGlzLmdldFNwYW4oYiwgb2Zmc2V0KTtcbiAgICAgICAgaWYgKCgwIDw9IHRoaXMubWF4U3BhbilcbiAgICAgICAgICAgICYmICh0aGlzLm1heFNwYW4gPCBzcGFuKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ3RleHQgbGVuZ3RoIGV4Y2VlZHMgbWF4U3BhbicpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB1aW50OEFycmF5VG9CdWZmZXIoYikuc2xpY2Uob2Zmc2V0LCBvZmZzZXQgKyBzcGFuKS50b1N0cmluZygndXRmLTgnKTtcbiAgICB9XG4gICAgLyoqIEBvdmVycmlkZSAqL1xuICAgIGVuY29kZShzcmMsIGIsIG9mZnNldCA9IDApIHtcbiAgICAgICAgLyogTXVzdCBmb3JjZSB0aGlzIHRvIGEgc3RyaW5nLCBsZXN0IGl0IGJlIGEgbnVtYmVyIGFuZCB0aGVcbiAgICAgICAgICogXCJ1dGY4LWVuY29kaW5nXCIgYmVsb3cgYWN0dWFsbHkgYWxsb2NhdGUgYSBidWZmZXIgb2YgbGVuZ3RoXG4gICAgICAgICAqIHNyYyAqL1xuICAgICAgICBpZiAoJ3N0cmluZycgIT09IHR5cGVvZiBzcmMpIHtcbiAgICAgICAgICAgIHNyYyA9IFN0cmluZyhzcmMpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHNyY2IgPSBidWZmZXJfMS5CdWZmZXIuZnJvbShzcmMsICd1dGY4Jyk7XG4gICAgICAgIGNvbnN0IHNwYW4gPSBzcmNiLmxlbmd0aDtcbiAgICAgICAgaWYgKCgwIDw9IHRoaXMubWF4U3BhbilcbiAgICAgICAgICAgICYmICh0aGlzLm1heFNwYW4gPCBzcGFuKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ3RleHQgbGVuZ3RoIGV4Y2VlZHMgbWF4U3BhbicpO1xuICAgICAgICB9XG4gICAgICAgIGlmICgob2Zmc2V0ICsgc3BhbikgPiBiLmxlbmd0aCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ2VuY29kaW5nIG92ZXJydW5zIEJ1ZmZlcicpO1xuICAgICAgICB9XG4gICAgICAgIHNyY2IuY29weSh1aW50OEFycmF5VG9CdWZmZXIoYiksIG9mZnNldCk7XG4gICAgICAgIHJldHVybiBzcGFuO1xuICAgIH1cbn1cbmV4cG9ydHMuVVRGOCA9IFVURjg7XG4vKipcbiAqIENvbnRhaW4gYSBjb25zdGFudCB2YWx1ZS5cbiAqXG4gKiBUaGlzIGxheW91dCBtYXkgYmUgdXNlZCBpbiBjYXNlcyB3aGVyZSBhIEphdmFTY3JpcHQgdmFsdWUgY2FuIGJlXG4gKiBpbmZlcnJlZCB3aXRob3V0IGFuIGV4cHJlc3Npb24gaW4gdGhlIGJpbmFyeSBlbmNvZGluZy4gIEFuIGV4YW1wbGVcbiAqIHdvdWxkIGJlIGEge0BsaW5rIFZhcmlhbnRMYXlvdXR8dmFyaWFudCBsYXlvdXR9IHdoZXJlIHRoZSBjb250ZW50XG4gKiBpcyBpbXBsaWVkIGJ5IHRoZSB1bmlvbiB7QGxpbmsgVW5pb24jZGlzY3JpbWluYXRvcnxkaXNjcmltaW5hdG9yfS5cbiAqXG4gKiBAcGFyYW0ge09iamVjdHxOdW1iZXJ8U3RyaW5nfSB2YWx1ZSAtIGluaXRpYWxpemVyIGZvciB7QGxpbmtcbiAqIENvbnN0YW50I3ZhbHVlfHZhbHVlfS4gIElmIHRoZSB2YWx1ZSBpcyBhbiBvYmplY3QgKG9yIGFycmF5KSBhbmRcbiAqIHRoZSBhcHBsaWNhdGlvbiBpbnRlbmRzIHRoZSBvYmplY3QgdG8gcmVtYWluIHVuY2hhbmdlZCByZWdhcmRsZXNzXG4gKiBvZiB3aGF0IGlzIGRvbmUgdG8gdmFsdWVzIGRlY29kZWQgYnkgdGhpcyBsYXlvdXQsIHRoZSB2YWx1ZSBzaG91bGRcbiAqIGJlIGZyb3plbiBwcmlvciBwYXNzaW5nIGl0IHRvIHRoaXMgY29uc3RydWN0b3IuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IFtwcm9wZXJ0eV0gLSBpbml0aWFsaXplciBmb3Ige0BsaW5rXG4gKiBMYXlvdXQjcHJvcGVydHl8cHJvcGVydHl9LlxuICpcbiAqIEBhdWdtZW50cyB7TGF5b3V0fVxuICovXG5jbGFzcyBDb25zdGFudCBleHRlbmRzIExheW91dCB7XG4gICAgY29uc3RydWN0b3IodmFsdWUsIHByb3BlcnR5KSB7XG4gICAgICAgIHN1cGVyKDAsIHByb3BlcnR5KTtcbiAgICAgICAgLyoqIFRoZSB2YWx1ZSBwcm9kdWNlZCBieSB0aGlzIGNvbnN0YW50IHdoZW4gdGhlIGxheW91dCBpcyB7QGxpbmtcbiAgICAgICAgICogQ29uc3RhbnQjZGVjb2RlfGRlY29kZWR9LlxuICAgICAgICAgKlxuICAgICAgICAgKiBBbnkgSmF2YVNjcmlwdCB2YWx1ZSBpbmNsdWRpbmcgYG51bGxgIGFuZCBgdW5kZWZpbmVkYCBpc1xuICAgICAgICAgKiBwZXJtaXR0ZWQuXG4gICAgICAgICAqXG4gICAgICAgICAqICoqV0FSTklORyoqIElmIGB2YWx1ZWAgcGFzc2VkIGluIHRoZSBjb25zdHJ1Y3RvciB3YXMgbm90XG4gICAgICAgICAqIGZyb3plbiwgaXQgaXMgcG9zc2libGUgZm9yIHVzZXJzIG9mIGRlY29kZWQgdmFsdWVzIHRvIGNoYW5nZVxuICAgICAgICAgKiB0aGUgY29udGVudCBvZiB0aGUgdmFsdWUuICovXG4gICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICB9XG4gICAgLyoqIEBvdmVycmlkZSAqL1xuICAgIGRlY29kZShiLCBvZmZzZXQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudmFsdWU7XG4gICAgfVxuICAgIC8qKiBAb3ZlcnJpZGUgKi9cbiAgICBlbmNvZGUoc3JjLCBiLCBvZmZzZXQpIHtcbiAgICAgICAgLyogQ29uc3RhbnRzIHRha2Ugbm8gc3BhY2UgKi9cbiAgICAgICAgcmV0dXJuIDA7XG4gICAgfVxufVxuZXhwb3J0cy5Db25zdGFudCA9IENvbnN0YW50O1xuLyoqIEZhY3RvcnkgZm9yIHtAbGluayBHcmVlZHlDb3VudH0uICovXG5leHBvcnRzLmdyZWVkeSA9ICgoZWxlbWVudFNwYW4sIHByb3BlcnR5KSA9PiBuZXcgR3JlZWR5Q291bnQoZWxlbWVudFNwYW4sIHByb3BlcnR5KSk7XG4vKiogRmFjdG9yeSBmb3Ige0BsaW5rIE9mZnNldExheW91dH0uICovXG5leHBvcnRzLm9mZnNldCA9ICgobGF5b3V0LCBvZmZzZXQsIHByb3BlcnR5KSA9PiBuZXcgT2Zmc2V0TGF5b3V0KGxheW91dCwgb2Zmc2V0LCBwcm9wZXJ0eSkpO1xuLyoqIEZhY3RvcnkgZm9yIHtAbGluayBVSW50fHVuc2lnbmVkIGludCBsYXlvdXRzfSBzcGFubmluZyBvbmVcbiAqIGJ5dGUuICovXG5leHBvcnRzLnU4ID0gKChwcm9wZXJ0eSkgPT4gbmV3IFVJbnQoMSwgcHJvcGVydHkpKTtcbi8qKiBGYWN0b3J5IGZvciB7QGxpbmsgVUludHxsaXR0bGUtZW5kaWFuIHVuc2lnbmVkIGludCBsYXlvdXRzfVxuICogc3Bhbm5pbmcgdHdvIGJ5dGVzLiAqL1xuZXhwb3J0cy51MTYgPSAoKHByb3BlcnR5KSA9PiBuZXcgVUludCgyLCBwcm9wZXJ0eSkpO1xuLyoqIEZhY3RvcnkgZm9yIHtAbGluayBVSW50fGxpdHRsZS1lbmRpYW4gdW5zaWduZWQgaW50IGxheW91dHN9XG4gKiBzcGFubmluZyB0aHJlZSBieXRlcy4gKi9cbmV4cG9ydHMudTI0ID0gKChwcm9wZXJ0eSkgPT4gbmV3IFVJbnQoMywgcHJvcGVydHkpKTtcbi8qKiBGYWN0b3J5IGZvciB7QGxpbmsgVUludHxsaXR0bGUtZW5kaWFuIHVuc2lnbmVkIGludCBsYXlvdXRzfVxuICogc3Bhbm5pbmcgZm91ciBieXRlcy4gKi9cbmV4cG9ydHMudTMyID0gKChwcm9wZXJ0eSkgPT4gbmV3IFVJbnQoNCwgcHJvcGVydHkpKTtcbi8qKiBGYWN0b3J5IGZvciB7QGxpbmsgVUludHxsaXR0bGUtZW5kaWFuIHVuc2lnbmVkIGludCBsYXlvdXRzfVxuICogc3Bhbm5pbmcgZml2ZSBieXRlcy4gKi9cbmV4cG9ydHMudTQwID0gKChwcm9wZXJ0eSkgPT4gbmV3IFVJbnQoNSwgcHJvcGVydHkpKTtcbi8qKiBGYWN0b3J5IGZvciB7QGxpbmsgVUludHxsaXR0bGUtZW5kaWFuIHVuc2lnbmVkIGludCBsYXlvdXRzfVxuICogc3Bhbm5pbmcgc2l4IGJ5dGVzLiAqL1xuZXhwb3J0cy51NDggPSAoKHByb3BlcnR5KSA9PiBuZXcgVUludCg2LCBwcm9wZXJ0eSkpO1xuLyoqIEZhY3RvcnkgZm9yIHtAbGluayBOZWFyVUludDY0fGxpdHRsZS1lbmRpYW4gdW5zaWduZWQgaW50XG4gKiBsYXlvdXRzfSBpbnRlcnByZXRlZCBhcyBOdW1iZXJzLiAqL1xuZXhwb3J0cy5udTY0ID0gKChwcm9wZXJ0eSkgPT4gbmV3IE5lYXJVSW50NjQocHJvcGVydHkpKTtcbi8qKiBGYWN0b3J5IGZvciB7QGxpbmsgVUludHxiaWctZW5kaWFuIHVuc2lnbmVkIGludCBsYXlvdXRzfVxuICogc3Bhbm5pbmcgdHdvIGJ5dGVzLiAqL1xuZXhwb3J0cy51MTZiZSA9ICgocHJvcGVydHkpID0+IG5ldyBVSW50QkUoMiwgcHJvcGVydHkpKTtcbi8qKiBGYWN0b3J5IGZvciB7QGxpbmsgVUludHxiaWctZW5kaWFuIHVuc2lnbmVkIGludCBsYXlvdXRzfVxuICogc3Bhbm5pbmcgdGhyZWUgYnl0ZXMuICovXG5leHBvcnRzLnUyNGJlID0gKChwcm9wZXJ0eSkgPT4gbmV3IFVJbnRCRSgzLCBwcm9wZXJ0eSkpO1xuLyoqIEZhY3RvcnkgZm9yIHtAbGluayBVSW50fGJpZy1lbmRpYW4gdW5zaWduZWQgaW50IGxheW91dHN9XG4gKiBzcGFubmluZyBmb3VyIGJ5dGVzLiAqL1xuZXhwb3J0cy51MzJiZSA9ICgocHJvcGVydHkpID0+IG5ldyBVSW50QkUoNCwgcHJvcGVydHkpKTtcbi8qKiBGYWN0b3J5IGZvciB7QGxpbmsgVUludHxiaWctZW5kaWFuIHVuc2lnbmVkIGludCBsYXlvdXRzfVxuICogc3Bhbm5pbmcgZml2ZSBieXRlcy4gKi9cbmV4cG9ydHMudTQwYmUgPSAoKHByb3BlcnR5KSA9PiBuZXcgVUludEJFKDUsIHByb3BlcnR5KSk7XG4vKiogRmFjdG9yeSBmb3Ige0BsaW5rIFVJbnR8YmlnLWVuZGlhbiB1bnNpZ25lZCBpbnQgbGF5b3V0c31cbiAqIHNwYW5uaW5nIHNpeCBieXRlcy4gKi9cbmV4cG9ydHMudTQ4YmUgPSAoKHByb3BlcnR5KSA9PiBuZXcgVUludEJFKDYsIHByb3BlcnR5KSk7XG4vKiogRmFjdG9yeSBmb3Ige0BsaW5rIE5lYXJVSW50NjRCRXxiaWctZW5kaWFuIHVuc2lnbmVkIGludFxuICogbGF5b3V0c30gaW50ZXJwcmV0ZWQgYXMgTnVtYmVycy4gKi9cbmV4cG9ydHMubnU2NGJlID0gKChwcm9wZXJ0eSkgPT4gbmV3IE5lYXJVSW50NjRCRShwcm9wZXJ0eSkpO1xuLyoqIEZhY3RvcnkgZm9yIHtAbGluayBJbnR8c2lnbmVkIGludCBsYXlvdXRzfSBzcGFubmluZyBvbmVcbiAqIGJ5dGUuICovXG5leHBvcnRzLnM4ID0gKChwcm9wZXJ0eSkgPT4gbmV3IEludCgxLCBwcm9wZXJ0eSkpO1xuLyoqIEZhY3RvcnkgZm9yIHtAbGluayBJbnR8bGl0dGxlLWVuZGlhbiBzaWduZWQgaW50IGxheW91dHN9XG4gKiBzcGFubmluZyB0d28gYnl0ZXMuICovXG5leHBvcnRzLnMxNiA9ICgocHJvcGVydHkpID0+IG5ldyBJbnQoMiwgcHJvcGVydHkpKTtcbi8qKiBGYWN0b3J5IGZvciB7QGxpbmsgSW50fGxpdHRsZS1lbmRpYW4gc2lnbmVkIGludCBsYXlvdXRzfVxuICogc3Bhbm5pbmcgdGhyZWUgYnl0ZXMuICovXG5leHBvcnRzLnMyNCA9ICgocHJvcGVydHkpID0+IG5ldyBJbnQoMywgcHJvcGVydHkpKTtcbi8qKiBGYWN0b3J5IGZvciB7QGxpbmsgSW50fGxpdHRsZS1lbmRpYW4gc2lnbmVkIGludCBsYXlvdXRzfVxuICogc3Bhbm5pbmcgZm91ciBieXRlcy4gKi9cbmV4cG9ydHMuczMyID0gKChwcm9wZXJ0eSkgPT4gbmV3IEludCg0LCBwcm9wZXJ0eSkpO1xuLyoqIEZhY3RvcnkgZm9yIHtAbGluayBJbnR8bGl0dGxlLWVuZGlhbiBzaWduZWQgaW50IGxheW91dHN9XG4gKiBzcGFubmluZyBmaXZlIGJ5dGVzLiAqL1xuZXhwb3J0cy5zNDAgPSAoKHByb3BlcnR5KSA9PiBuZXcgSW50KDUsIHByb3BlcnR5KSk7XG4vKiogRmFjdG9yeSBmb3Ige0BsaW5rIEludHxsaXR0bGUtZW5kaWFuIHNpZ25lZCBpbnQgbGF5b3V0c31cbiAqIHNwYW5uaW5nIHNpeCBieXRlcy4gKi9cbmV4cG9ydHMuczQ4ID0gKChwcm9wZXJ0eSkgPT4gbmV3IEludCg2LCBwcm9wZXJ0eSkpO1xuLyoqIEZhY3RvcnkgZm9yIHtAbGluayBOZWFySW50NjR8bGl0dGxlLWVuZGlhbiBzaWduZWQgaW50IGxheW91dHN9XG4gKiBpbnRlcnByZXRlZCBhcyBOdW1iZXJzLiAqL1xuZXhwb3J0cy5uczY0ID0gKChwcm9wZXJ0eSkgPT4gbmV3IE5lYXJJbnQ2NChwcm9wZXJ0eSkpO1xuLyoqIEZhY3RvcnkgZm9yIHtAbGluayBJbnR8YmlnLWVuZGlhbiBzaWduZWQgaW50IGxheW91dHN9XG4gKiBzcGFubmluZyB0d28gYnl0ZXMuICovXG5leHBvcnRzLnMxNmJlID0gKChwcm9wZXJ0eSkgPT4gbmV3IEludEJFKDIsIHByb3BlcnR5KSk7XG4vKiogRmFjdG9yeSBmb3Ige0BsaW5rIEludHxiaWctZW5kaWFuIHNpZ25lZCBpbnQgbGF5b3V0c31cbiAqIHNwYW5uaW5nIHRocmVlIGJ5dGVzLiAqL1xuZXhwb3J0cy5zMjRiZSA9ICgocHJvcGVydHkpID0+IG5ldyBJbnRCRSgzLCBwcm9wZXJ0eSkpO1xuLyoqIEZhY3RvcnkgZm9yIHtAbGluayBJbnR8YmlnLWVuZGlhbiBzaWduZWQgaW50IGxheW91dHN9XG4gKiBzcGFubmluZyBmb3VyIGJ5dGVzLiAqL1xuZXhwb3J0cy5zMzJiZSA9ICgocHJvcGVydHkpID0+IG5ldyBJbnRCRSg0LCBwcm9wZXJ0eSkpO1xuLyoqIEZhY3RvcnkgZm9yIHtAbGluayBJbnR8YmlnLWVuZGlhbiBzaWduZWQgaW50IGxheW91dHN9XG4gKiBzcGFubmluZyBmaXZlIGJ5dGVzLiAqL1xuZXhwb3J0cy5zNDBiZSA9ICgocHJvcGVydHkpID0+IG5ldyBJbnRCRSg1LCBwcm9wZXJ0eSkpO1xuLyoqIEZhY3RvcnkgZm9yIHtAbGluayBJbnR8YmlnLWVuZGlhbiBzaWduZWQgaW50IGxheW91dHN9XG4gKiBzcGFubmluZyBzaXggYnl0ZXMuICovXG5leHBvcnRzLnM0OGJlID0gKChwcm9wZXJ0eSkgPT4gbmV3IEludEJFKDYsIHByb3BlcnR5KSk7XG4vKiogRmFjdG9yeSBmb3Ige0BsaW5rIE5lYXJJbnQ2NEJFfGJpZy1lbmRpYW4gc2lnbmVkIGludCBsYXlvdXRzfVxuICogaW50ZXJwcmV0ZWQgYXMgTnVtYmVycy4gKi9cbmV4cG9ydHMubnM2NGJlID0gKChwcm9wZXJ0eSkgPT4gbmV3IE5lYXJJbnQ2NEJFKHByb3BlcnR5KSk7XG4vKiogRmFjdG9yeSBmb3Ige0BsaW5rIEZsb2F0fGxpdHRsZS1lbmRpYW4gMzItYml0IGZsb2F0aW5nIHBvaW50fSB2YWx1ZXMuICovXG5leHBvcnRzLmYzMiA9ICgocHJvcGVydHkpID0+IG5ldyBGbG9hdChwcm9wZXJ0eSkpO1xuLyoqIEZhY3RvcnkgZm9yIHtAbGluayBGbG9hdEJFfGJpZy1lbmRpYW4gMzItYml0IGZsb2F0aW5nIHBvaW50fSB2YWx1ZXMuICovXG5leHBvcnRzLmYzMmJlID0gKChwcm9wZXJ0eSkgPT4gbmV3IEZsb2F0QkUocHJvcGVydHkpKTtcbi8qKiBGYWN0b3J5IGZvciB7QGxpbmsgRG91YmxlfGxpdHRsZS1lbmRpYW4gNjQtYml0IGZsb2F0aW5nIHBvaW50fSB2YWx1ZXMuICovXG5leHBvcnRzLmY2NCA9ICgocHJvcGVydHkpID0+IG5ldyBEb3VibGUocHJvcGVydHkpKTtcbi8qKiBGYWN0b3J5IGZvciB7QGxpbmsgRG91YmxlQkV8YmlnLWVuZGlhbiA2NC1iaXQgZmxvYXRpbmcgcG9pbnR9IHZhbHVlcy4gKi9cbmV4cG9ydHMuZjY0YmUgPSAoKHByb3BlcnR5KSA9PiBuZXcgRG91YmxlQkUocHJvcGVydHkpKTtcbi8qKiBGYWN0b3J5IGZvciB7QGxpbmsgU3RydWN0dXJlfSB2YWx1ZXMuICovXG5leHBvcnRzLnN0cnVjdCA9ICgoZmllbGRzLCBwcm9wZXJ0eSwgZGVjb2RlUHJlZml4ZXMpID0+IG5ldyBTdHJ1Y3R1cmUoZmllbGRzLCBwcm9wZXJ0eSwgZGVjb2RlUHJlZml4ZXMpKTtcbi8qKiBGYWN0b3J5IGZvciB7QGxpbmsgQml0U3RydWN0dXJlfSB2YWx1ZXMuICovXG5leHBvcnRzLmJpdHMgPSAoKHdvcmQsIG1zYiwgcHJvcGVydHkpID0+IG5ldyBCaXRTdHJ1Y3R1cmUod29yZCwgbXNiLCBwcm9wZXJ0eSkpO1xuLyoqIEZhY3RvcnkgZm9yIHtAbGluayBTZXF1ZW5jZX0gdmFsdWVzLiAqL1xuZXhwb3J0cy5zZXEgPSAoKGVsZW1lbnRMYXlvdXQsIGNvdW50LCBwcm9wZXJ0eSkgPT4gbmV3IFNlcXVlbmNlKGVsZW1lbnRMYXlvdXQsIGNvdW50LCBwcm9wZXJ0eSkpO1xuLyoqIEZhY3RvcnkgZm9yIHtAbGluayBVbmlvbn0gdmFsdWVzLiAqL1xuZXhwb3J0cy51bmlvbiA9ICgoZGlzY3IsIGRlZmF1bHRMYXlvdXQsIHByb3BlcnR5KSA9PiBuZXcgVW5pb24oZGlzY3IsIGRlZmF1bHRMYXlvdXQsIHByb3BlcnR5KSk7XG4vKiogRmFjdG9yeSBmb3Ige0BsaW5rIFVuaW9uTGF5b3V0RGlzY3JpbWluYXRvcn0gdmFsdWVzLiAqL1xuZXhwb3J0cy51bmlvbkxheW91dERpc2NyaW1pbmF0b3IgPSAoKGxheW91dCwgcHJvcGVydHkpID0+IG5ldyBVbmlvbkxheW91dERpc2NyaW1pbmF0b3IobGF5b3V0LCBwcm9wZXJ0eSkpO1xuLyoqIEZhY3RvcnkgZm9yIHtAbGluayBCbG9ifSB2YWx1ZXMuICovXG5leHBvcnRzLmJsb2IgPSAoKGxlbmd0aCwgcHJvcGVydHkpID0+IG5ldyBCbG9iKGxlbmd0aCwgcHJvcGVydHkpKTtcbi8qKiBGYWN0b3J5IGZvciB7QGxpbmsgQ1N0cmluZ30gdmFsdWVzLiAqL1xuZXhwb3J0cy5jc3RyID0gKChwcm9wZXJ0eSkgPT4gbmV3IENTdHJpbmcocHJvcGVydHkpKTtcbi8qKiBGYWN0b3J5IGZvciB7QGxpbmsgVVRGOH0gdmFsdWVzLiAqL1xuZXhwb3J0cy51dGY4ID0gKChtYXhTcGFuLCBwcm9wZXJ0eSkgPT4gbmV3IFVURjgobWF4U3BhbiwgcHJvcGVydHkpKTtcbi8qKiBGYWN0b3J5IGZvciB7QGxpbmsgQ29uc3RhbnR9IHZhbHVlcy4gKi9cbmV4cG9ydHMuY29uc3RhbnQgPSAoKHZhbHVlLCBwcm9wZXJ0eSkgPT4gbmV3IENvbnN0YW50KHZhbHVlLCBwcm9wZXJ0eSkpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9TGF5b3V0LmpzLm1hcCJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsInMxNiIsInM4IiwibnU2NGJlIiwidTQ4YmUiLCJ1NDBiZSIsInUzMmJlIiwidTI0YmUiLCJ1MTZiZSIsIm51NjQiLCJ1NDgiLCJ1NDAiLCJ1MzIiLCJ1MjQiLCJ1MTYiLCJ1OCIsIm9mZnNldCIsImdyZWVkeSIsIkNvbnN0YW50IiwiVVRGOCIsIkNTdHJpbmciLCJCbG9iIiwiQm9vbGVhbiIsIkJpdEZpZWxkIiwiQml0U3RydWN0dXJlIiwiVmFyaWFudExheW91dCIsIlVuaW9uIiwiVW5pb25MYXlvdXREaXNjcmltaW5hdG9yIiwiVW5pb25EaXNjcmltaW5hdG9yIiwiU3RydWN0dXJlIiwiU2VxdWVuY2UiLCJEb3VibGVCRSIsIkRvdWJsZSIsIkZsb2F0QkUiLCJGbG9hdCIsIk5lYXJJbnQ2NEJFIiwiTmVhckludDY0IiwiTmVhclVJbnQ2NEJFIiwiTmVhclVJbnQ2NCIsIkludEJFIiwiSW50IiwiVUludEJFIiwiVUludCIsIk9mZnNldExheW91dCIsIkdyZWVkeUNvdW50IiwiRXh0ZXJuYWxMYXlvdXQiLCJiaW5kQ29uc3RydWN0b3JMYXlvdXQiLCJuYW1lV2l0aFByb3BlcnR5IiwiTGF5b3V0IiwidWludDhBcnJheVRvQnVmZmVyIiwiY2hlY2tVaW50OEFycmF5IiwiY29uc3RhbnQiLCJ1dGY4IiwiY3N0ciIsImJsb2IiLCJ1bmlvbkxheW91dERpc2NyaW1pbmF0b3IiLCJ1bmlvbiIsInNlcSIsImJpdHMiLCJzdHJ1Y3QiLCJmNjRiZSIsImY2NCIsImYzMmJlIiwiZjMyIiwibnM2NGJlIiwiczQ4YmUiLCJzNDBiZSIsInMzMmJlIiwiczI0YmUiLCJzMTZiZSIsIm5zNjQiLCJzNDgiLCJzNDAiLCJzMzIiLCJzMjQiLCJidWZmZXJfMSIsInJlcXVpcmUiLCJiIiwiVWludDhBcnJheSIsIlR5cGVFcnJvciIsIkJ1ZmZlciIsImZyb20iLCJidWZmZXIiLCJieXRlT2Zmc2V0IiwibGVuZ3RoIiwiY29uc3RydWN0b3IiLCJzcGFuIiwicHJvcGVydHkiLCJOdW1iZXIiLCJpc0ludGVnZXIiLCJtYWtlRGVzdGluYXRpb25PYmplY3QiLCJnZXRTcGFuIiwiUmFuZ2VFcnJvciIsInJlcGxpY2F0ZSIsInJ2IiwiY3JlYXRlIiwicHJvdG90eXBlIiwiYXNzaWduIiwiZnJvbUFycmF5IiwidmFsdWVzIiwidW5kZWZpbmVkIiwibmFtZSIsImxvIiwiQ2xhc3MiLCJsYXlvdXQiLCJoYXNPd25Qcm9wZXJ0eSIsImNhbGwiLCJFcnJvciIsImxheW91dF8iLCJib3VuZENvbnN0cnVjdG9yXyIsImVuY29kZSIsIndyaXRhYmxlIiwiZGVjb2RlIiwiaXNDb3VudCIsImVsZW1lbnRTcGFuIiwicmVtIiwiTWF0aCIsImZsb29yIiwic3JjIiwicmVhZFVJbnRMRSIsIndyaXRlVUludExFIiwicmVhZFVJbnRCRSIsIndyaXRlVUludEJFIiwicmVhZEludExFIiwid3JpdGVJbnRMRSIsInJlYWRJbnRCRSIsIndyaXRlSW50QkUiLCJWMkUzMiIsInBvdyIsImRpdm1vZEludDY0IiwiaGkzMiIsImxvMzIiLCJyb3VuZGVkSW50NjQiLCJyZWFkVUludDMyTEUiLCJzcGxpdCIsIndyaXRlVUludDMyTEUiLCJyZWFkVUludDMyQkUiLCJ3cml0ZVVJbnQzMkJFIiwicmVhZEludDMyTEUiLCJ3cml0ZUludDMyTEUiLCJyZWFkSW50MzJCRSIsIndyaXRlSW50MzJCRSIsInJlYWRGbG9hdExFIiwid3JpdGVGbG9hdExFIiwicmVhZEZsb2F0QkUiLCJ3cml0ZUZsb2F0QkUiLCJyZWFkRG91YmxlTEUiLCJ3cml0ZURvdWJsZUxFIiwicmVhZERvdWJsZUJFIiwid3JpdGVEb3VibGVCRSIsImVsZW1lbnRMYXlvdXQiLCJjb3VudCIsImlkeCIsImkiLCJwdXNoIiwiZWxvIiwicmVkdWNlIiwidiIsImZpZWxkcyIsImRlY29kZVByZWZpeGVzIiwiQXJyYXkiLCJpc0FycmF5IiwiYWNjIiwiZmQiLCJlIiwiZnNwIiwiZGVzdCIsImZpcnN0T2Zmc2V0IiwibGFzdE9mZnNldCIsImxhc3RXcm90ZSIsImZ2Iiwic2hpZnQiLCJsYXlvdXRGb3IiLCJvZmZzZXRPZiIsImRpc2NyIiwiZGVmYXVsdExheW91dCIsImRpc2NyaW1pbmF0b3IiLCJ1c2VzUHJlZml4RGlzY3JpbWluYXRvciIsInJlZ2lzdHJ5IiwiYm91bmRHZXRTb3VyY2VWYXJpYW50IiwiZGVmYXVsdEdldFNvdXJjZVZhcmlhbnQiLCJiaW5kIiwiZ2V0U291cmNlVmFyaWFudCIsImNvbmZpZ0dldFNvdXJjZVZhcmlhbnQiLCJnc3YiLCJ2bG8iLCJnZXRWYXJpYW50IiwidGFnIiwiZGxvIiwiY2xvIiwiY29udGVudE9mZnNldCIsImFkZFZhcmlhbnQiLCJ2YXJpYW50IiwidmIiLCJmaXhCaXR3aXNlUmVzdWx0Iiwid29yZCIsIm1zYiIsIl9wYWNrZWRTZXRWYWx1ZSIsIl9wYWNrZWRHZXRWYWx1ZSIsImFkZEZpZWxkIiwiYmYiLCJhZGRCb29sZWFuIiwiZmllbGRGb3IiLCJjb250YWluZXIiLCJ0b3RhbEJpdHMiLCJ1c2VkQml0cyIsInN1bSIsInZhbHVlTWFzayIsInN0YXJ0Iiwid29yZE1hc2siLCJ3b3JkVmFsdWUiLCJzbGljZSIsInNyY0J1ZmZlciIsIndyaXRlIiwidG9TdHJpbmciLCJTdHJpbmciLCJzcmNiIiwiY29weSIsIm1heFNwYW4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/@solana/buffer-layout/lib/Layout.js\n");

/***/ }),

/***/ "(ssr)/../node_modules/@solana/web3.js/lib/index.esm.js":
/*!********************************************************!*\
  !*** ../node_modules/@solana/web3.js/lib/index.esm.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Account: () => (/* binding */ Account),\n/* harmony export */   AddressLookupTableAccount: () => (/* binding */ AddressLookupTableAccount),\n/* harmony export */   AddressLookupTableInstruction: () => (/* binding */ AddressLookupTableInstruction),\n/* harmony export */   AddressLookupTableProgram: () => (/* binding */ AddressLookupTableProgram),\n/* harmony export */   Authorized: () => (/* binding */ Authorized),\n/* harmony export */   BLOCKHASH_CACHE_TIMEOUT_MS: () => (/* binding */ BLOCKHASH_CACHE_TIMEOUT_MS),\n/* harmony export */   BPF_LOADER_DEPRECATED_PROGRAM_ID: () => (/* binding */ BPF_LOADER_DEPRECATED_PROGRAM_ID),\n/* harmony export */   BPF_LOADER_PROGRAM_ID: () => (/* binding */ BPF_LOADER_PROGRAM_ID),\n/* harmony export */   BpfLoader: () => (/* binding */ BpfLoader),\n/* harmony export */   COMPUTE_BUDGET_INSTRUCTION_LAYOUTS: () => (/* binding */ COMPUTE_BUDGET_INSTRUCTION_LAYOUTS),\n/* harmony export */   ComputeBudgetInstruction: () => (/* binding */ ComputeBudgetInstruction),\n/* harmony export */   ComputeBudgetProgram: () => (/* binding */ ComputeBudgetProgram),\n/* harmony export */   Connection: () => (/* binding */ Connection),\n/* harmony export */   Ed25519Program: () => (/* binding */ Ed25519Program),\n/* harmony export */   Enum: () => (/* binding */ Enum),\n/* harmony export */   EpochSchedule: () => (/* binding */ EpochSchedule),\n/* harmony export */   FeeCalculatorLayout: () => (/* binding */ FeeCalculatorLayout),\n/* harmony export */   Keypair: () => (/* binding */ Keypair),\n/* harmony export */   LAMPORTS_PER_SOL: () => (/* binding */ LAMPORTS_PER_SOL),\n/* harmony export */   LOOKUP_TABLE_INSTRUCTION_LAYOUTS: () => (/* binding */ LOOKUP_TABLE_INSTRUCTION_LAYOUTS),\n/* harmony export */   Loader: () => (/* binding */ Loader),\n/* harmony export */   Lockup: () => (/* binding */ Lockup),\n/* harmony export */   MAX_SEED_LENGTH: () => (/* binding */ MAX_SEED_LENGTH),\n/* harmony export */   Message: () => (/* binding */ Message),\n/* harmony export */   MessageAccountKeys: () => (/* binding */ MessageAccountKeys),\n/* harmony export */   MessageV0: () => (/* binding */ MessageV0),\n/* harmony export */   NONCE_ACCOUNT_LENGTH: () => (/* binding */ NONCE_ACCOUNT_LENGTH),\n/* harmony export */   NonceAccount: () => (/* binding */ NonceAccount),\n/* harmony export */   PACKET_DATA_SIZE: () => (/* binding */ PACKET_DATA_SIZE),\n/* harmony export */   PUBLIC_KEY_LENGTH: () => (/* binding */ PUBLIC_KEY_LENGTH),\n/* harmony export */   PublicKey: () => (/* binding */ PublicKey),\n/* harmony export */   SIGNATURE_LENGTH_IN_BYTES: () => (/* binding */ SIGNATURE_LENGTH_IN_BYTES),\n/* harmony export */   SOLANA_SCHEMA: () => (/* binding */ SOLANA_SCHEMA),\n/* harmony export */   STAKE_CONFIG_ID: () => (/* binding */ STAKE_CONFIG_ID),\n/* harmony export */   STAKE_INSTRUCTION_LAYOUTS: () => (/* binding */ STAKE_INSTRUCTION_LAYOUTS),\n/* harmony export */   SYSTEM_INSTRUCTION_LAYOUTS: () => (/* binding */ SYSTEM_INSTRUCTION_LAYOUTS),\n/* harmony export */   SYSVAR_CLOCK_PUBKEY: () => (/* binding */ SYSVAR_CLOCK_PUBKEY),\n/* harmony export */   SYSVAR_EPOCH_SCHEDULE_PUBKEY: () => (/* binding */ SYSVAR_EPOCH_SCHEDULE_PUBKEY),\n/* harmony export */   SYSVAR_INSTRUCTIONS_PUBKEY: () => (/* binding */ SYSVAR_INSTRUCTIONS_PUBKEY),\n/* harmony export */   SYSVAR_RECENT_BLOCKHASHES_PUBKEY: () => (/* binding */ SYSVAR_RECENT_BLOCKHASHES_PUBKEY),\n/* harmony export */   SYSVAR_RENT_PUBKEY: () => (/* binding */ SYSVAR_RENT_PUBKEY),\n/* harmony export */   SYSVAR_REWARDS_PUBKEY: () => (/* binding */ SYSVAR_REWARDS_PUBKEY),\n/* harmony export */   SYSVAR_SLOT_HASHES_PUBKEY: () => (/* binding */ SYSVAR_SLOT_HASHES_PUBKEY),\n/* harmony export */   SYSVAR_SLOT_HISTORY_PUBKEY: () => (/* binding */ SYSVAR_SLOT_HISTORY_PUBKEY),\n/* harmony export */   SYSVAR_STAKE_HISTORY_PUBKEY: () => (/* binding */ SYSVAR_STAKE_HISTORY_PUBKEY),\n/* harmony export */   Secp256k1Program: () => (/* binding */ Secp256k1Program),\n/* harmony export */   SendTransactionError: () => (/* binding */ SendTransactionError),\n/* harmony export */   SolanaJSONRPCError: () => (/* binding */ SolanaJSONRPCError),\n/* harmony export */   SolanaJSONRPCErrorCode: () => (/* binding */ SolanaJSONRPCErrorCode),\n/* harmony export */   StakeAuthorizationLayout: () => (/* binding */ StakeAuthorizationLayout),\n/* harmony export */   StakeInstruction: () => (/* binding */ StakeInstruction),\n/* harmony export */   StakeProgram: () => (/* binding */ StakeProgram),\n/* harmony export */   Struct: () => (/* binding */ Struct),\n/* harmony export */   SystemInstruction: () => (/* binding */ SystemInstruction),\n/* harmony export */   SystemProgram: () => (/* binding */ SystemProgram),\n/* harmony export */   Transaction: () => (/* binding */ Transaction),\n/* harmony export */   TransactionExpiredBlockheightExceededError: () => (/* binding */ TransactionExpiredBlockheightExceededError),\n/* harmony export */   TransactionExpiredNonceInvalidError: () => (/* binding */ TransactionExpiredNonceInvalidError),\n/* harmony export */   TransactionExpiredTimeoutError: () => (/* binding */ TransactionExpiredTimeoutError),\n/* harmony export */   TransactionInstruction: () => (/* binding */ TransactionInstruction),\n/* harmony export */   TransactionMessage: () => (/* binding */ TransactionMessage),\n/* harmony export */   TransactionStatus: () => (/* binding */ TransactionStatus),\n/* harmony export */   VALIDATOR_INFO_KEY: () => (/* binding */ VALIDATOR_INFO_KEY),\n/* harmony export */   VERSION_PREFIX_MASK: () => (/* binding */ VERSION_PREFIX_MASK),\n/* harmony export */   VOTE_PROGRAM_ID: () => (/* binding */ VOTE_PROGRAM_ID),\n/* harmony export */   ValidatorInfo: () => (/* binding */ ValidatorInfo),\n/* harmony export */   VersionedMessage: () => (/* binding */ VersionedMessage),\n/* harmony export */   VersionedTransaction: () => (/* binding */ VersionedTransaction),\n/* harmony export */   VoteAccount: () => (/* binding */ VoteAccount),\n/* harmony export */   VoteAuthorizationLayout: () => (/* binding */ VoteAuthorizationLayout),\n/* harmony export */   VoteInit: () => (/* binding */ VoteInit),\n/* harmony export */   VoteInstruction: () => (/* binding */ VoteInstruction),\n/* harmony export */   VoteProgram: () => (/* binding */ VoteProgram),\n/* harmony export */   clusterApiUrl: () => (/* binding */ clusterApiUrl),\n/* harmony export */   sendAndConfirmRawTransaction: () => (/* binding */ sendAndConfirmRawTransaction),\n/* harmony export */   sendAndConfirmTransaction: () => (/* binding */ sendAndConfirmTransaction)\n/* harmony export */ });\n/* harmony import */ var buffer__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! buffer */ \"buffer\");\n/* harmony import */ var buffer__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(buffer__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _noble_curves_ed25519__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! @noble/curves/ed25519 */ \"(ssr)/../node_modules/@noble/curves/esm/ed25519.js\");\n/* harmony import */ var bn_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! bn.js */ \"(ssr)/../node_modules/bn.js/lib/bn.js\");\n/* harmony import */ var bn_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(bn_js__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var bs58__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! bs58 */ \"(ssr)/../node_modules/@solana/web3.js/node_modules/bs58/index.js\");\n/* harmony import */ var bs58__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(bs58__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var _noble_hashes_sha256__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! @noble/hashes/sha256 */ \"(ssr)/../node_modules/@noble/hashes/esm/sha256.js\");\n/* harmony import */ var borsh__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! borsh */ \"(ssr)/../node_modules/borsh/lib/index.js\");\n/* harmony import */ var borsh__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(borsh__WEBPACK_IMPORTED_MODULE_3__);\n/* harmony import */ var _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @solana/buffer-layout */ \"(ssr)/../node_modules/@solana/buffer-layout/lib/Layout.js\");\n/* harmony import */ var bigint_buffer__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! bigint-buffer */ \"(ssr)/../node_modules/bigint-buffer/dist/node.js\");\n/* harmony import */ var util__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! util */ \"util\");\n/* harmony import */ var util__WEBPACK_IMPORTED_MODULE_6___default = /*#__PURE__*/__webpack_require__.n(util__WEBPACK_IMPORTED_MODULE_6__);\n/* harmony import */ var http__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! http */ \"http\");\n/* harmony import */ var http__WEBPACK_IMPORTED_MODULE_7___default = /*#__PURE__*/__webpack_require__.n(http__WEBPACK_IMPORTED_MODULE_7__);\n/* harmony import */ var https__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! https */ \"https\");\n/* harmony import */ var https__WEBPACK_IMPORTED_MODULE_8___default = /*#__PURE__*/__webpack_require__.n(https__WEBPACK_IMPORTED_MODULE_8__);\n/* harmony import */ var superstruct__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! superstruct */ \"(ssr)/../node_modules/superstruct/dist/index.mjs\");\n/* harmony import */ var jayson_lib_client_browser__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! jayson/lib/client/browser */ \"(ssr)/../node_modules/jayson/lib/client/browser/index.js\");\n/* harmony import */ var jayson_lib_client_browser__WEBPACK_IMPORTED_MODULE_9___default = /*#__PURE__*/__webpack_require__.n(jayson_lib_client_browser__WEBPACK_IMPORTED_MODULE_9__);\n/* harmony import */ var node_fetch__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! node-fetch */ \"(ssr)/../node_modules/node-fetch/lib/index.mjs\");\n/* harmony import */ var rpc_websockets_dist_lib_client_cjs__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! rpc-websockets/dist/lib/client.cjs */ \"(ssr)/../node_modules/rpc-websockets/dist/lib/client.cjs\");\n/* harmony import */ var rpc_websockets_dist_lib_client_websocket_cjs__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! rpc-websockets/dist/lib/client/websocket.cjs */ \"(ssr)/../node_modules/rpc-websockets/dist/lib/client/websocket.cjs\");\n/* harmony import */ var rpc_websockets_dist_lib_client_websocket_cjs__WEBPACK_IMPORTED_MODULE_12___default = /*#__PURE__*/__webpack_require__.n(rpc_websockets_dist_lib_client_websocket_cjs__WEBPACK_IMPORTED_MODULE_12__);\n/* harmony import */ var _noble_hashes_sha3__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! @noble/hashes/sha3 */ \"(ssr)/../node_modules/@noble/hashes/esm/sha3.js\");\n/* harmony import */ var _noble_curves_secp256k1__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! @noble/curves/secp256k1 */ \"(ssr)/../node_modules/@noble/curves/esm/secp256k1.js\");\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n/**\n * A 64 byte secret key, the first 32 bytes of which is the\n * private scalar and the last 32 bytes is the public key.\n * Read more: https://blog.mozilla.org/warner/2011/11/29/ed25519-keys/\n */ /**\n * Ed25519 Keypair\n */ const generatePrivateKey = _noble_curves_ed25519__WEBPACK_IMPORTED_MODULE_13__.ed25519.utils.randomPrivateKey;\nconst generateKeypair = ()=>{\n    const privateScalar = _noble_curves_ed25519__WEBPACK_IMPORTED_MODULE_13__.ed25519.utils.randomPrivateKey();\n    const publicKey = getPublicKey(privateScalar);\n    const secretKey = new Uint8Array(64);\n    secretKey.set(privateScalar);\n    secretKey.set(publicKey, 32);\n    return {\n        publicKey,\n        secretKey\n    };\n};\nconst getPublicKey = _noble_curves_ed25519__WEBPACK_IMPORTED_MODULE_13__.ed25519.getPublicKey;\nfunction isOnCurve(publicKey) {\n    try {\n        _noble_curves_ed25519__WEBPACK_IMPORTED_MODULE_13__.ed25519.ExtendedPoint.fromHex(publicKey);\n        return true;\n    } catch  {\n        return false;\n    }\n}\nconst sign = (message, secretKey)=>_noble_curves_ed25519__WEBPACK_IMPORTED_MODULE_13__.ed25519.sign(message, secretKey.slice(0, 32));\nconst verify = _noble_curves_ed25519__WEBPACK_IMPORTED_MODULE_13__.ed25519.verify;\nconst toBuffer = (arr)=>{\n    if (buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.isBuffer(arr)) {\n        return arr;\n    } else if (arr instanceof Uint8Array) {\n        return buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.from(arr.buffer, arr.byteOffset, arr.byteLength);\n    } else {\n        return buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.from(arr);\n    }\n};\n// Class wrapping a plain object\nclass Struct {\n    constructor(properties){\n        Object.assign(this, properties);\n    }\n    encode() {\n        return buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.from((0,borsh__WEBPACK_IMPORTED_MODULE_3__.serialize)(SOLANA_SCHEMA, this));\n    }\n    static decode(data) {\n        return (0,borsh__WEBPACK_IMPORTED_MODULE_3__.deserialize)(SOLANA_SCHEMA, this, data);\n    }\n    static decodeUnchecked(data) {\n        return (0,borsh__WEBPACK_IMPORTED_MODULE_3__.deserializeUnchecked)(SOLANA_SCHEMA, this, data);\n    }\n}\n// Class representing a Rust-compatible enum, since enums are only strings or\n// numbers in pure JS\nclass Enum extends Struct {\n    constructor(properties){\n        super(properties);\n        this.enum = \"\";\n        if (Object.keys(properties).length !== 1) {\n            throw new Error(\"Enum can only take single value\");\n        }\n        Object.keys(properties).map((key)=>{\n            this.enum = key;\n        });\n    }\n}\nconst SOLANA_SCHEMA = new Map();\nvar _PublicKey;\n/**\n * Maximum length of derived pubkey seed\n */ const MAX_SEED_LENGTH = 32;\n/**\n * Size of public key in bytes\n */ const PUBLIC_KEY_LENGTH = 32;\n/**\n * Value to be converted into public key\n */ /**\n * JSON object representation of PublicKey class\n */ function isPublicKeyData(value) {\n    return value._bn !== undefined;\n}\n// local counter used by PublicKey.unique()\nlet uniquePublicKeyCounter = 1;\n/**\n * A public key\n */ class PublicKey extends Struct {\n    /**\n   * Create a new PublicKey object\n   * @param value ed25519 public key as buffer or base-58 encoded string\n   */ constructor(value){\n        super({});\n        /** @internal */ this._bn = void 0;\n        if (isPublicKeyData(value)) {\n            this._bn = value._bn;\n        } else {\n            if (typeof value === \"string\") {\n                // assume base 58 encoding by default\n                const decoded = bs58__WEBPACK_IMPORTED_MODULE_2___default().decode(value);\n                if (decoded.length != PUBLIC_KEY_LENGTH) {\n                    throw new Error(`Invalid public key input`);\n                }\n                this._bn = new (bn_js__WEBPACK_IMPORTED_MODULE_1___default())(decoded);\n            } else {\n                this._bn = new (bn_js__WEBPACK_IMPORTED_MODULE_1___default())(value);\n            }\n            if (this._bn.byteLength() > PUBLIC_KEY_LENGTH) {\n                throw new Error(`Invalid public key input`);\n            }\n        }\n    }\n    /**\n   * Returns a unique PublicKey for tests and benchmarks using a counter\n   */ static unique() {\n        const key = new PublicKey(uniquePublicKeyCounter);\n        uniquePublicKeyCounter += 1;\n        return new PublicKey(key.toBuffer());\n    }\n    /**\n   * Default public key value. The base58-encoded string representation is all ones (as seen below)\n   * The underlying BN number is 32 bytes that are all zeros\n   */ /**\n   * Checks if two publicKeys are equal\n   */ equals(publicKey) {\n        return this._bn.eq(publicKey._bn);\n    }\n    /**\n   * Return the base-58 representation of the public key\n   */ toBase58() {\n        return bs58__WEBPACK_IMPORTED_MODULE_2___default().encode(this.toBytes());\n    }\n    toJSON() {\n        return this.toBase58();\n    }\n    /**\n   * Return the byte array representation of the public key in big endian\n   */ toBytes() {\n        const buf = this.toBuffer();\n        return new Uint8Array(buf.buffer, buf.byteOffset, buf.byteLength);\n    }\n    /**\n   * Return the Buffer representation of the public key in big endian\n   */ toBuffer() {\n        const b = this._bn.toArrayLike(buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer);\n        if (b.length === PUBLIC_KEY_LENGTH) {\n            return b;\n        }\n        const zeroPad = buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.alloc(32);\n        b.copy(zeroPad, 32 - b.length);\n        return zeroPad;\n    }\n    get [Symbol.toStringTag]() {\n        return `PublicKey(${this.toString()})`;\n    }\n    /**\n   * Return the base-58 representation of the public key\n   */ toString() {\n        return this.toBase58();\n    }\n    /**\n   * Derive a public key from another key, a seed, and a program ID.\n   * The program ID will also serve as the owner of the public key, giving\n   * it permission to write data to the account.\n   */ /* eslint-disable require-await */ static async createWithSeed(fromPublicKey, seed, programId) {\n        const buffer = buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.concat([\n            fromPublicKey.toBuffer(),\n            buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.from(seed),\n            programId.toBuffer()\n        ]);\n        const publicKeyBytes = (0,_noble_hashes_sha256__WEBPACK_IMPORTED_MODULE_14__.sha256)(buffer);\n        return new PublicKey(publicKeyBytes);\n    }\n    /**\n   * Derive a program address from seeds and a program ID.\n   */ /* eslint-disable require-await */ static createProgramAddressSync(seeds, programId) {\n        let buffer = buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.alloc(0);\n        seeds.forEach(function(seed) {\n            if (seed.length > MAX_SEED_LENGTH) {\n                throw new TypeError(`Max seed length exceeded`);\n            }\n            buffer = buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.concat([\n                buffer,\n                toBuffer(seed)\n            ]);\n        });\n        buffer = buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.concat([\n            buffer,\n            programId.toBuffer(),\n            buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.from(\"ProgramDerivedAddress\")\n        ]);\n        const publicKeyBytes = (0,_noble_hashes_sha256__WEBPACK_IMPORTED_MODULE_14__.sha256)(buffer);\n        if (isOnCurve(publicKeyBytes)) {\n            throw new Error(`Invalid seeds, address must fall off the curve`);\n        }\n        return new PublicKey(publicKeyBytes);\n    }\n    /**\n   * Async version of createProgramAddressSync\n   * For backwards compatibility\n   *\n   * @deprecated Use {@link createProgramAddressSync} instead\n   */ /* eslint-disable require-await */ static async createProgramAddress(seeds, programId) {\n        return this.createProgramAddressSync(seeds, programId);\n    }\n    /**\n   * Find a valid program address\n   *\n   * Valid program addresses must fall off the ed25519 curve.  This function\n   * iterates a nonce until it finds one that when combined with the seeds\n   * results in a valid program address.\n   */ static findProgramAddressSync(seeds, programId) {\n        let nonce = 255;\n        let address;\n        while(nonce != 0){\n            try {\n                const seedsWithNonce = seeds.concat(buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.from([\n                    nonce\n                ]));\n                address = this.createProgramAddressSync(seedsWithNonce, programId);\n            } catch (err) {\n                if (err instanceof TypeError) {\n                    throw err;\n                }\n                nonce--;\n                continue;\n            }\n            return [\n                address,\n                nonce\n            ];\n        }\n        throw new Error(`Unable to find a viable program address nonce`);\n    }\n    /**\n   * Async version of findProgramAddressSync\n   * For backwards compatibility\n   *\n   * @deprecated Use {@link findProgramAddressSync} instead\n   */ static async findProgramAddress(seeds, programId) {\n        return this.findProgramAddressSync(seeds, programId);\n    }\n    /**\n   * Check that a pubkey is on the ed25519 curve.\n   */ static isOnCurve(pubkeyData) {\n        const pubkey = new PublicKey(pubkeyData);\n        return isOnCurve(pubkey.toBytes());\n    }\n}\n_PublicKey = PublicKey;\nPublicKey.default = new _PublicKey(\"11111111111111111111111111111111\");\nSOLANA_SCHEMA.set(PublicKey, {\n    kind: \"struct\",\n    fields: [\n        [\n            \"_bn\",\n            \"u256\"\n        ]\n    ]\n});\n/**\n * An account key pair (public and secret keys).\n *\n * @deprecated since v1.10.0, please use {@link Keypair} instead.\n */ class Account {\n    /**\n   * Create a new Account object\n   *\n   * If the secretKey parameter is not provided a new key pair is randomly\n   * created for the account\n   *\n   * @param secretKey Secret key for the account\n   */ constructor(secretKey){\n        /** @internal */ this._publicKey = void 0;\n        /** @internal */ this._secretKey = void 0;\n        if (secretKey) {\n            const secretKeyBuffer = toBuffer(secretKey);\n            if (secretKey.length !== 64) {\n                throw new Error(\"bad secret key size\");\n            }\n            this._publicKey = secretKeyBuffer.slice(32, 64);\n            this._secretKey = secretKeyBuffer.slice(0, 32);\n        } else {\n            this._secretKey = toBuffer(generatePrivateKey());\n            this._publicKey = toBuffer(getPublicKey(this._secretKey));\n        }\n    }\n    /**\n   * The public key for this account\n   */ get publicKey() {\n        return new PublicKey(this._publicKey);\n    }\n    /**\n   * The **unencrypted** secret key for this account. The first 32 bytes\n   * is the private scalar and the last 32 bytes is the public key.\n   * Read more: https://blog.mozilla.org/warner/2011/11/29/ed25519-keys/\n   */ get secretKey() {\n        return buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.concat([\n            this._secretKey,\n            this._publicKey\n        ], 64);\n    }\n}\nconst BPF_LOADER_DEPRECATED_PROGRAM_ID = new PublicKey(\"BPFLoader1111111111111111111111111111111111\");\n/**\n * Maximum over-the-wire size of a Transaction\n *\n * 1280 is IPv6 minimum MTU\n * 40 bytes is the size of the IPv6 header\n * 8 bytes is the size of the fragment header\n */ const PACKET_DATA_SIZE = 1280 - 40 - 8;\nconst VERSION_PREFIX_MASK = 0x7f;\nconst SIGNATURE_LENGTH_IN_BYTES = 64;\nclass TransactionExpiredBlockheightExceededError extends Error {\n    constructor(signature){\n        super(`Signature ${signature} has expired: block height exceeded.`);\n        this.signature = void 0;\n        this.signature = signature;\n    }\n}\nObject.defineProperty(TransactionExpiredBlockheightExceededError.prototype, \"name\", {\n    value: \"TransactionExpiredBlockheightExceededError\"\n});\nclass TransactionExpiredTimeoutError extends Error {\n    constructor(signature, timeoutSeconds){\n        super(`Transaction was not confirmed in ${timeoutSeconds.toFixed(2)} seconds. It is ` + \"unknown if it succeeded or failed. Check signature \" + `${signature} using the Solana Explorer or CLI tools.`);\n        this.signature = void 0;\n        this.signature = signature;\n    }\n}\nObject.defineProperty(TransactionExpiredTimeoutError.prototype, \"name\", {\n    value: \"TransactionExpiredTimeoutError\"\n});\nclass TransactionExpiredNonceInvalidError extends Error {\n    constructor(signature){\n        super(`Signature ${signature} has expired: the nonce is no longer valid.`);\n        this.signature = void 0;\n        this.signature = signature;\n    }\n}\nObject.defineProperty(TransactionExpiredNonceInvalidError.prototype, \"name\", {\n    value: \"TransactionExpiredNonceInvalidError\"\n});\nclass MessageAccountKeys {\n    constructor(staticAccountKeys, accountKeysFromLookups){\n        this.staticAccountKeys = void 0;\n        this.accountKeysFromLookups = void 0;\n        this.staticAccountKeys = staticAccountKeys;\n        this.accountKeysFromLookups = accountKeysFromLookups;\n    }\n    keySegments() {\n        const keySegments = [\n            this.staticAccountKeys\n        ];\n        if (this.accountKeysFromLookups) {\n            keySegments.push(this.accountKeysFromLookups.writable);\n            keySegments.push(this.accountKeysFromLookups.readonly);\n        }\n        return keySegments;\n    }\n    get(index) {\n        for (const keySegment of this.keySegments()){\n            if (index < keySegment.length) {\n                return keySegment[index];\n            } else {\n                index -= keySegment.length;\n            }\n        }\n        return;\n    }\n    get length() {\n        return this.keySegments().flat().length;\n    }\n    compileInstructions(instructions) {\n        // Bail early if any account indexes would overflow a u8\n        const U8_MAX = 255;\n        if (this.length > U8_MAX + 1) {\n            throw new Error(\"Account index overflow encountered during compilation\");\n        }\n        const keyIndexMap = new Map();\n        this.keySegments().flat().forEach((key, index)=>{\n            keyIndexMap.set(key.toBase58(), index);\n        });\n        const findKeyIndex = (key)=>{\n            const keyIndex = keyIndexMap.get(key.toBase58());\n            if (keyIndex === undefined) throw new Error(\"Encountered an unknown instruction account key during compilation\");\n            return keyIndex;\n        };\n        return instructions.map((instruction)=>{\n            return {\n                programIdIndex: findKeyIndex(instruction.programId),\n                accountKeyIndexes: instruction.keys.map((meta)=>findKeyIndex(meta.pubkey)),\n                data: instruction.data\n            };\n        });\n    }\n}\n/**\n * Layout for a public key\n */ const publicKey = (property = \"publicKey\")=>{\n    return _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.blob(32, property);\n};\n/**\n * Layout for a signature\n */ const signature = (property = \"signature\")=>{\n    return _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.blob(64, property);\n};\n/**\n * Layout for a Rust String type\n */ const rustString = (property = \"string\")=>{\n    const rsl = _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.struct([\n        _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u32(\"length\"),\n        _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u32(\"lengthPadding\"),\n        _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.blob(_solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.offset(_solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u32(), -8), \"chars\")\n    ], property);\n    const _decode = rsl.decode.bind(rsl);\n    const _encode = rsl.encode.bind(rsl);\n    const rslShim = rsl;\n    rslShim.decode = (b, offset)=>{\n        const data = _decode(b, offset);\n        return data[\"chars\"].toString();\n    };\n    rslShim.encode = (str, b, offset)=>{\n        const data = {\n            chars: buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.from(str, \"utf8\")\n        };\n        return _encode(data, b, offset);\n    };\n    rslShim.alloc = (str)=>{\n        return _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u32().span + _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u32().span + buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.from(str, \"utf8\").length;\n    };\n    return rslShim;\n};\n/**\n * Layout for an Authorized object\n */ const authorized = (property = \"authorized\")=>{\n    return _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.struct([\n        publicKey(\"staker\"),\n        publicKey(\"withdrawer\")\n    ], property);\n};\n/**\n * Layout for a Lockup object\n */ const lockup = (property = \"lockup\")=>{\n    return _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.struct([\n        _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.ns64(\"unixTimestamp\"),\n        _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.ns64(\"epoch\"),\n        publicKey(\"custodian\")\n    ], property);\n};\n/**\n *  Layout for a VoteInit object\n */ const voteInit = (property = \"voteInit\")=>{\n    return _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.struct([\n        publicKey(\"nodePubkey\"),\n        publicKey(\"authorizedVoter\"),\n        publicKey(\"authorizedWithdrawer\"),\n        _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u8(\"commission\")\n    ], property);\n};\n/**\n *  Layout for a VoteAuthorizeWithSeedArgs object\n */ const voteAuthorizeWithSeedArgs = (property = \"voteAuthorizeWithSeedArgs\")=>{\n    return _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.struct([\n        _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u32(\"voteAuthorizationType\"),\n        publicKey(\"currentAuthorityDerivedKeyOwnerPubkey\"),\n        rustString(\"currentAuthorityDerivedKeySeed\"),\n        publicKey(\"newAuthorized\")\n    ], property);\n};\nfunction getAlloc(type, fields) {\n    const getItemAlloc = (item)=>{\n        if (item.span >= 0) {\n            return item.span;\n        } else if (typeof item.alloc === \"function\") {\n            return item.alloc(fields[item.property]);\n        } else if (\"count\" in item && \"elementLayout\" in item) {\n            const field = fields[item.property];\n            if (Array.isArray(field)) {\n                return field.length * getItemAlloc(item.elementLayout);\n            }\n        } else if (\"fields\" in item) {\n            // This is a `Structure` whose size needs to be recursively measured.\n            return getAlloc({\n                layout: item\n            }, fields[item.property]);\n        }\n        // Couldn't determine allocated size of layout\n        return 0;\n    };\n    let alloc = 0;\n    type.layout.fields.forEach((item)=>{\n        alloc += getItemAlloc(item);\n    });\n    return alloc;\n}\nfunction decodeLength(bytes) {\n    let len = 0;\n    let size = 0;\n    for(;;){\n        let elem = bytes.shift();\n        len |= (elem & 0x7f) << size * 7;\n        size += 1;\n        if ((elem & 0x80) === 0) {\n            break;\n        }\n    }\n    return len;\n}\nfunction encodeLength(bytes, len) {\n    let rem_len = len;\n    for(;;){\n        let elem = rem_len & 0x7f;\n        rem_len >>= 7;\n        if (rem_len == 0) {\n            bytes.push(elem);\n            break;\n        } else {\n            elem |= 0x80;\n            bytes.push(elem);\n        }\n    }\n}\nfunction assert(condition, message) {\n    if (!condition) {\n        throw new Error(message || \"Assertion failed\");\n    }\n}\nclass CompiledKeys {\n    constructor(payer, keyMetaMap){\n        this.payer = void 0;\n        this.keyMetaMap = void 0;\n        this.payer = payer;\n        this.keyMetaMap = keyMetaMap;\n    }\n    static compile(instructions, payer) {\n        const keyMetaMap = new Map();\n        const getOrInsertDefault = (pubkey)=>{\n            const address = pubkey.toBase58();\n            let keyMeta = keyMetaMap.get(address);\n            if (keyMeta === undefined) {\n                keyMeta = {\n                    isSigner: false,\n                    isWritable: false,\n                    isInvoked: false\n                };\n                keyMetaMap.set(address, keyMeta);\n            }\n            return keyMeta;\n        };\n        const payerKeyMeta = getOrInsertDefault(payer);\n        payerKeyMeta.isSigner = true;\n        payerKeyMeta.isWritable = true;\n        for (const ix of instructions){\n            getOrInsertDefault(ix.programId).isInvoked = true;\n            for (const accountMeta of ix.keys){\n                const keyMeta = getOrInsertDefault(accountMeta.pubkey);\n                keyMeta.isSigner ||= accountMeta.isSigner;\n                keyMeta.isWritable ||= accountMeta.isWritable;\n            }\n        }\n        return new CompiledKeys(payer, keyMetaMap);\n    }\n    getMessageComponents() {\n        const mapEntries = [\n            ...this.keyMetaMap.entries()\n        ];\n        assert(mapEntries.length <= 256, \"Max static account keys length exceeded\");\n        const writableSigners = mapEntries.filter(([, meta])=>meta.isSigner && meta.isWritable);\n        const readonlySigners = mapEntries.filter(([, meta])=>meta.isSigner && !meta.isWritable);\n        const writableNonSigners = mapEntries.filter(([, meta])=>!meta.isSigner && meta.isWritable);\n        const readonlyNonSigners = mapEntries.filter(([, meta])=>!meta.isSigner && !meta.isWritable);\n        const header = {\n            numRequiredSignatures: writableSigners.length + readonlySigners.length,\n            numReadonlySignedAccounts: readonlySigners.length,\n            numReadonlyUnsignedAccounts: readonlyNonSigners.length\n        };\n        // sanity checks\n        {\n            assert(writableSigners.length > 0, \"Expected at least one writable signer key\");\n            const [payerAddress] = writableSigners[0];\n            assert(payerAddress === this.payer.toBase58(), \"Expected first writable signer key to be the fee payer\");\n        }\n        const staticAccountKeys = [\n            ...writableSigners.map(([address])=>new PublicKey(address)),\n            ...readonlySigners.map(([address])=>new PublicKey(address)),\n            ...writableNonSigners.map(([address])=>new PublicKey(address)),\n            ...readonlyNonSigners.map(([address])=>new PublicKey(address))\n        ];\n        return [\n            header,\n            staticAccountKeys\n        ];\n    }\n    extractTableLookup(lookupTable) {\n        const [writableIndexes, drainedWritableKeys] = this.drainKeysFoundInLookupTable(lookupTable.state.addresses, (keyMeta)=>!keyMeta.isSigner && !keyMeta.isInvoked && keyMeta.isWritable);\n        const [readonlyIndexes, drainedReadonlyKeys] = this.drainKeysFoundInLookupTable(lookupTable.state.addresses, (keyMeta)=>!keyMeta.isSigner && !keyMeta.isInvoked && !keyMeta.isWritable);\n        // Don't extract lookup if no keys were found\n        if (writableIndexes.length === 0 && readonlyIndexes.length === 0) {\n            return;\n        }\n        return [\n            {\n                accountKey: lookupTable.key,\n                writableIndexes,\n                readonlyIndexes\n            },\n            {\n                writable: drainedWritableKeys,\n                readonly: drainedReadonlyKeys\n            }\n        ];\n    }\n    /** @internal */ drainKeysFoundInLookupTable(lookupTableEntries, keyMetaFilter) {\n        const lookupTableIndexes = new Array();\n        const drainedKeys = new Array();\n        for (const [address, keyMeta] of this.keyMetaMap.entries()){\n            if (keyMetaFilter(keyMeta)) {\n                const key = new PublicKey(address);\n                const lookupTableIndex = lookupTableEntries.findIndex((entry)=>entry.equals(key));\n                if (lookupTableIndex >= 0) {\n                    assert(lookupTableIndex < 256, \"Max lookup table index exceeded\");\n                    lookupTableIndexes.push(lookupTableIndex);\n                    drainedKeys.push(key);\n                    this.keyMetaMap.delete(address);\n                }\n            }\n        }\n        return [\n            lookupTableIndexes,\n            drainedKeys\n        ];\n    }\n}\nconst END_OF_BUFFER_ERROR_MESSAGE = \"Reached end of buffer unexpectedly\";\n/**\n * Delegates to `Array#shift`, but throws if the array is zero-length.\n */ function guardedShift(byteArray) {\n    if (byteArray.length === 0) {\n        throw new Error(END_OF_BUFFER_ERROR_MESSAGE);\n    }\n    return byteArray.shift();\n}\n/**\n * Delegates to `Array#splice`, but throws if the section being spliced out extends past the end of\n * the array.\n */ function guardedSplice(byteArray, ...args) {\n    const [start] = args;\n    if (args.length === 2 // Implies that `deleteCount` was supplied\n     ? start + (args[1] ?? 0) > byteArray.length : start >= byteArray.length) {\n        throw new Error(END_OF_BUFFER_ERROR_MESSAGE);\n    }\n    return byteArray.splice(...args);\n}\n/**\n * An instruction to execute by a program\n *\n * @property {number} programIdIndex\n * @property {number[]} accounts\n * @property {string} data\n */ /**\n * Message constructor arguments\n */ /**\n * List of instructions to be processed atomically\n */ class Message {\n    constructor(args){\n        this.header = void 0;\n        this.accountKeys = void 0;\n        this.recentBlockhash = void 0;\n        this.instructions = void 0;\n        this.indexToProgramIds = new Map();\n        this.header = args.header;\n        this.accountKeys = args.accountKeys.map((account)=>new PublicKey(account));\n        this.recentBlockhash = args.recentBlockhash;\n        this.instructions = args.instructions;\n        this.instructions.forEach((ix)=>this.indexToProgramIds.set(ix.programIdIndex, this.accountKeys[ix.programIdIndex]));\n    }\n    get version() {\n        return \"legacy\";\n    }\n    get staticAccountKeys() {\n        return this.accountKeys;\n    }\n    get compiledInstructions() {\n        return this.instructions.map((ix)=>({\n                programIdIndex: ix.programIdIndex,\n                accountKeyIndexes: ix.accounts,\n                data: bs58__WEBPACK_IMPORTED_MODULE_2___default().decode(ix.data)\n            }));\n    }\n    get addressTableLookups() {\n        return [];\n    }\n    getAccountKeys() {\n        return new MessageAccountKeys(this.staticAccountKeys);\n    }\n    static compile(args) {\n        const compiledKeys = CompiledKeys.compile(args.instructions, args.payerKey);\n        const [header, staticAccountKeys] = compiledKeys.getMessageComponents();\n        const accountKeys = new MessageAccountKeys(staticAccountKeys);\n        const instructions = accountKeys.compileInstructions(args.instructions).map((ix)=>({\n                programIdIndex: ix.programIdIndex,\n                accounts: ix.accountKeyIndexes,\n                data: bs58__WEBPACK_IMPORTED_MODULE_2___default().encode(ix.data)\n            }));\n        return new Message({\n            header,\n            accountKeys: staticAccountKeys,\n            recentBlockhash: args.recentBlockhash,\n            instructions\n        });\n    }\n    isAccountSigner(index) {\n        return index < this.header.numRequiredSignatures;\n    }\n    isAccountWritable(index) {\n        const numSignedAccounts = this.header.numRequiredSignatures;\n        if (index >= this.header.numRequiredSignatures) {\n            const unsignedAccountIndex = index - numSignedAccounts;\n            const numUnsignedAccounts = this.accountKeys.length - numSignedAccounts;\n            const numWritableUnsignedAccounts = numUnsignedAccounts - this.header.numReadonlyUnsignedAccounts;\n            return unsignedAccountIndex < numWritableUnsignedAccounts;\n        } else {\n            const numWritableSignedAccounts = numSignedAccounts - this.header.numReadonlySignedAccounts;\n            return index < numWritableSignedAccounts;\n        }\n    }\n    isProgramId(index) {\n        return this.indexToProgramIds.has(index);\n    }\n    programIds() {\n        return [\n            ...this.indexToProgramIds.values()\n        ];\n    }\n    nonProgramIds() {\n        return this.accountKeys.filter((_, index)=>!this.isProgramId(index));\n    }\n    serialize() {\n        const numKeys = this.accountKeys.length;\n        let keyCount = [];\n        encodeLength(keyCount, numKeys);\n        const instructions = this.instructions.map((instruction)=>{\n            const { accounts, programIdIndex } = instruction;\n            const data = Array.from(bs58__WEBPACK_IMPORTED_MODULE_2___default().decode(instruction.data));\n            let keyIndicesCount = [];\n            encodeLength(keyIndicesCount, accounts.length);\n            let dataCount = [];\n            encodeLength(dataCount, data.length);\n            return {\n                programIdIndex,\n                keyIndicesCount: buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.from(keyIndicesCount),\n                keyIndices: accounts,\n                dataLength: buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.from(dataCount),\n                data\n            };\n        });\n        let instructionCount = [];\n        encodeLength(instructionCount, instructions.length);\n        let instructionBuffer = buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.alloc(PACKET_DATA_SIZE);\n        buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.from(instructionCount).copy(instructionBuffer);\n        let instructionBufferLength = instructionCount.length;\n        instructions.forEach((instruction)=>{\n            const instructionLayout = _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.struct([\n                _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u8(\"programIdIndex\"),\n                _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.blob(instruction.keyIndicesCount.length, \"keyIndicesCount\"),\n                _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.seq(_solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u8(\"keyIndex\"), instruction.keyIndices.length, \"keyIndices\"),\n                _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.blob(instruction.dataLength.length, \"dataLength\"),\n                _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.seq(_solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u8(\"userdatum\"), instruction.data.length, \"data\")\n            ]);\n            const length = instructionLayout.encode(instruction, instructionBuffer, instructionBufferLength);\n            instructionBufferLength += length;\n        });\n        instructionBuffer = instructionBuffer.slice(0, instructionBufferLength);\n        const signDataLayout = _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.struct([\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.blob(1, \"numRequiredSignatures\"),\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.blob(1, \"numReadonlySignedAccounts\"),\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.blob(1, \"numReadonlyUnsignedAccounts\"),\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.blob(keyCount.length, \"keyCount\"),\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.seq(publicKey(\"key\"), numKeys, \"keys\"),\n            publicKey(\"recentBlockhash\")\n        ]);\n        const transaction = {\n            numRequiredSignatures: buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.from([\n                this.header.numRequiredSignatures\n            ]),\n            numReadonlySignedAccounts: buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.from([\n                this.header.numReadonlySignedAccounts\n            ]),\n            numReadonlyUnsignedAccounts: buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.from([\n                this.header.numReadonlyUnsignedAccounts\n            ]),\n            keyCount: buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.from(keyCount),\n            keys: this.accountKeys.map((key)=>toBuffer(key.toBytes())),\n            recentBlockhash: bs58__WEBPACK_IMPORTED_MODULE_2___default().decode(this.recentBlockhash)\n        };\n        let signData = buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.alloc(2048);\n        const length = signDataLayout.encode(transaction, signData);\n        instructionBuffer.copy(signData, length);\n        return signData.slice(0, length + instructionBuffer.length);\n    }\n    /**\n   * Decode a compiled message into a Message object.\n   */ static from(buffer) {\n        // Slice up wire data\n        let byteArray = [\n            ...buffer\n        ];\n        const numRequiredSignatures = guardedShift(byteArray);\n        if (numRequiredSignatures !== (numRequiredSignatures & VERSION_PREFIX_MASK)) {\n            throw new Error(\"Versioned messages must be deserialized with VersionedMessage.deserialize()\");\n        }\n        const numReadonlySignedAccounts = guardedShift(byteArray);\n        const numReadonlyUnsignedAccounts = guardedShift(byteArray);\n        const accountCount = decodeLength(byteArray);\n        let accountKeys = [];\n        for(let i = 0; i < accountCount; i++){\n            const account = guardedSplice(byteArray, 0, PUBLIC_KEY_LENGTH);\n            accountKeys.push(new PublicKey(buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.from(account)));\n        }\n        const recentBlockhash = guardedSplice(byteArray, 0, PUBLIC_KEY_LENGTH);\n        const instructionCount = decodeLength(byteArray);\n        let instructions = [];\n        for(let i = 0; i < instructionCount; i++){\n            const programIdIndex = guardedShift(byteArray);\n            const accountCount = decodeLength(byteArray);\n            const accounts = guardedSplice(byteArray, 0, accountCount);\n            const dataLength = decodeLength(byteArray);\n            const dataSlice = guardedSplice(byteArray, 0, dataLength);\n            const data = bs58__WEBPACK_IMPORTED_MODULE_2___default().encode(buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.from(dataSlice));\n            instructions.push({\n                programIdIndex,\n                accounts,\n                data\n            });\n        }\n        const messageArgs = {\n            header: {\n                numRequiredSignatures,\n                numReadonlySignedAccounts,\n                numReadonlyUnsignedAccounts\n            },\n            recentBlockhash: bs58__WEBPACK_IMPORTED_MODULE_2___default().encode(buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.from(recentBlockhash)),\n            accountKeys,\n            instructions\n        };\n        return new Message(messageArgs);\n    }\n}\n/**\n * Message constructor arguments\n */ class MessageV0 {\n    constructor(args){\n        this.header = void 0;\n        this.staticAccountKeys = void 0;\n        this.recentBlockhash = void 0;\n        this.compiledInstructions = void 0;\n        this.addressTableLookups = void 0;\n        this.header = args.header;\n        this.staticAccountKeys = args.staticAccountKeys;\n        this.recentBlockhash = args.recentBlockhash;\n        this.compiledInstructions = args.compiledInstructions;\n        this.addressTableLookups = args.addressTableLookups;\n    }\n    get version() {\n        return 0;\n    }\n    get numAccountKeysFromLookups() {\n        let count = 0;\n        for (const lookup of this.addressTableLookups){\n            count += lookup.readonlyIndexes.length + lookup.writableIndexes.length;\n        }\n        return count;\n    }\n    getAccountKeys(args) {\n        let accountKeysFromLookups;\n        if (args && \"accountKeysFromLookups\" in args && args.accountKeysFromLookups) {\n            if (this.numAccountKeysFromLookups != args.accountKeysFromLookups.writable.length + args.accountKeysFromLookups.readonly.length) {\n                throw new Error(\"Failed to get account keys because of a mismatch in the number of account keys from lookups\");\n            }\n            accountKeysFromLookups = args.accountKeysFromLookups;\n        } else if (args && \"addressLookupTableAccounts\" in args && args.addressLookupTableAccounts) {\n            accountKeysFromLookups = this.resolveAddressTableLookups(args.addressLookupTableAccounts);\n        } else if (this.addressTableLookups.length > 0) {\n            throw new Error(\"Failed to get account keys because address table lookups were not resolved\");\n        }\n        return new MessageAccountKeys(this.staticAccountKeys, accountKeysFromLookups);\n    }\n    isAccountSigner(index) {\n        return index < this.header.numRequiredSignatures;\n    }\n    isAccountWritable(index) {\n        const numSignedAccounts = this.header.numRequiredSignatures;\n        const numStaticAccountKeys = this.staticAccountKeys.length;\n        if (index >= numStaticAccountKeys) {\n            const lookupAccountKeysIndex = index - numStaticAccountKeys;\n            const numWritableLookupAccountKeys = this.addressTableLookups.reduce((count, lookup)=>count + lookup.writableIndexes.length, 0);\n            return lookupAccountKeysIndex < numWritableLookupAccountKeys;\n        } else if (index >= this.header.numRequiredSignatures) {\n            const unsignedAccountIndex = index - numSignedAccounts;\n            const numUnsignedAccounts = numStaticAccountKeys - numSignedAccounts;\n            const numWritableUnsignedAccounts = numUnsignedAccounts - this.header.numReadonlyUnsignedAccounts;\n            return unsignedAccountIndex < numWritableUnsignedAccounts;\n        } else {\n            const numWritableSignedAccounts = numSignedAccounts - this.header.numReadonlySignedAccounts;\n            return index < numWritableSignedAccounts;\n        }\n    }\n    resolveAddressTableLookups(addressLookupTableAccounts) {\n        const accountKeysFromLookups = {\n            writable: [],\n            readonly: []\n        };\n        for (const tableLookup of this.addressTableLookups){\n            const tableAccount = addressLookupTableAccounts.find((account)=>account.key.equals(tableLookup.accountKey));\n            if (!tableAccount) {\n                throw new Error(`Failed to find address lookup table account for table key ${tableLookup.accountKey.toBase58()}`);\n            }\n            for (const index of tableLookup.writableIndexes){\n                if (index < tableAccount.state.addresses.length) {\n                    accountKeysFromLookups.writable.push(tableAccount.state.addresses[index]);\n                } else {\n                    throw new Error(`Failed to find address for index ${index} in address lookup table ${tableLookup.accountKey.toBase58()}`);\n                }\n            }\n            for (const index of tableLookup.readonlyIndexes){\n                if (index < tableAccount.state.addresses.length) {\n                    accountKeysFromLookups.readonly.push(tableAccount.state.addresses[index]);\n                } else {\n                    throw new Error(`Failed to find address for index ${index} in address lookup table ${tableLookup.accountKey.toBase58()}`);\n                }\n            }\n        }\n        return accountKeysFromLookups;\n    }\n    static compile(args) {\n        const compiledKeys = CompiledKeys.compile(args.instructions, args.payerKey);\n        const addressTableLookups = new Array();\n        const accountKeysFromLookups = {\n            writable: new Array(),\n            readonly: new Array()\n        };\n        const lookupTableAccounts = args.addressLookupTableAccounts || [];\n        for (const lookupTable of lookupTableAccounts){\n            const extractResult = compiledKeys.extractTableLookup(lookupTable);\n            if (extractResult !== undefined) {\n                const [addressTableLookup, { writable, readonly }] = extractResult;\n                addressTableLookups.push(addressTableLookup);\n                accountKeysFromLookups.writable.push(...writable);\n                accountKeysFromLookups.readonly.push(...readonly);\n            }\n        }\n        const [header, staticAccountKeys] = compiledKeys.getMessageComponents();\n        const accountKeys = new MessageAccountKeys(staticAccountKeys, accountKeysFromLookups);\n        const compiledInstructions = accountKeys.compileInstructions(args.instructions);\n        return new MessageV0({\n            header,\n            staticAccountKeys,\n            recentBlockhash: args.recentBlockhash,\n            compiledInstructions,\n            addressTableLookups\n        });\n    }\n    serialize() {\n        const encodedStaticAccountKeysLength = Array();\n        encodeLength(encodedStaticAccountKeysLength, this.staticAccountKeys.length);\n        const serializedInstructions = this.serializeInstructions();\n        const encodedInstructionsLength = Array();\n        encodeLength(encodedInstructionsLength, this.compiledInstructions.length);\n        const serializedAddressTableLookups = this.serializeAddressTableLookups();\n        const encodedAddressTableLookupsLength = Array();\n        encodeLength(encodedAddressTableLookupsLength, this.addressTableLookups.length);\n        const messageLayout = _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.struct([\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u8(\"prefix\"),\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.struct([\n                _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u8(\"numRequiredSignatures\"),\n                _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u8(\"numReadonlySignedAccounts\"),\n                _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u8(\"numReadonlyUnsignedAccounts\")\n            ], \"header\"),\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.blob(encodedStaticAccountKeysLength.length, \"staticAccountKeysLength\"),\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.seq(publicKey(), this.staticAccountKeys.length, \"staticAccountKeys\"),\n            publicKey(\"recentBlockhash\"),\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.blob(encodedInstructionsLength.length, \"instructionsLength\"),\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.blob(serializedInstructions.length, \"serializedInstructions\"),\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.blob(encodedAddressTableLookupsLength.length, \"addressTableLookupsLength\"),\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.blob(serializedAddressTableLookups.length, \"serializedAddressTableLookups\")\n        ]);\n        const serializedMessage = new Uint8Array(PACKET_DATA_SIZE);\n        const MESSAGE_VERSION_0_PREFIX = 1 << 7;\n        const serializedMessageLength = messageLayout.encode({\n            prefix: MESSAGE_VERSION_0_PREFIX,\n            header: this.header,\n            staticAccountKeysLength: new Uint8Array(encodedStaticAccountKeysLength),\n            staticAccountKeys: this.staticAccountKeys.map((key)=>key.toBytes()),\n            recentBlockhash: bs58__WEBPACK_IMPORTED_MODULE_2___default().decode(this.recentBlockhash),\n            instructionsLength: new Uint8Array(encodedInstructionsLength),\n            serializedInstructions,\n            addressTableLookupsLength: new Uint8Array(encodedAddressTableLookupsLength),\n            serializedAddressTableLookups\n        }, serializedMessage);\n        return serializedMessage.slice(0, serializedMessageLength);\n    }\n    serializeInstructions() {\n        let serializedLength = 0;\n        const serializedInstructions = new Uint8Array(PACKET_DATA_SIZE);\n        for (const instruction of this.compiledInstructions){\n            const encodedAccountKeyIndexesLength = Array();\n            encodeLength(encodedAccountKeyIndexesLength, instruction.accountKeyIndexes.length);\n            const encodedDataLength = Array();\n            encodeLength(encodedDataLength, instruction.data.length);\n            const instructionLayout = _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.struct([\n                _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u8(\"programIdIndex\"),\n                _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.blob(encodedAccountKeyIndexesLength.length, \"encodedAccountKeyIndexesLength\"),\n                _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.seq(_solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u8(), instruction.accountKeyIndexes.length, \"accountKeyIndexes\"),\n                _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.blob(encodedDataLength.length, \"encodedDataLength\"),\n                _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.blob(instruction.data.length, \"data\")\n            ]);\n            serializedLength += instructionLayout.encode({\n                programIdIndex: instruction.programIdIndex,\n                encodedAccountKeyIndexesLength: new Uint8Array(encodedAccountKeyIndexesLength),\n                accountKeyIndexes: instruction.accountKeyIndexes,\n                encodedDataLength: new Uint8Array(encodedDataLength),\n                data: instruction.data\n            }, serializedInstructions, serializedLength);\n        }\n        return serializedInstructions.slice(0, serializedLength);\n    }\n    serializeAddressTableLookups() {\n        let serializedLength = 0;\n        const serializedAddressTableLookups = new Uint8Array(PACKET_DATA_SIZE);\n        for (const lookup of this.addressTableLookups){\n            const encodedWritableIndexesLength = Array();\n            encodeLength(encodedWritableIndexesLength, lookup.writableIndexes.length);\n            const encodedReadonlyIndexesLength = Array();\n            encodeLength(encodedReadonlyIndexesLength, lookup.readonlyIndexes.length);\n            const addressTableLookupLayout = _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.struct([\n                publicKey(\"accountKey\"),\n                _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.blob(encodedWritableIndexesLength.length, \"encodedWritableIndexesLength\"),\n                _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.seq(_solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u8(), lookup.writableIndexes.length, \"writableIndexes\"),\n                _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.blob(encodedReadonlyIndexesLength.length, \"encodedReadonlyIndexesLength\"),\n                _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.seq(_solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u8(), lookup.readonlyIndexes.length, \"readonlyIndexes\")\n            ]);\n            serializedLength += addressTableLookupLayout.encode({\n                accountKey: lookup.accountKey.toBytes(),\n                encodedWritableIndexesLength: new Uint8Array(encodedWritableIndexesLength),\n                writableIndexes: lookup.writableIndexes,\n                encodedReadonlyIndexesLength: new Uint8Array(encodedReadonlyIndexesLength),\n                readonlyIndexes: lookup.readonlyIndexes\n            }, serializedAddressTableLookups, serializedLength);\n        }\n        return serializedAddressTableLookups.slice(0, serializedLength);\n    }\n    static deserialize(serializedMessage) {\n        let byteArray = [\n            ...serializedMessage\n        ];\n        const prefix = guardedShift(byteArray);\n        const maskedPrefix = prefix & VERSION_PREFIX_MASK;\n        assert(prefix !== maskedPrefix, `Expected versioned message but received legacy message`);\n        const version = maskedPrefix;\n        assert(version === 0, `Expected versioned message with version 0 but found version ${version}`);\n        const header = {\n            numRequiredSignatures: guardedShift(byteArray),\n            numReadonlySignedAccounts: guardedShift(byteArray),\n            numReadonlyUnsignedAccounts: guardedShift(byteArray)\n        };\n        const staticAccountKeys = [];\n        const staticAccountKeysLength = decodeLength(byteArray);\n        for(let i = 0; i < staticAccountKeysLength; i++){\n            staticAccountKeys.push(new PublicKey(guardedSplice(byteArray, 0, PUBLIC_KEY_LENGTH)));\n        }\n        const recentBlockhash = bs58__WEBPACK_IMPORTED_MODULE_2___default().encode(guardedSplice(byteArray, 0, PUBLIC_KEY_LENGTH));\n        const instructionCount = decodeLength(byteArray);\n        const compiledInstructions = [];\n        for(let i = 0; i < instructionCount; i++){\n            const programIdIndex = guardedShift(byteArray);\n            const accountKeyIndexesLength = decodeLength(byteArray);\n            const accountKeyIndexes = guardedSplice(byteArray, 0, accountKeyIndexesLength);\n            const dataLength = decodeLength(byteArray);\n            const data = new Uint8Array(guardedSplice(byteArray, 0, dataLength));\n            compiledInstructions.push({\n                programIdIndex,\n                accountKeyIndexes,\n                data\n            });\n        }\n        const addressTableLookupsCount = decodeLength(byteArray);\n        const addressTableLookups = [];\n        for(let i = 0; i < addressTableLookupsCount; i++){\n            const accountKey = new PublicKey(guardedSplice(byteArray, 0, PUBLIC_KEY_LENGTH));\n            const writableIndexesLength = decodeLength(byteArray);\n            const writableIndexes = guardedSplice(byteArray, 0, writableIndexesLength);\n            const readonlyIndexesLength = decodeLength(byteArray);\n            const readonlyIndexes = guardedSplice(byteArray, 0, readonlyIndexesLength);\n            addressTableLookups.push({\n                accountKey,\n                writableIndexes,\n                readonlyIndexes\n            });\n        }\n        return new MessageV0({\n            header,\n            staticAccountKeys,\n            recentBlockhash,\n            compiledInstructions,\n            addressTableLookups\n        });\n    }\n}\n// eslint-disable-next-line no-redeclare\nconst VersionedMessage = {\n    deserializeMessageVersion (serializedMessage) {\n        const prefix = serializedMessage[0];\n        const maskedPrefix = prefix & VERSION_PREFIX_MASK;\n        // if the highest bit of the prefix is not set, the message is not versioned\n        if (maskedPrefix === prefix) {\n            return \"legacy\";\n        }\n        // the lower 7 bits of the prefix indicate the message version\n        return maskedPrefix;\n    },\n    deserialize: (serializedMessage)=>{\n        const version = VersionedMessage.deserializeMessageVersion(serializedMessage);\n        if (version === \"legacy\") {\n            return Message.from(serializedMessage);\n        }\n        if (version === 0) {\n            return MessageV0.deserialize(serializedMessage);\n        } else {\n            throw new Error(`Transaction message version ${version} deserialization is not supported`);\n        }\n    }\n};\n/** @internal */ /**\n * Transaction signature as base-58 encoded string\n */ let TransactionStatus = /*#__PURE__*/ function(TransactionStatus) {\n    TransactionStatus[TransactionStatus[\"BLOCKHEIGHT_EXCEEDED\"] = 0] = \"BLOCKHEIGHT_EXCEEDED\";\n    TransactionStatus[TransactionStatus[\"PROCESSED\"] = 1] = \"PROCESSED\";\n    TransactionStatus[TransactionStatus[\"TIMED_OUT\"] = 2] = \"TIMED_OUT\";\n    TransactionStatus[TransactionStatus[\"NONCE_INVALID\"] = 3] = \"NONCE_INVALID\";\n    return TransactionStatus;\n}({});\n/**\n * Default (empty) signature\n */ const DEFAULT_SIGNATURE = buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.alloc(SIGNATURE_LENGTH_IN_BYTES).fill(0);\n/**\n * Account metadata used to define instructions\n */ /**\n * List of TransactionInstruction object fields that may be initialized at construction\n */ /**\n * Configuration object for Transaction.serialize()\n */ /**\n * @internal\n */ /**\n * Transaction Instruction class\n */ class TransactionInstruction {\n    constructor(opts){\n        /**\n     * Public keys to include in this transaction\n     * Boolean represents whether this pubkey needs to sign the transaction\n     */ this.keys = void 0;\n        /**\n     * Program Id to execute\n     */ this.programId = void 0;\n        /**\n     * Program input\n     */ this.data = buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.alloc(0);\n        this.programId = opts.programId;\n        this.keys = opts.keys;\n        if (opts.data) {\n            this.data = opts.data;\n        }\n    }\n    /**\n   * @internal\n   */ toJSON() {\n        return {\n            keys: this.keys.map(({ pubkey, isSigner, isWritable })=>({\n                    pubkey: pubkey.toJSON(),\n                    isSigner,\n                    isWritable\n                })),\n            programId: this.programId.toJSON(),\n            data: [\n                ...this.data\n            ]\n        };\n    }\n}\n/**\n * Pair of signature and corresponding public key\n */ /**\n * List of Transaction object fields that may be initialized at construction\n */ // For backward compatibility; an unfortunate consequence of being\n// forced to over-export types by the documentation generator.\n// See https://github.com/solana-labs/solana/pull/25820\n/**\n * Blockhash-based transactions have a lifetime that are defined by\n * the blockhash they include. Any transaction whose blockhash is\n * too old will be rejected.\n */ /**\n * Use these options to construct a durable nonce transaction.\n */ /**\n * Nonce information to be used to build an offline Transaction.\n */ /**\n * @internal\n */ /**\n * Transaction class\n */ class Transaction {\n    /**\n   * The first (payer) Transaction signature\n   *\n   * @returns {Buffer | null} Buffer of payer's signature\n   */ get signature() {\n        if (this.signatures.length > 0) {\n            return this.signatures[0].signature;\n        }\n        return null;\n    }\n    /**\n   * The transaction fee payer\n   */ // Construct a transaction with a blockhash and lastValidBlockHeight\n    // Construct a transaction using a durable nonce\n    /**\n   * @deprecated `TransactionCtorFields` has been deprecated and will be removed in a future version.\n   * Please supply a `TransactionBlockhashCtor` instead.\n   */ /**\n   * Construct an empty Transaction\n   */ constructor(opts){\n        /**\n     * Signatures for the transaction.  Typically created by invoking the\n     * `sign()` method\n     */ this.signatures = [];\n        this.feePayer = void 0;\n        /**\n     * The instructions to atomically execute\n     */ this.instructions = [];\n        /**\n     * A recent transaction id. Must be populated by the caller\n     */ this.recentBlockhash = void 0;\n        /**\n     * the last block chain can advance to before tx is declared expired\n     * */ this.lastValidBlockHeight = void 0;\n        /**\n     * Optional Nonce information. If populated, transaction will use a durable\n     * Nonce hash instead of a recentBlockhash. Must be populated by the caller\n     */ this.nonceInfo = void 0;\n        /**\n     * If this is a nonce transaction this represents the minimum slot from which\n     * to evaluate if the nonce has advanced when attempting to confirm the\n     * transaction. This protects against a case where the transaction confirmation\n     * logic loads the nonce account from an old slot and assumes the mismatch in\n     * nonce value implies that the nonce has been advanced.\n     */ this.minNonceContextSlot = void 0;\n        /**\n     * @internal\n     */ this._message = void 0;\n        /**\n     * @internal\n     */ this._json = void 0;\n        if (!opts) {\n            return;\n        }\n        if (opts.feePayer) {\n            this.feePayer = opts.feePayer;\n        }\n        if (opts.signatures) {\n            this.signatures = opts.signatures;\n        }\n        if (Object.prototype.hasOwnProperty.call(opts, \"nonceInfo\")) {\n            const { minContextSlot, nonceInfo } = opts;\n            this.minNonceContextSlot = minContextSlot;\n            this.nonceInfo = nonceInfo;\n        } else if (Object.prototype.hasOwnProperty.call(opts, \"lastValidBlockHeight\")) {\n            const { blockhash, lastValidBlockHeight } = opts;\n            this.recentBlockhash = blockhash;\n            this.lastValidBlockHeight = lastValidBlockHeight;\n        } else {\n            const { recentBlockhash, nonceInfo } = opts;\n            if (nonceInfo) {\n                this.nonceInfo = nonceInfo;\n            }\n            this.recentBlockhash = recentBlockhash;\n        }\n    }\n    /**\n   * @internal\n   */ toJSON() {\n        return {\n            recentBlockhash: this.recentBlockhash || null,\n            feePayer: this.feePayer ? this.feePayer.toJSON() : null,\n            nonceInfo: this.nonceInfo ? {\n                nonce: this.nonceInfo.nonce,\n                nonceInstruction: this.nonceInfo.nonceInstruction.toJSON()\n            } : null,\n            instructions: this.instructions.map((instruction)=>instruction.toJSON()),\n            signers: this.signatures.map(({ publicKey })=>{\n                return publicKey.toJSON();\n            })\n        };\n    }\n    /**\n   * Add one or more instructions to this Transaction\n   *\n   * @param {Array< Transaction | TransactionInstruction | TransactionInstructionCtorFields >} items - Instructions to add to the Transaction\n   */ add(...items) {\n        if (items.length === 0) {\n            throw new Error(\"No instructions\");\n        }\n        items.forEach((item)=>{\n            if (\"instructions\" in item) {\n                this.instructions = this.instructions.concat(item.instructions);\n            } else if (\"data\" in item && \"programId\" in item && \"keys\" in item) {\n                this.instructions.push(item);\n            } else {\n                this.instructions.push(new TransactionInstruction(item));\n            }\n        });\n        return this;\n    }\n    /**\n   * Compile transaction data\n   */ compileMessage() {\n        if (this._message && JSON.stringify(this.toJSON()) === JSON.stringify(this._json)) {\n            return this._message;\n        }\n        let recentBlockhash;\n        let instructions;\n        if (this.nonceInfo) {\n            recentBlockhash = this.nonceInfo.nonce;\n            if (this.instructions[0] != this.nonceInfo.nonceInstruction) {\n                instructions = [\n                    this.nonceInfo.nonceInstruction,\n                    ...this.instructions\n                ];\n            } else {\n                instructions = this.instructions;\n            }\n        } else {\n            recentBlockhash = this.recentBlockhash;\n            instructions = this.instructions;\n        }\n        if (!recentBlockhash) {\n            throw new Error(\"Transaction recentBlockhash required\");\n        }\n        if (instructions.length < 1) {\n            console.warn(\"No instructions provided\");\n        }\n        let feePayer;\n        if (this.feePayer) {\n            feePayer = this.feePayer;\n        } else if (this.signatures.length > 0 && this.signatures[0].publicKey) {\n            // Use implicit fee payer\n            feePayer = this.signatures[0].publicKey;\n        } else {\n            throw new Error(\"Transaction fee payer required\");\n        }\n        for(let i = 0; i < instructions.length; i++){\n            if (instructions[i].programId === undefined) {\n                throw new Error(`Transaction instruction index ${i} has undefined program id`);\n            }\n        }\n        const programIds = [];\n        const accountMetas = [];\n        instructions.forEach((instruction)=>{\n            instruction.keys.forEach((accountMeta)=>{\n                accountMetas.push({\n                    ...accountMeta\n                });\n            });\n            const programId = instruction.programId.toString();\n            if (!programIds.includes(programId)) {\n                programIds.push(programId);\n            }\n        });\n        // Append programID account metas\n        programIds.forEach((programId)=>{\n            accountMetas.push({\n                pubkey: new PublicKey(programId),\n                isSigner: false,\n                isWritable: false\n            });\n        });\n        // Cull duplicate account metas\n        const uniqueMetas = [];\n        accountMetas.forEach((accountMeta)=>{\n            const pubkeyString = accountMeta.pubkey.toString();\n            const uniqueIndex = uniqueMetas.findIndex((x)=>{\n                return x.pubkey.toString() === pubkeyString;\n            });\n            if (uniqueIndex > -1) {\n                uniqueMetas[uniqueIndex].isWritable = uniqueMetas[uniqueIndex].isWritable || accountMeta.isWritable;\n                uniqueMetas[uniqueIndex].isSigner = uniqueMetas[uniqueIndex].isSigner || accountMeta.isSigner;\n            } else {\n                uniqueMetas.push(accountMeta);\n            }\n        });\n        // Sort. Prioritizing first by signer, then by writable\n        uniqueMetas.sort(function(x, y) {\n            if (x.isSigner !== y.isSigner) {\n                // Signers always come before non-signers\n                return x.isSigner ? -1 : 1;\n            }\n            if (x.isWritable !== y.isWritable) {\n                // Writable accounts always come before read-only accounts\n                return x.isWritable ? -1 : 1;\n            }\n            // Otherwise, sort by pubkey, stringwise.\n            const options = {\n                localeMatcher: \"best fit\",\n                usage: \"sort\",\n                sensitivity: \"variant\",\n                ignorePunctuation: false,\n                numeric: false,\n                caseFirst: \"lower\"\n            };\n            return x.pubkey.toBase58().localeCompare(y.pubkey.toBase58(), \"en\", options);\n        });\n        // Move fee payer to the front\n        const feePayerIndex = uniqueMetas.findIndex((x)=>{\n            return x.pubkey.equals(feePayer);\n        });\n        if (feePayerIndex > -1) {\n            const [payerMeta] = uniqueMetas.splice(feePayerIndex, 1);\n            payerMeta.isSigner = true;\n            payerMeta.isWritable = true;\n            uniqueMetas.unshift(payerMeta);\n        } else {\n            uniqueMetas.unshift({\n                pubkey: feePayer,\n                isSigner: true,\n                isWritable: true\n            });\n        }\n        // Disallow unknown signers\n        for (const signature of this.signatures){\n            const uniqueIndex = uniqueMetas.findIndex((x)=>{\n                return x.pubkey.equals(signature.publicKey);\n            });\n            if (uniqueIndex > -1) {\n                if (!uniqueMetas[uniqueIndex].isSigner) {\n                    uniqueMetas[uniqueIndex].isSigner = true;\n                    console.warn(\"Transaction references a signature that is unnecessary, \" + \"only the fee payer and instruction signer accounts should sign a transaction. \" + \"This behavior is deprecated and will throw an error in the next major version release.\");\n                }\n            } else {\n                throw new Error(`unknown signer: ${signature.publicKey.toString()}`);\n            }\n        }\n        let numRequiredSignatures = 0;\n        let numReadonlySignedAccounts = 0;\n        let numReadonlyUnsignedAccounts = 0;\n        // Split out signing from non-signing keys and count header values\n        const signedKeys = [];\n        const unsignedKeys = [];\n        uniqueMetas.forEach(({ pubkey, isSigner, isWritable })=>{\n            if (isSigner) {\n                signedKeys.push(pubkey.toString());\n                numRequiredSignatures += 1;\n                if (!isWritable) {\n                    numReadonlySignedAccounts += 1;\n                }\n            } else {\n                unsignedKeys.push(pubkey.toString());\n                if (!isWritable) {\n                    numReadonlyUnsignedAccounts += 1;\n                }\n            }\n        });\n        const accountKeys = signedKeys.concat(unsignedKeys);\n        const compiledInstructions = instructions.map((instruction)=>{\n            const { data, programId } = instruction;\n            return {\n                programIdIndex: accountKeys.indexOf(programId.toString()),\n                accounts: instruction.keys.map((meta)=>accountKeys.indexOf(meta.pubkey.toString())),\n                data: bs58__WEBPACK_IMPORTED_MODULE_2___default().encode(data)\n            };\n        });\n        compiledInstructions.forEach((instruction)=>{\n            assert(instruction.programIdIndex >= 0);\n            instruction.accounts.forEach((keyIndex)=>assert(keyIndex >= 0));\n        });\n        return new Message({\n            header: {\n                numRequiredSignatures,\n                numReadonlySignedAccounts,\n                numReadonlyUnsignedAccounts\n            },\n            accountKeys,\n            recentBlockhash,\n            instructions: compiledInstructions\n        });\n    }\n    /**\n   * @internal\n   */ _compile() {\n        const message = this.compileMessage();\n        const signedKeys = message.accountKeys.slice(0, message.header.numRequiredSignatures);\n        if (this.signatures.length === signedKeys.length) {\n            const valid = this.signatures.every((pair, index)=>{\n                return signedKeys[index].equals(pair.publicKey);\n            });\n            if (valid) return message;\n        }\n        this.signatures = signedKeys.map((publicKey)=>({\n                signature: null,\n                publicKey\n            }));\n        return message;\n    }\n    /**\n   * Get a buffer of the Transaction data that need to be covered by signatures\n   */ serializeMessage() {\n        return this._compile().serialize();\n    }\n    /**\n   * Get the estimated fee associated with a transaction\n   *\n   * @param {Connection} connection Connection to RPC Endpoint.\n   *\n   * @returns {Promise<number | null>} The estimated fee for the transaction\n   */ async getEstimatedFee(connection) {\n        return (await connection.getFeeForMessage(this.compileMessage())).value;\n    }\n    /**\n   * Specify the public keys which will be used to sign the Transaction.\n   * The first signer will be used as the transaction fee payer account.\n   *\n   * Signatures can be added with either `partialSign` or `addSignature`\n   *\n   * @deprecated Deprecated since v0.84.0. Only the fee payer needs to be\n   * specified and it can be set in the Transaction constructor or with the\n   * `feePayer` property.\n   */ setSigners(...signers) {\n        if (signers.length === 0) {\n            throw new Error(\"No signers\");\n        }\n        const seen = new Set();\n        this.signatures = signers.filter((publicKey)=>{\n            const key = publicKey.toString();\n            if (seen.has(key)) {\n                return false;\n            } else {\n                seen.add(key);\n                return true;\n            }\n        }).map((publicKey)=>({\n                signature: null,\n                publicKey\n            }));\n    }\n    /**\n   * Sign the Transaction with the specified signers. Multiple signatures may\n   * be applied to a Transaction. The first signature is considered \"primary\"\n   * and is used identify and confirm transactions.\n   *\n   * If the Transaction `feePayer` is not set, the first signer will be used\n   * as the transaction fee payer account.\n   *\n   * Transaction fields should not be modified after the first call to `sign`,\n   * as doing so may invalidate the signature and cause the Transaction to be\n   * rejected.\n   *\n   * The Transaction must be assigned a valid `recentBlockhash` before invoking this method\n   *\n   * @param {Array<Signer>} signers Array of signers that will sign the transaction\n   */ sign(...signers) {\n        if (signers.length === 0) {\n            throw new Error(\"No signers\");\n        }\n        // Dedupe signers\n        const seen = new Set();\n        const uniqueSigners = [];\n        for (const signer of signers){\n            const key = signer.publicKey.toString();\n            if (seen.has(key)) {\n                continue;\n            } else {\n                seen.add(key);\n                uniqueSigners.push(signer);\n            }\n        }\n        this.signatures = uniqueSigners.map((signer)=>({\n                signature: null,\n                publicKey: signer.publicKey\n            }));\n        const message = this._compile();\n        this._partialSign(message, ...uniqueSigners);\n    }\n    /**\n   * Partially sign a transaction with the specified accounts. All accounts must\n   * correspond to either the fee payer or a signer account in the transaction\n   * instructions.\n   *\n   * All the caveats from the `sign` method apply to `partialSign`\n   *\n   * @param {Array<Signer>} signers Array of signers that will sign the transaction\n   */ partialSign(...signers) {\n        if (signers.length === 0) {\n            throw new Error(\"No signers\");\n        }\n        // Dedupe signers\n        const seen = new Set();\n        const uniqueSigners = [];\n        for (const signer of signers){\n            const key = signer.publicKey.toString();\n            if (seen.has(key)) {\n                continue;\n            } else {\n                seen.add(key);\n                uniqueSigners.push(signer);\n            }\n        }\n        const message = this._compile();\n        this._partialSign(message, ...uniqueSigners);\n    }\n    /**\n   * @internal\n   */ _partialSign(message, ...signers) {\n        const signData = message.serialize();\n        signers.forEach((signer)=>{\n            const signature = sign(signData, signer.secretKey);\n            this._addSignature(signer.publicKey, toBuffer(signature));\n        });\n    }\n    /**\n   * Add an externally created signature to a transaction. The public key\n   * must correspond to either the fee payer or a signer account in the transaction\n   * instructions.\n   *\n   * @param {PublicKey} pubkey Public key that will be added to the transaction.\n   * @param {Buffer} signature An externally created signature to add to the transaction.\n   */ addSignature(pubkey, signature) {\n        this._compile(); // Ensure signatures array is populated\n        this._addSignature(pubkey, signature);\n    }\n    /**\n   * @internal\n   */ _addSignature(pubkey, signature) {\n        assert(signature.length === 64);\n        const index = this.signatures.findIndex((sigpair)=>pubkey.equals(sigpair.publicKey));\n        if (index < 0) {\n            throw new Error(`unknown signer: ${pubkey.toString()}`);\n        }\n        this.signatures[index].signature = buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.from(signature);\n    }\n    /**\n   * Verify signatures of a Transaction\n   * Optional parameter specifies if we're expecting a fully signed Transaction or a partially signed one.\n   * If no boolean is provided, we expect a fully signed Transaction by default.\n   *\n   * @param {boolean} [requireAllSignatures=true] Require a fully signed Transaction\n   */ verifySignatures(requireAllSignatures = true) {\n        const signatureErrors = this._getMessageSignednessErrors(this.serializeMessage(), requireAllSignatures);\n        return !signatureErrors;\n    }\n    /**\n   * @internal\n   */ _getMessageSignednessErrors(message, requireAllSignatures) {\n        const errors = {};\n        for (const { signature, publicKey } of this.signatures){\n            if (signature === null) {\n                if (requireAllSignatures) {\n                    (errors.missing ||= []).push(publicKey);\n                }\n            } else {\n                if (!verify(signature, message, publicKey.toBytes())) {\n                    (errors.invalid ||= []).push(publicKey);\n                }\n            }\n        }\n        return errors.invalid || errors.missing ? errors : undefined;\n    }\n    /**\n   * Serialize the Transaction in the wire format.\n   *\n   * @param {Buffer} [config] Config of transaction.\n   *\n   * @returns {Buffer} Signature of transaction in wire format.\n   */ serialize(config) {\n        const { requireAllSignatures, verifySignatures } = Object.assign({\n            requireAllSignatures: true,\n            verifySignatures: true\n        }, config);\n        const signData = this.serializeMessage();\n        if (verifySignatures) {\n            const sigErrors = this._getMessageSignednessErrors(signData, requireAllSignatures);\n            if (sigErrors) {\n                let errorMessage = \"Signature verification failed.\";\n                if (sigErrors.invalid) {\n                    errorMessage += `\\nInvalid signature for public key${sigErrors.invalid.length === 1 ? \"\" : \"(s)\"} [\\`${sigErrors.invalid.map((p)=>p.toBase58()).join(\"`, `\")}\\`].`;\n                }\n                if (sigErrors.missing) {\n                    errorMessage += `\\nMissing signature for public key${sigErrors.missing.length === 1 ? \"\" : \"(s)\"} [\\`${sigErrors.missing.map((p)=>p.toBase58()).join(\"`, `\")}\\`].`;\n                }\n                throw new Error(errorMessage);\n            }\n        }\n        return this._serialize(signData);\n    }\n    /**\n   * @internal\n   */ _serialize(signData) {\n        const { signatures } = this;\n        const signatureCount = [];\n        encodeLength(signatureCount, signatures.length);\n        const transactionLength = signatureCount.length + signatures.length * 64 + signData.length;\n        const wireTransaction = buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.alloc(transactionLength);\n        assert(signatures.length < 256);\n        buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.from(signatureCount).copy(wireTransaction, 0);\n        signatures.forEach(({ signature }, index)=>{\n            if (signature !== null) {\n                assert(signature.length === 64, `signature has invalid length`);\n                buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.from(signature).copy(wireTransaction, signatureCount.length + index * 64);\n            }\n        });\n        signData.copy(wireTransaction, signatureCount.length + signatures.length * 64);\n        assert(wireTransaction.length <= PACKET_DATA_SIZE, `Transaction too large: ${wireTransaction.length} > ${PACKET_DATA_SIZE}`);\n        return wireTransaction;\n    }\n    /**\n   * Deprecated method\n   * @internal\n   */ get keys() {\n        assert(this.instructions.length === 1);\n        return this.instructions[0].keys.map((keyObj)=>keyObj.pubkey);\n    }\n    /**\n   * Deprecated method\n   * @internal\n   */ get programId() {\n        assert(this.instructions.length === 1);\n        return this.instructions[0].programId;\n    }\n    /**\n   * Deprecated method\n   * @internal\n   */ get data() {\n        assert(this.instructions.length === 1);\n        return this.instructions[0].data;\n    }\n    /**\n   * Parse a wire transaction into a Transaction object.\n   *\n   * @param {Buffer | Uint8Array | Array<number>} buffer Signature of wire Transaction\n   *\n   * @returns {Transaction} Transaction associated with the signature\n   */ static from(buffer) {\n        // Slice up wire data\n        let byteArray = [\n            ...buffer\n        ];\n        const signatureCount = decodeLength(byteArray);\n        let signatures = [];\n        for(let i = 0; i < signatureCount; i++){\n            const signature = guardedSplice(byteArray, 0, SIGNATURE_LENGTH_IN_BYTES);\n            signatures.push(bs58__WEBPACK_IMPORTED_MODULE_2___default().encode(buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.from(signature)));\n        }\n        return Transaction.populate(Message.from(byteArray), signatures);\n    }\n    /**\n   * Populate Transaction object from message and signatures\n   *\n   * @param {Message} message Message of transaction\n   * @param {Array<string>} signatures List of signatures to assign to the transaction\n   *\n   * @returns {Transaction} The populated Transaction\n   */ static populate(message, signatures = []) {\n        const transaction = new Transaction();\n        transaction.recentBlockhash = message.recentBlockhash;\n        if (message.header.numRequiredSignatures > 0) {\n            transaction.feePayer = message.accountKeys[0];\n        }\n        signatures.forEach((signature, index)=>{\n            const sigPubkeyPair = {\n                signature: signature == bs58__WEBPACK_IMPORTED_MODULE_2___default().encode(DEFAULT_SIGNATURE) ? null : bs58__WEBPACK_IMPORTED_MODULE_2___default().decode(signature),\n                publicKey: message.accountKeys[index]\n            };\n            transaction.signatures.push(sigPubkeyPair);\n        });\n        message.instructions.forEach((instruction)=>{\n            const keys = instruction.accounts.map((account)=>{\n                const pubkey = message.accountKeys[account];\n                return {\n                    pubkey,\n                    isSigner: transaction.signatures.some((keyObj)=>keyObj.publicKey.toString() === pubkey.toString()) || message.isAccountSigner(account),\n                    isWritable: message.isAccountWritable(account)\n                };\n            });\n            transaction.instructions.push(new TransactionInstruction({\n                keys,\n                programId: message.accountKeys[instruction.programIdIndex],\n                data: bs58__WEBPACK_IMPORTED_MODULE_2___default().decode(instruction.data)\n            }));\n        });\n        transaction._message = message;\n        transaction._json = transaction.toJSON();\n        return transaction;\n    }\n}\nclass TransactionMessage {\n    constructor(args){\n        this.payerKey = void 0;\n        this.instructions = void 0;\n        this.recentBlockhash = void 0;\n        this.payerKey = args.payerKey;\n        this.instructions = args.instructions;\n        this.recentBlockhash = args.recentBlockhash;\n    }\n    static decompile(message, args) {\n        const { header, compiledInstructions, recentBlockhash } = message;\n        const { numRequiredSignatures, numReadonlySignedAccounts, numReadonlyUnsignedAccounts } = header;\n        const numWritableSignedAccounts = numRequiredSignatures - numReadonlySignedAccounts;\n        assert(numWritableSignedAccounts > 0, \"Message header is invalid\");\n        const numWritableUnsignedAccounts = message.staticAccountKeys.length - numRequiredSignatures - numReadonlyUnsignedAccounts;\n        assert(numWritableUnsignedAccounts >= 0, \"Message header is invalid\");\n        const accountKeys = message.getAccountKeys(args);\n        const payerKey = accountKeys.get(0);\n        if (payerKey === undefined) {\n            throw new Error(\"Failed to decompile message because no account keys were found\");\n        }\n        const instructions = [];\n        for (const compiledIx of compiledInstructions){\n            const keys = [];\n            for (const keyIndex of compiledIx.accountKeyIndexes){\n                const pubkey = accountKeys.get(keyIndex);\n                if (pubkey === undefined) {\n                    throw new Error(`Failed to find key for account key index ${keyIndex}`);\n                }\n                const isSigner = keyIndex < numRequiredSignatures;\n                let isWritable;\n                if (isSigner) {\n                    isWritable = keyIndex < numWritableSignedAccounts;\n                } else if (keyIndex < accountKeys.staticAccountKeys.length) {\n                    isWritable = keyIndex - numRequiredSignatures < numWritableUnsignedAccounts;\n                } else {\n                    isWritable = keyIndex - accountKeys.staticAccountKeys.length < // accountKeysFromLookups cannot be undefined because we already found a pubkey for this index above\n                    accountKeys.accountKeysFromLookups.writable.length;\n                }\n                keys.push({\n                    pubkey,\n                    isSigner: keyIndex < header.numRequiredSignatures,\n                    isWritable\n                });\n            }\n            const programId = accountKeys.get(compiledIx.programIdIndex);\n            if (programId === undefined) {\n                throw new Error(`Failed to find program id for program id index ${compiledIx.programIdIndex}`);\n            }\n            instructions.push(new TransactionInstruction({\n                programId,\n                data: toBuffer(compiledIx.data),\n                keys\n            }));\n        }\n        return new TransactionMessage({\n            payerKey,\n            instructions,\n            recentBlockhash\n        });\n    }\n    compileToLegacyMessage() {\n        return Message.compile({\n            payerKey: this.payerKey,\n            recentBlockhash: this.recentBlockhash,\n            instructions: this.instructions\n        });\n    }\n    compileToV0Message(addressLookupTableAccounts) {\n        return MessageV0.compile({\n            payerKey: this.payerKey,\n            recentBlockhash: this.recentBlockhash,\n            instructions: this.instructions,\n            addressLookupTableAccounts\n        });\n    }\n}\n/**\n * Versioned transaction class\n */ class VersionedTransaction {\n    get version() {\n        return this.message.version;\n    }\n    constructor(message, signatures){\n        this.signatures = void 0;\n        this.message = void 0;\n        if (signatures !== undefined) {\n            assert(signatures.length === message.header.numRequiredSignatures, \"Expected signatures length to be equal to the number of required signatures\");\n            this.signatures = signatures;\n        } else {\n            const defaultSignatures = [];\n            for(let i = 0; i < message.header.numRequiredSignatures; i++){\n                defaultSignatures.push(new Uint8Array(SIGNATURE_LENGTH_IN_BYTES));\n            }\n            this.signatures = defaultSignatures;\n        }\n        this.message = message;\n    }\n    serialize() {\n        const serializedMessage = this.message.serialize();\n        const encodedSignaturesLength = Array();\n        encodeLength(encodedSignaturesLength, this.signatures.length);\n        const transactionLayout = _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.struct([\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.blob(encodedSignaturesLength.length, \"encodedSignaturesLength\"),\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.seq(signature(), this.signatures.length, \"signatures\"),\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.blob(serializedMessage.length, \"serializedMessage\")\n        ]);\n        const serializedTransaction = new Uint8Array(2048);\n        const serializedTransactionLength = transactionLayout.encode({\n            encodedSignaturesLength: new Uint8Array(encodedSignaturesLength),\n            signatures: this.signatures,\n            serializedMessage\n        }, serializedTransaction);\n        return serializedTransaction.slice(0, serializedTransactionLength);\n    }\n    static deserialize(serializedTransaction) {\n        let byteArray = [\n            ...serializedTransaction\n        ];\n        const signatures = [];\n        const signaturesLength = decodeLength(byteArray);\n        for(let i = 0; i < signaturesLength; i++){\n            signatures.push(new Uint8Array(guardedSplice(byteArray, 0, SIGNATURE_LENGTH_IN_BYTES)));\n        }\n        const message = VersionedMessage.deserialize(new Uint8Array(byteArray));\n        return new VersionedTransaction(message, signatures);\n    }\n    sign(signers) {\n        const messageData = this.message.serialize();\n        const signerPubkeys = this.message.staticAccountKeys.slice(0, this.message.header.numRequiredSignatures);\n        for (const signer of signers){\n            const signerIndex = signerPubkeys.findIndex((pubkey)=>pubkey.equals(signer.publicKey));\n            assert(signerIndex >= 0, `Cannot sign with non signer key ${signer.publicKey.toBase58()}`);\n            this.signatures[signerIndex] = sign(messageData, signer.secretKey);\n        }\n    }\n    addSignature(publicKey, signature) {\n        assert(signature.byteLength === 64, \"Signature must be 64 bytes long\");\n        const signerPubkeys = this.message.staticAccountKeys.slice(0, this.message.header.numRequiredSignatures);\n        const signerIndex = signerPubkeys.findIndex((pubkey)=>pubkey.equals(publicKey));\n        assert(signerIndex >= 0, `Can not add signature; \\`${publicKey.toBase58()}\\` is not required to sign this transaction`);\n        this.signatures[signerIndex] = signature;\n    }\n}\n// TODO: These constants should be removed in favor of reading them out of a\n// Syscall account\n/**\n * @internal\n */ const NUM_TICKS_PER_SECOND = 160;\n/**\n * @internal\n */ const DEFAULT_TICKS_PER_SLOT = 64;\n/**\n * @internal\n */ const NUM_SLOTS_PER_SECOND = NUM_TICKS_PER_SECOND / DEFAULT_TICKS_PER_SLOT;\n/**\n * @internal\n */ const MS_PER_SLOT = 1000 / NUM_SLOTS_PER_SECOND;\nconst SYSVAR_CLOCK_PUBKEY = new PublicKey(\"SysvarC1ock11111111111111111111111111111111\");\nconst SYSVAR_EPOCH_SCHEDULE_PUBKEY = new PublicKey(\"SysvarEpochSchedu1e111111111111111111111111\");\nconst SYSVAR_INSTRUCTIONS_PUBKEY = new PublicKey(\"Sysvar1nstructions1111111111111111111111111\");\nconst SYSVAR_RECENT_BLOCKHASHES_PUBKEY = new PublicKey(\"SysvarRecentB1ockHashes11111111111111111111\");\nconst SYSVAR_RENT_PUBKEY = new PublicKey(\"SysvarRent111111111111111111111111111111111\");\nconst SYSVAR_REWARDS_PUBKEY = new PublicKey(\"SysvarRewards111111111111111111111111111111\");\nconst SYSVAR_SLOT_HASHES_PUBKEY = new PublicKey(\"SysvarS1otHashes111111111111111111111111111\");\nconst SYSVAR_SLOT_HISTORY_PUBKEY = new PublicKey(\"SysvarS1otHistory11111111111111111111111111\");\nconst SYSVAR_STAKE_HISTORY_PUBKEY = new PublicKey(\"SysvarStakeHistory1111111111111111111111111\");\n/**\n * Sign, send and confirm a transaction.\n *\n * If `commitment` option is not specified, defaults to 'max' commitment.\n *\n * @param {Connection} connection\n * @param {Transaction} transaction\n * @param {Array<Signer>} signers\n * @param {ConfirmOptions} [options]\n * @returns {Promise<TransactionSignature>}\n */ async function sendAndConfirmTransaction(connection, transaction, signers, options) {\n    const sendOptions = options && {\n        skipPreflight: options.skipPreflight,\n        preflightCommitment: options.preflightCommitment || options.commitment,\n        maxRetries: options.maxRetries,\n        minContextSlot: options.minContextSlot\n    };\n    const signature = await connection.sendTransaction(transaction, signers, sendOptions);\n    let status;\n    if (transaction.recentBlockhash != null && transaction.lastValidBlockHeight != null) {\n        status = (await connection.confirmTransaction({\n            abortSignal: options?.abortSignal,\n            signature: signature,\n            blockhash: transaction.recentBlockhash,\n            lastValidBlockHeight: transaction.lastValidBlockHeight\n        }, options && options.commitment)).value;\n    } else if (transaction.minNonceContextSlot != null && transaction.nonceInfo != null) {\n        const { nonceInstruction } = transaction.nonceInfo;\n        const nonceAccountPubkey = nonceInstruction.keys[0].pubkey;\n        status = (await connection.confirmTransaction({\n            abortSignal: options?.abortSignal,\n            minContextSlot: transaction.minNonceContextSlot,\n            nonceAccountPubkey,\n            nonceValue: transaction.nonceInfo.nonce,\n            signature\n        }, options && options.commitment)).value;\n    } else {\n        if (options?.abortSignal != null) {\n            console.warn(\"sendAndConfirmTransaction(): A transaction with a deprecated confirmation strategy was \" + \"supplied along with an `abortSignal`. Only transactions having `lastValidBlockHeight` \" + \"or a combination of `nonceInfo` and `minNonceContextSlot` are abortable.\");\n        }\n        status = (await connection.confirmTransaction(signature, options && options.commitment)).value;\n    }\n    if (status.err) {\n        throw new Error(`Transaction ${signature} failed (${JSON.stringify(status)})`);\n    }\n    return signature;\n}\n// zzz\nfunction sleep(ms) {\n    return new Promise((resolve)=>setTimeout(resolve, ms));\n}\n/**\n * @internal\n */ /**\n * Populate a buffer of instruction data using an InstructionType\n * @internal\n */ function encodeData(type, fields) {\n    const allocLength = type.layout.span >= 0 ? type.layout.span : getAlloc(type, fields);\n    const data = buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.alloc(allocLength);\n    const layoutFields = Object.assign({\n        instruction: type.index\n    }, fields);\n    type.layout.encode(layoutFields, data);\n    return data;\n}\n/**\n * Decode instruction data buffer using an InstructionType\n * @internal\n */ function decodeData$1(type, buffer) {\n    let data;\n    try {\n        data = type.layout.decode(buffer);\n    } catch (err) {\n        throw new Error(\"invalid instruction; \" + err);\n    }\n    if (data.instruction !== type.index) {\n        throw new Error(`invalid instruction; instruction index mismatch ${data.instruction} != ${type.index}`);\n    }\n    return data;\n}\n/**\n * https://github.com/solana-labs/solana/blob/90bedd7e067b5b8f3ddbb45da00a4e9cabb22c62/sdk/src/fee_calculator.rs#L7-L11\n *\n * @internal\n */ const FeeCalculatorLayout = _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.nu64(\"lamportsPerSignature\");\n/**\n * Calculator for transaction fees.\n *\n * @deprecated Deprecated since Solana v1.8.0.\n */ /**\n * See https://github.com/solana-labs/solana/blob/0ea2843ec9cdc517572b8e62c959f41b55cf4453/sdk/src/nonce_state.rs#L29-L32\n *\n * @internal\n */ const NonceAccountLayout = _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.struct([\n    _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u32(\"version\"),\n    _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u32(\"state\"),\n    publicKey(\"authorizedPubkey\"),\n    publicKey(\"nonce\"),\n    _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.struct([\n        FeeCalculatorLayout\n    ], \"feeCalculator\")\n]);\nconst NONCE_ACCOUNT_LENGTH = NonceAccountLayout.span;\n/**\n * A durable nonce is a 32 byte value encoded as a base58 string.\n */ /**\n * NonceAccount class\n */ class NonceAccount {\n    /**\n   * @internal\n   */ constructor(args){\n        this.authorizedPubkey = void 0;\n        this.nonce = void 0;\n        this.feeCalculator = void 0;\n        this.authorizedPubkey = args.authorizedPubkey;\n        this.nonce = args.nonce;\n        this.feeCalculator = args.feeCalculator;\n    }\n    /**\n   * Deserialize NonceAccount from the account data.\n   *\n   * @param buffer account data\n   * @return NonceAccount\n   */ static fromAccountData(buffer) {\n        const nonceAccount = NonceAccountLayout.decode(toBuffer(buffer), 0);\n        return new NonceAccount({\n            authorizedPubkey: new PublicKey(nonceAccount.authorizedPubkey),\n            nonce: new PublicKey(nonceAccount.nonce).toString(),\n            feeCalculator: nonceAccount.feeCalculator\n        });\n    }\n}\nconst encodeDecode = (layout)=>{\n    const decode = layout.decode.bind(layout);\n    const encode = layout.encode.bind(layout);\n    return {\n        decode,\n        encode\n    };\n};\nconst bigInt = (length)=>(property)=>{\n        const layout = (0,_solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.blob)(length, property);\n        const { encode, decode } = encodeDecode(layout);\n        const bigIntLayout = layout;\n        bigIntLayout.decode = (buffer, offset)=>{\n            const src = decode(buffer, offset);\n            return (0,bigint_buffer__WEBPACK_IMPORTED_MODULE_5__.toBigIntLE)(buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.from(src));\n        };\n        bigIntLayout.encode = (bigInt, buffer, offset)=>{\n            const src = (0,bigint_buffer__WEBPACK_IMPORTED_MODULE_5__.toBufferLE)(bigInt, length);\n            return encode(src, buffer, offset);\n        };\n        return bigIntLayout;\n    };\nconst u64 = bigInt(8);\n/**\n * Create account system transaction params\n */ /**\n * Transfer system transaction params\n */ /**\n * Assign system transaction params\n */ /**\n * Create account with seed system transaction params\n */ /**\n * Create nonce account system transaction params\n */ /**\n * Create nonce account with seed system transaction params\n */ /**\n * Initialize nonce account system instruction params\n */ /**\n * Advance nonce account system instruction params\n */ /**\n * Withdraw nonce account system transaction params\n */ /**\n * Authorize nonce account system transaction params\n */ /**\n * Allocate account system transaction params\n */ /**\n * Allocate account with seed system transaction params\n */ /**\n * Assign account with seed system transaction params\n */ /**\n * Transfer with seed system transaction params\n */ /** Decoded transfer system transaction instruction */ /** Decoded transferWithSeed system transaction instruction */ /**\n * System Instruction class\n */ class SystemInstruction {\n    /**\n   * @internal\n   */ constructor(){}\n    /**\n   * Decode a system instruction and retrieve the instruction type.\n   */ static decodeInstructionType(instruction) {\n        this.checkProgramId(instruction.programId);\n        const instructionTypeLayout = _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u32(\"instruction\");\n        const typeIndex = instructionTypeLayout.decode(instruction.data);\n        let type;\n        for (const [ixType, layout] of Object.entries(SYSTEM_INSTRUCTION_LAYOUTS)){\n            if (layout.index == typeIndex) {\n                type = ixType;\n                break;\n            }\n        }\n        if (!type) {\n            throw new Error(\"Instruction type incorrect; not a SystemInstruction\");\n        }\n        return type;\n    }\n    /**\n   * Decode a create account system instruction and retrieve the instruction params.\n   */ static decodeCreateAccount(instruction) {\n        this.checkProgramId(instruction.programId);\n        this.checkKeyLength(instruction.keys, 2);\n        const { lamports, space, programId } = decodeData$1(SYSTEM_INSTRUCTION_LAYOUTS.Create, instruction.data);\n        return {\n            fromPubkey: instruction.keys[0].pubkey,\n            newAccountPubkey: instruction.keys[1].pubkey,\n            lamports,\n            space,\n            programId: new PublicKey(programId)\n        };\n    }\n    /**\n   * Decode a transfer system instruction and retrieve the instruction params.\n   */ static decodeTransfer(instruction) {\n        this.checkProgramId(instruction.programId);\n        this.checkKeyLength(instruction.keys, 2);\n        const { lamports } = decodeData$1(SYSTEM_INSTRUCTION_LAYOUTS.Transfer, instruction.data);\n        return {\n            fromPubkey: instruction.keys[0].pubkey,\n            toPubkey: instruction.keys[1].pubkey,\n            lamports\n        };\n    }\n    /**\n   * Decode a transfer with seed system instruction and retrieve the instruction params.\n   */ static decodeTransferWithSeed(instruction) {\n        this.checkProgramId(instruction.programId);\n        this.checkKeyLength(instruction.keys, 3);\n        const { lamports, seed, programId } = decodeData$1(SYSTEM_INSTRUCTION_LAYOUTS.TransferWithSeed, instruction.data);\n        return {\n            fromPubkey: instruction.keys[0].pubkey,\n            basePubkey: instruction.keys[1].pubkey,\n            toPubkey: instruction.keys[2].pubkey,\n            lamports,\n            seed,\n            programId: new PublicKey(programId)\n        };\n    }\n    /**\n   * Decode an allocate system instruction and retrieve the instruction params.\n   */ static decodeAllocate(instruction) {\n        this.checkProgramId(instruction.programId);\n        this.checkKeyLength(instruction.keys, 1);\n        const { space } = decodeData$1(SYSTEM_INSTRUCTION_LAYOUTS.Allocate, instruction.data);\n        return {\n            accountPubkey: instruction.keys[0].pubkey,\n            space\n        };\n    }\n    /**\n   * Decode an allocate with seed system instruction and retrieve the instruction params.\n   */ static decodeAllocateWithSeed(instruction) {\n        this.checkProgramId(instruction.programId);\n        this.checkKeyLength(instruction.keys, 1);\n        const { base, seed, space, programId } = decodeData$1(SYSTEM_INSTRUCTION_LAYOUTS.AllocateWithSeed, instruction.data);\n        return {\n            accountPubkey: instruction.keys[0].pubkey,\n            basePubkey: new PublicKey(base),\n            seed,\n            space,\n            programId: new PublicKey(programId)\n        };\n    }\n    /**\n   * Decode an assign system instruction and retrieve the instruction params.\n   */ static decodeAssign(instruction) {\n        this.checkProgramId(instruction.programId);\n        this.checkKeyLength(instruction.keys, 1);\n        const { programId } = decodeData$1(SYSTEM_INSTRUCTION_LAYOUTS.Assign, instruction.data);\n        return {\n            accountPubkey: instruction.keys[0].pubkey,\n            programId: new PublicKey(programId)\n        };\n    }\n    /**\n   * Decode an assign with seed system instruction and retrieve the instruction params.\n   */ static decodeAssignWithSeed(instruction) {\n        this.checkProgramId(instruction.programId);\n        this.checkKeyLength(instruction.keys, 1);\n        const { base, seed, programId } = decodeData$1(SYSTEM_INSTRUCTION_LAYOUTS.AssignWithSeed, instruction.data);\n        return {\n            accountPubkey: instruction.keys[0].pubkey,\n            basePubkey: new PublicKey(base),\n            seed,\n            programId: new PublicKey(programId)\n        };\n    }\n    /**\n   * Decode a create account with seed system instruction and retrieve the instruction params.\n   */ static decodeCreateWithSeed(instruction) {\n        this.checkProgramId(instruction.programId);\n        this.checkKeyLength(instruction.keys, 2);\n        const { base, seed, lamports, space, programId } = decodeData$1(SYSTEM_INSTRUCTION_LAYOUTS.CreateWithSeed, instruction.data);\n        return {\n            fromPubkey: instruction.keys[0].pubkey,\n            newAccountPubkey: instruction.keys[1].pubkey,\n            basePubkey: new PublicKey(base),\n            seed,\n            lamports,\n            space,\n            programId: new PublicKey(programId)\n        };\n    }\n    /**\n   * Decode a nonce initialize system instruction and retrieve the instruction params.\n   */ static decodeNonceInitialize(instruction) {\n        this.checkProgramId(instruction.programId);\n        this.checkKeyLength(instruction.keys, 3);\n        const { authorized } = decodeData$1(SYSTEM_INSTRUCTION_LAYOUTS.InitializeNonceAccount, instruction.data);\n        return {\n            noncePubkey: instruction.keys[0].pubkey,\n            authorizedPubkey: new PublicKey(authorized)\n        };\n    }\n    /**\n   * Decode a nonce advance system instruction and retrieve the instruction params.\n   */ static decodeNonceAdvance(instruction) {\n        this.checkProgramId(instruction.programId);\n        this.checkKeyLength(instruction.keys, 3);\n        decodeData$1(SYSTEM_INSTRUCTION_LAYOUTS.AdvanceNonceAccount, instruction.data);\n        return {\n            noncePubkey: instruction.keys[0].pubkey,\n            authorizedPubkey: instruction.keys[2].pubkey\n        };\n    }\n    /**\n   * Decode a nonce withdraw system instruction and retrieve the instruction params.\n   */ static decodeNonceWithdraw(instruction) {\n        this.checkProgramId(instruction.programId);\n        this.checkKeyLength(instruction.keys, 5);\n        const { lamports } = decodeData$1(SYSTEM_INSTRUCTION_LAYOUTS.WithdrawNonceAccount, instruction.data);\n        return {\n            noncePubkey: instruction.keys[0].pubkey,\n            toPubkey: instruction.keys[1].pubkey,\n            authorizedPubkey: instruction.keys[4].pubkey,\n            lamports\n        };\n    }\n    /**\n   * Decode a nonce authorize system instruction and retrieve the instruction params.\n   */ static decodeNonceAuthorize(instruction) {\n        this.checkProgramId(instruction.programId);\n        this.checkKeyLength(instruction.keys, 2);\n        const { authorized } = decodeData$1(SYSTEM_INSTRUCTION_LAYOUTS.AuthorizeNonceAccount, instruction.data);\n        return {\n            noncePubkey: instruction.keys[0].pubkey,\n            authorizedPubkey: instruction.keys[1].pubkey,\n            newAuthorizedPubkey: new PublicKey(authorized)\n        };\n    }\n    /**\n   * @internal\n   */ static checkProgramId(programId) {\n        if (!programId.equals(SystemProgram.programId)) {\n            throw new Error(\"invalid instruction; programId is not SystemProgram\");\n        }\n    }\n    /**\n   * @internal\n   */ static checkKeyLength(keys, expectedLength) {\n        if (keys.length < expectedLength) {\n            throw new Error(`invalid instruction; found ${keys.length} keys, expected at least ${expectedLength}`);\n        }\n    }\n}\n/**\n * An enumeration of valid SystemInstructionType's\n */ /**\n * An enumeration of valid system InstructionType's\n * @internal\n */ const SYSTEM_INSTRUCTION_LAYOUTS = Object.freeze({\n    Create: {\n        index: 0,\n        layout: _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.struct([\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u32(\"instruction\"),\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.ns64(\"lamports\"),\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.ns64(\"space\"),\n            publicKey(\"programId\")\n        ])\n    },\n    Assign: {\n        index: 1,\n        layout: _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.struct([\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u32(\"instruction\"),\n            publicKey(\"programId\")\n        ])\n    },\n    Transfer: {\n        index: 2,\n        layout: _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.struct([\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u32(\"instruction\"),\n            u64(\"lamports\")\n        ])\n    },\n    CreateWithSeed: {\n        index: 3,\n        layout: _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.struct([\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u32(\"instruction\"),\n            publicKey(\"base\"),\n            rustString(\"seed\"),\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.ns64(\"lamports\"),\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.ns64(\"space\"),\n            publicKey(\"programId\")\n        ])\n    },\n    AdvanceNonceAccount: {\n        index: 4,\n        layout: _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.struct([\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u32(\"instruction\")\n        ])\n    },\n    WithdrawNonceAccount: {\n        index: 5,\n        layout: _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.struct([\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u32(\"instruction\"),\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.ns64(\"lamports\")\n        ])\n    },\n    InitializeNonceAccount: {\n        index: 6,\n        layout: _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.struct([\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u32(\"instruction\"),\n            publicKey(\"authorized\")\n        ])\n    },\n    AuthorizeNonceAccount: {\n        index: 7,\n        layout: _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.struct([\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u32(\"instruction\"),\n            publicKey(\"authorized\")\n        ])\n    },\n    Allocate: {\n        index: 8,\n        layout: _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.struct([\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u32(\"instruction\"),\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.ns64(\"space\")\n        ])\n    },\n    AllocateWithSeed: {\n        index: 9,\n        layout: _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.struct([\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u32(\"instruction\"),\n            publicKey(\"base\"),\n            rustString(\"seed\"),\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.ns64(\"space\"),\n            publicKey(\"programId\")\n        ])\n    },\n    AssignWithSeed: {\n        index: 10,\n        layout: _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.struct([\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u32(\"instruction\"),\n            publicKey(\"base\"),\n            rustString(\"seed\"),\n            publicKey(\"programId\")\n        ])\n    },\n    TransferWithSeed: {\n        index: 11,\n        layout: _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.struct([\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u32(\"instruction\"),\n            u64(\"lamports\"),\n            rustString(\"seed\"),\n            publicKey(\"programId\")\n        ])\n    },\n    UpgradeNonceAccount: {\n        index: 12,\n        layout: _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.struct([\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u32(\"instruction\")\n        ])\n    }\n});\n/**\n * Factory class for transactions to interact with the System program\n */ class SystemProgram {\n    /**\n   * @internal\n   */ constructor(){}\n    /**\n   * Public key that identifies the System program\n   */ /**\n   * Generate a transaction instruction that creates a new account\n   */ static createAccount(params) {\n        const type = SYSTEM_INSTRUCTION_LAYOUTS.Create;\n        const data = encodeData(type, {\n            lamports: params.lamports,\n            space: params.space,\n            programId: toBuffer(params.programId.toBuffer())\n        });\n        return new TransactionInstruction({\n            keys: [\n                {\n                    pubkey: params.fromPubkey,\n                    isSigner: true,\n                    isWritable: true\n                },\n                {\n                    pubkey: params.newAccountPubkey,\n                    isSigner: true,\n                    isWritable: true\n                }\n            ],\n            programId: this.programId,\n            data\n        });\n    }\n    /**\n   * Generate a transaction instruction that transfers lamports from one account to another\n   */ static transfer(params) {\n        let data;\n        let keys;\n        if (\"basePubkey\" in params) {\n            const type = SYSTEM_INSTRUCTION_LAYOUTS.TransferWithSeed;\n            data = encodeData(type, {\n                lamports: BigInt(params.lamports),\n                seed: params.seed,\n                programId: toBuffer(params.programId.toBuffer())\n            });\n            keys = [\n                {\n                    pubkey: params.fromPubkey,\n                    isSigner: false,\n                    isWritable: true\n                },\n                {\n                    pubkey: params.basePubkey,\n                    isSigner: true,\n                    isWritable: false\n                },\n                {\n                    pubkey: params.toPubkey,\n                    isSigner: false,\n                    isWritable: true\n                }\n            ];\n        } else {\n            const type = SYSTEM_INSTRUCTION_LAYOUTS.Transfer;\n            data = encodeData(type, {\n                lamports: BigInt(params.lamports)\n            });\n            keys = [\n                {\n                    pubkey: params.fromPubkey,\n                    isSigner: true,\n                    isWritable: true\n                },\n                {\n                    pubkey: params.toPubkey,\n                    isSigner: false,\n                    isWritable: true\n                }\n            ];\n        }\n        return new TransactionInstruction({\n            keys,\n            programId: this.programId,\n            data\n        });\n    }\n    /**\n   * Generate a transaction instruction that assigns an account to a program\n   */ static assign(params) {\n        let data;\n        let keys;\n        if (\"basePubkey\" in params) {\n            const type = SYSTEM_INSTRUCTION_LAYOUTS.AssignWithSeed;\n            data = encodeData(type, {\n                base: toBuffer(params.basePubkey.toBuffer()),\n                seed: params.seed,\n                programId: toBuffer(params.programId.toBuffer())\n            });\n            keys = [\n                {\n                    pubkey: params.accountPubkey,\n                    isSigner: false,\n                    isWritable: true\n                },\n                {\n                    pubkey: params.basePubkey,\n                    isSigner: true,\n                    isWritable: false\n                }\n            ];\n        } else {\n            const type = SYSTEM_INSTRUCTION_LAYOUTS.Assign;\n            data = encodeData(type, {\n                programId: toBuffer(params.programId.toBuffer())\n            });\n            keys = [\n                {\n                    pubkey: params.accountPubkey,\n                    isSigner: true,\n                    isWritable: true\n                }\n            ];\n        }\n        return new TransactionInstruction({\n            keys,\n            programId: this.programId,\n            data\n        });\n    }\n    /**\n   * Generate a transaction instruction that creates a new account at\n   *   an address generated with `from`, a seed, and programId\n   */ static createAccountWithSeed(params) {\n        const type = SYSTEM_INSTRUCTION_LAYOUTS.CreateWithSeed;\n        const data = encodeData(type, {\n            base: toBuffer(params.basePubkey.toBuffer()),\n            seed: params.seed,\n            lamports: params.lamports,\n            space: params.space,\n            programId: toBuffer(params.programId.toBuffer())\n        });\n        let keys = [\n            {\n                pubkey: params.fromPubkey,\n                isSigner: true,\n                isWritable: true\n            },\n            {\n                pubkey: params.newAccountPubkey,\n                isSigner: false,\n                isWritable: true\n            }\n        ];\n        if (params.basePubkey != params.fromPubkey) {\n            keys.push({\n                pubkey: params.basePubkey,\n                isSigner: true,\n                isWritable: false\n            });\n        }\n        return new TransactionInstruction({\n            keys,\n            programId: this.programId,\n            data\n        });\n    }\n    /**\n   * Generate a transaction that creates a new Nonce account\n   */ static createNonceAccount(params) {\n        const transaction = new Transaction();\n        if (\"basePubkey\" in params && \"seed\" in params) {\n            transaction.add(SystemProgram.createAccountWithSeed({\n                fromPubkey: params.fromPubkey,\n                newAccountPubkey: params.noncePubkey,\n                basePubkey: params.basePubkey,\n                seed: params.seed,\n                lamports: params.lamports,\n                space: NONCE_ACCOUNT_LENGTH,\n                programId: this.programId\n            }));\n        } else {\n            transaction.add(SystemProgram.createAccount({\n                fromPubkey: params.fromPubkey,\n                newAccountPubkey: params.noncePubkey,\n                lamports: params.lamports,\n                space: NONCE_ACCOUNT_LENGTH,\n                programId: this.programId\n            }));\n        }\n        const initParams = {\n            noncePubkey: params.noncePubkey,\n            authorizedPubkey: params.authorizedPubkey\n        };\n        transaction.add(this.nonceInitialize(initParams));\n        return transaction;\n    }\n    /**\n   * Generate an instruction to initialize a Nonce account\n   */ static nonceInitialize(params) {\n        const type = SYSTEM_INSTRUCTION_LAYOUTS.InitializeNonceAccount;\n        const data = encodeData(type, {\n            authorized: toBuffer(params.authorizedPubkey.toBuffer())\n        });\n        const instructionData = {\n            keys: [\n                {\n                    pubkey: params.noncePubkey,\n                    isSigner: false,\n                    isWritable: true\n                },\n                {\n                    pubkey: SYSVAR_RECENT_BLOCKHASHES_PUBKEY,\n                    isSigner: false,\n                    isWritable: false\n                },\n                {\n                    pubkey: SYSVAR_RENT_PUBKEY,\n                    isSigner: false,\n                    isWritable: false\n                }\n            ],\n            programId: this.programId,\n            data\n        };\n        return new TransactionInstruction(instructionData);\n    }\n    /**\n   * Generate an instruction to advance the nonce in a Nonce account\n   */ static nonceAdvance(params) {\n        const type = SYSTEM_INSTRUCTION_LAYOUTS.AdvanceNonceAccount;\n        const data = encodeData(type);\n        const instructionData = {\n            keys: [\n                {\n                    pubkey: params.noncePubkey,\n                    isSigner: false,\n                    isWritable: true\n                },\n                {\n                    pubkey: SYSVAR_RECENT_BLOCKHASHES_PUBKEY,\n                    isSigner: false,\n                    isWritable: false\n                },\n                {\n                    pubkey: params.authorizedPubkey,\n                    isSigner: true,\n                    isWritable: false\n                }\n            ],\n            programId: this.programId,\n            data\n        };\n        return new TransactionInstruction(instructionData);\n    }\n    /**\n   * Generate a transaction instruction that withdraws lamports from a Nonce account\n   */ static nonceWithdraw(params) {\n        const type = SYSTEM_INSTRUCTION_LAYOUTS.WithdrawNonceAccount;\n        const data = encodeData(type, {\n            lamports: params.lamports\n        });\n        return new TransactionInstruction({\n            keys: [\n                {\n                    pubkey: params.noncePubkey,\n                    isSigner: false,\n                    isWritable: true\n                },\n                {\n                    pubkey: params.toPubkey,\n                    isSigner: false,\n                    isWritable: true\n                },\n                {\n                    pubkey: SYSVAR_RECENT_BLOCKHASHES_PUBKEY,\n                    isSigner: false,\n                    isWritable: false\n                },\n                {\n                    pubkey: SYSVAR_RENT_PUBKEY,\n                    isSigner: false,\n                    isWritable: false\n                },\n                {\n                    pubkey: params.authorizedPubkey,\n                    isSigner: true,\n                    isWritable: false\n                }\n            ],\n            programId: this.programId,\n            data\n        });\n    }\n    /**\n   * Generate a transaction instruction that authorizes a new PublicKey as the authority\n   * on a Nonce account.\n   */ static nonceAuthorize(params) {\n        const type = SYSTEM_INSTRUCTION_LAYOUTS.AuthorizeNonceAccount;\n        const data = encodeData(type, {\n            authorized: toBuffer(params.newAuthorizedPubkey.toBuffer())\n        });\n        return new TransactionInstruction({\n            keys: [\n                {\n                    pubkey: params.noncePubkey,\n                    isSigner: false,\n                    isWritable: true\n                },\n                {\n                    pubkey: params.authorizedPubkey,\n                    isSigner: true,\n                    isWritable: false\n                }\n            ],\n            programId: this.programId,\n            data\n        });\n    }\n    /**\n   * Generate a transaction instruction that allocates space in an account without funding\n   */ static allocate(params) {\n        let data;\n        let keys;\n        if (\"basePubkey\" in params) {\n            const type = SYSTEM_INSTRUCTION_LAYOUTS.AllocateWithSeed;\n            data = encodeData(type, {\n                base: toBuffer(params.basePubkey.toBuffer()),\n                seed: params.seed,\n                space: params.space,\n                programId: toBuffer(params.programId.toBuffer())\n            });\n            keys = [\n                {\n                    pubkey: params.accountPubkey,\n                    isSigner: false,\n                    isWritable: true\n                },\n                {\n                    pubkey: params.basePubkey,\n                    isSigner: true,\n                    isWritable: false\n                }\n            ];\n        } else {\n            const type = SYSTEM_INSTRUCTION_LAYOUTS.Allocate;\n            data = encodeData(type, {\n                space: params.space\n            });\n            keys = [\n                {\n                    pubkey: params.accountPubkey,\n                    isSigner: true,\n                    isWritable: true\n                }\n            ];\n        }\n        return new TransactionInstruction({\n            keys,\n            programId: this.programId,\n            data\n        });\n    }\n}\nSystemProgram.programId = new PublicKey(\"11111111111111111111111111111111\");\n// Keep program chunks under PACKET_DATA_SIZE, leaving enough room for the\n// rest of the Transaction fields\n//\n// TODO: replace 300 with a proper constant for the size of the other\n// Transaction fields\nconst CHUNK_SIZE = PACKET_DATA_SIZE - 300;\n/**\n * Program loader interface\n */ class Loader {\n    /**\n   * @internal\n   */ constructor(){}\n    /**\n   * Amount of program data placed in each load Transaction\n   */ /**\n   * Minimum number of signatures required to load a program not including\n   * retries\n   *\n   * Can be used to calculate transaction fees\n   */ static getMinNumSignatures(dataLength) {\n        return 2 * // Every transaction requires two signatures (payer + program)\n        (Math.ceil(dataLength / Loader.chunkSize) + 1 + // Add one for Create transaction\n        1 // Add one for Finalize transaction\n        );\n    }\n    /**\n   * Loads a generic program\n   *\n   * @param connection The connection to use\n   * @param payer System account that pays to load the program\n   * @param program Account to load the program into\n   * @param programId Public key that identifies the loader\n   * @param data Program octets\n   * @return true if program was loaded successfully, false if program was already loaded\n   */ static async load(connection, payer, program, programId, data) {\n        {\n            const balanceNeeded = await connection.getMinimumBalanceForRentExemption(data.length);\n            // Fetch program account info to check if it has already been created\n            const programInfo = await connection.getAccountInfo(program.publicKey, \"confirmed\");\n            let transaction = null;\n            if (programInfo !== null) {\n                if (programInfo.executable) {\n                    console.error(\"Program load failed, account is already executable\");\n                    return false;\n                }\n                if (programInfo.data.length !== data.length) {\n                    transaction = transaction || new Transaction();\n                    transaction.add(SystemProgram.allocate({\n                        accountPubkey: program.publicKey,\n                        space: data.length\n                    }));\n                }\n                if (!programInfo.owner.equals(programId)) {\n                    transaction = transaction || new Transaction();\n                    transaction.add(SystemProgram.assign({\n                        accountPubkey: program.publicKey,\n                        programId\n                    }));\n                }\n                if (programInfo.lamports < balanceNeeded) {\n                    transaction = transaction || new Transaction();\n                    transaction.add(SystemProgram.transfer({\n                        fromPubkey: payer.publicKey,\n                        toPubkey: program.publicKey,\n                        lamports: balanceNeeded - programInfo.lamports\n                    }));\n                }\n            } else {\n                transaction = new Transaction().add(SystemProgram.createAccount({\n                    fromPubkey: payer.publicKey,\n                    newAccountPubkey: program.publicKey,\n                    lamports: balanceNeeded > 0 ? balanceNeeded : 1,\n                    space: data.length,\n                    programId\n                }));\n            }\n            // If the account is already created correctly, skip this step\n            // and proceed directly to loading instructions\n            if (transaction !== null) {\n                await sendAndConfirmTransaction(connection, transaction, [\n                    payer,\n                    program\n                ], {\n                    commitment: \"confirmed\"\n                });\n            }\n        }\n        const dataLayout = _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.struct([\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u32(\"instruction\"),\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u32(\"offset\"),\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u32(\"bytesLength\"),\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u32(\"bytesLengthPadding\"),\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.seq(_solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u8(\"byte\"), _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.offset(_solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u32(), -8), \"bytes\")\n        ]);\n        const chunkSize = Loader.chunkSize;\n        let offset = 0;\n        let array = data;\n        let transactions = [];\n        while(array.length > 0){\n            const bytes = array.slice(0, chunkSize);\n            const data = buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.alloc(chunkSize + 16);\n            dataLayout.encode({\n                instruction: 0,\n                // Load instruction\n                offset,\n                bytes: bytes,\n                bytesLength: 0,\n                bytesLengthPadding: 0\n            }, data);\n            const transaction = new Transaction().add({\n                keys: [\n                    {\n                        pubkey: program.publicKey,\n                        isSigner: true,\n                        isWritable: true\n                    }\n                ],\n                programId,\n                data\n            });\n            transactions.push(sendAndConfirmTransaction(connection, transaction, [\n                payer,\n                program\n            ], {\n                commitment: \"confirmed\"\n            }));\n            // Delay between sends in an attempt to reduce rate limit errors\n            if (connection._rpcEndpoint.includes(\"solana.com\")) {\n                const REQUESTS_PER_SECOND = 4;\n                await sleep(1000 / REQUESTS_PER_SECOND);\n            }\n            offset += chunkSize;\n            array = array.slice(chunkSize);\n        }\n        await Promise.all(transactions);\n        // Finalize the account loaded with program data for execution\n        {\n            const dataLayout = _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.struct([\n                _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u32(\"instruction\")\n            ]);\n            const data = buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.alloc(dataLayout.span);\n            dataLayout.encode({\n                instruction: 1 // Finalize instruction\n            }, data);\n            const transaction = new Transaction().add({\n                keys: [\n                    {\n                        pubkey: program.publicKey,\n                        isSigner: true,\n                        isWritable: true\n                    },\n                    {\n                        pubkey: SYSVAR_RENT_PUBKEY,\n                        isSigner: false,\n                        isWritable: false\n                    }\n                ],\n                programId,\n                data\n            });\n            const deployCommitment = \"processed\";\n            const finalizeSignature = await connection.sendTransaction(transaction, [\n                payer,\n                program\n            ], {\n                preflightCommitment: deployCommitment\n            });\n            const { context, value } = await connection.confirmTransaction({\n                signature: finalizeSignature,\n                lastValidBlockHeight: transaction.lastValidBlockHeight,\n                blockhash: transaction.recentBlockhash\n            }, deployCommitment);\n            if (value.err) {\n                throw new Error(`Transaction ${finalizeSignature} failed (${JSON.stringify(value)})`);\n            }\n            // We prevent programs from being usable until the slot after their deployment.\n            // See https://github.com/solana-labs/solana/pull/29654\n            while(true // eslint-disable-line no-constant-condition\n            ){\n                try {\n                    const currentSlot = await connection.getSlot({\n                        commitment: deployCommitment\n                    });\n                    if (currentSlot > context.slot) {\n                        break;\n                    }\n                } catch  {\n                /* empty */ }\n                await new Promise((resolve)=>setTimeout(resolve, Math.round(MS_PER_SLOT / 2)));\n            }\n        }\n        // success\n        return true;\n    }\n}\nLoader.chunkSize = CHUNK_SIZE;\n/**\n * @deprecated Deprecated since Solana v1.17.20.\n */ const BPF_LOADER_PROGRAM_ID = new PublicKey(\"BPFLoader2111111111111111111111111111111111\");\n/**\n * Factory class for transactions to interact with a program loader\n *\n * @deprecated Deprecated since Solana v1.17.20.\n */ class BpfLoader {\n    /**\n   * Minimum number of signatures required to load a program not including\n   * retries\n   *\n   * Can be used to calculate transaction fees\n   */ static getMinNumSignatures(dataLength) {\n        return Loader.getMinNumSignatures(dataLength);\n    }\n    /**\n   * Load a SBF program\n   *\n   * @param connection The connection to use\n   * @param payer Account that will pay program loading fees\n   * @param program Account to load the program into\n   * @param elf The entire ELF containing the SBF program\n   * @param loaderProgramId The program id of the BPF loader to use\n   * @return true if program was loaded successfully, false if program was already loaded\n   */ static load(connection, payer, program, elf, loaderProgramId) {\n        return Loader.load(connection, payer, program, loaderProgramId, elf);\n    }\n}\nfunction getDefaultExportFromCjs(x) {\n    return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, \"default\") ? x[\"default\"] : x;\n}\nvar agentkeepalive = {\n    exports: {}\n};\n/**\n * Helpers.\n */ var s = 1000;\nvar m = s * 60;\nvar h = m * 60;\nvar d = h * 24;\nvar w = d * 7;\nvar y = d * 365.25;\n/**\n * Parse or format the given `val`.\n *\n * Options:\n *\n *  - `long` verbose formatting [false]\n *\n * @param {String|Number} val\n * @param {Object} [options]\n * @throws {Error} throw an error if val is not a non-empty string or a number\n * @return {String|Number}\n * @api public\n */ var ms$2 = function(val, options) {\n    options = options || {};\n    var type = typeof val;\n    if (type === \"string\" && val.length > 0) {\n        return parse(val);\n    } else if (type === \"number\" && isFinite(val)) {\n        return options.long ? fmtLong(val) : fmtShort(val);\n    }\n    throw new Error(\"val is not a non-empty string or a valid number. val=\" + JSON.stringify(val));\n};\n/**\n * Parse the given `str` and return milliseconds.\n *\n * @param {String} str\n * @return {Number}\n * @api private\n */ function parse(str) {\n    str = String(str);\n    if (str.length > 100) {\n        return;\n    }\n    var match = /^(-?(?:\\d+)?\\.?\\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(str);\n    if (!match) {\n        return;\n    }\n    var n = parseFloat(match[1]);\n    var type = (match[2] || \"ms\").toLowerCase();\n    switch(type){\n        case \"years\":\n        case \"year\":\n        case \"yrs\":\n        case \"yr\":\n        case \"y\":\n            return n * y;\n        case \"weeks\":\n        case \"week\":\n        case \"w\":\n            return n * w;\n        case \"days\":\n        case \"day\":\n        case \"d\":\n            return n * d;\n        case \"hours\":\n        case \"hour\":\n        case \"hrs\":\n        case \"hr\":\n        case \"h\":\n            return n * h;\n        case \"minutes\":\n        case \"minute\":\n        case \"mins\":\n        case \"min\":\n        case \"m\":\n            return n * m;\n        case \"seconds\":\n        case \"second\":\n        case \"secs\":\n        case \"sec\":\n        case \"s\":\n            return n * s;\n        case \"milliseconds\":\n        case \"millisecond\":\n        case \"msecs\":\n        case \"msec\":\n        case \"ms\":\n            return n;\n        default:\n            return undefined;\n    }\n}\n/**\n * Short format for `ms`.\n *\n * @param {Number} ms\n * @return {String}\n * @api private\n */ function fmtShort(ms) {\n    var msAbs = Math.abs(ms);\n    if (msAbs >= d) {\n        return Math.round(ms / d) + \"d\";\n    }\n    if (msAbs >= h) {\n        return Math.round(ms / h) + \"h\";\n    }\n    if (msAbs >= m) {\n        return Math.round(ms / m) + \"m\";\n    }\n    if (msAbs >= s) {\n        return Math.round(ms / s) + \"s\";\n    }\n    return ms + \"ms\";\n}\n/**\n * Long format for `ms`.\n *\n * @param {Number} ms\n * @return {String}\n * @api private\n */ function fmtLong(ms) {\n    var msAbs = Math.abs(ms);\n    if (msAbs >= d) {\n        return plural(ms, msAbs, d, \"day\");\n    }\n    if (msAbs >= h) {\n        return plural(ms, msAbs, h, \"hour\");\n    }\n    if (msAbs >= m) {\n        return plural(ms, msAbs, m, \"minute\");\n    }\n    if (msAbs >= s) {\n        return plural(ms, msAbs, s, \"second\");\n    }\n    return ms + \" ms\";\n}\n/**\n * Pluralization helper.\n */ function plural(ms, msAbs, n, name) {\n    var isPlural = msAbs >= n * 1.5;\n    return Math.round(ms / n) + \" \" + name + (isPlural ? \"s\" : \"\");\n}\n/*!\n * humanize-ms - index.js\n * Copyright(c) 2014 dead_horse <dead_horse@qq.com>\n * MIT Licensed\n */ /**\n * Module dependencies.\n */ var util = (util__WEBPACK_IMPORTED_MODULE_6___default());\nvar ms$1 = ms$2;\nvar humanizeMs = function(t) {\n    if (typeof t === \"number\") return t;\n    var r = ms$1(t);\n    if (r === undefined) {\n        var err = new Error(util.format(\"humanize-ms(%j) result undefined\", t));\n        console.warn(err.stack);\n    }\n    return r;\n};\nvar constants = {\n    // agent\n    CURRENT_ID: Symbol(\"agentkeepalive#currentId\"),\n    CREATE_ID: Symbol(\"agentkeepalive#createId\"),\n    INIT_SOCKET: Symbol(\"agentkeepalive#initSocket\"),\n    CREATE_HTTPS_CONNECTION: Symbol(\"agentkeepalive#createHttpsConnection\"),\n    // socket\n    SOCKET_CREATED_TIME: Symbol(\"agentkeepalive#socketCreatedTime\"),\n    SOCKET_NAME: Symbol(\"agentkeepalive#socketName\"),\n    SOCKET_REQUEST_COUNT: Symbol(\"agentkeepalive#socketRequestCount\"),\n    SOCKET_REQUEST_FINISHED_COUNT: Symbol(\"agentkeepalive#socketRequestFinishedCount\")\n};\nconst OriginalAgent = (http__WEBPACK_IMPORTED_MODULE_7___default().Agent);\nconst ms = humanizeMs;\nconst debug = util__WEBPACK_IMPORTED_MODULE_6___default().debuglog(\"agentkeepalive\");\nconst { INIT_SOCKET: INIT_SOCKET$1, CURRENT_ID, CREATE_ID, SOCKET_CREATED_TIME, SOCKET_NAME, SOCKET_REQUEST_COUNT, SOCKET_REQUEST_FINISHED_COUNT } = constants;\n// OriginalAgent come from\n// - https://github.com/nodejs/node/blob/v8.12.0/lib/_http_agent.js\n// - https://github.com/nodejs/node/blob/v10.12.0/lib/_http_agent.js\n// node <= 10\nlet defaultTimeoutListenerCount = 1;\nconst majorVersion = parseInt(process.version.split(\".\", 1)[0].substring(1));\nif (majorVersion >= 11 && majorVersion <= 12) {\n    defaultTimeoutListenerCount = 2;\n} else if (majorVersion >= 13) {\n    defaultTimeoutListenerCount = 3;\n}\nfunction deprecate(message) {\n    console.log(\"[agentkeepalive:deprecated] %s\", message);\n}\nclass Agent extends OriginalAgent {\n    constructor(options){\n        options = options || {};\n        options.keepAlive = options.keepAlive !== false;\n        // default is keep-alive and 4s free socket timeout\n        // see https://medium.com/ssense-tech/reduce-networking-errors-in-nodejs-23b4eb9f2d83\n        if (options.freeSocketTimeout === undefined) {\n            options.freeSocketTimeout = 4000;\n        }\n        // Legacy API: keepAliveTimeout should be rename to `freeSocketTimeout`\n        if (options.keepAliveTimeout) {\n            deprecate(\"options.keepAliveTimeout is deprecated, please use options.freeSocketTimeout instead\");\n            options.freeSocketTimeout = options.keepAliveTimeout;\n            delete options.keepAliveTimeout;\n        }\n        // Legacy API: freeSocketKeepAliveTimeout should be rename to `freeSocketTimeout`\n        if (options.freeSocketKeepAliveTimeout) {\n            deprecate(\"options.freeSocketKeepAliveTimeout is deprecated, please use options.freeSocketTimeout instead\");\n            options.freeSocketTimeout = options.freeSocketKeepAliveTimeout;\n            delete options.freeSocketKeepAliveTimeout;\n        }\n        // Sets the socket to timeout after timeout milliseconds of inactivity on the socket.\n        // By default is double free socket timeout.\n        if (options.timeout === undefined) {\n            // make sure socket default inactivity timeout >= 8s\n            options.timeout = Math.max(options.freeSocketTimeout * 2, 8000);\n        }\n        // support humanize format\n        options.timeout = ms(options.timeout);\n        options.freeSocketTimeout = ms(options.freeSocketTimeout);\n        options.socketActiveTTL = options.socketActiveTTL ? ms(options.socketActiveTTL) : 0;\n        super(options);\n        this[CURRENT_ID] = 0;\n        // create socket success counter\n        this.createSocketCount = 0;\n        this.createSocketCountLastCheck = 0;\n        this.createSocketErrorCount = 0;\n        this.createSocketErrorCountLastCheck = 0;\n        this.closeSocketCount = 0;\n        this.closeSocketCountLastCheck = 0;\n        // socket error event count\n        this.errorSocketCount = 0;\n        this.errorSocketCountLastCheck = 0;\n        // request finished counter\n        this.requestCount = 0;\n        this.requestCountLastCheck = 0;\n        // including free socket timeout counter\n        this.timeoutSocketCount = 0;\n        this.timeoutSocketCountLastCheck = 0;\n        this.on(\"free\", (socket)=>{\n            // https://github.com/nodejs/node/pull/32000\n            // Node.js native agent will check socket timeout eqs agent.options.timeout.\n            // Use the ttl or freeSocketTimeout to overwrite.\n            const timeout = this.calcSocketTimeout(socket);\n            if (timeout > 0 && socket.timeout !== timeout) {\n                socket.setTimeout(timeout);\n            }\n        });\n    }\n    get freeSocketKeepAliveTimeout() {\n        deprecate(\"agent.freeSocketKeepAliveTimeout is deprecated, please use agent.options.freeSocketTimeout instead\");\n        return this.options.freeSocketTimeout;\n    }\n    get timeout() {\n        deprecate(\"agent.timeout is deprecated, please use agent.options.timeout instead\");\n        return this.options.timeout;\n    }\n    get socketActiveTTL() {\n        deprecate(\"agent.socketActiveTTL is deprecated, please use agent.options.socketActiveTTL instead\");\n        return this.options.socketActiveTTL;\n    }\n    calcSocketTimeout(socket) {\n        /**\n     * return <= 0: should free socket\n     * return > 0: should update socket timeout\n     * return undefined: not find custom timeout\n     */ let freeSocketTimeout = this.options.freeSocketTimeout;\n        const socketActiveTTL = this.options.socketActiveTTL;\n        if (socketActiveTTL) {\n            // check socketActiveTTL\n            const aliveTime = Date.now() - socket[SOCKET_CREATED_TIME];\n            const diff = socketActiveTTL - aliveTime;\n            if (diff <= 0) {\n                return diff;\n            }\n            if (freeSocketTimeout && diff < freeSocketTimeout) {\n                freeSocketTimeout = diff;\n            }\n        }\n        // set freeSocketTimeout\n        if (freeSocketTimeout) {\n            // set free keepalive timer\n            // try to use socket custom freeSocketTimeout first, support headers['keep-alive']\n            // https://github.com/node-modules/urllib/blob/b76053020923f4d99a1c93cf2e16e0c5ba10bacf/lib/urllib.js#L498\n            const customFreeSocketTimeout = socket.freeSocketTimeout || socket.freeSocketKeepAliveTimeout;\n            return customFreeSocketTimeout || freeSocketTimeout;\n        }\n    }\n    keepSocketAlive(socket) {\n        const result = super.keepSocketAlive(socket);\n        // should not keepAlive, do nothing\n        if (!result) return result;\n        const customTimeout = this.calcSocketTimeout(socket);\n        if (typeof customTimeout === \"undefined\") {\n            return true;\n        }\n        if (customTimeout <= 0) {\n            debug(\"%s(requests: %s, finished: %s) free but need to destroy by TTL, request count %s, diff is %s\", socket[SOCKET_NAME], socket[SOCKET_REQUEST_COUNT], socket[SOCKET_REQUEST_FINISHED_COUNT], customTimeout);\n            return false;\n        }\n        if (socket.timeout !== customTimeout) {\n            socket.setTimeout(customTimeout);\n        }\n        return true;\n    }\n    // only call on addRequest\n    reuseSocket(...args) {\n        // reuseSocket(socket, req)\n        super.reuseSocket(...args);\n        const socket = args[0];\n        const req = args[1];\n        req.reusedSocket = true;\n        const agentTimeout = this.options.timeout;\n        if (getSocketTimeout(socket) !== agentTimeout) {\n            // reset timeout before use\n            socket.setTimeout(agentTimeout);\n            debug(\"%s reset timeout to %sms\", socket[SOCKET_NAME], agentTimeout);\n        }\n        socket[SOCKET_REQUEST_COUNT]++;\n        debug(\"%s(requests: %s, finished: %s) reuse on addRequest, timeout %sms\", socket[SOCKET_NAME], socket[SOCKET_REQUEST_COUNT], socket[SOCKET_REQUEST_FINISHED_COUNT], getSocketTimeout(socket));\n    }\n    [CREATE_ID]() {\n        const id = this[CURRENT_ID]++;\n        if (this[CURRENT_ID] === Number.MAX_SAFE_INTEGER) this[CURRENT_ID] = 0;\n        return id;\n    }\n    [INIT_SOCKET$1](socket, options) {\n        // bugfix here.\n        // https on node 8, 10 won't set agent.options.timeout by default\n        // TODO: need to fix on node itself\n        if (options.timeout) {\n            const timeout = getSocketTimeout(socket);\n            if (!timeout) {\n                socket.setTimeout(options.timeout);\n            }\n        }\n        if (this.options.keepAlive) {\n            // Disable Nagle's algorithm: http://blog.caustik.com/2012/04/08/scaling-node-js-to-100k-concurrent-connections/\n            // https://fengmk2.com/benchmark/nagle-algorithm-delayed-ack-mock.html\n            socket.setNoDelay(true);\n        }\n        this.createSocketCount++;\n        if (this.options.socketActiveTTL) {\n            socket[SOCKET_CREATED_TIME] = Date.now();\n        }\n        // don't show the hole '-----BEGIN CERTIFICATE----' key string\n        socket[SOCKET_NAME] = `sock[${this[CREATE_ID]()}#${options._agentKey}]`.split(\"-----BEGIN\", 1)[0];\n        socket[SOCKET_REQUEST_COUNT] = 1;\n        socket[SOCKET_REQUEST_FINISHED_COUNT] = 0;\n        installListeners(this, socket, options);\n    }\n    createConnection(options, oncreate) {\n        let called = false;\n        const onNewCreate = (err, socket)=>{\n            if (called) return;\n            called = true;\n            if (err) {\n                this.createSocketErrorCount++;\n                return oncreate(err);\n            }\n            this[INIT_SOCKET$1](socket, options);\n            oncreate(err, socket);\n        };\n        const newSocket = super.createConnection(options, onNewCreate);\n        if (newSocket) onNewCreate(null, newSocket);\n        return newSocket;\n    }\n    get statusChanged() {\n        const changed = this.createSocketCount !== this.createSocketCountLastCheck || this.createSocketErrorCount !== this.createSocketErrorCountLastCheck || this.closeSocketCount !== this.closeSocketCountLastCheck || this.errorSocketCount !== this.errorSocketCountLastCheck || this.timeoutSocketCount !== this.timeoutSocketCountLastCheck || this.requestCount !== this.requestCountLastCheck;\n        if (changed) {\n            this.createSocketCountLastCheck = this.createSocketCount;\n            this.createSocketErrorCountLastCheck = this.createSocketErrorCount;\n            this.closeSocketCountLastCheck = this.closeSocketCount;\n            this.errorSocketCountLastCheck = this.errorSocketCount;\n            this.timeoutSocketCountLastCheck = this.timeoutSocketCount;\n            this.requestCountLastCheck = this.requestCount;\n        }\n        return changed;\n    }\n    getCurrentStatus() {\n        return {\n            createSocketCount: this.createSocketCount,\n            createSocketErrorCount: this.createSocketErrorCount,\n            closeSocketCount: this.closeSocketCount,\n            errorSocketCount: this.errorSocketCount,\n            timeoutSocketCount: this.timeoutSocketCount,\n            requestCount: this.requestCount,\n            freeSockets: inspect(this.freeSockets),\n            sockets: inspect(this.sockets),\n            requests: inspect(this.requests)\n        };\n    }\n}\n// node 8 don't has timeout attribute on socket\n// https://github.com/nodejs/node/pull/21204/files#diff-e6ef024c3775d787c38487a6309e491dR408\nfunction getSocketTimeout(socket) {\n    return socket.timeout || socket._idleTimeout;\n}\nfunction installListeners(agent, socket, options) {\n    debug(\"%s create, timeout %sms\", socket[SOCKET_NAME], getSocketTimeout(socket));\n    // listener socket events: close, timeout, error, free\n    function onFree() {\n        // create and socket.emit('free') logic\n        // https://github.com/nodejs/node/blob/master/lib/_http_agent.js#L311\n        // no req on the socket, it should be the new socket\n        if (!socket._httpMessage && socket[SOCKET_REQUEST_COUNT] === 1) return;\n        socket[SOCKET_REQUEST_FINISHED_COUNT]++;\n        agent.requestCount++;\n        debug(\"%s(requests: %s, finished: %s) free\", socket[SOCKET_NAME], socket[SOCKET_REQUEST_COUNT], socket[SOCKET_REQUEST_FINISHED_COUNT]);\n        // should reuse on pedding requests?\n        const name = agent.getName(options);\n        if (socket.writable && agent.requests[name] && agent.requests[name].length) {\n            // will be reuse on agent free listener\n            socket[SOCKET_REQUEST_COUNT]++;\n            debug(\"%s(requests: %s, finished: %s) will be reuse on agent free event\", socket[SOCKET_NAME], socket[SOCKET_REQUEST_COUNT], socket[SOCKET_REQUEST_FINISHED_COUNT]);\n        }\n    }\n    socket.on(\"free\", onFree);\n    function onClose(isError) {\n        debug(\"%s(requests: %s, finished: %s) close, isError: %s\", socket[SOCKET_NAME], socket[SOCKET_REQUEST_COUNT], socket[SOCKET_REQUEST_FINISHED_COUNT], isError);\n        agent.closeSocketCount++;\n    }\n    socket.on(\"close\", onClose);\n    // start socket timeout handler\n    function onTimeout() {\n        // onTimeout and emitRequestTimeout(_http_client.js)\n        // https://github.com/nodejs/node/blob/v12.x/lib/_http_client.js#L711\n        const listenerCount = socket.listeners(\"timeout\").length;\n        // node <= 10, default listenerCount is 1, onTimeout\n        // 11 < node <= 12, default listenerCount is 2, onTimeout and emitRequestTimeout\n        // node >= 13, default listenerCount is 3, onTimeout,\n        //   onTimeout(https://github.com/nodejs/node/pull/32000/files#diff-5f7fb0850412c6be189faeddea6c5359R333)\n        //   and emitRequestTimeout\n        const timeout = getSocketTimeout(socket);\n        const req = socket._httpMessage;\n        const reqTimeoutListenerCount = req && req.listeners(\"timeout\").length || 0;\n        debug(\"%s(requests: %s, finished: %s) timeout after %sms, listeners %s, defaultTimeoutListenerCount %s, hasHttpRequest %s, HttpRequest timeoutListenerCount %s\", socket[SOCKET_NAME], socket[SOCKET_REQUEST_COUNT], socket[SOCKET_REQUEST_FINISHED_COUNT], timeout, listenerCount, defaultTimeoutListenerCount, !!req, reqTimeoutListenerCount);\n        if (debug.enabled) {\n            debug(\"timeout listeners: %s\", socket.listeners(\"timeout\").map((f)=>f.name).join(\", \"));\n        }\n        agent.timeoutSocketCount++;\n        const name = agent.getName(options);\n        if (agent.freeSockets[name] && agent.freeSockets[name].indexOf(socket) !== -1) {\n            // free socket timeout, destroy quietly\n            socket.destroy();\n            // Remove it from freeSockets list immediately to prevent new requests\n            // from being sent through this socket.\n            agent.removeSocket(socket, options);\n            debug(\"%s is free, destroy quietly\", socket[SOCKET_NAME]);\n        } else {\n            // if there is no any request socket timeout handler,\n            // agent need to handle socket timeout itself.\n            //\n            // custom request socket timeout handle logic must follow these rules:\n            //  1. Destroy socket first\n            //  2. Must emit socket 'agentRemove' event tell agent remove socket\n            //     from freeSockets list immediately.\n            //     Otherise you may be get 'socket hang up' error when reuse\n            //     free socket and timeout happen in the same time.\n            if (reqTimeoutListenerCount === 0) {\n                const error = new Error(\"Socket timeout\");\n                error.code = \"ERR_SOCKET_TIMEOUT\";\n                error.timeout = timeout;\n                // must manually call socket.end() or socket.destroy() to end the connection.\n                // https://nodejs.org/dist/latest-v10.x/docs/api/net.html#net_socket_settimeout_timeout_callback\n                socket.destroy(error);\n                agent.removeSocket(socket, options);\n                debug(\"%s destroy with timeout error\", socket[SOCKET_NAME]);\n            }\n        }\n    }\n    socket.on(\"timeout\", onTimeout);\n    function onError(err) {\n        const listenerCount = socket.listeners(\"error\").length;\n        debug(\"%s(requests: %s, finished: %s) error: %s, listenerCount: %s\", socket[SOCKET_NAME], socket[SOCKET_REQUEST_COUNT], socket[SOCKET_REQUEST_FINISHED_COUNT], err, listenerCount);\n        agent.errorSocketCount++;\n        if (listenerCount === 1) {\n            // if socket don't contain error event handler, don't catch it, emit it again\n            debug(\"%s emit uncaught error event\", socket[SOCKET_NAME]);\n            socket.removeListener(\"error\", onError);\n            socket.emit(\"error\", err);\n        }\n    }\n    socket.on(\"error\", onError);\n    function onRemove() {\n        debug(\"%s(requests: %s, finished: %s) agentRemove\", socket[SOCKET_NAME], socket[SOCKET_REQUEST_COUNT], socket[SOCKET_REQUEST_FINISHED_COUNT]);\n        // We need this function for cases like HTTP 'upgrade'\n        // (defined by WebSockets) where we need to remove a socket from the\n        // pool because it'll be locked up indefinitely\n        socket.removeListener(\"close\", onClose);\n        socket.removeListener(\"error\", onError);\n        socket.removeListener(\"free\", onFree);\n        socket.removeListener(\"timeout\", onTimeout);\n        socket.removeListener(\"agentRemove\", onRemove);\n    }\n    socket.on(\"agentRemove\", onRemove);\n}\nvar agent = Agent;\nfunction inspect(obj) {\n    const res = {};\n    for(const key in obj){\n        res[key] = obj[key].length;\n    }\n    return res;\n}\nconst OriginalHttpsAgent = (https__WEBPACK_IMPORTED_MODULE_8___default().Agent);\nconst HttpAgent = agent;\nconst { INIT_SOCKET, CREATE_HTTPS_CONNECTION } = constants;\nlet HttpsAgent$1 = class HttpsAgent extends HttpAgent {\n    constructor(options){\n        super(options);\n        this.defaultPort = 443;\n        this.protocol = \"https:\";\n        this.maxCachedSessions = this.options.maxCachedSessions;\n        /* istanbul ignore next */ if (this.maxCachedSessions === undefined) {\n            this.maxCachedSessions = 100;\n        }\n        this._sessionCache = {\n            map: {},\n            list: []\n        };\n    }\n    createConnection(options, oncreate) {\n        const socket = this[CREATE_HTTPS_CONNECTION](options, oncreate);\n        this[INIT_SOCKET](socket, options);\n        return socket;\n    }\n};\n// https://github.com/nodejs/node/blob/master/lib/https.js#L89\nHttpsAgent$1.prototype[CREATE_HTTPS_CONNECTION] = OriginalHttpsAgent.prototype.createConnection;\n[\n    \"getName\",\n    \"_getSession\",\n    \"_cacheSession\",\n    // https://github.com/nodejs/node/pull/4982\n    \"_evictSession\"\n].forEach(function(method) {\n    /* istanbul ignore next */ if (typeof OriginalHttpsAgent.prototype[method] === \"function\") {\n        HttpsAgent$1.prototype[method] = OriginalHttpsAgent.prototype[method];\n    }\n});\nvar https_agent = HttpsAgent$1;\nagentkeepalive.exports = agent;\nvar HttpsAgent = agentkeepalive.exports.HttpsAgent = https_agent;\nagentkeepalive.exports.constants = constants;\nvar agentkeepaliveExports = agentkeepalive.exports;\nvar HttpKeepAliveAgent = /*@__PURE__*/ getDefaultExportFromCjs(agentkeepaliveExports);\nvar objToString = Object.prototype.toString;\nvar objKeys = Object.keys || function(obj) {\n    var keys = [];\n    for(var name in obj){\n        keys.push(name);\n    }\n    return keys;\n};\nfunction stringify(val, isArrayProp) {\n    var i, max, str, keys, key, propVal, toStr;\n    if (val === true) {\n        return \"true\";\n    }\n    if (val === false) {\n        return \"false\";\n    }\n    switch(typeof val){\n        case \"object\":\n            if (val === null) {\n                return null;\n            } else if (val.toJSON && typeof val.toJSON === \"function\") {\n                return stringify(val.toJSON(), isArrayProp);\n            } else {\n                toStr = objToString.call(val);\n                if (toStr === \"[object Array]\") {\n                    str = \"[\";\n                    max = val.length - 1;\n                    for(i = 0; i < max; i++){\n                        str += stringify(val[i], true) + \",\";\n                    }\n                    if (max > -1) {\n                        str += stringify(val[i], true);\n                    }\n                    return str + \"]\";\n                } else if (toStr === \"[object Object]\") {\n                    // only object is left\n                    keys = objKeys(val).sort();\n                    max = keys.length;\n                    str = \"\";\n                    i = 0;\n                    while(i < max){\n                        key = keys[i];\n                        propVal = stringify(val[key], false);\n                        if (propVal !== undefined) {\n                            if (str) {\n                                str += \",\";\n                            }\n                            str += JSON.stringify(key) + \":\" + propVal;\n                        }\n                        i++;\n                    }\n                    return \"{\" + str + \"}\";\n                } else {\n                    return JSON.stringify(val);\n                }\n            }\n        case \"function\":\n        case \"undefined\":\n            return isArrayProp ? null : undefined;\n        case \"string\":\n            return JSON.stringify(val);\n        default:\n            return isFinite(val) ? val : null;\n    }\n}\nvar fastStableStringify = function(val) {\n    var returnVal = stringify(val, false);\n    if (returnVal !== undefined) {\n        return \"\" + returnVal;\n    }\n};\nvar fastStableStringify$1 = /*@__PURE__*/ getDefaultExportFromCjs(fastStableStringify);\nconst MINIMUM_SLOT_PER_EPOCH = 32;\n// Returns the number of trailing zeros in the binary representation of self.\nfunction trailingZeros(n) {\n    let trailingZeros = 0;\n    while(n > 1){\n        n /= 2;\n        trailingZeros++;\n    }\n    return trailingZeros;\n}\n// Returns the smallest power of two greater than or equal to n\nfunction nextPowerOfTwo(n) {\n    if (n === 0) return 1;\n    n--;\n    n |= n >> 1;\n    n |= n >> 2;\n    n |= n >> 4;\n    n |= n >> 8;\n    n |= n >> 16;\n    n |= n >> 32;\n    return n + 1;\n}\n/**\n * Epoch schedule\n * (see https://docs.solana.com/terminology#epoch)\n * Can be retrieved with the {@link Connection.getEpochSchedule} method\n */ class EpochSchedule {\n    constructor(slotsPerEpoch, leaderScheduleSlotOffset, warmup, firstNormalEpoch, firstNormalSlot){\n        /** The maximum number of slots in each epoch */ this.slotsPerEpoch = void 0;\n        /** The number of slots before beginning of an epoch to calculate a leader schedule for that epoch */ this.leaderScheduleSlotOffset = void 0;\n        /** Indicates whether epochs start short and grow */ this.warmup = void 0;\n        /** The first epoch with `slotsPerEpoch` slots */ this.firstNormalEpoch = void 0;\n        /** The first slot of `firstNormalEpoch` */ this.firstNormalSlot = void 0;\n        this.slotsPerEpoch = slotsPerEpoch;\n        this.leaderScheduleSlotOffset = leaderScheduleSlotOffset;\n        this.warmup = warmup;\n        this.firstNormalEpoch = firstNormalEpoch;\n        this.firstNormalSlot = firstNormalSlot;\n    }\n    getEpoch(slot) {\n        return this.getEpochAndSlotIndex(slot)[0];\n    }\n    getEpochAndSlotIndex(slot) {\n        if (slot < this.firstNormalSlot) {\n            const epoch = trailingZeros(nextPowerOfTwo(slot + MINIMUM_SLOT_PER_EPOCH + 1)) - trailingZeros(MINIMUM_SLOT_PER_EPOCH) - 1;\n            const epochLen = this.getSlotsInEpoch(epoch);\n            const slotIndex = slot - (epochLen - MINIMUM_SLOT_PER_EPOCH);\n            return [\n                epoch,\n                slotIndex\n            ];\n        } else {\n            const normalSlotIndex = slot - this.firstNormalSlot;\n            const normalEpochIndex = Math.floor(normalSlotIndex / this.slotsPerEpoch);\n            const epoch = this.firstNormalEpoch + normalEpochIndex;\n            const slotIndex = normalSlotIndex % this.slotsPerEpoch;\n            return [\n                epoch,\n                slotIndex\n            ];\n        }\n    }\n    getFirstSlotInEpoch(epoch) {\n        if (epoch <= this.firstNormalEpoch) {\n            return (Math.pow(2, epoch) - 1) * MINIMUM_SLOT_PER_EPOCH;\n        } else {\n            return (epoch - this.firstNormalEpoch) * this.slotsPerEpoch + this.firstNormalSlot;\n        }\n    }\n    getLastSlotInEpoch(epoch) {\n        return this.getFirstSlotInEpoch(epoch) + this.getSlotsInEpoch(epoch) - 1;\n    }\n    getSlotsInEpoch(epoch) {\n        if (epoch < this.firstNormalEpoch) {\n            return Math.pow(2, epoch + trailingZeros(MINIMUM_SLOT_PER_EPOCH));\n        } else {\n            return this.slotsPerEpoch;\n        }\n    }\n}\nclass SendTransactionError extends Error {\n    constructor(message, logs){\n        super(message);\n        this.logs = void 0;\n        this.logs = logs;\n    }\n}\n// Keep in sync with client/src/rpc_custom_errors.rs\n// Typescript `enums` thwart tree-shaking. See https://bargsten.org/jsts/enums/\nconst SolanaJSONRPCErrorCode = {\n    JSON_RPC_SERVER_ERROR_BLOCK_CLEANED_UP: -32001,\n    JSON_RPC_SERVER_ERROR_SEND_TRANSACTION_PREFLIGHT_FAILURE: -32002,\n    JSON_RPC_SERVER_ERROR_TRANSACTION_SIGNATURE_VERIFICATION_FAILURE: -32003,\n    JSON_RPC_SERVER_ERROR_BLOCK_NOT_AVAILABLE: -32004,\n    JSON_RPC_SERVER_ERROR_NODE_UNHEALTHY: -32005,\n    JSON_RPC_SERVER_ERROR_TRANSACTION_PRECOMPILE_VERIFICATION_FAILURE: -32006,\n    JSON_RPC_SERVER_ERROR_SLOT_SKIPPED: -32007,\n    JSON_RPC_SERVER_ERROR_NO_SNAPSHOT: -32008,\n    JSON_RPC_SERVER_ERROR_LONG_TERM_STORAGE_SLOT_SKIPPED: -32009,\n    JSON_RPC_SERVER_ERROR_KEY_EXCLUDED_FROM_SECONDARY_INDEX: -32010,\n    JSON_RPC_SERVER_ERROR_TRANSACTION_HISTORY_NOT_AVAILABLE: -32011,\n    JSON_RPC_SCAN_ERROR: -32012,\n    JSON_RPC_SERVER_ERROR_TRANSACTION_SIGNATURE_LEN_MISMATCH: -32013,\n    JSON_RPC_SERVER_ERROR_BLOCK_STATUS_NOT_AVAILABLE_YET: -32014,\n    JSON_RPC_SERVER_ERROR_UNSUPPORTED_TRANSACTION_VERSION: -32015,\n    JSON_RPC_SERVER_ERROR_MIN_CONTEXT_SLOT_NOT_REACHED: -32016\n};\nclass SolanaJSONRPCError extends Error {\n    constructor({ code, message, data }, customMessage){\n        super(customMessage != null ? `${customMessage}: ${message}` : message);\n        this.code = void 0;\n        this.data = void 0;\n        this.code = code;\n        this.data = data;\n        this.name = \"SolanaJSONRPCError\";\n    }\n}\nvar fetchImpl = typeof globalThis.fetch === \"function\" ? // The Fetch API is supported experimentally in Node 17.5+ and natively in Node 18+.\nglobalThis.fetch : // Otherwise use the polyfill.\nasync function(input, init) {\n    const processedInput = typeof input === \"string\" && input.slice(0, 2) === \"//\" ? \"https:\" + input : input;\n    return await node_fetch__WEBPACK_IMPORTED_MODULE_10__[\"default\"](processedInput, init);\n};\nclass RpcWebSocketClient extends rpc_websockets_dist_lib_client_cjs__WEBPACK_IMPORTED_MODULE_11__[\"default\"] {\n    constructor(address, options, generate_request_id){\n        const webSocketFactory = (url)=>{\n            const rpc = rpc_websockets_dist_lib_client_websocket_cjs__WEBPACK_IMPORTED_MODULE_12___default()(url, {\n                autoconnect: true,\n                max_reconnects: 5,\n                reconnect: true,\n                reconnect_interval: 1000,\n                ...options\n            });\n            if (\"socket\" in rpc) {\n                this.underlyingSocket = rpc.socket;\n            } else {\n                this.underlyingSocket = rpc;\n            }\n            return rpc;\n        };\n        super(webSocketFactory, address, options, generate_request_id);\n        this.underlyingSocket = void 0;\n    }\n    call(...args) {\n        const readyState = this.underlyingSocket?.readyState;\n        if (readyState === 1 /* WebSocket.OPEN */ ) {\n            return super.call(...args);\n        }\n        return Promise.reject(new Error(\"Tried to call a JSON-RPC method `\" + args[0] + \"` but the socket was not `CONNECTING` or `OPEN` (`readyState` was \" + readyState + \")\"));\n    }\n    notify(...args) {\n        const readyState = this.underlyingSocket?.readyState;\n        if (readyState === 1 /* WebSocket.OPEN */ ) {\n            return super.notify(...args);\n        }\n        return Promise.reject(new Error(\"Tried to send a JSON-RPC notification `\" + args[0] + \"` but the socket was not `CONNECTING` or `OPEN` (`readyState` was \" + readyState + \")\"));\n    }\n}\n/**\n * @internal\n */ /**\n * Decode account data buffer using an AccountType\n * @internal\n */ function decodeData(type, data) {\n    let decoded;\n    try {\n        decoded = type.layout.decode(data);\n    } catch (err) {\n        throw new Error(\"invalid instruction; \" + err);\n    }\n    if (decoded.typeIndex !== type.index) {\n        throw new Error(`invalid account data; account type mismatch ${decoded.typeIndex} != ${type.index}`);\n    }\n    return decoded;\n}\n/// The serialized size of lookup table metadata\nconst LOOKUP_TABLE_META_SIZE = 56;\nclass AddressLookupTableAccount {\n    constructor(args){\n        this.key = void 0;\n        this.state = void 0;\n        this.key = args.key;\n        this.state = args.state;\n    }\n    isActive() {\n        const U64_MAX = BigInt(\"0xffffffffffffffff\");\n        return this.state.deactivationSlot === U64_MAX;\n    }\n    static deserialize(accountData) {\n        const meta = decodeData(LookupTableMetaLayout, accountData);\n        const serializedAddressesLen = accountData.length - LOOKUP_TABLE_META_SIZE;\n        assert(serializedAddressesLen >= 0, \"lookup table is invalid\");\n        assert(serializedAddressesLen % 32 === 0, \"lookup table is invalid\");\n        const numSerializedAddresses = serializedAddressesLen / 32;\n        const { addresses } = _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.struct([\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.seq(publicKey(), numSerializedAddresses, \"addresses\")\n        ]).decode(accountData.slice(LOOKUP_TABLE_META_SIZE));\n        return {\n            deactivationSlot: meta.deactivationSlot,\n            lastExtendedSlot: meta.lastExtendedSlot,\n            lastExtendedSlotStartIndex: meta.lastExtendedStartIndex,\n            authority: meta.authority.length !== 0 ? new PublicKey(meta.authority[0]) : undefined,\n            addresses: addresses.map((address)=>new PublicKey(address))\n        };\n    }\n}\nconst LookupTableMetaLayout = {\n    index: 1,\n    layout: _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.struct([\n        _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u32(\"typeIndex\"),\n        u64(\"deactivationSlot\"),\n        _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.nu64(\"lastExtendedSlot\"),\n        _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u8(\"lastExtendedStartIndex\"),\n        _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u8(),\n        // option\n        _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.seq(publicKey(), _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.offset(_solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u8(), -1), \"authority\")\n    ])\n};\nconst URL_RE = /^[^:]+:\\/\\/([^:[]+|\\[[^\\]]+\\])(:\\d+)?(.*)/i;\nfunction makeWebsocketUrl(endpoint) {\n    const matches = endpoint.match(URL_RE);\n    if (matches == null) {\n        throw TypeError(`Failed to validate endpoint URL \\`${endpoint}\\``);\n    }\n    const [_, // eslint-disable-line @typescript-eslint/no-unused-vars\n    hostish, portWithColon, rest] = matches;\n    const protocol = endpoint.startsWith(\"https:\") ? \"wss:\" : \"ws:\";\n    const startPort = portWithColon == null ? null : parseInt(portWithColon.slice(1), 10);\n    const websocketPort = // Only shift the port by +1 as a convention for ws(s) only if given endpoint\n    // is explicitly specifying the endpoint port (HTTP-based RPC), assuming\n    // we're directly trying to connect to agave-validator's ws listening port.\n    // When the endpoint omits the port, we're connecting to the protocol\n    // default ports: http(80) or https(443) and it's assumed we're behind a reverse\n    // proxy which manages WebSocket upgrade and backend port redirection.\n    startPort == null ? \"\" : `:${startPort + 1}`;\n    return `${protocol}//${hostish}${websocketPort}${rest}`;\n}\nconst PublicKeyFromString = (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.coerce)((0,superstruct__WEBPACK_IMPORTED_MODULE_15__.instance)(PublicKey), (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.string)(), (value)=>new PublicKey(value));\nconst RawAccountDataResult = (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.tuple)([\n    (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.string)(),\n    (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.literal)(\"base64\")\n]);\nconst BufferFromRawAccountData = (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.coerce)((0,superstruct__WEBPACK_IMPORTED_MODULE_15__.instance)(buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer), RawAccountDataResult, (value)=>buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.from(value[0], \"base64\"));\n/**\n * Attempt to use a recent blockhash for up to 30 seconds\n * @internal\n */ const BLOCKHASH_CACHE_TIMEOUT_MS = 30 * 1000;\n/**\n * HACK.\n * Copied from rpc-websockets/dist/lib/client.\n * Otherwise, `yarn build` fails with:\n * https://gist.github.com/steveluscher/c057eca81d479ef705cdb53162f9971d\n */ /** @internal */ /** @internal */ /** @internal */ /** @internal */ /** @internal */ /**\n * @internal\n * Every subscription contains the args used to open the subscription with\n * the server, and a list of callers interested in notifications.\n */ /**\n * @internal\n * A subscription may be in various states of connectedness. Only when it is\n * fully connected will it have a server subscription id associated with it.\n * This id can be returned to the server to unsubscribe the client entirely.\n */ /**\n * A type that encapsulates a subscription's RPC method\n * names and notification (callback) signature.\n */ /**\n * @internal\n * Utility type that keeps tagged unions intact while omitting properties.\n */ /**\n * @internal\n * This type represents a single subscribable 'topic.' It's made up of:\n *\n * - The args used to open the subscription with the server,\n * - The state of the subscription, in terms of its connectedness, and\n * - The set of callbacks to call when the server publishes notifications\n *\n * This record gets indexed by `SubscriptionConfigHash` and is used to\n * set up subscriptions, fan out notifications, and track subscription state.\n */ /**\n * @internal\n */ /**\n * Extra contextual information for RPC responses\n */ /**\n * Options for sending transactions\n */ /**\n * Options for confirming transactions\n */ /**\n * Options for getConfirmedSignaturesForAddress2\n */ /**\n * Options for getSignaturesForAddress\n */ /**\n * RPC Response with extra contextual information\n */ /**\n * A strategy for confirming transactions that uses the last valid\n * block height for a given blockhash to check for transaction expiration.\n */ /**\n * A strategy for confirming durable nonce transactions.\n */ /**\n * Properties shared by all transaction confirmation strategies\n */ /**\n * This type represents all transaction confirmation strategies\n */ /* @internal */ function assertEndpointUrl(putativeUrl) {\n    if (/^https?:/.test(putativeUrl) === false) {\n        throw new TypeError(\"Endpoint URL must start with `http:` or `https:`.\");\n    }\n    return putativeUrl;\n}\n/** @internal */ function extractCommitmentFromConfig(commitmentOrConfig) {\n    let commitment;\n    let config;\n    if (typeof commitmentOrConfig === \"string\") {\n        commitment = commitmentOrConfig;\n    } else if (commitmentOrConfig) {\n        const { commitment: specifiedCommitment, ...specifiedConfig } = commitmentOrConfig;\n        commitment = specifiedCommitment;\n        config = specifiedConfig;\n    }\n    return {\n        commitment,\n        config\n    };\n}\n/**\n * @internal\n */ function createRpcResult(result) {\n    return (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.union)([\n        (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.type)({\n            jsonrpc: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.literal)(\"2.0\"),\n            id: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.string)(),\n            result\n        }),\n        (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.type)({\n            jsonrpc: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.literal)(\"2.0\"),\n            id: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.string)(),\n            error: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.type)({\n                code: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.unknown)(),\n                message: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.string)(),\n                data: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.optional)((0,superstruct__WEBPACK_IMPORTED_MODULE_15__.any)())\n            })\n        })\n    ]);\n}\nconst UnknownRpcResult = createRpcResult((0,superstruct__WEBPACK_IMPORTED_MODULE_15__.unknown)());\n/**\n * @internal\n */ function jsonRpcResult(schema) {\n    return (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.coerce)(createRpcResult(schema), UnknownRpcResult, (value)=>{\n        if (\"error\" in value) {\n            return value;\n        } else {\n            return {\n                ...value,\n                result: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.create)(value.result, schema)\n            };\n        }\n    });\n}\n/**\n * @internal\n */ function jsonRpcResultAndContext(value) {\n    return jsonRpcResult((0,superstruct__WEBPACK_IMPORTED_MODULE_15__.type)({\n        context: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.type)({\n            slot: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.number)()\n        }),\n        value\n    }));\n}\n/**\n * @internal\n */ function notificationResultAndContext(value) {\n    return (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.type)({\n        context: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.type)({\n            slot: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.number)()\n        }),\n        value\n    });\n}\n/**\n * @internal\n */ function versionedMessageFromResponse(version, response) {\n    if (version === 0) {\n        return new MessageV0({\n            header: response.header,\n            staticAccountKeys: response.accountKeys.map((accountKey)=>new PublicKey(accountKey)),\n            recentBlockhash: response.recentBlockhash,\n            compiledInstructions: response.instructions.map((ix)=>({\n                    programIdIndex: ix.programIdIndex,\n                    accountKeyIndexes: ix.accounts,\n                    data: bs58__WEBPACK_IMPORTED_MODULE_2___default().decode(ix.data)\n                })),\n            addressTableLookups: response.addressTableLookups\n        });\n    } else {\n        return new Message(response);\n    }\n}\n/**\n * The level of commitment desired when querying state\n * <pre>\n *   'processed': Query the most recent block which has reached 1 confirmation by the connected node\n *   'confirmed': Query the most recent block which has reached 1 confirmation by the cluster\n *   'finalized': Query the most recent block which has been finalized by the cluster\n * </pre>\n */ // Deprecated as of v1.5.5\n/**\n * A subset of Commitment levels, which are at least optimistically confirmed\n * <pre>\n *   'confirmed': Query the most recent block which has reached 1 confirmation by the cluster\n *   'finalized': Query the most recent block which has been finalized by the cluster\n * </pre>\n */ /**\n * Filter for largest accounts query\n * <pre>\n *   'circulating':    Return the largest accounts that are part of the circulating supply\n *   'nonCirculating': Return the largest accounts that are not part of the circulating supply\n * </pre>\n */ /**\n * Configuration object for changing `getAccountInfo` query behavior\n */ /**\n * Configuration object for changing `getBalance` query behavior\n */ /**\n * Configuration object for changing `getBlock` query behavior\n */ /**\n * Configuration object for changing `getBlock` query behavior\n */ /**\n * Configuration object for changing `getStakeMinimumDelegation` query behavior\n */ /**\n * Configuration object for changing `getBlockHeight` query behavior\n */ /**\n * Configuration object for changing `getEpochInfo` query behavior\n */ /**\n * Configuration object for changing `getInflationReward` query behavior\n */ /**\n * Configuration object for changing `getLatestBlockhash` query behavior\n */ /**\n * Configuration object for changing `isBlockhashValid` query behavior\n */ /**\n * Configuration object for changing `getSlot` query behavior\n */ /**\n * Configuration object for changing `getSlotLeader` query behavior\n */ /**\n * Configuration object for changing `getTransaction` query behavior\n */ /**\n * Configuration object for changing `getTransaction` query behavior\n */ /**\n * Configuration object for changing `getLargestAccounts` query behavior\n */ /**\n * Configuration object for changing `getSupply` request behavior\n */ /**\n * Configuration object for changing query behavior\n */ /**\n * Information describing a cluster node\n */ /**\n * Information describing a vote account\n */ /**\n * A collection of cluster vote accounts\n */ /**\n * Network Inflation\n * (see https://docs.solana.com/implemented-proposals/ed_overview)\n */ const GetInflationGovernorResult = (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.type)({\n    foundation: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.number)(),\n    foundationTerm: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.number)(),\n    initial: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.number)(),\n    taper: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.number)(),\n    terminal: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.number)()\n});\n/**\n * The inflation reward for an epoch\n */ /**\n * Expected JSON RPC response for the \"getInflationReward\" message\n */ const GetInflationRewardResult = jsonRpcResult((0,superstruct__WEBPACK_IMPORTED_MODULE_15__.array)((0,superstruct__WEBPACK_IMPORTED_MODULE_15__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_15__.type)({\n    epoch: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.number)(),\n    effectiveSlot: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.number)(),\n    amount: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.number)(),\n    postBalance: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.number)(),\n    commission: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.optional)((0,superstruct__WEBPACK_IMPORTED_MODULE_15__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_15__.number)()))\n}))));\n/**\n * Configuration object for changing `getRecentPrioritizationFees` query behavior\n */ /**\n * Expected JSON RPC response for the \"getRecentPrioritizationFees\" message\n */ const GetRecentPrioritizationFeesResult = (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.array)((0,superstruct__WEBPACK_IMPORTED_MODULE_15__.type)({\n    slot: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.number)(),\n    prioritizationFee: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.number)()\n}));\n/**\n * Expected JSON RPC response for the \"getInflationRate\" message\n */ const GetInflationRateResult = (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.type)({\n    total: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.number)(),\n    validator: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.number)(),\n    foundation: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.number)(),\n    epoch: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.number)()\n});\n/**\n * Information about the current epoch\n */ const GetEpochInfoResult = (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.type)({\n    epoch: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.number)(),\n    slotIndex: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.number)(),\n    slotsInEpoch: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.number)(),\n    absoluteSlot: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.number)(),\n    blockHeight: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.optional)((0,superstruct__WEBPACK_IMPORTED_MODULE_15__.number)()),\n    transactionCount: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.optional)((0,superstruct__WEBPACK_IMPORTED_MODULE_15__.number)())\n});\nconst GetEpochScheduleResult = (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.type)({\n    slotsPerEpoch: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.number)(),\n    leaderScheduleSlotOffset: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.number)(),\n    warmup: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.boolean)(),\n    firstNormalEpoch: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.number)(),\n    firstNormalSlot: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.number)()\n});\n/**\n * Leader schedule\n * (see https://docs.solana.com/terminology#leader-schedule)\n */ const GetLeaderScheduleResult = (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.record)((0,superstruct__WEBPACK_IMPORTED_MODULE_15__.string)(), (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.array)((0,superstruct__WEBPACK_IMPORTED_MODULE_15__.number)()));\n/**\n * Transaction error or null\n */ const TransactionErrorResult = (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_15__.union)([\n    (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.type)({}),\n    (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.string)()\n]));\n/**\n * Signature status for a transaction\n */ const SignatureStatusResult = (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.type)({\n    err: TransactionErrorResult\n});\n/**\n * Transaction signature received notification\n */ const SignatureReceivedResult = (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.literal)(\"receivedSignature\");\n/**\n * Version info for a node\n */ const VersionResult = (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.type)({\n    \"solana-core\": (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.string)(),\n    \"feature-set\": (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.optional)((0,superstruct__WEBPACK_IMPORTED_MODULE_15__.number)())\n});\nconst SimulatedTransactionResponseStruct = jsonRpcResultAndContext((0,superstruct__WEBPACK_IMPORTED_MODULE_15__.type)({\n    err: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_15__.union)([\n        (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.type)({}),\n        (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.string)()\n    ])),\n    logs: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_15__.array)((0,superstruct__WEBPACK_IMPORTED_MODULE_15__.string)())),\n    accounts: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.optional)((0,superstruct__WEBPACK_IMPORTED_MODULE_15__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_15__.array)((0,superstruct__WEBPACK_IMPORTED_MODULE_15__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_15__.type)({\n        executable: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.boolean)(),\n        owner: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.string)(),\n        lamports: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.number)(),\n        data: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.array)((0,superstruct__WEBPACK_IMPORTED_MODULE_15__.string)()),\n        rentEpoch: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.optional)((0,superstruct__WEBPACK_IMPORTED_MODULE_15__.number)())\n    }))))),\n    unitsConsumed: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.optional)((0,superstruct__WEBPACK_IMPORTED_MODULE_15__.number)()),\n    returnData: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.optional)((0,superstruct__WEBPACK_IMPORTED_MODULE_15__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_15__.type)({\n        programId: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.string)(),\n        data: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.tuple)([\n            (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.string)(),\n            (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.literal)(\"base64\")\n        ])\n    })))\n}));\n/**\n * Metadata for a parsed confirmed transaction on the ledger\n *\n * @deprecated Deprecated since Solana v1.8.0. Please use {@link ParsedTransactionMeta} instead.\n */ /**\n * Collection of addresses loaded by a transaction using address table lookups\n */ /**\n * Metadata for a parsed transaction on the ledger\n */ /**\n * Metadata for a confirmed transaction on the ledger\n */ /**\n * A processed transaction from the RPC API\n */ /**\n * A processed transaction from the RPC API\n */ /**\n * A processed transaction message from the RPC API\n */ /**\n * A confirmed transaction on the ledger\n *\n * @deprecated Deprecated since Solana v1.8.0.\n */ /**\n * A partially decoded transaction instruction\n */ /**\n * A parsed transaction message account\n */ /**\n * A parsed transaction instruction\n */ /**\n * A parsed address table lookup\n */ /**\n * A parsed transaction message\n */ /**\n * A parsed transaction\n */ /**\n * A parsed and confirmed transaction on the ledger\n *\n * @deprecated Deprecated since Solana v1.8.0. Please use {@link ParsedTransactionWithMeta} instead.\n */ /**\n * A parsed transaction on the ledger with meta\n */ /**\n * A processed block fetched from the RPC API\n */ /**\n * A processed block fetched from the RPC API where the `transactionDetails` mode is `accounts`\n */ /**\n * A processed block fetched from the RPC API where the `transactionDetails` mode is `none`\n */ /**\n * A block with parsed transactions\n */ /**\n * A block with parsed transactions where the `transactionDetails` mode is `accounts`\n */ /**\n * A block with parsed transactions where the `transactionDetails` mode is `none`\n */ /**\n * A processed block fetched from the RPC API\n */ /**\n * A processed block fetched from the RPC API where the `transactionDetails` mode is `accounts`\n */ /**\n * A processed block fetched from the RPC API where the `transactionDetails` mode is `none`\n */ /**\n * A confirmed block on the ledger\n *\n * @deprecated Deprecated since Solana v1.8.0.\n */ /**\n * A Block on the ledger with signatures only\n */ /**\n * recent block production information\n */ /**\n * Expected JSON RPC response for the \"getBlockProduction\" message\n */ const BlockProductionResponseStruct = jsonRpcResultAndContext((0,superstruct__WEBPACK_IMPORTED_MODULE_15__.type)({\n    byIdentity: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.record)((0,superstruct__WEBPACK_IMPORTED_MODULE_15__.string)(), (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.array)((0,superstruct__WEBPACK_IMPORTED_MODULE_15__.number)())),\n    range: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.type)({\n        firstSlot: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.number)(),\n        lastSlot: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.number)()\n    })\n}));\n/**\n * A performance sample\n */ function createRpcClient(url, httpHeaders, customFetch, fetchMiddleware, disableRetryOnRateLimit, httpAgent) {\n    const fetch = customFetch ? customFetch : fetchImpl;\n    let agent;\n    {\n        if (httpAgent == null) {\n            {\n                const agentOptions = {\n                    // One second fewer than the Solana RPC's keepalive timeout.\n                    // Read more: https://github.com/solana-labs/solana/issues/27859#issuecomment-1340097889\n                    freeSocketTimeout: 19000,\n                    keepAlive: true,\n                    maxSockets: 25\n                };\n                if (url.startsWith(\"https:\")) {\n                    agent = new HttpsAgent(agentOptions);\n                } else {\n                    agent = new HttpKeepAliveAgent(agentOptions);\n                }\n            }\n        } else {\n            if (httpAgent !== false) {\n                const isHttps = url.startsWith(\"https:\");\n                if (isHttps && !(httpAgent instanceof https__WEBPACK_IMPORTED_MODULE_8__.Agent)) {\n                    throw new Error(\"The endpoint `\" + url + \"` can only be paired with an `https.Agent`. You have, instead, supplied an \" + \"`http.Agent` through `httpAgent`.\");\n                } else if (!isHttps && httpAgent instanceof https__WEBPACK_IMPORTED_MODULE_8__.Agent) {\n                    throw new Error(\"The endpoint `\" + url + \"` can only be paired with an `http.Agent`. You have, instead, supplied an \" + \"`https.Agent` through `httpAgent`.\");\n                }\n                agent = httpAgent;\n            }\n        }\n    }\n    let fetchWithMiddleware;\n    if (fetchMiddleware) {\n        fetchWithMiddleware = async (info, init)=>{\n            const modifiedFetchArgs = await new Promise((resolve, reject)=>{\n                try {\n                    fetchMiddleware(info, init, (modifiedInfo, modifiedInit)=>resolve([\n                            modifiedInfo,\n                            modifiedInit\n                        ]));\n                } catch (error) {\n                    reject(error);\n                }\n            });\n            return await fetch(...modifiedFetchArgs);\n        };\n    }\n    const clientBrowser = new (jayson_lib_client_browser__WEBPACK_IMPORTED_MODULE_9___default())(async (request, callback)=>{\n        const options = {\n            method: \"POST\",\n            body: request,\n            agent,\n            headers: Object.assign({\n                \"Content-Type\": \"application/json\"\n            }, httpHeaders || {}, COMMON_HTTP_HEADERS)\n        };\n        try {\n            let too_many_requests_retries = 5;\n            let res;\n            let waitTime = 500;\n            for(;;){\n                if (fetchWithMiddleware) {\n                    res = await fetchWithMiddleware(url, options);\n                } else {\n                    res = await fetch(url, options);\n                }\n                if (res.status !== 429 /* Too many requests */ ) {\n                    break;\n                }\n                if (disableRetryOnRateLimit === true) {\n                    break;\n                }\n                too_many_requests_retries -= 1;\n                if (too_many_requests_retries === 0) {\n                    break;\n                }\n                console.error(`Server responded with ${res.status} ${res.statusText}.  Retrying after ${waitTime}ms delay...`);\n                await sleep(waitTime);\n                waitTime *= 2;\n            }\n            const text = await res.text();\n            if (res.ok) {\n                callback(null, text);\n            } else {\n                callback(new Error(`${res.status} ${res.statusText}: ${text}`));\n            }\n        } catch (err) {\n            if (err instanceof Error) callback(err);\n        }\n    }, {});\n    return clientBrowser;\n}\nfunction createRpcRequest(client) {\n    return (method, args)=>{\n        return new Promise((resolve, reject)=>{\n            client.request(method, args, (err, response)=>{\n                if (err) {\n                    reject(err);\n                    return;\n                }\n                resolve(response);\n            });\n        });\n    };\n}\nfunction createRpcBatchRequest(client) {\n    return (requests)=>{\n        return new Promise((resolve, reject)=>{\n            // Do nothing if requests is empty\n            if (requests.length === 0) resolve([]);\n            const batch = requests.map((params)=>{\n                return client.request(params.methodName, params.args);\n            });\n            client.request(batch, (err, response)=>{\n                if (err) {\n                    reject(err);\n                    return;\n                }\n                resolve(response);\n            });\n        });\n    };\n}\n/**\n * Expected JSON RPC response for the \"getInflationGovernor\" message\n */ const GetInflationGovernorRpcResult = jsonRpcResult(GetInflationGovernorResult);\n/**\n * Expected JSON RPC response for the \"getInflationRate\" message\n */ const GetInflationRateRpcResult = jsonRpcResult(GetInflationRateResult);\n/**\n * Expected JSON RPC response for the \"getRecentPrioritizationFees\" message\n */ const GetRecentPrioritizationFeesRpcResult = jsonRpcResult(GetRecentPrioritizationFeesResult);\n/**\n * Expected JSON RPC response for the \"getEpochInfo\" message\n */ const GetEpochInfoRpcResult = jsonRpcResult(GetEpochInfoResult);\n/**\n * Expected JSON RPC response for the \"getEpochSchedule\" message\n */ const GetEpochScheduleRpcResult = jsonRpcResult(GetEpochScheduleResult);\n/**\n * Expected JSON RPC response for the \"getLeaderSchedule\" message\n */ const GetLeaderScheduleRpcResult = jsonRpcResult(GetLeaderScheduleResult);\n/**\n * Expected JSON RPC response for the \"minimumLedgerSlot\" and \"getFirstAvailableBlock\" messages\n */ const SlotRpcResult = jsonRpcResult((0,superstruct__WEBPACK_IMPORTED_MODULE_15__.number)());\n/**\n * Supply\n */ /**\n * Expected JSON RPC response for the \"getSupply\" message\n */ const GetSupplyRpcResult = jsonRpcResultAndContext((0,superstruct__WEBPACK_IMPORTED_MODULE_15__.type)({\n    total: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.number)(),\n    circulating: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.number)(),\n    nonCirculating: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.number)(),\n    nonCirculatingAccounts: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.array)(PublicKeyFromString)\n}));\n/**\n * Token amount object which returns a token amount in different formats\n * for various client use cases.\n */ /**\n * Expected JSON RPC structure for token amounts\n */ const TokenAmountResult = (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.type)({\n    amount: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.string)(),\n    uiAmount: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_15__.number)()),\n    decimals: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.number)(),\n    uiAmountString: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.optional)((0,superstruct__WEBPACK_IMPORTED_MODULE_15__.string)())\n});\n/**\n * Token address and balance.\n */ /**\n * Expected JSON RPC response for the \"getTokenLargestAccounts\" message\n */ const GetTokenLargestAccountsResult = jsonRpcResultAndContext((0,superstruct__WEBPACK_IMPORTED_MODULE_15__.array)((0,superstruct__WEBPACK_IMPORTED_MODULE_15__.type)({\n    address: PublicKeyFromString,\n    amount: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.string)(),\n    uiAmount: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_15__.number)()),\n    decimals: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.number)(),\n    uiAmountString: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.optional)((0,superstruct__WEBPACK_IMPORTED_MODULE_15__.string)())\n})));\n/**\n * Expected JSON RPC response for the \"getTokenAccountsByOwner\" message\n */ const GetTokenAccountsByOwner = jsonRpcResultAndContext((0,superstruct__WEBPACK_IMPORTED_MODULE_15__.array)((0,superstruct__WEBPACK_IMPORTED_MODULE_15__.type)({\n    pubkey: PublicKeyFromString,\n    account: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.type)({\n        executable: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.boolean)(),\n        owner: PublicKeyFromString,\n        lamports: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.number)(),\n        data: BufferFromRawAccountData,\n        rentEpoch: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.number)()\n    })\n})));\nconst ParsedAccountDataResult = (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.type)({\n    program: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.string)(),\n    parsed: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.unknown)(),\n    space: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.number)()\n});\n/**\n * Expected JSON RPC response for the \"getTokenAccountsByOwner\" message with parsed data\n */ const GetParsedTokenAccountsByOwner = jsonRpcResultAndContext((0,superstruct__WEBPACK_IMPORTED_MODULE_15__.array)((0,superstruct__WEBPACK_IMPORTED_MODULE_15__.type)({\n    pubkey: PublicKeyFromString,\n    account: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.type)({\n        executable: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.boolean)(),\n        owner: PublicKeyFromString,\n        lamports: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.number)(),\n        data: ParsedAccountDataResult,\n        rentEpoch: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.number)()\n    })\n})));\n/**\n * Pair of an account address and its balance\n */ /**\n * Expected JSON RPC response for the \"getLargestAccounts\" message\n */ const GetLargestAccountsRpcResult = jsonRpcResultAndContext((0,superstruct__WEBPACK_IMPORTED_MODULE_15__.array)((0,superstruct__WEBPACK_IMPORTED_MODULE_15__.type)({\n    lamports: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.number)(),\n    address: PublicKeyFromString\n})));\n/**\n * @internal\n */ const AccountInfoResult = (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.type)({\n    executable: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.boolean)(),\n    owner: PublicKeyFromString,\n    lamports: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.number)(),\n    data: BufferFromRawAccountData,\n    rentEpoch: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.number)()\n});\n/**\n * @internal\n */ const KeyedAccountInfoResult = (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.type)({\n    pubkey: PublicKeyFromString,\n    account: AccountInfoResult\n});\nconst ParsedOrRawAccountData = (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.coerce)((0,superstruct__WEBPACK_IMPORTED_MODULE_15__.union)([\n    (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.instance)(buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer),\n    ParsedAccountDataResult\n]), (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.union)([\n    RawAccountDataResult,\n    ParsedAccountDataResult\n]), (value)=>{\n    if (Array.isArray(value)) {\n        return (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.create)(value, BufferFromRawAccountData);\n    } else {\n        return value;\n    }\n});\n/**\n * @internal\n */ const ParsedAccountInfoResult = (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.type)({\n    executable: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.boolean)(),\n    owner: PublicKeyFromString,\n    lamports: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.number)(),\n    data: ParsedOrRawAccountData,\n    rentEpoch: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.number)()\n});\nconst KeyedParsedAccountInfoResult = (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.type)({\n    pubkey: PublicKeyFromString,\n    account: ParsedAccountInfoResult\n});\n/**\n * @internal\n */ const StakeActivationResult = (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.type)({\n    state: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.union)([\n        (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.literal)(\"active\"),\n        (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.literal)(\"inactive\"),\n        (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.literal)(\"activating\"),\n        (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.literal)(\"deactivating\")\n    ]),\n    active: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.number)(),\n    inactive: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.number)()\n});\n/**\n * Expected JSON RPC response for the \"getConfirmedSignaturesForAddress2\" message\n */ const GetConfirmedSignaturesForAddress2RpcResult = jsonRpcResult((0,superstruct__WEBPACK_IMPORTED_MODULE_15__.array)((0,superstruct__WEBPACK_IMPORTED_MODULE_15__.type)({\n    signature: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.string)(),\n    slot: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.number)(),\n    err: TransactionErrorResult,\n    memo: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_15__.string)()),\n    blockTime: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.optional)((0,superstruct__WEBPACK_IMPORTED_MODULE_15__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_15__.number)()))\n})));\n/**\n * Expected JSON RPC response for the \"getSignaturesForAddress\" message\n */ const GetSignaturesForAddressRpcResult = jsonRpcResult((0,superstruct__WEBPACK_IMPORTED_MODULE_15__.array)((0,superstruct__WEBPACK_IMPORTED_MODULE_15__.type)({\n    signature: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.string)(),\n    slot: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.number)(),\n    err: TransactionErrorResult,\n    memo: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_15__.string)()),\n    blockTime: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.optional)((0,superstruct__WEBPACK_IMPORTED_MODULE_15__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_15__.number)()))\n})));\n/***\n * Expected JSON RPC response for the \"accountNotification\" message\n */ const AccountNotificationResult = (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.type)({\n    subscription: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.number)(),\n    result: notificationResultAndContext(AccountInfoResult)\n});\n/**\n * @internal\n */ const ProgramAccountInfoResult = (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.type)({\n    pubkey: PublicKeyFromString,\n    account: AccountInfoResult\n});\n/***\n * Expected JSON RPC response for the \"programNotification\" message\n */ const ProgramAccountNotificationResult = (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.type)({\n    subscription: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.number)(),\n    result: notificationResultAndContext(ProgramAccountInfoResult)\n});\n/**\n * @internal\n */ const SlotInfoResult = (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.type)({\n    parent: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.number)(),\n    slot: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.number)(),\n    root: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.number)()\n});\n/**\n * Expected JSON RPC response for the \"slotNotification\" message\n */ const SlotNotificationResult = (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.type)({\n    subscription: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.number)(),\n    result: SlotInfoResult\n});\n/**\n * Slot updates which can be used for tracking the live progress of a cluster.\n * - `\"firstShredReceived\"`: connected node received the first shred of a block.\n * Indicates that a new block that is being produced.\n * - `\"completed\"`: connected node has received all shreds of a block. Indicates\n * a block was recently produced.\n * - `\"optimisticConfirmation\"`: block was optimistically confirmed by the\n * cluster. It is not guaranteed that an optimistic confirmation notification\n * will be sent for every finalized blocks.\n * - `\"root\"`: the connected node rooted this block.\n * - `\"createdBank\"`: the connected node has started validating this block.\n * - `\"frozen\"`: the connected node has validated this block.\n * - `\"dead\"`: the connected node failed to validate this block.\n */ /**\n * @internal\n */ const SlotUpdateResult = (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.union)([\n    (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.type)({\n        type: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.union)([\n            (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.literal)(\"firstShredReceived\"),\n            (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.literal)(\"completed\"),\n            (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.literal)(\"optimisticConfirmation\"),\n            (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.literal)(\"root\")\n        ]),\n        slot: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.number)(),\n        timestamp: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.number)()\n    }),\n    (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.type)({\n        type: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.literal)(\"createdBank\"),\n        parent: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.number)(),\n        slot: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.number)(),\n        timestamp: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.number)()\n    }),\n    (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.type)({\n        type: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.literal)(\"frozen\"),\n        slot: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.number)(),\n        timestamp: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.number)(),\n        stats: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.type)({\n            numTransactionEntries: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.number)(),\n            numSuccessfulTransactions: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.number)(),\n            numFailedTransactions: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.number)(),\n            maxTransactionsPerEntry: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.number)()\n        })\n    }),\n    (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.type)({\n        type: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.literal)(\"dead\"),\n        slot: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.number)(),\n        timestamp: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.number)(),\n        err: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.string)()\n    })\n]);\n/**\n * Expected JSON RPC response for the \"slotsUpdatesNotification\" message\n */ const SlotUpdateNotificationResult = (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.type)({\n    subscription: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.number)(),\n    result: SlotUpdateResult\n});\n/**\n * Expected JSON RPC response for the \"signatureNotification\" message\n */ const SignatureNotificationResult = (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.type)({\n    subscription: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.number)(),\n    result: notificationResultAndContext((0,superstruct__WEBPACK_IMPORTED_MODULE_15__.union)([\n        SignatureStatusResult,\n        SignatureReceivedResult\n    ]))\n});\n/**\n * Expected JSON RPC response for the \"rootNotification\" message\n */ const RootNotificationResult = (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.type)({\n    subscription: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.number)(),\n    result: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.number)()\n});\nconst ContactInfoResult = (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.type)({\n    pubkey: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.string)(),\n    gossip: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_15__.string)()),\n    tpu: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_15__.string)()),\n    rpc: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_15__.string)()),\n    version: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_15__.string)())\n});\nconst VoteAccountInfoResult = (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.type)({\n    votePubkey: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.string)(),\n    nodePubkey: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.string)(),\n    activatedStake: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.number)(),\n    epochVoteAccount: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.boolean)(),\n    epochCredits: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.array)((0,superstruct__WEBPACK_IMPORTED_MODULE_15__.tuple)([\n        (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.number)(),\n        (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.number)(),\n        (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.number)()\n    ])),\n    commission: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.number)(),\n    lastVote: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.number)(),\n    rootSlot: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_15__.number)())\n});\n/**\n * Expected JSON RPC response for the \"getVoteAccounts\" message\n */ const GetVoteAccounts = jsonRpcResult((0,superstruct__WEBPACK_IMPORTED_MODULE_15__.type)({\n    current: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.array)(VoteAccountInfoResult),\n    delinquent: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.array)(VoteAccountInfoResult)\n}));\nconst ConfirmationStatus = (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.union)([\n    (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.literal)(\"processed\"),\n    (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.literal)(\"confirmed\"),\n    (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.literal)(\"finalized\")\n]);\nconst SignatureStatusResponse = (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.type)({\n    slot: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.number)(),\n    confirmations: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_15__.number)()),\n    err: TransactionErrorResult,\n    confirmationStatus: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.optional)(ConfirmationStatus)\n});\n/**\n * Expected JSON RPC response for the \"getSignatureStatuses\" message\n */ const GetSignatureStatusesRpcResult = jsonRpcResultAndContext((0,superstruct__WEBPACK_IMPORTED_MODULE_15__.array)((0,superstruct__WEBPACK_IMPORTED_MODULE_15__.nullable)(SignatureStatusResponse)));\n/**\n * Expected JSON RPC response for the \"getMinimumBalanceForRentExemption\" message\n */ const GetMinimumBalanceForRentExemptionRpcResult = jsonRpcResult((0,superstruct__WEBPACK_IMPORTED_MODULE_15__.number)());\nconst AddressTableLookupStruct = (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.type)({\n    accountKey: PublicKeyFromString,\n    writableIndexes: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.array)((0,superstruct__WEBPACK_IMPORTED_MODULE_15__.number)()),\n    readonlyIndexes: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.array)((0,superstruct__WEBPACK_IMPORTED_MODULE_15__.number)())\n});\nconst ConfirmedTransactionResult = (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.type)({\n    signatures: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.array)((0,superstruct__WEBPACK_IMPORTED_MODULE_15__.string)()),\n    message: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.type)({\n        accountKeys: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.array)((0,superstruct__WEBPACK_IMPORTED_MODULE_15__.string)()),\n        header: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.type)({\n            numRequiredSignatures: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.number)(),\n            numReadonlySignedAccounts: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.number)(),\n            numReadonlyUnsignedAccounts: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.number)()\n        }),\n        instructions: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.array)((0,superstruct__WEBPACK_IMPORTED_MODULE_15__.type)({\n            accounts: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.array)((0,superstruct__WEBPACK_IMPORTED_MODULE_15__.number)()),\n            data: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.string)(),\n            programIdIndex: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.number)()\n        })),\n        recentBlockhash: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.string)(),\n        addressTableLookups: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.optional)((0,superstruct__WEBPACK_IMPORTED_MODULE_15__.array)(AddressTableLookupStruct))\n    })\n});\nconst AnnotatedAccountKey = (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.type)({\n    pubkey: PublicKeyFromString,\n    signer: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.boolean)(),\n    writable: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.boolean)(),\n    source: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.optional)((0,superstruct__WEBPACK_IMPORTED_MODULE_15__.union)([\n        (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.literal)(\"transaction\"),\n        (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.literal)(\"lookupTable\")\n    ]))\n});\nconst ConfirmedTransactionAccountsModeResult = (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.type)({\n    accountKeys: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.array)(AnnotatedAccountKey),\n    signatures: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.array)((0,superstruct__WEBPACK_IMPORTED_MODULE_15__.string)())\n});\nconst ParsedInstructionResult = (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.type)({\n    parsed: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.unknown)(),\n    program: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.string)(),\n    programId: PublicKeyFromString\n});\nconst RawInstructionResult = (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.type)({\n    accounts: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.array)(PublicKeyFromString),\n    data: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.string)(),\n    programId: PublicKeyFromString\n});\nconst InstructionResult = (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.union)([\n    RawInstructionResult,\n    ParsedInstructionResult\n]);\nconst UnknownInstructionResult = (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.union)([\n    (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.type)({\n        parsed: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.unknown)(),\n        program: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.string)(),\n        programId: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.string)()\n    }),\n    (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.type)({\n        accounts: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.array)((0,superstruct__WEBPACK_IMPORTED_MODULE_15__.string)()),\n        data: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.string)(),\n        programId: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.string)()\n    })\n]);\nconst ParsedOrRawInstruction = (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.coerce)(InstructionResult, UnknownInstructionResult, (value)=>{\n    if (\"accounts\" in value) {\n        return (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.create)(value, RawInstructionResult);\n    } else {\n        return (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.create)(value, ParsedInstructionResult);\n    }\n});\n/**\n * @internal\n */ const ParsedConfirmedTransactionResult = (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.type)({\n    signatures: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.array)((0,superstruct__WEBPACK_IMPORTED_MODULE_15__.string)()),\n    message: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.type)({\n        accountKeys: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.array)(AnnotatedAccountKey),\n        instructions: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.array)(ParsedOrRawInstruction),\n        recentBlockhash: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.string)(),\n        addressTableLookups: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.optional)((0,superstruct__WEBPACK_IMPORTED_MODULE_15__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_15__.array)(AddressTableLookupStruct)))\n    })\n});\nconst TokenBalanceResult = (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.type)({\n    accountIndex: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.number)(),\n    mint: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.string)(),\n    owner: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.optional)((0,superstruct__WEBPACK_IMPORTED_MODULE_15__.string)()),\n    uiTokenAmount: TokenAmountResult\n});\nconst LoadedAddressesResult = (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.type)({\n    writable: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.array)(PublicKeyFromString),\n    readonly: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.array)(PublicKeyFromString)\n});\n/**\n * @internal\n */ const ConfirmedTransactionMetaResult = (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.type)({\n    err: TransactionErrorResult,\n    fee: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.number)(),\n    innerInstructions: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.optional)((0,superstruct__WEBPACK_IMPORTED_MODULE_15__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_15__.array)((0,superstruct__WEBPACK_IMPORTED_MODULE_15__.type)({\n        index: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.number)(),\n        instructions: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.array)((0,superstruct__WEBPACK_IMPORTED_MODULE_15__.type)({\n            accounts: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.array)((0,superstruct__WEBPACK_IMPORTED_MODULE_15__.number)()),\n            data: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.string)(),\n            programIdIndex: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.number)()\n        }))\n    })))),\n    preBalances: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.array)((0,superstruct__WEBPACK_IMPORTED_MODULE_15__.number)()),\n    postBalances: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.array)((0,superstruct__WEBPACK_IMPORTED_MODULE_15__.number)()),\n    logMessages: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.optional)((0,superstruct__WEBPACK_IMPORTED_MODULE_15__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_15__.array)((0,superstruct__WEBPACK_IMPORTED_MODULE_15__.string)()))),\n    preTokenBalances: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.optional)((0,superstruct__WEBPACK_IMPORTED_MODULE_15__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_15__.array)(TokenBalanceResult))),\n    postTokenBalances: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.optional)((0,superstruct__WEBPACK_IMPORTED_MODULE_15__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_15__.array)(TokenBalanceResult))),\n    loadedAddresses: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.optional)(LoadedAddressesResult),\n    computeUnitsConsumed: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.optional)((0,superstruct__WEBPACK_IMPORTED_MODULE_15__.number)())\n});\n/**\n * @internal\n */ const ParsedConfirmedTransactionMetaResult = (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.type)({\n    err: TransactionErrorResult,\n    fee: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.number)(),\n    innerInstructions: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.optional)((0,superstruct__WEBPACK_IMPORTED_MODULE_15__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_15__.array)((0,superstruct__WEBPACK_IMPORTED_MODULE_15__.type)({\n        index: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.number)(),\n        instructions: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.array)(ParsedOrRawInstruction)\n    })))),\n    preBalances: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.array)((0,superstruct__WEBPACK_IMPORTED_MODULE_15__.number)()),\n    postBalances: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.array)((0,superstruct__WEBPACK_IMPORTED_MODULE_15__.number)()),\n    logMessages: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.optional)((0,superstruct__WEBPACK_IMPORTED_MODULE_15__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_15__.array)((0,superstruct__WEBPACK_IMPORTED_MODULE_15__.string)()))),\n    preTokenBalances: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.optional)((0,superstruct__WEBPACK_IMPORTED_MODULE_15__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_15__.array)(TokenBalanceResult))),\n    postTokenBalances: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.optional)((0,superstruct__WEBPACK_IMPORTED_MODULE_15__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_15__.array)(TokenBalanceResult))),\n    loadedAddresses: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.optional)(LoadedAddressesResult),\n    computeUnitsConsumed: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.optional)((0,superstruct__WEBPACK_IMPORTED_MODULE_15__.number)())\n});\nconst TransactionVersionStruct = (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.union)([\n    (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.literal)(0),\n    (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.literal)(\"legacy\")\n]);\n/** @internal */ const RewardsResult = (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.type)({\n    pubkey: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.string)(),\n    lamports: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.number)(),\n    postBalance: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_15__.number)()),\n    rewardType: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_15__.string)()),\n    commission: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.optional)((0,superstruct__WEBPACK_IMPORTED_MODULE_15__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_15__.number)()))\n});\n/**\n * Expected JSON RPC response for the \"getBlock\" message\n */ const GetBlockRpcResult = jsonRpcResult((0,superstruct__WEBPACK_IMPORTED_MODULE_15__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_15__.type)({\n    blockhash: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.string)(),\n    previousBlockhash: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.string)(),\n    parentSlot: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.number)(),\n    transactions: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.array)((0,superstruct__WEBPACK_IMPORTED_MODULE_15__.type)({\n        transaction: ConfirmedTransactionResult,\n        meta: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.nullable)(ConfirmedTransactionMetaResult),\n        version: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.optional)(TransactionVersionStruct)\n    })),\n    rewards: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.optional)((0,superstruct__WEBPACK_IMPORTED_MODULE_15__.array)(RewardsResult)),\n    blockTime: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_15__.number)()),\n    blockHeight: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_15__.number)())\n})));\n/**\n * Expected JSON RPC response for the \"getBlock\" message when `transactionDetails` is `none`\n */ const GetNoneModeBlockRpcResult = jsonRpcResult((0,superstruct__WEBPACK_IMPORTED_MODULE_15__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_15__.type)({\n    blockhash: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.string)(),\n    previousBlockhash: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.string)(),\n    parentSlot: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.number)(),\n    rewards: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.optional)((0,superstruct__WEBPACK_IMPORTED_MODULE_15__.array)(RewardsResult)),\n    blockTime: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_15__.number)()),\n    blockHeight: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_15__.number)())\n})));\n/**\n * Expected JSON RPC response for the \"getBlock\" message when `transactionDetails` is `accounts`\n */ const GetAccountsModeBlockRpcResult = jsonRpcResult((0,superstruct__WEBPACK_IMPORTED_MODULE_15__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_15__.type)({\n    blockhash: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.string)(),\n    previousBlockhash: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.string)(),\n    parentSlot: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.number)(),\n    transactions: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.array)((0,superstruct__WEBPACK_IMPORTED_MODULE_15__.type)({\n        transaction: ConfirmedTransactionAccountsModeResult,\n        meta: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.nullable)(ConfirmedTransactionMetaResult),\n        version: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.optional)(TransactionVersionStruct)\n    })),\n    rewards: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.optional)((0,superstruct__WEBPACK_IMPORTED_MODULE_15__.array)(RewardsResult)),\n    blockTime: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_15__.number)()),\n    blockHeight: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_15__.number)())\n})));\n/**\n * Expected parsed JSON RPC response for the \"getBlock\" message\n */ const GetParsedBlockRpcResult = jsonRpcResult((0,superstruct__WEBPACK_IMPORTED_MODULE_15__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_15__.type)({\n    blockhash: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.string)(),\n    previousBlockhash: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.string)(),\n    parentSlot: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.number)(),\n    transactions: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.array)((0,superstruct__WEBPACK_IMPORTED_MODULE_15__.type)({\n        transaction: ParsedConfirmedTransactionResult,\n        meta: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.nullable)(ParsedConfirmedTransactionMetaResult),\n        version: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.optional)(TransactionVersionStruct)\n    })),\n    rewards: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.optional)((0,superstruct__WEBPACK_IMPORTED_MODULE_15__.array)(RewardsResult)),\n    blockTime: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_15__.number)()),\n    blockHeight: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_15__.number)())\n})));\n/**\n * Expected parsed JSON RPC response for the \"getBlock\" message  when `transactionDetails` is `accounts`\n */ const GetParsedAccountsModeBlockRpcResult = jsonRpcResult((0,superstruct__WEBPACK_IMPORTED_MODULE_15__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_15__.type)({\n    blockhash: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.string)(),\n    previousBlockhash: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.string)(),\n    parentSlot: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.number)(),\n    transactions: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.array)((0,superstruct__WEBPACK_IMPORTED_MODULE_15__.type)({\n        transaction: ConfirmedTransactionAccountsModeResult,\n        meta: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.nullable)(ParsedConfirmedTransactionMetaResult),\n        version: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.optional)(TransactionVersionStruct)\n    })),\n    rewards: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.optional)((0,superstruct__WEBPACK_IMPORTED_MODULE_15__.array)(RewardsResult)),\n    blockTime: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_15__.number)()),\n    blockHeight: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_15__.number)())\n})));\n/**\n * Expected parsed JSON RPC response for the \"getBlock\" message  when `transactionDetails` is `none`\n */ const GetParsedNoneModeBlockRpcResult = jsonRpcResult((0,superstruct__WEBPACK_IMPORTED_MODULE_15__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_15__.type)({\n    blockhash: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.string)(),\n    previousBlockhash: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.string)(),\n    parentSlot: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.number)(),\n    rewards: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.optional)((0,superstruct__WEBPACK_IMPORTED_MODULE_15__.array)(RewardsResult)),\n    blockTime: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_15__.number)()),\n    blockHeight: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_15__.number)())\n})));\n/**\n * Expected JSON RPC response for the \"getConfirmedBlock\" message\n *\n * @deprecated Deprecated since Solana v1.8.0. Please use {@link GetBlockRpcResult} instead.\n */ const GetConfirmedBlockRpcResult = jsonRpcResult((0,superstruct__WEBPACK_IMPORTED_MODULE_15__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_15__.type)({\n    blockhash: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.string)(),\n    previousBlockhash: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.string)(),\n    parentSlot: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.number)(),\n    transactions: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.array)((0,superstruct__WEBPACK_IMPORTED_MODULE_15__.type)({\n        transaction: ConfirmedTransactionResult,\n        meta: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.nullable)(ConfirmedTransactionMetaResult)\n    })),\n    rewards: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.optional)((0,superstruct__WEBPACK_IMPORTED_MODULE_15__.array)(RewardsResult)),\n    blockTime: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_15__.number)())\n})));\n/**\n * Expected JSON RPC response for the \"getBlock\" message\n */ const GetBlockSignaturesRpcResult = jsonRpcResult((0,superstruct__WEBPACK_IMPORTED_MODULE_15__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_15__.type)({\n    blockhash: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.string)(),\n    previousBlockhash: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.string)(),\n    parentSlot: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.number)(),\n    signatures: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.array)((0,superstruct__WEBPACK_IMPORTED_MODULE_15__.string)()),\n    blockTime: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_15__.number)())\n})));\n/**\n * Expected JSON RPC response for the \"getTransaction\" message\n */ const GetTransactionRpcResult = jsonRpcResult((0,superstruct__WEBPACK_IMPORTED_MODULE_15__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_15__.type)({\n    slot: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.number)(),\n    meta: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.nullable)(ConfirmedTransactionMetaResult),\n    blockTime: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.optional)((0,superstruct__WEBPACK_IMPORTED_MODULE_15__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_15__.number)())),\n    transaction: ConfirmedTransactionResult,\n    version: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.optional)(TransactionVersionStruct)\n})));\n/**\n * Expected parsed JSON RPC response for the \"getTransaction\" message\n */ const GetParsedTransactionRpcResult = jsonRpcResult((0,superstruct__WEBPACK_IMPORTED_MODULE_15__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_15__.type)({\n    slot: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.number)(),\n    transaction: ParsedConfirmedTransactionResult,\n    meta: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.nullable)(ParsedConfirmedTransactionMetaResult),\n    blockTime: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.optional)((0,superstruct__WEBPACK_IMPORTED_MODULE_15__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_15__.number)())),\n    version: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.optional)(TransactionVersionStruct)\n})));\n/**\n * Expected JSON RPC response for the \"getRecentBlockhash\" message\n *\n * @deprecated Deprecated since Solana v1.8.0. Please use {@link GetLatestBlockhashRpcResult} instead.\n */ const GetRecentBlockhashAndContextRpcResult = jsonRpcResultAndContext((0,superstruct__WEBPACK_IMPORTED_MODULE_15__.type)({\n    blockhash: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.string)(),\n    feeCalculator: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.type)({\n        lamportsPerSignature: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.number)()\n    })\n}));\n/**\n * Expected JSON RPC response for the \"getLatestBlockhash\" message\n */ const GetLatestBlockhashRpcResult = jsonRpcResultAndContext((0,superstruct__WEBPACK_IMPORTED_MODULE_15__.type)({\n    blockhash: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.string)(),\n    lastValidBlockHeight: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.number)()\n}));\n/**\n * Expected JSON RPC response for the \"isBlockhashValid\" message\n */ const IsBlockhashValidRpcResult = jsonRpcResultAndContext((0,superstruct__WEBPACK_IMPORTED_MODULE_15__.boolean)());\nconst PerfSampleResult = (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.type)({\n    slot: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.number)(),\n    numTransactions: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.number)(),\n    numSlots: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.number)(),\n    samplePeriodSecs: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.number)()\n});\n/*\n * Expected JSON RPC response for \"getRecentPerformanceSamples\" message\n */ const GetRecentPerformanceSamplesRpcResult = jsonRpcResult((0,superstruct__WEBPACK_IMPORTED_MODULE_15__.array)(PerfSampleResult));\n/**\n * Expected JSON RPC response for the \"getFeeCalculatorForBlockhash\" message\n */ const GetFeeCalculatorRpcResult = jsonRpcResultAndContext((0,superstruct__WEBPACK_IMPORTED_MODULE_15__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_15__.type)({\n    feeCalculator: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.type)({\n        lamportsPerSignature: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.number)()\n    })\n})));\n/**\n * Expected JSON RPC response for the \"requestAirdrop\" message\n */ const RequestAirdropRpcResult = jsonRpcResult((0,superstruct__WEBPACK_IMPORTED_MODULE_15__.string)());\n/**\n * Expected JSON RPC response for the \"sendTransaction\" message\n */ const SendTransactionRpcResult = jsonRpcResult((0,superstruct__WEBPACK_IMPORTED_MODULE_15__.string)());\n/**\n * Information about the latest slot being processed by a node\n */ /**\n * Parsed account data\n */ /**\n * Stake Activation data\n */ /**\n * Data slice argument for getProgramAccounts\n */ /**\n * Memory comparison filter for getProgramAccounts\n */ /**\n * Data size comparison filter for getProgramAccounts\n */ /**\n * A filter object for getProgramAccounts\n */ /**\n * Configuration object for getProgramAccounts requests\n */ /**\n * Configuration object for getParsedProgramAccounts\n */ /**\n * Configuration object for getMultipleAccounts\n */ /**\n * Configuration object for `getStakeActivation`\n */ /**\n * Configuration object for `getStakeActivation`\n */ /**\n * Configuration object for `getStakeActivation`\n */ /**\n * Configuration object for `getNonce`\n */ /**\n * Configuration object for `getNonceAndContext`\n */ /**\n * Information describing an account\n */ /**\n * Account information identified by pubkey\n */ /**\n * Callback function for account change notifications\n */ /**\n * Callback function for program account change notifications\n */ /**\n * Callback function for slot change notifications\n */ /**\n * Callback function for slot update notifications\n */ /**\n * Callback function for signature status notifications\n */ /**\n * Signature status notification with transaction result\n */ /**\n * Signature received notification\n */ /**\n * Callback function for signature notifications\n */ /**\n * Signature subscription options\n */ /**\n * Callback function for root change notifications\n */ /**\n * @internal\n */ const LogsResult = (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.type)({\n    err: TransactionErrorResult,\n    logs: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.array)((0,superstruct__WEBPACK_IMPORTED_MODULE_15__.string)()),\n    signature: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.string)()\n});\n/**\n * Logs result.\n */ /**\n * Expected JSON RPC response for the \"logsNotification\" message.\n */ const LogsNotificationResult = (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.type)({\n    result: notificationResultAndContext(LogsResult),\n    subscription: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.number)()\n});\n/**\n * Filter for log subscriptions.\n */ /**\n * Callback function for log notifications.\n */ /**\n * Signature result\n */ /**\n * Transaction error\n */ /**\n * Transaction confirmation status\n * <pre>\n *   'processed': Transaction landed in a block which has reached 1 confirmation by the connected node\n *   'confirmed': Transaction landed in a block which has reached 1 confirmation by the cluster\n *   'finalized': Transaction landed in a block which has been finalized by the cluster\n * </pre>\n */ /**\n * Signature status\n */ /**\n * A confirmed signature with its status\n */ /**\n * An object defining headers to be passed to the RPC server\n */ /**\n * The type of the JavaScript `fetch()` API\n */ /**\n * A callback used to augment the outgoing HTTP request\n */ /**\n * Configuration for instantiating a Connection\n */ /** @internal */ const COMMON_HTTP_HEADERS = {\n    \"solana-client\": `js/${\"0.0.0-development\"}`\n};\n/**\n * A connection to a fullnode JSON RPC endpoint\n */ class Connection {\n    /**\n   * Establish a JSON RPC connection\n   *\n   * @param endpoint URL to the fullnode JSON RPC endpoint\n   * @param commitmentOrConfig optional default commitment level or optional ConnectionConfig configuration object\n   */ constructor(endpoint, _commitmentOrConfig){\n        /** @internal */ this._commitment = void 0;\n        /** @internal */ this._confirmTransactionInitialTimeout = void 0;\n        /** @internal */ this._rpcEndpoint = void 0;\n        /** @internal */ this._rpcWsEndpoint = void 0;\n        /** @internal */ this._rpcClient = void 0;\n        /** @internal */ this._rpcRequest = void 0;\n        /** @internal */ this._rpcBatchRequest = void 0;\n        /** @internal */ this._rpcWebSocket = void 0;\n        /** @internal */ this._rpcWebSocketConnected = false;\n        /** @internal */ this._rpcWebSocketHeartbeat = null;\n        /** @internal */ this._rpcWebSocketIdleTimeout = null;\n        /** @internal\n     * A number that we increment every time an active connection closes.\n     * Used to determine whether the same socket connection that was open\n     * when an async operation started is the same one that's active when\n     * its continuation fires.\n     *\n     */ this._rpcWebSocketGeneration = 0;\n        /** @internal */ this._disableBlockhashCaching = false;\n        /** @internal */ this._pollingBlockhash = false;\n        /** @internal */ this._blockhashInfo = {\n            latestBlockhash: null,\n            lastFetch: 0,\n            transactionSignatures: [],\n            simulatedSignatures: []\n        };\n        /** @internal */ this._nextClientSubscriptionId = 0;\n        /** @internal */ this._subscriptionDisposeFunctionsByClientSubscriptionId = {};\n        /** @internal */ this._subscriptionHashByClientSubscriptionId = {};\n        /** @internal */ this._subscriptionStateChangeCallbacksByHash = {};\n        /** @internal */ this._subscriptionCallbacksByServerSubscriptionId = {};\n        /** @internal */ this._subscriptionsByHash = {};\n        /**\n     * Special case.\n     * After a signature is processed, RPCs automatically dispose of the\n     * subscription on the server side. We need to track which of these\n     * subscriptions have been disposed in such a way, so that we know\n     * whether the client is dealing with a not-yet-processed signature\n     * (in which case we must tear down the server subscription) or an\n     * already-processed signature (in which case the client can simply\n     * clear out the subscription locally without telling the server).\n     *\n     * NOTE: There is a proposal to eliminate this special case, here:\n     * https://github.com/solana-labs/solana/issues/18892\n     */ /** @internal */ this._subscriptionsAutoDisposedByRpc = new Set();\n        /*\n     * Returns the current block height of the node\n     */ this.getBlockHeight = (()=>{\n            const requestPromises = {};\n            return async (commitmentOrConfig)=>{\n                const { commitment, config } = extractCommitmentFromConfig(commitmentOrConfig);\n                const args = this._buildArgs([], commitment, undefined /* encoding */ , config);\n                const requestHash = fastStableStringify$1(args);\n                requestPromises[requestHash] = requestPromises[requestHash] ?? (async ()=>{\n                    try {\n                        const unsafeRes = await this._rpcRequest(\"getBlockHeight\", args);\n                        const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.create)(unsafeRes, jsonRpcResult((0,superstruct__WEBPACK_IMPORTED_MODULE_15__.number)()));\n                        if (\"error\" in res) {\n                            throw new SolanaJSONRPCError(res.error, \"failed to get block height information\");\n                        }\n                        return res.result;\n                    } finally{\n                        delete requestPromises[requestHash];\n                    }\n                })();\n                return await requestPromises[requestHash];\n            };\n        })();\n        let wsEndpoint;\n        let httpHeaders;\n        let fetch;\n        let fetchMiddleware;\n        let disableRetryOnRateLimit;\n        let httpAgent;\n        if (_commitmentOrConfig && typeof _commitmentOrConfig === \"string\") {\n            this._commitment = _commitmentOrConfig;\n        } else if (_commitmentOrConfig) {\n            this._commitment = _commitmentOrConfig.commitment;\n            this._confirmTransactionInitialTimeout = _commitmentOrConfig.confirmTransactionInitialTimeout;\n            wsEndpoint = _commitmentOrConfig.wsEndpoint;\n            httpHeaders = _commitmentOrConfig.httpHeaders;\n            fetch = _commitmentOrConfig.fetch;\n            fetchMiddleware = _commitmentOrConfig.fetchMiddleware;\n            disableRetryOnRateLimit = _commitmentOrConfig.disableRetryOnRateLimit;\n            httpAgent = _commitmentOrConfig.httpAgent;\n        }\n        this._rpcEndpoint = assertEndpointUrl(endpoint);\n        this._rpcWsEndpoint = wsEndpoint || makeWebsocketUrl(endpoint);\n        this._rpcClient = createRpcClient(endpoint, httpHeaders, fetch, fetchMiddleware, disableRetryOnRateLimit, httpAgent);\n        this._rpcRequest = createRpcRequest(this._rpcClient);\n        this._rpcBatchRequest = createRpcBatchRequest(this._rpcClient);\n        this._rpcWebSocket = new RpcWebSocketClient(this._rpcWsEndpoint, {\n            autoconnect: false,\n            max_reconnects: Infinity\n        });\n        this._rpcWebSocket.on(\"open\", this._wsOnOpen.bind(this));\n        this._rpcWebSocket.on(\"error\", this._wsOnError.bind(this));\n        this._rpcWebSocket.on(\"close\", this._wsOnClose.bind(this));\n        this._rpcWebSocket.on(\"accountNotification\", this._wsOnAccountNotification.bind(this));\n        this._rpcWebSocket.on(\"programNotification\", this._wsOnProgramAccountNotification.bind(this));\n        this._rpcWebSocket.on(\"slotNotification\", this._wsOnSlotNotification.bind(this));\n        this._rpcWebSocket.on(\"slotsUpdatesNotification\", this._wsOnSlotUpdatesNotification.bind(this));\n        this._rpcWebSocket.on(\"signatureNotification\", this._wsOnSignatureNotification.bind(this));\n        this._rpcWebSocket.on(\"rootNotification\", this._wsOnRootNotification.bind(this));\n        this._rpcWebSocket.on(\"logsNotification\", this._wsOnLogsNotification.bind(this));\n    }\n    /**\n   * The default commitment used for requests\n   */ get commitment() {\n        return this._commitment;\n    }\n    /**\n   * The RPC endpoint\n   */ get rpcEndpoint() {\n        return this._rpcEndpoint;\n    }\n    /**\n   * Fetch the balance for the specified public key, return with context\n   */ async getBalanceAndContext(publicKey, commitmentOrConfig) {\n        /** @internal */ const { commitment, config } = extractCommitmentFromConfig(commitmentOrConfig);\n        const args = this._buildArgs([\n            publicKey.toBase58()\n        ], commitment, undefined /* encoding */ , config);\n        const unsafeRes = await this._rpcRequest(\"getBalance\", args);\n        const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.create)(unsafeRes, jsonRpcResultAndContext((0,superstruct__WEBPACK_IMPORTED_MODULE_15__.number)()));\n        if (\"error\" in res) {\n            throw new SolanaJSONRPCError(res.error, `failed to get balance for ${publicKey.toBase58()}`);\n        }\n        return res.result;\n    }\n    /**\n   * Fetch the balance for the specified public key\n   */ async getBalance(publicKey, commitmentOrConfig) {\n        return await this.getBalanceAndContext(publicKey, commitmentOrConfig).then((x)=>x.value).catch((e)=>{\n            throw new Error(\"failed to get balance of account \" + publicKey.toBase58() + \": \" + e);\n        });\n    }\n    /**\n   * Fetch the estimated production time of a block\n   */ async getBlockTime(slot) {\n        const unsafeRes = await this._rpcRequest(\"getBlockTime\", [\n            slot\n        ]);\n        const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.create)(unsafeRes, jsonRpcResult((0,superstruct__WEBPACK_IMPORTED_MODULE_15__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_15__.number)())));\n        if (\"error\" in res) {\n            throw new SolanaJSONRPCError(res.error, `failed to get block time for slot ${slot}`);\n        }\n        return res.result;\n    }\n    /**\n   * Fetch the lowest slot that the node has information about in its ledger.\n   * This value may increase over time if the node is configured to purge older ledger data\n   */ async getMinimumLedgerSlot() {\n        const unsafeRes = await this._rpcRequest(\"minimumLedgerSlot\", []);\n        const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.create)(unsafeRes, jsonRpcResult((0,superstruct__WEBPACK_IMPORTED_MODULE_15__.number)()));\n        if (\"error\" in res) {\n            throw new SolanaJSONRPCError(res.error, \"failed to get minimum ledger slot\");\n        }\n        return res.result;\n    }\n    /**\n   * Fetch the slot of the lowest confirmed block that has not been purged from the ledger\n   */ async getFirstAvailableBlock() {\n        const unsafeRes = await this._rpcRequest(\"getFirstAvailableBlock\", []);\n        const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.create)(unsafeRes, SlotRpcResult);\n        if (\"error\" in res) {\n            throw new SolanaJSONRPCError(res.error, \"failed to get first available block\");\n        }\n        return res.result;\n    }\n    /**\n   * Fetch information about the current supply\n   */ async getSupply(config) {\n        let configArg = {};\n        if (typeof config === \"string\") {\n            configArg = {\n                commitment: config\n            };\n        } else if (config) {\n            configArg = {\n                ...config,\n                commitment: config && config.commitment || this.commitment\n            };\n        } else {\n            configArg = {\n                commitment: this.commitment\n            };\n        }\n        const unsafeRes = await this._rpcRequest(\"getSupply\", [\n            configArg\n        ]);\n        const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.create)(unsafeRes, GetSupplyRpcResult);\n        if (\"error\" in res) {\n            throw new SolanaJSONRPCError(res.error, \"failed to get supply\");\n        }\n        return res.result;\n    }\n    /**\n   * Fetch the current supply of a token mint\n   */ async getTokenSupply(tokenMintAddress, commitment) {\n        const args = this._buildArgs([\n            tokenMintAddress.toBase58()\n        ], commitment);\n        const unsafeRes = await this._rpcRequest(\"getTokenSupply\", args);\n        const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.create)(unsafeRes, jsonRpcResultAndContext(TokenAmountResult));\n        if (\"error\" in res) {\n            throw new SolanaJSONRPCError(res.error, \"failed to get token supply\");\n        }\n        return res.result;\n    }\n    /**\n   * Fetch the current balance of a token account\n   */ async getTokenAccountBalance(tokenAddress, commitment) {\n        const args = this._buildArgs([\n            tokenAddress.toBase58()\n        ], commitment);\n        const unsafeRes = await this._rpcRequest(\"getTokenAccountBalance\", args);\n        const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.create)(unsafeRes, jsonRpcResultAndContext(TokenAmountResult));\n        if (\"error\" in res) {\n            throw new SolanaJSONRPCError(res.error, \"failed to get token account balance\");\n        }\n        return res.result;\n    }\n    /**\n   * Fetch all the token accounts owned by the specified account\n   *\n   * @return {Promise<RpcResponseAndContext<GetProgramAccountsResponse>}\n   */ async getTokenAccountsByOwner(ownerAddress, filter, commitmentOrConfig) {\n        const { commitment, config } = extractCommitmentFromConfig(commitmentOrConfig);\n        let _args = [\n            ownerAddress.toBase58()\n        ];\n        if (\"mint\" in filter) {\n            _args.push({\n                mint: filter.mint.toBase58()\n            });\n        } else {\n            _args.push({\n                programId: filter.programId.toBase58()\n            });\n        }\n        const args = this._buildArgs(_args, commitment, \"base64\", config);\n        const unsafeRes = await this._rpcRequest(\"getTokenAccountsByOwner\", args);\n        const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.create)(unsafeRes, GetTokenAccountsByOwner);\n        if (\"error\" in res) {\n            throw new SolanaJSONRPCError(res.error, `failed to get token accounts owned by account ${ownerAddress.toBase58()}`);\n        }\n        return res.result;\n    }\n    /**\n   * Fetch parsed token accounts owned by the specified account\n   *\n   * @return {Promise<RpcResponseAndContext<Array<{pubkey: PublicKey, account: AccountInfo<ParsedAccountData>}>>>}\n   */ async getParsedTokenAccountsByOwner(ownerAddress, filter, commitment) {\n        let _args = [\n            ownerAddress.toBase58()\n        ];\n        if (\"mint\" in filter) {\n            _args.push({\n                mint: filter.mint.toBase58()\n            });\n        } else {\n            _args.push({\n                programId: filter.programId.toBase58()\n            });\n        }\n        const args = this._buildArgs(_args, commitment, \"jsonParsed\");\n        const unsafeRes = await this._rpcRequest(\"getTokenAccountsByOwner\", args);\n        const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.create)(unsafeRes, GetParsedTokenAccountsByOwner);\n        if (\"error\" in res) {\n            throw new SolanaJSONRPCError(res.error, `failed to get token accounts owned by account ${ownerAddress.toBase58()}`);\n        }\n        return res.result;\n    }\n    /**\n   * Fetch the 20 largest accounts with their current balances\n   */ async getLargestAccounts(config) {\n        const arg = {\n            ...config,\n            commitment: config && config.commitment || this.commitment\n        };\n        const args = arg.filter || arg.commitment ? [\n            arg\n        ] : [];\n        const unsafeRes = await this._rpcRequest(\"getLargestAccounts\", args);\n        const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.create)(unsafeRes, GetLargestAccountsRpcResult);\n        if (\"error\" in res) {\n            throw new SolanaJSONRPCError(res.error, \"failed to get largest accounts\");\n        }\n        return res.result;\n    }\n    /**\n   * Fetch the 20 largest token accounts with their current balances\n   * for a given mint.\n   */ async getTokenLargestAccounts(mintAddress, commitment) {\n        const args = this._buildArgs([\n            mintAddress.toBase58()\n        ], commitment);\n        const unsafeRes = await this._rpcRequest(\"getTokenLargestAccounts\", args);\n        const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.create)(unsafeRes, GetTokenLargestAccountsResult);\n        if (\"error\" in res) {\n            throw new SolanaJSONRPCError(res.error, \"failed to get token largest accounts\");\n        }\n        return res.result;\n    }\n    /**\n   * Fetch all the account info for the specified public key, return with context\n   */ async getAccountInfoAndContext(publicKey, commitmentOrConfig) {\n        const { commitment, config } = extractCommitmentFromConfig(commitmentOrConfig);\n        const args = this._buildArgs([\n            publicKey.toBase58()\n        ], commitment, \"base64\", config);\n        const unsafeRes = await this._rpcRequest(\"getAccountInfo\", args);\n        const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.create)(unsafeRes, jsonRpcResultAndContext((0,superstruct__WEBPACK_IMPORTED_MODULE_15__.nullable)(AccountInfoResult)));\n        if (\"error\" in res) {\n            throw new SolanaJSONRPCError(res.error, `failed to get info about account ${publicKey.toBase58()}`);\n        }\n        return res.result;\n    }\n    /**\n   * Fetch parsed account info for the specified public key\n   */ async getParsedAccountInfo(publicKey, commitmentOrConfig) {\n        const { commitment, config } = extractCommitmentFromConfig(commitmentOrConfig);\n        const args = this._buildArgs([\n            publicKey.toBase58()\n        ], commitment, \"jsonParsed\", config);\n        const unsafeRes = await this._rpcRequest(\"getAccountInfo\", args);\n        const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.create)(unsafeRes, jsonRpcResultAndContext((0,superstruct__WEBPACK_IMPORTED_MODULE_15__.nullable)(ParsedAccountInfoResult)));\n        if (\"error\" in res) {\n            throw new SolanaJSONRPCError(res.error, `failed to get info about account ${publicKey.toBase58()}`);\n        }\n        return res.result;\n    }\n    /**\n   * Fetch all the account info for the specified public key\n   */ async getAccountInfo(publicKey, commitmentOrConfig) {\n        try {\n            const res = await this.getAccountInfoAndContext(publicKey, commitmentOrConfig);\n            return res.value;\n        } catch (e) {\n            throw new Error(\"failed to get info about account \" + publicKey.toBase58() + \": \" + e);\n        }\n    }\n    /**\n   * Fetch all the account info for multiple accounts specified by an array of public keys, return with context\n   */ async getMultipleParsedAccounts(publicKeys, rawConfig) {\n        const { commitment, config } = extractCommitmentFromConfig(rawConfig);\n        const keys = publicKeys.map((key)=>key.toBase58());\n        const args = this._buildArgs([\n            keys\n        ], commitment, \"jsonParsed\", config);\n        const unsafeRes = await this._rpcRequest(\"getMultipleAccounts\", args);\n        const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.create)(unsafeRes, jsonRpcResultAndContext((0,superstruct__WEBPACK_IMPORTED_MODULE_15__.array)((0,superstruct__WEBPACK_IMPORTED_MODULE_15__.nullable)(ParsedAccountInfoResult))));\n        if (\"error\" in res) {\n            throw new SolanaJSONRPCError(res.error, `failed to get info for accounts ${keys}`);\n        }\n        return res.result;\n    }\n    /**\n   * Fetch all the account info for multiple accounts specified by an array of public keys, return with context\n   */ async getMultipleAccountsInfoAndContext(publicKeys, commitmentOrConfig) {\n        const { commitment, config } = extractCommitmentFromConfig(commitmentOrConfig);\n        const keys = publicKeys.map((key)=>key.toBase58());\n        const args = this._buildArgs([\n            keys\n        ], commitment, \"base64\", config);\n        const unsafeRes = await this._rpcRequest(\"getMultipleAccounts\", args);\n        const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.create)(unsafeRes, jsonRpcResultAndContext((0,superstruct__WEBPACK_IMPORTED_MODULE_15__.array)((0,superstruct__WEBPACK_IMPORTED_MODULE_15__.nullable)(AccountInfoResult))));\n        if (\"error\" in res) {\n            throw new SolanaJSONRPCError(res.error, `failed to get info for accounts ${keys}`);\n        }\n        return res.result;\n    }\n    /**\n   * Fetch all the account info for multiple accounts specified by an array of public keys\n   */ async getMultipleAccountsInfo(publicKeys, commitmentOrConfig) {\n        const res = await this.getMultipleAccountsInfoAndContext(publicKeys, commitmentOrConfig);\n        return res.value;\n    }\n    /**\n   * Returns epoch activation information for a stake account that has been delegated\n   */ async getStakeActivation(publicKey, commitmentOrConfig, epoch) {\n        const { commitment, config } = extractCommitmentFromConfig(commitmentOrConfig);\n        const args = this._buildArgs([\n            publicKey.toBase58()\n        ], commitment, undefined /* encoding */ , {\n            ...config,\n            epoch: epoch != null ? epoch : config?.epoch\n        });\n        const unsafeRes = await this._rpcRequest(\"getStakeActivation\", args);\n        const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.create)(unsafeRes, jsonRpcResult(StakeActivationResult));\n        if (\"error\" in res) {\n            throw new SolanaJSONRPCError(res.error, `failed to get Stake Activation ${publicKey.toBase58()}`);\n        }\n        return res.result;\n    }\n    /**\n   * Fetch all the accounts owned by the specified program id\n   *\n   * @return {Promise<Array<{pubkey: PublicKey, account: AccountInfo<Buffer>}>>}\n   */ // eslint-disable-next-line no-dupe-class-members\n    // eslint-disable-next-line no-dupe-class-members\n    async getProgramAccounts(programId, configOrCommitment) {\n        const { commitment, config } = extractCommitmentFromConfig(configOrCommitment);\n        const { encoding, ...configWithoutEncoding } = config || {};\n        const args = this._buildArgs([\n            programId.toBase58()\n        ], commitment, encoding || \"base64\", configWithoutEncoding);\n        const unsafeRes = await this._rpcRequest(\"getProgramAccounts\", args);\n        const baseSchema = (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.array)(KeyedAccountInfoResult);\n        const res = configWithoutEncoding.withContext === true ? (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.create)(unsafeRes, jsonRpcResultAndContext(baseSchema)) : (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.create)(unsafeRes, jsonRpcResult(baseSchema));\n        if (\"error\" in res) {\n            throw new SolanaJSONRPCError(res.error, `failed to get accounts owned by program ${programId.toBase58()}`);\n        }\n        return res.result;\n    }\n    /**\n   * Fetch and parse all the accounts owned by the specified program id\n   *\n   * @return {Promise<Array<{pubkey: PublicKey, account: AccountInfo<Buffer | ParsedAccountData>}>>}\n   */ async getParsedProgramAccounts(programId, configOrCommitment) {\n        const { commitment, config } = extractCommitmentFromConfig(configOrCommitment);\n        const args = this._buildArgs([\n            programId.toBase58()\n        ], commitment, \"jsonParsed\", config);\n        const unsafeRes = await this._rpcRequest(\"getProgramAccounts\", args);\n        const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.create)(unsafeRes, jsonRpcResult((0,superstruct__WEBPACK_IMPORTED_MODULE_15__.array)(KeyedParsedAccountInfoResult)));\n        if (\"error\" in res) {\n            throw new SolanaJSONRPCError(res.error, `failed to get accounts owned by program ${programId.toBase58()}`);\n        }\n        return res.result;\n    }\n    /** @deprecated Instead, call `confirmTransaction` and pass in {@link TransactionConfirmationStrategy} */ // eslint-disable-next-line no-dupe-class-members\n    // eslint-disable-next-line no-dupe-class-members\n    async confirmTransaction(strategy, commitment) {\n        let rawSignature;\n        if (typeof strategy == \"string\") {\n            rawSignature = strategy;\n        } else {\n            const config = strategy;\n            if (config.abortSignal?.aborted) {\n                return Promise.reject(config.abortSignal.reason);\n            }\n            rawSignature = config.signature;\n        }\n        let decodedSignature;\n        try {\n            decodedSignature = bs58__WEBPACK_IMPORTED_MODULE_2___default().decode(rawSignature);\n        } catch (err) {\n            throw new Error(\"signature must be base58 encoded: \" + rawSignature);\n        }\n        assert(decodedSignature.length === 64, \"signature has invalid length\");\n        if (typeof strategy === \"string\") {\n            return await this.confirmTransactionUsingLegacyTimeoutStrategy({\n                commitment: commitment || this.commitment,\n                signature: rawSignature\n            });\n        } else if (\"lastValidBlockHeight\" in strategy) {\n            return await this.confirmTransactionUsingBlockHeightExceedanceStrategy({\n                commitment: commitment || this.commitment,\n                strategy\n            });\n        } else {\n            return await this.confirmTransactionUsingDurableNonceStrategy({\n                commitment: commitment || this.commitment,\n                strategy\n            });\n        }\n    }\n    getCancellationPromise(signal) {\n        return new Promise((_, reject)=>{\n            if (signal == null) {\n                return;\n            }\n            if (signal.aborted) {\n                reject(signal.reason);\n            } else {\n                signal.addEventListener(\"abort\", ()=>{\n                    reject(signal.reason);\n                });\n            }\n        });\n    }\n    getTransactionConfirmationPromise({ commitment, signature }) {\n        let signatureSubscriptionId;\n        let disposeSignatureSubscriptionStateChangeObserver;\n        let done = false;\n        const confirmationPromise = new Promise((resolve, reject)=>{\n            try {\n                signatureSubscriptionId = this.onSignature(signature, (result, context)=>{\n                    signatureSubscriptionId = undefined;\n                    const response = {\n                        context,\n                        value: result\n                    };\n                    resolve({\n                        __type: TransactionStatus.PROCESSED,\n                        response\n                    });\n                }, commitment);\n                const subscriptionSetupPromise = new Promise((resolveSubscriptionSetup)=>{\n                    if (signatureSubscriptionId == null) {\n                        resolveSubscriptionSetup();\n                    } else {\n                        disposeSignatureSubscriptionStateChangeObserver = this._onSubscriptionStateChange(signatureSubscriptionId, (nextState)=>{\n                            if (nextState === \"subscribed\") {\n                                resolveSubscriptionSetup();\n                            }\n                        });\n                    }\n                });\n                (async ()=>{\n                    await subscriptionSetupPromise;\n                    if (done) return;\n                    const response = await this.getSignatureStatus(signature);\n                    if (done) return;\n                    if (response == null) {\n                        return;\n                    }\n                    const { context, value } = response;\n                    if (value == null) {\n                        return;\n                    }\n                    if (value?.err) {\n                        reject(value.err);\n                    } else {\n                        switch(commitment){\n                            case \"confirmed\":\n                            case \"single\":\n                            case \"singleGossip\":\n                                {\n                                    if (value.confirmationStatus === \"processed\") {\n                                        return;\n                                    }\n                                    break;\n                                }\n                            case \"finalized\":\n                            case \"max\":\n                            case \"root\":\n                                {\n                                    if (value.confirmationStatus === \"processed\" || value.confirmationStatus === \"confirmed\") {\n                                        return;\n                                    }\n                                    break;\n                                }\n                            // exhaust enums to ensure full coverage\n                            case \"processed\":\n                            case \"recent\":\n                        }\n                        done = true;\n                        resolve({\n                            __type: TransactionStatus.PROCESSED,\n                            response: {\n                                context,\n                                value\n                            }\n                        });\n                    }\n                })();\n            } catch (err) {\n                reject(err);\n            }\n        });\n        const abortConfirmation = ()=>{\n            if (disposeSignatureSubscriptionStateChangeObserver) {\n                disposeSignatureSubscriptionStateChangeObserver();\n                disposeSignatureSubscriptionStateChangeObserver = undefined;\n            }\n            if (signatureSubscriptionId != null) {\n                this.removeSignatureListener(signatureSubscriptionId);\n                signatureSubscriptionId = undefined;\n            }\n        };\n        return {\n            abortConfirmation,\n            confirmationPromise\n        };\n    }\n    async confirmTransactionUsingBlockHeightExceedanceStrategy({ commitment, strategy: { abortSignal, lastValidBlockHeight, signature } }) {\n        let done = false;\n        const expiryPromise = new Promise((resolve)=>{\n            const checkBlockHeight = async ()=>{\n                try {\n                    const blockHeight = await this.getBlockHeight(commitment);\n                    return blockHeight;\n                } catch (_e) {\n                    return -1;\n                }\n            };\n            (async ()=>{\n                let currentBlockHeight = await checkBlockHeight();\n                if (done) return;\n                while(currentBlockHeight <= lastValidBlockHeight){\n                    await sleep(1000);\n                    if (done) return;\n                    currentBlockHeight = await checkBlockHeight();\n                    if (done) return;\n                }\n                resolve({\n                    __type: TransactionStatus.BLOCKHEIGHT_EXCEEDED\n                });\n            })();\n        });\n        const { abortConfirmation, confirmationPromise } = this.getTransactionConfirmationPromise({\n            commitment,\n            signature\n        });\n        const cancellationPromise = this.getCancellationPromise(abortSignal);\n        let result;\n        try {\n            const outcome = await Promise.race([\n                cancellationPromise,\n                confirmationPromise,\n                expiryPromise\n            ]);\n            if (outcome.__type === TransactionStatus.PROCESSED) {\n                result = outcome.response;\n            } else {\n                throw new TransactionExpiredBlockheightExceededError(signature);\n            }\n        } finally{\n            done = true;\n            abortConfirmation();\n        }\n        return result;\n    }\n    async confirmTransactionUsingDurableNonceStrategy({ commitment, strategy: { abortSignal, minContextSlot, nonceAccountPubkey, nonceValue, signature } }) {\n        let done = false;\n        const expiryPromise = new Promise((resolve)=>{\n            let currentNonceValue = nonceValue;\n            let lastCheckedSlot = null;\n            const getCurrentNonceValue = async ()=>{\n                try {\n                    const { context, value: nonceAccount } = await this.getNonceAndContext(nonceAccountPubkey, {\n                        commitment,\n                        minContextSlot\n                    });\n                    lastCheckedSlot = context.slot;\n                    return nonceAccount?.nonce;\n                } catch (e) {\n                    // If for whatever reason we can't reach/read the nonce\n                    // account, just keep using the last-known value.\n                    return currentNonceValue;\n                }\n            };\n            (async ()=>{\n                currentNonceValue = await getCurrentNonceValue();\n                if (done) return;\n                while(true // eslint-disable-line no-constant-condition\n                ){\n                    if (nonceValue !== currentNonceValue) {\n                        resolve({\n                            __type: TransactionStatus.NONCE_INVALID,\n                            slotInWhichNonceDidAdvance: lastCheckedSlot\n                        });\n                        return;\n                    }\n                    await sleep(2000);\n                    if (done) return;\n                    currentNonceValue = await getCurrentNonceValue();\n                    if (done) return;\n                }\n            })();\n        });\n        const { abortConfirmation, confirmationPromise } = this.getTransactionConfirmationPromise({\n            commitment,\n            signature\n        });\n        const cancellationPromise = this.getCancellationPromise(abortSignal);\n        let result;\n        try {\n            const outcome = await Promise.race([\n                cancellationPromise,\n                confirmationPromise,\n                expiryPromise\n            ]);\n            if (outcome.__type === TransactionStatus.PROCESSED) {\n                result = outcome.response;\n            } else {\n                // Double check that the transaction is indeed unconfirmed.\n                let signatureStatus;\n                while(true // eslint-disable-line no-constant-condition\n                ){\n                    const status = await this.getSignatureStatus(signature);\n                    if (status == null) {\n                        break;\n                    }\n                    if (status.context.slot < (outcome.slotInWhichNonceDidAdvance ?? minContextSlot)) {\n                        await sleep(400);\n                        continue;\n                    }\n                    signatureStatus = status;\n                    break;\n                }\n                if (signatureStatus?.value) {\n                    const commitmentForStatus = commitment || \"finalized\";\n                    const { confirmationStatus } = signatureStatus.value;\n                    switch(commitmentForStatus){\n                        case \"processed\":\n                        case \"recent\":\n                            if (confirmationStatus !== \"processed\" && confirmationStatus !== \"confirmed\" && confirmationStatus !== \"finalized\") {\n                                throw new TransactionExpiredNonceInvalidError(signature);\n                            }\n                            break;\n                        case \"confirmed\":\n                        case \"single\":\n                        case \"singleGossip\":\n                            if (confirmationStatus !== \"confirmed\" && confirmationStatus !== \"finalized\") {\n                                throw new TransactionExpiredNonceInvalidError(signature);\n                            }\n                            break;\n                        case \"finalized\":\n                        case \"max\":\n                        case \"root\":\n                            if (confirmationStatus !== \"finalized\") {\n                                throw new TransactionExpiredNonceInvalidError(signature);\n                            }\n                            break;\n                        default:\n                            // Exhaustive switch.\n                            // eslint-disable-next-line @typescript-eslint/no-unused-vars\n                            ((_)=>{})(commitmentForStatus);\n                    }\n                    result = {\n                        context: signatureStatus.context,\n                        value: {\n                            err: signatureStatus.value.err\n                        }\n                    };\n                } else {\n                    throw new TransactionExpiredNonceInvalidError(signature);\n                }\n            }\n        } finally{\n            done = true;\n            abortConfirmation();\n        }\n        return result;\n    }\n    async confirmTransactionUsingLegacyTimeoutStrategy({ commitment, signature }) {\n        let timeoutId;\n        const expiryPromise = new Promise((resolve)=>{\n            let timeoutMs = this._confirmTransactionInitialTimeout || 60 * 1000;\n            switch(commitment){\n                case \"processed\":\n                case \"recent\":\n                case \"single\":\n                case \"confirmed\":\n                case \"singleGossip\":\n                    {\n                        timeoutMs = this._confirmTransactionInitialTimeout || 30 * 1000;\n                        break;\n                    }\n            }\n            timeoutId = setTimeout(()=>resolve({\n                    __type: TransactionStatus.TIMED_OUT,\n                    timeoutMs\n                }), timeoutMs);\n        });\n        const { abortConfirmation, confirmationPromise } = this.getTransactionConfirmationPromise({\n            commitment,\n            signature\n        });\n        let result;\n        try {\n            const outcome = await Promise.race([\n                confirmationPromise,\n                expiryPromise\n            ]);\n            if (outcome.__type === TransactionStatus.PROCESSED) {\n                result = outcome.response;\n            } else {\n                throw new TransactionExpiredTimeoutError(signature, outcome.timeoutMs / 1000);\n            }\n        } finally{\n            clearTimeout(timeoutId);\n            abortConfirmation();\n        }\n        return result;\n    }\n    /**\n   * Return the list of nodes that are currently participating in the cluster\n   */ async getClusterNodes() {\n        const unsafeRes = await this._rpcRequest(\"getClusterNodes\", []);\n        const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.create)(unsafeRes, jsonRpcResult((0,superstruct__WEBPACK_IMPORTED_MODULE_15__.array)(ContactInfoResult)));\n        if (\"error\" in res) {\n            throw new SolanaJSONRPCError(res.error, \"failed to get cluster nodes\");\n        }\n        return res.result;\n    }\n    /**\n   * Return the list of nodes that are currently participating in the cluster\n   */ async getVoteAccounts(commitment) {\n        const args = this._buildArgs([], commitment);\n        const unsafeRes = await this._rpcRequest(\"getVoteAccounts\", args);\n        const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.create)(unsafeRes, GetVoteAccounts);\n        if (\"error\" in res) {\n            throw new SolanaJSONRPCError(res.error, \"failed to get vote accounts\");\n        }\n        return res.result;\n    }\n    /**\n   * Fetch the current slot that the node is processing\n   */ async getSlot(commitmentOrConfig) {\n        const { commitment, config } = extractCommitmentFromConfig(commitmentOrConfig);\n        const args = this._buildArgs([], commitment, undefined /* encoding */ , config);\n        const unsafeRes = await this._rpcRequest(\"getSlot\", args);\n        const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.create)(unsafeRes, jsonRpcResult((0,superstruct__WEBPACK_IMPORTED_MODULE_15__.number)()));\n        if (\"error\" in res) {\n            throw new SolanaJSONRPCError(res.error, \"failed to get slot\");\n        }\n        return res.result;\n    }\n    /**\n   * Fetch the current slot leader of the cluster\n   */ async getSlotLeader(commitmentOrConfig) {\n        const { commitment, config } = extractCommitmentFromConfig(commitmentOrConfig);\n        const args = this._buildArgs([], commitment, undefined /* encoding */ , config);\n        const unsafeRes = await this._rpcRequest(\"getSlotLeader\", args);\n        const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.create)(unsafeRes, jsonRpcResult((0,superstruct__WEBPACK_IMPORTED_MODULE_15__.string)()));\n        if (\"error\" in res) {\n            throw new SolanaJSONRPCError(res.error, \"failed to get slot leader\");\n        }\n        return res.result;\n    }\n    /**\n   * Fetch `limit` number of slot leaders starting from `startSlot`\n   *\n   * @param startSlot fetch slot leaders starting from this slot\n   * @param limit number of slot leaders to return\n   */ async getSlotLeaders(startSlot, limit) {\n        const args = [\n            startSlot,\n            limit\n        ];\n        const unsafeRes = await this._rpcRequest(\"getSlotLeaders\", args);\n        const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.create)(unsafeRes, jsonRpcResult((0,superstruct__WEBPACK_IMPORTED_MODULE_15__.array)(PublicKeyFromString)));\n        if (\"error\" in res) {\n            throw new SolanaJSONRPCError(res.error, \"failed to get slot leaders\");\n        }\n        return res.result;\n    }\n    /**\n   * Fetch the current status of a signature\n   */ async getSignatureStatus(signature, config) {\n        const { context, value: values } = await this.getSignatureStatuses([\n            signature\n        ], config);\n        assert(values.length === 1);\n        const value = values[0];\n        return {\n            context,\n            value\n        };\n    }\n    /**\n   * Fetch the current statuses of a batch of signatures\n   */ async getSignatureStatuses(signatures, config) {\n        const params = [\n            signatures\n        ];\n        if (config) {\n            params.push(config);\n        }\n        const unsafeRes = await this._rpcRequest(\"getSignatureStatuses\", params);\n        const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.create)(unsafeRes, GetSignatureStatusesRpcResult);\n        if (\"error\" in res) {\n            throw new SolanaJSONRPCError(res.error, \"failed to get signature status\");\n        }\n        return res.result;\n    }\n    /**\n   * Fetch the current transaction count of the cluster\n   */ async getTransactionCount(commitmentOrConfig) {\n        const { commitment, config } = extractCommitmentFromConfig(commitmentOrConfig);\n        const args = this._buildArgs([], commitment, undefined /* encoding */ , config);\n        const unsafeRes = await this._rpcRequest(\"getTransactionCount\", args);\n        const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.create)(unsafeRes, jsonRpcResult((0,superstruct__WEBPACK_IMPORTED_MODULE_15__.number)()));\n        if (\"error\" in res) {\n            throw new SolanaJSONRPCError(res.error, \"failed to get transaction count\");\n        }\n        return res.result;\n    }\n    /**\n   * Fetch the current total currency supply of the cluster in lamports\n   *\n   * @deprecated Deprecated since v1.2.8. Please use {@link getSupply} instead.\n   */ async getTotalSupply(commitment) {\n        const result = await this.getSupply({\n            commitment,\n            excludeNonCirculatingAccountsList: true\n        });\n        return result.value.total;\n    }\n    /**\n   * Fetch the cluster InflationGovernor parameters\n   */ async getInflationGovernor(commitment) {\n        const args = this._buildArgs([], commitment);\n        const unsafeRes = await this._rpcRequest(\"getInflationGovernor\", args);\n        const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.create)(unsafeRes, GetInflationGovernorRpcResult);\n        if (\"error\" in res) {\n            throw new SolanaJSONRPCError(res.error, \"failed to get inflation\");\n        }\n        return res.result;\n    }\n    /**\n   * Fetch the inflation reward for a list of addresses for an epoch\n   */ async getInflationReward(addresses, epoch, commitmentOrConfig) {\n        const { commitment, config } = extractCommitmentFromConfig(commitmentOrConfig);\n        const args = this._buildArgs([\n            addresses.map((pubkey)=>pubkey.toBase58())\n        ], commitment, undefined /* encoding */ , {\n            ...config,\n            epoch: epoch != null ? epoch : config?.epoch\n        });\n        const unsafeRes = await this._rpcRequest(\"getInflationReward\", args);\n        const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.create)(unsafeRes, GetInflationRewardResult);\n        if (\"error\" in res) {\n            throw new SolanaJSONRPCError(res.error, \"failed to get inflation reward\");\n        }\n        return res.result;\n    }\n    /**\n   * Fetch the specific inflation values for the current epoch\n   */ async getInflationRate() {\n        const unsafeRes = await this._rpcRequest(\"getInflationRate\", []);\n        const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.create)(unsafeRes, GetInflationRateRpcResult);\n        if (\"error\" in res) {\n            throw new SolanaJSONRPCError(res.error, \"failed to get inflation rate\");\n        }\n        return res.result;\n    }\n    /**\n   * Fetch the Epoch Info parameters\n   */ async getEpochInfo(commitmentOrConfig) {\n        const { commitment, config } = extractCommitmentFromConfig(commitmentOrConfig);\n        const args = this._buildArgs([], commitment, undefined /* encoding */ , config);\n        const unsafeRes = await this._rpcRequest(\"getEpochInfo\", args);\n        const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.create)(unsafeRes, GetEpochInfoRpcResult);\n        if (\"error\" in res) {\n            throw new SolanaJSONRPCError(res.error, \"failed to get epoch info\");\n        }\n        return res.result;\n    }\n    /**\n   * Fetch the Epoch Schedule parameters\n   */ async getEpochSchedule() {\n        const unsafeRes = await this._rpcRequest(\"getEpochSchedule\", []);\n        const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.create)(unsafeRes, GetEpochScheduleRpcResult);\n        if (\"error\" in res) {\n            throw new SolanaJSONRPCError(res.error, \"failed to get epoch schedule\");\n        }\n        const epochSchedule = res.result;\n        return new EpochSchedule(epochSchedule.slotsPerEpoch, epochSchedule.leaderScheduleSlotOffset, epochSchedule.warmup, epochSchedule.firstNormalEpoch, epochSchedule.firstNormalSlot);\n    }\n    /**\n   * Fetch the leader schedule for the current epoch\n   * @return {Promise<RpcResponseAndContext<LeaderSchedule>>}\n   */ async getLeaderSchedule() {\n        const unsafeRes = await this._rpcRequest(\"getLeaderSchedule\", []);\n        const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.create)(unsafeRes, GetLeaderScheduleRpcResult);\n        if (\"error\" in res) {\n            throw new SolanaJSONRPCError(res.error, \"failed to get leader schedule\");\n        }\n        return res.result;\n    }\n    /**\n   * Fetch the minimum balance needed to exempt an account of `dataLength`\n   * size from rent\n   */ async getMinimumBalanceForRentExemption(dataLength, commitment) {\n        const args = this._buildArgs([\n            dataLength\n        ], commitment);\n        const unsafeRes = await this._rpcRequest(\"getMinimumBalanceForRentExemption\", args);\n        const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.create)(unsafeRes, GetMinimumBalanceForRentExemptionRpcResult);\n        if (\"error\" in res) {\n            console.warn(\"Unable to fetch minimum balance for rent exemption\");\n            return 0;\n        }\n        return res.result;\n    }\n    /**\n   * Fetch a recent blockhash from the cluster, return with context\n   * @return {Promise<RpcResponseAndContext<{blockhash: Blockhash, feeCalculator: FeeCalculator}>>}\n   *\n   * @deprecated Deprecated since Solana v1.8.0. Please use {@link getLatestBlockhash} instead.\n   */ async getRecentBlockhashAndContext(commitment) {\n        const args = this._buildArgs([], commitment);\n        const unsafeRes = await this._rpcRequest(\"getRecentBlockhash\", args);\n        const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.create)(unsafeRes, GetRecentBlockhashAndContextRpcResult);\n        if (\"error\" in res) {\n            throw new SolanaJSONRPCError(res.error, \"failed to get recent blockhash\");\n        }\n        return res.result;\n    }\n    /**\n   * Fetch recent performance samples\n   * @return {Promise<Array<PerfSample>>}\n   */ async getRecentPerformanceSamples(limit) {\n        const unsafeRes = await this._rpcRequest(\"getRecentPerformanceSamples\", limit ? [\n            limit\n        ] : []);\n        const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.create)(unsafeRes, GetRecentPerformanceSamplesRpcResult);\n        if (\"error\" in res) {\n            throw new SolanaJSONRPCError(res.error, \"failed to get recent performance samples\");\n        }\n        return res.result;\n    }\n    /**\n   * Fetch the fee calculator for a recent blockhash from the cluster, return with context\n   *\n   * @deprecated Deprecated since Solana v1.8.0. Please use {@link getFeeForMessage} instead.\n   */ async getFeeCalculatorForBlockhash(blockhash, commitment) {\n        const args = this._buildArgs([\n            blockhash\n        ], commitment);\n        const unsafeRes = await this._rpcRequest(\"getFeeCalculatorForBlockhash\", args);\n        const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.create)(unsafeRes, GetFeeCalculatorRpcResult);\n        if (\"error\" in res) {\n            throw new SolanaJSONRPCError(res.error, \"failed to get fee calculator\");\n        }\n        const { context, value } = res.result;\n        return {\n            context,\n            value: value !== null ? value.feeCalculator : null\n        };\n    }\n    /**\n   * Fetch the fee for a message from the cluster, return with context\n   */ async getFeeForMessage(message, commitment) {\n        const wireMessage = toBuffer(message.serialize()).toString(\"base64\");\n        const args = this._buildArgs([\n            wireMessage\n        ], commitment);\n        const unsafeRes = await this._rpcRequest(\"getFeeForMessage\", args);\n        const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.create)(unsafeRes, jsonRpcResultAndContext((0,superstruct__WEBPACK_IMPORTED_MODULE_15__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_15__.number)())));\n        if (\"error\" in res) {\n            throw new SolanaJSONRPCError(res.error, \"failed to get fee for message\");\n        }\n        if (res.result === null) {\n            throw new Error(\"invalid blockhash\");\n        }\n        return res.result;\n    }\n    /**\n   * Fetch a list of prioritization fees from recent blocks.\n   */ async getRecentPrioritizationFees(config) {\n        const accounts = config?.lockedWritableAccounts?.map((key)=>key.toBase58());\n        const args = accounts?.length ? [\n            accounts\n        ] : [];\n        const unsafeRes = await this._rpcRequest(\"getRecentPrioritizationFees\", args);\n        const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.create)(unsafeRes, GetRecentPrioritizationFeesRpcResult);\n        if (\"error\" in res) {\n            throw new SolanaJSONRPCError(res.error, \"failed to get recent prioritization fees\");\n        }\n        return res.result;\n    }\n    /**\n   * Fetch a recent blockhash from the cluster\n   * @return {Promise<{blockhash: Blockhash, feeCalculator: FeeCalculator}>}\n   *\n   * @deprecated Deprecated since Solana v1.8.0. Please use {@link getLatestBlockhash} instead.\n   */ async getRecentBlockhash(commitment) {\n        try {\n            const res = await this.getRecentBlockhashAndContext(commitment);\n            return res.value;\n        } catch (e) {\n            throw new Error(\"failed to get recent blockhash: \" + e);\n        }\n    }\n    /**\n   * Fetch the latest blockhash from the cluster\n   * @return {Promise<BlockhashWithExpiryBlockHeight>}\n   */ async getLatestBlockhash(commitmentOrConfig) {\n        try {\n            const res = await this.getLatestBlockhashAndContext(commitmentOrConfig);\n            return res.value;\n        } catch (e) {\n            throw new Error(\"failed to get recent blockhash: \" + e);\n        }\n    }\n    /**\n   * Fetch the latest blockhash from the cluster\n   * @return {Promise<BlockhashWithExpiryBlockHeight>}\n   */ async getLatestBlockhashAndContext(commitmentOrConfig) {\n        const { commitment, config } = extractCommitmentFromConfig(commitmentOrConfig);\n        const args = this._buildArgs([], commitment, undefined /* encoding */ , config);\n        const unsafeRes = await this._rpcRequest(\"getLatestBlockhash\", args);\n        const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.create)(unsafeRes, GetLatestBlockhashRpcResult);\n        if (\"error\" in res) {\n            throw new SolanaJSONRPCError(res.error, \"failed to get latest blockhash\");\n        }\n        return res.result;\n    }\n    /**\n   * Returns whether a blockhash is still valid or not\n   */ async isBlockhashValid(blockhash, rawConfig) {\n        const { commitment, config } = extractCommitmentFromConfig(rawConfig);\n        const args = this._buildArgs([\n            blockhash\n        ], commitment, undefined /* encoding */ , config);\n        const unsafeRes = await this._rpcRequest(\"isBlockhashValid\", args);\n        const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.create)(unsafeRes, IsBlockhashValidRpcResult);\n        if (\"error\" in res) {\n            throw new SolanaJSONRPCError(res.error, \"failed to determine if the blockhash `\" + blockhash + \"`is valid\");\n        }\n        return res.result;\n    }\n    /**\n   * Fetch the node version\n   */ async getVersion() {\n        const unsafeRes = await this._rpcRequest(\"getVersion\", []);\n        const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.create)(unsafeRes, jsonRpcResult(VersionResult));\n        if (\"error\" in res) {\n            throw new SolanaJSONRPCError(res.error, \"failed to get version\");\n        }\n        return res.result;\n    }\n    /**\n   * Fetch the genesis hash\n   */ async getGenesisHash() {\n        const unsafeRes = await this._rpcRequest(\"getGenesisHash\", []);\n        const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.create)(unsafeRes, jsonRpcResult((0,superstruct__WEBPACK_IMPORTED_MODULE_15__.string)()));\n        if (\"error\" in res) {\n            throw new SolanaJSONRPCError(res.error, \"failed to get genesis hash\");\n        }\n        return res.result;\n    }\n    /**\n   * Fetch a processed block from the cluster.\n   *\n   * @deprecated Instead, call `getBlock` using a `GetVersionedBlockConfig` by\n   * setting the `maxSupportedTransactionVersion` property.\n   */ /**\n   * @deprecated Instead, call `getBlock` using a `GetVersionedBlockConfig` by\n   * setting the `maxSupportedTransactionVersion` property.\n   */ // eslint-disable-next-line no-dupe-class-members\n    /**\n   * @deprecated Instead, call `getBlock` using a `GetVersionedBlockConfig` by\n   * setting the `maxSupportedTransactionVersion` property.\n   */ // eslint-disable-next-line no-dupe-class-members\n    /**\n   * Fetch a processed block from the cluster.\n   */ // eslint-disable-next-line no-dupe-class-members\n    // eslint-disable-next-line no-dupe-class-members\n    // eslint-disable-next-line no-dupe-class-members\n    /**\n   * Fetch a processed block from the cluster.\n   */ // eslint-disable-next-line no-dupe-class-members\n    async getBlock(slot, rawConfig) {\n        const { commitment, config } = extractCommitmentFromConfig(rawConfig);\n        const args = this._buildArgsAtLeastConfirmed([\n            slot\n        ], commitment, undefined /* encoding */ , config);\n        const unsafeRes = await this._rpcRequest(\"getBlock\", args);\n        try {\n            switch(config?.transactionDetails){\n                case \"accounts\":\n                    {\n                        const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.create)(unsafeRes, GetAccountsModeBlockRpcResult);\n                        if (\"error\" in res) {\n                            throw res.error;\n                        }\n                        return res.result;\n                    }\n                case \"none\":\n                    {\n                        const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.create)(unsafeRes, GetNoneModeBlockRpcResult);\n                        if (\"error\" in res) {\n                            throw res.error;\n                        }\n                        return res.result;\n                    }\n                default:\n                    {\n                        const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.create)(unsafeRes, GetBlockRpcResult);\n                        if (\"error\" in res) {\n                            throw res.error;\n                        }\n                        const { result } = res;\n                        return result ? {\n                            ...result,\n                            transactions: result.transactions.map(({ transaction, meta, version })=>({\n                                    meta,\n                                    transaction: {\n                                        ...transaction,\n                                        message: versionedMessageFromResponse(version, transaction.message)\n                                    },\n                                    version\n                                }))\n                        } : null;\n                    }\n            }\n        } catch (e) {\n            throw new SolanaJSONRPCError(e, \"failed to get confirmed block\");\n        }\n    }\n    /**\n   * Fetch parsed transaction details for a confirmed or finalized block\n   */ // eslint-disable-next-line no-dupe-class-members\n    // eslint-disable-next-line no-dupe-class-members\n    // eslint-disable-next-line no-dupe-class-members\n    async getParsedBlock(slot, rawConfig) {\n        const { commitment, config } = extractCommitmentFromConfig(rawConfig);\n        const args = this._buildArgsAtLeastConfirmed([\n            slot\n        ], commitment, \"jsonParsed\", config);\n        const unsafeRes = await this._rpcRequest(\"getBlock\", args);\n        try {\n            switch(config?.transactionDetails){\n                case \"accounts\":\n                    {\n                        const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.create)(unsafeRes, GetParsedAccountsModeBlockRpcResult);\n                        if (\"error\" in res) {\n                            throw res.error;\n                        }\n                        return res.result;\n                    }\n                case \"none\":\n                    {\n                        const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.create)(unsafeRes, GetParsedNoneModeBlockRpcResult);\n                        if (\"error\" in res) {\n                            throw res.error;\n                        }\n                        return res.result;\n                    }\n                default:\n                    {\n                        const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.create)(unsafeRes, GetParsedBlockRpcResult);\n                        if (\"error\" in res) {\n                            throw res.error;\n                        }\n                        return res.result;\n                    }\n            }\n        } catch (e) {\n            throw new SolanaJSONRPCError(e, \"failed to get block\");\n        }\n    }\n    /*\n   * Returns recent block production information from the current or previous epoch\n   */ async getBlockProduction(configOrCommitment) {\n        let extra;\n        let commitment;\n        if (typeof configOrCommitment === \"string\") {\n            commitment = configOrCommitment;\n        } else if (configOrCommitment) {\n            const { commitment: c, ...rest } = configOrCommitment;\n            commitment = c;\n            extra = rest;\n        }\n        const args = this._buildArgs([], commitment, \"base64\", extra);\n        const unsafeRes = await this._rpcRequest(\"getBlockProduction\", args);\n        const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.create)(unsafeRes, BlockProductionResponseStruct);\n        if (\"error\" in res) {\n            throw new SolanaJSONRPCError(res.error, \"failed to get block production information\");\n        }\n        return res.result;\n    }\n    /**\n   * Fetch a confirmed or finalized transaction from the cluster.\n   *\n   * @deprecated Instead, call `getTransaction` using a\n   * `GetVersionedTransactionConfig` by setting the\n   * `maxSupportedTransactionVersion` property.\n   */ /**\n   * Fetch a confirmed or finalized transaction from the cluster.\n   */ // eslint-disable-next-line no-dupe-class-members\n    /**\n   * Fetch a confirmed or finalized transaction from the cluster.\n   */ // eslint-disable-next-line no-dupe-class-members\n    async getTransaction(signature, rawConfig) {\n        const { commitment, config } = extractCommitmentFromConfig(rawConfig);\n        const args = this._buildArgsAtLeastConfirmed([\n            signature\n        ], commitment, undefined /* encoding */ , config);\n        const unsafeRes = await this._rpcRequest(\"getTransaction\", args);\n        const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.create)(unsafeRes, GetTransactionRpcResult);\n        if (\"error\" in res) {\n            throw new SolanaJSONRPCError(res.error, \"failed to get transaction\");\n        }\n        const result = res.result;\n        if (!result) return result;\n        return {\n            ...result,\n            transaction: {\n                ...result.transaction,\n                message: versionedMessageFromResponse(result.version, result.transaction.message)\n            }\n        };\n    }\n    /**\n   * Fetch parsed transaction details for a confirmed or finalized transaction\n   */ async getParsedTransaction(signature, commitmentOrConfig) {\n        const { commitment, config } = extractCommitmentFromConfig(commitmentOrConfig);\n        const args = this._buildArgsAtLeastConfirmed([\n            signature\n        ], commitment, \"jsonParsed\", config);\n        const unsafeRes = await this._rpcRequest(\"getTransaction\", args);\n        const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.create)(unsafeRes, GetParsedTransactionRpcResult);\n        if (\"error\" in res) {\n            throw new SolanaJSONRPCError(res.error, \"failed to get transaction\");\n        }\n        return res.result;\n    }\n    /**\n   * Fetch parsed transaction details for a batch of confirmed transactions\n   */ async getParsedTransactions(signatures, commitmentOrConfig) {\n        const { commitment, config } = extractCommitmentFromConfig(commitmentOrConfig);\n        const batch = signatures.map((signature)=>{\n            const args = this._buildArgsAtLeastConfirmed([\n                signature\n            ], commitment, \"jsonParsed\", config);\n            return {\n                methodName: \"getTransaction\",\n                args\n            };\n        });\n        const unsafeRes = await this._rpcBatchRequest(batch);\n        const res = unsafeRes.map((unsafeRes)=>{\n            const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.create)(unsafeRes, GetParsedTransactionRpcResult);\n            if (\"error\" in res) {\n                throw new SolanaJSONRPCError(res.error, \"failed to get transactions\");\n            }\n            return res.result;\n        });\n        return res;\n    }\n    /**\n   * Fetch transaction details for a batch of confirmed transactions.\n   * Similar to {@link getParsedTransactions} but returns a {@link TransactionResponse}.\n   *\n   * @deprecated Instead, call `getTransactions` using a\n   * `GetVersionedTransactionConfig` by setting the\n   * `maxSupportedTransactionVersion` property.\n   */ /**\n   * Fetch transaction details for a batch of confirmed transactions.\n   * Similar to {@link getParsedTransactions} but returns a {@link\n   * VersionedTransactionResponse}.\n   */ // eslint-disable-next-line no-dupe-class-members\n    /**\n   * Fetch transaction details for a batch of confirmed transactions.\n   * Similar to {@link getParsedTransactions} but returns a {@link\n   * VersionedTransactionResponse}.\n   */ // eslint-disable-next-line no-dupe-class-members\n    async getTransactions(signatures, commitmentOrConfig) {\n        const { commitment, config } = extractCommitmentFromConfig(commitmentOrConfig);\n        const batch = signatures.map((signature)=>{\n            const args = this._buildArgsAtLeastConfirmed([\n                signature\n            ], commitment, undefined /* encoding */ , config);\n            return {\n                methodName: \"getTransaction\",\n                args\n            };\n        });\n        const unsafeRes = await this._rpcBatchRequest(batch);\n        const res = unsafeRes.map((unsafeRes)=>{\n            const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.create)(unsafeRes, GetTransactionRpcResult);\n            if (\"error\" in res) {\n                throw new SolanaJSONRPCError(res.error, \"failed to get transactions\");\n            }\n            const result = res.result;\n            if (!result) return result;\n            return {\n                ...result,\n                transaction: {\n                    ...result.transaction,\n                    message: versionedMessageFromResponse(result.version, result.transaction.message)\n                }\n            };\n        });\n        return res;\n    }\n    /**\n   * Fetch a list of Transactions and transaction statuses from the cluster\n   * for a confirmed block.\n   *\n   * @deprecated Deprecated since v1.13.0. Please use {@link getBlock} instead.\n   */ async getConfirmedBlock(slot, commitment) {\n        const args = this._buildArgsAtLeastConfirmed([\n            slot\n        ], commitment);\n        const unsafeRes = await this._rpcRequest(\"getConfirmedBlock\", args);\n        const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.create)(unsafeRes, GetConfirmedBlockRpcResult);\n        if (\"error\" in res) {\n            throw new SolanaJSONRPCError(res.error, \"failed to get confirmed block\");\n        }\n        const result = res.result;\n        if (!result) {\n            throw new Error(\"Confirmed block \" + slot + \" not found\");\n        }\n        const block = {\n            ...result,\n            transactions: result.transactions.map(({ transaction, meta })=>{\n                const message = new Message(transaction.message);\n                return {\n                    meta,\n                    transaction: {\n                        ...transaction,\n                        message\n                    }\n                };\n            })\n        };\n        return {\n            ...block,\n            transactions: block.transactions.map(({ transaction, meta })=>{\n                return {\n                    meta,\n                    transaction: Transaction.populate(transaction.message, transaction.signatures)\n                };\n            })\n        };\n    }\n    /**\n   * Fetch confirmed blocks between two slots\n   */ async getBlocks(startSlot, endSlot, commitment) {\n        const args = this._buildArgsAtLeastConfirmed(endSlot !== undefined ? [\n            startSlot,\n            endSlot\n        ] : [\n            startSlot\n        ], commitment);\n        const unsafeRes = await this._rpcRequest(\"getBlocks\", args);\n        const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.create)(unsafeRes, jsonRpcResult((0,superstruct__WEBPACK_IMPORTED_MODULE_15__.array)((0,superstruct__WEBPACK_IMPORTED_MODULE_15__.number)())));\n        if (\"error\" in res) {\n            throw new SolanaJSONRPCError(res.error, \"failed to get blocks\");\n        }\n        return res.result;\n    }\n    /**\n   * Fetch a list of Signatures from the cluster for a block, excluding rewards\n   */ async getBlockSignatures(slot, commitment) {\n        const args = this._buildArgsAtLeastConfirmed([\n            slot\n        ], commitment, undefined, {\n            transactionDetails: \"signatures\",\n            rewards: false\n        });\n        const unsafeRes = await this._rpcRequest(\"getBlock\", args);\n        const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.create)(unsafeRes, GetBlockSignaturesRpcResult);\n        if (\"error\" in res) {\n            throw new SolanaJSONRPCError(res.error, \"failed to get block\");\n        }\n        const result = res.result;\n        if (!result) {\n            throw new Error(\"Block \" + slot + \" not found\");\n        }\n        return result;\n    }\n    /**\n   * Fetch a list of Signatures from the cluster for a confirmed block, excluding rewards\n   *\n   * @deprecated Deprecated since Solana v1.8.0. Please use {@link getBlockSignatures} instead.\n   */ async getConfirmedBlockSignatures(slot, commitment) {\n        const args = this._buildArgsAtLeastConfirmed([\n            slot\n        ], commitment, undefined, {\n            transactionDetails: \"signatures\",\n            rewards: false\n        });\n        const unsafeRes = await this._rpcRequest(\"getConfirmedBlock\", args);\n        const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.create)(unsafeRes, GetBlockSignaturesRpcResult);\n        if (\"error\" in res) {\n            throw new SolanaJSONRPCError(res.error, \"failed to get confirmed block\");\n        }\n        const result = res.result;\n        if (!result) {\n            throw new Error(\"Confirmed block \" + slot + \" not found\");\n        }\n        return result;\n    }\n    /**\n   * Fetch a transaction details for a confirmed transaction\n   *\n   * @deprecated Deprecated since Solana v1.8.0. Please use {@link getTransaction} instead.\n   */ async getConfirmedTransaction(signature, commitment) {\n        const args = this._buildArgsAtLeastConfirmed([\n            signature\n        ], commitment);\n        const unsafeRes = await this._rpcRequest(\"getConfirmedTransaction\", args);\n        const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.create)(unsafeRes, GetTransactionRpcResult);\n        if (\"error\" in res) {\n            throw new SolanaJSONRPCError(res.error, \"failed to get transaction\");\n        }\n        const result = res.result;\n        if (!result) return result;\n        const message = new Message(result.transaction.message);\n        const signatures = result.transaction.signatures;\n        return {\n            ...result,\n            transaction: Transaction.populate(message, signatures)\n        };\n    }\n    /**\n   * Fetch parsed transaction details for a confirmed transaction\n   *\n   * @deprecated Deprecated since Solana v1.8.0. Please use {@link getParsedTransaction} instead.\n   */ async getParsedConfirmedTransaction(signature, commitment) {\n        const args = this._buildArgsAtLeastConfirmed([\n            signature\n        ], commitment, \"jsonParsed\");\n        const unsafeRes = await this._rpcRequest(\"getConfirmedTransaction\", args);\n        const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.create)(unsafeRes, GetParsedTransactionRpcResult);\n        if (\"error\" in res) {\n            throw new SolanaJSONRPCError(res.error, \"failed to get confirmed transaction\");\n        }\n        return res.result;\n    }\n    /**\n   * Fetch parsed transaction details for a batch of confirmed transactions\n   *\n   * @deprecated Deprecated since Solana v1.8.0. Please use {@link getParsedTransactions} instead.\n   */ async getParsedConfirmedTransactions(signatures, commitment) {\n        const batch = signatures.map((signature)=>{\n            const args = this._buildArgsAtLeastConfirmed([\n                signature\n            ], commitment, \"jsonParsed\");\n            return {\n                methodName: \"getConfirmedTransaction\",\n                args\n            };\n        });\n        const unsafeRes = await this._rpcBatchRequest(batch);\n        const res = unsafeRes.map((unsafeRes)=>{\n            const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.create)(unsafeRes, GetParsedTransactionRpcResult);\n            if (\"error\" in res) {\n                throw new SolanaJSONRPCError(res.error, \"failed to get confirmed transactions\");\n            }\n            return res.result;\n        });\n        return res;\n    }\n    /**\n   * Fetch a list of all the confirmed signatures for transactions involving an address\n   * within a specified slot range. Max range allowed is 10,000 slots.\n   *\n   * @deprecated Deprecated since v1.3. Please use {@link getConfirmedSignaturesForAddress2} instead.\n   *\n   * @param address queried address\n   * @param startSlot start slot, inclusive\n   * @param endSlot end slot, inclusive\n   */ async getConfirmedSignaturesForAddress(address, startSlot, endSlot) {\n        let options = {};\n        let firstAvailableBlock = await this.getFirstAvailableBlock();\n        while(!(\"until\" in options)){\n            startSlot--;\n            if (startSlot <= 0 || startSlot < firstAvailableBlock) {\n                break;\n            }\n            try {\n                const block = await this.getConfirmedBlockSignatures(startSlot, \"finalized\");\n                if (block.signatures.length > 0) {\n                    options.until = block.signatures[block.signatures.length - 1].toString();\n                }\n            } catch (err) {\n                if (err instanceof Error && err.message.includes(\"skipped\")) {\n                    continue;\n                } else {\n                    throw err;\n                }\n            }\n        }\n        let highestConfirmedRoot = await this.getSlot(\"finalized\");\n        while(!(\"before\" in options)){\n            endSlot++;\n            if (endSlot > highestConfirmedRoot) {\n                break;\n            }\n            try {\n                const block = await this.getConfirmedBlockSignatures(endSlot);\n                if (block.signatures.length > 0) {\n                    options.before = block.signatures[block.signatures.length - 1].toString();\n                }\n            } catch (err) {\n                if (err instanceof Error && err.message.includes(\"skipped\")) {\n                    continue;\n                } else {\n                    throw err;\n                }\n            }\n        }\n        const confirmedSignatureInfo = await this.getConfirmedSignaturesForAddress2(address, options);\n        return confirmedSignatureInfo.map((info)=>info.signature);\n    }\n    /**\n   * Returns confirmed signatures for transactions involving an\n   * address backwards in time from the provided signature or most recent confirmed block\n   *\n   *\n   * @param address queried address\n   * @param options\n   */ async getConfirmedSignaturesForAddress2(address, options, commitment) {\n        const args = this._buildArgsAtLeastConfirmed([\n            address.toBase58()\n        ], commitment, undefined, options);\n        const unsafeRes = await this._rpcRequest(\"getConfirmedSignaturesForAddress2\", args);\n        const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.create)(unsafeRes, GetConfirmedSignaturesForAddress2RpcResult);\n        if (\"error\" in res) {\n            throw new SolanaJSONRPCError(res.error, \"failed to get confirmed signatures for address\");\n        }\n        return res.result;\n    }\n    /**\n   * Returns confirmed signatures for transactions involving an\n   * address backwards in time from the provided signature or most recent confirmed block\n   *\n   *\n   * @param address queried address\n   * @param options\n   */ async getSignaturesForAddress(address, options, commitment) {\n        const args = this._buildArgsAtLeastConfirmed([\n            address.toBase58()\n        ], commitment, undefined, options);\n        const unsafeRes = await this._rpcRequest(\"getSignaturesForAddress\", args);\n        const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.create)(unsafeRes, GetSignaturesForAddressRpcResult);\n        if (\"error\" in res) {\n            throw new SolanaJSONRPCError(res.error, \"failed to get signatures for address\");\n        }\n        return res.result;\n    }\n    async getAddressLookupTable(accountKey, config) {\n        const { context, value: accountInfo } = await this.getAccountInfoAndContext(accountKey, config);\n        let value = null;\n        if (accountInfo !== null) {\n            value = new AddressLookupTableAccount({\n                key: accountKey,\n                state: AddressLookupTableAccount.deserialize(accountInfo.data)\n            });\n        }\n        return {\n            context,\n            value\n        };\n    }\n    /**\n   * Fetch the contents of a Nonce account from the cluster, return with context\n   */ async getNonceAndContext(nonceAccount, commitmentOrConfig) {\n        const { context, value: accountInfo } = await this.getAccountInfoAndContext(nonceAccount, commitmentOrConfig);\n        let value = null;\n        if (accountInfo !== null) {\n            value = NonceAccount.fromAccountData(accountInfo.data);\n        }\n        return {\n            context,\n            value\n        };\n    }\n    /**\n   * Fetch the contents of a Nonce account from the cluster\n   */ async getNonce(nonceAccount, commitmentOrConfig) {\n        return await this.getNonceAndContext(nonceAccount, commitmentOrConfig).then((x)=>x.value).catch((e)=>{\n            throw new Error(\"failed to get nonce for account \" + nonceAccount.toBase58() + \": \" + e);\n        });\n    }\n    /**\n   * Request an allocation of lamports to the specified address\n   *\n   * ```typescript\n   * import { Connection, PublicKey, LAMPORTS_PER_SOL } from \"@solana/web3.js\";\n   *\n   * (async () => {\n   *   const connection = new Connection(\"https://api.testnet.solana.com\", \"confirmed\");\n   *   const myAddress = new PublicKey(\"2nr1bHFT86W9tGnyvmYW4vcHKsQB3sVQfnddasz4kExM\");\n   *   const signature = await connection.requestAirdrop(myAddress, LAMPORTS_PER_SOL);\n   *   await connection.confirmTransaction(signature);\n   * })();\n   * ```\n   */ async requestAirdrop(to, lamports) {\n        const unsafeRes = await this._rpcRequest(\"requestAirdrop\", [\n            to.toBase58(),\n            lamports\n        ]);\n        const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.create)(unsafeRes, RequestAirdropRpcResult);\n        if (\"error\" in res) {\n            throw new SolanaJSONRPCError(res.error, `airdrop to ${to.toBase58()} failed`);\n        }\n        return res.result;\n    }\n    /**\n   * @internal\n   */ async _blockhashWithExpiryBlockHeight(disableCache) {\n        if (!disableCache) {\n            // Wait for polling to finish\n            while(this._pollingBlockhash){\n                await sleep(100);\n            }\n            const timeSinceFetch = Date.now() - this._blockhashInfo.lastFetch;\n            const expired = timeSinceFetch >= BLOCKHASH_CACHE_TIMEOUT_MS;\n            if (this._blockhashInfo.latestBlockhash !== null && !expired) {\n                return this._blockhashInfo.latestBlockhash;\n            }\n        }\n        return await this._pollNewBlockhash();\n    }\n    /**\n   * @internal\n   */ async _pollNewBlockhash() {\n        this._pollingBlockhash = true;\n        try {\n            const startTime = Date.now();\n            const cachedLatestBlockhash = this._blockhashInfo.latestBlockhash;\n            const cachedBlockhash = cachedLatestBlockhash ? cachedLatestBlockhash.blockhash : null;\n            for(let i = 0; i < 50; i++){\n                const latestBlockhash = await this.getLatestBlockhash(\"finalized\");\n                if (cachedBlockhash !== latestBlockhash.blockhash) {\n                    this._blockhashInfo = {\n                        latestBlockhash,\n                        lastFetch: Date.now(),\n                        transactionSignatures: [],\n                        simulatedSignatures: []\n                    };\n                    return latestBlockhash;\n                }\n                // Sleep for approximately half a slot\n                await sleep(MS_PER_SLOT / 2);\n            }\n            throw new Error(`Unable to obtain a new blockhash after ${Date.now() - startTime}ms`);\n        } finally{\n            this._pollingBlockhash = false;\n        }\n    }\n    /**\n   * get the stake minimum delegation\n   */ async getStakeMinimumDelegation(config) {\n        const { commitment, config: configArg } = extractCommitmentFromConfig(config);\n        const args = this._buildArgs([], commitment, \"base64\", configArg);\n        const unsafeRes = await this._rpcRequest(\"getStakeMinimumDelegation\", args);\n        const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.create)(unsafeRes, jsonRpcResultAndContext((0,superstruct__WEBPACK_IMPORTED_MODULE_15__.number)()));\n        if (\"error\" in res) {\n            throw new SolanaJSONRPCError(res.error, `failed to get stake minimum delegation`);\n        }\n        return res.result;\n    }\n    /**\n   * Simulate a transaction\n   *\n   * @deprecated Instead, call {@link simulateTransaction} with {@link\n   * VersionedTransaction} and {@link SimulateTransactionConfig} parameters\n   */ /**\n   * Simulate a transaction\n   */ // eslint-disable-next-line no-dupe-class-members\n    /**\n   * Simulate a transaction\n   */ // eslint-disable-next-line no-dupe-class-members\n    async simulateTransaction(transactionOrMessage, configOrSigners, includeAccounts) {\n        if (\"message\" in transactionOrMessage) {\n            const versionedTx = transactionOrMessage;\n            const wireTransaction = versionedTx.serialize();\n            const encodedTransaction = buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.from(wireTransaction).toString(\"base64\");\n            if (Array.isArray(configOrSigners) || includeAccounts !== undefined) {\n                throw new Error(\"Invalid arguments\");\n            }\n            const config = configOrSigners || {};\n            config.encoding = \"base64\";\n            if (!(\"commitment\" in config)) {\n                config.commitment = this.commitment;\n            }\n            const args = [\n                encodedTransaction,\n                config\n            ];\n            const unsafeRes = await this._rpcRequest(\"simulateTransaction\", args);\n            const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.create)(unsafeRes, SimulatedTransactionResponseStruct);\n            if (\"error\" in res) {\n                throw new Error(\"failed to simulate transaction: \" + res.error.message);\n            }\n            return res.result;\n        }\n        let transaction;\n        if (transactionOrMessage instanceof Transaction) {\n            let originalTx = transactionOrMessage;\n            transaction = new Transaction();\n            transaction.feePayer = originalTx.feePayer;\n            transaction.instructions = transactionOrMessage.instructions;\n            transaction.nonceInfo = originalTx.nonceInfo;\n            transaction.signatures = originalTx.signatures;\n        } else {\n            transaction = Transaction.populate(transactionOrMessage);\n            // HACK: this function relies on mutating the populated transaction\n            transaction._message = transaction._json = undefined;\n        }\n        if (configOrSigners !== undefined && !Array.isArray(configOrSigners)) {\n            throw new Error(\"Invalid arguments\");\n        }\n        const signers = configOrSigners;\n        if (transaction.nonceInfo && signers) {\n            transaction.sign(...signers);\n        } else {\n            let disableCache = this._disableBlockhashCaching;\n            for(;;){\n                const latestBlockhash = await this._blockhashWithExpiryBlockHeight(disableCache);\n                transaction.lastValidBlockHeight = latestBlockhash.lastValidBlockHeight;\n                transaction.recentBlockhash = latestBlockhash.blockhash;\n                if (!signers) break;\n                transaction.sign(...signers);\n                if (!transaction.signature) {\n                    throw new Error(\"!signature\"); // should never happen\n                }\n                const signature = transaction.signature.toString(\"base64\");\n                if (!this._blockhashInfo.simulatedSignatures.includes(signature) && !this._blockhashInfo.transactionSignatures.includes(signature)) {\n                    // The signature of this transaction has not been seen before with the\n                    // current recentBlockhash, all done. Let's break\n                    this._blockhashInfo.simulatedSignatures.push(signature);\n                    break;\n                } else {\n                    // This transaction would be treated as duplicate (its derived signature\n                    // matched to one of already recorded signatures).\n                    // So, we must fetch a new blockhash for a different signature by disabling\n                    // our cache not to wait for the cache expiration (BLOCKHASH_CACHE_TIMEOUT_MS).\n                    disableCache = true;\n                }\n            }\n        }\n        const message = transaction._compile();\n        const signData = message.serialize();\n        const wireTransaction = transaction._serialize(signData);\n        const encodedTransaction = wireTransaction.toString(\"base64\");\n        const config = {\n            encoding: \"base64\",\n            commitment: this.commitment\n        };\n        if (includeAccounts) {\n            const addresses = (Array.isArray(includeAccounts) ? includeAccounts : message.nonProgramIds()).map((key)=>key.toBase58());\n            config[\"accounts\"] = {\n                encoding: \"base64\",\n                addresses\n            };\n        }\n        if (signers) {\n            config.sigVerify = true;\n        }\n        const args = [\n            encodedTransaction,\n            config\n        ];\n        const unsafeRes = await this._rpcRequest(\"simulateTransaction\", args);\n        const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.create)(unsafeRes, SimulatedTransactionResponseStruct);\n        if (\"error\" in res) {\n            let logs;\n            if (\"data\" in res.error) {\n                logs = res.error.data.logs;\n                if (logs && Array.isArray(logs)) {\n                    const traceIndent = \"\\n    \";\n                    const logTrace = traceIndent + logs.join(traceIndent);\n                    console.error(res.error.message, logTrace);\n                }\n            }\n            throw new SendTransactionError(\"failed to simulate transaction: \" + res.error.message, logs);\n        }\n        return res.result;\n    }\n    /**\n   * Sign and send a transaction\n   *\n   * @deprecated Instead, call {@link sendTransaction} with a {@link\n   * VersionedTransaction}\n   */ /**\n   * Send a signed transaction\n   */ // eslint-disable-next-line no-dupe-class-members\n    /**\n   * Sign and send a transaction\n   */ // eslint-disable-next-line no-dupe-class-members\n    async sendTransaction(transaction, signersOrOptions, options) {\n        if (\"version\" in transaction) {\n            if (signersOrOptions && Array.isArray(signersOrOptions)) {\n                throw new Error(\"Invalid arguments\");\n            }\n            const wireTransaction = transaction.serialize();\n            return await this.sendRawTransaction(wireTransaction, signersOrOptions);\n        }\n        if (signersOrOptions === undefined || !Array.isArray(signersOrOptions)) {\n            throw new Error(\"Invalid arguments\");\n        }\n        const signers = signersOrOptions;\n        if (transaction.nonceInfo) {\n            transaction.sign(...signers);\n        } else {\n            let disableCache = this._disableBlockhashCaching;\n            for(;;){\n                const latestBlockhash = await this._blockhashWithExpiryBlockHeight(disableCache);\n                transaction.lastValidBlockHeight = latestBlockhash.lastValidBlockHeight;\n                transaction.recentBlockhash = latestBlockhash.blockhash;\n                transaction.sign(...signers);\n                if (!transaction.signature) {\n                    throw new Error(\"!signature\"); // should never happen\n                }\n                const signature = transaction.signature.toString(\"base64\");\n                if (!this._blockhashInfo.transactionSignatures.includes(signature)) {\n                    // The signature of this transaction has not been seen before with the\n                    // current recentBlockhash, all done. Let's break\n                    this._blockhashInfo.transactionSignatures.push(signature);\n                    break;\n                } else {\n                    // This transaction would be treated as duplicate (its derived signature\n                    // matched to one of already recorded signatures).\n                    // So, we must fetch a new blockhash for a different signature by disabling\n                    // our cache not to wait for the cache expiration (BLOCKHASH_CACHE_TIMEOUT_MS).\n                    disableCache = true;\n                }\n            }\n        }\n        const wireTransaction = transaction.serialize();\n        return await this.sendRawTransaction(wireTransaction, options);\n    }\n    /**\n   * Send a transaction that has already been signed and serialized into the\n   * wire format\n   */ async sendRawTransaction(rawTransaction, options) {\n        const encodedTransaction = toBuffer(rawTransaction).toString(\"base64\");\n        const result = await this.sendEncodedTransaction(encodedTransaction, options);\n        return result;\n    }\n    /**\n   * Send a transaction that has already been signed, serialized into the\n   * wire format, and encoded as a base64 string\n   */ async sendEncodedTransaction(encodedTransaction, options) {\n        const config = {\n            encoding: \"base64\"\n        };\n        const skipPreflight = options && options.skipPreflight;\n        const preflightCommitment = skipPreflight === true ? \"processed\" // FIXME Remove when https://github.com/anza-xyz/agave/pull/483 is deployed.\n         : options && options.preflightCommitment || this.commitment;\n        if (options && options.maxRetries != null) {\n            config.maxRetries = options.maxRetries;\n        }\n        if (options && options.minContextSlot != null) {\n            config.minContextSlot = options.minContextSlot;\n        }\n        if (skipPreflight) {\n            config.skipPreflight = skipPreflight;\n        }\n        if (preflightCommitment) {\n            config.preflightCommitment = preflightCommitment;\n        }\n        const args = [\n            encodedTransaction,\n            config\n        ];\n        const unsafeRes = await this._rpcRequest(\"sendTransaction\", args);\n        const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.create)(unsafeRes, SendTransactionRpcResult);\n        if (\"error\" in res) {\n            let logs;\n            if (\"data\" in res.error) {\n                logs = res.error.data.logs;\n            }\n            throw new SendTransactionError(\"failed to send transaction: \" + res.error.message, logs);\n        }\n        return res.result;\n    }\n    /**\n   * @internal\n   */ _wsOnOpen() {\n        this._rpcWebSocketConnected = true;\n        this._rpcWebSocketHeartbeat = setInterval(()=>{\n            // Ping server every 5s to prevent idle timeouts\n            (async ()=>{\n                try {\n                    await this._rpcWebSocket.notify(\"ping\");\n                // eslint-disable-next-line no-empty\n                } catch  {}\n            })();\n        }, 5000);\n        this._updateSubscriptions();\n    }\n    /**\n   * @internal\n   */ _wsOnError(err) {\n        this._rpcWebSocketConnected = false;\n        console.error(\"ws error:\", err.message);\n    }\n    /**\n   * @internal\n   */ _wsOnClose(code) {\n        this._rpcWebSocketConnected = false;\n        this._rpcWebSocketGeneration = (this._rpcWebSocketGeneration + 1) % Number.MAX_SAFE_INTEGER;\n        if (this._rpcWebSocketIdleTimeout) {\n            clearTimeout(this._rpcWebSocketIdleTimeout);\n            this._rpcWebSocketIdleTimeout = null;\n        }\n        if (this._rpcWebSocketHeartbeat) {\n            clearInterval(this._rpcWebSocketHeartbeat);\n            this._rpcWebSocketHeartbeat = null;\n        }\n        if (code === 1000) {\n            // explicit close, check if any subscriptions have been made since close\n            this._updateSubscriptions();\n            return;\n        }\n        // implicit close, prepare subscriptions for auto-reconnect\n        this._subscriptionCallbacksByServerSubscriptionId = {};\n        Object.entries(this._subscriptionsByHash).forEach(([hash, subscription])=>{\n            this._setSubscription(hash, {\n                ...subscription,\n                state: \"pending\"\n            });\n        });\n    }\n    /**\n   * @internal\n   */ _setSubscription(hash, nextSubscription) {\n        const prevState = this._subscriptionsByHash[hash]?.state;\n        this._subscriptionsByHash[hash] = nextSubscription;\n        if (prevState !== nextSubscription.state) {\n            const stateChangeCallbacks = this._subscriptionStateChangeCallbacksByHash[hash];\n            if (stateChangeCallbacks) {\n                stateChangeCallbacks.forEach((cb)=>{\n                    try {\n                        cb(nextSubscription.state);\n                    // eslint-disable-next-line no-empty\n                    } catch  {}\n                });\n            }\n        }\n    }\n    /**\n   * @internal\n   */ _onSubscriptionStateChange(clientSubscriptionId, callback) {\n        const hash = this._subscriptionHashByClientSubscriptionId[clientSubscriptionId];\n        if (hash == null) {\n            return ()=>{};\n        }\n        const stateChangeCallbacks = this._subscriptionStateChangeCallbacksByHash[hash] ||= new Set();\n        stateChangeCallbacks.add(callback);\n        return ()=>{\n            stateChangeCallbacks.delete(callback);\n            if (stateChangeCallbacks.size === 0) {\n                delete this._subscriptionStateChangeCallbacksByHash[hash];\n            }\n        };\n    }\n    /**\n   * @internal\n   */ async _updateSubscriptions() {\n        if (Object.keys(this._subscriptionsByHash).length === 0) {\n            if (this._rpcWebSocketConnected) {\n                this._rpcWebSocketConnected = false;\n                this._rpcWebSocketIdleTimeout = setTimeout(()=>{\n                    this._rpcWebSocketIdleTimeout = null;\n                    try {\n                        this._rpcWebSocket.close();\n                    } catch (err) {\n                        // swallow error if socket has already been closed.\n                        if (err instanceof Error) {\n                            console.log(`Error when closing socket connection: ${err.message}`);\n                        }\n                    }\n                }, 500);\n            }\n            return;\n        }\n        if (this._rpcWebSocketIdleTimeout !== null) {\n            clearTimeout(this._rpcWebSocketIdleTimeout);\n            this._rpcWebSocketIdleTimeout = null;\n            this._rpcWebSocketConnected = true;\n        }\n        if (!this._rpcWebSocketConnected) {\n            this._rpcWebSocket.connect();\n            return;\n        }\n        const activeWebSocketGeneration = this._rpcWebSocketGeneration;\n        const isCurrentConnectionStillActive = ()=>{\n            return activeWebSocketGeneration === this._rpcWebSocketGeneration;\n        };\n        await Promise.all(// Don't be tempted to change this to `Object.entries`. We call\n        // `_updateSubscriptions` recursively when processing the state,\n        // so it's important that we look up the *current* version of\n        // each subscription, every time we process a hash.\n        Object.keys(this._subscriptionsByHash).map(async (hash)=>{\n            const subscription = this._subscriptionsByHash[hash];\n            if (subscription === undefined) {\n                // This entry has since been deleted. Skip.\n                return;\n            }\n            switch(subscription.state){\n                case \"pending\":\n                case \"unsubscribed\":\n                    if (subscription.callbacks.size === 0) {\n                        /**\n             * You can end up here when:\n             *\n             * - a subscription has recently unsubscribed\n             *   without having new callbacks added to it\n             *   while the unsubscribe was in flight, or\n             * - when a pending subscription has its\n             *   listeners removed before a request was\n             *   sent to the server.\n             *\n             * Being that nobody is interested in this\n             * subscription any longer, delete it.\n             */ delete this._subscriptionsByHash[hash];\n                        if (subscription.state === \"unsubscribed\") {\n                            delete this._subscriptionCallbacksByServerSubscriptionId[subscription.serverSubscriptionId];\n                        }\n                        await this._updateSubscriptions();\n                        return;\n                    }\n                    await (async ()=>{\n                        const { args, method } = subscription;\n                        try {\n                            this._setSubscription(hash, {\n                                ...subscription,\n                                state: \"subscribing\"\n                            });\n                            const serverSubscriptionId = await this._rpcWebSocket.call(method, args);\n                            this._setSubscription(hash, {\n                                ...subscription,\n                                serverSubscriptionId,\n                                state: \"subscribed\"\n                            });\n                            this._subscriptionCallbacksByServerSubscriptionId[serverSubscriptionId] = subscription.callbacks;\n                            await this._updateSubscriptions();\n                        } catch (e) {\n                            if (e instanceof Error) {\n                                console.error(`${method} error for argument`, args, e.message);\n                            }\n                            if (!isCurrentConnectionStillActive()) {\n                                return;\n                            }\n                            // TODO: Maybe add an 'errored' state or a retry limit?\n                            this._setSubscription(hash, {\n                                ...subscription,\n                                state: \"pending\"\n                            });\n                            await this._updateSubscriptions();\n                        }\n                    })();\n                    break;\n                case \"subscribed\":\n                    if (subscription.callbacks.size === 0) {\n                        // By the time we successfully set up a subscription\n                        // with the server, the client stopped caring about it.\n                        // Tear it down now.\n                        await (async ()=>{\n                            const { serverSubscriptionId, unsubscribeMethod } = subscription;\n                            if (this._subscriptionsAutoDisposedByRpc.has(serverSubscriptionId)) {\n                                /**\n                 * Special case.\n                 * If we're dealing with a subscription that has been auto-\n                 * disposed by the RPC, then we can skip the RPC call to\n                 * tear down the subscription here.\n                 *\n                 * NOTE: There is a proposal to eliminate this special case, here:\n                 * https://github.com/solana-labs/solana/issues/18892\n                 */ this._subscriptionsAutoDisposedByRpc.delete(serverSubscriptionId);\n                            } else {\n                                this._setSubscription(hash, {\n                                    ...subscription,\n                                    state: \"unsubscribing\"\n                                });\n                                this._setSubscription(hash, {\n                                    ...subscription,\n                                    state: \"unsubscribing\"\n                                });\n                                try {\n                                    await this._rpcWebSocket.call(unsubscribeMethod, [\n                                        serverSubscriptionId\n                                    ]);\n                                } catch (e) {\n                                    if (e instanceof Error) {\n                                        console.error(`${unsubscribeMethod} error:`, e.message);\n                                    }\n                                    if (!isCurrentConnectionStillActive()) {\n                                        return;\n                                    }\n                                    // TODO: Maybe add an 'errored' state or a retry limit?\n                                    this._setSubscription(hash, {\n                                        ...subscription,\n                                        state: \"subscribed\"\n                                    });\n                                    await this._updateSubscriptions();\n                                    return;\n                                }\n                            }\n                            this._setSubscription(hash, {\n                                ...subscription,\n                                state: \"unsubscribed\"\n                            });\n                            await this._updateSubscriptions();\n                        })();\n                    }\n                    break;\n            }\n        }));\n    }\n    /**\n   * @internal\n   */ _handleServerNotification(serverSubscriptionId, callbackArgs) {\n        const callbacks = this._subscriptionCallbacksByServerSubscriptionId[serverSubscriptionId];\n        if (callbacks === undefined) {\n            return;\n        }\n        callbacks.forEach((cb)=>{\n            try {\n                cb(// I failed to find a way to convince TypeScript that `cb` is of type\n                // `TCallback` which is certainly compatible with `Parameters<TCallback>`.\n                // See https://github.com/microsoft/TypeScript/issues/47615\n                // @ts-ignore\n                ...callbackArgs);\n            } catch (e) {\n                console.error(e);\n            }\n        });\n    }\n    /**\n   * @internal\n   */ _wsOnAccountNotification(notification) {\n        const { result, subscription } = (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.create)(notification, AccountNotificationResult);\n        this._handleServerNotification(subscription, [\n            result.value,\n            result.context\n        ]);\n    }\n    /**\n   * @internal\n   */ _makeSubscription(subscriptionConfig, /**\n   * When preparing `args` for a call to `_makeSubscription`, be sure\n   * to carefully apply a default `commitment` property, if necessary.\n   *\n   * - If the user supplied a `commitment` use that.\n   * - Otherwise, if the `Connection::commitment` is set, use that.\n   * - Otherwise, set it to the RPC server default: `finalized`.\n   *\n   * This is extremely important to ensure that these two fundamentally\n   * identical subscriptions produce the same identifying hash:\n   *\n   * - A subscription made without specifying a commitment.\n   * - A subscription made where the commitment specified is the same\n   *   as the default applied to the subscription above.\n   *\n   * Example; these two subscriptions must produce the same hash:\n   *\n   * - An `accountSubscribe` subscription for `'PUBKEY'`\n   * - An `accountSubscribe` subscription for `'PUBKEY'` with commitment\n   *   `'finalized'`.\n   *\n   * See the 'making a subscription with defaulted params omitted' test\n   * in `connection-subscriptions.ts` for more.\n   */ args) {\n        const clientSubscriptionId = this._nextClientSubscriptionId++;\n        const hash = fastStableStringify$1([\n            subscriptionConfig.method,\n            args\n        ]);\n        const existingSubscription = this._subscriptionsByHash[hash];\n        if (existingSubscription === undefined) {\n            this._subscriptionsByHash[hash] = {\n                ...subscriptionConfig,\n                args,\n                callbacks: new Set([\n                    subscriptionConfig.callback\n                ]),\n                state: \"pending\"\n            };\n        } else {\n            existingSubscription.callbacks.add(subscriptionConfig.callback);\n        }\n        this._subscriptionHashByClientSubscriptionId[clientSubscriptionId] = hash;\n        this._subscriptionDisposeFunctionsByClientSubscriptionId[clientSubscriptionId] = async ()=>{\n            delete this._subscriptionDisposeFunctionsByClientSubscriptionId[clientSubscriptionId];\n            delete this._subscriptionHashByClientSubscriptionId[clientSubscriptionId];\n            const subscription = this._subscriptionsByHash[hash];\n            assert(subscription !== undefined, `Could not find a \\`Subscription\\` when tearing down client subscription #${clientSubscriptionId}`);\n            subscription.callbacks.delete(subscriptionConfig.callback);\n            await this._updateSubscriptions();\n        };\n        this._updateSubscriptions();\n        return clientSubscriptionId;\n    }\n    /**\n   * Register a callback to be invoked whenever the specified account changes\n   *\n   * @param publicKey Public key of the account to monitor\n   * @param callback Function to invoke whenever the account is changed\n   * @param commitment Specify the commitment level account changes must reach before notification\n   * @return subscription id\n   */ onAccountChange(publicKey, callback, commitment) {\n        const args = this._buildArgs([\n            publicKey.toBase58()\n        ], commitment || this._commitment || \"finalized\", // Apply connection/server default.\n        \"base64\");\n        return this._makeSubscription({\n            callback,\n            method: \"accountSubscribe\",\n            unsubscribeMethod: \"accountUnsubscribe\"\n        }, args);\n    }\n    /**\n   * Deregister an account notification callback\n   *\n   * @param clientSubscriptionId client subscription id to deregister\n   */ async removeAccountChangeListener(clientSubscriptionId) {\n        await this._unsubscribeClientSubscription(clientSubscriptionId, \"account change\");\n    }\n    /**\n   * @internal\n   */ _wsOnProgramAccountNotification(notification) {\n        const { result, subscription } = (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.create)(notification, ProgramAccountNotificationResult);\n        this._handleServerNotification(subscription, [\n            {\n                accountId: result.value.pubkey,\n                accountInfo: result.value.account\n            },\n            result.context\n        ]);\n    }\n    /**\n   * Register a callback to be invoked whenever accounts owned by the\n   * specified program change\n   *\n   * @param programId Public key of the program to monitor\n   * @param callback Function to invoke whenever the account is changed\n   * @param commitment Specify the commitment level account changes must reach before notification\n   * @param filters The program account filters to pass into the RPC method\n   * @return subscription id\n   */ onProgramAccountChange(programId, callback, commitment, filters) {\n        const args = this._buildArgs([\n            programId.toBase58()\n        ], commitment || this._commitment || \"finalized\", // Apply connection/server default.\n        \"base64\" /* encoding */ , filters ? {\n            filters: filters\n        } : undefined /* extra */ );\n        return this._makeSubscription({\n            callback,\n            method: \"programSubscribe\",\n            unsubscribeMethod: \"programUnsubscribe\"\n        }, args);\n    }\n    /**\n   * Deregister an account notification callback\n   *\n   * @param clientSubscriptionId client subscription id to deregister\n   */ async removeProgramAccountChangeListener(clientSubscriptionId) {\n        await this._unsubscribeClientSubscription(clientSubscriptionId, \"program account change\");\n    }\n    /**\n   * Registers a callback to be invoked whenever logs are emitted.\n   */ onLogs(filter, callback, commitment) {\n        const args = this._buildArgs([\n            typeof filter === \"object\" ? {\n                mentions: [\n                    filter.toString()\n                ]\n            } : filter\n        ], commitment || this._commitment || \"finalized\" // Apply connection/server default.\n        );\n        return this._makeSubscription({\n            callback,\n            method: \"logsSubscribe\",\n            unsubscribeMethod: \"logsUnsubscribe\"\n        }, args);\n    }\n    /**\n   * Deregister a logs callback.\n   *\n   * @param clientSubscriptionId client subscription id to deregister.\n   */ async removeOnLogsListener(clientSubscriptionId) {\n        await this._unsubscribeClientSubscription(clientSubscriptionId, \"logs\");\n    }\n    /**\n   * @internal\n   */ _wsOnLogsNotification(notification) {\n        const { result, subscription } = (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.create)(notification, LogsNotificationResult);\n        this._handleServerNotification(subscription, [\n            result.value,\n            result.context\n        ]);\n    }\n    /**\n   * @internal\n   */ _wsOnSlotNotification(notification) {\n        const { result, subscription } = (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.create)(notification, SlotNotificationResult);\n        this._handleServerNotification(subscription, [\n            result\n        ]);\n    }\n    /**\n   * Register a callback to be invoked upon slot changes\n   *\n   * @param callback Function to invoke whenever the slot changes\n   * @return subscription id\n   */ onSlotChange(callback) {\n        return this._makeSubscription({\n            callback,\n            method: \"slotSubscribe\",\n            unsubscribeMethod: \"slotUnsubscribe\"\n        }, []);\n    }\n    /**\n   * Deregister a slot notification callback\n   *\n   * @param clientSubscriptionId client subscription id to deregister\n   */ async removeSlotChangeListener(clientSubscriptionId) {\n        await this._unsubscribeClientSubscription(clientSubscriptionId, \"slot change\");\n    }\n    /**\n   * @internal\n   */ _wsOnSlotUpdatesNotification(notification) {\n        const { result, subscription } = (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.create)(notification, SlotUpdateNotificationResult);\n        this._handleServerNotification(subscription, [\n            result\n        ]);\n    }\n    /**\n   * Register a callback to be invoked upon slot updates. {@link SlotUpdate}'s\n   * may be useful to track live progress of a cluster.\n   *\n   * @param callback Function to invoke whenever the slot updates\n   * @return subscription id\n   */ onSlotUpdate(callback) {\n        return this._makeSubscription({\n            callback,\n            method: \"slotsUpdatesSubscribe\",\n            unsubscribeMethod: \"slotsUpdatesUnsubscribe\"\n        }, []);\n    }\n    /**\n   * Deregister a slot update notification callback\n   *\n   * @param clientSubscriptionId client subscription id to deregister\n   */ async removeSlotUpdateListener(clientSubscriptionId) {\n        await this._unsubscribeClientSubscription(clientSubscriptionId, \"slot update\");\n    }\n    /**\n   * @internal\n   */ async _unsubscribeClientSubscription(clientSubscriptionId, subscriptionName) {\n        const dispose = this._subscriptionDisposeFunctionsByClientSubscriptionId[clientSubscriptionId];\n        if (dispose) {\n            await dispose();\n        } else {\n            console.warn(\"Ignored unsubscribe request because an active subscription with id \" + `\\`${clientSubscriptionId}\\` for '${subscriptionName}' events ` + \"could not be found.\");\n        }\n    }\n    _buildArgs(args, override, encoding, extra) {\n        const commitment = override || this._commitment;\n        if (commitment || encoding || extra) {\n            let options = {};\n            if (encoding) {\n                options.encoding = encoding;\n            }\n            if (commitment) {\n                options.commitment = commitment;\n            }\n            if (extra) {\n                options = Object.assign(options, extra);\n            }\n            args.push(options);\n        }\n        return args;\n    }\n    /**\n   * @internal\n   */ _buildArgsAtLeastConfirmed(args, override, encoding, extra) {\n        const commitment = override || this._commitment;\n        if (commitment && ![\n            \"confirmed\",\n            \"finalized\"\n        ].includes(commitment)) {\n            throw new Error(\"Using Connection with default commitment: `\" + this._commitment + \"`, but method requires at least `confirmed`\");\n        }\n        return this._buildArgs(args, override, encoding, extra);\n    }\n    /**\n   * @internal\n   */ _wsOnSignatureNotification(notification) {\n        const { result, subscription } = (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.create)(notification, SignatureNotificationResult);\n        if (result.value !== \"receivedSignature\") {\n            /**\n       * Special case.\n       * After a signature is processed, RPCs automatically dispose of the\n       * subscription on the server side. We need to track which of these\n       * subscriptions have been disposed in such a way, so that we know\n       * whether the client is dealing with a not-yet-processed signature\n       * (in which case we must tear down the server subscription) or an\n       * already-processed signature (in which case the client can simply\n       * clear out the subscription locally without telling the server).\n       *\n       * NOTE: There is a proposal to eliminate this special case, here:\n       * https://github.com/solana-labs/solana/issues/18892\n       */ this._subscriptionsAutoDisposedByRpc.add(subscription);\n        }\n        this._handleServerNotification(subscription, result.value === \"receivedSignature\" ? [\n            {\n                type: \"received\"\n            },\n            result.context\n        ] : [\n            {\n                type: \"status\",\n                result: result.value\n            },\n            result.context\n        ]);\n    }\n    /**\n   * Register a callback to be invoked upon signature updates\n   *\n   * @param signature Transaction signature string in base 58\n   * @param callback Function to invoke on signature notifications\n   * @param commitment Specify the commitment level signature must reach before notification\n   * @return subscription id\n   */ onSignature(signature, callback, commitment) {\n        const args = this._buildArgs([\n            signature\n        ], commitment || this._commitment || \"finalized\" // Apply connection/server default.\n        );\n        const clientSubscriptionId = this._makeSubscription({\n            callback: (notification, context)=>{\n                if (notification.type === \"status\") {\n                    callback(notification.result, context);\n                    // Signatures subscriptions are auto-removed by the RPC service\n                    // so no need to explicitly send an unsubscribe message.\n                    try {\n                        this.removeSignatureListener(clientSubscriptionId);\n                    // eslint-disable-next-line no-empty\n                    } catch (_err) {\n                    // Already removed.\n                    }\n                }\n            },\n            method: \"signatureSubscribe\",\n            unsubscribeMethod: \"signatureUnsubscribe\"\n        }, args);\n        return clientSubscriptionId;\n    }\n    /**\n   * Register a callback to be invoked when a transaction is\n   * received and/or processed.\n   *\n   * @param signature Transaction signature string in base 58\n   * @param callback Function to invoke on signature notifications\n   * @param options Enable received notifications and set the commitment\n   *   level that signature must reach before notification\n   * @return subscription id\n   */ onSignatureWithOptions(signature, callback, options) {\n        const { commitment, ...extra } = {\n            ...options,\n            commitment: options && options.commitment || this._commitment || \"finalized\" // Apply connection/server default.\n        };\n        const args = this._buildArgs([\n            signature\n        ], commitment, undefined /* encoding */ , extra);\n        const clientSubscriptionId = this._makeSubscription({\n            callback: (notification, context)=>{\n                callback(notification, context);\n                // Signatures subscriptions are auto-removed by the RPC service\n                // so no need to explicitly send an unsubscribe message.\n                try {\n                    this.removeSignatureListener(clientSubscriptionId);\n                // eslint-disable-next-line no-empty\n                } catch (_err) {\n                // Already removed.\n                }\n            },\n            method: \"signatureSubscribe\",\n            unsubscribeMethod: \"signatureUnsubscribe\"\n        }, args);\n        return clientSubscriptionId;\n    }\n    /**\n   * Deregister a signature notification callback\n   *\n   * @param clientSubscriptionId client subscription id to deregister\n   */ async removeSignatureListener(clientSubscriptionId) {\n        await this._unsubscribeClientSubscription(clientSubscriptionId, \"signature result\");\n    }\n    /**\n   * @internal\n   */ _wsOnRootNotification(notification) {\n        const { result, subscription } = (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.create)(notification, RootNotificationResult);\n        this._handleServerNotification(subscription, [\n            result\n        ]);\n    }\n    /**\n   * Register a callback to be invoked upon root changes\n   *\n   * @param callback Function to invoke whenever the root changes\n   * @return subscription id\n   */ onRootChange(callback) {\n        return this._makeSubscription({\n            callback,\n            method: \"rootSubscribe\",\n            unsubscribeMethod: \"rootUnsubscribe\"\n        }, []);\n    }\n    /**\n   * Deregister a root notification callback\n   *\n   * @param clientSubscriptionId client subscription id to deregister\n   */ async removeRootChangeListener(clientSubscriptionId) {\n        await this._unsubscribeClientSubscription(clientSubscriptionId, \"root change\");\n    }\n}\n/**\n * Keypair signer interface\n */ /**\n * An account keypair used for signing transactions.\n */ class Keypair {\n    /**\n   * Create a new keypair instance.\n   * Generate random keypair if no {@link Ed25519Keypair} is provided.\n   *\n   * @param {Ed25519Keypair} keypair ed25519 keypair\n   */ constructor(keypair){\n        this._keypair = void 0;\n        this._keypair = keypair ?? generateKeypair();\n    }\n    /**\n   * Generate a new random keypair\n   *\n   * @returns {Keypair} Keypair\n   */ static generate() {\n        return new Keypair(generateKeypair());\n    }\n    /**\n   * Create a keypair from a raw secret key byte array.\n   *\n   * This method should only be used to recreate a keypair from a previously\n   * generated secret key. Generating keypairs from a random seed should be done\n   * with the {@link Keypair.fromSeed} method.\n   *\n   * @throws error if the provided secret key is invalid and validation is not skipped.\n   *\n   * @param secretKey secret key byte array\n   * @param options skip secret key validation\n   *\n   * @returns {Keypair} Keypair\n   */ static fromSecretKey(secretKey, options) {\n        if (secretKey.byteLength !== 64) {\n            throw new Error(\"bad secret key size\");\n        }\n        const publicKey = secretKey.slice(32, 64);\n        if (!options || !options.skipValidation) {\n            const privateScalar = secretKey.slice(0, 32);\n            const computedPublicKey = getPublicKey(privateScalar);\n            for(let ii = 0; ii < 32; ii++){\n                if (publicKey[ii] !== computedPublicKey[ii]) {\n                    throw new Error(\"provided secretKey is invalid\");\n                }\n            }\n        }\n        return new Keypair({\n            publicKey,\n            secretKey\n        });\n    }\n    /**\n   * Generate a keypair from a 32 byte seed.\n   *\n   * @param seed seed byte array\n   *\n   * @returns {Keypair} Keypair\n   */ static fromSeed(seed) {\n        const publicKey = getPublicKey(seed);\n        const secretKey = new Uint8Array(64);\n        secretKey.set(seed);\n        secretKey.set(publicKey, 32);\n        return new Keypair({\n            publicKey,\n            secretKey\n        });\n    }\n    /**\n   * The public key for this keypair\n   *\n   * @returns {PublicKey} PublicKey\n   */ get publicKey() {\n        return new PublicKey(this._keypair.publicKey);\n    }\n    /**\n   * The raw secret key for this keypair\n   * @returns {Uint8Array} Secret key in an array of Uint8 bytes\n   */ get secretKey() {\n        return new Uint8Array(this._keypair.secretKey);\n    }\n}\n/**\n * An enumeration of valid LookupTableInstructionType's\n */ /**\n * An enumeration of valid address lookup table InstructionType's\n * @internal\n */ const LOOKUP_TABLE_INSTRUCTION_LAYOUTS = Object.freeze({\n    CreateLookupTable: {\n        index: 0,\n        layout: _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.struct([\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u32(\"instruction\"),\n            u64(\"recentSlot\"),\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u8(\"bumpSeed\")\n        ])\n    },\n    FreezeLookupTable: {\n        index: 1,\n        layout: _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.struct([\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u32(\"instruction\")\n        ])\n    },\n    ExtendLookupTable: {\n        index: 2,\n        layout: _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.struct([\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u32(\"instruction\"),\n            u64(),\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.seq(publicKey(), _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.offset(_solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u32(), -8), \"addresses\")\n        ])\n    },\n    DeactivateLookupTable: {\n        index: 3,\n        layout: _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.struct([\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u32(\"instruction\")\n        ])\n    },\n    CloseLookupTable: {\n        index: 4,\n        layout: _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.struct([\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u32(\"instruction\")\n        ])\n    }\n});\nclass AddressLookupTableInstruction {\n    /**\n   * @internal\n   */ constructor(){}\n    static decodeInstructionType(instruction) {\n        this.checkProgramId(instruction.programId);\n        const instructionTypeLayout = _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u32(\"instruction\");\n        const index = instructionTypeLayout.decode(instruction.data);\n        let type;\n        for (const [layoutType, layout] of Object.entries(LOOKUP_TABLE_INSTRUCTION_LAYOUTS)){\n            if (layout.index == index) {\n                type = layoutType;\n                break;\n            }\n        }\n        if (!type) {\n            throw new Error(\"Invalid Instruction. Should be a LookupTable Instruction\");\n        }\n        return type;\n    }\n    static decodeCreateLookupTable(instruction) {\n        this.checkProgramId(instruction.programId);\n        this.checkKeysLength(instruction.keys, 4);\n        const { recentSlot } = decodeData$1(LOOKUP_TABLE_INSTRUCTION_LAYOUTS.CreateLookupTable, instruction.data);\n        return {\n            authority: instruction.keys[1].pubkey,\n            payer: instruction.keys[2].pubkey,\n            recentSlot: Number(recentSlot)\n        };\n    }\n    static decodeExtendLookupTable(instruction) {\n        this.checkProgramId(instruction.programId);\n        if (instruction.keys.length < 2) {\n            throw new Error(`invalid instruction; found ${instruction.keys.length} keys, expected at least 2`);\n        }\n        const { addresses } = decodeData$1(LOOKUP_TABLE_INSTRUCTION_LAYOUTS.ExtendLookupTable, instruction.data);\n        return {\n            lookupTable: instruction.keys[0].pubkey,\n            authority: instruction.keys[1].pubkey,\n            payer: instruction.keys.length > 2 ? instruction.keys[2].pubkey : undefined,\n            addresses: addresses.map((buffer)=>new PublicKey(buffer))\n        };\n    }\n    static decodeCloseLookupTable(instruction) {\n        this.checkProgramId(instruction.programId);\n        this.checkKeysLength(instruction.keys, 3);\n        return {\n            lookupTable: instruction.keys[0].pubkey,\n            authority: instruction.keys[1].pubkey,\n            recipient: instruction.keys[2].pubkey\n        };\n    }\n    static decodeFreezeLookupTable(instruction) {\n        this.checkProgramId(instruction.programId);\n        this.checkKeysLength(instruction.keys, 2);\n        return {\n            lookupTable: instruction.keys[0].pubkey,\n            authority: instruction.keys[1].pubkey\n        };\n    }\n    static decodeDeactivateLookupTable(instruction) {\n        this.checkProgramId(instruction.programId);\n        this.checkKeysLength(instruction.keys, 2);\n        return {\n            lookupTable: instruction.keys[0].pubkey,\n            authority: instruction.keys[1].pubkey\n        };\n    }\n    /**\n   * @internal\n   */ static checkProgramId(programId) {\n        if (!programId.equals(AddressLookupTableProgram.programId)) {\n            throw new Error(\"invalid instruction; programId is not AddressLookupTable Program\");\n        }\n    }\n    /**\n   * @internal\n   */ static checkKeysLength(keys, expectedLength) {\n        if (keys.length < expectedLength) {\n            throw new Error(`invalid instruction; found ${keys.length} keys, expected at least ${expectedLength}`);\n        }\n    }\n}\nclass AddressLookupTableProgram {\n    /**\n   * @internal\n   */ constructor(){}\n    static createLookupTable(params) {\n        const [lookupTableAddress, bumpSeed] = PublicKey.findProgramAddressSync([\n            params.authority.toBuffer(),\n            (0,bigint_buffer__WEBPACK_IMPORTED_MODULE_5__.toBufferLE)(BigInt(params.recentSlot), 8)\n        ], this.programId);\n        const type = LOOKUP_TABLE_INSTRUCTION_LAYOUTS.CreateLookupTable;\n        const data = encodeData(type, {\n            recentSlot: BigInt(params.recentSlot),\n            bumpSeed: bumpSeed\n        });\n        const keys = [\n            {\n                pubkey: lookupTableAddress,\n                isSigner: false,\n                isWritable: true\n            },\n            {\n                pubkey: params.authority,\n                isSigner: true,\n                isWritable: false\n            },\n            {\n                pubkey: params.payer,\n                isSigner: true,\n                isWritable: true\n            },\n            {\n                pubkey: SystemProgram.programId,\n                isSigner: false,\n                isWritable: false\n            }\n        ];\n        return [\n            new TransactionInstruction({\n                programId: this.programId,\n                keys: keys,\n                data: data\n            }),\n            lookupTableAddress\n        ];\n    }\n    static freezeLookupTable(params) {\n        const type = LOOKUP_TABLE_INSTRUCTION_LAYOUTS.FreezeLookupTable;\n        const data = encodeData(type);\n        const keys = [\n            {\n                pubkey: params.lookupTable,\n                isSigner: false,\n                isWritable: true\n            },\n            {\n                pubkey: params.authority,\n                isSigner: true,\n                isWritable: false\n            }\n        ];\n        return new TransactionInstruction({\n            programId: this.programId,\n            keys: keys,\n            data: data\n        });\n    }\n    static extendLookupTable(params) {\n        const type = LOOKUP_TABLE_INSTRUCTION_LAYOUTS.ExtendLookupTable;\n        const data = encodeData(type, {\n            addresses: params.addresses.map((addr)=>addr.toBytes())\n        });\n        const keys = [\n            {\n                pubkey: params.lookupTable,\n                isSigner: false,\n                isWritable: true\n            },\n            {\n                pubkey: params.authority,\n                isSigner: true,\n                isWritable: false\n            }\n        ];\n        if (params.payer) {\n            keys.push({\n                pubkey: params.payer,\n                isSigner: true,\n                isWritable: true\n            }, {\n                pubkey: SystemProgram.programId,\n                isSigner: false,\n                isWritable: false\n            });\n        }\n        return new TransactionInstruction({\n            programId: this.programId,\n            keys: keys,\n            data: data\n        });\n    }\n    static deactivateLookupTable(params) {\n        const type = LOOKUP_TABLE_INSTRUCTION_LAYOUTS.DeactivateLookupTable;\n        const data = encodeData(type);\n        const keys = [\n            {\n                pubkey: params.lookupTable,\n                isSigner: false,\n                isWritable: true\n            },\n            {\n                pubkey: params.authority,\n                isSigner: true,\n                isWritable: false\n            }\n        ];\n        return new TransactionInstruction({\n            programId: this.programId,\n            keys: keys,\n            data: data\n        });\n    }\n    static closeLookupTable(params) {\n        const type = LOOKUP_TABLE_INSTRUCTION_LAYOUTS.CloseLookupTable;\n        const data = encodeData(type);\n        const keys = [\n            {\n                pubkey: params.lookupTable,\n                isSigner: false,\n                isWritable: true\n            },\n            {\n                pubkey: params.authority,\n                isSigner: true,\n                isWritable: false\n            },\n            {\n                pubkey: params.recipient,\n                isSigner: false,\n                isWritable: true\n            }\n        ];\n        return new TransactionInstruction({\n            programId: this.programId,\n            keys: keys,\n            data: data\n        });\n    }\n}\nAddressLookupTableProgram.programId = new PublicKey(\"AddressLookupTab1e1111111111111111111111111\");\n/**\n * Compute Budget Instruction class\n */ class ComputeBudgetInstruction {\n    /**\n   * @internal\n   */ constructor(){}\n    /**\n   * Decode a compute budget instruction and retrieve the instruction type.\n   */ static decodeInstructionType(instruction) {\n        this.checkProgramId(instruction.programId);\n        const instructionTypeLayout = _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u8(\"instruction\");\n        const typeIndex = instructionTypeLayout.decode(instruction.data);\n        let type;\n        for (const [ixType, layout] of Object.entries(COMPUTE_BUDGET_INSTRUCTION_LAYOUTS)){\n            if (layout.index == typeIndex) {\n                type = ixType;\n                break;\n            }\n        }\n        if (!type) {\n            throw new Error(\"Instruction type incorrect; not a ComputeBudgetInstruction\");\n        }\n        return type;\n    }\n    /**\n   * Decode request units compute budget instruction and retrieve the instruction params.\n   */ static decodeRequestUnits(instruction) {\n        this.checkProgramId(instruction.programId);\n        const { units, additionalFee } = decodeData$1(COMPUTE_BUDGET_INSTRUCTION_LAYOUTS.RequestUnits, instruction.data);\n        return {\n            units,\n            additionalFee\n        };\n    }\n    /**\n   * Decode request heap frame compute budget instruction and retrieve the instruction params.\n   */ static decodeRequestHeapFrame(instruction) {\n        this.checkProgramId(instruction.programId);\n        const { bytes } = decodeData$1(COMPUTE_BUDGET_INSTRUCTION_LAYOUTS.RequestHeapFrame, instruction.data);\n        return {\n            bytes\n        };\n    }\n    /**\n   * Decode set compute unit limit compute budget instruction and retrieve the instruction params.\n   */ static decodeSetComputeUnitLimit(instruction) {\n        this.checkProgramId(instruction.programId);\n        const { units } = decodeData$1(COMPUTE_BUDGET_INSTRUCTION_LAYOUTS.SetComputeUnitLimit, instruction.data);\n        return {\n            units\n        };\n    }\n    /**\n   * Decode set compute unit price compute budget instruction and retrieve the instruction params.\n   */ static decodeSetComputeUnitPrice(instruction) {\n        this.checkProgramId(instruction.programId);\n        const { microLamports } = decodeData$1(COMPUTE_BUDGET_INSTRUCTION_LAYOUTS.SetComputeUnitPrice, instruction.data);\n        return {\n            microLamports\n        };\n    }\n    /**\n   * @internal\n   */ static checkProgramId(programId) {\n        if (!programId.equals(ComputeBudgetProgram.programId)) {\n            throw new Error(\"invalid instruction; programId is not ComputeBudgetProgram\");\n        }\n    }\n}\n/**\n * An enumeration of valid ComputeBudgetInstructionType's\n */ /**\n * Request units instruction params\n */ /**\n * Request heap frame instruction params\n */ /**\n * Set compute unit limit instruction params\n */ /**\n * Set compute unit price instruction params\n */ /**\n * An enumeration of valid ComputeBudget InstructionType's\n * @internal\n */ const COMPUTE_BUDGET_INSTRUCTION_LAYOUTS = Object.freeze({\n    RequestUnits: {\n        index: 0,\n        layout: _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.struct([\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u8(\"instruction\"),\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u32(\"units\"),\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u32(\"additionalFee\")\n        ])\n    },\n    RequestHeapFrame: {\n        index: 1,\n        layout: _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.struct([\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u8(\"instruction\"),\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u32(\"bytes\")\n        ])\n    },\n    SetComputeUnitLimit: {\n        index: 2,\n        layout: _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.struct([\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u8(\"instruction\"),\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u32(\"units\")\n        ])\n    },\n    SetComputeUnitPrice: {\n        index: 3,\n        layout: _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.struct([\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u8(\"instruction\"),\n            u64(\"microLamports\")\n        ])\n    }\n});\n/**\n * Factory class for transaction instructions to interact with the Compute Budget program\n */ class ComputeBudgetProgram {\n    /**\n   * @internal\n   */ constructor(){}\n    /**\n   * Public key that identifies the Compute Budget program\n   */ /**\n   * @deprecated Instead, call {@link setComputeUnitLimit} and/or {@link setComputeUnitPrice}\n   */ static requestUnits(params) {\n        const type = COMPUTE_BUDGET_INSTRUCTION_LAYOUTS.RequestUnits;\n        const data = encodeData(type, params);\n        return new TransactionInstruction({\n            keys: [],\n            programId: this.programId,\n            data\n        });\n    }\n    static requestHeapFrame(params) {\n        const type = COMPUTE_BUDGET_INSTRUCTION_LAYOUTS.RequestHeapFrame;\n        const data = encodeData(type, params);\n        return new TransactionInstruction({\n            keys: [],\n            programId: this.programId,\n            data\n        });\n    }\n    static setComputeUnitLimit(params) {\n        const type = COMPUTE_BUDGET_INSTRUCTION_LAYOUTS.SetComputeUnitLimit;\n        const data = encodeData(type, params);\n        return new TransactionInstruction({\n            keys: [],\n            programId: this.programId,\n            data\n        });\n    }\n    static setComputeUnitPrice(params) {\n        const type = COMPUTE_BUDGET_INSTRUCTION_LAYOUTS.SetComputeUnitPrice;\n        const data = encodeData(type, {\n            microLamports: BigInt(params.microLamports)\n        });\n        return new TransactionInstruction({\n            keys: [],\n            programId: this.programId,\n            data\n        });\n    }\n}\nComputeBudgetProgram.programId = new PublicKey(\"ComputeBudget111111111111111111111111111111\");\nconst PRIVATE_KEY_BYTES$1 = 64;\nconst PUBLIC_KEY_BYTES$1 = 32;\nconst SIGNATURE_BYTES = 64;\n/**\n * Params for creating an ed25519 instruction using a public key\n */ /**\n * Params for creating an ed25519 instruction using a private key\n */ const ED25519_INSTRUCTION_LAYOUT = _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.struct([\n    _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u8(\"numSignatures\"),\n    _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u8(\"padding\"),\n    _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u16(\"signatureOffset\"),\n    _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u16(\"signatureInstructionIndex\"),\n    _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u16(\"publicKeyOffset\"),\n    _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u16(\"publicKeyInstructionIndex\"),\n    _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u16(\"messageDataOffset\"),\n    _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u16(\"messageDataSize\"),\n    _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u16(\"messageInstructionIndex\")\n]);\nclass Ed25519Program {\n    /**\n   * @internal\n   */ constructor(){}\n    /**\n   * Public key that identifies the ed25519 program\n   */ /**\n   * Create an ed25519 instruction with a public key and signature. The\n   * public key must be a buffer that is 32 bytes long, and the signature\n   * must be a buffer of 64 bytes.\n   */ static createInstructionWithPublicKey(params) {\n        const { publicKey, message, signature, instructionIndex } = params;\n        assert(publicKey.length === PUBLIC_KEY_BYTES$1, `Public Key must be ${PUBLIC_KEY_BYTES$1} bytes but received ${publicKey.length} bytes`);\n        assert(signature.length === SIGNATURE_BYTES, `Signature must be ${SIGNATURE_BYTES} bytes but received ${signature.length} bytes`);\n        const publicKeyOffset = ED25519_INSTRUCTION_LAYOUT.span;\n        const signatureOffset = publicKeyOffset + publicKey.length;\n        const messageDataOffset = signatureOffset + signature.length;\n        const numSignatures = 1;\n        const instructionData = buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.alloc(messageDataOffset + message.length);\n        const index = instructionIndex == null ? 0xffff // An index of `u16::MAX` makes it default to the current instruction.\n         : instructionIndex;\n        ED25519_INSTRUCTION_LAYOUT.encode({\n            numSignatures,\n            padding: 0,\n            signatureOffset,\n            signatureInstructionIndex: index,\n            publicKeyOffset,\n            publicKeyInstructionIndex: index,\n            messageDataOffset,\n            messageDataSize: message.length,\n            messageInstructionIndex: index\n        }, instructionData);\n        instructionData.fill(publicKey, publicKeyOffset);\n        instructionData.fill(signature, signatureOffset);\n        instructionData.fill(message, messageDataOffset);\n        return new TransactionInstruction({\n            keys: [],\n            programId: Ed25519Program.programId,\n            data: instructionData\n        });\n    }\n    /**\n   * Create an ed25519 instruction with a private key. The private key\n   * must be a buffer that is 64 bytes long.\n   */ static createInstructionWithPrivateKey(params) {\n        const { privateKey, message, instructionIndex } = params;\n        assert(privateKey.length === PRIVATE_KEY_BYTES$1, `Private key must be ${PRIVATE_KEY_BYTES$1} bytes but received ${privateKey.length} bytes`);\n        try {\n            const keypair = Keypair.fromSecretKey(privateKey);\n            const publicKey = keypair.publicKey.toBytes();\n            const signature = sign(message, keypair.secretKey);\n            return this.createInstructionWithPublicKey({\n                publicKey,\n                message,\n                signature,\n                instructionIndex\n            });\n        } catch (error) {\n            throw new Error(`Error creating instruction; ${error}`);\n        }\n    }\n}\nEd25519Program.programId = new PublicKey(\"Ed25519SigVerify111111111111111111111111111\");\nconst ecdsaSign = (msgHash, privKey)=>{\n    const signature = _noble_curves_secp256k1__WEBPACK_IMPORTED_MODULE_16__.secp256k1.sign(msgHash, privKey);\n    return [\n        signature.toCompactRawBytes(),\n        signature.recovery\n    ];\n};\n_noble_curves_secp256k1__WEBPACK_IMPORTED_MODULE_16__.secp256k1.utils.isValidPrivateKey;\nconst publicKeyCreate = _noble_curves_secp256k1__WEBPACK_IMPORTED_MODULE_16__.secp256k1.getPublicKey;\nconst PRIVATE_KEY_BYTES = 32;\nconst ETHEREUM_ADDRESS_BYTES = 20;\nconst PUBLIC_KEY_BYTES = 64;\nconst SIGNATURE_OFFSETS_SERIALIZED_SIZE = 11;\n/**\n * Params for creating an secp256k1 instruction using a public key\n */ /**\n * Params for creating an secp256k1 instruction using an Ethereum address\n */ /**\n * Params for creating an secp256k1 instruction using a private key\n */ const SECP256K1_INSTRUCTION_LAYOUT = _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.struct([\n    _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u8(\"numSignatures\"),\n    _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u16(\"signatureOffset\"),\n    _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u8(\"signatureInstructionIndex\"),\n    _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u16(\"ethAddressOffset\"),\n    _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u8(\"ethAddressInstructionIndex\"),\n    _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u16(\"messageDataOffset\"),\n    _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u16(\"messageDataSize\"),\n    _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u8(\"messageInstructionIndex\"),\n    _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.blob(20, \"ethAddress\"),\n    _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.blob(64, \"signature\"),\n    _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u8(\"recoveryId\")\n]);\nclass Secp256k1Program {\n    /**\n   * @internal\n   */ constructor(){}\n    /**\n   * Public key that identifies the secp256k1 program\n   */ /**\n   * Construct an Ethereum address from a secp256k1 public key buffer.\n   * @param {Buffer} publicKey a 64 byte secp256k1 public key buffer\n   */ static publicKeyToEthAddress(publicKey) {\n        assert(publicKey.length === PUBLIC_KEY_BYTES, `Public key must be ${PUBLIC_KEY_BYTES} bytes but received ${publicKey.length} bytes`);\n        try {\n            return buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.from((0,_noble_hashes_sha3__WEBPACK_IMPORTED_MODULE_17__.keccak_256)(toBuffer(publicKey))).slice(-ETHEREUM_ADDRESS_BYTES);\n        } catch (error) {\n            throw new Error(`Error constructing Ethereum address: ${error}`);\n        }\n    }\n    /**\n   * Create an secp256k1 instruction with a public key. The public key\n   * must be a buffer that is 64 bytes long.\n   */ static createInstructionWithPublicKey(params) {\n        const { publicKey, message, signature, recoveryId, instructionIndex } = params;\n        return Secp256k1Program.createInstructionWithEthAddress({\n            ethAddress: Secp256k1Program.publicKeyToEthAddress(publicKey),\n            message,\n            signature,\n            recoveryId,\n            instructionIndex\n        });\n    }\n    /**\n   * Create an secp256k1 instruction with an Ethereum address. The address\n   * must be a hex string or a buffer that is 20 bytes long.\n   */ static createInstructionWithEthAddress(params) {\n        const { ethAddress: rawAddress, message, signature, recoveryId, instructionIndex = 0 } = params;\n        let ethAddress;\n        if (typeof rawAddress === \"string\") {\n            if (rawAddress.startsWith(\"0x\")) {\n                ethAddress = buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.from(rawAddress.substr(2), \"hex\");\n            } else {\n                ethAddress = buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.from(rawAddress, \"hex\");\n            }\n        } else {\n            ethAddress = rawAddress;\n        }\n        assert(ethAddress.length === ETHEREUM_ADDRESS_BYTES, `Address must be ${ETHEREUM_ADDRESS_BYTES} bytes but received ${ethAddress.length} bytes`);\n        const dataStart = 1 + SIGNATURE_OFFSETS_SERIALIZED_SIZE;\n        const ethAddressOffset = dataStart;\n        const signatureOffset = dataStart + ethAddress.length;\n        const messageDataOffset = signatureOffset + signature.length + 1;\n        const numSignatures = 1;\n        const instructionData = buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.alloc(SECP256K1_INSTRUCTION_LAYOUT.span + message.length);\n        SECP256K1_INSTRUCTION_LAYOUT.encode({\n            numSignatures,\n            signatureOffset,\n            signatureInstructionIndex: instructionIndex,\n            ethAddressOffset,\n            ethAddressInstructionIndex: instructionIndex,\n            messageDataOffset,\n            messageDataSize: message.length,\n            messageInstructionIndex: instructionIndex,\n            signature: toBuffer(signature),\n            ethAddress: toBuffer(ethAddress),\n            recoveryId\n        }, instructionData);\n        instructionData.fill(toBuffer(message), SECP256K1_INSTRUCTION_LAYOUT.span);\n        return new TransactionInstruction({\n            keys: [],\n            programId: Secp256k1Program.programId,\n            data: instructionData\n        });\n    }\n    /**\n   * Create an secp256k1 instruction with a private key. The private key\n   * must be a buffer that is 32 bytes long.\n   */ static createInstructionWithPrivateKey(params) {\n        const { privateKey: pkey, message, instructionIndex } = params;\n        assert(pkey.length === PRIVATE_KEY_BYTES, `Private key must be ${PRIVATE_KEY_BYTES} bytes but received ${pkey.length} bytes`);\n        try {\n            const privateKey = toBuffer(pkey);\n            const publicKey = publicKeyCreate(privateKey, false).slice(1); // throw away leading byte\n            const messageHash = buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.from((0,_noble_hashes_sha3__WEBPACK_IMPORTED_MODULE_17__.keccak_256)(toBuffer(message)));\n            const [signature, recoveryId] = ecdsaSign(messageHash, privateKey);\n            return this.createInstructionWithPublicKey({\n                publicKey,\n                message,\n                signature,\n                recoveryId,\n                instructionIndex\n            });\n        } catch (error) {\n            throw new Error(`Error creating instruction; ${error}`);\n        }\n    }\n}\nSecp256k1Program.programId = new PublicKey(\"KeccakSecp256k11111111111111111111111111111\");\nvar _Lockup;\n/**\n * Address of the stake config account which configures the rate\n * of stake warmup and cooldown as well as the slashing penalty.\n */ const STAKE_CONFIG_ID = new PublicKey(\"StakeConfig11111111111111111111111111111111\");\n/**\n * Stake account authority info\n */ class Authorized {\n    /**\n   * Create a new Authorized object\n   * @param staker the stake authority\n   * @param withdrawer the withdraw authority\n   */ constructor(staker, withdrawer){\n        /** stake authority */ this.staker = void 0;\n        /** withdraw authority */ this.withdrawer = void 0;\n        this.staker = staker;\n        this.withdrawer = withdrawer;\n    }\n}\n/**\n * Stake account lockup info\n */ class Lockup {\n    /**\n   * Create a new Lockup object\n   */ constructor(unixTimestamp, epoch, custodian){\n        /** Unix timestamp of lockup expiration */ this.unixTimestamp = void 0;\n        /** Epoch of lockup expiration */ this.epoch = void 0;\n        /** Lockup custodian authority */ this.custodian = void 0;\n        this.unixTimestamp = unixTimestamp;\n        this.epoch = epoch;\n        this.custodian = custodian;\n    }\n}\n_Lockup = Lockup;\nLockup.default = new _Lockup(0, 0, PublicKey.default);\n/**\n * Create stake account transaction params\n */ /**\n * Create stake account with seed transaction params\n */ /**\n * Initialize stake instruction params\n */ /**\n * Delegate stake instruction params\n */ /**\n * Authorize stake instruction params\n */ /**\n * Authorize stake instruction params using a derived key\n */ /**\n * Split stake instruction params\n */ /**\n * Split with seed transaction params\n */ /**\n * Withdraw stake instruction params\n */ /**\n * Deactivate stake instruction params\n */ /**\n * Merge stake instruction params\n */ /**\n * Stake Instruction class\n */ class StakeInstruction {\n    /**\n   * @internal\n   */ constructor(){}\n    /**\n   * Decode a stake instruction and retrieve the instruction type.\n   */ static decodeInstructionType(instruction) {\n        this.checkProgramId(instruction.programId);\n        const instructionTypeLayout = _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u32(\"instruction\");\n        const typeIndex = instructionTypeLayout.decode(instruction.data);\n        let type;\n        for (const [ixType, layout] of Object.entries(STAKE_INSTRUCTION_LAYOUTS)){\n            if (layout.index == typeIndex) {\n                type = ixType;\n                break;\n            }\n        }\n        if (!type) {\n            throw new Error(\"Instruction type incorrect; not a StakeInstruction\");\n        }\n        return type;\n    }\n    /**\n   * Decode a initialize stake instruction and retrieve the instruction params.\n   */ static decodeInitialize(instruction) {\n        this.checkProgramId(instruction.programId);\n        this.checkKeyLength(instruction.keys, 2);\n        const { authorized, lockup } = decodeData$1(STAKE_INSTRUCTION_LAYOUTS.Initialize, instruction.data);\n        return {\n            stakePubkey: instruction.keys[0].pubkey,\n            authorized: new Authorized(new PublicKey(authorized.staker), new PublicKey(authorized.withdrawer)),\n            lockup: new Lockup(lockup.unixTimestamp, lockup.epoch, new PublicKey(lockup.custodian))\n        };\n    }\n    /**\n   * Decode a delegate stake instruction and retrieve the instruction params.\n   */ static decodeDelegate(instruction) {\n        this.checkProgramId(instruction.programId);\n        this.checkKeyLength(instruction.keys, 6);\n        decodeData$1(STAKE_INSTRUCTION_LAYOUTS.Delegate, instruction.data);\n        return {\n            stakePubkey: instruction.keys[0].pubkey,\n            votePubkey: instruction.keys[1].pubkey,\n            authorizedPubkey: instruction.keys[5].pubkey\n        };\n    }\n    /**\n   * Decode an authorize stake instruction and retrieve the instruction params.\n   */ static decodeAuthorize(instruction) {\n        this.checkProgramId(instruction.programId);\n        this.checkKeyLength(instruction.keys, 3);\n        const { newAuthorized, stakeAuthorizationType } = decodeData$1(STAKE_INSTRUCTION_LAYOUTS.Authorize, instruction.data);\n        const o = {\n            stakePubkey: instruction.keys[0].pubkey,\n            authorizedPubkey: instruction.keys[2].pubkey,\n            newAuthorizedPubkey: new PublicKey(newAuthorized),\n            stakeAuthorizationType: {\n                index: stakeAuthorizationType\n            }\n        };\n        if (instruction.keys.length > 3) {\n            o.custodianPubkey = instruction.keys[3].pubkey;\n        }\n        return o;\n    }\n    /**\n   * Decode an authorize-with-seed stake instruction and retrieve the instruction params.\n   */ static decodeAuthorizeWithSeed(instruction) {\n        this.checkProgramId(instruction.programId);\n        this.checkKeyLength(instruction.keys, 2);\n        const { newAuthorized, stakeAuthorizationType, authoritySeed, authorityOwner } = decodeData$1(STAKE_INSTRUCTION_LAYOUTS.AuthorizeWithSeed, instruction.data);\n        const o = {\n            stakePubkey: instruction.keys[0].pubkey,\n            authorityBase: instruction.keys[1].pubkey,\n            authoritySeed: authoritySeed,\n            authorityOwner: new PublicKey(authorityOwner),\n            newAuthorizedPubkey: new PublicKey(newAuthorized),\n            stakeAuthorizationType: {\n                index: stakeAuthorizationType\n            }\n        };\n        if (instruction.keys.length > 3) {\n            o.custodianPubkey = instruction.keys[3].pubkey;\n        }\n        return o;\n    }\n    /**\n   * Decode a split stake instruction and retrieve the instruction params.\n   */ static decodeSplit(instruction) {\n        this.checkProgramId(instruction.programId);\n        this.checkKeyLength(instruction.keys, 3);\n        const { lamports } = decodeData$1(STAKE_INSTRUCTION_LAYOUTS.Split, instruction.data);\n        return {\n            stakePubkey: instruction.keys[0].pubkey,\n            splitStakePubkey: instruction.keys[1].pubkey,\n            authorizedPubkey: instruction.keys[2].pubkey,\n            lamports\n        };\n    }\n    /**\n   * Decode a merge stake instruction and retrieve the instruction params.\n   */ static decodeMerge(instruction) {\n        this.checkProgramId(instruction.programId);\n        this.checkKeyLength(instruction.keys, 3);\n        decodeData$1(STAKE_INSTRUCTION_LAYOUTS.Merge, instruction.data);\n        return {\n            stakePubkey: instruction.keys[0].pubkey,\n            sourceStakePubKey: instruction.keys[1].pubkey,\n            authorizedPubkey: instruction.keys[4].pubkey\n        };\n    }\n    /**\n   * Decode a withdraw stake instruction and retrieve the instruction params.\n   */ static decodeWithdraw(instruction) {\n        this.checkProgramId(instruction.programId);\n        this.checkKeyLength(instruction.keys, 5);\n        const { lamports } = decodeData$1(STAKE_INSTRUCTION_LAYOUTS.Withdraw, instruction.data);\n        const o = {\n            stakePubkey: instruction.keys[0].pubkey,\n            toPubkey: instruction.keys[1].pubkey,\n            authorizedPubkey: instruction.keys[4].pubkey,\n            lamports\n        };\n        if (instruction.keys.length > 5) {\n            o.custodianPubkey = instruction.keys[5].pubkey;\n        }\n        return o;\n    }\n    /**\n   * Decode a deactivate stake instruction and retrieve the instruction params.\n   */ static decodeDeactivate(instruction) {\n        this.checkProgramId(instruction.programId);\n        this.checkKeyLength(instruction.keys, 3);\n        decodeData$1(STAKE_INSTRUCTION_LAYOUTS.Deactivate, instruction.data);\n        return {\n            stakePubkey: instruction.keys[0].pubkey,\n            authorizedPubkey: instruction.keys[2].pubkey\n        };\n    }\n    /**\n   * @internal\n   */ static checkProgramId(programId) {\n        if (!programId.equals(StakeProgram.programId)) {\n            throw new Error(\"invalid instruction; programId is not StakeProgram\");\n        }\n    }\n    /**\n   * @internal\n   */ static checkKeyLength(keys, expectedLength) {\n        if (keys.length < expectedLength) {\n            throw new Error(`invalid instruction; found ${keys.length} keys, expected at least ${expectedLength}`);\n        }\n    }\n}\n/**\n * An enumeration of valid StakeInstructionType's\n */ /**\n * An enumeration of valid stake InstructionType's\n * @internal\n */ const STAKE_INSTRUCTION_LAYOUTS = Object.freeze({\n    Initialize: {\n        index: 0,\n        layout: _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.struct([\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u32(\"instruction\"),\n            authorized(),\n            lockup()\n        ])\n    },\n    Authorize: {\n        index: 1,\n        layout: _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.struct([\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u32(\"instruction\"),\n            publicKey(\"newAuthorized\"),\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u32(\"stakeAuthorizationType\")\n        ])\n    },\n    Delegate: {\n        index: 2,\n        layout: _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.struct([\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u32(\"instruction\")\n        ])\n    },\n    Split: {\n        index: 3,\n        layout: _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.struct([\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u32(\"instruction\"),\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.ns64(\"lamports\")\n        ])\n    },\n    Withdraw: {\n        index: 4,\n        layout: _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.struct([\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u32(\"instruction\"),\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.ns64(\"lamports\")\n        ])\n    },\n    Deactivate: {\n        index: 5,\n        layout: _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.struct([\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u32(\"instruction\")\n        ])\n    },\n    Merge: {\n        index: 7,\n        layout: _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.struct([\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u32(\"instruction\")\n        ])\n    },\n    AuthorizeWithSeed: {\n        index: 8,\n        layout: _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.struct([\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u32(\"instruction\"),\n            publicKey(\"newAuthorized\"),\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u32(\"stakeAuthorizationType\"),\n            rustString(\"authoritySeed\"),\n            publicKey(\"authorityOwner\")\n        ])\n    }\n});\n/**\n * Stake authorization type\n */ /**\n * An enumeration of valid StakeAuthorizationLayout's\n */ const StakeAuthorizationLayout = Object.freeze({\n    Staker: {\n        index: 0\n    },\n    Withdrawer: {\n        index: 1\n    }\n});\n/**\n * Factory class for transactions to interact with the Stake program\n */ class StakeProgram {\n    /**\n   * @internal\n   */ constructor(){}\n    /**\n   * Public key that identifies the Stake program\n   */ /**\n   * Generate an Initialize instruction to add to a Stake Create transaction\n   */ static initialize(params) {\n        const { stakePubkey, authorized, lockup: maybeLockup } = params;\n        const lockup = maybeLockup || Lockup.default;\n        const type = STAKE_INSTRUCTION_LAYOUTS.Initialize;\n        const data = encodeData(type, {\n            authorized: {\n                staker: toBuffer(authorized.staker.toBuffer()),\n                withdrawer: toBuffer(authorized.withdrawer.toBuffer())\n            },\n            lockup: {\n                unixTimestamp: lockup.unixTimestamp,\n                epoch: lockup.epoch,\n                custodian: toBuffer(lockup.custodian.toBuffer())\n            }\n        });\n        const instructionData = {\n            keys: [\n                {\n                    pubkey: stakePubkey,\n                    isSigner: false,\n                    isWritable: true\n                },\n                {\n                    pubkey: SYSVAR_RENT_PUBKEY,\n                    isSigner: false,\n                    isWritable: false\n                }\n            ],\n            programId: this.programId,\n            data\n        };\n        return new TransactionInstruction(instructionData);\n    }\n    /**\n   * Generate a Transaction that creates a new Stake account at\n   *   an address generated with `from`, a seed, and the Stake programId\n   */ static createAccountWithSeed(params) {\n        const transaction = new Transaction();\n        transaction.add(SystemProgram.createAccountWithSeed({\n            fromPubkey: params.fromPubkey,\n            newAccountPubkey: params.stakePubkey,\n            basePubkey: params.basePubkey,\n            seed: params.seed,\n            lamports: params.lamports,\n            space: this.space,\n            programId: this.programId\n        }));\n        const { stakePubkey, authorized, lockup } = params;\n        return transaction.add(this.initialize({\n            stakePubkey,\n            authorized,\n            lockup\n        }));\n    }\n    /**\n   * Generate a Transaction that creates a new Stake account\n   */ static createAccount(params) {\n        const transaction = new Transaction();\n        transaction.add(SystemProgram.createAccount({\n            fromPubkey: params.fromPubkey,\n            newAccountPubkey: params.stakePubkey,\n            lamports: params.lamports,\n            space: this.space,\n            programId: this.programId\n        }));\n        const { stakePubkey, authorized, lockup } = params;\n        return transaction.add(this.initialize({\n            stakePubkey,\n            authorized,\n            lockup\n        }));\n    }\n    /**\n   * Generate a Transaction that delegates Stake tokens to a validator\n   * Vote PublicKey. This transaction can also be used to redelegate Stake\n   * to a new validator Vote PublicKey.\n   */ static delegate(params) {\n        const { stakePubkey, authorizedPubkey, votePubkey } = params;\n        const type = STAKE_INSTRUCTION_LAYOUTS.Delegate;\n        const data = encodeData(type);\n        return new Transaction().add({\n            keys: [\n                {\n                    pubkey: stakePubkey,\n                    isSigner: false,\n                    isWritable: true\n                },\n                {\n                    pubkey: votePubkey,\n                    isSigner: false,\n                    isWritable: false\n                },\n                {\n                    pubkey: SYSVAR_CLOCK_PUBKEY,\n                    isSigner: false,\n                    isWritable: false\n                },\n                {\n                    pubkey: SYSVAR_STAKE_HISTORY_PUBKEY,\n                    isSigner: false,\n                    isWritable: false\n                },\n                {\n                    pubkey: STAKE_CONFIG_ID,\n                    isSigner: false,\n                    isWritable: false\n                },\n                {\n                    pubkey: authorizedPubkey,\n                    isSigner: true,\n                    isWritable: false\n                }\n            ],\n            programId: this.programId,\n            data\n        });\n    }\n    /**\n   * Generate a Transaction that authorizes a new PublicKey as Staker\n   * or Withdrawer on the Stake account.\n   */ static authorize(params) {\n        const { stakePubkey, authorizedPubkey, newAuthorizedPubkey, stakeAuthorizationType, custodianPubkey } = params;\n        const type = STAKE_INSTRUCTION_LAYOUTS.Authorize;\n        const data = encodeData(type, {\n            newAuthorized: toBuffer(newAuthorizedPubkey.toBuffer()),\n            stakeAuthorizationType: stakeAuthorizationType.index\n        });\n        const keys = [\n            {\n                pubkey: stakePubkey,\n                isSigner: false,\n                isWritable: true\n            },\n            {\n                pubkey: SYSVAR_CLOCK_PUBKEY,\n                isSigner: false,\n                isWritable: true\n            },\n            {\n                pubkey: authorizedPubkey,\n                isSigner: true,\n                isWritable: false\n            }\n        ];\n        if (custodianPubkey) {\n            keys.push({\n                pubkey: custodianPubkey,\n                isSigner: true,\n                isWritable: false\n            });\n        }\n        return new Transaction().add({\n            keys,\n            programId: this.programId,\n            data\n        });\n    }\n    /**\n   * Generate a Transaction that authorizes a new PublicKey as Staker\n   * or Withdrawer on the Stake account.\n   */ static authorizeWithSeed(params) {\n        const { stakePubkey, authorityBase, authoritySeed, authorityOwner, newAuthorizedPubkey, stakeAuthorizationType, custodianPubkey } = params;\n        const type = STAKE_INSTRUCTION_LAYOUTS.AuthorizeWithSeed;\n        const data = encodeData(type, {\n            newAuthorized: toBuffer(newAuthorizedPubkey.toBuffer()),\n            stakeAuthorizationType: stakeAuthorizationType.index,\n            authoritySeed: authoritySeed,\n            authorityOwner: toBuffer(authorityOwner.toBuffer())\n        });\n        const keys = [\n            {\n                pubkey: stakePubkey,\n                isSigner: false,\n                isWritable: true\n            },\n            {\n                pubkey: authorityBase,\n                isSigner: true,\n                isWritable: false\n            },\n            {\n                pubkey: SYSVAR_CLOCK_PUBKEY,\n                isSigner: false,\n                isWritable: false\n            }\n        ];\n        if (custodianPubkey) {\n            keys.push({\n                pubkey: custodianPubkey,\n                isSigner: true,\n                isWritable: false\n            });\n        }\n        return new Transaction().add({\n            keys,\n            programId: this.programId,\n            data\n        });\n    }\n    /**\n   * @internal\n   */ static splitInstruction(params) {\n        const { stakePubkey, authorizedPubkey, splitStakePubkey, lamports } = params;\n        const type = STAKE_INSTRUCTION_LAYOUTS.Split;\n        const data = encodeData(type, {\n            lamports\n        });\n        return new TransactionInstruction({\n            keys: [\n                {\n                    pubkey: stakePubkey,\n                    isSigner: false,\n                    isWritable: true\n                },\n                {\n                    pubkey: splitStakePubkey,\n                    isSigner: false,\n                    isWritable: true\n                },\n                {\n                    pubkey: authorizedPubkey,\n                    isSigner: true,\n                    isWritable: false\n                }\n            ],\n            programId: this.programId,\n            data\n        });\n    }\n    /**\n   * Generate a Transaction that splits Stake tokens into another stake account\n   */ static split(params, // Compute the cost of allocating the new stake account in lamports\n    rentExemptReserve) {\n        const transaction = new Transaction();\n        transaction.add(SystemProgram.createAccount({\n            fromPubkey: params.authorizedPubkey,\n            newAccountPubkey: params.splitStakePubkey,\n            lamports: rentExemptReserve,\n            space: this.space,\n            programId: this.programId\n        }));\n        return transaction.add(this.splitInstruction(params));\n    }\n    /**\n   * Generate a Transaction that splits Stake tokens into another account\n   * derived from a base public key and seed\n   */ static splitWithSeed(params, // If this stake account is new, compute the cost of allocating it in lamports\n    rentExemptReserve) {\n        const { stakePubkey, authorizedPubkey, splitStakePubkey, basePubkey, seed, lamports } = params;\n        const transaction = new Transaction();\n        transaction.add(SystemProgram.allocate({\n            accountPubkey: splitStakePubkey,\n            basePubkey,\n            seed,\n            space: this.space,\n            programId: this.programId\n        }));\n        if (rentExemptReserve && rentExemptReserve > 0) {\n            transaction.add(SystemProgram.transfer({\n                fromPubkey: params.authorizedPubkey,\n                toPubkey: splitStakePubkey,\n                lamports: rentExemptReserve\n            }));\n        }\n        return transaction.add(this.splitInstruction({\n            stakePubkey,\n            authorizedPubkey,\n            splitStakePubkey,\n            lamports\n        }));\n    }\n    /**\n   * Generate a Transaction that merges Stake accounts.\n   */ static merge(params) {\n        const { stakePubkey, sourceStakePubKey, authorizedPubkey } = params;\n        const type = STAKE_INSTRUCTION_LAYOUTS.Merge;\n        const data = encodeData(type);\n        return new Transaction().add({\n            keys: [\n                {\n                    pubkey: stakePubkey,\n                    isSigner: false,\n                    isWritable: true\n                },\n                {\n                    pubkey: sourceStakePubKey,\n                    isSigner: false,\n                    isWritable: true\n                },\n                {\n                    pubkey: SYSVAR_CLOCK_PUBKEY,\n                    isSigner: false,\n                    isWritable: false\n                },\n                {\n                    pubkey: SYSVAR_STAKE_HISTORY_PUBKEY,\n                    isSigner: false,\n                    isWritable: false\n                },\n                {\n                    pubkey: authorizedPubkey,\n                    isSigner: true,\n                    isWritable: false\n                }\n            ],\n            programId: this.programId,\n            data\n        });\n    }\n    /**\n   * Generate a Transaction that withdraws deactivated Stake tokens.\n   */ static withdraw(params) {\n        const { stakePubkey, authorizedPubkey, toPubkey, lamports, custodianPubkey } = params;\n        const type = STAKE_INSTRUCTION_LAYOUTS.Withdraw;\n        const data = encodeData(type, {\n            lamports\n        });\n        const keys = [\n            {\n                pubkey: stakePubkey,\n                isSigner: false,\n                isWritable: true\n            },\n            {\n                pubkey: toPubkey,\n                isSigner: false,\n                isWritable: true\n            },\n            {\n                pubkey: SYSVAR_CLOCK_PUBKEY,\n                isSigner: false,\n                isWritable: false\n            },\n            {\n                pubkey: SYSVAR_STAKE_HISTORY_PUBKEY,\n                isSigner: false,\n                isWritable: false\n            },\n            {\n                pubkey: authorizedPubkey,\n                isSigner: true,\n                isWritable: false\n            }\n        ];\n        if (custodianPubkey) {\n            keys.push({\n                pubkey: custodianPubkey,\n                isSigner: true,\n                isWritable: false\n            });\n        }\n        return new Transaction().add({\n            keys,\n            programId: this.programId,\n            data\n        });\n    }\n    /**\n   * Generate a Transaction that deactivates Stake tokens.\n   */ static deactivate(params) {\n        const { stakePubkey, authorizedPubkey } = params;\n        const type = STAKE_INSTRUCTION_LAYOUTS.Deactivate;\n        const data = encodeData(type);\n        return new Transaction().add({\n            keys: [\n                {\n                    pubkey: stakePubkey,\n                    isSigner: false,\n                    isWritable: true\n                },\n                {\n                    pubkey: SYSVAR_CLOCK_PUBKEY,\n                    isSigner: false,\n                    isWritable: false\n                },\n                {\n                    pubkey: authorizedPubkey,\n                    isSigner: true,\n                    isWritable: false\n                }\n            ],\n            programId: this.programId,\n            data\n        });\n    }\n}\nStakeProgram.programId = new PublicKey(\"Stake11111111111111111111111111111111111111\");\n/**\n * Max space of a Stake account\n *\n * This is generated from the solana-stake-program StakeState struct as\n * `StakeStateV2::size_of()`:\n * https://docs.rs/solana-stake-program/latest/solana_stake_program/stake_state/enum.StakeStateV2.html\n */ StakeProgram.space = 200;\n/**\n * Vote account info\n */ class VoteInit {\n    /** [0, 100] */ constructor(nodePubkey, authorizedVoter, authorizedWithdrawer, commission){\n        this.nodePubkey = void 0;\n        this.authorizedVoter = void 0;\n        this.authorizedWithdrawer = void 0;\n        this.commission = void 0;\n        this.nodePubkey = nodePubkey;\n        this.authorizedVoter = authorizedVoter;\n        this.authorizedWithdrawer = authorizedWithdrawer;\n        this.commission = commission;\n    }\n}\n/**\n * Create vote account transaction params\n */ /**\n * InitializeAccount instruction params\n */ /**\n * Authorize instruction params\n */ /**\n * AuthorizeWithSeed instruction params\n */ /**\n * Withdraw from vote account transaction params\n */ /**\n * Update validator identity (node pubkey) vote account instruction params.\n */ /**\n * Vote Instruction class\n */ class VoteInstruction {\n    /**\n   * @internal\n   */ constructor(){}\n    /**\n   * Decode a vote instruction and retrieve the instruction type.\n   */ static decodeInstructionType(instruction) {\n        this.checkProgramId(instruction.programId);\n        const instructionTypeLayout = _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u32(\"instruction\");\n        const typeIndex = instructionTypeLayout.decode(instruction.data);\n        let type;\n        for (const [ixType, layout] of Object.entries(VOTE_INSTRUCTION_LAYOUTS)){\n            if (layout.index == typeIndex) {\n                type = ixType;\n                break;\n            }\n        }\n        if (!type) {\n            throw new Error(\"Instruction type incorrect; not a VoteInstruction\");\n        }\n        return type;\n    }\n    /**\n   * Decode an initialize vote instruction and retrieve the instruction params.\n   */ static decodeInitializeAccount(instruction) {\n        this.checkProgramId(instruction.programId);\n        this.checkKeyLength(instruction.keys, 4);\n        const { voteInit } = decodeData$1(VOTE_INSTRUCTION_LAYOUTS.InitializeAccount, instruction.data);\n        return {\n            votePubkey: instruction.keys[0].pubkey,\n            nodePubkey: instruction.keys[3].pubkey,\n            voteInit: new VoteInit(new PublicKey(voteInit.nodePubkey), new PublicKey(voteInit.authorizedVoter), new PublicKey(voteInit.authorizedWithdrawer), voteInit.commission)\n        };\n    }\n    /**\n   * Decode an authorize instruction and retrieve the instruction params.\n   */ static decodeAuthorize(instruction) {\n        this.checkProgramId(instruction.programId);\n        this.checkKeyLength(instruction.keys, 3);\n        const { newAuthorized, voteAuthorizationType } = decodeData$1(VOTE_INSTRUCTION_LAYOUTS.Authorize, instruction.data);\n        return {\n            votePubkey: instruction.keys[0].pubkey,\n            authorizedPubkey: instruction.keys[2].pubkey,\n            newAuthorizedPubkey: new PublicKey(newAuthorized),\n            voteAuthorizationType: {\n                index: voteAuthorizationType\n            }\n        };\n    }\n    /**\n   * Decode an authorize instruction and retrieve the instruction params.\n   */ static decodeAuthorizeWithSeed(instruction) {\n        this.checkProgramId(instruction.programId);\n        this.checkKeyLength(instruction.keys, 3);\n        const { voteAuthorizeWithSeedArgs: { currentAuthorityDerivedKeyOwnerPubkey, currentAuthorityDerivedKeySeed, newAuthorized, voteAuthorizationType } } = decodeData$1(VOTE_INSTRUCTION_LAYOUTS.AuthorizeWithSeed, instruction.data);\n        return {\n            currentAuthorityDerivedKeyBasePubkey: instruction.keys[2].pubkey,\n            currentAuthorityDerivedKeyOwnerPubkey: new PublicKey(currentAuthorityDerivedKeyOwnerPubkey),\n            currentAuthorityDerivedKeySeed: currentAuthorityDerivedKeySeed,\n            newAuthorizedPubkey: new PublicKey(newAuthorized),\n            voteAuthorizationType: {\n                index: voteAuthorizationType\n            },\n            votePubkey: instruction.keys[0].pubkey\n        };\n    }\n    /**\n   * Decode a withdraw instruction and retrieve the instruction params.\n   */ static decodeWithdraw(instruction) {\n        this.checkProgramId(instruction.programId);\n        this.checkKeyLength(instruction.keys, 3);\n        const { lamports } = decodeData$1(VOTE_INSTRUCTION_LAYOUTS.Withdraw, instruction.data);\n        return {\n            votePubkey: instruction.keys[0].pubkey,\n            authorizedWithdrawerPubkey: instruction.keys[2].pubkey,\n            lamports,\n            toPubkey: instruction.keys[1].pubkey\n        };\n    }\n    /**\n   * @internal\n   */ static checkProgramId(programId) {\n        if (!programId.equals(VoteProgram.programId)) {\n            throw new Error(\"invalid instruction; programId is not VoteProgram\");\n        }\n    }\n    /**\n   * @internal\n   */ static checkKeyLength(keys, expectedLength) {\n        if (keys.length < expectedLength) {\n            throw new Error(`invalid instruction; found ${keys.length} keys, expected at least ${expectedLength}`);\n        }\n    }\n}\n/**\n * An enumeration of valid VoteInstructionType's\n */ /** @internal */ const VOTE_INSTRUCTION_LAYOUTS = Object.freeze({\n    InitializeAccount: {\n        index: 0,\n        layout: _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.struct([\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u32(\"instruction\"),\n            voteInit()\n        ])\n    },\n    Authorize: {\n        index: 1,\n        layout: _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.struct([\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u32(\"instruction\"),\n            publicKey(\"newAuthorized\"),\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u32(\"voteAuthorizationType\")\n        ])\n    },\n    Withdraw: {\n        index: 3,\n        layout: _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.struct([\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u32(\"instruction\"),\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.ns64(\"lamports\")\n        ])\n    },\n    UpdateValidatorIdentity: {\n        index: 4,\n        layout: _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.struct([\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u32(\"instruction\")\n        ])\n    },\n    AuthorizeWithSeed: {\n        index: 10,\n        layout: _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.struct([\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u32(\"instruction\"),\n            voteAuthorizeWithSeedArgs()\n        ])\n    }\n});\n/**\n * VoteAuthorize type\n */ /**\n * An enumeration of valid VoteAuthorization layouts.\n */ const VoteAuthorizationLayout = Object.freeze({\n    Voter: {\n        index: 0\n    },\n    Withdrawer: {\n        index: 1\n    }\n});\n/**\n * Factory class for transactions to interact with the Vote program\n */ class VoteProgram {\n    /**\n   * @internal\n   */ constructor(){}\n    /**\n   * Public key that identifies the Vote program\n   */ /**\n   * Generate an Initialize instruction.\n   */ static initializeAccount(params) {\n        const { votePubkey, nodePubkey, voteInit } = params;\n        const type = VOTE_INSTRUCTION_LAYOUTS.InitializeAccount;\n        const data = encodeData(type, {\n            voteInit: {\n                nodePubkey: toBuffer(voteInit.nodePubkey.toBuffer()),\n                authorizedVoter: toBuffer(voteInit.authorizedVoter.toBuffer()),\n                authorizedWithdrawer: toBuffer(voteInit.authorizedWithdrawer.toBuffer()),\n                commission: voteInit.commission\n            }\n        });\n        const instructionData = {\n            keys: [\n                {\n                    pubkey: votePubkey,\n                    isSigner: false,\n                    isWritable: true\n                },\n                {\n                    pubkey: SYSVAR_RENT_PUBKEY,\n                    isSigner: false,\n                    isWritable: false\n                },\n                {\n                    pubkey: SYSVAR_CLOCK_PUBKEY,\n                    isSigner: false,\n                    isWritable: false\n                },\n                {\n                    pubkey: nodePubkey,\n                    isSigner: true,\n                    isWritable: false\n                }\n            ],\n            programId: this.programId,\n            data\n        };\n        return new TransactionInstruction(instructionData);\n    }\n    /**\n   * Generate a transaction that creates a new Vote account.\n   */ static createAccount(params) {\n        const transaction = new Transaction();\n        transaction.add(SystemProgram.createAccount({\n            fromPubkey: params.fromPubkey,\n            newAccountPubkey: params.votePubkey,\n            lamports: params.lamports,\n            space: this.space,\n            programId: this.programId\n        }));\n        return transaction.add(this.initializeAccount({\n            votePubkey: params.votePubkey,\n            nodePubkey: params.voteInit.nodePubkey,\n            voteInit: params.voteInit\n        }));\n    }\n    /**\n   * Generate a transaction that authorizes a new Voter or Withdrawer on the Vote account.\n   */ static authorize(params) {\n        const { votePubkey, authorizedPubkey, newAuthorizedPubkey, voteAuthorizationType } = params;\n        const type = VOTE_INSTRUCTION_LAYOUTS.Authorize;\n        const data = encodeData(type, {\n            newAuthorized: toBuffer(newAuthorizedPubkey.toBuffer()),\n            voteAuthorizationType: voteAuthorizationType.index\n        });\n        const keys = [\n            {\n                pubkey: votePubkey,\n                isSigner: false,\n                isWritable: true\n            },\n            {\n                pubkey: SYSVAR_CLOCK_PUBKEY,\n                isSigner: false,\n                isWritable: false\n            },\n            {\n                pubkey: authorizedPubkey,\n                isSigner: true,\n                isWritable: false\n            }\n        ];\n        return new Transaction().add({\n            keys,\n            programId: this.programId,\n            data\n        });\n    }\n    /**\n   * Generate a transaction that authorizes a new Voter or Withdrawer on the Vote account\n   * where the current Voter or Withdrawer authority is a derived key.\n   */ static authorizeWithSeed(params) {\n        const { currentAuthorityDerivedKeyBasePubkey, currentAuthorityDerivedKeyOwnerPubkey, currentAuthorityDerivedKeySeed, newAuthorizedPubkey, voteAuthorizationType, votePubkey } = params;\n        const type = VOTE_INSTRUCTION_LAYOUTS.AuthorizeWithSeed;\n        const data = encodeData(type, {\n            voteAuthorizeWithSeedArgs: {\n                currentAuthorityDerivedKeyOwnerPubkey: toBuffer(currentAuthorityDerivedKeyOwnerPubkey.toBuffer()),\n                currentAuthorityDerivedKeySeed: currentAuthorityDerivedKeySeed,\n                newAuthorized: toBuffer(newAuthorizedPubkey.toBuffer()),\n                voteAuthorizationType: voteAuthorizationType.index\n            }\n        });\n        const keys = [\n            {\n                pubkey: votePubkey,\n                isSigner: false,\n                isWritable: true\n            },\n            {\n                pubkey: SYSVAR_CLOCK_PUBKEY,\n                isSigner: false,\n                isWritable: false\n            },\n            {\n                pubkey: currentAuthorityDerivedKeyBasePubkey,\n                isSigner: true,\n                isWritable: false\n            }\n        ];\n        return new Transaction().add({\n            keys,\n            programId: this.programId,\n            data\n        });\n    }\n    /**\n   * Generate a transaction to withdraw from a Vote account.\n   */ static withdraw(params) {\n        const { votePubkey, authorizedWithdrawerPubkey, lamports, toPubkey } = params;\n        const type = VOTE_INSTRUCTION_LAYOUTS.Withdraw;\n        const data = encodeData(type, {\n            lamports\n        });\n        const keys = [\n            {\n                pubkey: votePubkey,\n                isSigner: false,\n                isWritable: true\n            },\n            {\n                pubkey: toPubkey,\n                isSigner: false,\n                isWritable: true\n            },\n            {\n                pubkey: authorizedWithdrawerPubkey,\n                isSigner: true,\n                isWritable: false\n            }\n        ];\n        return new Transaction().add({\n            keys,\n            programId: this.programId,\n            data\n        });\n    }\n    /**\n   * Generate a transaction to withdraw safely from a Vote account.\n   *\n   * This function was created as a safeguard for vote accounts running validators, `safeWithdraw`\n   * checks that the withdraw amount will not exceed the specified balance while leaving enough left\n   * to cover rent. If you wish to close the vote account by withdrawing the full amount, call the\n   * `withdraw` method directly.\n   */ static safeWithdraw(params, currentVoteAccountBalance, rentExemptMinimum) {\n        if (params.lamports > currentVoteAccountBalance - rentExemptMinimum) {\n            throw new Error(\"Withdraw will leave vote account with insufficient funds.\");\n        }\n        return VoteProgram.withdraw(params);\n    }\n    /**\n   * Generate a transaction to update the validator identity (node pubkey) of a Vote account.\n   */ static updateValidatorIdentity(params) {\n        const { votePubkey, authorizedWithdrawerPubkey, nodePubkey } = params;\n        const type = VOTE_INSTRUCTION_LAYOUTS.UpdateValidatorIdentity;\n        const data = encodeData(type);\n        const keys = [\n            {\n                pubkey: votePubkey,\n                isSigner: false,\n                isWritable: true\n            },\n            {\n                pubkey: nodePubkey,\n                isSigner: true,\n                isWritable: false\n            },\n            {\n                pubkey: authorizedWithdrawerPubkey,\n                isSigner: true,\n                isWritable: false\n            }\n        ];\n        return new Transaction().add({\n            keys,\n            programId: this.programId,\n            data\n        });\n    }\n}\nVoteProgram.programId = new PublicKey(\"Vote111111111111111111111111111111111111111\");\n/**\n * Max space of a Vote account\n *\n * This is generated from the solana-vote-program VoteState struct as\n * `VoteState::size_of()`:\n * https://docs.rs/solana-vote-program/1.9.5/solana_vote_program/vote_state/struct.VoteState.html#method.size_of\n *\n * KEEP IN SYNC WITH `VoteState::size_of()` in https://github.com/solana-labs/solana/blob/a474cb24b9238f5edcc982f65c0b37d4a1046f7e/sdk/program/src/vote/state/mod.rs#L340-L342\n */ VoteProgram.space = 3762;\nconst VALIDATOR_INFO_KEY = new PublicKey(\"Va1idator1nfo111111111111111111111111111111\");\n/**\n * @internal\n */ /**\n * Info used to identity validators.\n */ const InfoString = (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.type)({\n    name: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.string)(),\n    website: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.optional)((0,superstruct__WEBPACK_IMPORTED_MODULE_15__.string)()),\n    details: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.optional)((0,superstruct__WEBPACK_IMPORTED_MODULE_15__.string)()),\n    keybaseUsername: (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.optional)((0,superstruct__WEBPACK_IMPORTED_MODULE_15__.string)())\n});\n/**\n * ValidatorInfo class\n */ class ValidatorInfo {\n    /**\n   * Construct a valid ValidatorInfo\n   *\n   * @param key validator public key\n   * @param info validator information\n   */ constructor(key, info){\n        /**\n     * validator public key\n     */ this.key = void 0;\n        /**\n     * validator information\n     */ this.info = void 0;\n        this.key = key;\n        this.info = info;\n    }\n    /**\n   * Deserialize ValidatorInfo from the config account data. Exactly two config\n   * keys are required in the data.\n   *\n   * @param buffer config account data\n   * @return null if info was not found\n   */ static fromConfigData(buffer) {\n        let byteArray = [\n            ...buffer\n        ];\n        const configKeyCount = decodeLength(byteArray);\n        if (configKeyCount !== 2) return null;\n        const configKeys = [];\n        for(let i = 0; i < 2; i++){\n            const publicKey = new PublicKey(guardedSplice(byteArray, 0, PUBLIC_KEY_LENGTH));\n            const isSigner = guardedShift(byteArray) === 1;\n            configKeys.push({\n                publicKey,\n                isSigner\n            });\n        }\n        if (configKeys[0].publicKey.equals(VALIDATOR_INFO_KEY)) {\n            if (configKeys[1].isSigner) {\n                const rawInfo = rustString().decode(buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.from(byteArray));\n                const info = JSON.parse(rawInfo);\n                (0,superstruct__WEBPACK_IMPORTED_MODULE_15__.assert)(info, InfoString);\n                return new ValidatorInfo(configKeys[1].publicKey, info);\n            }\n        }\n        return null;\n    }\n}\nconst VOTE_PROGRAM_ID = new PublicKey(\"Vote111111111111111111111111111111111111111\");\n/**\n * History of how many credits earned by the end of each epoch\n */ /**\n * See https://github.com/solana-labs/solana/blob/8a12ed029cfa38d4a45400916c2463fb82bbec8c/programs/vote_api/src/vote_state.rs#L68-L88\n *\n * @internal\n */ const VoteAccountLayout = _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.struct([\n    publicKey(\"nodePubkey\"),\n    publicKey(\"authorizedWithdrawer\"),\n    _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u8(\"commission\"),\n    _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.nu64(),\n    // votes.length\n    _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.seq(_solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.struct([\n        _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.nu64(\"slot\"),\n        _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u32(\"confirmationCount\")\n    ]), _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.offset(_solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u32(), -8), \"votes\"),\n    _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u8(\"rootSlotValid\"),\n    _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.nu64(\"rootSlot\"),\n    _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.nu64(),\n    // authorizedVoters.length\n    _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.seq(_solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.struct([\n        _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.nu64(\"epoch\"),\n        publicKey(\"authorizedVoter\")\n    ]), _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.offset(_solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u32(), -8), \"authorizedVoters\"),\n    _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.struct([\n        _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.seq(_solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.struct([\n            publicKey(\"authorizedPubkey\"),\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.nu64(\"epochOfLastAuthorizedSwitch\"),\n            _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.nu64(\"targetEpoch\")\n        ]), 32, \"buf\"),\n        _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.nu64(\"idx\"),\n        _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u8(\"isEmpty\")\n    ], \"priorVoters\"),\n    _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.nu64(),\n    // epochCredits.length\n    _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.seq(_solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.struct([\n        _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.nu64(\"epoch\"),\n        _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.nu64(\"credits\"),\n        _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.nu64(\"prevCredits\")\n    ]), _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.offset(_solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u32(), -8), \"epochCredits\"),\n    _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.struct([\n        _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.nu64(\"slot\"),\n        _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.nu64(\"timestamp\")\n    ], \"lastTimestamp\")\n]);\n/**\n * VoteAccount class\n */ class VoteAccount {\n    /**\n   * @internal\n   */ constructor(args){\n        this.nodePubkey = void 0;\n        this.authorizedWithdrawer = void 0;\n        this.commission = void 0;\n        this.rootSlot = void 0;\n        this.votes = void 0;\n        this.authorizedVoters = void 0;\n        this.priorVoters = void 0;\n        this.epochCredits = void 0;\n        this.lastTimestamp = void 0;\n        this.nodePubkey = args.nodePubkey;\n        this.authorizedWithdrawer = args.authorizedWithdrawer;\n        this.commission = args.commission;\n        this.rootSlot = args.rootSlot;\n        this.votes = args.votes;\n        this.authorizedVoters = args.authorizedVoters;\n        this.priorVoters = args.priorVoters;\n        this.epochCredits = args.epochCredits;\n        this.lastTimestamp = args.lastTimestamp;\n    }\n    /**\n   * Deserialize VoteAccount from the account data.\n   *\n   * @param buffer account data\n   * @return VoteAccount\n   */ static fromAccountData(buffer) {\n        const versionOffset = 4;\n        const va = VoteAccountLayout.decode(toBuffer(buffer), versionOffset);\n        let rootSlot = va.rootSlot;\n        if (!va.rootSlotValid) {\n            rootSlot = null;\n        }\n        return new VoteAccount({\n            nodePubkey: new PublicKey(va.nodePubkey),\n            authorizedWithdrawer: new PublicKey(va.authorizedWithdrawer),\n            commission: va.commission,\n            votes: va.votes,\n            rootSlot,\n            authorizedVoters: va.authorizedVoters.map(parseAuthorizedVoter),\n            priorVoters: getPriorVoters(va.priorVoters),\n            epochCredits: va.epochCredits,\n            lastTimestamp: va.lastTimestamp\n        });\n    }\n}\nfunction parseAuthorizedVoter({ authorizedVoter, epoch }) {\n    return {\n        epoch,\n        authorizedVoter: new PublicKey(authorizedVoter)\n    };\n}\nfunction parsePriorVoters({ authorizedPubkey, epochOfLastAuthorizedSwitch, targetEpoch }) {\n    return {\n        authorizedPubkey: new PublicKey(authorizedPubkey),\n        epochOfLastAuthorizedSwitch,\n        targetEpoch\n    };\n}\nfunction getPriorVoters({ buf, idx, isEmpty }) {\n    if (isEmpty) {\n        return [];\n    }\n    return [\n        ...buf.slice(idx + 1).map(parsePriorVoters),\n        ...buf.slice(0, idx).map(parsePriorVoters)\n    ];\n}\nconst endpoint = {\n    http: {\n        devnet: \"http://api.devnet.solana.com\",\n        testnet: \"http://api.testnet.solana.com\",\n        \"mainnet-beta\": \"http://api.mainnet-beta.solana.com/\"\n    },\n    https: {\n        devnet: \"https://api.devnet.solana.com\",\n        testnet: \"https://api.testnet.solana.com\",\n        \"mainnet-beta\": \"https://api.mainnet-beta.solana.com/\"\n    }\n};\n/**\n * Retrieves the RPC API URL for the specified cluster\n * @param {Cluster} [cluster=\"devnet\"] - The cluster name of the RPC API URL to use. Possible options: 'devnet' | 'testnet' | 'mainnet-beta'\n * @param {boolean} [tls=\"http\"] - Use TLS when connecting to cluster.\n *\n * @returns {string} URL string of the RPC endpoint\n */ function clusterApiUrl(cluster, tls) {\n    const key = tls === false ? \"http\" : \"https\";\n    if (!cluster) {\n        return endpoint[key][\"devnet\"];\n    }\n    const url = endpoint[key][cluster];\n    if (!url) {\n        throw new Error(`Unknown ${key} cluster: ${cluster}`);\n    }\n    return url;\n}\n/**\n * Send and confirm a raw transaction\n *\n * If `commitment` option is not specified, defaults to 'max' commitment.\n *\n * @param {Connection} connection\n * @param {Buffer} rawTransaction\n * @param {TransactionConfirmationStrategy} confirmationStrategy\n * @param {ConfirmOptions} [options]\n * @returns {Promise<TransactionSignature>}\n */ /**\n * @deprecated Calling `sendAndConfirmRawTransaction()` without a `confirmationStrategy`\n * is no longer supported and will be removed in a future version.\n */ // eslint-disable-next-line no-redeclare\n// eslint-disable-next-line no-redeclare\nasync function sendAndConfirmRawTransaction(connection, rawTransaction, confirmationStrategyOrConfirmOptions, maybeConfirmOptions) {\n    let confirmationStrategy;\n    let options;\n    if (confirmationStrategyOrConfirmOptions && Object.prototype.hasOwnProperty.call(confirmationStrategyOrConfirmOptions, \"lastValidBlockHeight\")) {\n        confirmationStrategy = confirmationStrategyOrConfirmOptions;\n        options = maybeConfirmOptions;\n    } else if (confirmationStrategyOrConfirmOptions && Object.prototype.hasOwnProperty.call(confirmationStrategyOrConfirmOptions, \"nonceValue\")) {\n        confirmationStrategy = confirmationStrategyOrConfirmOptions;\n        options = maybeConfirmOptions;\n    } else {\n        options = confirmationStrategyOrConfirmOptions;\n    }\n    const sendOptions = options && {\n        skipPreflight: options.skipPreflight,\n        preflightCommitment: options.preflightCommitment || options.commitment,\n        minContextSlot: options.minContextSlot\n    };\n    const signature = await connection.sendRawTransaction(rawTransaction, sendOptions);\n    const commitment = options && options.commitment;\n    const confirmationPromise = confirmationStrategy ? connection.confirmTransaction(confirmationStrategy, commitment) : connection.confirmTransaction(signature, commitment);\n    const status = (await confirmationPromise).value;\n    if (status.err) {\n        throw new Error(`Raw transaction ${signature} failed (${JSON.stringify(status)})`);\n    }\n    return signature;\n}\n/**\n * There are 1-billion lamports in one SOL\n */ const LAMPORTS_PER_SOL = 1000000000;\n //# sourceMappingURL=index.esm.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL0Bzb2xhbmEvd2ViMy5qcy9saWIvaW5kZXguZXNtLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBZ0M7QUFDZ0I7QUFDekI7QUFDQztBQUNzQjtBQUN1QjtBQUNmO0FBQ1Q7QUFDVTtBQUN6QjtBQUNFO0FBQ3VCO0FBQzJIO0FBQ2hJO0FBQ1Y7QUFDa0M7QUFDRTtBQUM1QjtBQUNJO0FBRXBEOzs7O0NBSUMsR0FFRDs7Q0FFQyxHQUVELE1BQU15QyxxQkFBcUJ4QywyREFBT0EsQ0FBQ3lDLEtBQUssQ0FBQ0MsZ0JBQWdCO0FBQ3pELE1BQU1DLGtCQUFrQjtJQUN0QixNQUFNQyxnQkFBZ0I1QywyREFBT0EsQ0FBQ3lDLEtBQUssQ0FBQ0MsZ0JBQWdCO0lBQ3BELE1BQU1HLFlBQVlDLGFBQWFGO0lBQy9CLE1BQU1HLFlBQVksSUFBSUMsV0FBVztJQUNqQ0QsVUFBVUUsR0FBRyxDQUFDTDtJQUNkRyxVQUFVRSxHQUFHLENBQUNKLFdBQVc7SUFDekIsT0FBTztRQUNMQTtRQUNBRTtJQUNGO0FBQ0Y7QUFDQSxNQUFNRCxlQUFlOUMsMkRBQU9BLENBQUM4QyxZQUFZO0FBQ3pDLFNBQVNJLFVBQVVMLFNBQVM7SUFDMUIsSUFBSTtRQUNGN0MsMkRBQU9BLENBQUNtRCxhQUFhLENBQUNDLE9BQU8sQ0FBQ1A7UUFDOUIsT0FBTztJQUNULEVBQUUsT0FBTTtRQUNOLE9BQU87SUFDVDtBQUNGO0FBQ0EsTUFBTVEsT0FBTyxDQUFDQyxTQUFTUCxZQUFjL0MsMkRBQU9BLENBQUNxRCxJQUFJLENBQUNDLFNBQVNQLFVBQVVRLEtBQUssQ0FBQyxHQUFHO0FBQzlFLE1BQU1DLFNBQVN4RCwyREFBT0EsQ0FBQ3dELE1BQU07QUFFN0IsTUFBTUMsV0FBV0MsQ0FBQUE7SUFD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LENBQUM7SUFDbkY7SUFDQSxPQUFPbFU7QUFDVDtBQUVBOztDQUVDLEdBQ0QsTUFBTTIwQyxtQkFBbUI7QUFFNmdELENBQ3RpRCxxQ0FBcUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL0Bzb2xhbmEvd2ViMy5qcy9saWIvaW5kZXguZXNtLmpzPzM5MWUiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgQnVmZmVyIH0gZnJvbSAnYnVmZmVyJztcbmltcG9ydCB7IGVkMjU1MTkgfSBmcm9tICdAbm9ibGUvY3VydmVzL2VkMjU1MTknO1xuaW1wb3J0IEJOIGZyb20gJ2JuLmpzJztcbmltcG9ydCBiczU4IGZyb20gJ2JzNTgnO1xuaW1wb3J0IHsgc2hhMjU2IH0gZnJvbSAnQG5vYmxlL2hhc2hlcy9zaGEyNTYnO1xuaW1wb3J0IHsgc2VyaWFsaXplLCBkZXNlcmlhbGl6ZSwgZGVzZXJpYWxpemVVbmNoZWNrZWQgfSBmcm9tICdib3JzaCc7XG5pbXBvcnQgKiBhcyBCdWZmZXJMYXlvdXQgZnJvbSAnQHNvbGFuYS9idWZmZXItbGF5b3V0JztcbmltcG9ydCB7IGJsb2IgfSBmcm9tICdAc29sYW5hL2J1ZmZlci1sYXlvdXQnO1xuaW1wb3J0IHsgdG9CaWdJbnRMRSwgdG9CdWZmZXJMRSB9IGZyb20gJ2JpZ2ludC1idWZmZXInO1xuaW1wb3J0IHJlcXVpcmUkJDAgZnJvbSAndXRpbCc7XG5pbXBvcnQgcmVxdWlyZSQkMCQxIGZyb20gJ2h0dHAnO1xuaW1wb3J0IHJlcXVpcmUkJDAkMiwgeyBBZ2VudCBhcyBBZ2VudCQxIH0gZnJvbSAnaHR0cHMnO1xuaW1wb3J0IHsgY29lcmNlLCBpbnN0YW5jZSwgc3RyaW5nLCB0dXBsZSwgbGl0ZXJhbCwgdW5rbm93biwgdHlwZSwgbnVtYmVyLCBhcnJheSwgbnVsbGFibGUsIG9wdGlvbmFsLCBib29sZWFuLCByZWNvcmQsIHVuaW9uLCBjcmVhdGUsIGFueSwgYXNzZXJ0IGFzIGFzc2VydCQxIH0gZnJvbSAnc3VwZXJzdHJ1Y3QnO1xuaW1wb3J0IFJwY0NsaWVudCBmcm9tICdqYXlzb24vbGliL2NsaWVudC9icm93c2VyJztcbmltcG9ydCAqIGFzIG5vZGVGZXRjaCBmcm9tICdub2RlLWZldGNoJztcbmltcG9ydCBScGNXZWJTb2NrZXRDb21tb25DbGllbnQgZnJvbSAncnBjLXdlYnNvY2tldHMvZGlzdC9saWIvY2xpZW50LmNqcyc7XG5pbXBvcnQgV2Vic29ja2V0RmFjdG9yeSBmcm9tICdycGMtd2Vic29ja2V0cy9kaXN0L2xpYi9jbGllbnQvd2Vic29ja2V0LmNqcyc7XG5pbXBvcnQgeyBrZWNjYWtfMjU2IH0gZnJvbSAnQG5vYmxlL2hhc2hlcy9zaGEzJztcbmltcG9ydCB7IHNlY3AyNTZrMSB9IGZyb20gJ0Bub2JsZS9jdXJ2ZXMvc2VjcDI1NmsxJztcblxuLyoqXG4gKiBBIDY0IGJ5dGUgc2VjcmV0IGtleSwgdGhlIGZpcnN0IDMyIGJ5dGVzIG9mIHdoaWNoIGlzIHRoZVxuICogcHJpdmF0ZSBzY2FsYXIgYW5kIHRoZSBsYXN0IDMyIGJ5dGVzIGlzIHRoZSBwdWJsaWMga2V5LlxuICogUmVhZCBtb3JlOiBodHRwczovL2Jsb2cubW96aWxsYS5vcmcvd2FybmVyLzIwMTEvMTEvMjkvZWQyNTUxOS1rZXlzL1xuICovXG5cbi8qKlxuICogRWQyNTUxOSBLZXlwYWlyXG4gKi9cblxuY29uc3QgZ2VuZXJhdGVQcml2YXRlS2V5ID0gZWQyNTUxOS51dGlscy5yYW5kb21Qcml2YXRlS2V5O1xuY29uc3QgZ2VuZXJhdGVLZXlwYWlyID0gKCkgPT4ge1xuICBjb25zdCBwcml2YXRlU2NhbGFyID0gZWQyNTUxOS51dGlscy5yYW5kb21Qcml2YXRlS2V5KCk7XG4gIGNvbnN0IHB1YmxpY0tleSA9IGdldFB1YmxpY0tleShwcml2YXRlU2NhbGFyKTtcbiAgY29uc3Qgc2VjcmV0S2V5ID0gbmV3IFVpbnQ4QXJyYXkoNjQpO1xuICBzZWNyZXRLZXkuc2V0KHByaXZhdGVTY2FsYXIpO1xuICBzZWNyZXRLZXkuc2V0KHB1YmxpY0tleSwgMzIpO1xuICByZXR1cm4ge1xuICAgIHB1YmxpY0tleSxcbiAgICBzZWNyZXRLZXlcbiAgfTtcbn07XG5jb25zdCBnZXRQdWJsaWNLZXkgPSBlZDI1NTE5LmdldFB1YmxpY0tleTtcbmZ1bmN0aW9uIGlzT25DdXJ2ZShwdWJsaWNLZXkpIHtcbiAgdHJ5IHtcbiAgICBlZDI1NTE5LkV4dGVuZGVkUG9pbnQuZnJvbUhleChwdWJsaWNLZXkpO1xuICAgIHJldHVybiB0cnVlO1xuICB9IGNhdGNoIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn1cbmNvbnN0IHNpZ24gPSAobWVzc2FnZSwgc2VjcmV0S2V5KSA9PiBlZDI1NTE5LnNpZ24obWVzc2FnZSwgc2VjcmV0S2V5LnNsaWNlKDAsIDMyKSk7XG5jb25zdCB2ZXJpZnkgPSBlZDI1NTE5LnZlcmlmeTtcblxuY29uc3QgdG9CdWZmZXIgPSBhcnIgPT4ge1xuICBpZiAoQnVmZmVyLmlzQnVmZmVyKGFycikpIHtcbiAgICByZXR1cm4gYXJyO1xuICB9IGVsc2UgaWYgKGFyciBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpIHtcbiAgICByZXR1cm4gQnVmZmVyLmZyb20oYXJyLmJ1ZmZlciwgYXJyLmJ5dGVPZmZzZXQsIGFyci5ieXRlTGVuZ3RoKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gQnVmZmVyLmZyb20oYXJyKTtcbiAgfVxufTtcblxuLy8gQ2xhc3Mgd3JhcHBpbmcgYSBwbGFpbiBvYmplY3RcbmNsYXNzIFN0cnVjdCB7XG4gIGNvbnN0cnVjdG9yKHByb3BlcnRpZXMpIHtcbiAgICBPYmplY3QuYXNzaWduKHRoaXMsIHByb3BlcnRpZXMpO1xuICB9XG4gIGVuY29kZSgpIHtcbiAgICByZXR1cm4gQnVmZmVyLmZyb20oc2VyaWFsaXplKFNPTEFOQV9TQ0hFTUEsIHRoaXMpKTtcbiAgfVxuICBzdGF0aWMgZGVjb2RlKGRhdGEpIHtcbiAgICByZXR1cm4gZGVzZXJpYWxpemUoU09MQU5BX1NDSEVNQSwgdGhpcywgZGF0YSk7XG4gIH1cbiAgc3RhdGljIGRlY29kZVVuY2hlY2tlZChkYXRhKSB7XG4gICAgcmV0dXJuIGRlc2VyaWFsaXplVW5jaGVja2VkKFNPTEFOQV9TQ0hFTUEsIHRoaXMsIGRhdGEpO1xuICB9XG59XG5cbi8vIENsYXNzIHJlcHJlc2VudGluZyBhIFJ1c3QtY29tcGF0aWJsZSBlbnVtLCBzaW5jZSBlbnVtcyBhcmUgb25seSBzdHJpbmdzIG9yXG4vLyBudW1iZXJzIGluIHB1cmUgSlNcbmNsYXNzIEVudW0gZXh0ZW5kcyBTdHJ1Y3Qge1xuICBjb25zdHJ1Y3Rvcihwcm9wZXJ0aWVzKSB7XG4gICAgc3VwZXIocHJvcGVydGllcyk7XG4gICAgdGhpcy5lbnVtID0gJyc7XG4gICAgaWYgKE9iamVjdC5rZXlzKHByb3BlcnRpZXMpLmxlbmd0aCAhPT0gMSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdFbnVtIGNhbiBvbmx5IHRha2Ugc2luZ2xlIHZhbHVlJyk7XG4gICAgfVxuICAgIE9iamVjdC5rZXlzKHByb3BlcnRpZXMpLm1hcChrZXkgPT4ge1xuICAgICAgdGhpcy5lbnVtID0ga2V5O1xuICAgIH0pO1xuICB9XG59XG5jb25zdCBTT0xBTkFfU0NIRU1BID0gbmV3IE1hcCgpO1xuXG52YXIgX1B1YmxpY0tleTtcblxuLyoqXG4gKiBNYXhpbXVtIGxlbmd0aCBvZiBkZXJpdmVkIHB1YmtleSBzZWVkXG4gKi9cbmNvbnN0IE1BWF9TRUVEX0xFTkdUSCA9IDMyO1xuXG4vKipcbiAqIFNpemUgb2YgcHVibGljIGtleSBpbiBieXRlc1xuICovXG5jb25zdCBQVUJMSUNfS0VZX0xFTkdUSCA9IDMyO1xuXG4vKipcbiAqIFZhbHVlIHRvIGJlIGNvbnZlcnRlZCBpbnRvIHB1YmxpYyBrZXlcbiAqL1xuXG4vKipcbiAqIEpTT04gb2JqZWN0IHJlcHJlc2VudGF0aW9uIG9mIFB1YmxpY0tleSBjbGFzc1xuICovXG5cbmZ1bmN0aW9uIGlzUHVibGljS2V5RGF0YSh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUuX2JuICE9PSB1bmRlZmluZWQ7XG59XG5cbi8vIGxvY2FsIGNvdW50ZXIgdXNlZCBieSBQdWJsaWNLZXkudW5pcXVlKClcbmxldCB1bmlxdWVQdWJsaWNLZXlDb3VudGVyID0gMTtcblxuLyoqXG4gKiBBIHB1YmxpYyBrZXlcbiAqL1xuY2xhc3MgUHVibGljS2V5IGV4dGVuZHMgU3RydWN0IHtcbiAgLyoqXG4gICAqIENyZWF0ZSBhIG5ldyBQdWJsaWNLZXkgb2JqZWN0XG4gICAqIEBwYXJhbSB2YWx1ZSBlZDI1NTE5IHB1YmxpYyBrZXkgYXMgYnVmZmVyIG9yIGJhc2UtNTggZW5jb2RlZCBzdHJpbmdcbiAgICovXG4gIGNvbnN0cnVjdG9yKHZhbHVlKSB7XG4gICAgc3VwZXIoe30pO1xuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICB0aGlzLl9ibiA9IHZvaWQgMDtcbiAgICBpZiAoaXNQdWJsaWNLZXlEYXRhKHZhbHVlKSkge1xuICAgICAgdGhpcy5fYm4gPSB2YWx1ZS5fYm47XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIC8vIGFzc3VtZSBiYXNlIDU4IGVuY29kaW5nIGJ5IGRlZmF1bHRcbiAgICAgICAgY29uc3QgZGVjb2RlZCA9IGJzNTguZGVjb2RlKHZhbHVlKTtcbiAgICAgICAgaWYgKGRlY29kZWQubGVuZ3RoICE9IFBVQkxJQ19LRVlfTEVOR1RIKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIHB1YmxpYyBrZXkgaW5wdXRgKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9ibiA9IG5ldyBCTihkZWNvZGVkKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuX2JuID0gbmV3IEJOKHZhbHVlKTtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLl9ibi5ieXRlTGVuZ3RoKCkgPiBQVUJMSUNfS0VZX0xFTkdUSCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgcHVibGljIGtleSBpbnB1dGApO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgdW5pcXVlIFB1YmxpY0tleSBmb3IgdGVzdHMgYW5kIGJlbmNobWFya3MgdXNpbmcgYSBjb3VudGVyXG4gICAqL1xuICBzdGF0aWMgdW5pcXVlKCkge1xuICAgIGNvbnN0IGtleSA9IG5ldyBQdWJsaWNLZXkodW5pcXVlUHVibGljS2V5Q291bnRlcik7XG4gICAgdW5pcXVlUHVibGljS2V5Q291bnRlciArPSAxO1xuICAgIHJldHVybiBuZXcgUHVibGljS2V5KGtleS50b0J1ZmZlcigpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZWZhdWx0IHB1YmxpYyBrZXkgdmFsdWUuIFRoZSBiYXNlNTgtZW5jb2RlZCBzdHJpbmcgcmVwcmVzZW50YXRpb24gaXMgYWxsIG9uZXMgKGFzIHNlZW4gYmVsb3cpXG4gICAqIFRoZSB1bmRlcmx5aW5nIEJOIG51bWJlciBpcyAzMiBieXRlcyB0aGF0IGFyZSBhbGwgemVyb3NcbiAgICovXG5cbiAgLyoqXG4gICAqIENoZWNrcyBpZiB0d28gcHVibGljS2V5cyBhcmUgZXF1YWxcbiAgICovXG4gIGVxdWFscyhwdWJsaWNLZXkpIHtcbiAgICByZXR1cm4gdGhpcy5fYm4uZXEocHVibGljS2V5Ll9ibik7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJuIHRoZSBiYXNlLTU4IHJlcHJlc2VudGF0aW9uIG9mIHRoZSBwdWJsaWMga2V5XG4gICAqL1xuICB0b0Jhc2U1OCgpIHtcbiAgICByZXR1cm4gYnM1OC5lbmNvZGUodGhpcy50b0J5dGVzKCkpO1xuICB9XG4gIHRvSlNPTigpIHtcbiAgICByZXR1cm4gdGhpcy50b0Jhc2U1OCgpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiB0aGUgYnl0ZSBhcnJheSByZXByZXNlbnRhdGlvbiBvZiB0aGUgcHVibGljIGtleSBpbiBiaWcgZW5kaWFuXG4gICAqL1xuICB0b0J5dGVzKCkge1xuICAgIGNvbnN0IGJ1ZiA9IHRoaXMudG9CdWZmZXIoKTtcbiAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoYnVmLmJ1ZmZlciwgYnVmLmJ5dGVPZmZzZXQsIGJ1Zi5ieXRlTGVuZ3RoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gdGhlIEJ1ZmZlciByZXByZXNlbnRhdGlvbiBvZiB0aGUgcHVibGljIGtleSBpbiBiaWcgZW5kaWFuXG4gICAqL1xuICB0b0J1ZmZlcigpIHtcbiAgICBjb25zdCBiID0gdGhpcy5fYm4udG9BcnJheUxpa2UoQnVmZmVyKTtcbiAgICBpZiAoYi5sZW5ndGggPT09IFBVQkxJQ19LRVlfTEVOR1RIKSB7XG4gICAgICByZXR1cm4gYjtcbiAgICB9XG4gICAgY29uc3QgemVyb1BhZCA9IEJ1ZmZlci5hbGxvYygzMik7XG4gICAgYi5jb3B5KHplcm9QYWQsIDMyIC0gYi5sZW5ndGgpO1xuICAgIHJldHVybiB6ZXJvUGFkO1xuICB9XG4gIGdldCBbU3ltYm9sLnRvU3RyaW5nVGFnXSgpIHtcbiAgICByZXR1cm4gYFB1YmxpY0tleSgke3RoaXMudG9TdHJpbmcoKX0pYDtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gdGhlIGJhc2UtNTggcmVwcmVzZW50YXRpb24gb2YgdGhlIHB1YmxpYyBrZXlcbiAgICovXG4gIHRvU3RyaW5nKCkge1xuICAgIHJldHVybiB0aGlzLnRvQmFzZTU4KCk7XG4gIH1cblxuICAvKipcbiAgICogRGVyaXZlIGEgcHVibGljIGtleSBmcm9tIGFub3RoZXIga2V5LCBhIHNlZWQsIGFuZCBhIHByb2dyYW0gSUQuXG4gICAqIFRoZSBwcm9ncmFtIElEIHdpbGwgYWxzbyBzZXJ2ZSBhcyB0aGUgb3duZXIgb2YgdGhlIHB1YmxpYyBrZXksIGdpdmluZ1xuICAgKiBpdCBwZXJtaXNzaW9uIHRvIHdyaXRlIGRhdGEgdG8gdGhlIGFjY291bnQuXG4gICAqL1xuICAvKiBlc2xpbnQtZGlzYWJsZSByZXF1aXJlLWF3YWl0ICovXG4gIHN0YXRpYyBhc3luYyBjcmVhdGVXaXRoU2VlZChmcm9tUHVibGljS2V5LCBzZWVkLCBwcm9ncmFtSWQpIHtcbiAgICBjb25zdCBidWZmZXIgPSBCdWZmZXIuY29uY2F0KFtmcm9tUHVibGljS2V5LnRvQnVmZmVyKCksIEJ1ZmZlci5mcm9tKHNlZWQpLCBwcm9ncmFtSWQudG9CdWZmZXIoKV0pO1xuICAgIGNvbnN0IHB1YmxpY0tleUJ5dGVzID0gc2hhMjU2KGJ1ZmZlcik7XG4gICAgcmV0dXJuIG5ldyBQdWJsaWNLZXkocHVibGljS2V5Qnl0ZXMpO1xuICB9XG5cbiAgLyoqXG4gICAqIERlcml2ZSBhIHByb2dyYW0gYWRkcmVzcyBmcm9tIHNlZWRzIGFuZCBhIHByb2dyYW0gSUQuXG4gICAqL1xuICAvKiBlc2xpbnQtZGlzYWJsZSByZXF1aXJlLWF3YWl0ICovXG4gIHN0YXRpYyBjcmVhdGVQcm9ncmFtQWRkcmVzc1N5bmMoc2VlZHMsIHByb2dyYW1JZCkge1xuICAgIGxldCBidWZmZXIgPSBCdWZmZXIuYWxsb2MoMCk7XG4gICAgc2VlZHMuZm9yRWFjaChmdW5jdGlvbiAoc2VlZCkge1xuICAgICAgaWYgKHNlZWQubGVuZ3RoID4gTUFYX1NFRURfTEVOR1RIKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYE1heCBzZWVkIGxlbmd0aCBleGNlZWRlZGApO1xuICAgICAgfVxuICAgICAgYnVmZmVyID0gQnVmZmVyLmNvbmNhdChbYnVmZmVyLCB0b0J1ZmZlcihzZWVkKV0pO1xuICAgIH0pO1xuICAgIGJ1ZmZlciA9IEJ1ZmZlci5jb25jYXQoW2J1ZmZlciwgcHJvZ3JhbUlkLnRvQnVmZmVyKCksIEJ1ZmZlci5mcm9tKCdQcm9ncmFtRGVyaXZlZEFkZHJlc3MnKV0pO1xuICAgIGNvbnN0IHB1YmxpY0tleUJ5dGVzID0gc2hhMjU2KGJ1ZmZlcik7XG4gICAgaWYgKGlzT25DdXJ2ZShwdWJsaWNLZXlCeXRlcykpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBzZWVkcywgYWRkcmVzcyBtdXN0IGZhbGwgb2ZmIHRoZSBjdXJ2ZWApO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IFB1YmxpY0tleShwdWJsaWNLZXlCeXRlcyk7XG4gIH1cblxuICAvKipcbiAgICogQXN5bmMgdmVyc2lvbiBvZiBjcmVhdGVQcm9ncmFtQWRkcmVzc1N5bmNcbiAgICogRm9yIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5XG4gICAqXG4gICAqIEBkZXByZWNhdGVkIFVzZSB7QGxpbmsgY3JlYXRlUHJvZ3JhbUFkZHJlc3NTeW5jfSBpbnN0ZWFkXG4gICAqL1xuICAvKiBlc2xpbnQtZGlzYWJsZSByZXF1aXJlLWF3YWl0ICovXG4gIHN0YXRpYyBhc3luYyBjcmVhdGVQcm9ncmFtQWRkcmVzcyhzZWVkcywgcHJvZ3JhbUlkKSB7XG4gICAgcmV0dXJuIHRoaXMuY3JlYXRlUHJvZ3JhbUFkZHJlc3NTeW5jKHNlZWRzLCBwcm9ncmFtSWQpO1xuICB9XG5cbiAgLyoqXG4gICAqIEZpbmQgYSB2YWxpZCBwcm9ncmFtIGFkZHJlc3NcbiAgICpcbiAgICogVmFsaWQgcHJvZ3JhbSBhZGRyZXNzZXMgbXVzdCBmYWxsIG9mZiB0aGUgZWQyNTUxOSBjdXJ2ZS4gIFRoaXMgZnVuY3Rpb25cbiAgICogaXRlcmF0ZXMgYSBub25jZSB1bnRpbCBpdCBmaW5kcyBvbmUgdGhhdCB3aGVuIGNvbWJpbmVkIHdpdGggdGhlIHNlZWRzXG4gICAqIHJlc3VsdHMgaW4gYSB2YWxpZCBwcm9ncmFtIGFkZHJlc3MuXG4gICAqL1xuICBzdGF0aWMgZmluZFByb2dyYW1BZGRyZXNzU3luYyhzZWVkcywgcHJvZ3JhbUlkKSB7XG4gICAgbGV0IG5vbmNlID0gMjU1O1xuICAgIGxldCBhZGRyZXNzO1xuICAgIHdoaWxlIChub25jZSAhPSAwKSB7XG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCBzZWVkc1dpdGhOb25jZSA9IHNlZWRzLmNvbmNhdChCdWZmZXIuZnJvbShbbm9uY2VdKSk7XG4gICAgICAgIGFkZHJlc3MgPSB0aGlzLmNyZWF0ZVByb2dyYW1BZGRyZXNzU3luYyhzZWVkc1dpdGhOb25jZSwgcHJvZ3JhbUlkKTtcbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBpZiAoZXJyIGluc3RhbmNlb2YgVHlwZUVycm9yKSB7XG4gICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICB9XG4gICAgICAgIG5vbmNlLS07XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIFthZGRyZXNzLCBub25jZV07XG4gICAgfVxuICAgIHRocm93IG5ldyBFcnJvcihgVW5hYmxlIHRvIGZpbmQgYSB2aWFibGUgcHJvZ3JhbSBhZGRyZXNzIG5vbmNlYCk7XG4gIH1cblxuICAvKipcbiAgICogQXN5bmMgdmVyc2lvbiBvZiBmaW5kUHJvZ3JhbUFkZHJlc3NTeW5jXG4gICAqIEZvciBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eVxuICAgKlxuICAgKiBAZGVwcmVjYXRlZCBVc2Uge0BsaW5rIGZpbmRQcm9ncmFtQWRkcmVzc1N5bmN9IGluc3RlYWRcbiAgICovXG4gIHN0YXRpYyBhc3luYyBmaW5kUHJvZ3JhbUFkZHJlc3Moc2VlZHMsIHByb2dyYW1JZCkge1xuICAgIHJldHVybiB0aGlzLmZpbmRQcm9ncmFtQWRkcmVzc1N5bmMoc2VlZHMsIHByb2dyYW1JZCk7XG4gIH1cblxuICAvKipcbiAgICogQ2hlY2sgdGhhdCBhIHB1YmtleSBpcyBvbiB0aGUgZWQyNTUxOSBjdXJ2ZS5cbiAgICovXG4gIHN0YXRpYyBpc09uQ3VydmUocHVia2V5RGF0YSkge1xuICAgIGNvbnN0IHB1YmtleSA9IG5ldyBQdWJsaWNLZXkocHVia2V5RGF0YSk7XG4gICAgcmV0dXJuIGlzT25DdXJ2ZShwdWJrZXkudG9CeXRlcygpKTtcbiAgfVxufVxuX1B1YmxpY0tleSA9IFB1YmxpY0tleTtcblB1YmxpY0tleS5kZWZhdWx0ID0gbmV3IF9QdWJsaWNLZXkoJzExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExJyk7XG5TT0xBTkFfU0NIRU1BLnNldChQdWJsaWNLZXksIHtcbiAga2luZDogJ3N0cnVjdCcsXG4gIGZpZWxkczogW1snX2JuJywgJ3UyNTYnXV1cbn0pO1xuXG4vKipcbiAqIEFuIGFjY291bnQga2V5IHBhaXIgKHB1YmxpYyBhbmQgc2VjcmV0IGtleXMpLlxuICpcbiAqIEBkZXByZWNhdGVkIHNpbmNlIHYxLjEwLjAsIHBsZWFzZSB1c2Uge0BsaW5rIEtleXBhaXJ9IGluc3RlYWQuXG4gKi9cbmNsYXNzIEFjY291bnQge1xuICAvKipcbiAgICogQ3JlYXRlIGEgbmV3IEFjY291bnQgb2JqZWN0XG4gICAqXG4gICAqIElmIHRoZSBzZWNyZXRLZXkgcGFyYW1ldGVyIGlzIG5vdCBwcm92aWRlZCBhIG5ldyBrZXkgcGFpciBpcyByYW5kb21seVxuICAgKiBjcmVhdGVkIGZvciB0aGUgYWNjb3VudFxuICAgKlxuICAgKiBAcGFyYW0gc2VjcmV0S2V5IFNlY3JldCBrZXkgZm9yIHRoZSBhY2NvdW50XG4gICAqL1xuICBjb25zdHJ1Y3RvcihzZWNyZXRLZXkpIHtcbiAgICAvKiogQGludGVybmFsICovXG4gICAgdGhpcy5fcHVibGljS2V5ID0gdm9pZCAwO1xuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICB0aGlzLl9zZWNyZXRLZXkgPSB2b2lkIDA7XG4gICAgaWYgKHNlY3JldEtleSkge1xuICAgICAgY29uc3Qgc2VjcmV0S2V5QnVmZmVyID0gdG9CdWZmZXIoc2VjcmV0S2V5KTtcbiAgICAgIGlmIChzZWNyZXRLZXkubGVuZ3RoICE9PSA2NCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2JhZCBzZWNyZXQga2V5IHNpemUnKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuX3B1YmxpY0tleSA9IHNlY3JldEtleUJ1ZmZlci5zbGljZSgzMiwgNjQpO1xuICAgICAgdGhpcy5fc2VjcmV0S2V5ID0gc2VjcmV0S2V5QnVmZmVyLnNsaWNlKDAsIDMyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fc2VjcmV0S2V5ID0gdG9CdWZmZXIoZ2VuZXJhdGVQcml2YXRlS2V5KCkpO1xuICAgICAgdGhpcy5fcHVibGljS2V5ID0gdG9CdWZmZXIoZ2V0UHVibGljS2V5KHRoaXMuX3NlY3JldEtleSkpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBUaGUgcHVibGljIGtleSBmb3IgdGhpcyBhY2NvdW50XG4gICAqL1xuICBnZXQgcHVibGljS2V5KCkge1xuICAgIHJldHVybiBuZXcgUHVibGljS2V5KHRoaXMuX3B1YmxpY0tleSk7XG4gIH1cblxuICAvKipcbiAgICogVGhlICoqdW5lbmNyeXB0ZWQqKiBzZWNyZXQga2V5IGZvciB0aGlzIGFjY291bnQuIFRoZSBmaXJzdCAzMiBieXRlc1xuICAgKiBpcyB0aGUgcHJpdmF0ZSBzY2FsYXIgYW5kIHRoZSBsYXN0IDMyIGJ5dGVzIGlzIHRoZSBwdWJsaWMga2V5LlxuICAgKiBSZWFkIG1vcmU6IGh0dHBzOi8vYmxvZy5tb3ppbGxhLm9yZy93YXJuZXIvMjAxMS8xMS8yOS9lZDI1NTE5LWtleXMvXG4gICAqL1xuICBnZXQgc2VjcmV0S2V5KCkge1xuICAgIHJldHVybiBCdWZmZXIuY29uY2F0KFt0aGlzLl9zZWNyZXRLZXksIHRoaXMuX3B1YmxpY0tleV0sIDY0KTtcbiAgfVxufVxuXG5jb25zdCBCUEZfTE9BREVSX0RFUFJFQ0FURURfUFJPR1JBTV9JRCA9IG5ldyBQdWJsaWNLZXkoJ0JQRkxvYWRlcjExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTEnKTtcblxuLyoqXG4gKiBNYXhpbXVtIG92ZXItdGhlLXdpcmUgc2l6ZSBvZiBhIFRyYW5zYWN0aW9uXG4gKlxuICogMTI4MCBpcyBJUHY2IG1pbmltdW0gTVRVXG4gKiA0MCBieXRlcyBpcyB0aGUgc2l6ZSBvZiB0aGUgSVB2NiBoZWFkZXJcbiAqIDggYnl0ZXMgaXMgdGhlIHNpemUgb2YgdGhlIGZyYWdtZW50IGhlYWRlclxuICovXG5jb25zdCBQQUNLRVRfREFUQV9TSVpFID0gMTI4MCAtIDQwIC0gODtcbmNvbnN0IFZFUlNJT05fUFJFRklYX01BU0sgPSAweDdmO1xuY29uc3QgU0lHTkFUVVJFX0xFTkdUSF9JTl9CWVRFUyA9IDY0O1xuXG5jbGFzcyBUcmFuc2FjdGlvbkV4cGlyZWRCbG9ja2hlaWdodEV4Y2VlZGVkRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gIGNvbnN0cnVjdG9yKHNpZ25hdHVyZSkge1xuICAgIHN1cGVyKGBTaWduYXR1cmUgJHtzaWduYXR1cmV9IGhhcyBleHBpcmVkOiBibG9jayBoZWlnaHQgZXhjZWVkZWQuYCk7XG4gICAgdGhpcy5zaWduYXR1cmUgPSB2b2lkIDA7XG4gICAgdGhpcy5zaWduYXR1cmUgPSBzaWduYXR1cmU7XG4gIH1cbn1cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShUcmFuc2FjdGlvbkV4cGlyZWRCbG9ja2hlaWdodEV4Y2VlZGVkRXJyb3IucHJvdG90eXBlLCAnbmFtZScsIHtcbiAgdmFsdWU6ICdUcmFuc2FjdGlvbkV4cGlyZWRCbG9ja2hlaWdodEV4Y2VlZGVkRXJyb3InXG59KTtcbmNsYXNzIFRyYW5zYWN0aW9uRXhwaXJlZFRpbWVvdXRFcnJvciBleHRlbmRzIEVycm9yIHtcbiAgY29uc3RydWN0b3Ioc2lnbmF0dXJlLCB0aW1lb3V0U2Vjb25kcykge1xuICAgIHN1cGVyKGBUcmFuc2FjdGlvbiB3YXMgbm90IGNvbmZpcm1lZCBpbiAke3RpbWVvdXRTZWNvbmRzLnRvRml4ZWQoMil9IHNlY29uZHMuIEl0IGlzIGAgKyAndW5rbm93biBpZiBpdCBzdWNjZWVkZWQgb3IgZmFpbGVkLiBDaGVjayBzaWduYXR1cmUgJyArIGAke3NpZ25hdHVyZX0gdXNpbmcgdGhlIFNvbGFuYSBFeHBsb3JlciBvciBDTEkgdG9vbHMuYCk7XG4gICAgdGhpcy5zaWduYXR1cmUgPSB2b2lkIDA7XG4gICAgdGhpcy5zaWduYXR1cmUgPSBzaWduYXR1cmU7XG4gIH1cbn1cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShUcmFuc2FjdGlvbkV4cGlyZWRUaW1lb3V0RXJyb3IucHJvdG90eXBlLCAnbmFtZScsIHtcbiAgdmFsdWU6ICdUcmFuc2FjdGlvbkV4cGlyZWRUaW1lb3V0RXJyb3InXG59KTtcbmNsYXNzIFRyYW5zYWN0aW9uRXhwaXJlZE5vbmNlSW52YWxpZEVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICBjb25zdHJ1Y3RvcihzaWduYXR1cmUpIHtcbiAgICBzdXBlcihgU2lnbmF0dXJlICR7c2lnbmF0dXJlfSBoYXMgZXhwaXJlZDogdGhlIG5vbmNlIGlzIG5vIGxvbmdlciB2YWxpZC5gKTtcbiAgICB0aGlzLnNpZ25hdHVyZSA9IHZvaWQgMDtcbiAgICB0aGlzLnNpZ25hdHVyZSA9IHNpZ25hdHVyZTtcbiAgfVxufVxuT2JqZWN0LmRlZmluZVByb3BlcnR5KFRyYW5zYWN0aW9uRXhwaXJlZE5vbmNlSW52YWxpZEVycm9yLnByb3RvdHlwZSwgJ25hbWUnLCB7XG4gIHZhbHVlOiAnVHJhbnNhY3Rpb25FeHBpcmVkTm9uY2VJbnZhbGlkRXJyb3InXG59KTtcblxuY2xhc3MgTWVzc2FnZUFjY291bnRLZXlzIHtcbiAgY29uc3RydWN0b3Ioc3RhdGljQWNjb3VudEtleXMsIGFjY291bnRLZXlzRnJvbUxvb2t1cHMpIHtcbiAgICB0aGlzLnN0YXRpY0FjY291bnRLZXlzID0gdm9pZCAwO1xuICAgIHRoaXMuYWNjb3VudEtleXNGcm9tTG9va3VwcyA9IHZvaWQgMDtcbiAgICB0aGlzLnN0YXRpY0FjY291bnRLZXlzID0gc3RhdGljQWNjb3VudEtleXM7XG4gICAgdGhpcy5hY2NvdW50S2V5c0Zyb21Mb29rdXBzID0gYWNjb3VudEtleXNGcm9tTG9va3VwcztcbiAgfVxuICBrZXlTZWdtZW50cygpIHtcbiAgICBjb25zdCBrZXlTZWdtZW50cyA9IFt0aGlzLnN0YXRpY0FjY291bnRLZXlzXTtcbiAgICBpZiAodGhpcy5hY2NvdW50S2V5c0Zyb21Mb29rdXBzKSB7XG4gICAgICBrZXlTZWdtZW50cy5wdXNoKHRoaXMuYWNjb3VudEtleXNGcm9tTG9va3Vwcy53cml0YWJsZSk7XG4gICAgICBrZXlTZWdtZW50cy5wdXNoKHRoaXMuYWNjb3VudEtleXNGcm9tTG9va3Vwcy5yZWFkb25seSk7XG4gICAgfVxuICAgIHJldHVybiBrZXlTZWdtZW50cztcbiAgfVxuICBnZXQoaW5kZXgpIHtcbiAgICBmb3IgKGNvbnN0IGtleVNlZ21lbnQgb2YgdGhpcy5rZXlTZWdtZW50cygpKSB7XG4gICAgICBpZiAoaW5kZXggPCBrZXlTZWdtZW50Lmxlbmd0aCkge1xuICAgICAgICByZXR1cm4ga2V5U2VnbWVudFtpbmRleF07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpbmRleCAtPSBrZXlTZWdtZW50Lmxlbmd0aDtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuO1xuICB9XG4gIGdldCBsZW5ndGgoKSB7XG4gICAgcmV0dXJuIHRoaXMua2V5U2VnbWVudHMoKS5mbGF0KCkubGVuZ3RoO1xuICB9XG4gIGNvbXBpbGVJbnN0cnVjdGlvbnMoaW5zdHJ1Y3Rpb25zKSB7XG4gICAgLy8gQmFpbCBlYXJseSBpZiBhbnkgYWNjb3VudCBpbmRleGVzIHdvdWxkIG92ZXJmbG93IGEgdThcbiAgICBjb25zdCBVOF9NQVggPSAyNTU7XG4gICAgaWYgKHRoaXMubGVuZ3RoID4gVThfTUFYICsgMSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdBY2NvdW50IGluZGV4IG92ZXJmbG93IGVuY291bnRlcmVkIGR1cmluZyBjb21waWxhdGlvbicpO1xuICAgIH1cbiAgICBjb25zdCBrZXlJbmRleE1hcCA9IG5ldyBNYXAoKTtcbiAgICB0aGlzLmtleVNlZ21lbnRzKCkuZmxhdCgpLmZvckVhY2goKGtleSwgaW5kZXgpID0+IHtcbiAgICAgIGtleUluZGV4TWFwLnNldChrZXkudG9CYXNlNTgoKSwgaW5kZXgpO1xuICAgIH0pO1xuICAgIGNvbnN0IGZpbmRLZXlJbmRleCA9IGtleSA9PiB7XG4gICAgICBjb25zdCBrZXlJbmRleCA9IGtleUluZGV4TWFwLmdldChrZXkudG9CYXNlNTgoKSk7XG4gICAgICBpZiAoa2V5SW5kZXggPT09IHVuZGVmaW5lZCkgdGhyb3cgbmV3IEVycm9yKCdFbmNvdW50ZXJlZCBhbiB1bmtub3duIGluc3RydWN0aW9uIGFjY291bnQga2V5IGR1cmluZyBjb21waWxhdGlvbicpO1xuICAgICAgcmV0dXJuIGtleUluZGV4O1xuICAgIH07XG4gICAgcmV0dXJuIGluc3RydWN0aW9ucy5tYXAoaW5zdHJ1Y3Rpb24gPT4ge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgcHJvZ3JhbUlkSW5kZXg6IGZpbmRLZXlJbmRleChpbnN0cnVjdGlvbi5wcm9ncmFtSWQpLFxuICAgICAgICBhY2NvdW50S2V5SW5kZXhlczogaW5zdHJ1Y3Rpb24ua2V5cy5tYXAobWV0YSA9PiBmaW5kS2V5SW5kZXgobWV0YS5wdWJrZXkpKSxcbiAgICAgICAgZGF0YTogaW5zdHJ1Y3Rpb24uZGF0YVxuICAgICAgfTtcbiAgICB9KTtcbiAgfVxufVxuXG4vKipcbiAqIExheW91dCBmb3IgYSBwdWJsaWMga2V5XG4gKi9cbmNvbnN0IHB1YmxpY0tleSA9IChwcm9wZXJ0eSA9ICdwdWJsaWNLZXknKSA9PiB7XG4gIHJldHVybiBCdWZmZXJMYXlvdXQuYmxvYigzMiwgcHJvcGVydHkpO1xufTtcblxuLyoqXG4gKiBMYXlvdXQgZm9yIGEgc2lnbmF0dXJlXG4gKi9cbmNvbnN0IHNpZ25hdHVyZSA9IChwcm9wZXJ0eSA9ICdzaWduYXR1cmUnKSA9PiB7XG4gIHJldHVybiBCdWZmZXJMYXlvdXQuYmxvYig2NCwgcHJvcGVydHkpO1xufTtcbi8qKlxuICogTGF5b3V0IGZvciBhIFJ1c3QgU3RyaW5nIHR5cGVcbiAqL1xuY29uc3QgcnVzdFN0cmluZyA9IChwcm9wZXJ0eSA9ICdzdHJpbmcnKSA9PiB7XG4gIGNvbnN0IHJzbCA9IEJ1ZmZlckxheW91dC5zdHJ1Y3QoW0J1ZmZlckxheW91dC51MzIoJ2xlbmd0aCcpLCBCdWZmZXJMYXlvdXQudTMyKCdsZW5ndGhQYWRkaW5nJyksIEJ1ZmZlckxheW91dC5ibG9iKEJ1ZmZlckxheW91dC5vZmZzZXQoQnVmZmVyTGF5b3V0LnUzMigpLCAtOCksICdjaGFycycpXSwgcHJvcGVydHkpO1xuICBjb25zdCBfZGVjb2RlID0gcnNsLmRlY29kZS5iaW5kKHJzbCk7XG4gIGNvbnN0IF9lbmNvZGUgPSByc2wuZW5jb2RlLmJpbmQocnNsKTtcbiAgY29uc3QgcnNsU2hpbSA9IHJzbDtcbiAgcnNsU2hpbS5kZWNvZGUgPSAoYiwgb2Zmc2V0KSA9PiB7XG4gICAgY29uc3QgZGF0YSA9IF9kZWNvZGUoYiwgb2Zmc2V0KTtcbiAgICByZXR1cm4gZGF0YVsnY2hhcnMnXS50b1N0cmluZygpO1xuICB9O1xuICByc2xTaGltLmVuY29kZSA9IChzdHIsIGIsIG9mZnNldCkgPT4ge1xuICAgIGNvbnN0IGRhdGEgPSB7XG4gICAgICBjaGFyczogQnVmZmVyLmZyb20oc3RyLCAndXRmOCcpXG4gICAgfTtcbiAgICByZXR1cm4gX2VuY29kZShkYXRhLCBiLCBvZmZzZXQpO1xuICB9O1xuICByc2xTaGltLmFsbG9jID0gc3RyID0+IHtcbiAgICByZXR1cm4gQnVmZmVyTGF5b3V0LnUzMigpLnNwYW4gKyBCdWZmZXJMYXlvdXQudTMyKCkuc3BhbiArIEJ1ZmZlci5mcm9tKHN0ciwgJ3V0ZjgnKS5sZW5ndGg7XG4gIH07XG4gIHJldHVybiByc2xTaGltO1xufTtcblxuLyoqXG4gKiBMYXlvdXQgZm9yIGFuIEF1dGhvcml6ZWQgb2JqZWN0XG4gKi9cbmNvbnN0IGF1dGhvcml6ZWQgPSAocHJvcGVydHkgPSAnYXV0aG9yaXplZCcpID0+IHtcbiAgcmV0dXJuIEJ1ZmZlckxheW91dC5zdHJ1Y3QoW3B1YmxpY0tleSgnc3Rha2VyJyksIHB1YmxpY0tleSgnd2l0aGRyYXdlcicpXSwgcHJvcGVydHkpO1xufTtcblxuLyoqXG4gKiBMYXlvdXQgZm9yIGEgTG9ja3VwIG9iamVjdFxuICovXG5jb25zdCBsb2NrdXAgPSAocHJvcGVydHkgPSAnbG9ja3VwJykgPT4ge1xuICByZXR1cm4gQnVmZmVyTGF5b3V0LnN0cnVjdChbQnVmZmVyTGF5b3V0Lm5zNjQoJ3VuaXhUaW1lc3RhbXAnKSwgQnVmZmVyTGF5b3V0Lm5zNjQoJ2Vwb2NoJyksIHB1YmxpY0tleSgnY3VzdG9kaWFuJyldLCBwcm9wZXJ0eSk7XG59O1xuXG4vKipcbiAqICBMYXlvdXQgZm9yIGEgVm90ZUluaXQgb2JqZWN0XG4gKi9cbmNvbnN0IHZvdGVJbml0ID0gKHByb3BlcnR5ID0gJ3ZvdGVJbml0JykgPT4ge1xuICByZXR1cm4gQnVmZmVyTGF5b3V0LnN0cnVjdChbcHVibGljS2V5KCdub2RlUHVia2V5JyksIHB1YmxpY0tleSgnYXV0aG9yaXplZFZvdGVyJyksIHB1YmxpY0tleSgnYXV0aG9yaXplZFdpdGhkcmF3ZXInKSwgQnVmZmVyTGF5b3V0LnU4KCdjb21taXNzaW9uJyldLCBwcm9wZXJ0eSk7XG59O1xuXG4vKipcbiAqICBMYXlvdXQgZm9yIGEgVm90ZUF1dGhvcml6ZVdpdGhTZWVkQXJncyBvYmplY3RcbiAqL1xuY29uc3Qgdm90ZUF1dGhvcml6ZVdpdGhTZWVkQXJncyA9IChwcm9wZXJ0eSA9ICd2b3RlQXV0aG9yaXplV2l0aFNlZWRBcmdzJykgPT4ge1xuICByZXR1cm4gQnVmZmVyTGF5b3V0LnN0cnVjdChbQnVmZmVyTGF5b3V0LnUzMigndm90ZUF1dGhvcml6YXRpb25UeXBlJyksIHB1YmxpY0tleSgnY3VycmVudEF1dGhvcml0eURlcml2ZWRLZXlPd25lclB1YmtleScpLCBydXN0U3RyaW5nKCdjdXJyZW50QXV0aG9yaXR5RGVyaXZlZEtleVNlZWQnKSwgcHVibGljS2V5KCduZXdBdXRob3JpemVkJyldLCBwcm9wZXJ0eSk7XG59O1xuZnVuY3Rpb24gZ2V0QWxsb2ModHlwZSwgZmllbGRzKSB7XG4gIGNvbnN0IGdldEl0ZW1BbGxvYyA9IGl0ZW0gPT4ge1xuICAgIGlmIChpdGVtLnNwYW4gPj0gMCkge1xuICAgICAgcmV0dXJuIGl0ZW0uc3BhbjtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBpdGVtLmFsbG9jID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICByZXR1cm4gaXRlbS5hbGxvYyhmaWVsZHNbaXRlbS5wcm9wZXJ0eV0pO1xuICAgIH0gZWxzZSBpZiAoJ2NvdW50JyBpbiBpdGVtICYmICdlbGVtZW50TGF5b3V0JyBpbiBpdGVtKSB7XG4gICAgICBjb25zdCBmaWVsZCA9IGZpZWxkc1tpdGVtLnByb3BlcnR5XTtcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KGZpZWxkKSkge1xuICAgICAgICByZXR1cm4gZmllbGQubGVuZ3RoICogZ2V0SXRlbUFsbG9jKGl0ZW0uZWxlbWVudExheW91dCk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICgnZmllbGRzJyBpbiBpdGVtKSB7XG4gICAgICAvLyBUaGlzIGlzIGEgYFN0cnVjdHVyZWAgd2hvc2Ugc2l6ZSBuZWVkcyB0byBiZSByZWN1cnNpdmVseSBtZWFzdXJlZC5cbiAgICAgIHJldHVybiBnZXRBbGxvYyh7XG4gICAgICAgIGxheW91dDogaXRlbVxuICAgICAgfSwgZmllbGRzW2l0ZW0ucHJvcGVydHldKTtcbiAgICB9XG4gICAgLy8gQ291bGRuJ3QgZGV0ZXJtaW5lIGFsbG9jYXRlZCBzaXplIG9mIGxheW91dFxuICAgIHJldHVybiAwO1xuICB9O1xuICBsZXQgYWxsb2MgPSAwO1xuICB0eXBlLmxheW91dC5maWVsZHMuZm9yRWFjaChpdGVtID0+IHtcbiAgICBhbGxvYyArPSBnZXRJdGVtQWxsb2MoaXRlbSk7XG4gIH0pO1xuICByZXR1cm4gYWxsb2M7XG59XG5cbmZ1bmN0aW9uIGRlY29kZUxlbmd0aChieXRlcykge1xuICBsZXQgbGVuID0gMDtcbiAgbGV0IHNpemUgPSAwO1xuICBmb3IgKDs7KSB7XG4gICAgbGV0IGVsZW0gPSBieXRlcy5zaGlmdCgpO1xuICAgIGxlbiB8PSAoZWxlbSAmIDB4N2YpIDw8IHNpemUgKiA3O1xuICAgIHNpemUgKz0gMTtcbiAgICBpZiAoKGVsZW0gJiAweDgwKSA9PT0gMCkge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIHJldHVybiBsZW47XG59XG5mdW5jdGlvbiBlbmNvZGVMZW5ndGgoYnl0ZXMsIGxlbikge1xuICBsZXQgcmVtX2xlbiA9IGxlbjtcbiAgZm9yICg7Oykge1xuICAgIGxldCBlbGVtID0gcmVtX2xlbiAmIDB4N2Y7XG4gICAgcmVtX2xlbiA+Pj0gNztcbiAgICBpZiAocmVtX2xlbiA9PSAwKSB7XG4gICAgICBieXRlcy5wdXNoKGVsZW0pO1xuICAgICAgYnJlYWs7XG4gICAgfSBlbHNlIHtcbiAgICAgIGVsZW0gfD0gMHg4MDtcbiAgICAgIGJ5dGVzLnB1c2goZWxlbSk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGFzc2VydCAoY29uZGl0aW9uLCBtZXNzYWdlKSB7XG4gIGlmICghY29uZGl0aW9uKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKG1lc3NhZ2UgfHwgJ0Fzc2VydGlvbiBmYWlsZWQnKTtcbiAgfVxufVxuXG5jbGFzcyBDb21waWxlZEtleXMge1xuICBjb25zdHJ1Y3RvcihwYXllciwga2V5TWV0YU1hcCkge1xuICAgIHRoaXMucGF5ZXIgPSB2b2lkIDA7XG4gICAgdGhpcy5rZXlNZXRhTWFwID0gdm9pZCAwO1xuICAgIHRoaXMucGF5ZXIgPSBwYXllcjtcbiAgICB0aGlzLmtleU1ldGFNYXAgPSBrZXlNZXRhTWFwO1xuICB9XG4gIHN0YXRpYyBjb21waWxlKGluc3RydWN0aW9ucywgcGF5ZXIpIHtcbiAgICBjb25zdCBrZXlNZXRhTWFwID0gbmV3IE1hcCgpO1xuICAgIGNvbnN0IGdldE9ySW5zZXJ0RGVmYXVsdCA9IHB1YmtleSA9PiB7XG4gICAgICBjb25zdCBhZGRyZXNzID0gcHVia2V5LnRvQmFzZTU4KCk7XG4gICAgICBsZXQga2V5TWV0YSA9IGtleU1ldGFNYXAuZ2V0KGFkZHJlc3MpO1xuICAgICAgaWYgKGtleU1ldGEgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBrZXlNZXRhID0ge1xuICAgICAgICAgIGlzU2lnbmVyOiBmYWxzZSxcbiAgICAgICAgICBpc1dyaXRhYmxlOiBmYWxzZSxcbiAgICAgICAgICBpc0ludm9rZWQ6IGZhbHNlXG4gICAgICAgIH07XG4gICAgICAgIGtleU1ldGFNYXAuc2V0KGFkZHJlc3MsIGtleU1ldGEpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGtleU1ldGE7XG4gICAgfTtcbiAgICBjb25zdCBwYXllcktleU1ldGEgPSBnZXRPckluc2VydERlZmF1bHQocGF5ZXIpO1xuICAgIHBheWVyS2V5TWV0YS5pc1NpZ25lciA9IHRydWU7XG4gICAgcGF5ZXJLZXlNZXRhLmlzV3JpdGFibGUgPSB0cnVlO1xuICAgIGZvciAoY29uc3QgaXggb2YgaW5zdHJ1Y3Rpb25zKSB7XG4gICAgICBnZXRPckluc2VydERlZmF1bHQoaXgucHJvZ3JhbUlkKS5pc0ludm9rZWQgPSB0cnVlO1xuICAgICAgZm9yIChjb25zdCBhY2NvdW50TWV0YSBvZiBpeC5rZXlzKSB7XG4gICAgICAgIGNvbnN0IGtleU1ldGEgPSBnZXRPckluc2VydERlZmF1bHQoYWNjb3VudE1ldGEucHVia2V5KTtcbiAgICAgICAga2V5TWV0YS5pc1NpZ25lciB8fD0gYWNjb3VudE1ldGEuaXNTaWduZXI7XG4gICAgICAgIGtleU1ldGEuaXNXcml0YWJsZSB8fD0gYWNjb3VudE1ldGEuaXNXcml0YWJsZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG5ldyBDb21waWxlZEtleXMocGF5ZXIsIGtleU1ldGFNYXApO1xuICB9XG4gIGdldE1lc3NhZ2VDb21wb25lbnRzKCkge1xuICAgIGNvbnN0IG1hcEVudHJpZXMgPSBbLi4udGhpcy5rZXlNZXRhTWFwLmVudHJpZXMoKV07XG4gICAgYXNzZXJ0KG1hcEVudHJpZXMubGVuZ3RoIDw9IDI1NiwgJ01heCBzdGF0aWMgYWNjb3VudCBrZXlzIGxlbmd0aCBleGNlZWRlZCcpO1xuICAgIGNvbnN0IHdyaXRhYmxlU2lnbmVycyA9IG1hcEVudHJpZXMuZmlsdGVyKChbLCBtZXRhXSkgPT4gbWV0YS5pc1NpZ25lciAmJiBtZXRhLmlzV3JpdGFibGUpO1xuICAgIGNvbnN0IHJlYWRvbmx5U2lnbmVycyA9IG1hcEVudHJpZXMuZmlsdGVyKChbLCBtZXRhXSkgPT4gbWV0YS5pc1NpZ25lciAmJiAhbWV0YS5pc1dyaXRhYmxlKTtcbiAgICBjb25zdCB3cml0YWJsZU5vblNpZ25lcnMgPSBtYXBFbnRyaWVzLmZpbHRlcigoWywgbWV0YV0pID0+ICFtZXRhLmlzU2lnbmVyICYmIG1ldGEuaXNXcml0YWJsZSk7XG4gICAgY29uc3QgcmVhZG9ubHlOb25TaWduZXJzID0gbWFwRW50cmllcy5maWx0ZXIoKFssIG1ldGFdKSA9PiAhbWV0YS5pc1NpZ25lciAmJiAhbWV0YS5pc1dyaXRhYmxlKTtcbiAgICBjb25zdCBoZWFkZXIgPSB7XG4gICAgICBudW1SZXF1aXJlZFNpZ25hdHVyZXM6IHdyaXRhYmxlU2lnbmVycy5sZW5ndGggKyByZWFkb25seVNpZ25lcnMubGVuZ3RoLFxuICAgICAgbnVtUmVhZG9ubHlTaWduZWRBY2NvdW50czogcmVhZG9ubHlTaWduZXJzLmxlbmd0aCxcbiAgICAgIG51bVJlYWRvbmx5VW5zaWduZWRBY2NvdW50czogcmVhZG9ubHlOb25TaWduZXJzLmxlbmd0aFxuICAgIH07XG5cbiAgICAvLyBzYW5pdHkgY2hlY2tzXG4gICAge1xuICAgICAgYXNzZXJ0KHdyaXRhYmxlU2lnbmVycy5sZW5ndGggPiAwLCAnRXhwZWN0ZWQgYXQgbGVhc3Qgb25lIHdyaXRhYmxlIHNpZ25lciBrZXknKTtcbiAgICAgIGNvbnN0IFtwYXllckFkZHJlc3NdID0gd3JpdGFibGVTaWduZXJzWzBdO1xuICAgICAgYXNzZXJ0KHBheWVyQWRkcmVzcyA9PT0gdGhpcy5wYXllci50b0Jhc2U1OCgpLCAnRXhwZWN0ZWQgZmlyc3Qgd3JpdGFibGUgc2lnbmVyIGtleSB0byBiZSB0aGUgZmVlIHBheWVyJyk7XG4gICAgfVxuICAgIGNvbnN0IHN0YXRpY0FjY291bnRLZXlzID0gWy4uLndyaXRhYmxlU2lnbmVycy5tYXAoKFthZGRyZXNzXSkgPT4gbmV3IFB1YmxpY0tleShhZGRyZXNzKSksIC4uLnJlYWRvbmx5U2lnbmVycy5tYXAoKFthZGRyZXNzXSkgPT4gbmV3IFB1YmxpY0tleShhZGRyZXNzKSksIC4uLndyaXRhYmxlTm9uU2lnbmVycy5tYXAoKFthZGRyZXNzXSkgPT4gbmV3IFB1YmxpY0tleShhZGRyZXNzKSksIC4uLnJlYWRvbmx5Tm9uU2lnbmVycy5tYXAoKFthZGRyZXNzXSkgPT4gbmV3IFB1YmxpY0tleShhZGRyZXNzKSldO1xuICAgIHJldHVybiBbaGVhZGVyLCBzdGF0aWNBY2NvdW50S2V5c107XG4gIH1cbiAgZXh0cmFjdFRhYmxlTG9va3VwKGxvb2t1cFRhYmxlKSB7XG4gICAgY29uc3QgW3dyaXRhYmxlSW5kZXhlcywgZHJhaW5lZFdyaXRhYmxlS2V5c10gPSB0aGlzLmRyYWluS2V5c0ZvdW5kSW5Mb29rdXBUYWJsZShsb29rdXBUYWJsZS5zdGF0ZS5hZGRyZXNzZXMsIGtleU1ldGEgPT4gIWtleU1ldGEuaXNTaWduZXIgJiYgIWtleU1ldGEuaXNJbnZva2VkICYmIGtleU1ldGEuaXNXcml0YWJsZSk7XG4gICAgY29uc3QgW3JlYWRvbmx5SW5kZXhlcywgZHJhaW5lZFJlYWRvbmx5S2V5c10gPSB0aGlzLmRyYWluS2V5c0ZvdW5kSW5Mb29rdXBUYWJsZShsb29rdXBUYWJsZS5zdGF0ZS5hZGRyZXNzZXMsIGtleU1ldGEgPT4gIWtleU1ldGEuaXNTaWduZXIgJiYgIWtleU1ldGEuaXNJbnZva2VkICYmICFrZXlNZXRhLmlzV3JpdGFibGUpO1xuXG4gICAgLy8gRG9uJ3QgZXh0cmFjdCBsb29rdXAgaWYgbm8ga2V5cyB3ZXJlIGZvdW5kXG4gICAgaWYgKHdyaXRhYmxlSW5kZXhlcy5sZW5ndGggPT09IDAgJiYgcmVhZG9ubHlJbmRleGVzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICByZXR1cm4gW3tcbiAgICAgIGFjY291bnRLZXk6IGxvb2t1cFRhYmxlLmtleSxcbiAgICAgIHdyaXRhYmxlSW5kZXhlcyxcbiAgICAgIHJlYWRvbmx5SW5kZXhlc1xuICAgIH0sIHtcbiAgICAgIHdyaXRhYmxlOiBkcmFpbmVkV3JpdGFibGVLZXlzLFxuICAgICAgcmVhZG9ubHk6IGRyYWluZWRSZWFkb25seUtleXNcbiAgICB9XTtcbiAgfVxuXG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgZHJhaW5LZXlzRm91bmRJbkxvb2t1cFRhYmxlKGxvb2t1cFRhYmxlRW50cmllcywga2V5TWV0YUZpbHRlcikge1xuICAgIGNvbnN0IGxvb2t1cFRhYmxlSW5kZXhlcyA9IG5ldyBBcnJheSgpO1xuICAgIGNvbnN0IGRyYWluZWRLZXlzID0gbmV3IEFycmF5KCk7XG4gICAgZm9yIChjb25zdCBbYWRkcmVzcywga2V5TWV0YV0gb2YgdGhpcy5rZXlNZXRhTWFwLmVudHJpZXMoKSkge1xuICAgICAgaWYgKGtleU1ldGFGaWx0ZXIoa2V5TWV0YSkpIHtcbiAgICAgICAgY29uc3Qga2V5ID0gbmV3IFB1YmxpY0tleShhZGRyZXNzKTtcbiAgICAgICAgY29uc3QgbG9va3VwVGFibGVJbmRleCA9IGxvb2t1cFRhYmxlRW50cmllcy5maW5kSW5kZXgoZW50cnkgPT4gZW50cnkuZXF1YWxzKGtleSkpO1xuICAgICAgICBpZiAobG9va3VwVGFibGVJbmRleCA+PSAwKSB7XG4gICAgICAgICAgYXNzZXJ0KGxvb2t1cFRhYmxlSW5kZXggPCAyNTYsICdNYXggbG9va3VwIHRhYmxlIGluZGV4IGV4Y2VlZGVkJyk7XG4gICAgICAgICAgbG9va3VwVGFibGVJbmRleGVzLnB1c2gobG9va3VwVGFibGVJbmRleCk7XG4gICAgICAgICAgZHJhaW5lZEtleXMucHVzaChrZXkpO1xuICAgICAgICAgIHRoaXMua2V5TWV0YU1hcC5kZWxldGUoYWRkcmVzcyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIFtsb29rdXBUYWJsZUluZGV4ZXMsIGRyYWluZWRLZXlzXTtcbiAgfVxufVxuXG5jb25zdCBFTkRfT0ZfQlVGRkVSX0VSUk9SX01FU1NBR0UgPSAnUmVhY2hlZCBlbmQgb2YgYnVmZmVyIHVuZXhwZWN0ZWRseSc7XG5cbi8qKlxuICogRGVsZWdhdGVzIHRvIGBBcnJheSNzaGlmdGAsIGJ1dCB0aHJvd3MgaWYgdGhlIGFycmF5IGlzIHplcm8tbGVuZ3RoLlxuICovXG5mdW5jdGlvbiBndWFyZGVkU2hpZnQoYnl0ZUFycmF5KSB7XG4gIGlmIChieXRlQXJyYXkubGVuZ3RoID09PSAwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKEVORF9PRl9CVUZGRVJfRVJST1JfTUVTU0FHRSk7XG4gIH1cbiAgcmV0dXJuIGJ5dGVBcnJheS5zaGlmdCgpO1xufVxuXG4vKipcbiAqIERlbGVnYXRlcyB0byBgQXJyYXkjc3BsaWNlYCwgYnV0IHRocm93cyBpZiB0aGUgc2VjdGlvbiBiZWluZyBzcGxpY2VkIG91dCBleHRlbmRzIHBhc3QgdGhlIGVuZCBvZlxuICogdGhlIGFycmF5LlxuICovXG5mdW5jdGlvbiBndWFyZGVkU3BsaWNlKGJ5dGVBcnJheSwgLi4uYXJncykge1xuICBjb25zdCBbc3RhcnRdID0gYXJncztcbiAgaWYgKGFyZ3MubGVuZ3RoID09PSAyIC8vIEltcGxpZXMgdGhhdCBgZGVsZXRlQ291bnRgIHdhcyBzdXBwbGllZFxuICA/IHN0YXJ0ICsgKGFyZ3NbMV0gPz8gMCkgPiBieXRlQXJyYXkubGVuZ3RoIDogc3RhcnQgPj0gYnl0ZUFycmF5Lmxlbmd0aCkge1xuICAgIHRocm93IG5ldyBFcnJvcihFTkRfT0ZfQlVGRkVSX0VSUk9SX01FU1NBR0UpO1xuICB9XG4gIHJldHVybiBieXRlQXJyYXkuc3BsaWNlKC4uLmFyZ3MpO1xufVxuXG4vKipcbiAqIEFuIGluc3RydWN0aW9uIHRvIGV4ZWN1dGUgYnkgYSBwcm9ncmFtXG4gKlxuICogQHByb3BlcnR5IHtudW1iZXJ9IHByb2dyYW1JZEluZGV4XG4gKiBAcHJvcGVydHkge251bWJlcltdfSBhY2NvdW50c1xuICogQHByb3BlcnR5IHtzdHJpbmd9IGRhdGFcbiAqL1xuXG4vKipcbiAqIE1lc3NhZ2UgY29uc3RydWN0b3IgYXJndW1lbnRzXG4gKi9cblxuLyoqXG4gKiBMaXN0IG9mIGluc3RydWN0aW9ucyB0byBiZSBwcm9jZXNzZWQgYXRvbWljYWxseVxuICovXG5jbGFzcyBNZXNzYWdlIHtcbiAgY29uc3RydWN0b3IoYXJncykge1xuICAgIHRoaXMuaGVhZGVyID0gdm9pZCAwO1xuICAgIHRoaXMuYWNjb3VudEtleXMgPSB2b2lkIDA7XG4gICAgdGhpcy5yZWNlbnRCbG9ja2hhc2ggPSB2b2lkIDA7XG4gICAgdGhpcy5pbnN0cnVjdGlvbnMgPSB2b2lkIDA7XG4gICAgdGhpcy5pbmRleFRvUHJvZ3JhbUlkcyA9IG5ldyBNYXAoKTtcbiAgICB0aGlzLmhlYWRlciA9IGFyZ3MuaGVhZGVyO1xuICAgIHRoaXMuYWNjb3VudEtleXMgPSBhcmdzLmFjY291bnRLZXlzLm1hcChhY2NvdW50ID0+IG5ldyBQdWJsaWNLZXkoYWNjb3VudCkpO1xuICAgIHRoaXMucmVjZW50QmxvY2toYXNoID0gYXJncy5yZWNlbnRCbG9ja2hhc2g7XG4gICAgdGhpcy5pbnN0cnVjdGlvbnMgPSBhcmdzLmluc3RydWN0aW9ucztcbiAgICB0aGlzLmluc3RydWN0aW9ucy5mb3JFYWNoKGl4ID0+IHRoaXMuaW5kZXhUb1Byb2dyYW1JZHMuc2V0KGl4LnByb2dyYW1JZEluZGV4LCB0aGlzLmFjY291bnRLZXlzW2l4LnByb2dyYW1JZEluZGV4XSkpO1xuICB9XG4gIGdldCB2ZXJzaW9uKCkge1xuICAgIHJldHVybiAnbGVnYWN5JztcbiAgfVxuICBnZXQgc3RhdGljQWNjb3VudEtleXMoKSB7XG4gICAgcmV0dXJuIHRoaXMuYWNjb3VudEtleXM7XG4gIH1cbiAgZ2V0IGNvbXBpbGVkSW5zdHJ1Y3Rpb25zKCkge1xuICAgIHJldHVybiB0aGlzLmluc3RydWN0aW9ucy5tYXAoaXggPT4gKHtcbiAgICAgIHByb2dyYW1JZEluZGV4OiBpeC5wcm9ncmFtSWRJbmRleCxcbiAgICAgIGFjY291bnRLZXlJbmRleGVzOiBpeC5hY2NvdW50cyxcbiAgICAgIGRhdGE6IGJzNTguZGVjb2RlKGl4LmRhdGEpXG4gICAgfSkpO1xuICB9XG4gIGdldCBhZGRyZXNzVGFibGVMb29rdXBzKCkge1xuICAgIHJldHVybiBbXTtcbiAgfVxuICBnZXRBY2NvdW50S2V5cygpIHtcbiAgICByZXR1cm4gbmV3IE1lc3NhZ2VBY2NvdW50S2V5cyh0aGlzLnN0YXRpY0FjY291bnRLZXlzKTtcbiAgfVxuICBzdGF0aWMgY29tcGlsZShhcmdzKSB7XG4gICAgY29uc3QgY29tcGlsZWRLZXlzID0gQ29tcGlsZWRLZXlzLmNvbXBpbGUoYXJncy5pbnN0cnVjdGlvbnMsIGFyZ3MucGF5ZXJLZXkpO1xuICAgIGNvbnN0IFtoZWFkZXIsIHN0YXRpY0FjY291bnRLZXlzXSA9IGNvbXBpbGVkS2V5cy5nZXRNZXNzYWdlQ29tcG9uZW50cygpO1xuICAgIGNvbnN0IGFjY291bnRLZXlzID0gbmV3IE1lc3NhZ2VBY2NvdW50S2V5cyhzdGF0aWNBY2NvdW50S2V5cyk7XG4gICAgY29uc3QgaW5zdHJ1Y3Rpb25zID0gYWNjb3VudEtleXMuY29tcGlsZUluc3RydWN0aW9ucyhhcmdzLmluc3RydWN0aW9ucykubWFwKGl4ID0+ICh7XG4gICAgICBwcm9ncmFtSWRJbmRleDogaXgucHJvZ3JhbUlkSW5kZXgsXG4gICAgICBhY2NvdW50czogaXguYWNjb3VudEtleUluZGV4ZXMsXG4gICAgICBkYXRhOiBiczU4LmVuY29kZShpeC5kYXRhKVxuICAgIH0pKTtcbiAgICByZXR1cm4gbmV3IE1lc3NhZ2Uoe1xuICAgICAgaGVhZGVyLFxuICAgICAgYWNjb3VudEtleXM6IHN0YXRpY0FjY291bnRLZXlzLFxuICAgICAgcmVjZW50QmxvY2toYXNoOiBhcmdzLnJlY2VudEJsb2NraGFzaCxcbiAgICAgIGluc3RydWN0aW9uc1xuICAgIH0pO1xuICB9XG4gIGlzQWNjb3VudFNpZ25lcihpbmRleCkge1xuICAgIHJldHVybiBpbmRleCA8IHRoaXMuaGVhZGVyLm51bVJlcXVpcmVkU2lnbmF0dXJlcztcbiAgfVxuICBpc0FjY291bnRXcml0YWJsZShpbmRleCkge1xuICAgIGNvbnN0IG51bVNpZ25lZEFjY291bnRzID0gdGhpcy5oZWFkZXIubnVtUmVxdWlyZWRTaWduYXR1cmVzO1xuICAgIGlmIChpbmRleCA+PSB0aGlzLmhlYWRlci5udW1SZXF1aXJlZFNpZ25hdHVyZXMpIHtcbiAgICAgIGNvbnN0IHVuc2lnbmVkQWNjb3VudEluZGV4ID0gaW5kZXggLSBudW1TaWduZWRBY2NvdW50cztcbiAgICAgIGNvbnN0IG51bVVuc2lnbmVkQWNjb3VudHMgPSB0aGlzLmFjY291bnRLZXlzLmxlbmd0aCAtIG51bVNpZ25lZEFjY291bnRzO1xuICAgICAgY29uc3QgbnVtV3JpdGFibGVVbnNpZ25lZEFjY291bnRzID0gbnVtVW5zaWduZWRBY2NvdW50cyAtIHRoaXMuaGVhZGVyLm51bVJlYWRvbmx5VW5zaWduZWRBY2NvdW50cztcbiAgICAgIHJldHVybiB1bnNpZ25lZEFjY291bnRJbmRleCA8IG51bVdyaXRhYmxlVW5zaWduZWRBY2NvdW50cztcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgbnVtV3JpdGFibGVTaWduZWRBY2NvdW50cyA9IG51bVNpZ25lZEFjY291bnRzIC0gdGhpcy5oZWFkZXIubnVtUmVhZG9ubHlTaWduZWRBY2NvdW50cztcbiAgICAgIHJldHVybiBpbmRleCA8IG51bVdyaXRhYmxlU2lnbmVkQWNjb3VudHM7XG4gICAgfVxuICB9XG4gIGlzUHJvZ3JhbUlkKGluZGV4KSB7XG4gICAgcmV0dXJuIHRoaXMuaW5kZXhUb1Byb2dyYW1JZHMuaGFzKGluZGV4KTtcbiAgfVxuICBwcm9ncmFtSWRzKCkge1xuICAgIHJldHVybiBbLi4udGhpcy5pbmRleFRvUHJvZ3JhbUlkcy52YWx1ZXMoKV07XG4gIH1cbiAgbm9uUHJvZ3JhbUlkcygpIHtcbiAgICByZXR1cm4gdGhpcy5hY2NvdW50S2V5cy5maWx0ZXIoKF8sIGluZGV4KSA9PiAhdGhpcy5pc1Byb2dyYW1JZChpbmRleCkpO1xuICB9XG4gIHNlcmlhbGl6ZSgpIHtcbiAgICBjb25zdCBudW1LZXlzID0gdGhpcy5hY2NvdW50S2V5cy5sZW5ndGg7XG4gICAgbGV0IGtleUNvdW50ID0gW107XG4gICAgZW5jb2RlTGVuZ3RoKGtleUNvdW50LCBudW1LZXlzKTtcbiAgICBjb25zdCBpbnN0cnVjdGlvbnMgPSB0aGlzLmluc3RydWN0aW9ucy5tYXAoaW5zdHJ1Y3Rpb24gPT4ge1xuICAgICAgY29uc3Qge1xuICAgICAgICBhY2NvdW50cyxcbiAgICAgICAgcHJvZ3JhbUlkSW5kZXhcbiAgICAgIH0gPSBpbnN0cnVjdGlvbjtcbiAgICAgIGNvbnN0IGRhdGEgPSBBcnJheS5mcm9tKGJzNTguZGVjb2RlKGluc3RydWN0aW9uLmRhdGEpKTtcbiAgICAgIGxldCBrZXlJbmRpY2VzQ291bnQgPSBbXTtcbiAgICAgIGVuY29kZUxlbmd0aChrZXlJbmRpY2VzQ291bnQsIGFjY291bnRzLmxlbmd0aCk7XG4gICAgICBsZXQgZGF0YUNvdW50ID0gW107XG4gICAgICBlbmNvZGVMZW5ndGgoZGF0YUNvdW50LCBkYXRhLmxlbmd0aCk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBwcm9ncmFtSWRJbmRleCxcbiAgICAgICAga2V5SW5kaWNlc0NvdW50OiBCdWZmZXIuZnJvbShrZXlJbmRpY2VzQ291bnQpLFxuICAgICAgICBrZXlJbmRpY2VzOiBhY2NvdW50cyxcbiAgICAgICAgZGF0YUxlbmd0aDogQnVmZmVyLmZyb20oZGF0YUNvdW50KSxcbiAgICAgICAgZGF0YVxuICAgICAgfTtcbiAgICB9KTtcbiAgICBsZXQgaW5zdHJ1Y3Rpb25Db3VudCA9IFtdO1xuICAgIGVuY29kZUxlbmd0aChpbnN0cnVjdGlvbkNvdW50LCBpbnN0cnVjdGlvbnMubGVuZ3RoKTtcbiAgICBsZXQgaW5zdHJ1Y3Rpb25CdWZmZXIgPSBCdWZmZXIuYWxsb2MoUEFDS0VUX0RBVEFfU0laRSk7XG4gICAgQnVmZmVyLmZyb20oaW5zdHJ1Y3Rpb25Db3VudCkuY29weShpbnN0cnVjdGlvbkJ1ZmZlcik7XG4gICAgbGV0IGluc3RydWN0aW9uQnVmZmVyTGVuZ3RoID0gaW5zdHJ1Y3Rpb25Db3VudC5sZW5ndGg7XG4gICAgaW5zdHJ1Y3Rpb25zLmZvckVhY2goaW5zdHJ1Y3Rpb24gPT4ge1xuICAgICAgY29uc3QgaW5zdHJ1Y3Rpb25MYXlvdXQgPSBCdWZmZXJMYXlvdXQuc3RydWN0KFtCdWZmZXJMYXlvdXQudTgoJ3Byb2dyYW1JZEluZGV4JyksIEJ1ZmZlckxheW91dC5ibG9iKGluc3RydWN0aW9uLmtleUluZGljZXNDb3VudC5sZW5ndGgsICdrZXlJbmRpY2VzQ291bnQnKSwgQnVmZmVyTGF5b3V0LnNlcShCdWZmZXJMYXlvdXQudTgoJ2tleUluZGV4JyksIGluc3RydWN0aW9uLmtleUluZGljZXMubGVuZ3RoLCAna2V5SW5kaWNlcycpLCBCdWZmZXJMYXlvdXQuYmxvYihpbnN0cnVjdGlvbi5kYXRhTGVuZ3RoLmxlbmd0aCwgJ2RhdGFMZW5ndGgnKSwgQnVmZmVyTGF5b3V0LnNlcShCdWZmZXJMYXlvdXQudTgoJ3VzZXJkYXR1bScpLCBpbnN0cnVjdGlvbi5kYXRhLmxlbmd0aCwgJ2RhdGEnKV0pO1xuICAgICAgY29uc3QgbGVuZ3RoID0gaW5zdHJ1Y3Rpb25MYXlvdXQuZW5jb2RlKGluc3RydWN0aW9uLCBpbnN0cnVjdGlvbkJ1ZmZlciwgaW5zdHJ1Y3Rpb25CdWZmZXJMZW5ndGgpO1xuICAgICAgaW5zdHJ1Y3Rpb25CdWZmZXJMZW5ndGggKz0gbGVuZ3RoO1xuICAgIH0pO1xuICAgIGluc3RydWN0aW9uQnVmZmVyID0gaW5zdHJ1Y3Rpb25CdWZmZXIuc2xpY2UoMCwgaW5zdHJ1Y3Rpb25CdWZmZXJMZW5ndGgpO1xuICAgIGNvbnN0IHNpZ25EYXRhTGF5b3V0ID0gQnVmZmVyTGF5b3V0LnN0cnVjdChbQnVmZmVyTGF5b3V0LmJsb2IoMSwgJ251bVJlcXVpcmVkU2lnbmF0dXJlcycpLCBCdWZmZXJMYXlvdXQuYmxvYigxLCAnbnVtUmVhZG9ubHlTaWduZWRBY2NvdW50cycpLCBCdWZmZXJMYXlvdXQuYmxvYigxLCAnbnVtUmVhZG9ubHlVbnNpZ25lZEFjY291bnRzJyksIEJ1ZmZlckxheW91dC5ibG9iKGtleUNvdW50Lmxlbmd0aCwgJ2tleUNvdW50JyksIEJ1ZmZlckxheW91dC5zZXEocHVibGljS2V5KCdrZXknKSwgbnVtS2V5cywgJ2tleXMnKSwgcHVibGljS2V5KCdyZWNlbnRCbG9ja2hhc2gnKV0pO1xuICAgIGNvbnN0IHRyYW5zYWN0aW9uID0ge1xuICAgICAgbnVtUmVxdWlyZWRTaWduYXR1cmVzOiBCdWZmZXIuZnJvbShbdGhpcy5oZWFkZXIubnVtUmVxdWlyZWRTaWduYXR1cmVzXSksXG4gICAgICBudW1SZWFkb25seVNpZ25lZEFjY291bnRzOiBCdWZmZXIuZnJvbShbdGhpcy5oZWFkZXIubnVtUmVhZG9ubHlTaWduZWRBY2NvdW50c10pLFxuICAgICAgbnVtUmVhZG9ubHlVbnNpZ25lZEFjY291bnRzOiBCdWZmZXIuZnJvbShbdGhpcy5oZWFkZXIubnVtUmVhZG9ubHlVbnNpZ25lZEFjY291bnRzXSksXG4gICAgICBrZXlDb3VudDogQnVmZmVyLmZyb20oa2V5Q291bnQpLFxuICAgICAga2V5czogdGhpcy5hY2NvdW50S2V5cy5tYXAoa2V5ID0+IHRvQnVmZmVyKGtleS50b0J5dGVzKCkpKSxcbiAgICAgIHJlY2VudEJsb2NraGFzaDogYnM1OC5kZWNvZGUodGhpcy5yZWNlbnRCbG9ja2hhc2gpXG4gICAgfTtcbiAgICBsZXQgc2lnbkRhdGEgPSBCdWZmZXIuYWxsb2MoMjA0OCk7XG4gICAgY29uc3QgbGVuZ3RoID0gc2lnbkRhdGFMYXlvdXQuZW5jb2RlKHRyYW5zYWN0aW9uLCBzaWduRGF0YSk7XG4gICAgaW5zdHJ1Y3Rpb25CdWZmZXIuY29weShzaWduRGF0YSwgbGVuZ3RoKTtcbiAgICByZXR1cm4gc2lnbkRhdGEuc2xpY2UoMCwgbGVuZ3RoICsgaW5zdHJ1Y3Rpb25CdWZmZXIubGVuZ3RoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZWNvZGUgYSBjb21waWxlZCBtZXNzYWdlIGludG8gYSBNZXNzYWdlIG9iamVjdC5cbiAgICovXG4gIHN0YXRpYyBmcm9tKGJ1ZmZlcikge1xuICAgIC8vIFNsaWNlIHVwIHdpcmUgZGF0YVxuICAgIGxldCBieXRlQXJyYXkgPSBbLi4uYnVmZmVyXTtcbiAgICBjb25zdCBudW1SZXF1aXJlZFNpZ25hdHVyZXMgPSBndWFyZGVkU2hpZnQoYnl0ZUFycmF5KTtcbiAgICBpZiAobnVtUmVxdWlyZWRTaWduYXR1cmVzICE9PSAobnVtUmVxdWlyZWRTaWduYXR1cmVzICYgVkVSU0lPTl9QUkVGSVhfTUFTSykpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignVmVyc2lvbmVkIG1lc3NhZ2VzIG11c3QgYmUgZGVzZXJpYWxpemVkIHdpdGggVmVyc2lvbmVkTWVzc2FnZS5kZXNlcmlhbGl6ZSgpJyk7XG4gICAgfVxuICAgIGNvbnN0IG51bVJlYWRvbmx5U2lnbmVkQWNjb3VudHMgPSBndWFyZGVkU2hpZnQoYnl0ZUFycmF5KTtcbiAgICBjb25zdCBudW1SZWFkb25seVVuc2lnbmVkQWNjb3VudHMgPSBndWFyZGVkU2hpZnQoYnl0ZUFycmF5KTtcbiAgICBjb25zdCBhY2NvdW50Q291bnQgPSBkZWNvZGVMZW5ndGgoYnl0ZUFycmF5KTtcbiAgICBsZXQgYWNjb3VudEtleXMgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGFjY291bnRDb3VudDsgaSsrKSB7XG4gICAgICBjb25zdCBhY2NvdW50ID0gZ3VhcmRlZFNwbGljZShieXRlQXJyYXksIDAsIFBVQkxJQ19LRVlfTEVOR1RIKTtcbiAgICAgIGFjY291bnRLZXlzLnB1c2gobmV3IFB1YmxpY0tleShCdWZmZXIuZnJvbShhY2NvdW50KSkpO1xuICAgIH1cbiAgICBjb25zdCByZWNlbnRCbG9ja2hhc2ggPSBndWFyZGVkU3BsaWNlKGJ5dGVBcnJheSwgMCwgUFVCTElDX0tFWV9MRU5HVEgpO1xuICAgIGNvbnN0IGluc3RydWN0aW9uQ291bnQgPSBkZWNvZGVMZW5ndGgoYnl0ZUFycmF5KTtcbiAgICBsZXQgaW5zdHJ1Y3Rpb25zID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBpbnN0cnVjdGlvbkNvdW50OyBpKyspIHtcbiAgICAgIGNvbnN0IHByb2dyYW1JZEluZGV4ID0gZ3VhcmRlZFNoaWZ0KGJ5dGVBcnJheSk7XG4gICAgICBjb25zdCBhY2NvdW50Q291bnQgPSBkZWNvZGVMZW5ndGgoYnl0ZUFycmF5KTtcbiAgICAgIGNvbnN0IGFjY291bnRzID0gZ3VhcmRlZFNwbGljZShieXRlQXJyYXksIDAsIGFjY291bnRDb3VudCk7XG4gICAgICBjb25zdCBkYXRhTGVuZ3RoID0gZGVjb2RlTGVuZ3RoKGJ5dGVBcnJheSk7XG4gICAgICBjb25zdCBkYXRhU2xpY2UgPSBndWFyZGVkU3BsaWNlKGJ5dGVBcnJheSwgMCwgZGF0YUxlbmd0aCk7XG4gICAgICBjb25zdCBkYXRhID0gYnM1OC5lbmNvZGUoQnVmZmVyLmZyb20oZGF0YVNsaWNlKSk7XG4gICAgICBpbnN0cnVjdGlvbnMucHVzaCh7XG4gICAgICAgIHByb2dyYW1JZEluZGV4LFxuICAgICAgICBhY2NvdW50cyxcbiAgICAgICAgZGF0YVxuICAgICAgfSk7XG4gICAgfVxuICAgIGNvbnN0IG1lc3NhZ2VBcmdzID0ge1xuICAgICAgaGVhZGVyOiB7XG4gICAgICAgIG51bVJlcXVpcmVkU2lnbmF0dXJlcyxcbiAgICAgICAgbnVtUmVhZG9ubHlTaWduZWRBY2NvdW50cyxcbiAgICAgICAgbnVtUmVhZG9ubHlVbnNpZ25lZEFjY291bnRzXG4gICAgICB9LFxuICAgICAgcmVjZW50QmxvY2toYXNoOiBiczU4LmVuY29kZShCdWZmZXIuZnJvbShyZWNlbnRCbG9ja2hhc2gpKSxcbiAgICAgIGFjY291bnRLZXlzLFxuICAgICAgaW5zdHJ1Y3Rpb25zXG4gICAgfTtcbiAgICByZXR1cm4gbmV3IE1lc3NhZ2UobWVzc2FnZUFyZ3MpO1xuICB9XG59XG5cbi8qKlxuICogTWVzc2FnZSBjb25zdHJ1Y3RvciBhcmd1bWVudHNcbiAqL1xuXG5jbGFzcyBNZXNzYWdlVjAge1xuICBjb25zdHJ1Y3RvcihhcmdzKSB7XG4gICAgdGhpcy5oZWFkZXIgPSB2b2lkIDA7XG4gICAgdGhpcy5zdGF0aWNBY2NvdW50S2V5cyA9IHZvaWQgMDtcbiAgICB0aGlzLnJlY2VudEJsb2NraGFzaCA9IHZvaWQgMDtcbiAgICB0aGlzLmNvbXBpbGVkSW5zdHJ1Y3Rpb25zID0gdm9pZCAwO1xuICAgIHRoaXMuYWRkcmVzc1RhYmxlTG9va3VwcyA9IHZvaWQgMDtcbiAgICB0aGlzLmhlYWRlciA9IGFyZ3MuaGVhZGVyO1xuICAgIHRoaXMuc3RhdGljQWNjb3VudEtleXMgPSBhcmdzLnN0YXRpY0FjY291bnRLZXlzO1xuICAgIHRoaXMucmVjZW50QmxvY2toYXNoID0gYXJncy5yZWNlbnRCbG9ja2hhc2g7XG4gICAgdGhpcy5jb21waWxlZEluc3RydWN0aW9ucyA9IGFyZ3MuY29tcGlsZWRJbnN0cnVjdGlvbnM7XG4gICAgdGhpcy5hZGRyZXNzVGFibGVMb29rdXBzID0gYXJncy5hZGRyZXNzVGFibGVMb29rdXBzO1xuICB9XG4gIGdldCB2ZXJzaW9uKCkge1xuICAgIHJldHVybiAwO1xuICB9XG4gIGdldCBudW1BY2NvdW50S2V5c0Zyb21Mb29rdXBzKCkge1xuICAgIGxldCBjb3VudCA9IDA7XG4gICAgZm9yIChjb25zdCBsb29rdXAgb2YgdGhpcy5hZGRyZXNzVGFibGVMb29rdXBzKSB7XG4gICAgICBjb3VudCArPSBsb29rdXAucmVhZG9ubHlJbmRleGVzLmxlbmd0aCArIGxvb2t1cC53cml0YWJsZUluZGV4ZXMubGVuZ3RoO1xuICAgIH1cbiAgICByZXR1cm4gY291bnQ7XG4gIH1cbiAgZ2V0QWNjb3VudEtleXMoYXJncykge1xuICAgIGxldCBhY2NvdW50S2V5c0Zyb21Mb29rdXBzO1xuICAgIGlmIChhcmdzICYmICdhY2NvdW50S2V5c0Zyb21Mb29rdXBzJyBpbiBhcmdzICYmIGFyZ3MuYWNjb3VudEtleXNGcm9tTG9va3Vwcykge1xuICAgICAgaWYgKHRoaXMubnVtQWNjb3VudEtleXNGcm9tTG9va3VwcyAhPSBhcmdzLmFjY291bnRLZXlzRnJvbUxvb2t1cHMud3JpdGFibGUubGVuZ3RoICsgYXJncy5hY2NvdW50S2V5c0Zyb21Mb29rdXBzLnJlYWRvbmx5Lmxlbmd0aCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZhaWxlZCB0byBnZXQgYWNjb3VudCBrZXlzIGJlY2F1c2Ugb2YgYSBtaXNtYXRjaCBpbiB0aGUgbnVtYmVyIG9mIGFjY291bnQga2V5cyBmcm9tIGxvb2t1cHMnKTtcbiAgICAgIH1cbiAgICAgIGFjY291bnRLZXlzRnJvbUxvb2t1cHMgPSBhcmdzLmFjY291bnRLZXlzRnJvbUxvb2t1cHM7XG4gICAgfSBlbHNlIGlmIChhcmdzICYmICdhZGRyZXNzTG9va3VwVGFibGVBY2NvdW50cycgaW4gYXJncyAmJiBhcmdzLmFkZHJlc3NMb29rdXBUYWJsZUFjY291bnRzKSB7XG4gICAgICBhY2NvdW50S2V5c0Zyb21Mb29rdXBzID0gdGhpcy5yZXNvbHZlQWRkcmVzc1RhYmxlTG9va3VwcyhhcmdzLmFkZHJlc3NMb29rdXBUYWJsZUFjY291bnRzKTtcbiAgICB9IGVsc2UgaWYgKHRoaXMuYWRkcmVzc1RhYmxlTG9va3Vwcy5sZW5ndGggPiAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZhaWxlZCB0byBnZXQgYWNjb3VudCBrZXlzIGJlY2F1c2UgYWRkcmVzcyB0YWJsZSBsb29rdXBzIHdlcmUgbm90IHJlc29sdmVkJyk7XG4gICAgfVxuICAgIHJldHVybiBuZXcgTWVzc2FnZUFjY291bnRLZXlzKHRoaXMuc3RhdGljQWNjb3VudEtleXMsIGFjY291bnRLZXlzRnJvbUxvb2t1cHMpO1xuICB9XG4gIGlzQWNjb3VudFNpZ25lcihpbmRleCkge1xuICAgIHJldHVybiBpbmRleCA8IHRoaXMuaGVhZGVyLm51bVJlcXVpcmVkU2lnbmF0dXJlcztcbiAgfVxuICBpc0FjY291bnRXcml0YWJsZShpbmRleCkge1xuICAgIGNvbnN0IG51bVNpZ25lZEFjY291bnRzID0gdGhpcy5oZWFkZXIubnVtUmVxdWlyZWRTaWduYXR1cmVzO1xuICAgIGNvbnN0IG51bVN0YXRpY0FjY291bnRLZXlzID0gdGhpcy5zdGF0aWNBY2NvdW50S2V5cy5sZW5ndGg7XG4gICAgaWYgKGluZGV4ID49IG51bVN0YXRpY0FjY291bnRLZXlzKSB7XG4gICAgICBjb25zdCBsb29rdXBBY2NvdW50S2V5c0luZGV4ID0gaW5kZXggLSBudW1TdGF0aWNBY2NvdW50S2V5cztcbiAgICAgIGNvbnN0IG51bVdyaXRhYmxlTG9va3VwQWNjb3VudEtleXMgPSB0aGlzLmFkZHJlc3NUYWJsZUxvb2t1cHMucmVkdWNlKChjb3VudCwgbG9va3VwKSA9PiBjb3VudCArIGxvb2t1cC53cml0YWJsZUluZGV4ZXMubGVuZ3RoLCAwKTtcbiAgICAgIHJldHVybiBsb29rdXBBY2NvdW50S2V5c0luZGV4IDwgbnVtV3JpdGFibGVMb29rdXBBY2NvdW50S2V5cztcbiAgICB9IGVsc2UgaWYgKGluZGV4ID49IHRoaXMuaGVhZGVyLm51bVJlcXVpcmVkU2lnbmF0dXJlcykge1xuICAgICAgY29uc3QgdW5zaWduZWRBY2NvdW50SW5kZXggPSBpbmRleCAtIG51bVNpZ25lZEFjY291bnRzO1xuICAgICAgY29uc3QgbnVtVW5zaWduZWRBY2NvdW50cyA9IG51bVN0YXRpY0FjY291bnRLZXlzIC0gbnVtU2lnbmVkQWNjb3VudHM7XG4gICAgICBjb25zdCBudW1Xcml0YWJsZVVuc2lnbmVkQWNjb3VudHMgPSBudW1VbnNpZ25lZEFjY291bnRzIC0gdGhpcy5oZWFkZXIubnVtUmVhZG9ubHlVbnNpZ25lZEFjY291bnRzO1xuICAgICAgcmV0dXJuIHVuc2lnbmVkQWNjb3VudEluZGV4IDwgbnVtV3JpdGFibGVVbnNpZ25lZEFjY291bnRzO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBudW1Xcml0YWJsZVNpZ25lZEFjY291bnRzID0gbnVtU2lnbmVkQWNjb3VudHMgLSB0aGlzLmhlYWRlci5udW1SZWFkb25seVNpZ25lZEFjY291bnRzO1xuICAgICAgcmV0dXJuIGluZGV4IDwgbnVtV3JpdGFibGVTaWduZWRBY2NvdW50cztcbiAgICB9XG4gIH1cbiAgcmVzb2x2ZUFkZHJlc3NUYWJsZUxvb2t1cHMoYWRkcmVzc0xvb2t1cFRhYmxlQWNjb3VudHMpIHtcbiAgICBjb25zdCBhY2NvdW50S2V5c0Zyb21Mb29rdXBzID0ge1xuICAgICAgd3JpdGFibGU6IFtdLFxuICAgICAgcmVhZG9ubHk6IFtdXG4gICAgfTtcbiAgICBmb3IgKGNvbnN0IHRhYmxlTG9va3VwIG9mIHRoaXMuYWRkcmVzc1RhYmxlTG9va3Vwcykge1xuICAgICAgY29uc3QgdGFibGVBY2NvdW50ID0gYWRkcmVzc0xvb2t1cFRhYmxlQWNjb3VudHMuZmluZChhY2NvdW50ID0+IGFjY291bnQua2V5LmVxdWFscyh0YWJsZUxvb2t1cC5hY2NvdW50S2V5KSk7XG4gICAgICBpZiAoIXRhYmxlQWNjb3VudCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEZhaWxlZCB0byBmaW5kIGFkZHJlc3MgbG9va3VwIHRhYmxlIGFjY291bnQgZm9yIHRhYmxlIGtleSAke3RhYmxlTG9va3VwLmFjY291bnRLZXkudG9CYXNlNTgoKX1gKTtcbiAgICAgIH1cbiAgICAgIGZvciAoY29uc3QgaW5kZXggb2YgdGFibGVMb29rdXAud3JpdGFibGVJbmRleGVzKSB7XG4gICAgICAgIGlmIChpbmRleCA8IHRhYmxlQWNjb3VudC5zdGF0ZS5hZGRyZXNzZXMubGVuZ3RoKSB7XG4gICAgICAgICAgYWNjb3VudEtleXNGcm9tTG9va3Vwcy53cml0YWJsZS5wdXNoKHRhYmxlQWNjb3VudC5zdGF0ZS5hZGRyZXNzZXNbaW5kZXhdKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEZhaWxlZCB0byBmaW5kIGFkZHJlc3MgZm9yIGluZGV4ICR7aW5kZXh9IGluIGFkZHJlc3MgbG9va3VwIHRhYmxlICR7dGFibGVMb29rdXAuYWNjb3VudEtleS50b0Jhc2U1OCgpfWApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBmb3IgKGNvbnN0IGluZGV4IG9mIHRhYmxlTG9va3VwLnJlYWRvbmx5SW5kZXhlcykge1xuICAgICAgICBpZiAoaW5kZXggPCB0YWJsZUFjY291bnQuc3RhdGUuYWRkcmVzc2VzLmxlbmd0aCkge1xuICAgICAgICAgIGFjY291bnRLZXlzRnJvbUxvb2t1cHMucmVhZG9ubHkucHVzaCh0YWJsZUFjY291bnQuc3RhdGUuYWRkcmVzc2VzW2luZGV4XSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBGYWlsZWQgdG8gZmluZCBhZGRyZXNzIGZvciBpbmRleCAke2luZGV4fSBpbiBhZGRyZXNzIGxvb2t1cCB0YWJsZSAke3RhYmxlTG9va3VwLmFjY291bnRLZXkudG9CYXNlNTgoKX1gKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gYWNjb3VudEtleXNGcm9tTG9va3VwcztcbiAgfVxuICBzdGF0aWMgY29tcGlsZShhcmdzKSB7XG4gICAgY29uc3QgY29tcGlsZWRLZXlzID0gQ29tcGlsZWRLZXlzLmNvbXBpbGUoYXJncy5pbnN0cnVjdGlvbnMsIGFyZ3MucGF5ZXJLZXkpO1xuICAgIGNvbnN0IGFkZHJlc3NUYWJsZUxvb2t1cHMgPSBuZXcgQXJyYXkoKTtcbiAgICBjb25zdCBhY2NvdW50S2V5c0Zyb21Mb29rdXBzID0ge1xuICAgICAgd3JpdGFibGU6IG5ldyBBcnJheSgpLFxuICAgICAgcmVhZG9ubHk6IG5ldyBBcnJheSgpXG4gICAgfTtcbiAgICBjb25zdCBsb29rdXBUYWJsZUFjY291bnRzID0gYXJncy5hZGRyZXNzTG9va3VwVGFibGVBY2NvdW50cyB8fCBbXTtcbiAgICBmb3IgKGNvbnN0IGxvb2t1cFRhYmxlIG9mIGxvb2t1cFRhYmxlQWNjb3VudHMpIHtcbiAgICAgIGNvbnN0IGV4dHJhY3RSZXN1bHQgPSBjb21waWxlZEtleXMuZXh0cmFjdFRhYmxlTG9va3VwKGxvb2t1cFRhYmxlKTtcbiAgICAgIGlmIChleHRyYWN0UmVzdWx0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgY29uc3QgW2FkZHJlc3NUYWJsZUxvb2t1cCwge1xuICAgICAgICAgIHdyaXRhYmxlLFxuICAgICAgICAgIHJlYWRvbmx5XG4gICAgICAgIH1dID0gZXh0cmFjdFJlc3VsdDtcbiAgICAgICAgYWRkcmVzc1RhYmxlTG9va3Vwcy5wdXNoKGFkZHJlc3NUYWJsZUxvb2t1cCk7XG4gICAgICAgIGFjY291bnRLZXlzRnJvbUxvb2t1cHMud3JpdGFibGUucHVzaCguLi53cml0YWJsZSk7XG4gICAgICAgIGFjY291bnRLZXlzRnJvbUxvb2t1cHMucmVhZG9ubHkucHVzaCguLi5yZWFkb25seSk7XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IFtoZWFkZXIsIHN0YXRpY0FjY291bnRLZXlzXSA9IGNvbXBpbGVkS2V5cy5nZXRNZXNzYWdlQ29tcG9uZW50cygpO1xuICAgIGNvbnN0IGFjY291bnRLZXlzID0gbmV3IE1lc3NhZ2VBY2NvdW50S2V5cyhzdGF0aWNBY2NvdW50S2V5cywgYWNjb3VudEtleXNGcm9tTG9va3Vwcyk7XG4gICAgY29uc3QgY29tcGlsZWRJbnN0cnVjdGlvbnMgPSBhY2NvdW50S2V5cy5jb21waWxlSW5zdHJ1Y3Rpb25zKGFyZ3MuaW5zdHJ1Y3Rpb25zKTtcbiAgICByZXR1cm4gbmV3IE1lc3NhZ2VWMCh7XG4gICAgICBoZWFkZXIsXG4gICAgICBzdGF0aWNBY2NvdW50S2V5cyxcbiAgICAgIHJlY2VudEJsb2NraGFzaDogYXJncy5yZWNlbnRCbG9ja2hhc2gsXG4gICAgICBjb21waWxlZEluc3RydWN0aW9ucyxcbiAgICAgIGFkZHJlc3NUYWJsZUxvb2t1cHNcbiAgICB9KTtcbiAgfVxuICBzZXJpYWxpemUoKSB7XG4gICAgY29uc3QgZW5jb2RlZFN0YXRpY0FjY291bnRLZXlzTGVuZ3RoID0gQXJyYXkoKTtcbiAgICBlbmNvZGVMZW5ndGgoZW5jb2RlZFN0YXRpY0FjY291bnRLZXlzTGVuZ3RoLCB0aGlzLnN0YXRpY0FjY291bnRLZXlzLmxlbmd0aCk7XG4gICAgY29uc3Qgc2VyaWFsaXplZEluc3RydWN0aW9ucyA9IHRoaXMuc2VyaWFsaXplSW5zdHJ1Y3Rpb25zKCk7XG4gICAgY29uc3QgZW5jb2RlZEluc3RydWN0aW9uc0xlbmd0aCA9IEFycmF5KCk7XG4gICAgZW5jb2RlTGVuZ3RoKGVuY29kZWRJbnN0cnVjdGlvbnNMZW5ndGgsIHRoaXMuY29tcGlsZWRJbnN0cnVjdGlvbnMubGVuZ3RoKTtcbiAgICBjb25zdCBzZXJpYWxpemVkQWRkcmVzc1RhYmxlTG9va3VwcyA9IHRoaXMuc2VyaWFsaXplQWRkcmVzc1RhYmxlTG9va3VwcygpO1xuICAgIGNvbnN0IGVuY29kZWRBZGRyZXNzVGFibGVMb29rdXBzTGVuZ3RoID0gQXJyYXkoKTtcbiAgICBlbmNvZGVMZW5ndGgoZW5jb2RlZEFkZHJlc3NUYWJsZUxvb2t1cHNMZW5ndGgsIHRoaXMuYWRkcmVzc1RhYmxlTG9va3Vwcy5sZW5ndGgpO1xuICAgIGNvbnN0IG1lc3NhZ2VMYXlvdXQgPSBCdWZmZXJMYXlvdXQuc3RydWN0KFtCdWZmZXJMYXlvdXQudTgoJ3ByZWZpeCcpLCBCdWZmZXJMYXlvdXQuc3RydWN0KFtCdWZmZXJMYXlvdXQudTgoJ251bVJlcXVpcmVkU2lnbmF0dXJlcycpLCBCdWZmZXJMYXlvdXQudTgoJ251bVJlYWRvbmx5U2lnbmVkQWNjb3VudHMnKSwgQnVmZmVyTGF5b3V0LnU4KCdudW1SZWFkb25seVVuc2lnbmVkQWNjb3VudHMnKV0sICdoZWFkZXInKSwgQnVmZmVyTGF5b3V0LmJsb2IoZW5jb2RlZFN0YXRpY0FjY291bnRLZXlzTGVuZ3RoLmxlbmd0aCwgJ3N0YXRpY0FjY291bnRLZXlzTGVuZ3RoJyksIEJ1ZmZlckxheW91dC5zZXEocHVibGljS2V5KCksIHRoaXMuc3RhdGljQWNjb3VudEtleXMubGVuZ3RoLCAnc3RhdGljQWNjb3VudEtleXMnKSwgcHVibGljS2V5KCdyZWNlbnRCbG9ja2hhc2gnKSwgQnVmZmVyTGF5b3V0LmJsb2IoZW5jb2RlZEluc3RydWN0aW9uc0xlbmd0aC5sZW5ndGgsICdpbnN0cnVjdGlvbnNMZW5ndGgnKSwgQnVmZmVyTGF5b3V0LmJsb2Ioc2VyaWFsaXplZEluc3RydWN0aW9ucy5sZW5ndGgsICdzZXJpYWxpemVkSW5zdHJ1Y3Rpb25zJyksIEJ1ZmZlckxheW91dC5ibG9iKGVuY29kZWRBZGRyZXNzVGFibGVMb29rdXBzTGVuZ3RoLmxlbmd0aCwgJ2FkZHJlc3NUYWJsZUxvb2t1cHNMZW5ndGgnKSwgQnVmZmVyTGF5b3V0LmJsb2Ioc2VyaWFsaXplZEFkZHJlc3NUYWJsZUxvb2t1cHMubGVuZ3RoLCAnc2VyaWFsaXplZEFkZHJlc3NUYWJsZUxvb2t1cHMnKV0pO1xuICAgIGNvbnN0IHNlcmlhbGl6ZWRNZXNzYWdlID0gbmV3IFVpbnQ4QXJyYXkoUEFDS0VUX0RBVEFfU0laRSk7XG4gICAgY29uc3QgTUVTU0FHRV9WRVJTSU9OXzBfUFJFRklYID0gMSA8PCA3O1xuICAgIGNvbnN0IHNlcmlhbGl6ZWRNZXNzYWdlTGVuZ3RoID0gbWVzc2FnZUxheW91dC5lbmNvZGUoe1xuICAgICAgcHJlZml4OiBNRVNTQUdFX1ZFUlNJT05fMF9QUkVGSVgsXG4gICAgICBoZWFkZXI6IHRoaXMuaGVhZGVyLFxuICAgICAgc3RhdGljQWNjb3VudEtleXNMZW5ndGg6IG5ldyBVaW50OEFycmF5KGVuY29kZWRTdGF0aWNBY2NvdW50S2V5c0xlbmd0aCksXG4gICAgICBzdGF0aWNBY2NvdW50S2V5czogdGhpcy5zdGF0aWNBY2NvdW50S2V5cy5tYXAoa2V5ID0+IGtleS50b0J5dGVzKCkpLFxuICAgICAgcmVjZW50QmxvY2toYXNoOiBiczU4LmRlY29kZSh0aGlzLnJlY2VudEJsb2NraGFzaCksXG4gICAgICBpbnN0cnVjdGlvbnNMZW5ndGg6IG5ldyBVaW50OEFycmF5KGVuY29kZWRJbnN0cnVjdGlvbnNMZW5ndGgpLFxuICAgICAgc2VyaWFsaXplZEluc3RydWN0aW9ucyxcbiAgICAgIGFkZHJlc3NUYWJsZUxvb2t1cHNMZW5ndGg6IG5ldyBVaW50OEFycmF5KGVuY29kZWRBZGRyZXNzVGFibGVMb29rdXBzTGVuZ3RoKSxcbiAgICAgIHNlcmlhbGl6ZWRBZGRyZXNzVGFibGVMb29rdXBzXG4gICAgfSwgc2VyaWFsaXplZE1lc3NhZ2UpO1xuICAgIHJldHVybiBzZXJpYWxpemVkTWVzc2FnZS5zbGljZSgwLCBzZXJpYWxpemVkTWVzc2FnZUxlbmd0aCk7XG4gIH1cbiAgc2VyaWFsaXplSW5zdHJ1Y3Rpb25zKCkge1xuICAgIGxldCBzZXJpYWxpemVkTGVuZ3RoID0gMDtcbiAgICBjb25zdCBzZXJpYWxpemVkSW5zdHJ1Y3Rpb25zID0gbmV3IFVpbnQ4QXJyYXkoUEFDS0VUX0RBVEFfU0laRSk7XG4gICAgZm9yIChjb25zdCBpbnN0cnVjdGlvbiBvZiB0aGlzLmNvbXBpbGVkSW5zdHJ1Y3Rpb25zKSB7XG4gICAgICBjb25zdCBlbmNvZGVkQWNjb3VudEtleUluZGV4ZXNMZW5ndGggPSBBcnJheSgpO1xuICAgICAgZW5jb2RlTGVuZ3RoKGVuY29kZWRBY2NvdW50S2V5SW5kZXhlc0xlbmd0aCwgaW5zdHJ1Y3Rpb24uYWNjb3VudEtleUluZGV4ZXMubGVuZ3RoKTtcbiAgICAgIGNvbnN0IGVuY29kZWREYXRhTGVuZ3RoID0gQXJyYXkoKTtcbiAgICAgIGVuY29kZUxlbmd0aChlbmNvZGVkRGF0YUxlbmd0aCwgaW5zdHJ1Y3Rpb24uZGF0YS5sZW5ndGgpO1xuICAgICAgY29uc3QgaW5zdHJ1Y3Rpb25MYXlvdXQgPSBCdWZmZXJMYXlvdXQuc3RydWN0KFtCdWZmZXJMYXlvdXQudTgoJ3Byb2dyYW1JZEluZGV4JyksIEJ1ZmZlckxheW91dC5ibG9iKGVuY29kZWRBY2NvdW50S2V5SW5kZXhlc0xlbmd0aC5sZW5ndGgsICdlbmNvZGVkQWNjb3VudEtleUluZGV4ZXNMZW5ndGgnKSwgQnVmZmVyTGF5b3V0LnNlcShCdWZmZXJMYXlvdXQudTgoKSwgaW5zdHJ1Y3Rpb24uYWNjb3VudEtleUluZGV4ZXMubGVuZ3RoLCAnYWNjb3VudEtleUluZGV4ZXMnKSwgQnVmZmVyTGF5b3V0LmJsb2IoZW5jb2RlZERhdGFMZW5ndGgubGVuZ3RoLCAnZW5jb2RlZERhdGFMZW5ndGgnKSwgQnVmZmVyTGF5b3V0LmJsb2IoaW5zdHJ1Y3Rpb24uZGF0YS5sZW5ndGgsICdkYXRhJyldKTtcbiAgICAgIHNlcmlhbGl6ZWRMZW5ndGggKz0gaW5zdHJ1Y3Rpb25MYXlvdXQuZW5jb2RlKHtcbiAgICAgICAgcHJvZ3JhbUlkSW5kZXg6IGluc3RydWN0aW9uLnByb2dyYW1JZEluZGV4LFxuICAgICAgICBlbmNvZGVkQWNjb3VudEtleUluZGV4ZXNMZW5ndGg6IG5ldyBVaW50OEFycmF5KGVuY29kZWRBY2NvdW50S2V5SW5kZXhlc0xlbmd0aCksXG4gICAgICAgIGFjY291bnRLZXlJbmRleGVzOiBpbnN0cnVjdGlvbi5hY2NvdW50S2V5SW5kZXhlcyxcbiAgICAgICAgZW5jb2RlZERhdGFMZW5ndGg6IG5ldyBVaW50OEFycmF5KGVuY29kZWREYXRhTGVuZ3RoKSxcbiAgICAgICAgZGF0YTogaW5zdHJ1Y3Rpb24uZGF0YVxuICAgICAgfSwgc2VyaWFsaXplZEluc3RydWN0aW9ucywgc2VyaWFsaXplZExlbmd0aCk7XG4gICAgfVxuICAgIHJldHVybiBzZXJpYWxpemVkSW5zdHJ1Y3Rpb25zLnNsaWNlKDAsIHNlcmlhbGl6ZWRMZW5ndGgpO1xuICB9XG4gIHNlcmlhbGl6ZUFkZHJlc3NUYWJsZUxvb2t1cHMoKSB7XG4gICAgbGV0IHNlcmlhbGl6ZWRMZW5ndGggPSAwO1xuICAgIGNvbnN0IHNlcmlhbGl6ZWRBZGRyZXNzVGFibGVMb29rdXBzID0gbmV3IFVpbnQ4QXJyYXkoUEFDS0VUX0RBVEFfU0laRSk7XG4gICAgZm9yIChjb25zdCBsb29rdXAgb2YgdGhpcy5hZGRyZXNzVGFibGVMb29rdXBzKSB7XG4gICAgICBjb25zdCBlbmNvZGVkV3JpdGFibGVJbmRleGVzTGVuZ3RoID0gQXJyYXkoKTtcbiAgICAgIGVuY29kZUxlbmd0aChlbmNvZGVkV3JpdGFibGVJbmRleGVzTGVuZ3RoLCBsb29rdXAud3JpdGFibGVJbmRleGVzLmxlbmd0aCk7XG4gICAgICBjb25zdCBlbmNvZGVkUmVhZG9ubHlJbmRleGVzTGVuZ3RoID0gQXJyYXkoKTtcbiAgICAgIGVuY29kZUxlbmd0aChlbmNvZGVkUmVhZG9ubHlJbmRleGVzTGVuZ3RoLCBsb29rdXAucmVhZG9ubHlJbmRleGVzLmxlbmd0aCk7XG4gICAgICBjb25zdCBhZGRyZXNzVGFibGVMb29rdXBMYXlvdXQgPSBCdWZmZXJMYXlvdXQuc3RydWN0KFtwdWJsaWNLZXkoJ2FjY291bnRLZXknKSwgQnVmZmVyTGF5b3V0LmJsb2IoZW5jb2RlZFdyaXRhYmxlSW5kZXhlc0xlbmd0aC5sZW5ndGgsICdlbmNvZGVkV3JpdGFibGVJbmRleGVzTGVuZ3RoJyksIEJ1ZmZlckxheW91dC5zZXEoQnVmZmVyTGF5b3V0LnU4KCksIGxvb2t1cC53cml0YWJsZUluZGV4ZXMubGVuZ3RoLCAnd3JpdGFibGVJbmRleGVzJyksIEJ1ZmZlckxheW91dC5ibG9iKGVuY29kZWRSZWFkb25seUluZGV4ZXNMZW5ndGgubGVuZ3RoLCAnZW5jb2RlZFJlYWRvbmx5SW5kZXhlc0xlbmd0aCcpLCBCdWZmZXJMYXlvdXQuc2VxKEJ1ZmZlckxheW91dC51OCgpLCBsb29rdXAucmVhZG9ubHlJbmRleGVzLmxlbmd0aCwgJ3JlYWRvbmx5SW5kZXhlcycpXSk7XG4gICAgICBzZXJpYWxpemVkTGVuZ3RoICs9IGFkZHJlc3NUYWJsZUxvb2t1cExheW91dC5lbmNvZGUoe1xuICAgICAgICBhY2NvdW50S2V5OiBsb29rdXAuYWNjb3VudEtleS50b0J5dGVzKCksXG4gICAgICAgIGVuY29kZWRXcml0YWJsZUluZGV4ZXNMZW5ndGg6IG5ldyBVaW50OEFycmF5KGVuY29kZWRXcml0YWJsZUluZGV4ZXNMZW5ndGgpLFxuICAgICAgICB3cml0YWJsZUluZGV4ZXM6IGxvb2t1cC53cml0YWJsZUluZGV4ZXMsXG4gICAgICAgIGVuY29kZWRSZWFkb25seUluZGV4ZXNMZW5ndGg6IG5ldyBVaW50OEFycmF5KGVuY29kZWRSZWFkb25seUluZGV4ZXNMZW5ndGgpLFxuICAgICAgICByZWFkb25seUluZGV4ZXM6IGxvb2t1cC5yZWFkb25seUluZGV4ZXNcbiAgICAgIH0sIHNlcmlhbGl6ZWRBZGRyZXNzVGFibGVMb29rdXBzLCBzZXJpYWxpemVkTGVuZ3RoKTtcbiAgICB9XG4gICAgcmV0dXJuIHNlcmlhbGl6ZWRBZGRyZXNzVGFibGVMb29rdXBzLnNsaWNlKDAsIHNlcmlhbGl6ZWRMZW5ndGgpO1xuICB9XG4gIHN0YXRpYyBkZXNlcmlhbGl6ZShzZXJpYWxpemVkTWVzc2FnZSkge1xuICAgIGxldCBieXRlQXJyYXkgPSBbLi4uc2VyaWFsaXplZE1lc3NhZ2VdO1xuICAgIGNvbnN0IHByZWZpeCA9IGd1YXJkZWRTaGlmdChieXRlQXJyYXkpO1xuICAgIGNvbnN0IG1hc2tlZFByZWZpeCA9IHByZWZpeCAmIFZFUlNJT05fUFJFRklYX01BU0s7XG4gICAgYXNzZXJ0KHByZWZpeCAhPT0gbWFza2VkUHJlZml4LCBgRXhwZWN0ZWQgdmVyc2lvbmVkIG1lc3NhZ2UgYnV0IHJlY2VpdmVkIGxlZ2FjeSBtZXNzYWdlYCk7XG4gICAgY29uc3QgdmVyc2lvbiA9IG1hc2tlZFByZWZpeDtcbiAgICBhc3NlcnQodmVyc2lvbiA9PT0gMCwgYEV4cGVjdGVkIHZlcnNpb25lZCBtZXNzYWdlIHdpdGggdmVyc2lvbiAwIGJ1dCBmb3VuZCB2ZXJzaW9uICR7dmVyc2lvbn1gKTtcbiAgICBjb25zdCBoZWFkZXIgPSB7XG4gICAgICBudW1SZXF1aXJlZFNpZ25hdHVyZXM6IGd1YXJkZWRTaGlmdChieXRlQXJyYXkpLFxuICAgICAgbnVtUmVhZG9ubHlTaWduZWRBY2NvdW50czogZ3VhcmRlZFNoaWZ0KGJ5dGVBcnJheSksXG4gICAgICBudW1SZWFkb25seVVuc2lnbmVkQWNjb3VudHM6IGd1YXJkZWRTaGlmdChieXRlQXJyYXkpXG4gICAgfTtcbiAgICBjb25zdCBzdGF0aWNBY2NvdW50S2V5cyA9IFtdO1xuICAgIGNvbnN0IHN0YXRpY0FjY291bnRLZXlzTGVuZ3RoID0gZGVjb2RlTGVuZ3RoKGJ5dGVBcnJheSk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzdGF0aWNBY2NvdW50S2V5c0xlbmd0aDsgaSsrKSB7XG4gICAgICBzdGF0aWNBY2NvdW50S2V5cy5wdXNoKG5ldyBQdWJsaWNLZXkoZ3VhcmRlZFNwbGljZShieXRlQXJyYXksIDAsIFBVQkxJQ19LRVlfTEVOR1RIKSkpO1xuICAgIH1cbiAgICBjb25zdCByZWNlbnRCbG9ja2hhc2ggPSBiczU4LmVuY29kZShndWFyZGVkU3BsaWNlKGJ5dGVBcnJheSwgMCwgUFVCTElDX0tFWV9MRU5HVEgpKTtcbiAgICBjb25zdCBpbnN0cnVjdGlvbkNvdW50ID0gZGVjb2RlTGVuZ3RoKGJ5dGVBcnJheSk7XG4gICAgY29uc3QgY29tcGlsZWRJbnN0cnVjdGlvbnMgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGluc3RydWN0aW9uQ291bnQ7IGkrKykge1xuICAgICAgY29uc3QgcHJvZ3JhbUlkSW5kZXggPSBndWFyZGVkU2hpZnQoYnl0ZUFycmF5KTtcbiAgICAgIGNvbnN0IGFjY291bnRLZXlJbmRleGVzTGVuZ3RoID0gZGVjb2RlTGVuZ3RoKGJ5dGVBcnJheSk7XG4gICAgICBjb25zdCBhY2NvdW50S2V5SW5kZXhlcyA9IGd1YXJkZWRTcGxpY2UoYnl0ZUFycmF5LCAwLCBhY2NvdW50S2V5SW5kZXhlc0xlbmd0aCk7XG4gICAgICBjb25zdCBkYXRhTGVuZ3RoID0gZGVjb2RlTGVuZ3RoKGJ5dGVBcnJheSk7XG4gICAgICBjb25zdCBkYXRhID0gbmV3IFVpbnQ4QXJyYXkoZ3VhcmRlZFNwbGljZShieXRlQXJyYXksIDAsIGRhdGFMZW5ndGgpKTtcbiAgICAgIGNvbXBpbGVkSW5zdHJ1Y3Rpb25zLnB1c2goe1xuICAgICAgICBwcm9ncmFtSWRJbmRleCxcbiAgICAgICAgYWNjb3VudEtleUluZGV4ZXMsXG4gICAgICAgIGRhdGFcbiAgICAgIH0pO1xuICAgIH1cbiAgICBjb25zdCBhZGRyZXNzVGFibGVMb29rdXBzQ291bnQgPSBkZWNvZGVMZW5ndGgoYnl0ZUFycmF5KTtcbiAgICBjb25zdCBhZGRyZXNzVGFibGVMb29rdXBzID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhZGRyZXNzVGFibGVMb29rdXBzQ291bnQ7IGkrKykge1xuICAgICAgY29uc3QgYWNjb3VudEtleSA9IG5ldyBQdWJsaWNLZXkoZ3VhcmRlZFNwbGljZShieXRlQXJyYXksIDAsIFBVQkxJQ19LRVlfTEVOR1RIKSk7XG4gICAgICBjb25zdCB3cml0YWJsZUluZGV4ZXNMZW5ndGggPSBkZWNvZGVMZW5ndGgoYnl0ZUFycmF5KTtcbiAgICAgIGNvbnN0IHdyaXRhYmxlSW5kZXhlcyA9IGd1YXJkZWRTcGxpY2UoYnl0ZUFycmF5LCAwLCB3cml0YWJsZUluZGV4ZXNMZW5ndGgpO1xuICAgICAgY29uc3QgcmVhZG9ubHlJbmRleGVzTGVuZ3RoID0gZGVjb2RlTGVuZ3RoKGJ5dGVBcnJheSk7XG4gICAgICBjb25zdCByZWFkb25seUluZGV4ZXMgPSBndWFyZGVkU3BsaWNlKGJ5dGVBcnJheSwgMCwgcmVhZG9ubHlJbmRleGVzTGVuZ3RoKTtcbiAgICAgIGFkZHJlc3NUYWJsZUxvb2t1cHMucHVzaCh7XG4gICAgICAgIGFjY291bnRLZXksXG4gICAgICAgIHdyaXRhYmxlSW5kZXhlcyxcbiAgICAgICAgcmVhZG9ubHlJbmRleGVzXG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBNZXNzYWdlVjAoe1xuICAgICAgaGVhZGVyLFxuICAgICAgc3RhdGljQWNjb3VudEtleXMsXG4gICAgICByZWNlbnRCbG9ja2hhc2gsXG4gICAgICBjb21waWxlZEluc3RydWN0aW9ucyxcbiAgICAgIGFkZHJlc3NUYWJsZUxvb2t1cHNcbiAgICB9KTtcbiAgfVxufVxuXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcmVkZWNsYXJlXG5jb25zdCBWZXJzaW9uZWRNZXNzYWdlID0ge1xuICBkZXNlcmlhbGl6ZU1lc3NhZ2VWZXJzaW9uKHNlcmlhbGl6ZWRNZXNzYWdlKSB7XG4gICAgY29uc3QgcHJlZml4ID0gc2VyaWFsaXplZE1lc3NhZ2VbMF07XG4gICAgY29uc3QgbWFza2VkUHJlZml4ID0gcHJlZml4ICYgVkVSU0lPTl9QUkVGSVhfTUFTSztcblxuICAgIC8vIGlmIHRoZSBoaWdoZXN0IGJpdCBvZiB0aGUgcHJlZml4IGlzIG5vdCBzZXQsIHRoZSBtZXNzYWdlIGlzIG5vdCB2ZXJzaW9uZWRcbiAgICBpZiAobWFza2VkUHJlZml4ID09PSBwcmVmaXgpIHtcbiAgICAgIHJldHVybiAnbGVnYWN5JztcbiAgICB9XG5cbiAgICAvLyB0aGUgbG93ZXIgNyBiaXRzIG9mIHRoZSBwcmVmaXggaW5kaWNhdGUgdGhlIG1lc3NhZ2UgdmVyc2lvblxuICAgIHJldHVybiBtYXNrZWRQcmVmaXg7XG4gIH0sXG4gIGRlc2VyaWFsaXplOiBzZXJpYWxpemVkTWVzc2FnZSA9PiB7XG4gICAgY29uc3QgdmVyc2lvbiA9IFZlcnNpb25lZE1lc3NhZ2UuZGVzZXJpYWxpemVNZXNzYWdlVmVyc2lvbihzZXJpYWxpemVkTWVzc2FnZSk7XG4gICAgaWYgKHZlcnNpb24gPT09ICdsZWdhY3knKSB7XG4gICAgICByZXR1cm4gTWVzc2FnZS5mcm9tKHNlcmlhbGl6ZWRNZXNzYWdlKTtcbiAgICB9XG4gICAgaWYgKHZlcnNpb24gPT09IDApIHtcbiAgICAgIHJldHVybiBNZXNzYWdlVjAuZGVzZXJpYWxpemUoc2VyaWFsaXplZE1lc3NhZ2UpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFRyYW5zYWN0aW9uIG1lc3NhZ2UgdmVyc2lvbiAke3ZlcnNpb259IGRlc2VyaWFsaXphdGlvbiBpcyBub3Qgc3VwcG9ydGVkYCk7XG4gICAgfVxuICB9XG59O1xuXG4vKiogQGludGVybmFsICovXG5cbi8qKlxuICogVHJhbnNhY3Rpb24gc2lnbmF0dXJlIGFzIGJhc2UtNTggZW5jb2RlZCBzdHJpbmdcbiAqL1xuXG5sZXQgVHJhbnNhY3Rpb25TdGF0dXMgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKFRyYW5zYWN0aW9uU3RhdHVzKSB7XG4gIFRyYW5zYWN0aW9uU3RhdHVzW1RyYW5zYWN0aW9uU3RhdHVzW1wiQkxPQ0tIRUlHSFRfRVhDRUVERURcIl0gPSAwXSA9IFwiQkxPQ0tIRUlHSFRfRVhDRUVERURcIjtcbiAgVHJhbnNhY3Rpb25TdGF0dXNbVHJhbnNhY3Rpb25TdGF0dXNbXCJQUk9DRVNTRURcIl0gPSAxXSA9IFwiUFJPQ0VTU0VEXCI7XG4gIFRyYW5zYWN0aW9uU3RhdHVzW1RyYW5zYWN0aW9uU3RhdHVzW1wiVElNRURfT1VUXCJdID0gMl0gPSBcIlRJTUVEX09VVFwiO1xuICBUcmFuc2FjdGlvblN0YXR1c1tUcmFuc2FjdGlvblN0YXR1c1tcIk5PTkNFX0lOVkFMSURcIl0gPSAzXSA9IFwiTk9OQ0VfSU5WQUxJRFwiO1xuICByZXR1cm4gVHJhbnNhY3Rpb25TdGF0dXM7XG59KHt9KTtcblxuLyoqXG4gKiBEZWZhdWx0IChlbXB0eSkgc2lnbmF0dXJlXG4gKi9cbmNvbnN0IERFRkFVTFRfU0lHTkFUVVJFID0gQnVmZmVyLmFsbG9jKFNJR05BVFVSRV9MRU5HVEhfSU5fQllURVMpLmZpbGwoMCk7XG5cbi8qKlxuICogQWNjb3VudCBtZXRhZGF0YSB1c2VkIHRvIGRlZmluZSBpbnN0cnVjdGlvbnNcbiAqL1xuXG4vKipcbiAqIExpc3Qgb2YgVHJhbnNhY3Rpb25JbnN0cnVjdGlvbiBvYmplY3QgZmllbGRzIHRoYXQgbWF5IGJlIGluaXRpYWxpemVkIGF0IGNvbnN0cnVjdGlvblxuICovXG5cbi8qKlxuICogQ29uZmlndXJhdGlvbiBvYmplY3QgZm9yIFRyYW5zYWN0aW9uLnNlcmlhbGl6ZSgpXG4gKi9cblxuLyoqXG4gKiBAaW50ZXJuYWxcbiAqL1xuXG4vKipcbiAqIFRyYW5zYWN0aW9uIEluc3RydWN0aW9uIGNsYXNzXG4gKi9cbmNsYXNzIFRyYW5zYWN0aW9uSW5zdHJ1Y3Rpb24ge1xuICBjb25zdHJ1Y3RvcihvcHRzKSB7XG4gICAgLyoqXG4gICAgICogUHVibGljIGtleXMgdG8gaW5jbHVkZSBpbiB0aGlzIHRyYW5zYWN0aW9uXG4gICAgICogQm9vbGVhbiByZXByZXNlbnRzIHdoZXRoZXIgdGhpcyBwdWJrZXkgbmVlZHMgdG8gc2lnbiB0aGUgdHJhbnNhY3Rpb25cbiAgICAgKi9cbiAgICB0aGlzLmtleXMgPSB2b2lkIDA7XG4gICAgLyoqXG4gICAgICogUHJvZ3JhbSBJZCB0byBleGVjdXRlXG4gICAgICovXG4gICAgdGhpcy5wcm9ncmFtSWQgPSB2b2lkIDA7XG4gICAgLyoqXG4gICAgICogUHJvZ3JhbSBpbnB1dFxuICAgICAqL1xuICAgIHRoaXMuZGF0YSA9IEJ1ZmZlci5hbGxvYygwKTtcbiAgICB0aGlzLnByb2dyYW1JZCA9IG9wdHMucHJvZ3JhbUlkO1xuICAgIHRoaXMua2V5cyA9IG9wdHMua2V5cztcbiAgICBpZiAob3B0cy5kYXRhKSB7XG4gICAgICB0aGlzLmRhdGEgPSBvcHRzLmRhdGE7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgdG9KU09OKCkge1xuICAgIHJldHVybiB7XG4gICAgICBrZXlzOiB0aGlzLmtleXMubWFwKCh7XG4gICAgICAgIHB1YmtleSxcbiAgICAgICAgaXNTaWduZXIsXG4gICAgICAgIGlzV3JpdGFibGVcbiAgICAgIH0pID0+ICh7XG4gICAgICAgIHB1YmtleTogcHVia2V5LnRvSlNPTigpLFxuICAgICAgICBpc1NpZ25lcixcbiAgICAgICAgaXNXcml0YWJsZVxuICAgICAgfSkpLFxuICAgICAgcHJvZ3JhbUlkOiB0aGlzLnByb2dyYW1JZC50b0pTT04oKSxcbiAgICAgIGRhdGE6IFsuLi50aGlzLmRhdGFdXG4gICAgfTtcbiAgfVxufVxuXG4vKipcbiAqIFBhaXIgb2Ygc2lnbmF0dXJlIGFuZCBjb3JyZXNwb25kaW5nIHB1YmxpYyBrZXlcbiAqL1xuXG4vKipcbiAqIExpc3Qgb2YgVHJhbnNhY3Rpb24gb2JqZWN0IGZpZWxkcyB0aGF0IG1heSBiZSBpbml0aWFsaXplZCBhdCBjb25zdHJ1Y3Rpb25cbiAqL1xuXG4vLyBGb3IgYmFja3dhcmQgY29tcGF0aWJpbGl0eTsgYW4gdW5mb3J0dW5hdGUgY29uc2VxdWVuY2Ugb2YgYmVpbmdcbi8vIGZvcmNlZCB0byBvdmVyLWV4cG9ydCB0eXBlcyBieSB0aGUgZG9jdW1lbnRhdGlvbiBnZW5lcmF0b3IuXG4vLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL3NvbGFuYS1sYWJzL3NvbGFuYS9wdWxsLzI1ODIwXG5cbi8qKlxuICogQmxvY2toYXNoLWJhc2VkIHRyYW5zYWN0aW9ucyBoYXZlIGEgbGlmZXRpbWUgdGhhdCBhcmUgZGVmaW5lZCBieVxuICogdGhlIGJsb2NraGFzaCB0aGV5IGluY2x1ZGUuIEFueSB0cmFuc2FjdGlvbiB3aG9zZSBibG9ja2hhc2ggaXNcbiAqIHRvbyBvbGQgd2lsbCBiZSByZWplY3RlZC5cbiAqL1xuXG4vKipcbiAqIFVzZSB0aGVzZSBvcHRpb25zIHRvIGNvbnN0cnVjdCBhIGR1cmFibGUgbm9uY2UgdHJhbnNhY3Rpb24uXG4gKi9cblxuLyoqXG4gKiBOb25jZSBpbmZvcm1hdGlvbiB0byBiZSB1c2VkIHRvIGJ1aWxkIGFuIG9mZmxpbmUgVHJhbnNhY3Rpb24uXG4gKi9cblxuLyoqXG4gKiBAaW50ZXJuYWxcbiAqL1xuXG4vKipcbiAqIFRyYW5zYWN0aW9uIGNsYXNzXG4gKi9cbmNsYXNzIFRyYW5zYWN0aW9uIHtcbiAgLyoqXG4gICAqIFRoZSBmaXJzdCAocGF5ZXIpIFRyYW5zYWN0aW9uIHNpZ25hdHVyZVxuICAgKlxuICAgKiBAcmV0dXJucyB7QnVmZmVyIHwgbnVsbH0gQnVmZmVyIG9mIHBheWVyJ3Mgc2lnbmF0dXJlXG4gICAqL1xuICBnZXQgc2lnbmF0dXJlKCkge1xuICAgIGlmICh0aGlzLnNpZ25hdHVyZXMubGVuZ3RoID4gMCkge1xuICAgICAgcmV0dXJuIHRoaXMuc2lnbmF0dXJlc1swXS5zaWduYXR1cmU7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgLyoqXG4gICAqIFRoZSB0cmFuc2FjdGlvbiBmZWUgcGF5ZXJcbiAgICovXG5cbiAgLy8gQ29uc3RydWN0IGEgdHJhbnNhY3Rpb24gd2l0aCBhIGJsb2NraGFzaCBhbmQgbGFzdFZhbGlkQmxvY2tIZWlnaHRcblxuICAvLyBDb25zdHJ1Y3QgYSB0cmFuc2FjdGlvbiB1c2luZyBhIGR1cmFibGUgbm9uY2VcblxuICAvKipcbiAgICogQGRlcHJlY2F0ZWQgYFRyYW5zYWN0aW9uQ3RvckZpZWxkc2AgaGFzIGJlZW4gZGVwcmVjYXRlZCBhbmQgd2lsbCBiZSByZW1vdmVkIGluIGEgZnV0dXJlIHZlcnNpb24uXG4gICAqIFBsZWFzZSBzdXBwbHkgYSBgVHJhbnNhY3Rpb25CbG9ja2hhc2hDdG9yYCBpbnN0ZWFkLlxuICAgKi9cblxuICAvKipcbiAgICogQ29uc3RydWN0IGFuIGVtcHR5IFRyYW5zYWN0aW9uXG4gICAqL1xuICBjb25zdHJ1Y3RvcihvcHRzKSB7XG4gICAgLyoqXG4gICAgICogU2lnbmF0dXJlcyBmb3IgdGhlIHRyYW5zYWN0aW9uLiAgVHlwaWNhbGx5IGNyZWF0ZWQgYnkgaW52b2tpbmcgdGhlXG4gICAgICogYHNpZ24oKWAgbWV0aG9kXG4gICAgICovXG4gICAgdGhpcy5zaWduYXR1cmVzID0gW107XG4gICAgdGhpcy5mZWVQYXllciA9IHZvaWQgMDtcbiAgICAvKipcbiAgICAgKiBUaGUgaW5zdHJ1Y3Rpb25zIHRvIGF0b21pY2FsbHkgZXhlY3V0ZVxuICAgICAqL1xuICAgIHRoaXMuaW5zdHJ1Y3Rpb25zID0gW107XG4gICAgLyoqXG4gICAgICogQSByZWNlbnQgdHJhbnNhY3Rpb24gaWQuIE11c3QgYmUgcG9wdWxhdGVkIGJ5IHRoZSBjYWxsZXJcbiAgICAgKi9cbiAgICB0aGlzLnJlY2VudEJsb2NraGFzaCA9IHZvaWQgMDtcbiAgICAvKipcbiAgICAgKiB0aGUgbGFzdCBibG9jayBjaGFpbiBjYW4gYWR2YW5jZSB0byBiZWZvcmUgdHggaXMgZGVjbGFyZWQgZXhwaXJlZFxuICAgICAqICovXG4gICAgdGhpcy5sYXN0VmFsaWRCbG9ja0hlaWdodCA9IHZvaWQgMDtcbiAgICAvKipcbiAgICAgKiBPcHRpb25hbCBOb25jZSBpbmZvcm1hdGlvbi4gSWYgcG9wdWxhdGVkLCB0cmFuc2FjdGlvbiB3aWxsIHVzZSBhIGR1cmFibGVcbiAgICAgKiBOb25jZSBoYXNoIGluc3RlYWQgb2YgYSByZWNlbnRCbG9ja2hhc2guIE11c3QgYmUgcG9wdWxhdGVkIGJ5IHRoZSBjYWxsZXJcbiAgICAgKi9cbiAgICB0aGlzLm5vbmNlSW5mbyA9IHZvaWQgMDtcbiAgICAvKipcbiAgICAgKiBJZiB0aGlzIGlzIGEgbm9uY2UgdHJhbnNhY3Rpb24gdGhpcyByZXByZXNlbnRzIHRoZSBtaW5pbXVtIHNsb3QgZnJvbSB3aGljaFxuICAgICAqIHRvIGV2YWx1YXRlIGlmIHRoZSBub25jZSBoYXMgYWR2YW5jZWQgd2hlbiBhdHRlbXB0aW5nIHRvIGNvbmZpcm0gdGhlXG4gICAgICogdHJhbnNhY3Rpb24uIFRoaXMgcHJvdGVjdHMgYWdhaW5zdCBhIGNhc2Ugd2hlcmUgdGhlIHRyYW5zYWN0aW9uIGNvbmZpcm1hdGlvblxuICAgICAqIGxvZ2ljIGxvYWRzIHRoZSBub25jZSBhY2NvdW50IGZyb20gYW4gb2xkIHNsb3QgYW5kIGFzc3VtZXMgdGhlIG1pc21hdGNoIGluXG4gICAgICogbm9uY2UgdmFsdWUgaW1wbGllcyB0aGF0IHRoZSBub25jZSBoYXMgYmVlbiBhZHZhbmNlZC5cbiAgICAgKi9cbiAgICB0aGlzLm1pbk5vbmNlQ29udGV4dFNsb3QgPSB2b2lkIDA7XG4gICAgLyoqXG4gICAgICogQGludGVybmFsXG4gICAgICovXG4gICAgdGhpcy5fbWVzc2FnZSA9IHZvaWQgMDtcbiAgICAvKipcbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICB0aGlzLl9qc29uID0gdm9pZCAwO1xuICAgIGlmICghb3B0cykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAob3B0cy5mZWVQYXllcikge1xuICAgICAgdGhpcy5mZWVQYXllciA9IG9wdHMuZmVlUGF5ZXI7XG4gICAgfVxuICAgIGlmIChvcHRzLnNpZ25hdHVyZXMpIHtcbiAgICAgIHRoaXMuc2lnbmF0dXJlcyA9IG9wdHMuc2lnbmF0dXJlcztcbiAgICB9XG4gICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvcHRzLCAnbm9uY2VJbmZvJykpIHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgbWluQ29udGV4dFNsb3QsXG4gICAgICAgIG5vbmNlSW5mb1xuICAgICAgfSA9IG9wdHM7XG4gICAgICB0aGlzLm1pbk5vbmNlQ29udGV4dFNsb3QgPSBtaW5Db250ZXh0U2xvdDtcbiAgICAgIHRoaXMubm9uY2VJbmZvID0gbm9uY2VJbmZvO1xuICAgIH0gZWxzZSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9wdHMsICdsYXN0VmFsaWRCbG9ja0hlaWdodCcpKSB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIGJsb2NraGFzaCxcbiAgICAgICAgbGFzdFZhbGlkQmxvY2tIZWlnaHRcbiAgICAgIH0gPSBvcHRzO1xuICAgICAgdGhpcy5yZWNlbnRCbG9ja2hhc2ggPSBibG9ja2hhc2g7XG4gICAgICB0aGlzLmxhc3RWYWxpZEJsb2NrSGVpZ2h0ID0gbGFzdFZhbGlkQmxvY2tIZWlnaHQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgcmVjZW50QmxvY2toYXNoLFxuICAgICAgICBub25jZUluZm9cbiAgICAgIH0gPSBvcHRzO1xuICAgICAgaWYgKG5vbmNlSW5mbykge1xuICAgICAgICB0aGlzLm5vbmNlSW5mbyA9IG5vbmNlSW5mbztcbiAgICAgIH1cbiAgICAgIHRoaXMucmVjZW50QmxvY2toYXNoID0gcmVjZW50QmxvY2toYXNoO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIHRvSlNPTigpIHtcbiAgICByZXR1cm4ge1xuICAgICAgcmVjZW50QmxvY2toYXNoOiB0aGlzLnJlY2VudEJsb2NraGFzaCB8fCBudWxsLFxuICAgICAgZmVlUGF5ZXI6IHRoaXMuZmVlUGF5ZXIgPyB0aGlzLmZlZVBheWVyLnRvSlNPTigpIDogbnVsbCxcbiAgICAgIG5vbmNlSW5mbzogdGhpcy5ub25jZUluZm8gPyB7XG4gICAgICAgIG5vbmNlOiB0aGlzLm5vbmNlSW5mby5ub25jZSxcbiAgICAgICAgbm9uY2VJbnN0cnVjdGlvbjogdGhpcy5ub25jZUluZm8ubm9uY2VJbnN0cnVjdGlvbi50b0pTT04oKVxuICAgICAgfSA6IG51bGwsXG4gICAgICBpbnN0cnVjdGlvbnM6IHRoaXMuaW5zdHJ1Y3Rpb25zLm1hcChpbnN0cnVjdGlvbiA9PiBpbnN0cnVjdGlvbi50b0pTT04oKSksXG4gICAgICBzaWduZXJzOiB0aGlzLnNpZ25hdHVyZXMubWFwKCh7XG4gICAgICAgIHB1YmxpY0tleVxuICAgICAgfSkgPT4ge1xuICAgICAgICByZXR1cm4gcHVibGljS2V5LnRvSlNPTigpO1xuICAgICAgfSlcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIEFkZCBvbmUgb3IgbW9yZSBpbnN0cnVjdGlvbnMgdG8gdGhpcyBUcmFuc2FjdGlvblxuICAgKlxuICAgKiBAcGFyYW0ge0FycmF5PCBUcmFuc2FjdGlvbiB8IFRyYW5zYWN0aW9uSW5zdHJ1Y3Rpb24gfCBUcmFuc2FjdGlvbkluc3RydWN0aW9uQ3RvckZpZWxkcyA+fSBpdGVtcyAtIEluc3RydWN0aW9ucyB0byBhZGQgdG8gdGhlIFRyYW5zYWN0aW9uXG4gICAqL1xuICBhZGQoLi4uaXRlbXMpIHtcbiAgICBpZiAoaXRlbXMubGVuZ3RoID09PSAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIGluc3RydWN0aW9ucycpO1xuICAgIH1cbiAgICBpdGVtcy5mb3JFYWNoKGl0ZW0gPT4ge1xuICAgICAgaWYgKCdpbnN0cnVjdGlvbnMnIGluIGl0ZW0pIHtcbiAgICAgICAgdGhpcy5pbnN0cnVjdGlvbnMgPSB0aGlzLmluc3RydWN0aW9ucy5jb25jYXQoaXRlbS5pbnN0cnVjdGlvbnMpO1xuICAgICAgfSBlbHNlIGlmICgnZGF0YScgaW4gaXRlbSAmJiAncHJvZ3JhbUlkJyBpbiBpdGVtICYmICdrZXlzJyBpbiBpdGVtKSB7XG4gICAgICAgIHRoaXMuaW5zdHJ1Y3Rpb25zLnB1c2goaXRlbSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmluc3RydWN0aW9ucy5wdXNoKG5ldyBUcmFuc2FjdGlvbkluc3RydWN0aW9uKGl0ZW0pKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBDb21waWxlIHRyYW5zYWN0aW9uIGRhdGFcbiAgICovXG4gIGNvbXBpbGVNZXNzYWdlKCkge1xuICAgIGlmICh0aGlzLl9tZXNzYWdlICYmIEpTT04uc3RyaW5naWZ5KHRoaXMudG9KU09OKCkpID09PSBKU09OLnN0cmluZ2lmeSh0aGlzLl9qc29uKSkge1xuICAgICAgcmV0dXJuIHRoaXMuX21lc3NhZ2U7XG4gICAgfVxuICAgIGxldCByZWNlbnRCbG9ja2hhc2g7XG4gICAgbGV0IGluc3RydWN0aW9ucztcbiAgICBpZiAodGhpcy5ub25jZUluZm8pIHtcbiAgICAgIHJlY2VudEJsb2NraGFzaCA9IHRoaXMubm9uY2VJbmZvLm5vbmNlO1xuICAgICAgaWYgKHRoaXMuaW5zdHJ1Y3Rpb25zWzBdICE9IHRoaXMubm9uY2VJbmZvLm5vbmNlSW5zdHJ1Y3Rpb24pIHtcbiAgICAgICAgaW5zdHJ1Y3Rpb25zID0gW3RoaXMubm9uY2VJbmZvLm5vbmNlSW5zdHJ1Y3Rpb24sIC4uLnRoaXMuaW5zdHJ1Y3Rpb25zXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGluc3RydWN0aW9ucyA9IHRoaXMuaW5zdHJ1Y3Rpb25zO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICByZWNlbnRCbG9ja2hhc2ggPSB0aGlzLnJlY2VudEJsb2NraGFzaDtcbiAgICAgIGluc3RydWN0aW9ucyA9IHRoaXMuaW5zdHJ1Y3Rpb25zO1xuICAgIH1cbiAgICBpZiAoIXJlY2VudEJsb2NraGFzaCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdUcmFuc2FjdGlvbiByZWNlbnRCbG9ja2hhc2ggcmVxdWlyZWQnKTtcbiAgICB9XG4gICAgaWYgKGluc3RydWN0aW9ucy5sZW5ndGggPCAxKSB7XG4gICAgICBjb25zb2xlLndhcm4oJ05vIGluc3RydWN0aW9ucyBwcm92aWRlZCcpO1xuICAgIH1cbiAgICBsZXQgZmVlUGF5ZXI7XG4gICAgaWYgKHRoaXMuZmVlUGF5ZXIpIHtcbiAgICAgIGZlZVBheWVyID0gdGhpcy5mZWVQYXllcjtcbiAgICB9IGVsc2UgaWYgKHRoaXMuc2lnbmF0dXJlcy5sZW5ndGggPiAwICYmIHRoaXMuc2lnbmF0dXJlc1swXS5wdWJsaWNLZXkpIHtcbiAgICAgIC8vIFVzZSBpbXBsaWNpdCBmZWUgcGF5ZXJcbiAgICAgIGZlZVBheWVyID0gdGhpcy5zaWduYXR1cmVzWzBdLnB1YmxpY0tleTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdUcmFuc2FjdGlvbiBmZWUgcGF5ZXIgcmVxdWlyZWQnKTtcbiAgICB9XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBpbnN0cnVjdGlvbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChpbnN0cnVjdGlvbnNbaV0ucHJvZ3JhbUlkID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBUcmFuc2FjdGlvbiBpbnN0cnVjdGlvbiBpbmRleCAke2l9IGhhcyB1bmRlZmluZWQgcHJvZ3JhbSBpZGApO1xuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBwcm9ncmFtSWRzID0gW107XG4gICAgY29uc3QgYWNjb3VudE1ldGFzID0gW107XG4gICAgaW5zdHJ1Y3Rpb25zLmZvckVhY2goaW5zdHJ1Y3Rpb24gPT4ge1xuICAgICAgaW5zdHJ1Y3Rpb24ua2V5cy5mb3JFYWNoKGFjY291bnRNZXRhID0+IHtcbiAgICAgICAgYWNjb3VudE1ldGFzLnB1c2goe1xuICAgICAgICAgIC4uLmFjY291bnRNZXRhXG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgICBjb25zdCBwcm9ncmFtSWQgPSBpbnN0cnVjdGlvbi5wcm9ncmFtSWQudG9TdHJpbmcoKTtcbiAgICAgIGlmICghcHJvZ3JhbUlkcy5pbmNsdWRlcyhwcm9ncmFtSWQpKSB7XG4gICAgICAgIHByb2dyYW1JZHMucHVzaChwcm9ncmFtSWQpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgLy8gQXBwZW5kIHByb2dyYW1JRCBhY2NvdW50IG1ldGFzXG4gICAgcHJvZ3JhbUlkcy5mb3JFYWNoKHByb2dyYW1JZCA9PiB7XG4gICAgICBhY2NvdW50TWV0YXMucHVzaCh7XG4gICAgICAgIHB1YmtleTogbmV3IFB1YmxpY0tleShwcm9ncmFtSWQpLFxuICAgICAgICBpc1NpZ25lcjogZmFsc2UsXG4gICAgICAgIGlzV3JpdGFibGU6IGZhbHNlXG4gICAgICB9KTtcbiAgICB9KTtcblxuICAgIC8vIEN1bGwgZHVwbGljYXRlIGFjY291bnQgbWV0YXNcbiAgICBjb25zdCB1bmlxdWVNZXRhcyA9IFtdO1xuICAgIGFjY291bnRNZXRhcy5mb3JFYWNoKGFjY291bnRNZXRhID0+IHtcbiAgICAgIGNvbnN0IHB1YmtleVN0cmluZyA9IGFjY291bnRNZXRhLnB1YmtleS50b1N0cmluZygpO1xuICAgICAgY29uc3QgdW5pcXVlSW5kZXggPSB1bmlxdWVNZXRhcy5maW5kSW5kZXgoeCA9PiB7XG4gICAgICAgIHJldHVybiB4LnB1YmtleS50b1N0cmluZygpID09PSBwdWJrZXlTdHJpbmc7XG4gICAgICB9KTtcbiAgICAgIGlmICh1bmlxdWVJbmRleCA+IC0xKSB7XG4gICAgICAgIHVuaXF1ZU1ldGFzW3VuaXF1ZUluZGV4XS5pc1dyaXRhYmxlID0gdW5pcXVlTWV0YXNbdW5pcXVlSW5kZXhdLmlzV3JpdGFibGUgfHwgYWNjb3VudE1ldGEuaXNXcml0YWJsZTtcbiAgICAgICAgdW5pcXVlTWV0YXNbdW5pcXVlSW5kZXhdLmlzU2lnbmVyID0gdW5pcXVlTWV0YXNbdW5pcXVlSW5kZXhdLmlzU2lnbmVyIHx8IGFjY291bnRNZXRhLmlzU2lnbmVyO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdW5pcXVlTWV0YXMucHVzaChhY2NvdW50TWV0YSk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICAvLyBTb3J0LiBQcmlvcml0aXppbmcgZmlyc3QgYnkgc2lnbmVyLCB0aGVuIGJ5IHdyaXRhYmxlXG4gICAgdW5pcXVlTWV0YXMuc29ydChmdW5jdGlvbiAoeCwgeSkge1xuICAgICAgaWYgKHguaXNTaWduZXIgIT09IHkuaXNTaWduZXIpIHtcbiAgICAgICAgLy8gU2lnbmVycyBhbHdheXMgY29tZSBiZWZvcmUgbm9uLXNpZ25lcnNcbiAgICAgICAgcmV0dXJuIHguaXNTaWduZXIgPyAtMSA6IDE7XG4gICAgICB9XG4gICAgICBpZiAoeC5pc1dyaXRhYmxlICE9PSB5LmlzV3JpdGFibGUpIHtcbiAgICAgICAgLy8gV3JpdGFibGUgYWNjb3VudHMgYWx3YXlzIGNvbWUgYmVmb3JlIHJlYWQtb25seSBhY2NvdW50c1xuICAgICAgICByZXR1cm4geC5pc1dyaXRhYmxlID8gLTEgOiAxO1xuICAgICAgfVxuICAgICAgLy8gT3RoZXJ3aXNlLCBzb3J0IGJ5IHB1YmtleSwgc3RyaW5nd2lzZS5cbiAgICAgIGNvbnN0IG9wdGlvbnMgPSB7XG4gICAgICAgIGxvY2FsZU1hdGNoZXI6ICdiZXN0IGZpdCcsXG4gICAgICAgIHVzYWdlOiAnc29ydCcsXG4gICAgICAgIHNlbnNpdGl2aXR5OiAndmFyaWFudCcsXG4gICAgICAgIGlnbm9yZVB1bmN0dWF0aW9uOiBmYWxzZSxcbiAgICAgICAgbnVtZXJpYzogZmFsc2UsXG4gICAgICAgIGNhc2VGaXJzdDogJ2xvd2VyJ1xuICAgICAgfTtcbiAgICAgIHJldHVybiB4LnB1YmtleS50b0Jhc2U1OCgpLmxvY2FsZUNvbXBhcmUoeS5wdWJrZXkudG9CYXNlNTgoKSwgJ2VuJywgb3B0aW9ucyk7XG4gICAgfSk7XG5cbiAgICAvLyBNb3ZlIGZlZSBwYXllciB0byB0aGUgZnJvbnRcbiAgICBjb25zdCBmZWVQYXllckluZGV4ID0gdW5pcXVlTWV0YXMuZmluZEluZGV4KHggPT4ge1xuICAgICAgcmV0dXJuIHgucHVia2V5LmVxdWFscyhmZWVQYXllcik7XG4gICAgfSk7XG4gICAgaWYgKGZlZVBheWVySW5kZXggPiAtMSkge1xuICAgICAgY29uc3QgW3BheWVyTWV0YV0gPSB1bmlxdWVNZXRhcy5zcGxpY2UoZmVlUGF5ZXJJbmRleCwgMSk7XG4gICAgICBwYXllck1ldGEuaXNTaWduZXIgPSB0cnVlO1xuICAgICAgcGF5ZXJNZXRhLmlzV3JpdGFibGUgPSB0cnVlO1xuICAgICAgdW5pcXVlTWV0YXMudW5zaGlmdChwYXllck1ldGEpO1xuICAgIH0gZWxzZSB7XG4gICAgICB1bmlxdWVNZXRhcy51bnNoaWZ0KHtcbiAgICAgICAgcHVia2V5OiBmZWVQYXllcixcbiAgICAgICAgaXNTaWduZXI6IHRydWUsXG4gICAgICAgIGlzV3JpdGFibGU6IHRydWVcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIC8vIERpc2FsbG93IHVua25vd24gc2lnbmVyc1xuICAgIGZvciAoY29uc3Qgc2lnbmF0dXJlIG9mIHRoaXMuc2lnbmF0dXJlcykge1xuICAgICAgY29uc3QgdW5pcXVlSW5kZXggPSB1bmlxdWVNZXRhcy5maW5kSW5kZXgoeCA9PiB7XG4gICAgICAgIHJldHVybiB4LnB1YmtleS5lcXVhbHMoc2lnbmF0dXJlLnB1YmxpY0tleSk7XG4gICAgICB9KTtcbiAgICAgIGlmICh1bmlxdWVJbmRleCA+IC0xKSB7XG4gICAgICAgIGlmICghdW5pcXVlTWV0YXNbdW5pcXVlSW5kZXhdLmlzU2lnbmVyKSB7XG4gICAgICAgICAgdW5pcXVlTWV0YXNbdW5pcXVlSW5kZXhdLmlzU2lnbmVyID0gdHJ1ZTtcbiAgICAgICAgICBjb25zb2xlLndhcm4oJ1RyYW5zYWN0aW9uIHJlZmVyZW5jZXMgYSBzaWduYXR1cmUgdGhhdCBpcyB1bm5lY2Vzc2FyeSwgJyArICdvbmx5IHRoZSBmZWUgcGF5ZXIgYW5kIGluc3RydWN0aW9uIHNpZ25lciBhY2NvdW50cyBzaG91bGQgc2lnbiBhIHRyYW5zYWN0aW9uLiAnICsgJ1RoaXMgYmVoYXZpb3IgaXMgZGVwcmVjYXRlZCBhbmQgd2lsbCB0aHJvdyBhbiBlcnJvciBpbiB0aGUgbmV4dCBtYWpvciB2ZXJzaW9uIHJlbGVhc2UuJyk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgdW5rbm93biBzaWduZXI6ICR7c2lnbmF0dXJlLnB1YmxpY0tleS50b1N0cmluZygpfWApO1xuICAgICAgfVxuICAgIH1cbiAgICBsZXQgbnVtUmVxdWlyZWRTaWduYXR1cmVzID0gMDtcbiAgICBsZXQgbnVtUmVhZG9ubHlTaWduZWRBY2NvdW50cyA9IDA7XG4gICAgbGV0IG51bVJlYWRvbmx5VW5zaWduZWRBY2NvdW50cyA9IDA7XG5cbiAgICAvLyBTcGxpdCBvdXQgc2lnbmluZyBmcm9tIG5vbi1zaWduaW5nIGtleXMgYW5kIGNvdW50IGhlYWRlciB2YWx1ZXNcbiAgICBjb25zdCBzaWduZWRLZXlzID0gW107XG4gICAgY29uc3QgdW5zaWduZWRLZXlzID0gW107XG4gICAgdW5pcXVlTWV0YXMuZm9yRWFjaCgoe1xuICAgICAgcHVia2V5LFxuICAgICAgaXNTaWduZXIsXG4gICAgICBpc1dyaXRhYmxlXG4gICAgfSkgPT4ge1xuICAgICAgaWYgKGlzU2lnbmVyKSB7XG4gICAgICAgIHNpZ25lZEtleXMucHVzaChwdWJrZXkudG9TdHJpbmcoKSk7XG4gICAgICAgIG51bVJlcXVpcmVkU2lnbmF0dXJlcyArPSAxO1xuICAgICAgICBpZiAoIWlzV3JpdGFibGUpIHtcbiAgICAgICAgICBudW1SZWFkb25seVNpZ25lZEFjY291bnRzICs9IDE7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHVuc2lnbmVkS2V5cy5wdXNoKHB1YmtleS50b1N0cmluZygpKTtcbiAgICAgICAgaWYgKCFpc1dyaXRhYmxlKSB7XG4gICAgICAgICAgbnVtUmVhZG9ubHlVbnNpZ25lZEFjY291bnRzICs9IDE7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgICBjb25zdCBhY2NvdW50S2V5cyA9IHNpZ25lZEtleXMuY29uY2F0KHVuc2lnbmVkS2V5cyk7XG4gICAgY29uc3QgY29tcGlsZWRJbnN0cnVjdGlvbnMgPSBpbnN0cnVjdGlvbnMubWFwKGluc3RydWN0aW9uID0+IHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgZGF0YSxcbiAgICAgICAgcHJvZ3JhbUlkXG4gICAgICB9ID0gaW5zdHJ1Y3Rpb247XG4gICAgICByZXR1cm4ge1xuICAgICAgICBwcm9ncmFtSWRJbmRleDogYWNjb3VudEtleXMuaW5kZXhPZihwcm9ncmFtSWQudG9TdHJpbmcoKSksXG4gICAgICAgIGFjY291bnRzOiBpbnN0cnVjdGlvbi5rZXlzLm1hcChtZXRhID0+IGFjY291bnRLZXlzLmluZGV4T2YobWV0YS5wdWJrZXkudG9TdHJpbmcoKSkpLFxuICAgICAgICBkYXRhOiBiczU4LmVuY29kZShkYXRhKVxuICAgICAgfTtcbiAgICB9KTtcbiAgICBjb21waWxlZEluc3RydWN0aW9ucy5mb3JFYWNoKGluc3RydWN0aW9uID0+IHtcbiAgICAgIGFzc2VydChpbnN0cnVjdGlvbi5wcm9ncmFtSWRJbmRleCA+PSAwKTtcbiAgICAgIGluc3RydWN0aW9uLmFjY291bnRzLmZvckVhY2goa2V5SW5kZXggPT4gYXNzZXJ0KGtleUluZGV4ID49IDApKTtcbiAgICB9KTtcbiAgICByZXR1cm4gbmV3IE1lc3NhZ2Uoe1xuICAgICAgaGVhZGVyOiB7XG4gICAgICAgIG51bVJlcXVpcmVkU2lnbmF0dXJlcyxcbiAgICAgICAgbnVtUmVhZG9ubHlTaWduZWRBY2NvdW50cyxcbiAgICAgICAgbnVtUmVhZG9ubHlVbnNpZ25lZEFjY291bnRzXG4gICAgICB9LFxuICAgICAgYWNjb3VudEtleXMsXG4gICAgICByZWNlbnRCbG9ja2hhc2gsXG4gICAgICBpbnN0cnVjdGlvbnM6IGNvbXBpbGVkSW5zdHJ1Y3Rpb25zXG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogQGludGVybmFsXG4gICAqL1xuICBfY29tcGlsZSgpIHtcbiAgICBjb25zdCBtZXNzYWdlID0gdGhpcy5jb21waWxlTWVzc2FnZSgpO1xuICAgIGNvbnN0IHNpZ25lZEtleXMgPSBtZXNzYWdlLmFjY291bnRLZXlzLnNsaWNlKDAsIG1lc3NhZ2UuaGVhZGVyLm51bVJlcXVpcmVkU2lnbmF0dXJlcyk7XG4gICAgaWYgKHRoaXMuc2lnbmF0dXJlcy5sZW5ndGggPT09IHNpZ25lZEtleXMubGVuZ3RoKSB7XG4gICAgICBjb25zdCB2YWxpZCA9IHRoaXMuc2lnbmF0dXJlcy5ldmVyeSgocGFpciwgaW5kZXgpID0+IHtcbiAgICAgICAgcmV0dXJuIHNpZ25lZEtleXNbaW5kZXhdLmVxdWFscyhwYWlyLnB1YmxpY0tleSk7XG4gICAgICB9KTtcbiAgICAgIGlmICh2YWxpZCkgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfVxuICAgIHRoaXMuc2lnbmF0dXJlcyA9IHNpZ25lZEtleXMubWFwKHB1YmxpY0tleSA9PiAoe1xuICAgICAgc2lnbmF0dXJlOiBudWxsLFxuICAgICAgcHVibGljS2V5XG4gICAgfSkpO1xuICAgIHJldHVybiBtZXNzYWdlO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCBhIGJ1ZmZlciBvZiB0aGUgVHJhbnNhY3Rpb24gZGF0YSB0aGF0IG5lZWQgdG8gYmUgY292ZXJlZCBieSBzaWduYXR1cmVzXG4gICAqL1xuICBzZXJpYWxpemVNZXNzYWdlKCkge1xuICAgIHJldHVybiB0aGlzLl9jb21waWxlKCkuc2VyaWFsaXplKCk7XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBlc3RpbWF0ZWQgZmVlIGFzc29jaWF0ZWQgd2l0aCBhIHRyYW5zYWN0aW9uXG4gICAqXG4gICAqIEBwYXJhbSB7Q29ubmVjdGlvbn0gY29ubmVjdGlvbiBDb25uZWN0aW9uIHRvIFJQQyBFbmRwb2ludC5cbiAgICpcbiAgICogQHJldHVybnMge1Byb21pc2U8bnVtYmVyIHwgbnVsbD59IFRoZSBlc3RpbWF0ZWQgZmVlIGZvciB0aGUgdHJhbnNhY3Rpb25cbiAgICovXG4gIGFzeW5jIGdldEVzdGltYXRlZEZlZShjb25uZWN0aW9uKSB7XG4gICAgcmV0dXJuIChhd2FpdCBjb25uZWN0aW9uLmdldEZlZUZvck1lc3NhZ2UodGhpcy5jb21waWxlTWVzc2FnZSgpKSkudmFsdWU7XG4gIH1cblxuICAvKipcbiAgICogU3BlY2lmeSB0aGUgcHVibGljIGtleXMgd2hpY2ggd2lsbCBiZSB1c2VkIHRvIHNpZ24gdGhlIFRyYW5zYWN0aW9uLlxuICAgKiBUaGUgZmlyc3Qgc2lnbmVyIHdpbGwgYmUgdXNlZCBhcyB0aGUgdHJhbnNhY3Rpb24gZmVlIHBheWVyIGFjY291bnQuXG4gICAqXG4gICAqIFNpZ25hdHVyZXMgY2FuIGJlIGFkZGVkIHdpdGggZWl0aGVyIGBwYXJ0aWFsU2lnbmAgb3IgYGFkZFNpZ25hdHVyZWBcbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgRGVwcmVjYXRlZCBzaW5jZSB2MC44NC4wLiBPbmx5IHRoZSBmZWUgcGF5ZXIgbmVlZHMgdG8gYmVcbiAgICogc3BlY2lmaWVkIGFuZCBpdCBjYW4gYmUgc2V0IGluIHRoZSBUcmFuc2FjdGlvbiBjb25zdHJ1Y3RvciBvciB3aXRoIHRoZVxuICAgKiBgZmVlUGF5ZXJgIHByb3BlcnR5LlxuICAgKi9cbiAgc2V0U2lnbmVycyguLi5zaWduZXJzKSB7XG4gICAgaWYgKHNpZ25lcnMubGVuZ3RoID09PSAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIHNpZ25lcnMnKTtcbiAgICB9XG4gICAgY29uc3Qgc2VlbiA9IG5ldyBTZXQoKTtcbiAgICB0aGlzLnNpZ25hdHVyZXMgPSBzaWduZXJzLmZpbHRlcihwdWJsaWNLZXkgPT4ge1xuICAgICAgY29uc3Qga2V5ID0gcHVibGljS2V5LnRvU3RyaW5nKCk7XG4gICAgICBpZiAoc2Vlbi5oYXMoa2V5KSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzZWVuLmFkZChrZXkpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9KS5tYXAocHVibGljS2V5ID0+ICh7XG4gICAgICBzaWduYXR1cmU6IG51bGwsXG4gICAgICBwdWJsaWNLZXlcbiAgICB9KSk7XG4gIH1cblxuICAvKipcbiAgICogU2lnbiB0aGUgVHJhbnNhY3Rpb24gd2l0aCB0aGUgc3BlY2lmaWVkIHNpZ25lcnMuIE11bHRpcGxlIHNpZ25hdHVyZXMgbWF5XG4gICAqIGJlIGFwcGxpZWQgdG8gYSBUcmFuc2FjdGlvbi4gVGhlIGZpcnN0IHNpZ25hdHVyZSBpcyBjb25zaWRlcmVkIFwicHJpbWFyeVwiXG4gICAqIGFuZCBpcyB1c2VkIGlkZW50aWZ5IGFuZCBjb25maXJtIHRyYW5zYWN0aW9ucy5cbiAgICpcbiAgICogSWYgdGhlIFRyYW5zYWN0aW9uIGBmZWVQYXllcmAgaXMgbm90IHNldCwgdGhlIGZpcnN0IHNpZ25lciB3aWxsIGJlIHVzZWRcbiAgICogYXMgdGhlIHRyYW5zYWN0aW9uIGZlZSBwYXllciBhY2NvdW50LlxuICAgKlxuICAgKiBUcmFuc2FjdGlvbiBmaWVsZHMgc2hvdWxkIG5vdCBiZSBtb2RpZmllZCBhZnRlciB0aGUgZmlyc3QgY2FsbCB0byBgc2lnbmAsXG4gICAqIGFzIGRvaW5nIHNvIG1heSBpbnZhbGlkYXRlIHRoZSBzaWduYXR1cmUgYW5kIGNhdXNlIHRoZSBUcmFuc2FjdGlvbiB0byBiZVxuICAgKiByZWplY3RlZC5cbiAgICpcbiAgICogVGhlIFRyYW5zYWN0aW9uIG11c3QgYmUgYXNzaWduZWQgYSB2YWxpZCBgcmVjZW50QmxvY2toYXNoYCBiZWZvcmUgaW52b2tpbmcgdGhpcyBtZXRob2RcbiAgICpcbiAgICogQHBhcmFtIHtBcnJheTxTaWduZXI+fSBzaWduZXJzIEFycmF5IG9mIHNpZ25lcnMgdGhhdCB3aWxsIHNpZ24gdGhlIHRyYW5zYWN0aW9uXG4gICAqL1xuICBzaWduKC4uLnNpZ25lcnMpIHtcbiAgICBpZiAoc2lnbmVycy5sZW5ndGggPT09IDApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignTm8gc2lnbmVycycpO1xuICAgIH1cblxuICAgIC8vIERlZHVwZSBzaWduZXJzXG4gICAgY29uc3Qgc2VlbiA9IG5ldyBTZXQoKTtcbiAgICBjb25zdCB1bmlxdWVTaWduZXJzID0gW107XG4gICAgZm9yIChjb25zdCBzaWduZXIgb2Ygc2lnbmVycykge1xuICAgICAgY29uc3Qga2V5ID0gc2lnbmVyLnB1YmxpY0tleS50b1N0cmluZygpO1xuICAgICAgaWYgKHNlZW4uaGFzKGtleSkpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzZWVuLmFkZChrZXkpO1xuICAgICAgICB1bmlxdWVTaWduZXJzLnB1c2goc2lnbmVyKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5zaWduYXR1cmVzID0gdW5pcXVlU2lnbmVycy5tYXAoc2lnbmVyID0+ICh7XG4gICAgICBzaWduYXR1cmU6IG51bGwsXG4gICAgICBwdWJsaWNLZXk6IHNpZ25lci5wdWJsaWNLZXlcbiAgICB9KSk7XG4gICAgY29uc3QgbWVzc2FnZSA9IHRoaXMuX2NvbXBpbGUoKTtcbiAgICB0aGlzLl9wYXJ0aWFsU2lnbihtZXNzYWdlLCAuLi51bmlxdWVTaWduZXJzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBQYXJ0aWFsbHkgc2lnbiBhIHRyYW5zYWN0aW9uIHdpdGggdGhlIHNwZWNpZmllZCBhY2NvdW50cy4gQWxsIGFjY291bnRzIG11c3RcbiAgICogY29ycmVzcG9uZCB0byBlaXRoZXIgdGhlIGZlZSBwYXllciBvciBhIHNpZ25lciBhY2NvdW50IGluIHRoZSB0cmFuc2FjdGlvblxuICAgKiBpbnN0cnVjdGlvbnMuXG4gICAqXG4gICAqIEFsbCB0aGUgY2F2ZWF0cyBmcm9tIHRoZSBgc2lnbmAgbWV0aG9kIGFwcGx5IHRvIGBwYXJ0aWFsU2lnbmBcbiAgICpcbiAgICogQHBhcmFtIHtBcnJheTxTaWduZXI+fSBzaWduZXJzIEFycmF5IG9mIHNpZ25lcnMgdGhhdCB3aWxsIHNpZ24gdGhlIHRyYW5zYWN0aW9uXG4gICAqL1xuICBwYXJ0aWFsU2lnbiguLi5zaWduZXJzKSB7XG4gICAgaWYgKHNpZ25lcnMubGVuZ3RoID09PSAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIHNpZ25lcnMnKTtcbiAgICB9XG5cbiAgICAvLyBEZWR1cGUgc2lnbmVyc1xuICAgIGNvbnN0IHNlZW4gPSBuZXcgU2V0KCk7XG4gICAgY29uc3QgdW5pcXVlU2lnbmVycyA9IFtdO1xuICAgIGZvciAoY29uc3Qgc2lnbmVyIG9mIHNpZ25lcnMpIHtcbiAgICAgIGNvbnN0IGtleSA9IHNpZ25lci5wdWJsaWNLZXkudG9TdHJpbmcoKTtcbiAgICAgIGlmIChzZWVuLmhhcyhrZXkpKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2Vlbi5hZGQoa2V5KTtcbiAgICAgICAgdW5pcXVlU2lnbmVycy5wdXNoKHNpZ25lcik7XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IG1lc3NhZ2UgPSB0aGlzLl9jb21waWxlKCk7XG4gICAgdGhpcy5fcGFydGlhbFNpZ24obWVzc2FnZSwgLi4udW5pcXVlU2lnbmVycyk7XG4gIH1cblxuICAvKipcbiAgICogQGludGVybmFsXG4gICAqL1xuICBfcGFydGlhbFNpZ24obWVzc2FnZSwgLi4uc2lnbmVycykge1xuICAgIGNvbnN0IHNpZ25EYXRhID0gbWVzc2FnZS5zZXJpYWxpemUoKTtcbiAgICBzaWduZXJzLmZvckVhY2goc2lnbmVyID0+IHtcbiAgICAgIGNvbnN0IHNpZ25hdHVyZSA9IHNpZ24oc2lnbkRhdGEsIHNpZ25lci5zZWNyZXRLZXkpO1xuICAgICAgdGhpcy5fYWRkU2lnbmF0dXJlKHNpZ25lci5wdWJsaWNLZXksIHRvQnVmZmVyKHNpZ25hdHVyZSkpO1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEFkZCBhbiBleHRlcm5hbGx5IGNyZWF0ZWQgc2lnbmF0dXJlIHRvIGEgdHJhbnNhY3Rpb24uIFRoZSBwdWJsaWMga2V5XG4gICAqIG11c3QgY29ycmVzcG9uZCB0byBlaXRoZXIgdGhlIGZlZSBwYXllciBvciBhIHNpZ25lciBhY2NvdW50IGluIHRoZSB0cmFuc2FjdGlvblxuICAgKiBpbnN0cnVjdGlvbnMuXG4gICAqXG4gICAqIEBwYXJhbSB7UHVibGljS2V5fSBwdWJrZXkgUHVibGljIGtleSB0aGF0IHdpbGwgYmUgYWRkZWQgdG8gdGhlIHRyYW5zYWN0aW9uLlxuICAgKiBAcGFyYW0ge0J1ZmZlcn0gc2lnbmF0dXJlIEFuIGV4dGVybmFsbHkgY3JlYXRlZCBzaWduYXR1cmUgdG8gYWRkIHRvIHRoZSB0cmFuc2FjdGlvbi5cbiAgICovXG4gIGFkZFNpZ25hdHVyZShwdWJrZXksIHNpZ25hdHVyZSkge1xuICAgIHRoaXMuX2NvbXBpbGUoKTsgLy8gRW5zdXJlIHNpZ25hdHVyZXMgYXJyYXkgaXMgcG9wdWxhdGVkXG4gICAgdGhpcy5fYWRkU2lnbmF0dXJlKHB1YmtleSwgc2lnbmF0dXJlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIF9hZGRTaWduYXR1cmUocHVia2V5LCBzaWduYXR1cmUpIHtcbiAgICBhc3NlcnQoc2lnbmF0dXJlLmxlbmd0aCA9PT0gNjQpO1xuICAgIGNvbnN0IGluZGV4ID0gdGhpcy5zaWduYXR1cmVzLmZpbmRJbmRleChzaWdwYWlyID0+IHB1YmtleS5lcXVhbHMoc2lncGFpci5wdWJsaWNLZXkpKTtcbiAgICBpZiAoaW5kZXggPCAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYHVua25vd24gc2lnbmVyOiAke3B1YmtleS50b1N0cmluZygpfWApO1xuICAgIH1cbiAgICB0aGlzLnNpZ25hdHVyZXNbaW5kZXhdLnNpZ25hdHVyZSA9IEJ1ZmZlci5mcm9tKHNpZ25hdHVyZSk7XG4gIH1cblxuICAvKipcbiAgICogVmVyaWZ5IHNpZ25hdHVyZXMgb2YgYSBUcmFuc2FjdGlvblxuICAgKiBPcHRpb25hbCBwYXJhbWV0ZXIgc3BlY2lmaWVzIGlmIHdlJ3JlIGV4cGVjdGluZyBhIGZ1bGx5IHNpZ25lZCBUcmFuc2FjdGlvbiBvciBhIHBhcnRpYWxseSBzaWduZWQgb25lLlxuICAgKiBJZiBubyBib29sZWFuIGlzIHByb3ZpZGVkLCB3ZSBleHBlY3QgYSBmdWxseSBzaWduZWQgVHJhbnNhY3Rpb24gYnkgZGVmYXVsdC5cbiAgICpcbiAgICogQHBhcmFtIHtib29sZWFufSBbcmVxdWlyZUFsbFNpZ25hdHVyZXM9dHJ1ZV0gUmVxdWlyZSBhIGZ1bGx5IHNpZ25lZCBUcmFuc2FjdGlvblxuICAgKi9cbiAgdmVyaWZ5U2lnbmF0dXJlcyhyZXF1aXJlQWxsU2lnbmF0dXJlcyA9IHRydWUpIHtcbiAgICBjb25zdCBzaWduYXR1cmVFcnJvcnMgPSB0aGlzLl9nZXRNZXNzYWdlU2lnbmVkbmVzc0Vycm9ycyh0aGlzLnNlcmlhbGl6ZU1lc3NhZ2UoKSwgcmVxdWlyZUFsbFNpZ25hdHVyZXMpO1xuICAgIHJldHVybiAhc2lnbmF0dXJlRXJyb3JzO1xuICB9XG5cbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgX2dldE1lc3NhZ2VTaWduZWRuZXNzRXJyb3JzKG1lc3NhZ2UsIHJlcXVpcmVBbGxTaWduYXR1cmVzKSB7XG4gICAgY29uc3QgZXJyb3JzID0ge307XG4gICAgZm9yIChjb25zdCB7XG4gICAgICBzaWduYXR1cmUsXG4gICAgICBwdWJsaWNLZXlcbiAgICB9IG9mIHRoaXMuc2lnbmF0dXJlcykge1xuICAgICAgaWYgKHNpZ25hdHVyZSA9PT0gbnVsbCkge1xuICAgICAgICBpZiAocmVxdWlyZUFsbFNpZ25hdHVyZXMpIHtcbiAgICAgICAgICAoZXJyb3JzLm1pc3NpbmcgfHw9IFtdKS5wdXNoKHB1YmxpY0tleSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmICghdmVyaWZ5KHNpZ25hdHVyZSwgbWVzc2FnZSwgcHVibGljS2V5LnRvQnl0ZXMoKSkpIHtcbiAgICAgICAgICAoZXJyb3JzLmludmFsaWQgfHw9IFtdKS5wdXNoKHB1YmxpY0tleSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGVycm9ycy5pbnZhbGlkIHx8IGVycm9ycy5taXNzaW5nID8gZXJyb3JzIDogdW5kZWZpbmVkO1xuICB9XG5cbiAgLyoqXG4gICAqIFNlcmlhbGl6ZSB0aGUgVHJhbnNhY3Rpb24gaW4gdGhlIHdpcmUgZm9ybWF0LlxuICAgKlxuICAgKiBAcGFyYW0ge0J1ZmZlcn0gW2NvbmZpZ10gQ29uZmlnIG9mIHRyYW5zYWN0aW9uLlxuICAgKlxuICAgKiBAcmV0dXJucyB7QnVmZmVyfSBTaWduYXR1cmUgb2YgdHJhbnNhY3Rpb24gaW4gd2lyZSBmb3JtYXQuXG4gICAqL1xuICBzZXJpYWxpemUoY29uZmlnKSB7XG4gICAgY29uc3Qge1xuICAgICAgcmVxdWlyZUFsbFNpZ25hdHVyZXMsXG4gICAgICB2ZXJpZnlTaWduYXR1cmVzXG4gICAgfSA9IE9iamVjdC5hc3NpZ24oe1xuICAgICAgcmVxdWlyZUFsbFNpZ25hdHVyZXM6IHRydWUsXG4gICAgICB2ZXJpZnlTaWduYXR1cmVzOiB0cnVlXG4gICAgfSwgY29uZmlnKTtcbiAgICBjb25zdCBzaWduRGF0YSA9IHRoaXMuc2VyaWFsaXplTWVzc2FnZSgpO1xuICAgIGlmICh2ZXJpZnlTaWduYXR1cmVzKSB7XG4gICAgICBjb25zdCBzaWdFcnJvcnMgPSB0aGlzLl9nZXRNZXNzYWdlU2lnbmVkbmVzc0Vycm9ycyhzaWduRGF0YSwgcmVxdWlyZUFsbFNpZ25hdHVyZXMpO1xuICAgICAgaWYgKHNpZ0Vycm9ycykge1xuICAgICAgICBsZXQgZXJyb3JNZXNzYWdlID0gJ1NpZ25hdHVyZSB2ZXJpZmljYXRpb24gZmFpbGVkLic7XG4gICAgICAgIGlmIChzaWdFcnJvcnMuaW52YWxpZCkge1xuICAgICAgICAgIGVycm9yTWVzc2FnZSArPSBgXFxuSW52YWxpZCBzaWduYXR1cmUgZm9yIHB1YmxpYyBrZXkke3NpZ0Vycm9ycy5pbnZhbGlkLmxlbmd0aCA9PT0gMSA/ICcnIDogJyhzKSd9IFtcXGAke3NpZ0Vycm9ycy5pbnZhbGlkLm1hcChwID0+IHAudG9CYXNlNTgoKSkuam9pbignYCwgYCcpfVxcYF0uYDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc2lnRXJyb3JzLm1pc3NpbmcpIHtcbiAgICAgICAgICBlcnJvck1lc3NhZ2UgKz0gYFxcbk1pc3Npbmcgc2lnbmF0dXJlIGZvciBwdWJsaWMga2V5JHtzaWdFcnJvcnMubWlzc2luZy5sZW5ndGggPT09IDEgPyAnJyA6ICcocyknfSBbXFxgJHtzaWdFcnJvcnMubWlzc2luZy5tYXAocCA9PiBwLnRvQmFzZTU4KCkpLmpvaW4oJ2AsIGAnKX1cXGBdLmA7XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGVycm9yTWVzc2FnZSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9zZXJpYWxpemUoc2lnbkRhdGEpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgX3NlcmlhbGl6ZShzaWduRGF0YSkge1xuICAgIGNvbnN0IHtcbiAgICAgIHNpZ25hdHVyZXNcbiAgICB9ID0gdGhpcztcbiAgICBjb25zdCBzaWduYXR1cmVDb3VudCA9IFtdO1xuICAgIGVuY29kZUxlbmd0aChzaWduYXR1cmVDb3VudCwgc2lnbmF0dXJlcy5sZW5ndGgpO1xuICAgIGNvbnN0IHRyYW5zYWN0aW9uTGVuZ3RoID0gc2lnbmF0dXJlQ291bnQubGVuZ3RoICsgc2lnbmF0dXJlcy5sZW5ndGggKiA2NCArIHNpZ25EYXRhLmxlbmd0aDtcbiAgICBjb25zdCB3aXJlVHJhbnNhY3Rpb24gPSBCdWZmZXIuYWxsb2ModHJhbnNhY3Rpb25MZW5ndGgpO1xuICAgIGFzc2VydChzaWduYXR1cmVzLmxlbmd0aCA8IDI1Nik7XG4gICAgQnVmZmVyLmZyb20oc2lnbmF0dXJlQ291bnQpLmNvcHkod2lyZVRyYW5zYWN0aW9uLCAwKTtcbiAgICBzaWduYXR1cmVzLmZvckVhY2goKHtcbiAgICAgIHNpZ25hdHVyZVxuICAgIH0sIGluZGV4KSA9PiB7XG4gICAgICBpZiAoc2lnbmF0dXJlICE9PSBudWxsKSB7XG4gICAgICAgIGFzc2VydChzaWduYXR1cmUubGVuZ3RoID09PSA2NCwgYHNpZ25hdHVyZSBoYXMgaW52YWxpZCBsZW5ndGhgKTtcbiAgICAgICAgQnVmZmVyLmZyb20oc2lnbmF0dXJlKS5jb3B5KHdpcmVUcmFuc2FjdGlvbiwgc2lnbmF0dXJlQ291bnQubGVuZ3RoICsgaW5kZXggKiA2NCk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgc2lnbkRhdGEuY29weSh3aXJlVHJhbnNhY3Rpb24sIHNpZ25hdHVyZUNvdW50Lmxlbmd0aCArIHNpZ25hdHVyZXMubGVuZ3RoICogNjQpO1xuICAgIGFzc2VydCh3aXJlVHJhbnNhY3Rpb24ubGVuZ3RoIDw9IFBBQ0tFVF9EQVRBX1NJWkUsIGBUcmFuc2FjdGlvbiB0b28gbGFyZ2U6ICR7d2lyZVRyYW5zYWN0aW9uLmxlbmd0aH0gPiAke1BBQ0tFVF9EQVRBX1NJWkV9YCk7XG4gICAgcmV0dXJuIHdpcmVUcmFuc2FjdGlvbjtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZXByZWNhdGVkIG1ldGhvZFxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIGdldCBrZXlzKCkge1xuICAgIGFzc2VydCh0aGlzLmluc3RydWN0aW9ucy5sZW5ndGggPT09IDEpO1xuICAgIHJldHVybiB0aGlzLmluc3RydWN0aW9uc1swXS5rZXlzLm1hcChrZXlPYmogPT4ga2V5T2JqLnB1YmtleSk7XG4gIH1cblxuICAvKipcbiAgICogRGVwcmVjYXRlZCBtZXRob2RcbiAgICogQGludGVybmFsXG4gICAqL1xuICBnZXQgcHJvZ3JhbUlkKCkge1xuICAgIGFzc2VydCh0aGlzLmluc3RydWN0aW9ucy5sZW5ndGggPT09IDEpO1xuICAgIHJldHVybiB0aGlzLmluc3RydWN0aW9uc1swXS5wcm9ncmFtSWQ7XG4gIH1cblxuICAvKipcbiAgICogRGVwcmVjYXRlZCBtZXRob2RcbiAgICogQGludGVybmFsXG4gICAqL1xuICBnZXQgZGF0YSgpIHtcbiAgICBhc3NlcnQodGhpcy5pbnN0cnVjdGlvbnMubGVuZ3RoID09PSAxKTtcbiAgICByZXR1cm4gdGhpcy5pbnN0cnVjdGlvbnNbMF0uZGF0YTtcbiAgfVxuXG4gIC8qKlxuICAgKiBQYXJzZSBhIHdpcmUgdHJhbnNhY3Rpb24gaW50byBhIFRyYW5zYWN0aW9uIG9iamVjdC5cbiAgICpcbiAgICogQHBhcmFtIHtCdWZmZXIgfCBVaW50OEFycmF5IHwgQXJyYXk8bnVtYmVyPn0gYnVmZmVyIFNpZ25hdHVyZSBvZiB3aXJlIFRyYW5zYWN0aW9uXG4gICAqXG4gICAqIEByZXR1cm5zIHtUcmFuc2FjdGlvbn0gVHJhbnNhY3Rpb24gYXNzb2NpYXRlZCB3aXRoIHRoZSBzaWduYXR1cmVcbiAgICovXG4gIHN0YXRpYyBmcm9tKGJ1ZmZlcikge1xuICAgIC8vIFNsaWNlIHVwIHdpcmUgZGF0YVxuICAgIGxldCBieXRlQXJyYXkgPSBbLi4uYnVmZmVyXTtcbiAgICBjb25zdCBzaWduYXR1cmVDb3VudCA9IGRlY29kZUxlbmd0aChieXRlQXJyYXkpO1xuICAgIGxldCBzaWduYXR1cmVzID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzaWduYXR1cmVDb3VudDsgaSsrKSB7XG4gICAgICBjb25zdCBzaWduYXR1cmUgPSBndWFyZGVkU3BsaWNlKGJ5dGVBcnJheSwgMCwgU0lHTkFUVVJFX0xFTkdUSF9JTl9CWVRFUyk7XG4gICAgICBzaWduYXR1cmVzLnB1c2goYnM1OC5lbmNvZGUoQnVmZmVyLmZyb20oc2lnbmF0dXJlKSkpO1xuICAgIH1cbiAgICByZXR1cm4gVHJhbnNhY3Rpb24ucG9wdWxhdGUoTWVzc2FnZS5mcm9tKGJ5dGVBcnJheSksIHNpZ25hdHVyZXMpO1xuICB9XG5cbiAgLyoqXG4gICAqIFBvcHVsYXRlIFRyYW5zYWN0aW9uIG9iamVjdCBmcm9tIG1lc3NhZ2UgYW5kIHNpZ25hdHVyZXNcbiAgICpcbiAgICogQHBhcmFtIHtNZXNzYWdlfSBtZXNzYWdlIE1lc3NhZ2Ugb2YgdHJhbnNhY3Rpb25cbiAgICogQHBhcmFtIHtBcnJheTxzdHJpbmc+fSBzaWduYXR1cmVzIExpc3Qgb2Ygc2lnbmF0dXJlcyB0byBhc3NpZ24gdG8gdGhlIHRyYW5zYWN0aW9uXG4gICAqXG4gICAqIEByZXR1cm5zIHtUcmFuc2FjdGlvbn0gVGhlIHBvcHVsYXRlZCBUcmFuc2FjdGlvblxuICAgKi9cbiAgc3RhdGljIHBvcHVsYXRlKG1lc3NhZ2UsIHNpZ25hdHVyZXMgPSBbXSkge1xuICAgIGNvbnN0IHRyYW5zYWN0aW9uID0gbmV3IFRyYW5zYWN0aW9uKCk7XG4gICAgdHJhbnNhY3Rpb24ucmVjZW50QmxvY2toYXNoID0gbWVzc2FnZS5yZWNlbnRCbG9ja2hhc2g7XG4gICAgaWYgKG1lc3NhZ2UuaGVhZGVyLm51bVJlcXVpcmVkU2lnbmF0dXJlcyA+IDApIHtcbiAgICAgIHRyYW5zYWN0aW9uLmZlZVBheWVyID0gbWVzc2FnZS5hY2NvdW50S2V5c1swXTtcbiAgICB9XG4gICAgc2lnbmF0dXJlcy5mb3JFYWNoKChzaWduYXR1cmUsIGluZGV4KSA9PiB7XG4gICAgICBjb25zdCBzaWdQdWJrZXlQYWlyID0ge1xuICAgICAgICBzaWduYXR1cmU6IHNpZ25hdHVyZSA9PSBiczU4LmVuY29kZShERUZBVUxUX1NJR05BVFVSRSkgPyBudWxsIDogYnM1OC5kZWNvZGUoc2lnbmF0dXJlKSxcbiAgICAgICAgcHVibGljS2V5OiBtZXNzYWdlLmFjY291bnRLZXlzW2luZGV4XVxuICAgICAgfTtcbiAgICAgIHRyYW5zYWN0aW9uLnNpZ25hdHVyZXMucHVzaChzaWdQdWJrZXlQYWlyKTtcbiAgICB9KTtcbiAgICBtZXNzYWdlLmluc3RydWN0aW9ucy5mb3JFYWNoKGluc3RydWN0aW9uID0+IHtcbiAgICAgIGNvbnN0IGtleXMgPSBpbnN0cnVjdGlvbi5hY2NvdW50cy5tYXAoYWNjb3VudCA9PiB7XG4gICAgICAgIGNvbnN0IHB1YmtleSA9IG1lc3NhZ2UuYWNjb3VudEtleXNbYWNjb3VudF07XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgcHVia2V5LFxuICAgICAgICAgIGlzU2lnbmVyOiB0cmFuc2FjdGlvbi5zaWduYXR1cmVzLnNvbWUoa2V5T2JqID0+IGtleU9iai5wdWJsaWNLZXkudG9TdHJpbmcoKSA9PT0gcHVia2V5LnRvU3RyaW5nKCkpIHx8IG1lc3NhZ2UuaXNBY2NvdW50U2lnbmVyKGFjY291bnQpLFxuICAgICAgICAgIGlzV3JpdGFibGU6IG1lc3NhZ2UuaXNBY2NvdW50V3JpdGFibGUoYWNjb3VudClcbiAgICAgICAgfTtcbiAgICAgIH0pO1xuICAgICAgdHJhbnNhY3Rpb24uaW5zdHJ1Y3Rpb25zLnB1c2gobmV3IFRyYW5zYWN0aW9uSW5zdHJ1Y3Rpb24oe1xuICAgICAgICBrZXlzLFxuICAgICAgICBwcm9ncmFtSWQ6IG1lc3NhZ2UuYWNjb3VudEtleXNbaW5zdHJ1Y3Rpb24ucHJvZ3JhbUlkSW5kZXhdLFxuICAgICAgICBkYXRhOiBiczU4LmRlY29kZShpbnN0cnVjdGlvbi5kYXRhKVxuICAgICAgfSkpO1xuICAgIH0pO1xuICAgIHRyYW5zYWN0aW9uLl9tZXNzYWdlID0gbWVzc2FnZTtcbiAgICB0cmFuc2FjdGlvbi5fanNvbiA9IHRyYW5zYWN0aW9uLnRvSlNPTigpO1xuICAgIHJldHVybiB0cmFuc2FjdGlvbjtcbiAgfVxufVxuXG5jbGFzcyBUcmFuc2FjdGlvbk1lc3NhZ2Uge1xuICBjb25zdHJ1Y3RvcihhcmdzKSB7XG4gICAgdGhpcy5wYXllcktleSA9IHZvaWQgMDtcbiAgICB0aGlzLmluc3RydWN0aW9ucyA9IHZvaWQgMDtcbiAgICB0aGlzLnJlY2VudEJsb2NraGFzaCA9IHZvaWQgMDtcbiAgICB0aGlzLnBheWVyS2V5ID0gYXJncy5wYXllcktleTtcbiAgICB0aGlzLmluc3RydWN0aW9ucyA9IGFyZ3MuaW5zdHJ1Y3Rpb25zO1xuICAgIHRoaXMucmVjZW50QmxvY2toYXNoID0gYXJncy5yZWNlbnRCbG9ja2hhc2g7XG4gIH1cbiAgc3RhdGljIGRlY29tcGlsZShtZXNzYWdlLCBhcmdzKSB7XG4gICAgY29uc3Qge1xuICAgICAgaGVhZGVyLFxuICAgICAgY29tcGlsZWRJbnN0cnVjdGlvbnMsXG4gICAgICByZWNlbnRCbG9ja2hhc2hcbiAgICB9ID0gbWVzc2FnZTtcbiAgICBjb25zdCB7XG4gICAgICBudW1SZXF1aXJlZFNpZ25hdHVyZXMsXG4gICAgICBudW1SZWFkb25seVNpZ25lZEFjY291bnRzLFxuICAgICAgbnVtUmVhZG9ubHlVbnNpZ25lZEFjY291bnRzXG4gICAgfSA9IGhlYWRlcjtcbiAgICBjb25zdCBudW1Xcml0YWJsZVNpZ25lZEFjY291bnRzID0gbnVtUmVxdWlyZWRTaWduYXR1cmVzIC0gbnVtUmVhZG9ubHlTaWduZWRBY2NvdW50cztcbiAgICBhc3NlcnQobnVtV3JpdGFibGVTaWduZWRBY2NvdW50cyA+IDAsICdNZXNzYWdlIGhlYWRlciBpcyBpbnZhbGlkJyk7XG4gICAgY29uc3QgbnVtV3JpdGFibGVVbnNpZ25lZEFjY291bnRzID0gbWVzc2FnZS5zdGF0aWNBY2NvdW50S2V5cy5sZW5ndGggLSBudW1SZXF1aXJlZFNpZ25hdHVyZXMgLSBudW1SZWFkb25seVVuc2lnbmVkQWNjb3VudHM7XG4gICAgYXNzZXJ0KG51bVdyaXRhYmxlVW5zaWduZWRBY2NvdW50cyA+PSAwLCAnTWVzc2FnZSBoZWFkZXIgaXMgaW52YWxpZCcpO1xuICAgIGNvbnN0IGFjY291bnRLZXlzID0gbWVzc2FnZS5nZXRBY2NvdW50S2V5cyhhcmdzKTtcbiAgICBjb25zdCBwYXllcktleSA9IGFjY291bnRLZXlzLmdldCgwKTtcbiAgICBpZiAocGF5ZXJLZXkgPT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdGYWlsZWQgdG8gZGVjb21waWxlIG1lc3NhZ2UgYmVjYXVzZSBubyBhY2NvdW50IGtleXMgd2VyZSBmb3VuZCcpO1xuICAgIH1cbiAgICBjb25zdCBpbnN0cnVjdGlvbnMgPSBbXTtcbiAgICBmb3IgKGNvbnN0IGNvbXBpbGVkSXggb2YgY29tcGlsZWRJbnN0cnVjdGlvbnMpIHtcbiAgICAgIGNvbnN0IGtleXMgPSBbXTtcbiAgICAgIGZvciAoY29uc3Qga2V5SW5kZXggb2YgY29tcGlsZWRJeC5hY2NvdW50S2V5SW5kZXhlcykge1xuICAgICAgICBjb25zdCBwdWJrZXkgPSBhY2NvdW50S2V5cy5nZXQoa2V5SW5kZXgpO1xuICAgICAgICBpZiAocHVia2V5ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEZhaWxlZCB0byBmaW5kIGtleSBmb3IgYWNjb3VudCBrZXkgaW5kZXggJHtrZXlJbmRleH1gKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBpc1NpZ25lciA9IGtleUluZGV4IDwgbnVtUmVxdWlyZWRTaWduYXR1cmVzO1xuICAgICAgICBsZXQgaXNXcml0YWJsZTtcbiAgICAgICAgaWYgKGlzU2lnbmVyKSB7XG4gICAgICAgICAgaXNXcml0YWJsZSA9IGtleUluZGV4IDwgbnVtV3JpdGFibGVTaWduZWRBY2NvdW50cztcbiAgICAgICAgfSBlbHNlIGlmIChrZXlJbmRleCA8IGFjY291bnRLZXlzLnN0YXRpY0FjY291bnRLZXlzLmxlbmd0aCkge1xuICAgICAgICAgIGlzV3JpdGFibGUgPSBrZXlJbmRleCAtIG51bVJlcXVpcmVkU2lnbmF0dXJlcyA8IG51bVdyaXRhYmxlVW5zaWduZWRBY2NvdW50cztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpc1dyaXRhYmxlID0ga2V5SW5kZXggLSBhY2NvdW50S2V5cy5zdGF0aWNBY2NvdW50S2V5cy5sZW5ndGggPFxuICAgICAgICAgIC8vIGFjY291bnRLZXlzRnJvbUxvb2t1cHMgY2Fubm90IGJlIHVuZGVmaW5lZCBiZWNhdXNlIHdlIGFscmVhZHkgZm91bmQgYSBwdWJrZXkgZm9yIHRoaXMgaW5kZXggYWJvdmVcbiAgICAgICAgICBhY2NvdW50S2V5cy5hY2NvdW50S2V5c0Zyb21Mb29rdXBzLndyaXRhYmxlLmxlbmd0aDtcbiAgICAgICAgfVxuICAgICAgICBrZXlzLnB1c2goe1xuICAgICAgICAgIHB1YmtleSxcbiAgICAgICAgICBpc1NpZ25lcjoga2V5SW5kZXggPCBoZWFkZXIubnVtUmVxdWlyZWRTaWduYXR1cmVzLFxuICAgICAgICAgIGlzV3JpdGFibGVcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBjb25zdCBwcm9ncmFtSWQgPSBhY2NvdW50S2V5cy5nZXQoY29tcGlsZWRJeC5wcm9ncmFtSWRJbmRleCk7XG4gICAgICBpZiAocHJvZ3JhbUlkID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBGYWlsZWQgdG8gZmluZCBwcm9ncmFtIGlkIGZvciBwcm9ncmFtIGlkIGluZGV4ICR7Y29tcGlsZWRJeC5wcm9ncmFtSWRJbmRleH1gKTtcbiAgICAgIH1cbiAgICAgIGluc3RydWN0aW9ucy5wdXNoKG5ldyBUcmFuc2FjdGlvbkluc3RydWN0aW9uKHtcbiAgICAgICAgcHJvZ3JhbUlkLFxuICAgICAgICBkYXRhOiB0b0J1ZmZlcihjb21waWxlZEl4LmRhdGEpLFxuICAgICAgICBrZXlzXG4gICAgICB9KSk7XG4gICAgfVxuICAgIHJldHVybiBuZXcgVHJhbnNhY3Rpb25NZXNzYWdlKHtcbiAgICAgIHBheWVyS2V5LFxuICAgICAgaW5zdHJ1Y3Rpb25zLFxuICAgICAgcmVjZW50QmxvY2toYXNoXG4gICAgfSk7XG4gIH1cbiAgY29tcGlsZVRvTGVnYWN5TWVzc2FnZSgpIHtcbiAgICByZXR1cm4gTWVzc2FnZS5jb21waWxlKHtcbiAgICAgIHBheWVyS2V5OiB0aGlzLnBheWVyS2V5LFxuICAgICAgcmVjZW50QmxvY2toYXNoOiB0aGlzLnJlY2VudEJsb2NraGFzaCxcbiAgICAgIGluc3RydWN0aW9uczogdGhpcy5pbnN0cnVjdGlvbnNcbiAgICB9KTtcbiAgfVxuICBjb21waWxlVG9WME1lc3NhZ2UoYWRkcmVzc0xvb2t1cFRhYmxlQWNjb3VudHMpIHtcbiAgICByZXR1cm4gTWVzc2FnZVYwLmNvbXBpbGUoe1xuICAgICAgcGF5ZXJLZXk6IHRoaXMucGF5ZXJLZXksXG4gICAgICByZWNlbnRCbG9ja2hhc2g6IHRoaXMucmVjZW50QmxvY2toYXNoLFxuICAgICAgaW5zdHJ1Y3Rpb25zOiB0aGlzLmluc3RydWN0aW9ucyxcbiAgICAgIGFkZHJlc3NMb29rdXBUYWJsZUFjY291bnRzXG4gICAgfSk7XG4gIH1cbn1cblxuLyoqXG4gKiBWZXJzaW9uZWQgdHJhbnNhY3Rpb24gY2xhc3NcbiAqL1xuY2xhc3MgVmVyc2lvbmVkVHJhbnNhY3Rpb24ge1xuICBnZXQgdmVyc2lvbigpIHtcbiAgICByZXR1cm4gdGhpcy5tZXNzYWdlLnZlcnNpb247XG4gIH1cbiAgY29uc3RydWN0b3IobWVzc2FnZSwgc2lnbmF0dXJlcykge1xuICAgIHRoaXMuc2lnbmF0dXJlcyA9IHZvaWQgMDtcbiAgICB0aGlzLm1lc3NhZ2UgPSB2b2lkIDA7XG4gICAgaWYgKHNpZ25hdHVyZXMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgYXNzZXJ0KHNpZ25hdHVyZXMubGVuZ3RoID09PSBtZXNzYWdlLmhlYWRlci5udW1SZXF1aXJlZFNpZ25hdHVyZXMsICdFeHBlY3RlZCBzaWduYXR1cmVzIGxlbmd0aCB0byBiZSBlcXVhbCB0byB0aGUgbnVtYmVyIG9mIHJlcXVpcmVkIHNpZ25hdHVyZXMnKTtcbiAgICAgIHRoaXMuc2lnbmF0dXJlcyA9IHNpZ25hdHVyZXM7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IGRlZmF1bHRTaWduYXR1cmVzID0gW107XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG1lc3NhZ2UuaGVhZGVyLm51bVJlcXVpcmVkU2lnbmF0dXJlczsgaSsrKSB7XG4gICAgICAgIGRlZmF1bHRTaWduYXR1cmVzLnB1c2gobmV3IFVpbnQ4QXJyYXkoU0lHTkFUVVJFX0xFTkdUSF9JTl9CWVRFUykpO1xuICAgICAgfVxuICAgICAgdGhpcy5zaWduYXR1cmVzID0gZGVmYXVsdFNpZ25hdHVyZXM7XG4gICAgfVxuICAgIHRoaXMubWVzc2FnZSA9IG1lc3NhZ2U7XG4gIH1cbiAgc2VyaWFsaXplKCkge1xuICAgIGNvbnN0IHNlcmlhbGl6ZWRNZXNzYWdlID0gdGhpcy5tZXNzYWdlLnNlcmlhbGl6ZSgpO1xuICAgIGNvbnN0IGVuY29kZWRTaWduYXR1cmVzTGVuZ3RoID0gQXJyYXkoKTtcbiAgICBlbmNvZGVMZW5ndGgoZW5jb2RlZFNpZ25hdHVyZXNMZW5ndGgsIHRoaXMuc2lnbmF0dXJlcy5sZW5ndGgpO1xuICAgIGNvbnN0IHRyYW5zYWN0aW9uTGF5b3V0ID0gQnVmZmVyTGF5b3V0LnN0cnVjdChbQnVmZmVyTGF5b3V0LmJsb2IoZW5jb2RlZFNpZ25hdHVyZXNMZW5ndGgubGVuZ3RoLCAnZW5jb2RlZFNpZ25hdHVyZXNMZW5ndGgnKSwgQnVmZmVyTGF5b3V0LnNlcShzaWduYXR1cmUoKSwgdGhpcy5zaWduYXR1cmVzLmxlbmd0aCwgJ3NpZ25hdHVyZXMnKSwgQnVmZmVyTGF5b3V0LmJsb2Ioc2VyaWFsaXplZE1lc3NhZ2UubGVuZ3RoLCAnc2VyaWFsaXplZE1lc3NhZ2UnKV0pO1xuICAgIGNvbnN0IHNlcmlhbGl6ZWRUcmFuc2FjdGlvbiA9IG5ldyBVaW50OEFycmF5KDIwNDgpO1xuICAgIGNvbnN0IHNlcmlhbGl6ZWRUcmFuc2FjdGlvbkxlbmd0aCA9IHRyYW5zYWN0aW9uTGF5b3V0LmVuY29kZSh7XG4gICAgICBlbmNvZGVkU2lnbmF0dXJlc0xlbmd0aDogbmV3IFVpbnQ4QXJyYXkoZW5jb2RlZFNpZ25hdHVyZXNMZW5ndGgpLFxuICAgICAgc2lnbmF0dXJlczogdGhpcy5zaWduYXR1cmVzLFxuICAgICAgc2VyaWFsaXplZE1lc3NhZ2VcbiAgICB9LCBzZXJpYWxpemVkVHJhbnNhY3Rpb24pO1xuICAgIHJldHVybiBzZXJpYWxpemVkVHJhbnNhY3Rpb24uc2xpY2UoMCwgc2VyaWFsaXplZFRyYW5zYWN0aW9uTGVuZ3RoKTtcbiAgfVxuICBzdGF0aWMgZGVzZXJpYWxpemUoc2VyaWFsaXplZFRyYW5zYWN0aW9uKSB7XG4gICAgbGV0IGJ5dGVBcnJheSA9IFsuLi5zZXJpYWxpemVkVHJhbnNhY3Rpb25dO1xuICAgIGNvbnN0IHNpZ25hdHVyZXMgPSBbXTtcbiAgICBjb25zdCBzaWduYXR1cmVzTGVuZ3RoID0gZGVjb2RlTGVuZ3RoKGJ5dGVBcnJheSk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzaWduYXR1cmVzTGVuZ3RoOyBpKyspIHtcbiAgICAgIHNpZ25hdHVyZXMucHVzaChuZXcgVWludDhBcnJheShndWFyZGVkU3BsaWNlKGJ5dGVBcnJheSwgMCwgU0lHTkFUVVJFX0xFTkdUSF9JTl9CWVRFUykpKTtcbiAgICB9XG4gICAgY29uc3QgbWVzc2FnZSA9IFZlcnNpb25lZE1lc3NhZ2UuZGVzZXJpYWxpemUobmV3IFVpbnQ4QXJyYXkoYnl0ZUFycmF5KSk7XG4gICAgcmV0dXJuIG5ldyBWZXJzaW9uZWRUcmFuc2FjdGlvbihtZXNzYWdlLCBzaWduYXR1cmVzKTtcbiAgfVxuICBzaWduKHNpZ25lcnMpIHtcbiAgICBjb25zdCBtZXNzYWdlRGF0YSA9IHRoaXMubWVzc2FnZS5zZXJpYWxpemUoKTtcbiAgICBjb25zdCBzaWduZXJQdWJrZXlzID0gdGhpcy5tZXNzYWdlLnN0YXRpY0FjY291bnRLZXlzLnNsaWNlKDAsIHRoaXMubWVzc2FnZS5oZWFkZXIubnVtUmVxdWlyZWRTaWduYXR1cmVzKTtcbiAgICBmb3IgKGNvbnN0IHNpZ25lciBvZiBzaWduZXJzKSB7XG4gICAgICBjb25zdCBzaWduZXJJbmRleCA9IHNpZ25lclB1YmtleXMuZmluZEluZGV4KHB1YmtleSA9PiBwdWJrZXkuZXF1YWxzKHNpZ25lci5wdWJsaWNLZXkpKTtcbiAgICAgIGFzc2VydChzaWduZXJJbmRleCA+PSAwLCBgQ2Fubm90IHNpZ24gd2l0aCBub24gc2lnbmVyIGtleSAke3NpZ25lci5wdWJsaWNLZXkudG9CYXNlNTgoKX1gKTtcbiAgICAgIHRoaXMuc2lnbmF0dXJlc1tzaWduZXJJbmRleF0gPSBzaWduKG1lc3NhZ2VEYXRhLCBzaWduZXIuc2VjcmV0S2V5KTtcbiAgICB9XG4gIH1cbiAgYWRkU2lnbmF0dXJlKHB1YmxpY0tleSwgc2lnbmF0dXJlKSB7XG4gICAgYXNzZXJ0KHNpZ25hdHVyZS5ieXRlTGVuZ3RoID09PSA2NCwgJ1NpZ25hdHVyZSBtdXN0IGJlIDY0IGJ5dGVzIGxvbmcnKTtcbiAgICBjb25zdCBzaWduZXJQdWJrZXlzID0gdGhpcy5tZXNzYWdlLnN0YXRpY0FjY291bnRLZXlzLnNsaWNlKDAsIHRoaXMubWVzc2FnZS5oZWFkZXIubnVtUmVxdWlyZWRTaWduYXR1cmVzKTtcbiAgICBjb25zdCBzaWduZXJJbmRleCA9IHNpZ25lclB1YmtleXMuZmluZEluZGV4KHB1YmtleSA9PiBwdWJrZXkuZXF1YWxzKHB1YmxpY0tleSkpO1xuICAgIGFzc2VydChzaWduZXJJbmRleCA+PSAwLCBgQ2FuIG5vdCBhZGQgc2lnbmF0dXJlOyBcXGAke3B1YmxpY0tleS50b0Jhc2U1OCgpfVxcYCBpcyBub3QgcmVxdWlyZWQgdG8gc2lnbiB0aGlzIHRyYW5zYWN0aW9uYCk7XG4gICAgdGhpcy5zaWduYXR1cmVzW3NpZ25lckluZGV4XSA9IHNpZ25hdHVyZTtcbiAgfVxufVxuXG4vLyBUT0RPOiBUaGVzZSBjb25zdGFudHMgc2hvdWxkIGJlIHJlbW92ZWQgaW4gZmF2b3Igb2YgcmVhZGluZyB0aGVtIG91dCBvZiBhXG4vLyBTeXNjYWxsIGFjY291bnRcblxuLyoqXG4gKiBAaW50ZXJuYWxcbiAqL1xuY29uc3QgTlVNX1RJQ0tTX1BFUl9TRUNPTkQgPSAxNjA7XG5cbi8qKlxuICogQGludGVybmFsXG4gKi9cbmNvbnN0IERFRkFVTFRfVElDS1NfUEVSX1NMT1QgPSA2NDtcblxuLyoqXG4gKiBAaW50ZXJuYWxcbiAqL1xuY29uc3QgTlVNX1NMT1RTX1BFUl9TRUNPTkQgPSBOVU1fVElDS1NfUEVSX1NFQ09ORCAvIERFRkFVTFRfVElDS1NfUEVSX1NMT1Q7XG5cbi8qKlxuICogQGludGVybmFsXG4gKi9cbmNvbnN0IE1TX1BFUl9TTE9UID0gMTAwMCAvIE5VTV9TTE9UU19QRVJfU0VDT05EO1xuXG5jb25zdCBTWVNWQVJfQ0xPQ0tfUFVCS0VZID0gbmV3IFB1YmxpY0tleSgnU3lzdmFyQzFvY2sxMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMScpO1xuY29uc3QgU1lTVkFSX0VQT0NIX1NDSEVEVUxFX1BVQktFWSA9IG5ldyBQdWJsaWNLZXkoJ1N5c3ZhckVwb2NoU2NoZWR1MWUxMTExMTExMTExMTExMTExMTExMTExMTEnKTtcbmNvbnN0IFNZU1ZBUl9JTlNUUlVDVElPTlNfUFVCS0VZID0gbmV3IFB1YmxpY0tleSgnU3lzdmFyMW5zdHJ1Y3Rpb25zMTExMTExMTExMTExMTExMTExMTExMTExMScpO1xuY29uc3QgU1lTVkFSX1JFQ0VOVF9CTE9DS0hBU0hFU19QVUJLRVkgPSBuZXcgUHVibGljS2V5KCdTeXN2YXJSZWNlbnRCMW9ja0hhc2hlczExMTExMTExMTExMTExMTExMTExJyk7XG5jb25zdCBTWVNWQVJfUkVOVF9QVUJLRVkgPSBuZXcgUHVibGljS2V5KCdTeXN2YXJSZW50MTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExJyk7XG5jb25zdCBTWVNWQVJfUkVXQVJEU19QVUJLRVkgPSBuZXcgUHVibGljS2V5KCdTeXN2YXJSZXdhcmRzMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExJyk7XG5jb25zdCBTWVNWQVJfU0xPVF9IQVNIRVNfUFVCS0VZID0gbmV3IFB1YmxpY0tleSgnU3lzdmFyUzFvdEhhc2hlczExMTExMTExMTExMTExMTExMTExMTExMTExMScpO1xuY29uc3QgU1lTVkFSX1NMT1RfSElTVE9SWV9QVUJLRVkgPSBuZXcgUHVibGljS2V5KCdTeXN2YXJTMW90SGlzdG9yeTExMTExMTExMTExMTExMTExMTExMTExMTExJyk7XG5jb25zdCBTWVNWQVJfU1RBS0VfSElTVE9SWV9QVUJLRVkgPSBuZXcgUHVibGljS2V5KCdTeXN2YXJTdGFrZUhpc3RvcnkxMTExMTExMTExMTExMTExMTExMTExMTExJyk7XG5cbi8qKlxuICogU2lnbiwgc2VuZCBhbmQgY29uZmlybSBhIHRyYW5zYWN0aW9uLlxuICpcbiAqIElmIGBjb21taXRtZW50YCBvcHRpb24gaXMgbm90IHNwZWNpZmllZCwgZGVmYXVsdHMgdG8gJ21heCcgY29tbWl0bWVudC5cbiAqXG4gKiBAcGFyYW0ge0Nvbm5lY3Rpb259IGNvbm5lY3Rpb25cbiAqIEBwYXJhbSB7VHJhbnNhY3Rpb259IHRyYW5zYWN0aW9uXG4gKiBAcGFyYW0ge0FycmF5PFNpZ25lcj59IHNpZ25lcnNcbiAqIEBwYXJhbSB7Q29uZmlybU9wdGlvbnN9IFtvcHRpb25zXVxuICogQHJldHVybnMge1Byb21pc2U8VHJhbnNhY3Rpb25TaWduYXR1cmU+fVxuICovXG5hc3luYyBmdW5jdGlvbiBzZW5kQW5kQ29uZmlybVRyYW5zYWN0aW9uKGNvbm5lY3Rpb24sIHRyYW5zYWN0aW9uLCBzaWduZXJzLCBvcHRpb25zKSB7XG4gIGNvbnN0IHNlbmRPcHRpb25zID0gb3B0aW9ucyAmJiB7XG4gICAgc2tpcFByZWZsaWdodDogb3B0aW9ucy5za2lwUHJlZmxpZ2h0LFxuICAgIHByZWZsaWdodENvbW1pdG1lbnQ6IG9wdGlvbnMucHJlZmxpZ2h0Q29tbWl0bWVudCB8fCBvcHRpb25zLmNvbW1pdG1lbnQsXG4gICAgbWF4UmV0cmllczogb3B0aW9ucy5tYXhSZXRyaWVzLFxuICAgIG1pbkNvbnRleHRTbG90OiBvcHRpb25zLm1pbkNvbnRleHRTbG90XG4gIH07XG4gIGNvbnN0IHNpZ25hdHVyZSA9IGF3YWl0IGNvbm5lY3Rpb24uc2VuZFRyYW5zYWN0aW9uKHRyYW5zYWN0aW9uLCBzaWduZXJzLCBzZW5kT3B0aW9ucyk7XG4gIGxldCBzdGF0dXM7XG4gIGlmICh0cmFuc2FjdGlvbi5yZWNlbnRCbG9ja2hhc2ggIT0gbnVsbCAmJiB0cmFuc2FjdGlvbi5sYXN0VmFsaWRCbG9ja0hlaWdodCAhPSBudWxsKSB7XG4gICAgc3RhdHVzID0gKGF3YWl0IGNvbm5lY3Rpb24uY29uZmlybVRyYW5zYWN0aW9uKHtcbiAgICAgIGFib3J0U2lnbmFsOiBvcHRpb25zPy5hYm9ydFNpZ25hbCxcbiAgICAgIHNpZ25hdHVyZTogc2lnbmF0dXJlLFxuICAgICAgYmxvY2toYXNoOiB0cmFuc2FjdGlvbi5yZWNlbnRCbG9ja2hhc2gsXG4gICAgICBsYXN0VmFsaWRCbG9ja0hlaWdodDogdHJhbnNhY3Rpb24ubGFzdFZhbGlkQmxvY2tIZWlnaHRcbiAgICB9LCBvcHRpb25zICYmIG9wdGlvbnMuY29tbWl0bWVudCkpLnZhbHVlO1xuICB9IGVsc2UgaWYgKHRyYW5zYWN0aW9uLm1pbk5vbmNlQ29udGV4dFNsb3QgIT0gbnVsbCAmJiB0cmFuc2FjdGlvbi5ub25jZUluZm8gIT0gbnVsbCkge1xuICAgIGNvbnN0IHtcbiAgICAgIG5vbmNlSW5zdHJ1Y3Rpb25cbiAgICB9ID0gdHJhbnNhY3Rpb24ubm9uY2VJbmZvO1xuICAgIGNvbnN0IG5vbmNlQWNjb3VudFB1YmtleSA9IG5vbmNlSW5zdHJ1Y3Rpb24ua2V5c1swXS5wdWJrZXk7XG4gICAgc3RhdHVzID0gKGF3YWl0IGNvbm5lY3Rpb24uY29uZmlybVRyYW5zYWN0aW9uKHtcbiAgICAgIGFib3J0U2lnbmFsOiBvcHRpb25zPy5hYm9ydFNpZ25hbCxcbiAgICAgIG1pbkNvbnRleHRTbG90OiB0cmFuc2FjdGlvbi5taW5Ob25jZUNvbnRleHRTbG90LFxuICAgICAgbm9uY2VBY2NvdW50UHVia2V5LFxuICAgICAgbm9uY2VWYWx1ZTogdHJhbnNhY3Rpb24ubm9uY2VJbmZvLm5vbmNlLFxuICAgICAgc2lnbmF0dXJlXG4gICAgfSwgb3B0aW9ucyAmJiBvcHRpb25zLmNvbW1pdG1lbnQpKS52YWx1ZTtcbiAgfSBlbHNlIHtcbiAgICBpZiAob3B0aW9ucz8uYWJvcnRTaWduYWwgIT0gbnVsbCkge1xuICAgICAgY29uc29sZS53YXJuKCdzZW5kQW5kQ29uZmlybVRyYW5zYWN0aW9uKCk6IEEgdHJhbnNhY3Rpb24gd2l0aCBhIGRlcHJlY2F0ZWQgY29uZmlybWF0aW9uIHN0cmF0ZWd5IHdhcyAnICsgJ3N1cHBsaWVkIGFsb25nIHdpdGggYW4gYGFib3J0U2lnbmFsYC4gT25seSB0cmFuc2FjdGlvbnMgaGF2aW5nIGBsYXN0VmFsaWRCbG9ja0hlaWdodGAgJyArICdvciBhIGNvbWJpbmF0aW9uIG9mIGBub25jZUluZm9gIGFuZCBgbWluTm9uY2VDb250ZXh0U2xvdGAgYXJlIGFib3J0YWJsZS4nKTtcbiAgICB9XG4gICAgc3RhdHVzID0gKGF3YWl0IGNvbm5lY3Rpb24uY29uZmlybVRyYW5zYWN0aW9uKHNpZ25hdHVyZSwgb3B0aW9ucyAmJiBvcHRpb25zLmNvbW1pdG1lbnQpKS52YWx1ZTtcbiAgfVxuICBpZiAoc3RhdHVzLmVycikge1xuICAgIHRocm93IG5ldyBFcnJvcihgVHJhbnNhY3Rpb24gJHtzaWduYXR1cmV9IGZhaWxlZCAoJHtKU09OLnN0cmluZ2lmeShzdGF0dXMpfSlgKTtcbiAgfVxuICByZXR1cm4gc2lnbmF0dXJlO1xufVxuXG4vLyB6enpcbmZ1bmN0aW9uIHNsZWVwKG1zKSB7XG4gIHJldHVybiBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgbXMpKTtcbn1cblxuLyoqXG4gKiBAaW50ZXJuYWxcbiAqL1xuXG4vKipcbiAqIFBvcHVsYXRlIGEgYnVmZmVyIG9mIGluc3RydWN0aW9uIGRhdGEgdXNpbmcgYW4gSW5zdHJ1Y3Rpb25UeXBlXG4gKiBAaW50ZXJuYWxcbiAqL1xuZnVuY3Rpb24gZW5jb2RlRGF0YSh0eXBlLCBmaWVsZHMpIHtcbiAgY29uc3QgYWxsb2NMZW5ndGggPSB0eXBlLmxheW91dC5zcGFuID49IDAgPyB0eXBlLmxheW91dC5zcGFuIDogZ2V0QWxsb2ModHlwZSwgZmllbGRzKTtcbiAgY29uc3QgZGF0YSA9IEJ1ZmZlci5hbGxvYyhhbGxvY0xlbmd0aCk7XG4gIGNvbnN0IGxheW91dEZpZWxkcyA9IE9iamVjdC5hc3NpZ24oe1xuICAgIGluc3RydWN0aW9uOiB0eXBlLmluZGV4XG4gIH0sIGZpZWxkcyk7XG4gIHR5cGUubGF5b3V0LmVuY29kZShsYXlvdXRGaWVsZHMsIGRhdGEpO1xuICByZXR1cm4gZGF0YTtcbn1cblxuLyoqXG4gKiBEZWNvZGUgaW5zdHJ1Y3Rpb24gZGF0YSBidWZmZXIgdXNpbmcgYW4gSW5zdHJ1Y3Rpb25UeXBlXG4gKiBAaW50ZXJuYWxcbiAqL1xuZnVuY3Rpb24gZGVjb2RlRGF0YSQxKHR5cGUsIGJ1ZmZlcikge1xuICBsZXQgZGF0YTtcbiAgdHJ5IHtcbiAgICBkYXRhID0gdHlwZS5sYXlvdXQuZGVjb2RlKGJ1ZmZlcik7XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBpbnN0cnVjdGlvbjsgJyArIGVycik7XG4gIH1cbiAgaWYgKGRhdGEuaW5zdHJ1Y3Rpb24gIT09IHR5cGUuaW5kZXgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYGludmFsaWQgaW5zdHJ1Y3Rpb247IGluc3RydWN0aW9uIGluZGV4IG1pc21hdGNoICR7ZGF0YS5pbnN0cnVjdGlvbn0gIT0gJHt0eXBlLmluZGV4fWApO1xuICB9XG4gIHJldHVybiBkYXRhO1xufVxuXG4vKipcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9zb2xhbmEtbGFicy9zb2xhbmEvYmxvYi85MGJlZGQ3ZTA2N2I1YjhmM2RkYmI0NWRhMDBhNGU5Y2FiYjIyYzYyL3Nkay9zcmMvZmVlX2NhbGN1bGF0b3IucnMjTDctTDExXG4gKlxuICogQGludGVybmFsXG4gKi9cbmNvbnN0IEZlZUNhbGN1bGF0b3JMYXlvdXQgPSBCdWZmZXJMYXlvdXQubnU2NCgnbGFtcG9ydHNQZXJTaWduYXR1cmUnKTtcblxuLyoqXG4gKiBDYWxjdWxhdG9yIGZvciB0cmFuc2FjdGlvbiBmZWVzLlxuICpcbiAqIEBkZXByZWNhdGVkIERlcHJlY2F0ZWQgc2luY2UgU29sYW5hIHYxLjguMC5cbiAqL1xuXG4vKipcbiAqIFNlZSBodHRwczovL2dpdGh1Yi5jb20vc29sYW5hLWxhYnMvc29sYW5hL2Jsb2IvMGVhMjg0M2VjOWNkYzUxNzU3MmI4ZTYyYzk1OWY0MWI1NWNmNDQ1My9zZGsvc3JjL25vbmNlX3N0YXRlLnJzI0wyOS1MMzJcbiAqXG4gKiBAaW50ZXJuYWxcbiAqL1xuY29uc3QgTm9uY2VBY2NvdW50TGF5b3V0ID0gQnVmZmVyTGF5b3V0LnN0cnVjdChbQnVmZmVyTGF5b3V0LnUzMigndmVyc2lvbicpLCBCdWZmZXJMYXlvdXQudTMyKCdzdGF0ZScpLCBwdWJsaWNLZXkoJ2F1dGhvcml6ZWRQdWJrZXknKSwgcHVibGljS2V5KCdub25jZScpLCBCdWZmZXJMYXlvdXQuc3RydWN0KFtGZWVDYWxjdWxhdG9yTGF5b3V0XSwgJ2ZlZUNhbGN1bGF0b3InKV0pO1xuY29uc3QgTk9OQ0VfQUNDT1VOVF9MRU5HVEggPSBOb25jZUFjY291bnRMYXlvdXQuc3BhbjtcblxuLyoqXG4gKiBBIGR1cmFibGUgbm9uY2UgaXMgYSAzMiBieXRlIHZhbHVlIGVuY29kZWQgYXMgYSBiYXNlNTggc3RyaW5nLlxuICovXG5cbi8qKlxuICogTm9uY2VBY2NvdW50IGNsYXNzXG4gKi9cbmNsYXNzIE5vbmNlQWNjb3VudCB7XG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIGNvbnN0cnVjdG9yKGFyZ3MpIHtcbiAgICB0aGlzLmF1dGhvcml6ZWRQdWJrZXkgPSB2b2lkIDA7XG4gICAgdGhpcy5ub25jZSA9IHZvaWQgMDtcbiAgICB0aGlzLmZlZUNhbGN1bGF0b3IgPSB2b2lkIDA7XG4gICAgdGhpcy5hdXRob3JpemVkUHVia2V5ID0gYXJncy5hdXRob3JpemVkUHVia2V5O1xuICAgIHRoaXMubm9uY2UgPSBhcmdzLm5vbmNlO1xuICAgIHRoaXMuZmVlQ2FsY3VsYXRvciA9IGFyZ3MuZmVlQ2FsY3VsYXRvcjtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZXNlcmlhbGl6ZSBOb25jZUFjY291bnQgZnJvbSB0aGUgYWNjb3VudCBkYXRhLlxuICAgKlxuICAgKiBAcGFyYW0gYnVmZmVyIGFjY291bnQgZGF0YVxuICAgKiBAcmV0dXJuIE5vbmNlQWNjb3VudFxuICAgKi9cbiAgc3RhdGljIGZyb21BY2NvdW50RGF0YShidWZmZXIpIHtcbiAgICBjb25zdCBub25jZUFjY291bnQgPSBOb25jZUFjY291bnRMYXlvdXQuZGVjb2RlKHRvQnVmZmVyKGJ1ZmZlciksIDApO1xuICAgIHJldHVybiBuZXcgTm9uY2VBY2NvdW50KHtcbiAgICAgIGF1dGhvcml6ZWRQdWJrZXk6IG5ldyBQdWJsaWNLZXkobm9uY2VBY2NvdW50LmF1dGhvcml6ZWRQdWJrZXkpLFxuICAgICAgbm9uY2U6IG5ldyBQdWJsaWNLZXkobm9uY2VBY2NvdW50Lm5vbmNlKS50b1N0cmluZygpLFxuICAgICAgZmVlQ2FsY3VsYXRvcjogbm9uY2VBY2NvdW50LmZlZUNhbGN1bGF0b3JcbiAgICB9KTtcbiAgfVxufVxuXG5jb25zdCBlbmNvZGVEZWNvZGUgPSBsYXlvdXQgPT4ge1xuICBjb25zdCBkZWNvZGUgPSBsYXlvdXQuZGVjb2RlLmJpbmQobGF5b3V0KTtcbiAgY29uc3QgZW5jb2RlID0gbGF5b3V0LmVuY29kZS5iaW5kKGxheW91dCk7XG4gIHJldHVybiB7XG4gICAgZGVjb2RlLFxuICAgIGVuY29kZVxuICB9O1xufTtcbmNvbnN0IGJpZ0ludCA9IGxlbmd0aCA9PiBwcm9wZXJ0eSA9PiB7XG4gIGNvbnN0IGxheW91dCA9IGJsb2IobGVuZ3RoLCBwcm9wZXJ0eSk7XG4gIGNvbnN0IHtcbiAgICBlbmNvZGUsXG4gICAgZGVjb2RlXG4gIH0gPSBlbmNvZGVEZWNvZGUobGF5b3V0KTtcbiAgY29uc3QgYmlnSW50TGF5b3V0ID0gbGF5b3V0O1xuICBiaWdJbnRMYXlvdXQuZGVjb2RlID0gKGJ1ZmZlciwgb2Zmc2V0KSA9PiB7XG4gICAgY29uc3Qgc3JjID0gZGVjb2RlKGJ1ZmZlciwgb2Zmc2V0KTtcbiAgICByZXR1cm4gdG9CaWdJbnRMRShCdWZmZXIuZnJvbShzcmMpKTtcbiAgfTtcbiAgYmlnSW50TGF5b3V0LmVuY29kZSA9IChiaWdJbnQsIGJ1ZmZlciwgb2Zmc2V0KSA9PiB7XG4gICAgY29uc3Qgc3JjID0gdG9CdWZmZXJMRShiaWdJbnQsIGxlbmd0aCk7XG4gICAgcmV0dXJuIGVuY29kZShzcmMsIGJ1ZmZlciwgb2Zmc2V0KTtcbiAgfTtcbiAgcmV0dXJuIGJpZ0ludExheW91dDtcbn07XG5jb25zdCB1NjQgPSBiaWdJbnQoOCk7XG5cbi8qKlxuICogQ3JlYXRlIGFjY291bnQgc3lzdGVtIHRyYW5zYWN0aW9uIHBhcmFtc1xuICovXG5cbi8qKlxuICogVHJhbnNmZXIgc3lzdGVtIHRyYW5zYWN0aW9uIHBhcmFtc1xuICovXG5cbi8qKlxuICogQXNzaWduIHN5c3RlbSB0cmFuc2FjdGlvbiBwYXJhbXNcbiAqL1xuXG4vKipcbiAqIENyZWF0ZSBhY2NvdW50IHdpdGggc2VlZCBzeXN0ZW0gdHJhbnNhY3Rpb24gcGFyYW1zXG4gKi9cblxuLyoqXG4gKiBDcmVhdGUgbm9uY2UgYWNjb3VudCBzeXN0ZW0gdHJhbnNhY3Rpb24gcGFyYW1zXG4gKi9cblxuLyoqXG4gKiBDcmVhdGUgbm9uY2UgYWNjb3VudCB3aXRoIHNlZWQgc3lzdGVtIHRyYW5zYWN0aW9uIHBhcmFtc1xuICovXG5cbi8qKlxuICogSW5pdGlhbGl6ZSBub25jZSBhY2NvdW50IHN5c3RlbSBpbnN0cnVjdGlvbiBwYXJhbXNcbiAqL1xuXG4vKipcbiAqIEFkdmFuY2Ugbm9uY2UgYWNjb3VudCBzeXN0ZW0gaW5zdHJ1Y3Rpb24gcGFyYW1zXG4gKi9cblxuLyoqXG4gKiBXaXRoZHJhdyBub25jZSBhY2NvdW50IHN5c3RlbSB0cmFuc2FjdGlvbiBwYXJhbXNcbiAqL1xuXG4vKipcbiAqIEF1dGhvcml6ZSBub25jZSBhY2NvdW50IHN5c3RlbSB0cmFuc2FjdGlvbiBwYXJhbXNcbiAqL1xuXG4vKipcbiAqIEFsbG9jYXRlIGFjY291bnQgc3lzdGVtIHRyYW5zYWN0aW9uIHBhcmFtc1xuICovXG5cbi8qKlxuICogQWxsb2NhdGUgYWNjb3VudCB3aXRoIHNlZWQgc3lzdGVtIHRyYW5zYWN0aW9uIHBhcmFtc1xuICovXG5cbi8qKlxuICogQXNzaWduIGFjY291bnQgd2l0aCBzZWVkIHN5c3RlbSB0cmFuc2FjdGlvbiBwYXJhbXNcbiAqL1xuXG4vKipcbiAqIFRyYW5zZmVyIHdpdGggc2VlZCBzeXN0ZW0gdHJhbnNhY3Rpb24gcGFyYW1zXG4gKi9cblxuLyoqIERlY29kZWQgdHJhbnNmZXIgc3lzdGVtIHRyYW5zYWN0aW9uIGluc3RydWN0aW9uICovXG5cbi8qKiBEZWNvZGVkIHRyYW5zZmVyV2l0aFNlZWQgc3lzdGVtIHRyYW5zYWN0aW9uIGluc3RydWN0aW9uICovXG5cbi8qKlxuICogU3lzdGVtIEluc3RydWN0aW9uIGNsYXNzXG4gKi9cbmNsYXNzIFN5c3RlbUluc3RydWN0aW9uIHtcbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgY29uc3RydWN0b3IoKSB7fVxuXG4gIC8qKlxuICAgKiBEZWNvZGUgYSBzeXN0ZW0gaW5zdHJ1Y3Rpb24gYW5kIHJldHJpZXZlIHRoZSBpbnN0cnVjdGlvbiB0eXBlLlxuICAgKi9cbiAgc3RhdGljIGRlY29kZUluc3RydWN0aW9uVHlwZShpbnN0cnVjdGlvbikge1xuICAgIHRoaXMuY2hlY2tQcm9ncmFtSWQoaW5zdHJ1Y3Rpb24ucHJvZ3JhbUlkKTtcbiAgICBjb25zdCBpbnN0cnVjdGlvblR5cGVMYXlvdXQgPSBCdWZmZXJMYXlvdXQudTMyKCdpbnN0cnVjdGlvbicpO1xuICAgIGNvbnN0IHR5cGVJbmRleCA9IGluc3RydWN0aW9uVHlwZUxheW91dC5kZWNvZGUoaW5zdHJ1Y3Rpb24uZGF0YSk7XG4gICAgbGV0IHR5cGU7XG4gICAgZm9yIChjb25zdCBbaXhUeXBlLCBsYXlvdXRdIG9mIE9iamVjdC5lbnRyaWVzKFNZU1RFTV9JTlNUUlVDVElPTl9MQVlPVVRTKSkge1xuICAgICAgaWYgKGxheW91dC5pbmRleCA9PSB0eXBlSW5kZXgpIHtcbiAgICAgICAgdHlwZSA9IGl4VHlwZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICghdHlwZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnN0cnVjdGlvbiB0eXBlIGluY29ycmVjdDsgbm90IGEgU3lzdGVtSW5zdHJ1Y3Rpb24nKTtcbiAgICB9XG4gICAgcmV0dXJuIHR5cGU7XG4gIH1cblxuICAvKipcbiAgICogRGVjb2RlIGEgY3JlYXRlIGFjY291bnQgc3lzdGVtIGluc3RydWN0aW9uIGFuZCByZXRyaWV2ZSB0aGUgaW5zdHJ1Y3Rpb24gcGFyYW1zLlxuICAgKi9cbiAgc3RhdGljIGRlY29kZUNyZWF0ZUFjY291bnQoaW5zdHJ1Y3Rpb24pIHtcbiAgICB0aGlzLmNoZWNrUHJvZ3JhbUlkKGluc3RydWN0aW9uLnByb2dyYW1JZCk7XG4gICAgdGhpcy5jaGVja0tleUxlbmd0aChpbnN0cnVjdGlvbi5rZXlzLCAyKTtcbiAgICBjb25zdCB7XG4gICAgICBsYW1wb3J0cyxcbiAgICAgIHNwYWNlLFxuICAgICAgcHJvZ3JhbUlkXG4gICAgfSA9IGRlY29kZURhdGEkMShTWVNURU1fSU5TVFJVQ1RJT05fTEFZT1VUUy5DcmVhdGUsIGluc3RydWN0aW9uLmRhdGEpO1xuICAgIHJldHVybiB7XG4gICAgICBmcm9tUHVia2V5OiBpbnN0cnVjdGlvbi5rZXlzWzBdLnB1YmtleSxcbiAgICAgIG5ld0FjY291bnRQdWJrZXk6IGluc3RydWN0aW9uLmtleXNbMV0ucHVia2V5LFxuICAgICAgbGFtcG9ydHMsXG4gICAgICBzcGFjZSxcbiAgICAgIHByb2dyYW1JZDogbmV3IFB1YmxpY0tleShwcm9ncmFtSWQpXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZWNvZGUgYSB0cmFuc2ZlciBzeXN0ZW0gaW5zdHJ1Y3Rpb24gYW5kIHJldHJpZXZlIHRoZSBpbnN0cnVjdGlvbiBwYXJhbXMuXG4gICAqL1xuICBzdGF0aWMgZGVjb2RlVHJhbnNmZXIoaW5zdHJ1Y3Rpb24pIHtcbiAgICB0aGlzLmNoZWNrUHJvZ3JhbUlkKGluc3RydWN0aW9uLnByb2dyYW1JZCk7XG4gICAgdGhpcy5jaGVja0tleUxlbmd0aChpbnN0cnVjdGlvbi5rZXlzLCAyKTtcbiAgICBjb25zdCB7XG4gICAgICBsYW1wb3J0c1xuICAgIH0gPSBkZWNvZGVEYXRhJDEoU1lTVEVNX0lOU1RSVUNUSU9OX0xBWU9VVFMuVHJhbnNmZXIsIGluc3RydWN0aW9uLmRhdGEpO1xuICAgIHJldHVybiB7XG4gICAgICBmcm9tUHVia2V5OiBpbnN0cnVjdGlvbi5rZXlzWzBdLnB1YmtleSxcbiAgICAgIHRvUHVia2V5OiBpbnN0cnVjdGlvbi5rZXlzWzFdLnB1YmtleSxcbiAgICAgIGxhbXBvcnRzXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZWNvZGUgYSB0cmFuc2ZlciB3aXRoIHNlZWQgc3lzdGVtIGluc3RydWN0aW9uIGFuZCByZXRyaWV2ZSB0aGUgaW5zdHJ1Y3Rpb24gcGFyYW1zLlxuICAgKi9cbiAgc3RhdGljIGRlY29kZVRyYW5zZmVyV2l0aFNlZWQoaW5zdHJ1Y3Rpb24pIHtcbiAgICB0aGlzLmNoZWNrUHJvZ3JhbUlkKGluc3RydWN0aW9uLnByb2dyYW1JZCk7XG4gICAgdGhpcy5jaGVja0tleUxlbmd0aChpbnN0cnVjdGlvbi5rZXlzLCAzKTtcbiAgICBjb25zdCB7XG4gICAgICBsYW1wb3J0cyxcbiAgICAgIHNlZWQsXG4gICAgICBwcm9ncmFtSWRcbiAgICB9ID0gZGVjb2RlRGF0YSQxKFNZU1RFTV9JTlNUUlVDVElPTl9MQVlPVVRTLlRyYW5zZmVyV2l0aFNlZWQsIGluc3RydWN0aW9uLmRhdGEpO1xuICAgIHJldHVybiB7XG4gICAgICBmcm9tUHVia2V5OiBpbnN0cnVjdGlvbi5rZXlzWzBdLnB1YmtleSxcbiAgICAgIGJhc2VQdWJrZXk6IGluc3RydWN0aW9uLmtleXNbMV0ucHVia2V5LFxuICAgICAgdG9QdWJrZXk6IGluc3RydWN0aW9uLmtleXNbMl0ucHVia2V5LFxuICAgICAgbGFtcG9ydHMsXG4gICAgICBzZWVkLFxuICAgICAgcHJvZ3JhbUlkOiBuZXcgUHVibGljS2V5KHByb2dyYW1JZClcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIERlY29kZSBhbiBhbGxvY2F0ZSBzeXN0ZW0gaW5zdHJ1Y3Rpb24gYW5kIHJldHJpZXZlIHRoZSBpbnN0cnVjdGlvbiBwYXJhbXMuXG4gICAqL1xuICBzdGF0aWMgZGVjb2RlQWxsb2NhdGUoaW5zdHJ1Y3Rpb24pIHtcbiAgICB0aGlzLmNoZWNrUHJvZ3JhbUlkKGluc3RydWN0aW9uLnByb2dyYW1JZCk7XG4gICAgdGhpcy5jaGVja0tleUxlbmd0aChpbnN0cnVjdGlvbi5rZXlzLCAxKTtcbiAgICBjb25zdCB7XG4gICAgICBzcGFjZVxuICAgIH0gPSBkZWNvZGVEYXRhJDEoU1lTVEVNX0lOU1RSVUNUSU9OX0xBWU9VVFMuQWxsb2NhdGUsIGluc3RydWN0aW9uLmRhdGEpO1xuICAgIHJldHVybiB7XG4gICAgICBhY2NvdW50UHVia2V5OiBpbnN0cnVjdGlvbi5rZXlzWzBdLnB1YmtleSxcbiAgICAgIHNwYWNlXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZWNvZGUgYW4gYWxsb2NhdGUgd2l0aCBzZWVkIHN5c3RlbSBpbnN0cnVjdGlvbiBhbmQgcmV0cmlldmUgdGhlIGluc3RydWN0aW9uIHBhcmFtcy5cbiAgICovXG4gIHN0YXRpYyBkZWNvZGVBbGxvY2F0ZVdpdGhTZWVkKGluc3RydWN0aW9uKSB7XG4gICAgdGhpcy5jaGVja1Byb2dyYW1JZChpbnN0cnVjdGlvbi5wcm9ncmFtSWQpO1xuICAgIHRoaXMuY2hlY2tLZXlMZW5ndGgoaW5zdHJ1Y3Rpb24ua2V5cywgMSk7XG4gICAgY29uc3Qge1xuICAgICAgYmFzZSxcbiAgICAgIHNlZWQsXG4gICAgICBzcGFjZSxcbiAgICAgIHByb2dyYW1JZFxuICAgIH0gPSBkZWNvZGVEYXRhJDEoU1lTVEVNX0lOU1RSVUNUSU9OX0xBWU9VVFMuQWxsb2NhdGVXaXRoU2VlZCwgaW5zdHJ1Y3Rpb24uZGF0YSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIGFjY291bnRQdWJrZXk6IGluc3RydWN0aW9uLmtleXNbMF0ucHVia2V5LFxuICAgICAgYmFzZVB1YmtleTogbmV3IFB1YmxpY0tleShiYXNlKSxcbiAgICAgIHNlZWQsXG4gICAgICBzcGFjZSxcbiAgICAgIHByb2dyYW1JZDogbmV3IFB1YmxpY0tleShwcm9ncmFtSWQpXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZWNvZGUgYW4gYXNzaWduIHN5c3RlbSBpbnN0cnVjdGlvbiBhbmQgcmV0cmlldmUgdGhlIGluc3RydWN0aW9uIHBhcmFtcy5cbiAgICovXG4gIHN0YXRpYyBkZWNvZGVBc3NpZ24oaW5zdHJ1Y3Rpb24pIHtcbiAgICB0aGlzLmNoZWNrUHJvZ3JhbUlkKGluc3RydWN0aW9uLnByb2dyYW1JZCk7XG4gICAgdGhpcy5jaGVja0tleUxlbmd0aChpbnN0cnVjdGlvbi5rZXlzLCAxKTtcbiAgICBjb25zdCB7XG4gICAgICBwcm9ncmFtSWRcbiAgICB9ID0gZGVjb2RlRGF0YSQxKFNZU1RFTV9JTlNUUlVDVElPTl9MQVlPVVRTLkFzc2lnbiwgaW5zdHJ1Y3Rpb24uZGF0YSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIGFjY291bnRQdWJrZXk6IGluc3RydWN0aW9uLmtleXNbMF0ucHVia2V5LFxuICAgICAgcHJvZ3JhbUlkOiBuZXcgUHVibGljS2V5KHByb2dyYW1JZClcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIERlY29kZSBhbiBhc3NpZ24gd2l0aCBzZWVkIHN5c3RlbSBpbnN0cnVjdGlvbiBhbmQgcmV0cmlldmUgdGhlIGluc3RydWN0aW9uIHBhcmFtcy5cbiAgICovXG4gIHN0YXRpYyBkZWNvZGVBc3NpZ25XaXRoU2VlZChpbnN0cnVjdGlvbikge1xuICAgIHRoaXMuY2hlY2tQcm9ncmFtSWQoaW5zdHJ1Y3Rpb24ucHJvZ3JhbUlkKTtcbiAgICB0aGlzLmNoZWNrS2V5TGVuZ3RoKGluc3RydWN0aW9uLmtleXMsIDEpO1xuICAgIGNvbnN0IHtcbiAgICAgIGJhc2UsXG4gICAgICBzZWVkLFxuICAgICAgcHJvZ3JhbUlkXG4gICAgfSA9IGRlY29kZURhdGEkMShTWVNURU1fSU5TVFJVQ1RJT05fTEFZT1VUUy5Bc3NpZ25XaXRoU2VlZCwgaW5zdHJ1Y3Rpb24uZGF0YSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIGFjY291bnRQdWJrZXk6IGluc3RydWN0aW9uLmtleXNbMF0ucHVia2V5LFxuICAgICAgYmFzZVB1YmtleTogbmV3IFB1YmxpY0tleShiYXNlKSxcbiAgICAgIHNlZWQsXG4gICAgICBwcm9ncmFtSWQ6IG5ldyBQdWJsaWNLZXkocHJvZ3JhbUlkKVxuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogRGVjb2RlIGEgY3JlYXRlIGFjY291bnQgd2l0aCBzZWVkIHN5c3RlbSBpbnN0cnVjdGlvbiBhbmQgcmV0cmlldmUgdGhlIGluc3RydWN0aW9uIHBhcmFtcy5cbiAgICovXG4gIHN0YXRpYyBkZWNvZGVDcmVhdGVXaXRoU2VlZChpbnN0cnVjdGlvbikge1xuICAgIHRoaXMuY2hlY2tQcm9ncmFtSWQoaW5zdHJ1Y3Rpb24ucHJvZ3JhbUlkKTtcbiAgICB0aGlzLmNoZWNrS2V5TGVuZ3RoKGluc3RydWN0aW9uLmtleXMsIDIpO1xuICAgIGNvbnN0IHtcbiAgICAgIGJhc2UsXG4gICAgICBzZWVkLFxuICAgICAgbGFtcG9ydHMsXG4gICAgICBzcGFjZSxcbiAgICAgIHByb2dyYW1JZFxuICAgIH0gPSBkZWNvZGVEYXRhJDEoU1lTVEVNX0lOU1RSVUNUSU9OX0xBWU9VVFMuQ3JlYXRlV2l0aFNlZWQsIGluc3RydWN0aW9uLmRhdGEpO1xuICAgIHJldHVybiB7XG4gICAgICBmcm9tUHVia2V5OiBpbnN0cnVjdGlvbi5rZXlzWzBdLnB1YmtleSxcbiAgICAgIG5ld0FjY291bnRQdWJrZXk6IGluc3RydWN0aW9uLmtleXNbMV0ucHVia2V5LFxuICAgICAgYmFzZVB1YmtleTogbmV3IFB1YmxpY0tleShiYXNlKSxcbiAgICAgIHNlZWQsXG4gICAgICBsYW1wb3J0cyxcbiAgICAgIHNwYWNlLFxuICAgICAgcHJvZ3JhbUlkOiBuZXcgUHVibGljS2V5KHByb2dyYW1JZClcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIERlY29kZSBhIG5vbmNlIGluaXRpYWxpemUgc3lzdGVtIGluc3RydWN0aW9uIGFuZCByZXRyaWV2ZSB0aGUgaW5zdHJ1Y3Rpb24gcGFyYW1zLlxuICAgKi9cbiAgc3RhdGljIGRlY29kZU5vbmNlSW5pdGlhbGl6ZShpbnN0cnVjdGlvbikge1xuICAgIHRoaXMuY2hlY2tQcm9ncmFtSWQoaW5zdHJ1Y3Rpb24ucHJvZ3JhbUlkKTtcbiAgICB0aGlzLmNoZWNrS2V5TGVuZ3RoKGluc3RydWN0aW9uLmtleXMsIDMpO1xuICAgIGNvbnN0IHtcbiAgICAgIGF1dGhvcml6ZWRcbiAgICB9ID0gZGVjb2RlRGF0YSQxKFNZU1RFTV9JTlNUUlVDVElPTl9MQVlPVVRTLkluaXRpYWxpemVOb25jZUFjY291bnQsIGluc3RydWN0aW9uLmRhdGEpO1xuICAgIHJldHVybiB7XG4gICAgICBub25jZVB1YmtleTogaW5zdHJ1Y3Rpb24ua2V5c1swXS5wdWJrZXksXG4gICAgICBhdXRob3JpemVkUHVia2V5OiBuZXcgUHVibGljS2V5KGF1dGhvcml6ZWQpXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZWNvZGUgYSBub25jZSBhZHZhbmNlIHN5c3RlbSBpbnN0cnVjdGlvbiBhbmQgcmV0cmlldmUgdGhlIGluc3RydWN0aW9uIHBhcmFtcy5cbiAgICovXG4gIHN0YXRpYyBkZWNvZGVOb25jZUFkdmFuY2UoaW5zdHJ1Y3Rpb24pIHtcbiAgICB0aGlzLmNoZWNrUHJvZ3JhbUlkKGluc3RydWN0aW9uLnByb2dyYW1JZCk7XG4gICAgdGhpcy5jaGVja0tleUxlbmd0aChpbnN0cnVjdGlvbi5rZXlzLCAzKTtcbiAgICBkZWNvZGVEYXRhJDEoU1lTVEVNX0lOU1RSVUNUSU9OX0xBWU9VVFMuQWR2YW5jZU5vbmNlQWNjb3VudCwgaW5zdHJ1Y3Rpb24uZGF0YSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIG5vbmNlUHVia2V5OiBpbnN0cnVjdGlvbi5rZXlzWzBdLnB1YmtleSxcbiAgICAgIGF1dGhvcml6ZWRQdWJrZXk6IGluc3RydWN0aW9uLmtleXNbMl0ucHVia2V5XG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZWNvZGUgYSBub25jZSB3aXRoZHJhdyBzeXN0ZW0gaW5zdHJ1Y3Rpb24gYW5kIHJldHJpZXZlIHRoZSBpbnN0cnVjdGlvbiBwYXJhbXMuXG4gICAqL1xuICBzdGF0aWMgZGVjb2RlTm9uY2VXaXRoZHJhdyhpbnN0cnVjdGlvbikge1xuICAgIHRoaXMuY2hlY2tQcm9ncmFtSWQoaW5zdHJ1Y3Rpb24ucHJvZ3JhbUlkKTtcbiAgICB0aGlzLmNoZWNrS2V5TGVuZ3RoKGluc3RydWN0aW9uLmtleXMsIDUpO1xuICAgIGNvbnN0IHtcbiAgICAgIGxhbXBvcnRzXG4gICAgfSA9IGRlY29kZURhdGEkMShTWVNURU1fSU5TVFJVQ1RJT05fTEFZT1VUUy5XaXRoZHJhd05vbmNlQWNjb3VudCwgaW5zdHJ1Y3Rpb24uZGF0YSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIG5vbmNlUHVia2V5OiBpbnN0cnVjdGlvbi5rZXlzWzBdLnB1YmtleSxcbiAgICAgIHRvUHVia2V5OiBpbnN0cnVjdGlvbi5rZXlzWzFdLnB1YmtleSxcbiAgICAgIGF1dGhvcml6ZWRQdWJrZXk6IGluc3RydWN0aW9uLmtleXNbNF0ucHVia2V5LFxuICAgICAgbGFtcG9ydHNcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIERlY29kZSBhIG5vbmNlIGF1dGhvcml6ZSBzeXN0ZW0gaW5zdHJ1Y3Rpb24gYW5kIHJldHJpZXZlIHRoZSBpbnN0cnVjdGlvbiBwYXJhbXMuXG4gICAqL1xuICBzdGF0aWMgZGVjb2RlTm9uY2VBdXRob3JpemUoaW5zdHJ1Y3Rpb24pIHtcbiAgICB0aGlzLmNoZWNrUHJvZ3JhbUlkKGluc3RydWN0aW9uLnByb2dyYW1JZCk7XG4gICAgdGhpcy5jaGVja0tleUxlbmd0aChpbnN0cnVjdGlvbi5rZXlzLCAyKTtcbiAgICBjb25zdCB7XG4gICAgICBhdXRob3JpemVkXG4gICAgfSA9IGRlY29kZURhdGEkMShTWVNURU1fSU5TVFJVQ1RJT05fTEFZT1VUUy5BdXRob3JpemVOb25jZUFjY291bnQsIGluc3RydWN0aW9uLmRhdGEpO1xuICAgIHJldHVybiB7XG4gICAgICBub25jZVB1YmtleTogaW5zdHJ1Y3Rpb24ua2V5c1swXS5wdWJrZXksXG4gICAgICBhdXRob3JpemVkUHVia2V5OiBpbnN0cnVjdGlvbi5rZXlzWzFdLnB1YmtleSxcbiAgICAgIG5ld0F1dGhvcml6ZWRQdWJrZXk6IG5ldyBQdWJsaWNLZXkoYXV0aG9yaXplZClcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgc3RhdGljIGNoZWNrUHJvZ3JhbUlkKHByb2dyYW1JZCkge1xuICAgIGlmICghcHJvZ3JhbUlkLmVxdWFscyhTeXN0ZW1Qcm9ncmFtLnByb2dyYW1JZCkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBpbnN0cnVjdGlvbjsgcHJvZ3JhbUlkIGlzIG5vdCBTeXN0ZW1Qcm9ncmFtJyk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgc3RhdGljIGNoZWNrS2V5TGVuZ3RoKGtleXMsIGV4cGVjdGVkTGVuZ3RoKSB7XG4gICAgaWYgKGtleXMubGVuZ3RoIDwgZXhwZWN0ZWRMZW5ndGgpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgaW52YWxpZCBpbnN0cnVjdGlvbjsgZm91bmQgJHtrZXlzLmxlbmd0aH0ga2V5cywgZXhwZWN0ZWQgYXQgbGVhc3QgJHtleHBlY3RlZExlbmd0aH1gKTtcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBBbiBlbnVtZXJhdGlvbiBvZiB2YWxpZCBTeXN0ZW1JbnN0cnVjdGlvblR5cGUnc1xuICovXG5cbi8qKlxuICogQW4gZW51bWVyYXRpb24gb2YgdmFsaWQgc3lzdGVtIEluc3RydWN0aW9uVHlwZSdzXG4gKiBAaW50ZXJuYWxcbiAqL1xuY29uc3QgU1lTVEVNX0lOU1RSVUNUSU9OX0xBWU9VVFMgPSBPYmplY3QuZnJlZXplKHtcbiAgQ3JlYXRlOiB7XG4gICAgaW5kZXg6IDAsXG4gICAgbGF5b3V0OiBCdWZmZXJMYXlvdXQuc3RydWN0KFtCdWZmZXJMYXlvdXQudTMyKCdpbnN0cnVjdGlvbicpLCBCdWZmZXJMYXlvdXQubnM2NCgnbGFtcG9ydHMnKSwgQnVmZmVyTGF5b3V0Lm5zNjQoJ3NwYWNlJyksIHB1YmxpY0tleSgncHJvZ3JhbUlkJyldKVxuICB9LFxuICBBc3NpZ246IHtcbiAgICBpbmRleDogMSxcbiAgICBsYXlvdXQ6IEJ1ZmZlckxheW91dC5zdHJ1Y3QoW0J1ZmZlckxheW91dC51MzIoJ2luc3RydWN0aW9uJyksIHB1YmxpY0tleSgncHJvZ3JhbUlkJyldKVxuICB9LFxuICBUcmFuc2Zlcjoge1xuICAgIGluZGV4OiAyLFxuICAgIGxheW91dDogQnVmZmVyTGF5b3V0LnN0cnVjdChbQnVmZmVyTGF5b3V0LnUzMignaW5zdHJ1Y3Rpb24nKSwgdTY0KCdsYW1wb3J0cycpXSlcbiAgfSxcbiAgQ3JlYXRlV2l0aFNlZWQ6IHtcbiAgICBpbmRleDogMyxcbiAgICBsYXlvdXQ6IEJ1ZmZlckxheW91dC5zdHJ1Y3QoW0J1ZmZlckxheW91dC51MzIoJ2luc3RydWN0aW9uJyksIHB1YmxpY0tleSgnYmFzZScpLCBydXN0U3RyaW5nKCdzZWVkJyksIEJ1ZmZlckxheW91dC5uczY0KCdsYW1wb3J0cycpLCBCdWZmZXJMYXlvdXQubnM2NCgnc3BhY2UnKSwgcHVibGljS2V5KCdwcm9ncmFtSWQnKV0pXG4gIH0sXG4gIEFkdmFuY2VOb25jZUFjY291bnQ6IHtcbiAgICBpbmRleDogNCxcbiAgICBsYXlvdXQ6IEJ1ZmZlckxheW91dC5zdHJ1Y3QoW0J1ZmZlckxheW91dC51MzIoJ2luc3RydWN0aW9uJyldKVxuICB9LFxuICBXaXRoZHJhd05vbmNlQWNjb3VudDoge1xuICAgIGluZGV4OiA1LFxuICAgIGxheW91dDogQnVmZmVyTGF5b3V0LnN0cnVjdChbQnVmZmVyTGF5b3V0LnUzMignaW5zdHJ1Y3Rpb24nKSwgQnVmZmVyTGF5b3V0Lm5zNjQoJ2xhbXBvcnRzJyldKVxuICB9LFxuICBJbml0aWFsaXplTm9uY2VBY2NvdW50OiB7XG4gICAgaW5kZXg6IDYsXG4gICAgbGF5b3V0OiBCdWZmZXJMYXlvdXQuc3RydWN0KFtCdWZmZXJMYXlvdXQudTMyKCdpbnN0cnVjdGlvbicpLCBwdWJsaWNLZXkoJ2F1dGhvcml6ZWQnKV0pXG4gIH0sXG4gIEF1dGhvcml6ZU5vbmNlQWNjb3VudDoge1xuICAgIGluZGV4OiA3LFxuICAgIGxheW91dDogQnVmZmVyTGF5b3V0LnN0cnVjdChbQnVmZmVyTGF5b3V0LnUzMignaW5zdHJ1Y3Rpb24nKSwgcHVibGljS2V5KCdhdXRob3JpemVkJyldKVxuICB9LFxuICBBbGxvY2F0ZToge1xuICAgIGluZGV4OiA4LFxuICAgIGxheW91dDogQnVmZmVyTGF5b3V0LnN0cnVjdChbQnVmZmVyTGF5b3V0LnUzMignaW5zdHJ1Y3Rpb24nKSwgQnVmZmVyTGF5b3V0Lm5zNjQoJ3NwYWNlJyldKVxuICB9LFxuICBBbGxvY2F0ZVdpdGhTZWVkOiB7XG4gICAgaW5kZXg6IDksXG4gICAgbGF5b3V0OiBCdWZmZXJMYXlvdXQuc3RydWN0KFtCdWZmZXJMYXlvdXQudTMyKCdpbnN0cnVjdGlvbicpLCBwdWJsaWNLZXkoJ2Jhc2UnKSwgcnVzdFN0cmluZygnc2VlZCcpLCBCdWZmZXJMYXlvdXQubnM2NCgnc3BhY2UnKSwgcHVibGljS2V5KCdwcm9ncmFtSWQnKV0pXG4gIH0sXG4gIEFzc2lnbldpdGhTZWVkOiB7XG4gICAgaW5kZXg6IDEwLFxuICAgIGxheW91dDogQnVmZmVyTGF5b3V0LnN0cnVjdChbQnVmZmVyTGF5b3V0LnUzMignaW5zdHJ1Y3Rpb24nKSwgcHVibGljS2V5KCdiYXNlJyksIHJ1c3RTdHJpbmcoJ3NlZWQnKSwgcHVibGljS2V5KCdwcm9ncmFtSWQnKV0pXG4gIH0sXG4gIFRyYW5zZmVyV2l0aFNlZWQ6IHtcbiAgICBpbmRleDogMTEsXG4gICAgbGF5b3V0OiBCdWZmZXJMYXlvdXQuc3RydWN0KFtCdWZmZXJMYXlvdXQudTMyKCdpbnN0cnVjdGlvbicpLCB1NjQoJ2xhbXBvcnRzJyksIHJ1c3RTdHJpbmcoJ3NlZWQnKSwgcHVibGljS2V5KCdwcm9ncmFtSWQnKV0pXG4gIH0sXG4gIFVwZ3JhZGVOb25jZUFjY291bnQ6IHtcbiAgICBpbmRleDogMTIsXG4gICAgbGF5b3V0OiBCdWZmZXJMYXlvdXQuc3RydWN0KFtCdWZmZXJMYXlvdXQudTMyKCdpbnN0cnVjdGlvbicpXSlcbiAgfVxufSk7XG5cbi8qKlxuICogRmFjdG9yeSBjbGFzcyBmb3IgdHJhbnNhY3Rpb25zIHRvIGludGVyYWN0IHdpdGggdGhlIFN5c3RlbSBwcm9ncmFtXG4gKi9cbmNsYXNzIFN5c3RlbVByb2dyYW0ge1xuICAvKipcbiAgICogQGludGVybmFsXG4gICAqL1xuICBjb25zdHJ1Y3RvcigpIHt9XG5cbiAgLyoqXG4gICAqIFB1YmxpYyBrZXkgdGhhdCBpZGVudGlmaWVzIHRoZSBTeXN0ZW0gcHJvZ3JhbVxuICAgKi9cblxuICAvKipcbiAgICogR2VuZXJhdGUgYSB0cmFuc2FjdGlvbiBpbnN0cnVjdGlvbiB0aGF0IGNyZWF0ZXMgYSBuZXcgYWNjb3VudFxuICAgKi9cbiAgc3RhdGljIGNyZWF0ZUFjY291bnQocGFyYW1zKSB7XG4gICAgY29uc3QgdHlwZSA9IFNZU1RFTV9JTlNUUlVDVElPTl9MQVlPVVRTLkNyZWF0ZTtcbiAgICBjb25zdCBkYXRhID0gZW5jb2RlRGF0YSh0eXBlLCB7XG4gICAgICBsYW1wb3J0czogcGFyYW1zLmxhbXBvcnRzLFxuICAgICAgc3BhY2U6IHBhcmFtcy5zcGFjZSxcbiAgICAgIHByb2dyYW1JZDogdG9CdWZmZXIocGFyYW1zLnByb2dyYW1JZC50b0J1ZmZlcigpKVxuICAgIH0pO1xuICAgIHJldHVybiBuZXcgVHJhbnNhY3Rpb25JbnN0cnVjdGlvbih7XG4gICAgICBrZXlzOiBbe1xuICAgICAgICBwdWJrZXk6IHBhcmFtcy5mcm9tUHVia2V5LFxuICAgICAgICBpc1NpZ25lcjogdHJ1ZSxcbiAgICAgICAgaXNXcml0YWJsZTogdHJ1ZVxuICAgICAgfSwge1xuICAgICAgICBwdWJrZXk6IHBhcmFtcy5uZXdBY2NvdW50UHVia2V5LFxuICAgICAgICBpc1NpZ25lcjogdHJ1ZSxcbiAgICAgICAgaXNXcml0YWJsZTogdHJ1ZVxuICAgICAgfV0sXG4gICAgICBwcm9ncmFtSWQ6IHRoaXMucHJvZ3JhbUlkLFxuICAgICAgZGF0YVxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEdlbmVyYXRlIGEgdHJhbnNhY3Rpb24gaW5zdHJ1Y3Rpb24gdGhhdCB0cmFuc2ZlcnMgbGFtcG9ydHMgZnJvbSBvbmUgYWNjb3VudCB0byBhbm90aGVyXG4gICAqL1xuICBzdGF0aWMgdHJhbnNmZXIocGFyYW1zKSB7XG4gICAgbGV0IGRhdGE7XG4gICAgbGV0IGtleXM7XG4gICAgaWYgKCdiYXNlUHVia2V5JyBpbiBwYXJhbXMpIHtcbiAgICAgIGNvbnN0IHR5cGUgPSBTWVNURU1fSU5TVFJVQ1RJT05fTEFZT1VUUy5UcmFuc2ZlcldpdGhTZWVkO1xuICAgICAgZGF0YSA9IGVuY29kZURhdGEodHlwZSwge1xuICAgICAgICBsYW1wb3J0czogQmlnSW50KHBhcmFtcy5sYW1wb3J0cyksXG4gICAgICAgIHNlZWQ6IHBhcmFtcy5zZWVkLFxuICAgICAgICBwcm9ncmFtSWQ6IHRvQnVmZmVyKHBhcmFtcy5wcm9ncmFtSWQudG9CdWZmZXIoKSlcbiAgICAgIH0pO1xuICAgICAga2V5cyA9IFt7XG4gICAgICAgIHB1YmtleTogcGFyYW1zLmZyb21QdWJrZXksXG4gICAgICAgIGlzU2lnbmVyOiBmYWxzZSxcbiAgICAgICAgaXNXcml0YWJsZTogdHJ1ZVxuICAgICAgfSwge1xuICAgICAgICBwdWJrZXk6IHBhcmFtcy5iYXNlUHVia2V5LFxuICAgICAgICBpc1NpZ25lcjogdHJ1ZSxcbiAgICAgICAgaXNXcml0YWJsZTogZmFsc2VcbiAgICAgIH0sIHtcbiAgICAgICAgcHVia2V5OiBwYXJhbXMudG9QdWJrZXksXG4gICAgICAgIGlzU2lnbmVyOiBmYWxzZSxcbiAgICAgICAgaXNXcml0YWJsZTogdHJ1ZVxuICAgICAgfV07XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IHR5cGUgPSBTWVNURU1fSU5TVFJVQ1RJT05fTEFZT1VUUy5UcmFuc2ZlcjtcbiAgICAgIGRhdGEgPSBlbmNvZGVEYXRhKHR5cGUsIHtcbiAgICAgICAgbGFtcG9ydHM6IEJpZ0ludChwYXJhbXMubGFtcG9ydHMpXG4gICAgICB9KTtcbiAgICAgIGtleXMgPSBbe1xuICAgICAgICBwdWJrZXk6IHBhcmFtcy5mcm9tUHVia2V5LFxuICAgICAgICBpc1NpZ25lcjogdHJ1ZSxcbiAgICAgICAgaXNXcml0YWJsZTogdHJ1ZVxuICAgICAgfSwge1xuICAgICAgICBwdWJrZXk6IHBhcmFtcy50b1B1YmtleSxcbiAgICAgICAgaXNTaWduZXI6IGZhbHNlLFxuICAgICAgICBpc1dyaXRhYmxlOiB0cnVlXG4gICAgICB9XTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBUcmFuc2FjdGlvbkluc3RydWN0aW9uKHtcbiAgICAgIGtleXMsXG4gICAgICBwcm9ncmFtSWQ6IHRoaXMucHJvZ3JhbUlkLFxuICAgICAgZGF0YVxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEdlbmVyYXRlIGEgdHJhbnNhY3Rpb24gaW5zdHJ1Y3Rpb24gdGhhdCBhc3NpZ25zIGFuIGFjY291bnQgdG8gYSBwcm9ncmFtXG4gICAqL1xuICBzdGF0aWMgYXNzaWduKHBhcmFtcykge1xuICAgIGxldCBkYXRhO1xuICAgIGxldCBrZXlzO1xuICAgIGlmICgnYmFzZVB1YmtleScgaW4gcGFyYW1zKSB7XG4gICAgICBjb25zdCB0eXBlID0gU1lTVEVNX0lOU1RSVUNUSU9OX0xBWU9VVFMuQXNzaWduV2l0aFNlZWQ7XG4gICAgICBkYXRhID0gZW5jb2RlRGF0YSh0eXBlLCB7XG4gICAgICAgIGJhc2U6IHRvQnVmZmVyKHBhcmFtcy5iYXNlUHVia2V5LnRvQnVmZmVyKCkpLFxuICAgICAgICBzZWVkOiBwYXJhbXMuc2VlZCxcbiAgICAgICAgcHJvZ3JhbUlkOiB0b0J1ZmZlcihwYXJhbXMucHJvZ3JhbUlkLnRvQnVmZmVyKCkpXG4gICAgICB9KTtcbiAgICAgIGtleXMgPSBbe1xuICAgICAgICBwdWJrZXk6IHBhcmFtcy5hY2NvdW50UHVia2V5LFxuICAgICAgICBpc1NpZ25lcjogZmFsc2UsXG4gICAgICAgIGlzV3JpdGFibGU6IHRydWVcbiAgICAgIH0sIHtcbiAgICAgICAgcHVia2V5OiBwYXJhbXMuYmFzZVB1YmtleSxcbiAgICAgICAgaXNTaWduZXI6IHRydWUsXG4gICAgICAgIGlzV3JpdGFibGU6IGZhbHNlXG4gICAgICB9XTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgdHlwZSA9IFNZU1RFTV9JTlNUUlVDVElPTl9MQVlPVVRTLkFzc2lnbjtcbiAgICAgIGRhdGEgPSBlbmNvZGVEYXRhKHR5cGUsIHtcbiAgICAgICAgcHJvZ3JhbUlkOiB0b0J1ZmZlcihwYXJhbXMucHJvZ3JhbUlkLnRvQnVmZmVyKCkpXG4gICAgICB9KTtcbiAgICAgIGtleXMgPSBbe1xuICAgICAgICBwdWJrZXk6IHBhcmFtcy5hY2NvdW50UHVia2V5LFxuICAgICAgICBpc1NpZ25lcjogdHJ1ZSxcbiAgICAgICAgaXNXcml0YWJsZTogdHJ1ZVxuICAgICAgfV07XG4gICAgfVxuICAgIHJldHVybiBuZXcgVHJhbnNhY3Rpb25JbnN0cnVjdGlvbih7XG4gICAgICBrZXlzLFxuICAgICAgcHJvZ3JhbUlkOiB0aGlzLnByb2dyYW1JZCxcbiAgICAgIGRhdGFcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZW5lcmF0ZSBhIHRyYW5zYWN0aW9uIGluc3RydWN0aW9uIHRoYXQgY3JlYXRlcyBhIG5ldyBhY2NvdW50IGF0XG4gICAqICAgYW4gYWRkcmVzcyBnZW5lcmF0ZWQgd2l0aCBgZnJvbWAsIGEgc2VlZCwgYW5kIHByb2dyYW1JZFxuICAgKi9cbiAgc3RhdGljIGNyZWF0ZUFjY291bnRXaXRoU2VlZChwYXJhbXMpIHtcbiAgICBjb25zdCB0eXBlID0gU1lTVEVNX0lOU1RSVUNUSU9OX0xBWU9VVFMuQ3JlYXRlV2l0aFNlZWQ7XG4gICAgY29uc3QgZGF0YSA9IGVuY29kZURhdGEodHlwZSwge1xuICAgICAgYmFzZTogdG9CdWZmZXIocGFyYW1zLmJhc2VQdWJrZXkudG9CdWZmZXIoKSksXG4gICAgICBzZWVkOiBwYXJhbXMuc2VlZCxcbiAgICAgIGxhbXBvcnRzOiBwYXJhbXMubGFtcG9ydHMsXG4gICAgICBzcGFjZTogcGFyYW1zLnNwYWNlLFxuICAgICAgcHJvZ3JhbUlkOiB0b0J1ZmZlcihwYXJhbXMucHJvZ3JhbUlkLnRvQnVmZmVyKCkpXG4gICAgfSk7XG4gICAgbGV0IGtleXMgPSBbe1xuICAgICAgcHVia2V5OiBwYXJhbXMuZnJvbVB1YmtleSxcbiAgICAgIGlzU2lnbmVyOiB0cnVlLFxuICAgICAgaXNXcml0YWJsZTogdHJ1ZVxuICAgIH0sIHtcbiAgICAgIHB1YmtleTogcGFyYW1zLm5ld0FjY291bnRQdWJrZXksXG4gICAgICBpc1NpZ25lcjogZmFsc2UsXG4gICAgICBpc1dyaXRhYmxlOiB0cnVlXG4gICAgfV07XG4gICAgaWYgKHBhcmFtcy5iYXNlUHVia2V5ICE9IHBhcmFtcy5mcm9tUHVia2V5KSB7XG4gICAgICBrZXlzLnB1c2goe1xuICAgICAgICBwdWJrZXk6IHBhcmFtcy5iYXNlUHVia2V5LFxuICAgICAgICBpc1NpZ25lcjogdHJ1ZSxcbiAgICAgICAgaXNXcml0YWJsZTogZmFsc2VcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IFRyYW5zYWN0aW9uSW5zdHJ1Y3Rpb24oe1xuICAgICAga2V5cyxcbiAgICAgIHByb2dyYW1JZDogdGhpcy5wcm9ncmFtSWQsXG4gICAgICBkYXRhXG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogR2VuZXJhdGUgYSB0cmFuc2FjdGlvbiB0aGF0IGNyZWF0ZXMgYSBuZXcgTm9uY2UgYWNjb3VudFxuICAgKi9cbiAgc3RhdGljIGNyZWF0ZU5vbmNlQWNjb3VudChwYXJhbXMpIHtcbiAgICBjb25zdCB0cmFuc2FjdGlvbiA9IG5ldyBUcmFuc2FjdGlvbigpO1xuICAgIGlmICgnYmFzZVB1YmtleScgaW4gcGFyYW1zICYmICdzZWVkJyBpbiBwYXJhbXMpIHtcbiAgICAgIHRyYW5zYWN0aW9uLmFkZChTeXN0ZW1Qcm9ncmFtLmNyZWF0ZUFjY291bnRXaXRoU2VlZCh7XG4gICAgICAgIGZyb21QdWJrZXk6IHBhcmFtcy5mcm9tUHVia2V5LFxuICAgICAgICBuZXdBY2NvdW50UHVia2V5OiBwYXJhbXMubm9uY2VQdWJrZXksXG4gICAgICAgIGJhc2VQdWJrZXk6IHBhcmFtcy5iYXNlUHVia2V5LFxuICAgICAgICBzZWVkOiBwYXJhbXMuc2VlZCxcbiAgICAgICAgbGFtcG9ydHM6IHBhcmFtcy5sYW1wb3J0cyxcbiAgICAgICAgc3BhY2U6IE5PTkNFX0FDQ09VTlRfTEVOR1RILFxuICAgICAgICBwcm9ncmFtSWQ6IHRoaXMucHJvZ3JhbUlkXG4gICAgICB9KSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRyYW5zYWN0aW9uLmFkZChTeXN0ZW1Qcm9ncmFtLmNyZWF0ZUFjY291bnQoe1xuICAgICAgICBmcm9tUHVia2V5OiBwYXJhbXMuZnJvbVB1YmtleSxcbiAgICAgICAgbmV3QWNjb3VudFB1YmtleTogcGFyYW1zLm5vbmNlUHVia2V5LFxuICAgICAgICBsYW1wb3J0czogcGFyYW1zLmxhbXBvcnRzLFxuICAgICAgICBzcGFjZTogTk9OQ0VfQUNDT1VOVF9MRU5HVEgsXG4gICAgICAgIHByb2dyYW1JZDogdGhpcy5wcm9ncmFtSWRcbiAgICAgIH0pKTtcbiAgICB9XG4gICAgY29uc3QgaW5pdFBhcmFtcyA9IHtcbiAgICAgIG5vbmNlUHVia2V5OiBwYXJhbXMubm9uY2VQdWJrZXksXG4gICAgICBhdXRob3JpemVkUHVia2V5OiBwYXJhbXMuYXV0aG9yaXplZFB1YmtleVxuICAgIH07XG4gICAgdHJhbnNhY3Rpb24uYWRkKHRoaXMubm9uY2VJbml0aWFsaXplKGluaXRQYXJhbXMpKTtcbiAgICByZXR1cm4gdHJhbnNhY3Rpb247XG4gIH1cblxuICAvKipcbiAgICogR2VuZXJhdGUgYW4gaW5zdHJ1Y3Rpb24gdG8gaW5pdGlhbGl6ZSBhIE5vbmNlIGFjY291bnRcbiAgICovXG4gIHN0YXRpYyBub25jZUluaXRpYWxpemUocGFyYW1zKSB7XG4gICAgY29uc3QgdHlwZSA9IFNZU1RFTV9JTlNUUlVDVElPTl9MQVlPVVRTLkluaXRpYWxpemVOb25jZUFjY291bnQ7XG4gICAgY29uc3QgZGF0YSA9IGVuY29kZURhdGEodHlwZSwge1xuICAgICAgYXV0aG9yaXplZDogdG9CdWZmZXIocGFyYW1zLmF1dGhvcml6ZWRQdWJrZXkudG9CdWZmZXIoKSlcbiAgICB9KTtcbiAgICBjb25zdCBpbnN0cnVjdGlvbkRhdGEgPSB7XG4gICAgICBrZXlzOiBbe1xuICAgICAgICBwdWJrZXk6IHBhcmFtcy5ub25jZVB1YmtleSxcbiAgICAgICAgaXNTaWduZXI6IGZhbHNlLFxuICAgICAgICBpc1dyaXRhYmxlOiB0cnVlXG4gICAgICB9LCB7XG4gICAgICAgIHB1YmtleTogU1lTVkFSX1JFQ0VOVF9CTE9DS0hBU0hFU19QVUJLRVksXG4gICAgICAgIGlzU2lnbmVyOiBmYWxzZSxcbiAgICAgICAgaXNXcml0YWJsZTogZmFsc2VcbiAgICAgIH0sIHtcbiAgICAgICAgcHVia2V5OiBTWVNWQVJfUkVOVF9QVUJLRVksXG4gICAgICAgIGlzU2lnbmVyOiBmYWxzZSxcbiAgICAgICAgaXNXcml0YWJsZTogZmFsc2VcbiAgICAgIH1dLFxuICAgICAgcHJvZ3JhbUlkOiB0aGlzLnByb2dyYW1JZCxcbiAgICAgIGRhdGFcbiAgICB9O1xuICAgIHJldHVybiBuZXcgVHJhbnNhY3Rpb25JbnN0cnVjdGlvbihpbnN0cnVjdGlvbkRhdGEpO1xuICB9XG5cbiAgLyoqXG4gICAqIEdlbmVyYXRlIGFuIGluc3RydWN0aW9uIHRvIGFkdmFuY2UgdGhlIG5vbmNlIGluIGEgTm9uY2UgYWNjb3VudFxuICAgKi9cbiAgc3RhdGljIG5vbmNlQWR2YW5jZShwYXJhbXMpIHtcbiAgICBjb25zdCB0eXBlID0gU1lTVEVNX0lOU1RSVUNUSU9OX0xBWU9VVFMuQWR2YW5jZU5vbmNlQWNjb3VudDtcbiAgICBjb25zdCBkYXRhID0gZW5jb2RlRGF0YSh0eXBlKTtcbiAgICBjb25zdCBpbnN0cnVjdGlvbkRhdGEgPSB7XG4gICAgICBrZXlzOiBbe1xuICAgICAgICBwdWJrZXk6IHBhcmFtcy5ub25jZVB1YmtleSxcbiAgICAgICAgaXNTaWduZXI6IGZhbHNlLFxuICAgICAgICBpc1dyaXRhYmxlOiB0cnVlXG4gICAgICB9LCB7XG4gICAgICAgIHB1YmtleTogU1lTVkFSX1JFQ0VOVF9CTE9DS0hBU0hFU19QVUJLRVksXG4gICAgICAgIGlzU2lnbmVyOiBmYWxzZSxcbiAgICAgICAgaXNXcml0YWJsZTogZmFsc2VcbiAgICAgIH0sIHtcbiAgICAgICAgcHVia2V5OiBwYXJhbXMuYXV0aG9yaXplZFB1YmtleSxcbiAgICAgICAgaXNTaWduZXI6IHRydWUsXG4gICAgICAgIGlzV3JpdGFibGU6IGZhbHNlXG4gICAgICB9XSxcbiAgICAgIHByb2dyYW1JZDogdGhpcy5wcm9ncmFtSWQsXG4gICAgICBkYXRhXG4gICAgfTtcbiAgICByZXR1cm4gbmV3IFRyYW5zYWN0aW9uSW5zdHJ1Y3Rpb24oaW5zdHJ1Y3Rpb25EYXRhKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZW5lcmF0ZSBhIHRyYW5zYWN0aW9uIGluc3RydWN0aW9uIHRoYXQgd2l0aGRyYXdzIGxhbXBvcnRzIGZyb20gYSBOb25jZSBhY2NvdW50XG4gICAqL1xuICBzdGF0aWMgbm9uY2VXaXRoZHJhdyhwYXJhbXMpIHtcbiAgICBjb25zdCB0eXBlID0gU1lTVEVNX0lOU1RSVUNUSU9OX0xBWU9VVFMuV2l0aGRyYXdOb25jZUFjY291bnQ7XG4gICAgY29uc3QgZGF0YSA9IGVuY29kZURhdGEodHlwZSwge1xuICAgICAgbGFtcG9ydHM6IHBhcmFtcy5sYW1wb3J0c1xuICAgIH0pO1xuICAgIHJldHVybiBuZXcgVHJhbnNhY3Rpb25JbnN0cnVjdGlvbih7XG4gICAgICBrZXlzOiBbe1xuICAgICAgICBwdWJrZXk6IHBhcmFtcy5ub25jZVB1YmtleSxcbiAgICAgICAgaXNTaWduZXI6IGZhbHNlLFxuICAgICAgICBpc1dyaXRhYmxlOiB0cnVlXG4gICAgICB9LCB7XG4gICAgICAgIHB1YmtleTogcGFyYW1zLnRvUHVia2V5LFxuICAgICAgICBpc1NpZ25lcjogZmFsc2UsXG4gICAgICAgIGlzV3JpdGFibGU6IHRydWVcbiAgICAgIH0sIHtcbiAgICAgICAgcHVia2V5OiBTWVNWQVJfUkVDRU5UX0JMT0NLSEFTSEVTX1BVQktFWSxcbiAgICAgICAgaXNTaWduZXI6IGZhbHNlLFxuICAgICAgICBpc1dyaXRhYmxlOiBmYWxzZVxuICAgICAgfSwge1xuICAgICAgICBwdWJrZXk6IFNZU1ZBUl9SRU5UX1BVQktFWSxcbiAgICAgICAgaXNTaWduZXI6IGZhbHNlLFxuICAgICAgICBpc1dyaXRhYmxlOiBmYWxzZVxuICAgICAgfSwge1xuICAgICAgICBwdWJrZXk6IHBhcmFtcy5hdXRob3JpemVkUHVia2V5LFxuICAgICAgICBpc1NpZ25lcjogdHJ1ZSxcbiAgICAgICAgaXNXcml0YWJsZTogZmFsc2VcbiAgICAgIH1dLFxuICAgICAgcHJvZ3JhbUlkOiB0aGlzLnByb2dyYW1JZCxcbiAgICAgIGRhdGFcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZW5lcmF0ZSBhIHRyYW5zYWN0aW9uIGluc3RydWN0aW9uIHRoYXQgYXV0aG9yaXplcyBhIG5ldyBQdWJsaWNLZXkgYXMgdGhlIGF1dGhvcml0eVxuICAgKiBvbiBhIE5vbmNlIGFjY291bnQuXG4gICAqL1xuICBzdGF0aWMgbm9uY2VBdXRob3JpemUocGFyYW1zKSB7XG4gICAgY29uc3QgdHlwZSA9IFNZU1RFTV9JTlNUUlVDVElPTl9MQVlPVVRTLkF1dGhvcml6ZU5vbmNlQWNjb3VudDtcbiAgICBjb25zdCBkYXRhID0gZW5jb2RlRGF0YSh0eXBlLCB7XG4gICAgICBhdXRob3JpemVkOiB0b0J1ZmZlcihwYXJhbXMubmV3QXV0aG9yaXplZFB1YmtleS50b0J1ZmZlcigpKVxuICAgIH0pO1xuICAgIHJldHVybiBuZXcgVHJhbnNhY3Rpb25JbnN0cnVjdGlvbih7XG4gICAgICBrZXlzOiBbe1xuICAgICAgICBwdWJrZXk6IHBhcmFtcy5ub25jZVB1YmtleSxcbiAgICAgICAgaXNTaWduZXI6IGZhbHNlLFxuICAgICAgICBpc1dyaXRhYmxlOiB0cnVlXG4gICAgICB9LCB7XG4gICAgICAgIHB1YmtleTogcGFyYW1zLmF1dGhvcml6ZWRQdWJrZXksXG4gICAgICAgIGlzU2lnbmVyOiB0cnVlLFxuICAgICAgICBpc1dyaXRhYmxlOiBmYWxzZVxuICAgICAgfV0sXG4gICAgICBwcm9ncmFtSWQ6IHRoaXMucHJvZ3JhbUlkLFxuICAgICAgZGF0YVxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEdlbmVyYXRlIGEgdHJhbnNhY3Rpb24gaW5zdHJ1Y3Rpb24gdGhhdCBhbGxvY2F0ZXMgc3BhY2UgaW4gYW4gYWNjb3VudCB3aXRob3V0IGZ1bmRpbmdcbiAgICovXG4gIHN0YXRpYyBhbGxvY2F0ZShwYXJhbXMpIHtcbiAgICBsZXQgZGF0YTtcbiAgICBsZXQga2V5cztcbiAgICBpZiAoJ2Jhc2VQdWJrZXknIGluIHBhcmFtcykge1xuICAgICAgY29uc3QgdHlwZSA9IFNZU1RFTV9JTlNUUlVDVElPTl9MQVlPVVRTLkFsbG9jYXRlV2l0aFNlZWQ7XG4gICAgICBkYXRhID0gZW5jb2RlRGF0YSh0eXBlLCB7XG4gICAgICAgIGJhc2U6IHRvQnVmZmVyKHBhcmFtcy5iYXNlUHVia2V5LnRvQnVmZmVyKCkpLFxuICAgICAgICBzZWVkOiBwYXJhbXMuc2VlZCxcbiAgICAgICAgc3BhY2U6IHBhcmFtcy5zcGFjZSxcbiAgICAgICAgcHJvZ3JhbUlkOiB0b0J1ZmZlcihwYXJhbXMucHJvZ3JhbUlkLnRvQnVmZmVyKCkpXG4gICAgICB9KTtcbiAgICAgIGtleXMgPSBbe1xuICAgICAgICBwdWJrZXk6IHBhcmFtcy5hY2NvdW50UHVia2V5LFxuICAgICAgICBpc1NpZ25lcjogZmFsc2UsXG4gICAgICAgIGlzV3JpdGFibGU6IHRydWVcbiAgICAgIH0sIHtcbiAgICAgICAgcHVia2V5OiBwYXJhbXMuYmFzZVB1YmtleSxcbiAgICAgICAgaXNTaWduZXI6IHRydWUsXG4gICAgICAgIGlzV3JpdGFibGU6IGZhbHNlXG4gICAgICB9XTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgdHlwZSA9IFNZU1RFTV9JTlNUUlVDVElPTl9MQVlPVVRTLkFsbG9jYXRlO1xuICAgICAgZGF0YSA9IGVuY29kZURhdGEodHlwZSwge1xuICAgICAgICBzcGFjZTogcGFyYW1zLnNwYWNlXG4gICAgICB9KTtcbiAgICAgIGtleXMgPSBbe1xuICAgICAgICBwdWJrZXk6IHBhcmFtcy5hY2NvdW50UHVia2V5LFxuICAgICAgICBpc1NpZ25lcjogdHJ1ZSxcbiAgICAgICAgaXNXcml0YWJsZTogdHJ1ZVxuICAgICAgfV07XG4gICAgfVxuICAgIHJldHVybiBuZXcgVHJhbnNhY3Rpb25JbnN0cnVjdGlvbih7XG4gICAgICBrZXlzLFxuICAgICAgcHJvZ3JhbUlkOiB0aGlzLnByb2dyYW1JZCxcbiAgICAgIGRhdGFcbiAgICB9KTtcbiAgfVxufVxuU3lzdGVtUHJvZ3JhbS5wcm9ncmFtSWQgPSBuZXcgUHVibGljS2V5KCcxMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMScpO1xuXG4vLyBLZWVwIHByb2dyYW0gY2h1bmtzIHVuZGVyIFBBQ0tFVF9EQVRBX1NJWkUsIGxlYXZpbmcgZW5vdWdoIHJvb20gZm9yIHRoZVxuLy8gcmVzdCBvZiB0aGUgVHJhbnNhY3Rpb24gZmllbGRzXG4vL1xuLy8gVE9ETzogcmVwbGFjZSAzMDAgd2l0aCBhIHByb3BlciBjb25zdGFudCBmb3IgdGhlIHNpemUgb2YgdGhlIG90aGVyXG4vLyBUcmFuc2FjdGlvbiBmaWVsZHNcbmNvbnN0IENIVU5LX1NJWkUgPSBQQUNLRVRfREFUQV9TSVpFIC0gMzAwO1xuXG4vKipcbiAqIFByb2dyYW0gbG9hZGVyIGludGVyZmFjZVxuICovXG5jbGFzcyBMb2FkZXIge1xuICAvKipcbiAgICogQGludGVybmFsXG4gICAqL1xuICBjb25zdHJ1Y3RvcigpIHt9XG5cbiAgLyoqXG4gICAqIEFtb3VudCBvZiBwcm9ncmFtIGRhdGEgcGxhY2VkIGluIGVhY2ggbG9hZCBUcmFuc2FjdGlvblxuICAgKi9cblxuICAvKipcbiAgICogTWluaW11bSBudW1iZXIgb2Ygc2lnbmF0dXJlcyByZXF1aXJlZCB0byBsb2FkIGEgcHJvZ3JhbSBub3QgaW5jbHVkaW5nXG4gICAqIHJldHJpZXNcbiAgICpcbiAgICogQ2FuIGJlIHVzZWQgdG8gY2FsY3VsYXRlIHRyYW5zYWN0aW9uIGZlZXNcbiAgICovXG4gIHN0YXRpYyBnZXRNaW5OdW1TaWduYXR1cmVzKGRhdGFMZW5ndGgpIHtcbiAgICByZXR1cm4gMiAqIChcbiAgICAvLyBFdmVyeSB0cmFuc2FjdGlvbiByZXF1aXJlcyB0d28gc2lnbmF0dXJlcyAocGF5ZXIgKyBwcm9ncmFtKVxuICAgIE1hdGguY2VpbChkYXRhTGVuZ3RoIC8gTG9hZGVyLmNodW5rU2l6ZSkgKyAxICtcbiAgICAvLyBBZGQgb25lIGZvciBDcmVhdGUgdHJhbnNhY3Rpb25cbiAgICAxKSAvLyBBZGQgb25lIGZvciBGaW5hbGl6ZSB0cmFuc2FjdGlvblxuICAgIDtcbiAgfVxuXG4gIC8qKlxuICAgKiBMb2FkcyBhIGdlbmVyaWMgcHJvZ3JhbVxuICAgKlxuICAgKiBAcGFyYW0gY29ubmVjdGlvbiBUaGUgY29ubmVjdGlvbiB0byB1c2VcbiAgICogQHBhcmFtIHBheWVyIFN5c3RlbSBhY2NvdW50IHRoYXQgcGF5cyB0byBsb2FkIHRoZSBwcm9ncmFtXG4gICAqIEBwYXJhbSBwcm9ncmFtIEFjY291bnQgdG8gbG9hZCB0aGUgcHJvZ3JhbSBpbnRvXG4gICAqIEBwYXJhbSBwcm9ncmFtSWQgUHVibGljIGtleSB0aGF0IGlkZW50aWZpZXMgdGhlIGxvYWRlclxuICAgKiBAcGFyYW0gZGF0YSBQcm9ncmFtIG9jdGV0c1xuICAgKiBAcmV0dXJuIHRydWUgaWYgcHJvZ3JhbSB3YXMgbG9hZGVkIHN1Y2Nlc3NmdWxseSwgZmFsc2UgaWYgcHJvZ3JhbSB3YXMgYWxyZWFkeSBsb2FkZWRcbiAgICovXG4gIHN0YXRpYyBhc3luYyBsb2FkKGNvbm5lY3Rpb24sIHBheWVyLCBwcm9ncmFtLCBwcm9ncmFtSWQsIGRhdGEpIHtcbiAgICB7XG4gICAgICBjb25zdCBiYWxhbmNlTmVlZGVkID0gYXdhaXQgY29ubmVjdGlvbi5nZXRNaW5pbXVtQmFsYW5jZUZvclJlbnRFeGVtcHRpb24oZGF0YS5sZW5ndGgpO1xuXG4gICAgICAvLyBGZXRjaCBwcm9ncmFtIGFjY291bnQgaW5mbyB0byBjaGVjayBpZiBpdCBoYXMgYWxyZWFkeSBiZWVuIGNyZWF0ZWRcbiAgICAgIGNvbnN0IHByb2dyYW1JbmZvID0gYXdhaXQgY29ubmVjdGlvbi5nZXRBY2NvdW50SW5mbyhwcm9ncmFtLnB1YmxpY0tleSwgJ2NvbmZpcm1lZCcpO1xuICAgICAgbGV0IHRyYW5zYWN0aW9uID0gbnVsbDtcbiAgICAgIGlmIChwcm9ncmFtSW5mbyAhPT0gbnVsbCkge1xuICAgICAgICBpZiAocHJvZ3JhbUluZm8uZXhlY3V0YWJsZSkge1xuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ1Byb2dyYW0gbG9hZCBmYWlsZWQsIGFjY291bnQgaXMgYWxyZWFkeSBleGVjdXRhYmxlJyk7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwcm9ncmFtSW5mby5kYXRhLmxlbmd0aCAhPT0gZGF0YS5sZW5ndGgpIHtcbiAgICAgICAgICB0cmFuc2FjdGlvbiA9IHRyYW5zYWN0aW9uIHx8IG5ldyBUcmFuc2FjdGlvbigpO1xuICAgICAgICAgIHRyYW5zYWN0aW9uLmFkZChTeXN0ZW1Qcm9ncmFtLmFsbG9jYXRlKHtcbiAgICAgICAgICAgIGFjY291bnRQdWJrZXk6IHByb2dyYW0ucHVibGljS2V5LFxuICAgICAgICAgICAgc3BhY2U6IGRhdGEubGVuZ3RoXG4gICAgICAgICAgfSkpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghcHJvZ3JhbUluZm8ub3duZXIuZXF1YWxzKHByb2dyYW1JZCkpIHtcbiAgICAgICAgICB0cmFuc2FjdGlvbiA9IHRyYW5zYWN0aW9uIHx8IG5ldyBUcmFuc2FjdGlvbigpO1xuICAgICAgICAgIHRyYW5zYWN0aW9uLmFkZChTeXN0ZW1Qcm9ncmFtLmFzc2lnbih7XG4gICAgICAgICAgICBhY2NvdW50UHVia2V5OiBwcm9ncmFtLnB1YmxpY0tleSxcbiAgICAgICAgICAgIHByb2dyYW1JZFxuICAgICAgICAgIH0pKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocHJvZ3JhbUluZm8ubGFtcG9ydHMgPCBiYWxhbmNlTmVlZGVkKSB7XG4gICAgICAgICAgdHJhbnNhY3Rpb24gPSB0cmFuc2FjdGlvbiB8fCBuZXcgVHJhbnNhY3Rpb24oKTtcbiAgICAgICAgICB0cmFuc2FjdGlvbi5hZGQoU3lzdGVtUHJvZ3JhbS50cmFuc2Zlcih7XG4gICAgICAgICAgICBmcm9tUHVia2V5OiBwYXllci5wdWJsaWNLZXksXG4gICAgICAgICAgICB0b1B1YmtleTogcHJvZ3JhbS5wdWJsaWNLZXksXG4gICAgICAgICAgICBsYW1wb3J0czogYmFsYW5jZU5lZWRlZCAtIHByb2dyYW1JbmZvLmxhbXBvcnRzXG4gICAgICAgICAgfSkpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0cmFuc2FjdGlvbiA9IG5ldyBUcmFuc2FjdGlvbigpLmFkZChTeXN0ZW1Qcm9ncmFtLmNyZWF0ZUFjY291bnQoe1xuICAgICAgICAgIGZyb21QdWJrZXk6IHBheWVyLnB1YmxpY0tleSxcbiAgICAgICAgICBuZXdBY2NvdW50UHVia2V5OiBwcm9ncmFtLnB1YmxpY0tleSxcbiAgICAgICAgICBsYW1wb3J0czogYmFsYW5jZU5lZWRlZCA+IDAgPyBiYWxhbmNlTmVlZGVkIDogMSxcbiAgICAgICAgICBzcGFjZTogZGF0YS5sZW5ndGgsXG4gICAgICAgICAgcHJvZ3JhbUlkXG4gICAgICAgIH0pKTtcbiAgICAgIH1cblxuICAgICAgLy8gSWYgdGhlIGFjY291bnQgaXMgYWxyZWFkeSBjcmVhdGVkIGNvcnJlY3RseSwgc2tpcCB0aGlzIHN0ZXBcbiAgICAgIC8vIGFuZCBwcm9jZWVkIGRpcmVjdGx5IHRvIGxvYWRpbmcgaW5zdHJ1Y3Rpb25zXG4gICAgICBpZiAodHJhbnNhY3Rpb24gIT09IG51bGwpIHtcbiAgICAgICAgYXdhaXQgc2VuZEFuZENvbmZpcm1UcmFuc2FjdGlvbihjb25uZWN0aW9uLCB0cmFuc2FjdGlvbiwgW3BheWVyLCBwcm9ncmFtXSwge1xuICAgICAgICAgIGNvbW1pdG1lbnQ6ICdjb25maXJtZWQnXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBkYXRhTGF5b3V0ID0gQnVmZmVyTGF5b3V0LnN0cnVjdChbQnVmZmVyTGF5b3V0LnUzMignaW5zdHJ1Y3Rpb24nKSwgQnVmZmVyTGF5b3V0LnUzMignb2Zmc2V0JyksIEJ1ZmZlckxheW91dC51MzIoJ2J5dGVzTGVuZ3RoJyksIEJ1ZmZlckxheW91dC51MzIoJ2J5dGVzTGVuZ3RoUGFkZGluZycpLCBCdWZmZXJMYXlvdXQuc2VxKEJ1ZmZlckxheW91dC51OCgnYnl0ZScpLCBCdWZmZXJMYXlvdXQub2Zmc2V0KEJ1ZmZlckxheW91dC51MzIoKSwgLTgpLCAnYnl0ZXMnKV0pO1xuICAgIGNvbnN0IGNodW5rU2l6ZSA9IExvYWRlci5jaHVua1NpemU7XG4gICAgbGV0IG9mZnNldCA9IDA7XG4gICAgbGV0IGFycmF5ID0gZGF0YTtcbiAgICBsZXQgdHJhbnNhY3Rpb25zID0gW107XG4gICAgd2hpbGUgKGFycmF5Lmxlbmd0aCA+IDApIHtcbiAgICAgIGNvbnN0IGJ5dGVzID0gYXJyYXkuc2xpY2UoMCwgY2h1bmtTaXplKTtcbiAgICAgIGNvbnN0IGRhdGEgPSBCdWZmZXIuYWxsb2MoY2h1bmtTaXplICsgMTYpO1xuICAgICAgZGF0YUxheW91dC5lbmNvZGUoe1xuICAgICAgICBpbnN0cnVjdGlvbjogMCxcbiAgICAgICAgLy8gTG9hZCBpbnN0cnVjdGlvblxuICAgICAgICBvZmZzZXQsXG4gICAgICAgIGJ5dGVzOiBieXRlcyxcbiAgICAgICAgYnl0ZXNMZW5ndGg6IDAsXG4gICAgICAgIGJ5dGVzTGVuZ3RoUGFkZGluZzogMFxuICAgICAgfSwgZGF0YSk7XG4gICAgICBjb25zdCB0cmFuc2FjdGlvbiA9IG5ldyBUcmFuc2FjdGlvbigpLmFkZCh7XG4gICAgICAgIGtleXM6IFt7XG4gICAgICAgICAgcHVia2V5OiBwcm9ncmFtLnB1YmxpY0tleSxcbiAgICAgICAgICBpc1NpZ25lcjogdHJ1ZSxcbiAgICAgICAgICBpc1dyaXRhYmxlOiB0cnVlXG4gICAgICAgIH1dLFxuICAgICAgICBwcm9ncmFtSWQsXG4gICAgICAgIGRhdGFcbiAgICAgIH0pO1xuICAgICAgdHJhbnNhY3Rpb25zLnB1c2goc2VuZEFuZENvbmZpcm1UcmFuc2FjdGlvbihjb25uZWN0aW9uLCB0cmFuc2FjdGlvbiwgW3BheWVyLCBwcm9ncmFtXSwge1xuICAgICAgICBjb21taXRtZW50OiAnY29uZmlybWVkJ1xuICAgICAgfSkpO1xuXG4gICAgICAvLyBEZWxheSBiZXR3ZWVuIHNlbmRzIGluIGFuIGF0dGVtcHQgdG8gcmVkdWNlIHJhdGUgbGltaXQgZXJyb3JzXG4gICAgICBpZiAoY29ubmVjdGlvbi5fcnBjRW5kcG9pbnQuaW5jbHVkZXMoJ3NvbGFuYS5jb20nKSkge1xuICAgICAgICBjb25zdCBSRVFVRVNUU19QRVJfU0VDT05EID0gNDtcbiAgICAgICAgYXdhaXQgc2xlZXAoMTAwMCAvIFJFUVVFU1RTX1BFUl9TRUNPTkQpO1xuICAgICAgfVxuICAgICAgb2Zmc2V0ICs9IGNodW5rU2l6ZTtcbiAgICAgIGFycmF5ID0gYXJyYXkuc2xpY2UoY2h1bmtTaXplKTtcbiAgICB9XG4gICAgYXdhaXQgUHJvbWlzZS5hbGwodHJhbnNhY3Rpb25zKTtcblxuICAgIC8vIEZpbmFsaXplIHRoZSBhY2NvdW50IGxvYWRlZCB3aXRoIHByb2dyYW0gZGF0YSBmb3IgZXhlY3V0aW9uXG4gICAge1xuICAgICAgY29uc3QgZGF0YUxheW91dCA9IEJ1ZmZlckxheW91dC5zdHJ1Y3QoW0J1ZmZlckxheW91dC51MzIoJ2luc3RydWN0aW9uJyldKTtcbiAgICAgIGNvbnN0IGRhdGEgPSBCdWZmZXIuYWxsb2MoZGF0YUxheW91dC5zcGFuKTtcbiAgICAgIGRhdGFMYXlvdXQuZW5jb2RlKHtcbiAgICAgICAgaW5zdHJ1Y3Rpb246IDEgLy8gRmluYWxpemUgaW5zdHJ1Y3Rpb25cbiAgICAgIH0sIGRhdGEpO1xuICAgICAgY29uc3QgdHJhbnNhY3Rpb24gPSBuZXcgVHJhbnNhY3Rpb24oKS5hZGQoe1xuICAgICAgICBrZXlzOiBbe1xuICAgICAgICAgIHB1YmtleTogcHJvZ3JhbS5wdWJsaWNLZXksXG4gICAgICAgICAgaXNTaWduZXI6IHRydWUsXG4gICAgICAgICAgaXNXcml0YWJsZTogdHJ1ZVxuICAgICAgICB9LCB7XG4gICAgICAgICAgcHVia2V5OiBTWVNWQVJfUkVOVF9QVUJLRVksXG4gICAgICAgICAgaXNTaWduZXI6IGZhbHNlLFxuICAgICAgICAgIGlzV3JpdGFibGU6IGZhbHNlXG4gICAgICAgIH1dLFxuICAgICAgICBwcm9ncmFtSWQsXG4gICAgICAgIGRhdGFcbiAgICAgIH0pO1xuICAgICAgY29uc3QgZGVwbG95Q29tbWl0bWVudCA9ICdwcm9jZXNzZWQnO1xuICAgICAgY29uc3QgZmluYWxpemVTaWduYXR1cmUgPSBhd2FpdCBjb25uZWN0aW9uLnNlbmRUcmFuc2FjdGlvbih0cmFuc2FjdGlvbiwgW3BheWVyLCBwcm9ncmFtXSwge1xuICAgICAgICBwcmVmbGlnaHRDb21taXRtZW50OiBkZXBsb3lDb21taXRtZW50XG4gICAgICB9KTtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgY29udGV4dCxcbiAgICAgICAgdmFsdWVcbiAgICAgIH0gPSBhd2FpdCBjb25uZWN0aW9uLmNvbmZpcm1UcmFuc2FjdGlvbih7XG4gICAgICAgIHNpZ25hdHVyZTogZmluYWxpemVTaWduYXR1cmUsXG4gICAgICAgIGxhc3RWYWxpZEJsb2NrSGVpZ2h0OiB0cmFuc2FjdGlvbi5sYXN0VmFsaWRCbG9ja0hlaWdodCxcbiAgICAgICAgYmxvY2toYXNoOiB0cmFuc2FjdGlvbi5yZWNlbnRCbG9ja2hhc2hcbiAgICAgIH0sIGRlcGxveUNvbW1pdG1lbnQpO1xuICAgICAgaWYgKHZhbHVlLmVycikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFRyYW5zYWN0aW9uICR7ZmluYWxpemVTaWduYXR1cmV9IGZhaWxlZCAoJHtKU09OLnN0cmluZ2lmeSh2YWx1ZSl9KWApO1xuICAgICAgfVxuICAgICAgLy8gV2UgcHJldmVudCBwcm9ncmFtcyBmcm9tIGJlaW5nIHVzYWJsZSB1bnRpbCB0aGUgc2xvdCBhZnRlciB0aGVpciBkZXBsb3ltZW50LlxuICAgICAgLy8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9zb2xhbmEtbGFicy9zb2xhbmEvcHVsbC8yOTY1NFxuICAgICAgd2hpbGUgKHRydWUgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1jb25zdGFudC1jb25kaXRpb25cbiAgICAgICkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGNvbnN0IGN1cnJlbnRTbG90ID0gYXdhaXQgY29ubmVjdGlvbi5nZXRTbG90KHtcbiAgICAgICAgICAgIGNvbW1pdG1lbnQ6IGRlcGxveUNvbW1pdG1lbnRcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBpZiAoY3VycmVudFNsb3QgPiBjb250ZXh0LnNsb3QpIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaCB7XG4gICAgICAgICAgLyogZW1wdHkgKi9cbiAgICAgICAgfVxuICAgICAgICBhd2FpdCBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgTWF0aC5yb3VuZChNU19QRVJfU0xPVCAvIDIpKSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gc3VjY2Vzc1xuICAgIHJldHVybiB0cnVlO1xuICB9XG59XG5Mb2FkZXIuY2h1bmtTaXplID0gQ0hVTktfU0laRTtcblxuLyoqXG4gKiBAZGVwcmVjYXRlZCBEZXByZWNhdGVkIHNpbmNlIFNvbGFuYSB2MS4xNy4yMC5cbiAqL1xuY29uc3QgQlBGX0xPQURFUl9QUk9HUkFNX0lEID0gbmV3IFB1YmxpY0tleSgnQlBGTG9hZGVyMjExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMScpO1xuXG4vKipcbiAqIEZhY3RvcnkgY2xhc3MgZm9yIHRyYW5zYWN0aW9ucyB0byBpbnRlcmFjdCB3aXRoIGEgcHJvZ3JhbSBsb2FkZXJcbiAqXG4gKiBAZGVwcmVjYXRlZCBEZXByZWNhdGVkIHNpbmNlIFNvbGFuYSB2MS4xNy4yMC5cbiAqL1xuY2xhc3MgQnBmTG9hZGVyIHtcbiAgLyoqXG4gICAqIE1pbmltdW0gbnVtYmVyIG9mIHNpZ25hdHVyZXMgcmVxdWlyZWQgdG8gbG9hZCBhIHByb2dyYW0gbm90IGluY2x1ZGluZ1xuICAgKiByZXRyaWVzXG4gICAqXG4gICAqIENhbiBiZSB1c2VkIHRvIGNhbGN1bGF0ZSB0cmFuc2FjdGlvbiBmZWVzXG4gICAqL1xuICBzdGF0aWMgZ2V0TWluTnVtU2lnbmF0dXJlcyhkYXRhTGVuZ3RoKSB7XG4gICAgcmV0dXJuIExvYWRlci5nZXRNaW5OdW1TaWduYXR1cmVzKGRhdGFMZW5ndGgpO1xuICB9XG5cbiAgLyoqXG4gICAqIExvYWQgYSBTQkYgcHJvZ3JhbVxuICAgKlxuICAgKiBAcGFyYW0gY29ubmVjdGlvbiBUaGUgY29ubmVjdGlvbiB0byB1c2VcbiAgICogQHBhcmFtIHBheWVyIEFjY291bnQgdGhhdCB3aWxsIHBheSBwcm9ncmFtIGxvYWRpbmcgZmVlc1xuICAgKiBAcGFyYW0gcHJvZ3JhbSBBY2NvdW50IHRvIGxvYWQgdGhlIHByb2dyYW0gaW50b1xuICAgKiBAcGFyYW0gZWxmIFRoZSBlbnRpcmUgRUxGIGNvbnRhaW5pbmcgdGhlIFNCRiBwcm9ncmFtXG4gICAqIEBwYXJhbSBsb2FkZXJQcm9ncmFtSWQgVGhlIHByb2dyYW0gaWQgb2YgdGhlIEJQRiBsb2FkZXIgdG8gdXNlXG4gICAqIEByZXR1cm4gdHJ1ZSBpZiBwcm9ncmFtIHdhcyBsb2FkZWQgc3VjY2Vzc2Z1bGx5LCBmYWxzZSBpZiBwcm9ncmFtIHdhcyBhbHJlYWR5IGxvYWRlZFxuICAgKi9cbiAgc3RhdGljIGxvYWQoY29ubmVjdGlvbiwgcGF5ZXIsIHByb2dyYW0sIGVsZiwgbG9hZGVyUHJvZ3JhbUlkKSB7XG4gICAgcmV0dXJuIExvYWRlci5sb2FkKGNvbm5lY3Rpb24sIHBheWVyLCBwcm9ncmFtLCBsb2FkZXJQcm9ncmFtSWQsIGVsZik7XG4gIH1cbn1cblxuZnVuY3Rpb24gZ2V0RGVmYXVsdEV4cG9ydEZyb21DanMgKHgpIHtcblx0cmV0dXJuIHggJiYgeC5fX2VzTW9kdWxlICYmIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh4LCAnZGVmYXVsdCcpID8geFsnZGVmYXVsdCddIDogeDtcbn1cblxudmFyIGFnZW50a2VlcGFsaXZlID0ge2V4cG9ydHM6IHt9fTtcblxuLyoqXG4gKiBIZWxwZXJzLlxuICovXG5cbnZhciBzID0gMTAwMDtcbnZhciBtID0gcyAqIDYwO1xudmFyIGggPSBtICogNjA7XG52YXIgZCA9IGggKiAyNDtcbnZhciB3ID0gZCAqIDc7XG52YXIgeSA9IGQgKiAzNjUuMjU7XG5cbi8qKlxuICogUGFyc2Ugb3IgZm9ybWF0IHRoZSBnaXZlbiBgdmFsYC5cbiAqXG4gKiBPcHRpb25zOlxuICpcbiAqICAtIGBsb25nYCB2ZXJib3NlIGZvcm1hdHRpbmcgW2ZhbHNlXVxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfE51bWJlcn0gdmFsXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gKiBAdGhyb3dzIHtFcnJvcn0gdGhyb3cgYW4gZXJyb3IgaWYgdmFsIGlzIG5vdCBhIG5vbi1lbXB0eSBzdHJpbmcgb3IgYSBudW1iZXJcbiAqIEByZXR1cm4ge1N0cmluZ3xOdW1iZXJ9XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbnZhciBtcyQyID0gZnVuY3Rpb24gKHZhbCwgb3B0aW9ucykge1xuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgdmFyIHR5cGUgPSB0eXBlb2YgdmFsO1xuICBpZiAodHlwZSA9PT0gJ3N0cmluZycgJiYgdmFsLmxlbmd0aCA+IDApIHtcbiAgICByZXR1cm4gcGFyc2UodmFsKTtcbiAgfSBlbHNlIGlmICh0eXBlID09PSAnbnVtYmVyJyAmJiBpc0Zpbml0ZSh2YWwpKSB7XG4gICAgcmV0dXJuIG9wdGlvbnMubG9uZyA/IGZtdExvbmcodmFsKSA6IGZtdFNob3J0KHZhbCk7XG4gIH1cbiAgdGhyb3cgbmV3IEVycm9yKFxuICAgICd2YWwgaXMgbm90IGEgbm9uLWVtcHR5IHN0cmluZyBvciBhIHZhbGlkIG51bWJlci4gdmFsPScgK1xuICAgICAgSlNPTi5zdHJpbmdpZnkodmFsKVxuICApO1xufTtcblxuLyoqXG4gKiBQYXJzZSB0aGUgZ2l2ZW4gYHN0cmAgYW5kIHJldHVybiBtaWxsaXNlY29uZHMuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHN0clxuICogQHJldHVybiB7TnVtYmVyfVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gcGFyc2Uoc3RyKSB7XG4gIHN0ciA9IFN0cmluZyhzdHIpO1xuICBpZiAoc3RyLmxlbmd0aCA+IDEwMCkge1xuICAgIHJldHVybjtcbiAgfVxuICB2YXIgbWF0Y2ggPSAvXigtPyg/OlxcZCspP1xcLj9cXGQrKSAqKG1pbGxpc2Vjb25kcz98bXNlY3M/fG1zfHNlY29uZHM/fHNlY3M/fHN8bWludXRlcz98bWlucz98bXxob3Vycz98aHJzP3xofGRheXM/fGR8d2Vla3M/fHd8eWVhcnM/fHlycz98eSk/JC9pLmV4ZWMoXG4gICAgc3RyXG4gICk7XG4gIGlmICghbWF0Y2gpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgdmFyIG4gPSBwYXJzZUZsb2F0KG1hdGNoWzFdKTtcbiAgdmFyIHR5cGUgPSAobWF0Y2hbMl0gfHwgJ21zJykudG9Mb3dlckNhc2UoKTtcbiAgc3dpdGNoICh0eXBlKSB7XG4gICAgY2FzZSAneWVhcnMnOlxuICAgIGNhc2UgJ3llYXInOlxuICAgIGNhc2UgJ3lycyc6XG4gICAgY2FzZSAneXInOlxuICAgIGNhc2UgJ3knOlxuICAgICAgcmV0dXJuIG4gKiB5O1xuICAgIGNhc2UgJ3dlZWtzJzpcbiAgICBjYXNlICd3ZWVrJzpcbiAgICBjYXNlICd3JzpcbiAgICAgIHJldHVybiBuICogdztcbiAgICBjYXNlICdkYXlzJzpcbiAgICBjYXNlICdkYXknOlxuICAgIGNhc2UgJ2QnOlxuICAgICAgcmV0dXJuIG4gKiBkO1xuICAgIGNhc2UgJ2hvdXJzJzpcbiAgICBjYXNlICdob3VyJzpcbiAgICBjYXNlICdocnMnOlxuICAgIGNhc2UgJ2hyJzpcbiAgICBjYXNlICdoJzpcbiAgICAgIHJldHVybiBuICogaDtcbiAgICBjYXNlICdtaW51dGVzJzpcbiAgICBjYXNlICdtaW51dGUnOlxuICAgIGNhc2UgJ21pbnMnOlxuICAgIGNhc2UgJ21pbic6XG4gICAgY2FzZSAnbSc6XG4gICAgICByZXR1cm4gbiAqIG07XG4gICAgY2FzZSAnc2Vjb25kcyc6XG4gICAgY2FzZSAnc2Vjb25kJzpcbiAgICBjYXNlICdzZWNzJzpcbiAgICBjYXNlICdzZWMnOlxuICAgIGNhc2UgJ3MnOlxuICAgICAgcmV0dXJuIG4gKiBzO1xuICAgIGNhc2UgJ21pbGxpc2Vjb25kcyc6XG4gICAgY2FzZSAnbWlsbGlzZWNvbmQnOlxuICAgIGNhc2UgJ21zZWNzJzpcbiAgICBjYXNlICdtc2VjJzpcbiAgICBjYXNlICdtcyc6XG4gICAgICByZXR1cm4gbjtcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxufVxuXG4vKipcbiAqIFNob3J0IGZvcm1hdCBmb3IgYG1zYC5cbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gbXNcbiAqIEByZXR1cm4ge1N0cmluZ31cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIGZtdFNob3J0KG1zKSB7XG4gIHZhciBtc0FicyA9IE1hdGguYWJzKG1zKTtcbiAgaWYgKG1zQWJzID49IGQpIHtcbiAgICByZXR1cm4gTWF0aC5yb3VuZChtcyAvIGQpICsgJ2QnO1xuICB9XG4gIGlmIChtc0FicyA+PSBoKSB7XG4gICAgcmV0dXJuIE1hdGgucm91bmQobXMgLyBoKSArICdoJztcbiAgfVxuICBpZiAobXNBYnMgPj0gbSkge1xuICAgIHJldHVybiBNYXRoLnJvdW5kKG1zIC8gbSkgKyAnbSc7XG4gIH1cbiAgaWYgKG1zQWJzID49IHMpIHtcbiAgICByZXR1cm4gTWF0aC5yb3VuZChtcyAvIHMpICsgJ3MnO1xuICB9XG4gIHJldHVybiBtcyArICdtcyc7XG59XG5cbi8qKlxuICogTG9uZyBmb3JtYXQgZm9yIGBtc2AuXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IG1zXG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBmbXRMb25nKG1zKSB7XG4gIHZhciBtc0FicyA9IE1hdGguYWJzKG1zKTtcbiAgaWYgKG1zQWJzID49IGQpIHtcbiAgICByZXR1cm4gcGx1cmFsKG1zLCBtc0FicywgZCwgJ2RheScpO1xuICB9XG4gIGlmIChtc0FicyA+PSBoKSB7XG4gICAgcmV0dXJuIHBsdXJhbChtcywgbXNBYnMsIGgsICdob3VyJyk7XG4gIH1cbiAgaWYgKG1zQWJzID49IG0pIHtcbiAgICByZXR1cm4gcGx1cmFsKG1zLCBtc0FicywgbSwgJ21pbnV0ZScpO1xuICB9XG4gIGlmIChtc0FicyA+PSBzKSB7XG4gICAgcmV0dXJuIHBsdXJhbChtcywgbXNBYnMsIHMsICdzZWNvbmQnKTtcbiAgfVxuICByZXR1cm4gbXMgKyAnIG1zJztcbn1cblxuLyoqXG4gKiBQbHVyYWxpemF0aW9uIGhlbHBlci5cbiAqL1xuXG5mdW5jdGlvbiBwbHVyYWwobXMsIG1zQWJzLCBuLCBuYW1lKSB7XG4gIHZhciBpc1BsdXJhbCA9IG1zQWJzID49IG4gKiAxLjU7XG4gIHJldHVybiBNYXRoLnJvdW5kKG1zIC8gbikgKyAnICcgKyBuYW1lICsgKGlzUGx1cmFsID8gJ3MnIDogJycpO1xufVxuXG4vKiFcbiAqIGh1bWFuaXplLW1zIC0gaW5kZXguanNcbiAqIENvcHlyaWdodChjKSAyMDE0IGRlYWRfaG9yc2UgPGRlYWRfaG9yc2VAcXEuY29tPlxuICogTUlUIExpY2Vuc2VkXG4gKi9cblxuLyoqXG4gKiBNb2R1bGUgZGVwZW5kZW5jaWVzLlxuICovXG5cbnZhciB1dGlsID0gcmVxdWlyZSQkMDtcbnZhciBtcyQxID0gbXMkMjtcblxudmFyIGh1bWFuaXplTXMgPSBmdW5jdGlvbiAodCkge1xuICBpZiAodHlwZW9mIHQgPT09ICdudW1iZXInKSByZXR1cm4gdDtcbiAgdmFyIHIgPSBtcyQxKHQpO1xuICBpZiAociA9PT0gdW5kZWZpbmVkKSB7XG4gICAgdmFyIGVyciA9IG5ldyBFcnJvcih1dGlsLmZvcm1hdCgnaHVtYW5pemUtbXMoJWopIHJlc3VsdCB1bmRlZmluZWQnLCB0KSk7XG4gICAgY29uc29sZS53YXJuKGVyci5zdGFjayk7XG4gIH1cbiAgcmV0dXJuIHI7XG59O1xuXG52YXIgY29uc3RhbnRzID0ge1xuICAvLyBhZ2VudFxuICBDVVJSRU5UX0lEOiBTeW1ib2woJ2FnZW50a2VlcGFsaXZlI2N1cnJlbnRJZCcpLFxuICBDUkVBVEVfSUQ6IFN5bWJvbCgnYWdlbnRrZWVwYWxpdmUjY3JlYXRlSWQnKSxcbiAgSU5JVF9TT0NLRVQ6IFN5bWJvbCgnYWdlbnRrZWVwYWxpdmUjaW5pdFNvY2tldCcpLFxuICBDUkVBVEVfSFRUUFNfQ09OTkVDVElPTjogU3ltYm9sKCdhZ2VudGtlZXBhbGl2ZSNjcmVhdGVIdHRwc0Nvbm5lY3Rpb24nKSxcbiAgLy8gc29ja2V0XG4gIFNPQ0tFVF9DUkVBVEVEX1RJTUU6IFN5bWJvbCgnYWdlbnRrZWVwYWxpdmUjc29ja2V0Q3JlYXRlZFRpbWUnKSxcbiAgU09DS0VUX05BTUU6IFN5bWJvbCgnYWdlbnRrZWVwYWxpdmUjc29ja2V0TmFtZScpLFxuICBTT0NLRVRfUkVRVUVTVF9DT1VOVDogU3ltYm9sKCdhZ2VudGtlZXBhbGl2ZSNzb2NrZXRSZXF1ZXN0Q291bnQnKSxcbiAgU09DS0VUX1JFUVVFU1RfRklOSVNIRURfQ09VTlQ6IFN5bWJvbCgnYWdlbnRrZWVwYWxpdmUjc29ja2V0UmVxdWVzdEZpbmlzaGVkQ291bnQnKSxcbn07XG5cbmNvbnN0IE9yaWdpbmFsQWdlbnQgPSByZXF1aXJlJCQwJDEuQWdlbnQ7XG5jb25zdCBtcyA9IGh1bWFuaXplTXM7XG5jb25zdCBkZWJ1ZyA9IHJlcXVpcmUkJDAuZGVidWdsb2coJ2FnZW50a2VlcGFsaXZlJyk7XG5jb25zdCB7XG4gIElOSVRfU09DS0VUOiBJTklUX1NPQ0tFVCQxLFxuICBDVVJSRU5UX0lELFxuICBDUkVBVEVfSUQsXG4gIFNPQ0tFVF9DUkVBVEVEX1RJTUUsXG4gIFNPQ0tFVF9OQU1FLFxuICBTT0NLRVRfUkVRVUVTVF9DT1VOVCxcbiAgU09DS0VUX1JFUVVFU1RfRklOSVNIRURfQ09VTlQsXG59ID0gY29uc3RhbnRzO1xuXG4vLyBPcmlnaW5hbEFnZW50IGNvbWUgZnJvbVxuLy8gLSBodHRwczovL2dpdGh1Yi5jb20vbm9kZWpzL25vZGUvYmxvYi92OC4xMi4wL2xpYi9faHR0cF9hZ2VudC5qc1xuLy8gLSBodHRwczovL2dpdGh1Yi5jb20vbm9kZWpzL25vZGUvYmxvYi92MTAuMTIuMC9saWIvX2h0dHBfYWdlbnQuanNcblxuLy8gbm9kZSA8PSAxMFxubGV0IGRlZmF1bHRUaW1lb3V0TGlzdGVuZXJDb3VudCA9IDE7XG5jb25zdCBtYWpvclZlcnNpb24gPSBwYXJzZUludChwcm9jZXNzLnZlcnNpb24uc3BsaXQoJy4nLCAxKVswXS5zdWJzdHJpbmcoMSkpO1xuaWYgKG1ham9yVmVyc2lvbiA+PSAxMSAmJiBtYWpvclZlcnNpb24gPD0gMTIpIHtcbiAgZGVmYXVsdFRpbWVvdXRMaXN0ZW5lckNvdW50ID0gMjtcbn0gZWxzZSBpZiAobWFqb3JWZXJzaW9uID49IDEzKSB7XG4gIGRlZmF1bHRUaW1lb3V0TGlzdGVuZXJDb3VudCA9IDM7XG59XG5cbmZ1bmN0aW9uIGRlcHJlY2F0ZShtZXNzYWdlKSB7XG4gIGNvbnNvbGUubG9nKCdbYWdlbnRrZWVwYWxpdmU6ZGVwcmVjYXRlZF0gJXMnLCBtZXNzYWdlKTtcbn1cblxuY2xhc3MgQWdlbnQgZXh0ZW5kcyBPcmlnaW5hbEFnZW50IHtcbiAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgIG9wdGlvbnMua2VlcEFsaXZlID0gb3B0aW9ucy5rZWVwQWxpdmUgIT09IGZhbHNlO1xuICAgIC8vIGRlZmF1bHQgaXMga2VlcC1hbGl2ZSBhbmQgNHMgZnJlZSBzb2NrZXQgdGltZW91dFxuICAgIC8vIHNlZSBodHRwczovL21lZGl1bS5jb20vc3NlbnNlLXRlY2gvcmVkdWNlLW5ldHdvcmtpbmctZXJyb3JzLWluLW5vZGVqcy0yM2I0ZWI5ZjJkODNcbiAgICBpZiAob3B0aW9ucy5mcmVlU29ja2V0VGltZW91dCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBvcHRpb25zLmZyZWVTb2NrZXRUaW1lb3V0ID0gNDAwMDtcbiAgICB9XG4gICAgLy8gTGVnYWN5IEFQSToga2VlcEFsaXZlVGltZW91dCBzaG91bGQgYmUgcmVuYW1lIHRvIGBmcmVlU29ja2V0VGltZW91dGBcbiAgICBpZiAob3B0aW9ucy5rZWVwQWxpdmVUaW1lb3V0KSB7XG4gICAgICBkZXByZWNhdGUoJ29wdGlvbnMua2VlcEFsaXZlVGltZW91dCBpcyBkZXByZWNhdGVkLCBwbGVhc2UgdXNlIG9wdGlvbnMuZnJlZVNvY2tldFRpbWVvdXQgaW5zdGVhZCcpO1xuICAgICAgb3B0aW9ucy5mcmVlU29ja2V0VGltZW91dCA9IG9wdGlvbnMua2VlcEFsaXZlVGltZW91dDtcbiAgICAgIGRlbGV0ZSBvcHRpb25zLmtlZXBBbGl2ZVRpbWVvdXQ7XG4gICAgfVxuICAgIC8vIExlZ2FjeSBBUEk6IGZyZWVTb2NrZXRLZWVwQWxpdmVUaW1lb3V0IHNob3VsZCBiZSByZW5hbWUgdG8gYGZyZWVTb2NrZXRUaW1lb3V0YFxuICAgIGlmIChvcHRpb25zLmZyZWVTb2NrZXRLZWVwQWxpdmVUaW1lb3V0KSB7XG4gICAgICBkZXByZWNhdGUoJ29wdGlvbnMuZnJlZVNvY2tldEtlZXBBbGl2ZVRpbWVvdXQgaXMgZGVwcmVjYXRlZCwgcGxlYXNlIHVzZSBvcHRpb25zLmZyZWVTb2NrZXRUaW1lb3V0IGluc3RlYWQnKTtcbiAgICAgIG9wdGlvbnMuZnJlZVNvY2tldFRpbWVvdXQgPSBvcHRpb25zLmZyZWVTb2NrZXRLZWVwQWxpdmVUaW1lb3V0O1xuICAgICAgZGVsZXRlIG9wdGlvbnMuZnJlZVNvY2tldEtlZXBBbGl2ZVRpbWVvdXQ7XG4gICAgfVxuXG4gICAgLy8gU2V0cyB0aGUgc29ja2V0IHRvIHRpbWVvdXQgYWZ0ZXIgdGltZW91dCBtaWxsaXNlY29uZHMgb2YgaW5hY3Rpdml0eSBvbiB0aGUgc29ja2V0LlxuICAgIC8vIEJ5IGRlZmF1bHQgaXMgZG91YmxlIGZyZWUgc29ja2V0IHRpbWVvdXQuXG4gICAgaWYgKG9wdGlvbnMudGltZW91dCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAvLyBtYWtlIHN1cmUgc29ja2V0IGRlZmF1bHQgaW5hY3Rpdml0eSB0aW1lb3V0ID49IDhzXG4gICAgICBvcHRpb25zLnRpbWVvdXQgPSBNYXRoLm1heChvcHRpb25zLmZyZWVTb2NrZXRUaW1lb3V0ICogMiwgODAwMCk7XG4gICAgfVxuXG4gICAgLy8gc3VwcG9ydCBodW1hbml6ZSBmb3JtYXRcbiAgICBvcHRpb25zLnRpbWVvdXQgPSBtcyhvcHRpb25zLnRpbWVvdXQpO1xuICAgIG9wdGlvbnMuZnJlZVNvY2tldFRpbWVvdXQgPSBtcyhvcHRpb25zLmZyZWVTb2NrZXRUaW1lb3V0KTtcbiAgICBvcHRpb25zLnNvY2tldEFjdGl2ZVRUTCA9IG9wdGlvbnMuc29ja2V0QWN0aXZlVFRMID8gbXMob3B0aW9ucy5zb2NrZXRBY3RpdmVUVEwpIDogMDtcblxuICAgIHN1cGVyKG9wdGlvbnMpO1xuXG4gICAgdGhpc1tDVVJSRU5UX0lEXSA9IDA7XG5cbiAgICAvLyBjcmVhdGUgc29ja2V0IHN1Y2Nlc3MgY291bnRlclxuICAgIHRoaXMuY3JlYXRlU29ja2V0Q291bnQgPSAwO1xuICAgIHRoaXMuY3JlYXRlU29ja2V0Q291bnRMYXN0Q2hlY2sgPSAwO1xuXG4gICAgdGhpcy5jcmVhdGVTb2NrZXRFcnJvckNvdW50ID0gMDtcbiAgICB0aGlzLmNyZWF0ZVNvY2tldEVycm9yQ291bnRMYXN0Q2hlY2sgPSAwO1xuXG4gICAgdGhpcy5jbG9zZVNvY2tldENvdW50ID0gMDtcbiAgICB0aGlzLmNsb3NlU29ja2V0Q291bnRMYXN0Q2hlY2sgPSAwO1xuXG4gICAgLy8gc29ja2V0IGVycm9yIGV2ZW50IGNvdW50XG4gICAgdGhpcy5lcnJvclNvY2tldENvdW50ID0gMDtcbiAgICB0aGlzLmVycm9yU29ja2V0Q291bnRMYXN0Q2hlY2sgPSAwO1xuXG4gICAgLy8gcmVxdWVzdCBmaW5pc2hlZCBjb3VudGVyXG4gICAgdGhpcy5yZXF1ZXN0Q291bnQgPSAwO1xuICAgIHRoaXMucmVxdWVzdENvdW50TGFzdENoZWNrID0gMDtcblxuICAgIC8vIGluY2x1ZGluZyBmcmVlIHNvY2tldCB0aW1lb3V0IGNvdW50ZXJcbiAgICB0aGlzLnRpbWVvdXRTb2NrZXRDb3VudCA9IDA7XG4gICAgdGhpcy50aW1lb3V0U29ja2V0Q291bnRMYXN0Q2hlY2sgPSAwO1xuXG4gICAgdGhpcy5vbignZnJlZScsIHNvY2tldCA9PiB7XG4gICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vbm9kZWpzL25vZGUvcHVsbC8zMjAwMFxuICAgICAgLy8gTm9kZS5qcyBuYXRpdmUgYWdlbnQgd2lsbCBjaGVjayBzb2NrZXQgdGltZW91dCBlcXMgYWdlbnQub3B0aW9ucy50aW1lb3V0LlxuICAgICAgLy8gVXNlIHRoZSB0dGwgb3IgZnJlZVNvY2tldFRpbWVvdXQgdG8gb3ZlcndyaXRlLlxuICAgICAgY29uc3QgdGltZW91dCA9IHRoaXMuY2FsY1NvY2tldFRpbWVvdXQoc29ja2V0KTtcbiAgICAgIGlmICh0aW1lb3V0ID4gMCAmJiBzb2NrZXQudGltZW91dCAhPT0gdGltZW91dCkge1xuICAgICAgICBzb2NrZXQuc2V0VGltZW91dCh0aW1lb3V0KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIGdldCBmcmVlU29ja2V0S2VlcEFsaXZlVGltZW91dCgpIHtcbiAgICBkZXByZWNhdGUoJ2FnZW50LmZyZWVTb2NrZXRLZWVwQWxpdmVUaW1lb3V0IGlzIGRlcHJlY2F0ZWQsIHBsZWFzZSB1c2UgYWdlbnQub3B0aW9ucy5mcmVlU29ja2V0VGltZW91dCBpbnN0ZWFkJyk7XG4gICAgcmV0dXJuIHRoaXMub3B0aW9ucy5mcmVlU29ja2V0VGltZW91dDtcbiAgfVxuXG4gIGdldCB0aW1lb3V0KCkge1xuICAgIGRlcHJlY2F0ZSgnYWdlbnQudGltZW91dCBpcyBkZXByZWNhdGVkLCBwbGVhc2UgdXNlIGFnZW50Lm9wdGlvbnMudGltZW91dCBpbnN0ZWFkJyk7XG4gICAgcmV0dXJuIHRoaXMub3B0aW9ucy50aW1lb3V0O1xuICB9XG5cbiAgZ2V0IHNvY2tldEFjdGl2ZVRUTCgpIHtcbiAgICBkZXByZWNhdGUoJ2FnZW50LnNvY2tldEFjdGl2ZVRUTCBpcyBkZXByZWNhdGVkLCBwbGVhc2UgdXNlIGFnZW50Lm9wdGlvbnMuc29ja2V0QWN0aXZlVFRMIGluc3RlYWQnKTtcbiAgICByZXR1cm4gdGhpcy5vcHRpb25zLnNvY2tldEFjdGl2ZVRUTDtcbiAgfVxuXG4gIGNhbGNTb2NrZXRUaW1lb3V0KHNvY2tldCkge1xuICAgIC8qKlxuICAgICAqIHJldHVybiA8PSAwOiBzaG91bGQgZnJlZSBzb2NrZXRcbiAgICAgKiByZXR1cm4gPiAwOiBzaG91bGQgdXBkYXRlIHNvY2tldCB0aW1lb3V0XG4gICAgICogcmV0dXJuIHVuZGVmaW5lZDogbm90IGZpbmQgY3VzdG9tIHRpbWVvdXRcbiAgICAgKi9cbiAgICBsZXQgZnJlZVNvY2tldFRpbWVvdXQgPSB0aGlzLm9wdGlvbnMuZnJlZVNvY2tldFRpbWVvdXQ7XG4gICAgY29uc3Qgc29ja2V0QWN0aXZlVFRMID0gdGhpcy5vcHRpb25zLnNvY2tldEFjdGl2ZVRUTDtcbiAgICBpZiAoc29ja2V0QWN0aXZlVFRMKSB7XG4gICAgICAvLyBjaGVjayBzb2NrZXRBY3RpdmVUVExcbiAgICAgIGNvbnN0IGFsaXZlVGltZSA9IERhdGUubm93KCkgLSBzb2NrZXRbU09DS0VUX0NSRUFURURfVElNRV07XG4gICAgICBjb25zdCBkaWZmID0gc29ja2V0QWN0aXZlVFRMIC0gYWxpdmVUaW1lO1xuICAgICAgaWYgKGRpZmYgPD0gMCkge1xuICAgICAgICByZXR1cm4gZGlmZjtcbiAgICAgIH1cbiAgICAgIGlmIChmcmVlU29ja2V0VGltZW91dCAmJiBkaWZmIDwgZnJlZVNvY2tldFRpbWVvdXQpIHtcbiAgICAgICAgZnJlZVNvY2tldFRpbWVvdXQgPSBkaWZmO1xuICAgICAgfVxuICAgIH1cbiAgICAvLyBzZXQgZnJlZVNvY2tldFRpbWVvdXRcbiAgICBpZiAoZnJlZVNvY2tldFRpbWVvdXQpIHtcbiAgICAgIC8vIHNldCBmcmVlIGtlZXBhbGl2ZSB0aW1lclxuICAgICAgLy8gdHJ5IHRvIHVzZSBzb2NrZXQgY3VzdG9tIGZyZWVTb2NrZXRUaW1lb3V0IGZpcnN0LCBzdXBwb3J0IGhlYWRlcnNbJ2tlZXAtYWxpdmUnXVxuICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL25vZGUtbW9kdWxlcy91cmxsaWIvYmxvYi9iNzYwNTMwMjA5MjNmNGQ5OWExYzkzY2YyZTE2ZTBjNWJhMTBiYWNmL2xpYi91cmxsaWIuanMjTDQ5OFxuICAgICAgY29uc3QgY3VzdG9tRnJlZVNvY2tldFRpbWVvdXQgPSBzb2NrZXQuZnJlZVNvY2tldFRpbWVvdXQgfHwgc29ja2V0LmZyZWVTb2NrZXRLZWVwQWxpdmVUaW1lb3V0O1xuICAgICAgcmV0dXJuIGN1c3RvbUZyZWVTb2NrZXRUaW1lb3V0IHx8IGZyZWVTb2NrZXRUaW1lb3V0O1xuICAgIH1cbiAgfVxuXG4gIGtlZXBTb2NrZXRBbGl2ZShzb2NrZXQpIHtcbiAgICBjb25zdCByZXN1bHQgPSBzdXBlci5rZWVwU29ja2V0QWxpdmUoc29ja2V0KTtcbiAgICAvLyBzaG91bGQgbm90IGtlZXBBbGl2ZSwgZG8gbm90aGluZ1xuICAgIGlmICghcmVzdWx0KSByZXR1cm4gcmVzdWx0O1xuXG4gICAgY29uc3QgY3VzdG9tVGltZW91dCA9IHRoaXMuY2FsY1NvY2tldFRpbWVvdXQoc29ja2V0KTtcbiAgICBpZiAodHlwZW9mIGN1c3RvbVRpbWVvdXQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKGN1c3RvbVRpbWVvdXQgPD0gMCkge1xuICAgICAgZGVidWcoJyVzKHJlcXVlc3RzOiAlcywgZmluaXNoZWQ6ICVzKSBmcmVlIGJ1dCBuZWVkIHRvIGRlc3Ryb3kgYnkgVFRMLCByZXF1ZXN0IGNvdW50ICVzLCBkaWZmIGlzICVzJyxcbiAgICAgICAgc29ja2V0W1NPQ0tFVF9OQU1FXSwgc29ja2V0W1NPQ0tFVF9SRVFVRVNUX0NPVU5UXSwgc29ja2V0W1NPQ0tFVF9SRVFVRVNUX0ZJTklTSEVEX0NPVU5UXSwgY3VzdG9tVGltZW91dCk7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmIChzb2NrZXQudGltZW91dCAhPT0gY3VzdG9tVGltZW91dCkge1xuICAgICAgc29ja2V0LnNldFRpbWVvdXQoY3VzdG9tVGltZW91dCk7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgLy8gb25seSBjYWxsIG9uIGFkZFJlcXVlc3RcbiAgcmV1c2VTb2NrZXQoLi4uYXJncykge1xuICAgIC8vIHJldXNlU29ja2V0KHNvY2tldCwgcmVxKVxuICAgIHN1cGVyLnJldXNlU29ja2V0KC4uLmFyZ3MpO1xuICAgIGNvbnN0IHNvY2tldCA9IGFyZ3NbMF07XG4gICAgY29uc3QgcmVxID0gYXJnc1sxXTtcbiAgICByZXEucmV1c2VkU29ja2V0ID0gdHJ1ZTtcbiAgICBjb25zdCBhZ2VudFRpbWVvdXQgPSB0aGlzLm9wdGlvbnMudGltZW91dDtcbiAgICBpZiAoZ2V0U29ja2V0VGltZW91dChzb2NrZXQpICE9PSBhZ2VudFRpbWVvdXQpIHtcbiAgICAgIC8vIHJlc2V0IHRpbWVvdXQgYmVmb3JlIHVzZVxuICAgICAgc29ja2V0LnNldFRpbWVvdXQoYWdlbnRUaW1lb3V0KTtcbiAgICAgIGRlYnVnKCclcyByZXNldCB0aW1lb3V0IHRvICVzbXMnLCBzb2NrZXRbU09DS0VUX05BTUVdLCBhZ2VudFRpbWVvdXQpO1xuICAgIH1cbiAgICBzb2NrZXRbU09DS0VUX1JFUVVFU1RfQ09VTlRdKys7XG4gICAgZGVidWcoJyVzKHJlcXVlc3RzOiAlcywgZmluaXNoZWQ6ICVzKSByZXVzZSBvbiBhZGRSZXF1ZXN0LCB0aW1lb3V0ICVzbXMnLFxuICAgICAgc29ja2V0W1NPQ0tFVF9OQU1FXSwgc29ja2V0W1NPQ0tFVF9SRVFVRVNUX0NPVU5UXSwgc29ja2V0W1NPQ0tFVF9SRVFVRVNUX0ZJTklTSEVEX0NPVU5UXSxcbiAgICAgIGdldFNvY2tldFRpbWVvdXQoc29ja2V0KSk7XG4gIH1cblxuICBbQ1JFQVRFX0lEXSgpIHtcbiAgICBjb25zdCBpZCA9IHRoaXNbQ1VSUkVOVF9JRF0rKztcbiAgICBpZiAodGhpc1tDVVJSRU5UX0lEXSA9PT0gTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVIpIHRoaXNbQ1VSUkVOVF9JRF0gPSAwO1xuICAgIHJldHVybiBpZDtcbiAgfVxuXG4gIFtJTklUX1NPQ0tFVCQxXShzb2NrZXQsIG9wdGlvbnMpIHtcbiAgICAvLyBidWdmaXggaGVyZS5cbiAgICAvLyBodHRwcyBvbiBub2RlIDgsIDEwIHdvbid0IHNldCBhZ2VudC5vcHRpb25zLnRpbWVvdXQgYnkgZGVmYXVsdFxuICAgIC8vIFRPRE86IG5lZWQgdG8gZml4IG9uIG5vZGUgaXRzZWxmXG4gICAgaWYgKG9wdGlvbnMudGltZW91dCkge1xuICAgICAgY29uc3QgdGltZW91dCA9IGdldFNvY2tldFRpbWVvdXQoc29ja2V0KTtcbiAgICAgIGlmICghdGltZW91dCkge1xuICAgICAgICBzb2NrZXQuc2V0VGltZW91dChvcHRpb25zLnRpbWVvdXQpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh0aGlzLm9wdGlvbnMua2VlcEFsaXZlKSB7XG4gICAgICAvLyBEaXNhYmxlIE5hZ2xlJ3MgYWxnb3JpdGhtOiBodHRwOi8vYmxvZy5jYXVzdGlrLmNvbS8yMDEyLzA0LzA4L3NjYWxpbmctbm9kZS1qcy10by0xMDBrLWNvbmN1cnJlbnQtY29ubmVjdGlvbnMvXG4gICAgICAvLyBodHRwczovL2ZlbmdtazIuY29tL2JlbmNobWFyay9uYWdsZS1hbGdvcml0aG0tZGVsYXllZC1hY2stbW9jay5odG1sXG4gICAgICBzb2NrZXQuc2V0Tm9EZWxheSh0cnVlKTtcbiAgICB9XG4gICAgdGhpcy5jcmVhdGVTb2NrZXRDb3VudCsrO1xuICAgIGlmICh0aGlzLm9wdGlvbnMuc29ja2V0QWN0aXZlVFRMKSB7XG4gICAgICBzb2NrZXRbU09DS0VUX0NSRUFURURfVElNRV0gPSBEYXRlLm5vdygpO1xuICAgIH1cbiAgICAvLyBkb24ndCBzaG93IHRoZSBob2xlICctLS0tLUJFR0lOIENFUlRJRklDQVRFLS0tLScga2V5IHN0cmluZ1xuICAgIHNvY2tldFtTT0NLRVRfTkFNRV0gPSBgc29ja1ske3RoaXNbQ1JFQVRFX0lEXSgpfSMke29wdGlvbnMuX2FnZW50S2V5fV1gLnNwbGl0KCctLS0tLUJFR0lOJywgMSlbMF07XG4gICAgc29ja2V0W1NPQ0tFVF9SRVFVRVNUX0NPVU5UXSA9IDE7XG4gICAgc29ja2V0W1NPQ0tFVF9SRVFVRVNUX0ZJTklTSEVEX0NPVU5UXSA9IDA7XG4gICAgaW5zdGFsbExpc3RlbmVycyh0aGlzLCBzb2NrZXQsIG9wdGlvbnMpO1xuICB9XG5cbiAgY3JlYXRlQ29ubmVjdGlvbihvcHRpb25zLCBvbmNyZWF0ZSkge1xuICAgIGxldCBjYWxsZWQgPSBmYWxzZTtcbiAgICBjb25zdCBvbk5ld0NyZWF0ZSA9IChlcnIsIHNvY2tldCkgPT4ge1xuICAgICAgaWYgKGNhbGxlZCkgcmV0dXJuO1xuICAgICAgY2FsbGVkID0gdHJ1ZTtcblxuICAgICAgaWYgKGVycikge1xuICAgICAgICB0aGlzLmNyZWF0ZVNvY2tldEVycm9yQ291bnQrKztcbiAgICAgICAgcmV0dXJuIG9uY3JlYXRlKGVycik7XG4gICAgICB9XG4gICAgICB0aGlzW0lOSVRfU09DS0VUJDFdKHNvY2tldCwgb3B0aW9ucyk7XG4gICAgICBvbmNyZWF0ZShlcnIsIHNvY2tldCk7XG4gICAgfTtcblxuICAgIGNvbnN0IG5ld1NvY2tldCA9IHN1cGVyLmNyZWF0ZUNvbm5lY3Rpb24ob3B0aW9ucywgb25OZXdDcmVhdGUpO1xuICAgIGlmIChuZXdTb2NrZXQpIG9uTmV3Q3JlYXRlKG51bGwsIG5ld1NvY2tldCk7XG4gICAgcmV0dXJuIG5ld1NvY2tldDtcbiAgfVxuXG4gIGdldCBzdGF0dXNDaGFuZ2VkKCkge1xuICAgIGNvbnN0IGNoYW5nZWQgPSB0aGlzLmNyZWF0ZVNvY2tldENvdW50ICE9PSB0aGlzLmNyZWF0ZVNvY2tldENvdW50TGFzdENoZWNrIHx8XG4gICAgICB0aGlzLmNyZWF0ZVNvY2tldEVycm9yQ291bnQgIT09IHRoaXMuY3JlYXRlU29ja2V0RXJyb3JDb3VudExhc3RDaGVjayB8fFxuICAgICAgdGhpcy5jbG9zZVNvY2tldENvdW50ICE9PSB0aGlzLmNsb3NlU29ja2V0Q291bnRMYXN0Q2hlY2sgfHxcbiAgICAgIHRoaXMuZXJyb3JTb2NrZXRDb3VudCAhPT0gdGhpcy5lcnJvclNvY2tldENvdW50TGFzdENoZWNrIHx8XG4gICAgICB0aGlzLnRpbWVvdXRTb2NrZXRDb3VudCAhPT0gdGhpcy50aW1lb3V0U29ja2V0Q291bnRMYXN0Q2hlY2sgfHxcbiAgICAgIHRoaXMucmVxdWVzdENvdW50ICE9PSB0aGlzLnJlcXVlc3RDb3VudExhc3RDaGVjaztcbiAgICBpZiAoY2hhbmdlZCkge1xuICAgICAgdGhpcy5jcmVhdGVTb2NrZXRDb3VudExhc3RDaGVjayA9IHRoaXMuY3JlYXRlU29ja2V0Q291bnQ7XG4gICAgICB0aGlzLmNyZWF0ZVNvY2tldEVycm9yQ291bnRMYXN0Q2hlY2sgPSB0aGlzLmNyZWF0ZVNvY2tldEVycm9yQ291bnQ7XG4gICAgICB0aGlzLmNsb3NlU29ja2V0Q291bnRMYXN0Q2hlY2sgPSB0aGlzLmNsb3NlU29ja2V0Q291bnQ7XG4gICAgICB0aGlzLmVycm9yU29ja2V0Q291bnRMYXN0Q2hlY2sgPSB0aGlzLmVycm9yU29ja2V0Q291bnQ7XG4gICAgICB0aGlzLnRpbWVvdXRTb2NrZXRDb3VudExhc3RDaGVjayA9IHRoaXMudGltZW91dFNvY2tldENvdW50O1xuICAgICAgdGhpcy5yZXF1ZXN0Q291bnRMYXN0Q2hlY2sgPSB0aGlzLnJlcXVlc3RDb3VudDtcbiAgICB9XG4gICAgcmV0dXJuIGNoYW5nZWQ7XG4gIH1cblxuICBnZXRDdXJyZW50U3RhdHVzKCkge1xuICAgIHJldHVybiB7XG4gICAgICBjcmVhdGVTb2NrZXRDb3VudDogdGhpcy5jcmVhdGVTb2NrZXRDb3VudCxcbiAgICAgIGNyZWF0ZVNvY2tldEVycm9yQ291bnQ6IHRoaXMuY3JlYXRlU29ja2V0RXJyb3JDb3VudCxcbiAgICAgIGNsb3NlU29ja2V0Q291bnQ6IHRoaXMuY2xvc2VTb2NrZXRDb3VudCxcbiAgICAgIGVycm9yU29ja2V0Q291bnQ6IHRoaXMuZXJyb3JTb2NrZXRDb3VudCxcbiAgICAgIHRpbWVvdXRTb2NrZXRDb3VudDogdGhpcy50aW1lb3V0U29ja2V0Q291bnQsXG4gICAgICByZXF1ZXN0Q291bnQ6IHRoaXMucmVxdWVzdENvdW50LFxuICAgICAgZnJlZVNvY2tldHM6IGluc3BlY3QodGhpcy5mcmVlU29ja2V0cyksXG4gICAgICBzb2NrZXRzOiBpbnNwZWN0KHRoaXMuc29ja2V0cyksXG4gICAgICByZXF1ZXN0czogaW5zcGVjdCh0aGlzLnJlcXVlc3RzKSxcbiAgICB9O1xuICB9XG59XG5cbi8vIG5vZGUgOCBkb24ndCBoYXMgdGltZW91dCBhdHRyaWJ1dGUgb24gc29ja2V0XG4vLyBodHRwczovL2dpdGh1Yi5jb20vbm9kZWpzL25vZGUvcHVsbC8yMTIwNC9maWxlcyNkaWZmLWU2ZWYwMjRjMzc3NWQ3ODdjMzg0ODdhNjMwOWU0OTFkUjQwOFxuZnVuY3Rpb24gZ2V0U29ja2V0VGltZW91dChzb2NrZXQpIHtcbiAgcmV0dXJuIHNvY2tldC50aW1lb3V0IHx8IHNvY2tldC5faWRsZVRpbWVvdXQ7XG59XG5cbmZ1bmN0aW9uIGluc3RhbGxMaXN0ZW5lcnMoYWdlbnQsIHNvY2tldCwgb3B0aW9ucykge1xuICBkZWJ1ZygnJXMgY3JlYXRlLCB0aW1lb3V0ICVzbXMnLCBzb2NrZXRbU09DS0VUX05BTUVdLCBnZXRTb2NrZXRUaW1lb3V0KHNvY2tldCkpO1xuXG4gIC8vIGxpc3RlbmVyIHNvY2tldCBldmVudHM6IGNsb3NlLCB0aW1lb3V0LCBlcnJvciwgZnJlZVxuICBmdW5jdGlvbiBvbkZyZWUoKSB7XG4gICAgLy8gY3JlYXRlIGFuZCBzb2NrZXQuZW1pdCgnZnJlZScpIGxvZ2ljXG4gICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL25vZGVqcy9ub2RlL2Jsb2IvbWFzdGVyL2xpYi9faHR0cF9hZ2VudC5qcyNMMzExXG4gICAgLy8gbm8gcmVxIG9uIHRoZSBzb2NrZXQsIGl0IHNob3VsZCBiZSB0aGUgbmV3IHNvY2tldFxuICAgIGlmICghc29ja2V0Ll9odHRwTWVzc2FnZSAmJiBzb2NrZXRbU09DS0VUX1JFUVVFU1RfQ09VTlRdID09PSAxKSByZXR1cm47XG5cbiAgICBzb2NrZXRbU09DS0VUX1JFUVVFU1RfRklOSVNIRURfQ09VTlRdKys7XG4gICAgYWdlbnQucmVxdWVzdENvdW50Kys7XG4gICAgZGVidWcoJyVzKHJlcXVlc3RzOiAlcywgZmluaXNoZWQ6ICVzKSBmcmVlJyxcbiAgICAgIHNvY2tldFtTT0NLRVRfTkFNRV0sIHNvY2tldFtTT0NLRVRfUkVRVUVTVF9DT1VOVF0sIHNvY2tldFtTT0NLRVRfUkVRVUVTVF9GSU5JU0hFRF9DT1VOVF0pO1xuXG4gICAgLy8gc2hvdWxkIHJldXNlIG9uIHBlZGRpbmcgcmVxdWVzdHM/XG4gICAgY29uc3QgbmFtZSA9IGFnZW50LmdldE5hbWUob3B0aW9ucyk7XG4gICAgaWYgKHNvY2tldC53cml0YWJsZSAmJiBhZ2VudC5yZXF1ZXN0c1tuYW1lXSAmJiBhZ2VudC5yZXF1ZXN0c1tuYW1lXS5sZW5ndGgpIHtcbiAgICAgIC8vIHdpbGwgYmUgcmV1c2Ugb24gYWdlbnQgZnJlZSBsaXN0ZW5lclxuICAgICAgc29ja2V0W1NPQ0tFVF9SRVFVRVNUX0NPVU5UXSsrO1xuICAgICAgZGVidWcoJyVzKHJlcXVlc3RzOiAlcywgZmluaXNoZWQ6ICVzKSB3aWxsIGJlIHJldXNlIG9uIGFnZW50IGZyZWUgZXZlbnQnLFxuICAgICAgICBzb2NrZXRbU09DS0VUX05BTUVdLCBzb2NrZXRbU09DS0VUX1JFUVVFU1RfQ09VTlRdLCBzb2NrZXRbU09DS0VUX1JFUVVFU1RfRklOSVNIRURfQ09VTlRdKTtcbiAgICB9XG4gIH1cbiAgc29ja2V0Lm9uKCdmcmVlJywgb25GcmVlKTtcblxuICBmdW5jdGlvbiBvbkNsb3NlKGlzRXJyb3IpIHtcbiAgICBkZWJ1ZygnJXMocmVxdWVzdHM6ICVzLCBmaW5pc2hlZDogJXMpIGNsb3NlLCBpc0Vycm9yOiAlcycsXG4gICAgICBzb2NrZXRbU09DS0VUX05BTUVdLCBzb2NrZXRbU09DS0VUX1JFUVVFU1RfQ09VTlRdLCBzb2NrZXRbU09DS0VUX1JFUVVFU1RfRklOSVNIRURfQ09VTlRdLCBpc0Vycm9yKTtcbiAgICBhZ2VudC5jbG9zZVNvY2tldENvdW50Kys7XG4gIH1cbiAgc29ja2V0Lm9uKCdjbG9zZScsIG9uQ2xvc2UpO1xuXG4gIC8vIHN0YXJ0IHNvY2tldCB0aW1lb3V0IGhhbmRsZXJcbiAgZnVuY3Rpb24gb25UaW1lb3V0KCkge1xuICAgIC8vIG9uVGltZW91dCBhbmQgZW1pdFJlcXVlc3RUaW1lb3V0KF9odHRwX2NsaWVudC5qcylcbiAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vbm9kZWpzL25vZGUvYmxvYi92MTIueC9saWIvX2h0dHBfY2xpZW50LmpzI0w3MTFcbiAgICBjb25zdCBsaXN0ZW5lckNvdW50ID0gc29ja2V0Lmxpc3RlbmVycygndGltZW91dCcpLmxlbmd0aDtcbiAgICAvLyBub2RlIDw9IDEwLCBkZWZhdWx0IGxpc3RlbmVyQ291bnQgaXMgMSwgb25UaW1lb3V0XG4gICAgLy8gMTEgPCBub2RlIDw9IDEyLCBkZWZhdWx0IGxpc3RlbmVyQ291bnQgaXMgMiwgb25UaW1lb3V0IGFuZCBlbWl0UmVxdWVzdFRpbWVvdXRcbiAgICAvLyBub2RlID49IDEzLCBkZWZhdWx0IGxpc3RlbmVyQ291bnQgaXMgMywgb25UaW1lb3V0LFxuICAgIC8vICAgb25UaW1lb3V0KGh0dHBzOi8vZ2l0aHViLmNvbS9ub2RlanMvbm9kZS9wdWxsLzMyMDAwL2ZpbGVzI2RpZmYtNWY3ZmIwODUwNDEyYzZiZTE4OWZhZWRkZWE2YzUzNTlSMzMzKVxuICAgIC8vICAgYW5kIGVtaXRSZXF1ZXN0VGltZW91dFxuICAgIGNvbnN0IHRpbWVvdXQgPSBnZXRTb2NrZXRUaW1lb3V0KHNvY2tldCk7XG4gICAgY29uc3QgcmVxID0gc29ja2V0Ll9odHRwTWVzc2FnZTtcbiAgICBjb25zdCByZXFUaW1lb3V0TGlzdGVuZXJDb3VudCA9IHJlcSAmJiByZXEubGlzdGVuZXJzKCd0aW1lb3V0JykubGVuZ3RoIHx8IDA7XG4gICAgZGVidWcoJyVzKHJlcXVlc3RzOiAlcywgZmluaXNoZWQ6ICVzKSB0aW1lb3V0IGFmdGVyICVzbXMsIGxpc3RlbmVycyAlcywgZGVmYXVsdFRpbWVvdXRMaXN0ZW5lckNvdW50ICVzLCBoYXNIdHRwUmVxdWVzdCAlcywgSHR0cFJlcXVlc3QgdGltZW91dExpc3RlbmVyQ291bnQgJXMnLFxuICAgICAgc29ja2V0W1NPQ0tFVF9OQU1FXSwgc29ja2V0W1NPQ0tFVF9SRVFVRVNUX0NPVU5UXSwgc29ja2V0W1NPQ0tFVF9SRVFVRVNUX0ZJTklTSEVEX0NPVU5UXSxcbiAgICAgIHRpbWVvdXQsIGxpc3RlbmVyQ291bnQsIGRlZmF1bHRUaW1lb3V0TGlzdGVuZXJDb3VudCwgISFyZXEsIHJlcVRpbWVvdXRMaXN0ZW5lckNvdW50KTtcbiAgICBpZiAoZGVidWcuZW5hYmxlZCkge1xuICAgICAgZGVidWcoJ3RpbWVvdXQgbGlzdGVuZXJzOiAlcycsIHNvY2tldC5saXN0ZW5lcnMoJ3RpbWVvdXQnKS5tYXAoZiA9PiBmLm5hbWUpLmpvaW4oJywgJykpO1xuICAgIH1cbiAgICBhZ2VudC50aW1lb3V0U29ja2V0Q291bnQrKztcbiAgICBjb25zdCBuYW1lID0gYWdlbnQuZ2V0TmFtZShvcHRpb25zKTtcbiAgICBpZiAoYWdlbnQuZnJlZVNvY2tldHNbbmFtZV0gJiYgYWdlbnQuZnJlZVNvY2tldHNbbmFtZV0uaW5kZXhPZihzb2NrZXQpICE9PSAtMSkge1xuICAgICAgLy8gZnJlZSBzb2NrZXQgdGltZW91dCwgZGVzdHJveSBxdWlldGx5XG4gICAgICBzb2NrZXQuZGVzdHJveSgpO1xuICAgICAgLy8gUmVtb3ZlIGl0IGZyb20gZnJlZVNvY2tldHMgbGlzdCBpbW1lZGlhdGVseSB0byBwcmV2ZW50IG5ldyByZXF1ZXN0c1xuICAgICAgLy8gZnJvbSBiZWluZyBzZW50IHRocm91Z2ggdGhpcyBzb2NrZXQuXG4gICAgICBhZ2VudC5yZW1vdmVTb2NrZXQoc29ja2V0LCBvcHRpb25zKTtcbiAgICAgIGRlYnVnKCclcyBpcyBmcmVlLCBkZXN0cm95IHF1aWV0bHknLCBzb2NrZXRbU09DS0VUX05BTUVdKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gaWYgdGhlcmUgaXMgbm8gYW55IHJlcXVlc3Qgc29ja2V0IHRpbWVvdXQgaGFuZGxlcixcbiAgICAgIC8vIGFnZW50IG5lZWQgdG8gaGFuZGxlIHNvY2tldCB0aW1lb3V0IGl0c2VsZi5cbiAgICAgIC8vXG4gICAgICAvLyBjdXN0b20gcmVxdWVzdCBzb2NrZXQgdGltZW91dCBoYW5kbGUgbG9naWMgbXVzdCBmb2xsb3cgdGhlc2UgcnVsZXM6XG4gICAgICAvLyAgMS4gRGVzdHJveSBzb2NrZXQgZmlyc3RcbiAgICAgIC8vICAyLiBNdXN0IGVtaXQgc29ja2V0ICdhZ2VudFJlbW92ZScgZXZlbnQgdGVsbCBhZ2VudCByZW1vdmUgc29ja2V0XG4gICAgICAvLyAgICAgZnJvbSBmcmVlU29ja2V0cyBsaXN0IGltbWVkaWF0ZWx5LlxuICAgICAgLy8gICAgIE90aGVyaXNlIHlvdSBtYXkgYmUgZ2V0ICdzb2NrZXQgaGFuZyB1cCcgZXJyb3Igd2hlbiByZXVzZVxuICAgICAgLy8gICAgIGZyZWUgc29ja2V0IGFuZCB0aW1lb3V0IGhhcHBlbiBpbiB0aGUgc2FtZSB0aW1lLlxuICAgICAgaWYgKHJlcVRpbWVvdXRMaXN0ZW5lckNvdW50ID09PSAwKSB7XG4gICAgICAgIGNvbnN0IGVycm9yID0gbmV3IEVycm9yKCdTb2NrZXQgdGltZW91dCcpO1xuICAgICAgICBlcnJvci5jb2RlID0gJ0VSUl9TT0NLRVRfVElNRU9VVCc7XG4gICAgICAgIGVycm9yLnRpbWVvdXQgPSB0aW1lb3V0O1xuICAgICAgICAvLyBtdXN0IG1hbnVhbGx5IGNhbGwgc29ja2V0LmVuZCgpIG9yIHNvY2tldC5kZXN0cm95KCkgdG8gZW5kIHRoZSBjb25uZWN0aW9uLlxuICAgICAgICAvLyBodHRwczovL25vZGVqcy5vcmcvZGlzdC9sYXRlc3QtdjEwLngvZG9jcy9hcGkvbmV0Lmh0bWwjbmV0X3NvY2tldF9zZXR0aW1lb3V0X3RpbWVvdXRfY2FsbGJhY2tcbiAgICAgICAgc29ja2V0LmRlc3Ryb3koZXJyb3IpO1xuICAgICAgICBhZ2VudC5yZW1vdmVTb2NrZXQoc29ja2V0LCBvcHRpb25zKTtcbiAgICAgICAgZGVidWcoJyVzIGRlc3Ryb3kgd2l0aCB0aW1lb3V0IGVycm9yJywgc29ja2V0W1NPQ0tFVF9OQU1FXSk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHNvY2tldC5vbigndGltZW91dCcsIG9uVGltZW91dCk7XG5cbiAgZnVuY3Rpb24gb25FcnJvcihlcnIpIHtcbiAgICBjb25zdCBsaXN0ZW5lckNvdW50ID0gc29ja2V0Lmxpc3RlbmVycygnZXJyb3InKS5sZW5ndGg7XG4gICAgZGVidWcoJyVzKHJlcXVlc3RzOiAlcywgZmluaXNoZWQ6ICVzKSBlcnJvcjogJXMsIGxpc3RlbmVyQ291bnQ6ICVzJyxcbiAgICAgIHNvY2tldFtTT0NLRVRfTkFNRV0sIHNvY2tldFtTT0NLRVRfUkVRVUVTVF9DT1VOVF0sIHNvY2tldFtTT0NLRVRfUkVRVUVTVF9GSU5JU0hFRF9DT1VOVF0sXG4gICAgICBlcnIsIGxpc3RlbmVyQ291bnQpO1xuICAgIGFnZW50LmVycm9yU29ja2V0Q291bnQrKztcbiAgICBpZiAobGlzdGVuZXJDb3VudCA9PT0gMSkge1xuICAgICAgLy8gaWYgc29ja2V0IGRvbid0IGNvbnRhaW4gZXJyb3IgZXZlbnQgaGFuZGxlciwgZG9uJ3QgY2F0Y2ggaXQsIGVtaXQgaXQgYWdhaW5cbiAgICAgIGRlYnVnKCclcyBlbWl0IHVuY2F1Z2h0IGVycm9yIGV2ZW50Jywgc29ja2V0W1NPQ0tFVF9OQU1FXSk7XG4gICAgICBzb2NrZXQucmVtb3ZlTGlzdGVuZXIoJ2Vycm9yJywgb25FcnJvcik7XG4gICAgICBzb2NrZXQuZW1pdCgnZXJyb3InLCBlcnIpO1xuICAgIH1cbiAgfVxuICBzb2NrZXQub24oJ2Vycm9yJywgb25FcnJvcik7XG5cbiAgZnVuY3Rpb24gb25SZW1vdmUoKSB7XG4gICAgZGVidWcoJyVzKHJlcXVlc3RzOiAlcywgZmluaXNoZWQ6ICVzKSBhZ2VudFJlbW92ZScsXG4gICAgICBzb2NrZXRbU09DS0VUX05BTUVdLFxuICAgICAgc29ja2V0W1NPQ0tFVF9SRVFVRVNUX0NPVU5UXSwgc29ja2V0W1NPQ0tFVF9SRVFVRVNUX0ZJTklTSEVEX0NPVU5UXSk7XG4gICAgLy8gV2UgbmVlZCB0aGlzIGZ1bmN0aW9uIGZvciBjYXNlcyBsaWtlIEhUVFAgJ3VwZ3JhZGUnXG4gICAgLy8gKGRlZmluZWQgYnkgV2ViU29ja2V0cykgd2hlcmUgd2UgbmVlZCB0byByZW1vdmUgYSBzb2NrZXQgZnJvbSB0aGVcbiAgICAvLyBwb29sIGJlY2F1c2UgaXQnbGwgYmUgbG9ja2VkIHVwIGluZGVmaW5pdGVseVxuICAgIHNvY2tldC5yZW1vdmVMaXN0ZW5lcignY2xvc2UnLCBvbkNsb3NlKTtcbiAgICBzb2NrZXQucmVtb3ZlTGlzdGVuZXIoJ2Vycm9yJywgb25FcnJvcik7XG4gICAgc29ja2V0LnJlbW92ZUxpc3RlbmVyKCdmcmVlJywgb25GcmVlKTtcbiAgICBzb2NrZXQucmVtb3ZlTGlzdGVuZXIoJ3RpbWVvdXQnLCBvblRpbWVvdXQpO1xuICAgIHNvY2tldC5yZW1vdmVMaXN0ZW5lcignYWdlbnRSZW1vdmUnLCBvblJlbW92ZSk7XG4gIH1cbiAgc29ja2V0Lm9uKCdhZ2VudFJlbW92ZScsIG9uUmVtb3ZlKTtcbn1cblxudmFyIGFnZW50ID0gQWdlbnQ7XG5cbmZ1bmN0aW9uIGluc3BlY3Qob2JqKSB7XG4gIGNvbnN0IHJlcyA9IHt9O1xuICBmb3IgKGNvbnN0IGtleSBpbiBvYmopIHtcbiAgICByZXNba2V5XSA9IG9ialtrZXldLmxlbmd0aDtcbiAgfVxuICByZXR1cm4gcmVzO1xufVxuXG5jb25zdCBPcmlnaW5hbEh0dHBzQWdlbnQgPSByZXF1aXJlJCQwJDIuQWdlbnQ7XG5jb25zdCBIdHRwQWdlbnQgPSBhZ2VudDtcbmNvbnN0IHtcbiAgSU5JVF9TT0NLRVQsXG4gIENSRUFURV9IVFRQU19DT05ORUNUSU9OLFxufSA9IGNvbnN0YW50cztcblxubGV0IEh0dHBzQWdlbnQkMSA9IGNsYXNzIEh0dHBzQWdlbnQgZXh0ZW5kcyBIdHRwQWdlbnQge1xuICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgc3VwZXIob3B0aW9ucyk7XG5cbiAgICB0aGlzLmRlZmF1bHRQb3J0ID0gNDQzO1xuICAgIHRoaXMucHJvdG9jb2wgPSAnaHR0cHM6JztcbiAgICB0aGlzLm1heENhY2hlZFNlc3Npb25zID0gdGhpcy5vcHRpb25zLm1heENhY2hlZFNlc3Npb25zO1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgaWYgKHRoaXMubWF4Q2FjaGVkU2Vzc2lvbnMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhpcy5tYXhDYWNoZWRTZXNzaW9ucyA9IDEwMDtcbiAgICB9XG5cbiAgICB0aGlzLl9zZXNzaW9uQ2FjaGUgPSB7XG4gICAgICBtYXA6IHt9LFxuICAgICAgbGlzdDogW10sXG4gICAgfTtcbiAgfVxuXG4gIGNyZWF0ZUNvbm5lY3Rpb24ob3B0aW9ucywgb25jcmVhdGUpIHtcbiAgICBjb25zdCBzb2NrZXQgPSB0aGlzW0NSRUFURV9IVFRQU19DT05ORUNUSU9OXShvcHRpb25zLCBvbmNyZWF0ZSk7XG4gICAgdGhpc1tJTklUX1NPQ0tFVF0oc29ja2V0LCBvcHRpb25zKTtcbiAgICByZXR1cm4gc29ja2V0O1xuICB9XG59O1xuXG4vLyBodHRwczovL2dpdGh1Yi5jb20vbm9kZWpzL25vZGUvYmxvYi9tYXN0ZXIvbGliL2h0dHBzLmpzI0w4OVxuSHR0cHNBZ2VudCQxLnByb3RvdHlwZVtDUkVBVEVfSFRUUFNfQ09OTkVDVElPTl0gPSBPcmlnaW5hbEh0dHBzQWdlbnQucHJvdG90eXBlLmNyZWF0ZUNvbm5lY3Rpb247XG5cbltcbiAgJ2dldE5hbWUnLFxuICAnX2dldFNlc3Npb24nLFxuICAnX2NhY2hlU2Vzc2lvbicsXG4gIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9ub2RlanMvbm9kZS9wdWxsLzQ5ODJcbiAgJ19ldmljdFNlc3Npb24nLFxuXS5mb3JFYWNoKGZ1bmN0aW9uKG1ldGhvZCkge1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICBpZiAodHlwZW9mIE9yaWdpbmFsSHR0cHNBZ2VudC5wcm90b3R5cGVbbWV0aG9kXSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIEh0dHBzQWdlbnQkMS5wcm90b3R5cGVbbWV0aG9kXSA9IE9yaWdpbmFsSHR0cHNBZ2VudC5wcm90b3R5cGVbbWV0aG9kXTtcbiAgfVxufSk7XG5cbnZhciBodHRwc19hZ2VudCA9IEh0dHBzQWdlbnQkMTtcblxuYWdlbnRrZWVwYWxpdmUuZXhwb3J0cyA9IGFnZW50O1xudmFyIEh0dHBzQWdlbnQgPSBhZ2VudGtlZXBhbGl2ZS5leHBvcnRzLkh0dHBzQWdlbnQgPSBodHRwc19hZ2VudDtcbmFnZW50a2VlcGFsaXZlLmV4cG9ydHMuY29uc3RhbnRzID0gY29uc3RhbnRzO1xuXG52YXIgYWdlbnRrZWVwYWxpdmVFeHBvcnRzID0gYWdlbnRrZWVwYWxpdmUuZXhwb3J0cztcbnZhciBIdHRwS2VlcEFsaXZlQWdlbnQgPSAvKkBfX1BVUkVfXyovZ2V0RGVmYXVsdEV4cG9ydEZyb21DanMoYWdlbnRrZWVwYWxpdmVFeHBvcnRzKTtcblxudmFyIG9ialRvU3RyaW5nID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZztcbnZhciBvYmpLZXlzID0gT2JqZWN0LmtleXMgfHwgZnVuY3Rpb24ob2JqKSB7XG5cdFx0dmFyIGtleXMgPSBbXTtcblx0XHRmb3IgKHZhciBuYW1lIGluIG9iaikge1xuXHRcdFx0a2V5cy5wdXNoKG5hbWUpO1xuXHRcdH1cblx0XHRyZXR1cm4ga2V5cztcblx0fTtcblxuZnVuY3Rpb24gc3RyaW5naWZ5KHZhbCwgaXNBcnJheVByb3ApIHtcblx0dmFyIGksIG1heCwgc3RyLCBrZXlzLCBrZXksIHByb3BWYWwsIHRvU3RyO1xuXHRpZiAodmFsID09PSB0cnVlKSB7XG5cdFx0cmV0dXJuIFwidHJ1ZVwiO1xuXHR9XG5cdGlmICh2YWwgPT09IGZhbHNlKSB7XG5cdFx0cmV0dXJuIFwiZmFsc2VcIjtcblx0fVxuXHRzd2l0Y2ggKHR5cGVvZiB2YWwpIHtcblx0XHRjYXNlIFwib2JqZWN0XCI6XG5cdFx0XHRpZiAodmFsID09PSBudWxsKSB7XG5cdFx0XHRcdHJldHVybiBudWxsO1xuXHRcdFx0fSBlbHNlIGlmICh2YWwudG9KU09OICYmIHR5cGVvZiB2YWwudG9KU09OID09PSBcImZ1bmN0aW9uXCIpIHtcblx0XHRcdFx0cmV0dXJuIHN0cmluZ2lmeSh2YWwudG9KU09OKCksIGlzQXJyYXlQcm9wKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHRvU3RyID0gb2JqVG9TdHJpbmcuY2FsbCh2YWwpO1xuXHRcdFx0XHRpZiAodG9TdHIgPT09IFwiW29iamVjdCBBcnJheV1cIikge1xuXHRcdFx0XHRcdHN0ciA9ICdbJztcblx0XHRcdFx0XHRtYXggPSB2YWwubGVuZ3RoIC0gMTtcblx0XHRcdFx0XHRmb3IoaSA9IDA7IGkgPCBtYXg7IGkrKykge1xuXHRcdFx0XHRcdFx0c3RyICs9IHN0cmluZ2lmeSh2YWxbaV0sIHRydWUpICsgJywnO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZiAobWF4ID4gLTEpIHtcblx0XHRcdFx0XHRcdHN0ciArPSBzdHJpbmdpZnkodmFsW2ldLCB0cnVlKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cmV0dXJuIHN0ciArICddJztcblx0XHRcdFx0fSBlbHNlIGlmICh0b1N0ciA9PT0gXCJbb2JqZWN0IE9iamVjdF1cIikge1xuXHRcdFx0XHRcdC8vIG9ubHkgb2JqZWN0IGlzIGxlZnRcblx0XHRcdFx0XHRrZXlzID0gb2JqS2V5cyh2YWwpLnNvcnQoKTtcblx0XHRcdFx0XHRtYXggPSBrZXlzLmxlbmd0aDtcblx0XHRcdFx0XHRzdHIgPSBcIlwiO1xuXHRcdFx0XHRcdGkgPSAwO1xuXHRcdFx0XHRcdHdoaWxlIChpIDwgbWF4KSB7XG5cdFx0XHRcdFx0XHRrZXkgPSBrZXlzW2ldO1xuXHRcdFx0XHRcdFx0cHJvcFZhbCA9IHN0cmluZ2lmeSh2YWxba2V5XSwgZmFsc2UpO1xuXHRcdFx0XHRcdFx0aWYgKHByb3BWYWwgIT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHRcdFx0XHRpZiAoc3RyKSB7XG5cdFx0XHRcdFx0XHRcdFx0c3RyICs9ICcsJztcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRzdHIgKz0gSlNPTi5zdHJpbmdpZnkoa2V5KSArICc6JyArIHByb3BWYWw7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRpKys7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHJldHVybiAneycgKyBzdHIgKyAnfSc7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0cmV0dXJuIEpTT04uc3RyaW5naWZ5KHZhbCk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRjYXNlIFwiZnVuY3Rpb25cIjpcblx0XHRjYXNlIFwidW5kZWZpbmVkXCI6XG5cdFx0XHRyZXR1cm4gaXNBcnJheVByb3AgPyBudWxsIDogdW5kZWZpbmVkO1xuXHRcdGNhc2UgXCJzdHJpbmdcIjpcblx0XHRcdHJldHVybiBKU09OLnN0cmluZ2lmeSh2YWwpO1xuXHRcdGRlZmF1bHQ6XG5cdFx0XHRyZXR1cm4gaXNGaW5pdGUodmFsKSA/IHZhbCA6IG51bGw7XG5cdH1cbn1cblxudmFyIGZhc3RTdGFibGVTdHJpbmdpZnkgPSBmdW5jdGlvbih2YWwpIHtcblx0dmFyIHJldHVyblZhbCA9IHN0cmluZ2lmeSh2YWwsIGZhbHNlKTtcblx0aWYgKHJldHVyblZhbCAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0cmV0dXJuICcnKyByZXR1cm5WYWw7XG5cdH1cbn07XG5cbnZhciBmYXN0U3RhYmxlU3RyaW5naWZ5JDEgPSAvKkBfX1BVUkVfXyovZ2V0RGVmYXVsdEV4cG9ydEZyb21DanMoZmFzdFN0YWJsZVN0cmluZ2lmeSk7XG5cbmNvbnN0IE1JTklNVU1fU0xPVF9QRVJfRVBPQ0ggPSAzMjtcblxuLy8gUmV0dXJucyB0aGUgbnVtYmVyIG9mIHRyYWlsaW5nIHplcm9zIGluIHRoZSBiaW5hcnkgcmVwcmVzZW50YXRpb24gb2Ygc2VsZi5cbmZ1bmN0aW9uIHRyYWlsaW5nWmVyb3Mobikge1xuICBsZXQgdHJhaWxpbmdaZXJvcyA9IDA7XG4gIHdoaWxlIChuID4gMSkge1xuICAgIG4gLz0gMjtcbiAgICB0cmFpbGluZ1plcm9zKys7XG4gIH1cbiAgcmV0dXJuIHRyYWlsaW5nWmVyb3M7XG59XG5cbi8vIFJldHVybnMgdGhlIHNtYWxsZXN0IHBvd2VyIG9mIHR3byBncmVhdGVyIHRoYW4gb3IgZXF1YWwgdG8gblxuZnVuY3Rpb24gbmV4dFBvd2VyT2ZUd28obikge1xuICBpZiAobiA9PT0gMCkgcmV0dXJuIDE7XG4gIG4tLTtcbiAgbiB8PSBuID4+IDE7XG4gIG4gfD0gbiA+PiAyO1xuICBuIHw9IG4gPj4gNDtcbiAgbiB8PSBuID4+IDg7XG4gIG4gfD0gbiA+PiAxNjtcbiAgbiB8PSBuID4+IDMyO1xuICByZXR1cm4gbiArIDE7XG59XG5cbi8qKlxuICogRXBvY2ggc2NoZWR1bGVcbiAqIChzZWUgaHR0cHM6Ly9kb2NzLnNvbGFuYS5jb20vdGVybWlub2xvZ3kjZXBvY2gpXG4gKiBDYW4gYmUgcmV0cmlldmVkIHdpdGggdGhlIHtAbGluayBDb25uZWN0aW9uLmdldEVwb2NoU2NoZWR1bGV9IG1ldGhvZFxuICovXG5jbGFzcyBFcG9jaFNjaGVkdWxlIHtcbiAgY29uc3RydWN0b3Ioc2xvdHNQZXJFcG9jaCwgbGVhZGVyU2NoZWR1bGVTbG90T2Zmc2V0LCB3YXJtdXAsIGZpcnN0Tm9ybWFsRXBvY2gsIGZpcnN0Tm9ybWFsU2xvdCkge1xuICAgIC8qKiBUaGUgbWF4aW11bSBudW1iZXIgb2Ygc2xvdHMgaW4gZWFjaCBlcG9jaCAqL1xuICAgIHRoaXMuc2xvdHNQZXJFcG9jaCA9IHZvaWQgMDtcbiAgICAvKiogVGhlIG51bWJlciBvZiBzbG90cyBiZWZvcmUgYmVnaW5uaW5nIG9mIGFuIGVwb2NoIHRvIGNhbGN1bGF0ZSBhIGxlYWRlciBzY2hlZHVsZSBmb3IgdGhhdCBlcG9jaCAqL1xuICAgIHRoaXMubGVhZGVyU2NoZWR1bGVTbG90T2Zmc2V0ID0gdm9pZCAwO1xuICAgIC8qKiBJbmRpY2F0ZXMgd2hldGhlciBlcG9jaHMgc3RhcnQgc2hvcnQgYW5kIGdyb3cgKi9cbiAgICB0aGlzLndhcm11cCA9IHZvaWQgMDtcbiAgICAvKiogVGhlIGZpcnN0IGVwb2NoIHdpdGggYHNsb3RzUGVyRXBvY2hgIHNsb3RzICovXG4gICAgdGhpcy5maXJzdE5vcm1hbEVwb2NoID0gdm9pZCAwO1xuICAgIC8qKiBUaGUgZmlyc3Qgc2xvdCBvZiBgZmlyc3ROb3JtYWxFcG9jaGAgKi9cbiAgICB0aGlzLmZpcnN0Tm9ybWFsU2xvdCA9IHZvaWQgMDtcbiAgICB0aGlzLnNsb3RzUGVyRXBvY2ggPSBzbG90c1BlckVwb2NoO1xuICAgIHRoaXMubGVhZGVyU2NoZWR1bGVTbG90T2Zmc2V0ID0gbGVhZGVyU2NoZWR1bGVTbG90T2Zmc2V0O1xuICAgIHRoaXMud2FybXVwID0gd2FybXVwO1xuICAgIHRoaXMuZmlyc3ROb3JtYWxFcG9jaCA9IGZpcnN0Tm9ybWFsRXBvY2g7XG4gICAgdGhpcy5maXJzdE5vcm1hbFNsb3QgPSBmaXJzdE5vcm1hbFNsb3Q7XG4gIH1cbiAgZ2V0RXBvY2goc2xvdCkge1xuICAgIHJldHVybiB0aGlzLmdldEVwb2NoQW5kU2xvdEluZGV4KHNsb3QpWzBdO1xuICB9XG4gIGdldEVwb2NoQW5kU2xvdEluZGV4KHNsb3QpIHtcbiAgICBpZiAoc2xvdCA8IHRoaXMuZmlyc3ROb3JtYWxTbG90KSB7XG4gICAgICBjb25zdCBlcG9jaCA9IHRyYWlsaW5nWmVyb3MobmV4dFBvd2VyT2ZUd28oc2xvdCArIE1JTklNVU1fU0xPVF9QRVJfRVBPQ0ggKyAxKSkgLSB0cmFpbGluZ1plcm9zKE1JTklNVU1fU0xPVF9QRVJfRVBPQ0gpIC0gMTtcbiAgICAgIGNvbnN0IGVwb2NoTGVuID0gdGhpcy5nZXRTbG90c0luRXBvY2goZXBvY2gpO1xuICAgICAgY29uc3Qgc2xvdEluZGV4ID0gc2xvdCAtIChlcG9jaExlbiAtIE1JTklNVU1fU0xPVF9QRVJfRVBPQ0gpO1xuICAgICAgcmV0dXJuIFtlcG9jaCwgc2xvdEluZGV4XTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3Qgbm9ybWFsU2xvdEluZGV4ID0gc2xvdCAtIHRoaXMuZmlyc3ROb3JtYWxTbG90O1xuICAgICAgY29uc3Qgbm9ybWFsRXBvY2hJbmRleCA9IE1hdGguZmxvb3Iobm9ybWFsU2xvdEluZGV4IC8gdGhpcy5zbG90c1BlckVwb2NoKTtcbiAgICAgIGNvbnN0IGVwb2NoID0gdGhpcy5maXJzdE5vcm1hbEVwb2NoICsgbm9ybWFsRXBvY2hJbmRleDtcbiAgICAgIGNvbnN0IHNsb3RJbmRleCA9IG5vcm1hbFNsb3RJbmRleCAlIHRoaXMuc2xvdHNQZXJFcG9jaDtcbiAgICAgIHJldHVybiBbZXBvY2gsIHNsb3RJbmRleF07XG4gICAgfVxuICB9XG4gIGdldEZpcnN0U2xvdEluRXBvY2goZXBvY2gpIHtcbiAgICBpZiAoZXBvY2ggPD0gdGhpcy5maXJzdE5vcm1hbEVwb2NoKSB7XG4gICAgICByZXR1cm4gKE1hdGgucG93KDIsIGVwb2NoKSAtIDEpICogTUlOSU1VTV9TTE9UX1BFUl9FUE9DSDtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIChlcG9jaCAtIHRoaXMuZmlyc3ROb3JtYWxFcG9jaCkgKiB0aGlzLnNsb3RzUGVyRXBvY2ggKyB0aGlzLmZpcnN0Tm9ybWFsU2xvdDtcbiAgICB9XG4gIH1cbiAgZ2V0TGFzdFNsb3RJbkVwb2NoKGVwb2NoKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0Rmlyc3RTbG90SW5FcG9jaChlcG9jaCkgKyB0aGlzLmdldFNsb3RzSW5FcG9jaChlcG9jaCkgLSAxO1xuICB9XG4gIGdldFNsb3RzSW5FcG9jaChlcG9jaCkge1xuICAgIGlmIChlcG9jaCA8IHRoaXMuZmlyc3ROb3JtYWxFcG9jaCkge1xuICAgICAgcmV0dXJuIE1hdGgucG93KDIsIGVwb2NoICsgdHJhaWxpbmdaZXJvcyhNSU5JTVVNX1NMT1RfUEVSX0VQT0NIKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB0aGlzLnNsb3RzUGVyRXBvY2g7XG4gICAgfVxuICB9XG59XG5cbmNsYXNzIFNlbmRUcmFuc2FjdGlvbkVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICBjb25zdHJ1Y3RvcihtZXNzYWdlLCBsb2dzKSB7XG4gICAgc3VwZXIobWVzc2FnZSk7XG4gICAgdGhpcy5sb2dzID0gdm9pZCAwO1xuICAgIHRoaXMubG9ncyA9IGxvZ3M7XG4gIH1cbn1cblxuLy8gS2VlcCBpbiBzeW5jIHdpdGggY2xpZW50L3NyYy9ycGNfY3VzdG9tX2Vycm9ycy5yc1xuLy8gVHlwZXNjcmlwdCBgZW51bXNgIHRod2FydCB0cmVlLXNoYWtpbmcuIFNlZSBodHRwczovL2JhcmdzdGVuLm9yZy9qc3RzL2VudW1zL1xuY29uc3QgU29sYW5hSlNPTlJQQ0Vycm9yQ29kZSA9IHtcbiAgSlNPTl9SUENfU0VSVkVSX0VSUk9SX0JMT0NLX0NMRUFORURfVVA6IC0zMjAwMSxcbiAgSlNPTl9SUENfU0VSVkVSX0VSUk9SX1NFTkRfVFJBTlNBQ1RJT05fUFJFRkxJR0hUX0ZBSUxVUkU6IC0zMjAwMixcbiAgSlNPTl9SUENfU0VSVkVSX0VSUk9SX1RSQU5TQUNUSU9OX1NJR05BVFVSRV9WRVJJRklDQVRJT05fRkFJTFVSRTogLTMyMDAzLFxuICBKU09OX1JQQ19TRVJWRVJfRVJST1JfQkxPQ0tfTk9UX0FWQUlMQUJMRTogLTMyMDA0LFxuICBKU09OX1JQQ19TRVJWRVJfRVJST1JfTk9ERV9VTkhFQUxUSFk6IC0zMjAwNSxcbiAgSlNPTl9SUENfU0VSVkVSX0VSUk9SX1RSQU5TQUNUSU9OX1BSRUNPTVBJTEVfVkVSSUZJQ0FUSU9OX0ZBSUxVUkU6IC0zMjAwNixcbiAgSlNPTl9SUENfU0VSVkVSX0VSUk9SX1NMT1RfU0tJUFBFRDogLTMyMDA3LFxuICBKU09OX1JQQ19TRVJWRVJfRVJST1JfTk9fU05BUFNIT1Q6IC0zMjAwOCxcbiAgSlNPTl9SUENfU0VSVkVSX0VSUk9SX0xPTkdfVEVSTV9TVE9SQUdFX1NMT1RfU0tJUFBFRDogLTMyMDA5LFxuICBKU09OX1JQQ19TRVJWRVJfRVJST1JfS0VZX0VYQ0xVREVEX0ZST01fU0VDT05EQVJZX0lOREVYOiAtMzIwMTAsXG4gIEpTT05fUlBDX1NFUlZFUl9FUlJPUl9UUkFOU0FDVElPTl9ISVNUT1JZX05PVF9BVkFJTEFCTEU6IC0zMjAxMSxcbiAgSlNPTl9SUENfU0NBTl9FUlJPUjogLTMyMDEyLFxuICBKU09OX1JQQ19TRVJWRVJfRVJST1JfVFJBTlNBQ1RJT05fU0lHTkFUVVJFX0xFTl9NSVNNQVRDSDogLTMyMDEzLFxuICBKU09OX1JQQ19TRVJWRVJfRVJST1JfQkxPQ0tfU1RBVFVTX05PVF9BVkFJTEFCTEVfWUVUOiAtMzIwMTQsXG4gIEpTT05fUlBDX1NFUlZFUl9FUlJPUl9VTlNVUFBPUlRFRF9UUkFOU0FDVElPTl9WRVJTSU9OOiAtMzIwMTUsXG4gIEpTT05fUlBDX1NFUlZFUl9FUlJPUl9NSU5fQ09OVEVYVF9TTE9UX05PVF9SRUFDSEVEOiAtMzIwMTZcbn07XG5jbGFzcyBTb2xhbmFKU09OUlBDRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gIGNvbnN0cnVjdG9yKHtcbiAgICBjb2RlLFxuICAgIG1lc3NhZ2UsXG4gICAgZGF0YVxuICB9LCBjdXN0b21NZXNzYWdlKSB7XG4gICAgc3VwZXIoY3VzdG9tTWVzc2FnZSAhPSBudWxsID8gYCR7Y3VzdG9tTWVzc2FnZX06ICR7bWVzc2FnZX1gIDogbWVzc2FnZSk7XG4gICAgdGhpcy5jb2RlID0gdm9pZCAwO1xuICAgIHRoaXMuZGF0YSA9IHZvaWQgMDtcbiAgICB0aGlzLmNvZGUgPSBjb2RlO1xuICAgIHRoaXMuZGF0YSA9IGRhdGE7XG4gICAgdGhpcy5uYW1lID0gJ1NvbGFuYUpTT05SUENFcnJvcic7XG4gIH1cbn1cblxudmFyIGZldGNoSW1wbCA9IHR5cGVvZiBnbG9iYWxUaGlzLmZldGNoID09PSAnZnVuY3Rpb24nID9cbi8vIFRoZSBGZXRjaCBBUEkgaXMgc3VwcG9ydGVkIGV4cGVyaW1lbnRhbGx5IGluIE5vZGUgMTcuNSsgYW5kIG5hdGl2ZWx5IGluIE5vZGUgMTgrLlxuZ2xvYmFsVGhpcy5mZXRjaCA6XG4vLyBPdGhlcndpc2UgdXNlIHRoZSBwb2x5ZmlsbC5cbmFzeW5jIGZ1bmN0aW9uIChpbnB1dCwgaW5pdCkge1xuICBjb25zdCBwcm9jZXNzZWRJbnB1dCA9IHR5cGVvZiBpbnB1dCA9PT0gJ3N0cmluZycgJiYgaW5wdXQuc2xpY2UoMCwgMikgPT09ICcvLycgPyAnaHR0cHM6JyArIGlucHV0IDogaW5wdXQ7XG4gIHJldHVybiBhd2FpdCBub2RlRmV0Y2guZGVmYXVsdChwcm9jZXNzZWRJbnB1dCwgaW5pdCk7XG59O1xuXG5jbGFzcyBScGNXZWJTb2NrZXRDbGllbnQgZXh0ZW5kcyBScGNXZWJTb2NrZXRDb21tb25DbGllbnQge1xuICBjb25zdHJ1Y3RvcihhZGRyZXNzLCBvcHRpb25zLCBnZW5lcmF0ZV9yZXF1ZXN0X2lkKSB7XG4gICAgY29uc3Qgd2ViU29ja2V0RmFjdG9yeSA9IHVybCA9PiB7XG4gICAgICBjb25zdCBycGMgPSBXZWJzb2NrZXRGYWN0b3J5KHVybCwge1xuICAgICAgICBhdXRvY29ubmVjdDogdHJ1ZSxcbiAgICAgICAgbWF4X3JlY29ubmVjdHM6IDUsXG4gICAgICAgIHJlY29ubmVjdDogdHJ1ZSxcbiAgICAgICAgcmVjb25uZWN0X2ludGVydmFsOiAxMDAwLFxuICAgICAgICAuLi5vcHRpb25zXG4gICAgICB9KTtcbiAgICAgIGlmICgnc29ja2V0JyBpbiBycGMpIHtcbiAgICAgICAgdGhpcy51bmRlcmx5aW5nU29ja2V0ID0gcnBjLnNvY2tldDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMudW5kZXJseWluZ1NvY2tldCA9IHJwYztcbiAgICAgIH1cbiAgICAgIHJldHVybiBycGM7XG4gICAgfTtcbiAgICBzdXBlcih3ZWJTb2NrZXRGYWN0b3J5LCBhZGRyZXNzLCBvcHRpb25zLCBnZW5lcmF0ZV9yZXF1ZXN0X2lkKTtcbiAgICB0aGlzLnVuZGVybHlpbmdTb2NrZXQgPSB2b2lkIDA7XG4gIH1cbiAgY2FsbCguLi5hcmdzKSB7XG4gICAgY29uc3QgcmVhZHlTdGF0ZSA9IHRoaXMudW5kZXJseWluZ1NvY2tldD8ucmVhZHlTdGF0ZTtcbiAgICBpZiAocmVhZHlTdGF0ZSA9PT0gMSAvKiBXZWJTb2NrZXQuT1BFTiAqLykge1xuICAgICAgcmV0dXJuIHN1cGVyLmNhbGwoLi4uYXJncyk7XG4gICAgfVxuICAgIHJldHVybiBQcm9taXNlLnJlamVjdChuZXcgRXJyb3IoJ1RyaWVkIHRvIGNhbGwgYSBKU09OLVJQQyBtZXRob2QgYCcgKyBhcmdzWzBdICsgJ2AgYnV0IHRoZSBzb2NrZXQgd2FzIG5vdCBgQ09OTkVDVElOR2Agb3IgYE9QRU5gIChgcmVhZHlTdGF0ZWAgd2FzICcgKyByZWFkeVN0YXRlICsgJyknKSk7XG4gIH1cbiAgbm90aWZ5KC4uLmFyZ3MpIHtcbiAgICBjb25zdCByZWFkeVN0YXRlID0gdGhpcy51bmRlcmx5aW5nU29ja2V0Py5yZWFkeVN0YXRlO1xuICAgIGlmIChyZWFkeVN0YXRlID09PSAxIC8qIFdlYlNvY2tldC5PUEVOICovKSB7XG4gICAgICByZXR1cm4gc3VwZXIubm90aWZ5KC4uLmFyZ3MpO1xuICAgIH1cbiAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QobmV3IEVycm9yKCdUcmllZCB0byBzZW5kIGEgSlNPTi1SUEMgbm90aWZpY2F0aW9uIGAnICsgYXJnc1swXSArICdgIGJ1dCB0aGUgc29ja2V0IHdhcyBub3QgYENPTk5FQ1RJTkdgIG9yIGBPUEVOYCAoYHJlYWR5U3RhdGVgIHdhcyAnICsgcmVhZHlTdGF0ZSArICcpJykpO1xuICB9XG59XG5cbi8qKlxuICogQGludGVybmFsXG4gKi9cblxuLyoqXG4gKiBEZWNvZGUgYWNjb3VudCBkYXRhIGJ1ZmZlciB1c2luZyBhbiBBY2NvdW50VHlwZVxuICogQGludGVybmFsXG4gKi9cbmZ1bmN0aW9uIGRlY29kZURhdGEodHlwZSwgZGF0YSkge1xuICBsZXQgZGVjb2RlZDtcbiAgdHJ5IHtcbiAgICBkZWNvZGVkID0gdHlwZS5sYXlvdXQuZGVjb2RlKGRhdGEpO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgaW5zdHJ1Y3Rpb247ICcgKyBlcnIpO1xuICB9XG4gIGlmIChkZWNvZGVkLnR5cGVJbmRleCAhPT0gdHlwZS5pbmRleCkge1xuICAgIHRocm93IG5ldyBFcnJvcihgaW52YWxpZCBhY2NvdW50IGRhdGE7IGFjY291bnQgdHlwZSBtaXNtYXRjaCAke2RlY29kZWQudHlwZUluZGV4fSAhPSAke3R5cGUuaW5kZXh9YCk7XG4gIH1cbiAgcmV0dXJuIGRlY29kZWQ7XG59XG5cbi8vLyBUaGUgc2VyaWFsaXplZCBzaXplIG9mIGxvb2t1cCB0YWJsZSBtZXRhZGF0YVxuY29uc3QgTE9PS1VQX1RBQkxFX01FVEFfU0laRSA9IDU2O1xuY2xhc3MgQWRkcmVzc0xvb2t1cFRhYmxlQWNjb3VudCB7XG4gIGNvbnN0cnVjdG9yKGFyZ3MpIHtcbiAgICB0aGlzLmtleSA9IHZvaWQgMDtcbiAgICB0aGlzLnN0YXRlID0gdm9pZCAwO1xuICAgIHRoaXMua2V5ID0gYXJncy5rZXk7XG4gICAgdGhpcy5zdGF0ZSA9IGFyZ3Muc3RhdGU7XG4gIH1cbiAgaXNBY3RpdmUoKSB7XG4gICAgY29uc3QgVTY0X01BWCA9IEJpZ0ludCgnMHhmZmZmZmZmZmZmZmZmZmZmJyk7XG4gICAgcmV0dXJuIHRoaXMuc3RhdGUuZGVhY3RpdmF0aW9uU2xvdCA9PT0gVTY0X01BWDtcbiAgfVxuICBzdGF0aWMgZGVzZXJpYWxpemUoYWNjb3VudERhdGEpIHtcbiAgICBjb25zdCBtZXRhID0gZGVjb2RlRGF0YShMb29rdXBUYWJsZU1ldGFMYXlvdXQsIGFjY291bnREYXRhKTtcbiAgICBjb25zdCBzZXJpYWxpemVkQWRkcmVzc2VzTGVuID0gYWNjb3VudERhdGEubGVuZ3RoIC0gTE9PS1VQX1RBQkxFX01FVEFfU0laRTtcbiAgICBhc3NlcnQoc2VyaWFsaXplZEFkZHJlc3Nlc0xlbiA+PSAwLCAnbG9va3VwIHRhYmxlIGlzIGludmFsaWQnKTtcbiAgICBhc3NlcnQoc2VyaWFsaXplZEFkZHJlc3Nlc0xlbiAlIDMyID09PSAwLCAnbG9va3VwIHRhYmxlIGlzIGludmFsaWQnKTtcbiAgICBjb25zdCBudW1TZXJpYWxpemVkQWRkcmVzc2VzID0gc2VyaWFsaXplZEFkZHJlc3Nlc0xlbiAvIDMyO1xuICAgIGNvbnN0IHtcbiAgICAgIGFkZHJlc3Nlc1xuICAgIH0gPSBCdWZmZXJMYXlvdXQuc3RydWN0KFtCdWZmZXJMYXlvdXQuc2VxKHB1YmxpY0tleSgpLCBudW1TZXJpYWxpemVkQWRkcmVzc2VzLCAnYWRkcmVzc2VzJyldKS5kZWNvZGUoYWNjb3VudERhdGEuc2xpY2UoTE9PS1VQX1RBQkxFX01FVEFfU0laRSkpO1xuICAgIHJldHVybiB7XG4gICAgICBkZWFjdGl2YXRpb25TbG90OiBtZXRhLmRlYWN0aXZhdGlvblNsb3QsXG4gICAgICBsYXN0RXh0ZW5kZWRTbG90OiBtZXRhLmxhc3RFeHRlbmRlZFNsb3QsXG4gICAgICBsYXN0RXh0ZW5kZWRTbG90U3RhcnRJbmRleDogbWV0YS5sYXN0RXh0ZW5kZWRTdGFydEluZGV4LFxuICAgICAgYXV0aG9yaXR5OiBtZXRhLmF1dGhvcml0eS5sZW5ndGggIT09IDAgPyBuZXcgUHVibGljS2V5KG1ldGEuYXV0aG9yaXR5WzBdKSA6IHVuZGVmaW5lZCxcbiAgICAgIGFkZHJlc3NlczogYWRkcmVzc2VzLm1hcChhZGRyZXNzID0+IG5ldyBQdWJsaWNLZXkoYWRkcmVzcykpXG4gICAgfTtcbiAgfVxufVxuY29uc3QgTG9va3VwVGFibGVNZXRhTGF5b3V0ID0ge1xuICBpbmRleDogMSxcbiAgbGF5b3V0OiBCdWZmZXJMYXlvdXQuc3RydWN0KFtCdWZmZXJMYXlvdXQudTMyKCd0eXBlSW5kZXgnKSwgdTY0KCdkZWFjdGl2YXRpb25TbG90JyksIEJ1ZmZlckxheW91dC5udTY0KCdsYXN0RXh0ZW5kZWRTbG90JyksIEJ1ZmZlckxheW91dC51OCgnbGFzdEV4dGVuZGVkU3RhcnRJbmRleCcpLCBCdWZmZXJMYXlvdXQudTgoKSxcbiAgLy8gb3B0aW9uXG4gIEJ1ZmZlckxheW91dC5zZXEocHVibGljS2V5KCksIEJ1ZmZlckxheW91dC5vZmZzZXQoQnVmZmVyTGF5b3V0LnU4KCksIC0xKSwgJ2F1dGhvcml0eScpXSlcbn07XG5cbmNvbnN0IFVSTF9SRSA9IC9eW146XSs6XFwvXFwvKFteOltdK3xcXFtbXlxcXV0rXFxdKSg6XFxkKyk/KC4qKS9pO1xuZnVuY3Rpb24gbWFrZVdlYnNvY2tldFVybChlbmRwb2ludCkge1xuICBjb25zdCBtYXRjaGVzID0gZW5kcG9pbnQubWF0Y2goVVJMX1JFKTtcbiAgaWYgKG1hdGNoZXMgPT0gbnVsbCkge1xuICAgIHRocm93IFR5cGVFcnJvcihgRmFpbGVkIHRvIHZhbGlkYXRlIGVuZHBvaW50IFVSTCBcXGAke2VuZHBvaW50fVxcYGApO1xuICB9XG4gIGNvbnN0IFtfLFxuICAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnVzZWQtdmFyc1xuICBob3N0aXNoLCBwb3J0V2l0aENvbG9uLCByZXN0XSA9IG1hdGNoZXM7XG4gIGNvbnN0IHByb3RvY29sID0gZW5kcG9pbnQuc3RhcnRzV2l0aCgnaHR0cHM6JykgPyAnd3NzOicgOiAnd3M6JztcbiAgY29uc3Qgc3RhcnRQb3J0ID0gcG9ydFdpdGhDb2xvbiA9PSBudWxsID8gbnVsbCA6IHBhcnNlSW50KHBvcnRXaXRoQ29sb24uc2xpY2UoMSksIDEwKTtcbiAgY29uc3Qgd2Vic29ja2V0UG9ydCA9XG4gIC8vIE9ubHkgc2hpZnQgdGhlIHBvcnQgYnkgKzEgYXMgYSBjb252ZW50aW9uIGZvciB3cyhzKSBvbmx5IGlmIGdpdmVuIGVuZHBvaW50XG4gIC8vIGlzIGV4cGxpY2l0bHkgc3BlY2lmeWluZyB0aGUgZW5kcG9pbnQgcG9ydCAoSFRUUC1iYXNlZCBSUEMpLCBhc3N1bWluZ1xuICAvLyB3ZSdyZSBkaXJlY3RseSB0cnlpbmcgdG8gY29ubmVjdCB0byBhZ2F2ZS12YWxpZGF0b3IncyB3cyBsaXN0ZW5pbmcgcG9ydC5cbiAgLy8gV2hlbiB0aGUgZW5kcG9pbnQgb21pdHMgdGhlIHBvcnQsIHdlJ3JlIGNvbm5lY3RpbmcgdG8gdGhlIHByb3RvY29sXG4gIC8vIGRlZmF1bHQgcG9ydHM6IGh0dHAoODApIG9yIGh0dHBzKDQ0MykgYW5kIGl0J3MgYXNzdW1lZCB3ZSdyZSBiZWhpbmQgYSByZXZlcnNlXG4gIC8vIHByb3h5IHdoaWNoIG1hbmFnZXMgV2ViU29ja2V0IHVwZ3JhZGUgYW5kIGJhY2tlbmQgcG9ydCByZWRpcmVjdGlvbi5cbiAgc3RhcnRQb3J0ID09IG51bGwgPyAnJyA6IGA6JHtzdGFydFBvcnQgKyAxfWA7XG4gIHJldHVybiBgJHtwcm90b2NvbH0vLyR7aG9zdGlzaH0ke3dlYnNvY2tldFBvcnR9JHtyZXN0fWA7XG59XG5cbmNvbnN0IFB1YmxpY0tleUZyb21TdHJpbmcgPSBjb2VyY2UoaW5zdGFuY2UoUHVibGljS2V5KSwgc3RyaW5nKCksIHZhbHVlID0+IG5ldyBQdWJsaWNLZXkodmFsdWUpKTtcbmNvbnN0IFJhd0FjY291bnREYXRhUmVzdWx0ID0gdHVwbGUoW3N0cmluZygpLCBsaXRlcmFsKCdiYXNlNjQnKV0pO1xuY29uc3QgQnVmZmVyRnJvbVJhd0FjY291bnREYXRhID0gY29lcmNlKGluc3RhbmNlKEJ1ZmZlciksIFJhd0FjY291bnREYXRhUmVzdWx0LCB2YWx1ZSA9PiBCdWZmZXIuZnJvbSh2YWx1ZVswXSwgJ2Jhc2U2NCcpKTtcblxuLyoqXG4gKiBBdHRlbXB0IHRvIHVzZSBhIHJlY2VudCBibG9ja2hhc2ggZm9yIHVwIHRvIDMwIHNlY29uZHNcbiAqIEBpbnRlcm5hbFxuICovXG5jb25zdCBCTE9DS0hBU0hfQ0FDSEVfVElNRU9VVF9NUyA9IDMwICogMTAwMDtcblxuLyoqXG4gKiBIQUNLLlxuICogQ29waWVkIGZyb20gcnBjLXdlYnNvY2tldHMvZGlzdC9saWIvY2xpZW50LlxuICogT3RoZXJ3aXNlLCBgeWFybiBidWlsZGAgZmFpbHMgd2l0aDpcbiAqIGh0dHBzOi8vZ2lzdC5naXRodWIuY29tL3N0ZXZlbHVzY2hlci9jMDU3ZWNhODFkNDc5ZWY3MDVjZGI1MzE2MmY5OTcxZFxuICovXG5cbi8qKiBAaW50ZXJuYWwgKi9cbi8qKiBAaW50ZXJuYWwgKi9cbi8qKiBAaW50ZXJuYWwgKi9cbi8qKiBAaW50ZXJuYWwgKi9cblxuLyoqIEBpbnRlcm5hbCAqL1xuLyoqXG4gKiBAaW50ZXJuYWxcbiAqIEV2ZXJ5IHN1YnNjcmlwdGlvbiBjb250YWlucyB0aGUgYXJncyB1c2VkIHRvIG9wZW4gdGhlIHN1YnNjcmlwdGlvbiB3aXRoXG4gKiB0aGUgc2VydmVyLCBhbmQgYSBsaXN0IG9mIGNhbGxlcnMgaW50ZXJlc3RlZCBpbiBub3RpZmljYXRpb25zLlxuICovXG5cbi8qKlxuICogQGludGVybmFsXG4gKiBBIHN1YnNjcmlwdGlvbiBtYXkgYmUgaW4gdmFyaW91cyBzdGF0ZXMgb2YgY29ubmVjdGVkbmVzcy4gT25seSB3aGVuIGl0IGlzXG4gKiBmdWxseSBjb25uZWN0ZWQgd2lsbCBpdCBoYXZlIGEgc2VydmVyIHN1YnNjcmlwdGlvbiBpZCBhc3NvY2lhdGVkIHdpdGggaXQuXG4gKiBUaGlzIGlkIGNhbiBiZSByZXR1cm5lZCB0byB0aGUgc2VydmVyIHRvIHVuc3Vic2NyaWJlIHRoZSBjbGllbnQgZW50aXJlbHkuXG4gKi9cblxuLyoqXG4gKiBBIHR5cGUgdGhhdCBlbmNhcHN1bGF0ZXMgYSBzdWJzY3JpcHRpb24ncyBSUEMgbWV0aG9kXG4gKiBuYW1lcyBhbmQgbm90aWZpY2F0aW9uIChjYWxsYmFjaykgc2lnbmF0dXJlLlxuICovXG5cbi8qKlxuICogQGludGVybmFsXG4gKiBVdGlsaXR5IHR5cGUgdGhhdCBrZWVwcyB0YWdnZWQgdW5pb25zIGludGFjdCB3aGlsZSBvbWl0dGluZyBwcm9wZXJ0aWVzLlxuICovXG5cbi8qKlxuICogQGludGVybmFsXG4gKiBUaGlzIHR5cGUgcmVwcmVzZW50cyBhIHNpbmdsZSBzdWJzY3JpYmFibGUgJ3RvcGljLicgSXQncyBtYWRlIHVwIG9mOlxuICpcbiAqIC0gVGhlIGFyZ3MgdXNlZCB0byBvcGVuIHRoZSBzdWJzY3JpcHRpb24gd2l0aCB0aGUgc2VydmVyLFxuICogLSBUaGUgc3RhdGUgb2YgdGhlIHN1YnNjcmlwdGlvbiwgaW4gdGVybXMgb2YgaXRzIGNvbm5lY3RlZG5lc3MsIGFuZFxuICogLSBUaGUgc2V0IG9mIGNhbGxiYWNrcyB0byBjYWxsIHdoZW4gdGhlIHNlcnZlciBwdWJsaXNoZXMgbm90aWZpY2F0aW9uc1xuICpcbiAqIFRoaXMgcmVjb3JkIGdldHMgaW5kZXhlZCBieSBgU3Vic2NyaXB0aW9uQ29uZmlnSGFzaGAgYW5kIGlzIHVzZWQgdG9cbiAqIHNldCB1cCBzdWJzY3JpcHRpb25zLCBmYW4gb3V0IG5vdGlmaWNhdGlvbnMsIGFuZCB0cmFjayBzdWJzY3JpcHRpb24gc3RhdGUuXG4gKi9cblxuLyoqXG4gKiBAaW50ZXJuYWxcbiAqL1xuXG4vKipcbiAqIEV4dHJhIGNvbnRleHR1YWwgaW5mb3JtYXRpb24gZm9yIFJQQyByZXNwb25zZXNcbiAqL1xuXG4vKipcbiAqIE9wdGlvbnMgZm9yIHNlbmRpbmcgdHJhbnNhY3Rpb25zXG4gKi9cblxuLyoqXG4gKiBPcHRpb25zIGZvciBjb25maXJtaW5nIHRyYW5zYWN0aW9uc1xuICovXG5cbi8qKlxuICogT3B0aW9ucyBmb3IgZ2V0Q29uZmlybWVkU2lnbmF0dXJlc0ZvckFkZHJlc3MyXG4gKi9cblxuLyoqXG4gKiBPcHRpb25zIGZvciBnZXRTaWduYXR1cmVzRm9yQWRkcmVzc1xuICovXG5cbi8qKlxuICogUlBDIFJlc3BvbnNlIHdpdGggZXh0cmEgY29udGV4dHVhbCBpbmZvcm1hdGlvblxuICovXG5cbi8qKlxuICogQSBzdHJhdGVneSBmb3IgY29uZmlybWluZyB0cmFuc2FjdGlvbnMgdGhhdCB1c2VzIHRoZSBsYXN0IHZhbGlkXG4gKiBibG9jayBoZWlnaHQgZm9yIGEgZ2l2ZW4gYmxvY2toYXNoIHRvIGNoZWNrIGZvciB0cmFuc2FjdGlvbiBleHBpcmF0aW9uLlxuICovXG5cbi8qKlxuICogQSBzdHJhdGVneSBmb3IgY29uZmlybWluZyBkdXJhYmxlIG5vbmNlIHRyYW5zYWN0aW9ucy5cbiAqL1xuXG4vKipcbiAqIFByb3BlcnRpZXMgc2hhcmVkIGJ5IGFsbCB0cmFuc2FjdGlvbiBjb25maXJtYXRpb24gc3RyYXRlZ2llc1xuICovXG5cbi8qKlxuICogVGhpcyB0eXBlIHJlcHJlc2VudHMgYWxsIHRyYW5zYWN0aW9uIGNvbmZpcm1hdGlvbiBzdHJhdGVnaWVzXG4gKi9cblxuLyogQGludGVybmFsICovXG5mdW5jdGlvbiBhc3NlcnRFbmRwb2ludFVybChwdXRhdGl2ZVVybCkge1xuICBpZiAoL15odHRwcz86Ly50ZXN0KHB1dGF0aXZlVXJsKSA9PT0gZmFsc2UpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdFbmRwb2ludCBVUkwgbXVzdCBzdGFydCB3aXRoIGBodHRwOmAgb3IgYGh0dHBzOmAuJyk7XG4gIH1cbiAgcmV0dXJuIHB1dGF0aXZlVXJsO1xufVxuXG4vKiogQGludGVybmFsICovXG5mdW5jdGlvbiBleHRyYWN0Q29tbWl0bWVudEZyb21Db25maWcoY29tbWl0bWVudE9yQ29uZmlnKSB7XG4gIGxldCBjb21taXRtZW50O1xuICBsZXQgY29uZmlnO1xuICBpZiAodHlwZW9mIGNvbW1pdG1lbnRPckNvbmZpZyA9PT0gJ3N0cmluZycpIHtcbiAgICBjb21taXRtZW50ID0gY29tbWl0bWVudE9yQ29uZmlnO1xuICB9IGVsc2UgaWYgKGNvbW1pdG1lbnRPckNvbmZpZykge1xuICAgIGNvbnN0IHtcbiAgICAgIGNvbW1pdG1lbnQ6IHNwZWNpZmllZENvbW1pdG1lbnQsXG4gICAgICAuLi5zcGVjaWZpZWRDb25maWdcbiAgICB9ID0gY29tbWl0bWVudE9yQ29uZmlnO1xuICAgIGNvbW1pdG1lbnQgPSBzcGVjaWZpZWRDb21taXRtZW50O1xuICAgIGNvbmZpZyA9IHNwZWNpZmllZENvbmZpZztcbiAgfVxuICByZXR1cm4ge1xuICAgIGNvbW1pdG1lbnQsXG4gICAgY29uZmlnXG4gIH07XG59XG5cbi8qKlxuICogQGludGVybmFsXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZVJwY1Jlc3VsdChyZXN1bHQpIHtcbiAgcmV0dXJuIHVuaW9uKFt0eXBlKHtcbiAgICBqc29ucnBjOiBsaXRlcmFsKCcyLjAnKSxcbiAgICBpZDogc3RyaW5nKCksXG4gICAgcmVzdWx0XG4gIH0pLCB0eXBlKHtcbiAgICBqc29ucnBjOiBsaXRlcmFsKCcyLjAnKSxcbiAgICBpZDogc3RyaW5nKCksXG4gICAgZXJyb3I6IHR5cGUoe1xuICAgICAgY29kZTogdW5rbm93bigpLFxuICAgICAgbWVzc2FnZTogc3RyaW5nKCksXG4gICAgICBkYXRhOiBvcHRpb25hbChhbnkoKSlcbiAgICB9KVxuICB9KV0pO1xufVxuY29uc3QgVW5rbm93blJwY1Jlc3VsdCA9IGNyZWF0ZVJwY1Jlc3VsdCh1bmtub3duKCkpO1xuXG4vKipcbiAqIEBpbnRlcm5hbFxuICovXG5mdW5jdGlvbiBqc29uUnBjUmVzdWx0KHNjaGVtYSkge1xuICByZXR1cm4gY29lcmNlKGNyZWF0ZVJwY1Jlc3VsdChzY2hlbWEpLCBVbmtub3duUnBjUmVzdWx0LCB2YWx1ZSA9PiB7XG4gICAgaWYgKCdlcnJvcicgaW4gdmFsdWUpIHtcbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgLi4udmFsdWUsXG4gICAgICAgIHJlc3VsdDogY3JlYXRlKHZhbHVlLnJlc3VsdCwgc2NoZW1hKVxuICAgICAgfTtcbiAgICB9XG4gIH0pO1xufVxuXG4vKipcbiAqIEBpbnRlcm5hbFxuICovXG5mdW5jdGlvbiBqc29uUnBjUmVzdWx0QW5kQ29udGV4dCh2YWx1ZSkge1xuICByZXR1cm4ganNvblJwY1Jlc3VsdCh0eXBlKHtcbiAgICBjb250ZXh0OiB0eXBlKHtcbiAgICAgIHNsb3Q6IG51bWJlcigpXG4gICAgfSksXG4gICAgdmFsdWVcbiAgfSkpO1xufVxuXG4vKipcbiAqIEBpbnRlcm5hbFxuICovXG5mdW5jdGlvbiBub3RpZmljYXRpb25SZXN1bHRBbmRDb250ZXh0KHZhbHVlKSB7XG4gIHJldHVybiB0eXBlKHtcbiAgICBjb250ZXh0OiB0eXBlKHtcbiAgICAgIHNsb3Q6IG51bWJlcigpXG4gICAgfSksXG4gICAgdmFsdWVcbiAgfSk7XG59XG5cbi8qKlxuICogQGludGVybmFsXG4gKi9cbmZ1bmN0aW9uIHZlcnNpb25lZE1lc3NhZ2VGcm9tUmVzcG9uc2UodmVyc2lvbiwgcmVzcG9uc2UpIHtcbiAgaWYgKHZlcnNpb24gPT09IDApIHtcbiAgICByZXR1cm4gbmV3IE1lc3NhZ2VWMCh7XG4gICAgICBoZWFkZXI6IHJlc3BvbnNlLmhlYWRlcixcbiAgICAgIHN0YXRpY0FjY291bnRLZXlzOiByZXNwb25zZS5hY2NvdW50S2V5cy5tYXAoYWNjb3VudEtleSA9PiBuZXcgUHVibGljS2V5KGFjY291bnRLZXkpKSxcbiAgICAgIHJlY2VudEJsb2NraGFzaDogcmVzcG9uc2UucmVjZW50QmxvY2toYXNoLFxuICAgICAgY29tcGlsZWRJbnN0cnVjdGlvbnM6IHJlc3BvbnNlLmluc3RydWN0aW9ucy5tYXAoaXggPT4gKHtcbiAgICAgICAgcHJvZ3JhbUlkSW5kZXg6IGl4LnByb2dyYW1JZEluZGV4LFxuICAgICAgICBhY2NvdW50S2V5SW5kZXhlczogaXguYWNjb3VudHMsXG4gICAgICAgIGRhdGE6IGJzNTguZGVjb2RlKGl4LmRhdGEpXG4gICAgICB9KSksXG4gICAgICBhZGRyZXNzVGFibGVMb29rdXBzOiByZXNwb25zZS5hZGRyZXNzVGFibGVMb29rdXBzXG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIG5ldyBNZXNzYWdlKHJlc3BvbnNlKTtcbiAgfVxufVxuXG4vKipcbiAqIFRoZSBsZXZlbCBvZiBjb21taXRtZW50IGRlc2lyZWQgd2hlbiBxdWVyeWluZyBzdGF0ZVxuICogPHByZT5cbiAqICAgJ3Byb2Nlc3NlZCc6IFF1ZXJ5IHRoZSBtb3N0IHJlY2VudCBibG9jayB3aGljaCBoYXMgcmVhY2hlZCAxIGNvbmZpcm1hdGlvbiBieSB0aGUgY29ubmVjdGVkIG5vZGVcbiAqICAgJ2NvbmZpcm1lZCc6IFF1ZXJ5IHRoZSBtb3N0IHJlY2VudCBibG9jayB3aGljaCBoYXMgcmVhY2hlZCAxIGNvbmZpcm1hdGlvbiBieSB0aGUgY2x1c3RlclxuICogICAnZmluYWxpemVkJzogUXVlcnkgdGhlIG1vc3QgcmVjZW50IGJsb2NrIHdoaWNoIGhhcyBiZWVuIGZpbmFsaXplZCBieSB0aGUgY2x1c3RlclxuICogPC9wcmU+XG4gKi9cblxuLy8gRGVwcmVjYXRlZCBhcyBvZiB2MS41LjVcblxuLyoqXG4gKiBBIHN1YnNldCBvZiBDb21taXRtZW50IGxldmVscywgd2hpY2ggYXJlIGF0IGxlYXN0IG9wdGltaXN0aWNhbGx5IGNvbmZpcm1lZFxuICogPHByZT5cbiAqICAgJ2NvbmZpcm1lZCc6IFF1ZXJ5IHRoZSBtb3N0IHJlY2VudCBibG9jayB3aGljaCBoYXMgcmVhY2hlZCAxIGNvbmZpcm1hdGlvbiBieSB0aGUgY2x1c3RlclxuICogICAnZmluYWxpemVkJzogUXVlcnkgdGhlIG1vc3QgcmVjZW50IGJsb2NrIHdoaWNoIGhhcyBiZWVuIGZpbmFsaXplZCBieSB0aGUgY2x1c3RlclxuICogPC9wcmU+XG4gKi9cblxuLyoqXG4gKiBGaWx0ZXIgZm9yIGxhcmdlc3QgYWNjb3VudHMgcXVlcnlcbiAqIDxwcmU+XG4gKiAgICdjaXJjdWxhdGluZyc6ICAgIFJldHVybiB0aGUgbGFyZ2VzdCBhY2NvdW50cyB0aGF0IGFyZSBwYXJ0IG9mIHRoZSBjaXJjdWxhdGluZyBzdXBwbHlcbiAqICAgJ25vbkNpcmN1bGF0aW5nJzogUmV0dXJuIHRoZSBsYXJnZXN0IGFjY291bnRzIHRoYXQgYXJlIG5vdCBwYXJ0IG9mIHRoZSBjaXJjdWxhdGluZyBzdXBwbHlcbiAqIDwvcHJlPlxuICovXG5cbi8qKlxuICogQ29uZmlndXJhdGlvbiBvYmplY3QgZm9yIGNoYW5naW5nIGBnZXRBY2NvdW50SW5mb2AgcXVlcnkgYmVoYXZpb3JcbiAqL1xuXG4vKipcbiAqIENvbmZpZ3VyYXRpb24gb2JqZWN0IGZvciBjaGFuZ2luZyBgZ2V0QmFsYW5jZWAgcXVlcnkgYmVoYXZpb3JcbiAqL1xuXG4vKipcbiAqIENvbmZpZ3VyYXRpb24gb2JqZWN0IGZvciBjaGFuZ2luZyBgZ2V0QmxvY2tgIHF1ZXJ5IGJlaGF2aW9yXG4gKi9cblxuLyoqXG4gKiBDb25maWd1cmF0aW9uIG9iamVjdCBmb3IgY2hhbmdpbmcgYGdldEJsb2NrYCBxdWVyeSBiZWhhdmlvclxuICovXG5cbi8qKlxuICogQ29uZmlndXJhdGlvbiBvYmplY3QgZm9yIGNoYW5naW5nIGBnZXRTdGFrZU1pbmltdW1EZWxlZ2F0aW9uYCBxdWVyeSBiZWhhdmlvclxuICovXG5cbi8qKlxuICogQ29uZmlndXJhdGlvbiBvYmplY3QgZm9yIGNoYW5naW5nIGBnZXRCbG9ja0hlaWdodGAgcXVlcnkgYmVoYXZpb3JcbiAqL1xuXG4vKipcbiAqIENvbmZpZ3VyYXRpb24gb2JqZWN0IGZvciBjaGFuZ2luZyBgZ2V0RXBvY2hJbmZvYCBxdWVyeSBiZWhhdmlvclxuICovXG5cbi8qKlxuICogQ29uZmlndXJhdGlvbiBvYmplY3QgZm9yIGNoYW5naW5nIGBnZXRJbmZsYXRpb25SZXdhcmRgIHF1ZXJ5IGJlaGF2aW9yXG4gKi9cblxuLyoqXG4gKiBDb25maWd1cmF0aW9uIG9iamVjdCBmb3IgY2hhbmdpbmcgYGdldExhdGVzdEJsb2NraGFzaGAgcXVlcnkgYmVoYXZpb3JcbiAqL1xuXG4vKipcbiAqIENvbmZpZ3VyYXRpb24gb2JqZWN0IGZvciBjaGFuZ2luZyBgaXNCbG9ja2hhc2hWYWxpZGAgcXVlcnkgYmVoYXZpb3JcbiAqL1xuXG4vKipcbiAqIENvbmZpZ3VyYXRpb24gb2JqZWN0IGZvciBjaGFuZ2luZyBgZ2V0U2xvdGAgcXVlcnkgYmVoYXZpb3JcbiAqL1xuXG4vKipcbiAqIENvbmZpZ3VyYXRpb24gb2JqZWN0IGZvciBjaGFuZ2luZyBgZ2V0U2xvdExlYWRlcmAgcXVlcnkgYmVoYXZpb3JcbiAqL1xuXG4vKipcbiAqIENvbmZpZ3VyYXRpb24gb2JqZWN0IGZvciBjaGFuZ2luZyBgZ2V0VHJhbnNhY3Rpb25gIHF1ZXJ5IGJlaGF2aW9yXG4gKi9cblxuLyoqXG4gKiBDb25maWd1cmF0aW9uIG9iamVjdCBmb3IgY2hhbmdpbmcgYGdldFRyYW5zYWN0aW9uYCBxdWVyeSBiZWhhdmlvclxuICovXG5cbi8qKlxuICogQ29uZmlndXJhdGlvbiBvYmplY3QgZm9yIGNoYW5naW5nIGBnZXRMYXJnZXN0QWNjb3VudHNgIHF1ZXJ5IGJlaGF2aW9yXG4gKi9cblxuLyoqXG4gKiBDb25maWd1cmF0aW9uIG9iamVjdCBmb3IgY2hhbmdpbmcgYGdldFN1cHBseWAgcmVxdWVzdCBiZWhhdmlvclxuICovXG5cbi8qKlxuICogQ29uZmlndXJhdGlvbiBvYmplY3QgZm9yIGNoYW5naW5nIHF1ZXJ5IGJlaGF2aW9yXG4gKi9cblxuLyoqXG4gKiBJbmZvcm1hdGlvbiBkZXNjcmliaW5nIGEgY2x1c3RlciBub2RlXG4gKi9cblxuLyoqXG4gKiBJbmZvcm1hdGlvbiBkZXNjcmliaW5nIGEgdm90ZSBhY2NvdW50XG4gKi9cblxuLyoqXG4gKiBBIGNvbGxlY3Rpb24gb2YgY2x1c3RlciB2b3RlIGFjY291bnRzXG4gKi9cblxuLyoqXG4gKiBOZXR3b3JrIEluZmxhdGlvblxuICogKHNlZSBodHRwczovL2RvY3Muc29sYW5hLmNvbS9pbXBsZW1lbnRlZC1wcm9wb3NhbHMvZWRfb3ZlcnZpZXcpXG4gKi9cblxuY29uc3QgR2V0SW5mbGF0aW9uR292ZXJub3JSZXN1bHQgPSB0eXBlKHtcbiAgZm91bmRhdGlvbjogbnVtYmVyKCksXG4gIGZvdW5kYXRpb25UZXJtOiBudW1iZXIoKSxcbiAgaW5pdGlhbDogbnVtYmVyKCksXG4gIHRhcGVyOiBudW1iZXIoKSxcbiAgdGVybWluYWw6IG51bWJlcigpXG59KTtcblxuLyoqXG4gKiBUaGUgaW5mbGF0aW9uIHJld2FyZCBmb3IgYW4gZXBvY2hcbiAqL1xuXG4vKipcbiAqIEV4cGVjdGVkIEpTT04gUlBDIHJlc3BvbnNlIGZvciB0aGUgXCJnZXRJbmZsYXRpb25SZXdhcmRcIiBtZXNzYWdlXG4gKi9cbmNvbnN0IEdldEluZmxhdGlvblJld2FyZFJlc3VsdCA9IGpzb25ScGNSZXN1bHQoYXJyYXkobnVsbGFibGUodHlwZSh7XG4gIGVwb2NoOiBudW1iZXIoKSxcbiAgZWZmZWN0aXZlU2xvdDogbnVtYmVyKCksXG4gIGFtb3VudDogbnVtYmVyKCksXG4gIHBvc3RCYWxhbmNlOiBudW1iZXIoKSxcbiAgY29tbWlzc2lvbjogb3B0aW9uYWwobnVsbGFibGUobnVtYmVyKCkpKVxufSkpKSk7XG5cbi8qKlxuICogQ29uZmlndXJhdGlvbiBvYmplY3QgZm9yIGNoYW5naW5nIGBnZXRSZWNlbnRQcmlvcml0aXphdGlvbkZlZXNgIHF1ZXJ5IGJlaGF2aW9yXG4gKi9cblxuLyoqXG4gKiBFeHBlY3RlZCBKU09OIFJQQyByZXNwb25zZSBmb3IgdGhlIFwiZ2V0UmVjZW50UHJpb3JpdGl6YXRpb25GZWVzXCIgbWVzc2FnZVxuICovXG5jb25zdCBHZXRSZWNlbnRQcmlvcml0aXphdGlvbkZlZXNSZXN1bHQgPSBhcnJheSh0eXBlKHtcbiAgc2xvdDogbnVtYmVyKCksXG4gIHByaW9yaXRpemF0aW9uRmVlOiBudW1iZXIoKVxufSkpO1xuLyoqXG4gKiBFeHBlY3RlZCBKU09OIFJQQyByZXNwb25zZSBmb3IgdGhlIFwiZ2V0SW5mbGF0aW9uUmF0ZVwiIG1lc3NhZ2VcbiAqL1xuY29uc3QgR2V0SW5mbGF0aW9uUmF0ZVJlc3VsdCA9IHR5cGUoe1xuICB0b3RhbDogbnVtYmVyKCksXG4gIHZhbGlkYXRvcjogbnVtYmVyKCksXG4gIGZvdW5kYXRpb246IG51bWJlcigpLFxuICBlcG9jaDogbnVtYmVyKClcbn0pO1xuXG4vKipcbiAqIEluZm9ybWF0aW9uIGFib3V0IHRoZSBjdXJyZW50IGVwb2NoXG4gKi9cblxuY29uc3QgR2V0RXBvY2hJbmZvUmVzdWx0ID0gdHlwZSh7XG4gIGVwb2NoOiBudW1iZXIoKSxcbiAgc2xvdEluZGV4OiBudW1iZXIoKSxcbiAgc2xvdHNJbkVwb2NoOiBudW1iZXIoKSxcbiAgYWJzb2x1dGVTbG90OiBudW1iZXIoKSxcbiAgYmxvY2tIZWlnaHQ6IG9wdGlvbmFsKG51bWJlcigpKSxcbiAgdHJhbnNhY3Rpb25Db3VudDogb3B0aW9uYWwobnVtYmVyKCkpXG59KTtcbmNvbnN0IEdldEVwb2NoU2NoZWR1bGVSZXN1bHQgPSB0eXBlKHtcbiAgc2xvdHNQZXJFcG9jaDogbnVtYmVyKCksXG4gIGxlYWRlclNjaGVkdWxlU2xvdE9mZnNldDogbnVtYmVyKCksXG4gIHdhcm11cDogYm9vbGVhbigpLFxuICBmaXJzdE5vcm1hbEVwb2NoOiBudW1iZXIoKSxcbiAgZmlyc3ROb3JtYWxTbG90OiBudW1iZXIoKVxufSk7XG5cbi8qKlxuICogTGVhZGVyIHNjaGVkdWxlXG4gKiAoc2VlIGh0dHBzOi8vZG9jcy5zb2xhbmEuY29tL3Rlcm1pbm9sb2d5I2xlYWRlci1zY2hlZHVsZSlcbiAqL1xuXG5jb25zdCBHZXRMZWFkZXJTY2hlZHVsZVJlc3VsdCA9IHJlY29yZChzdHJpbmcoKSwgYXJyYXkobnVtYmVyKCkpKTtcblxuLyoqXG4gKiBUcmFuc2FjdGlvbiBlcnJvciBvciBudWxsXG4gKi9cbmNvbnN0IFRyYW5zYWN0aW9uRXJyb3JSZXN1bHQgPSBudWxsYWJsZSh1bmlvbihbdHlwZSh7fSksIHN0cmluZygpXSkpO1xuXG4vKipcbiAqIFNpZ25hdHVyZSBzdGF0dXMgZm9yIGEgdHJhbnNhY3Rpb25cbiAqL1xuY29uc3QgU2lnbmF0dXJlU3RhdHVzUmVzdWx0ID0gdHlwZSh7XG4gIGVycjogVHJhbnNhY3Rpb25FcnJvclJlc3VsdFxufSk7XG5cbi8qKlxuICogVHJhbnNhY3Rpb24gc2lnbmF0dXJlIHJlY2VpdmVkIG5vdGlmaWNhdGlvblxuICovXG5jb25zdCBTaWduYXR1cmVSZWNlaXZlZFJlc3VsdCA9IGxpdGVyYWwoJ3JlY2VpdmVkU2lnbmF0dXJlJyk7XG5cbi8qKlxuICogVmVyc2lvbiBpbmZvIGZvciBhIG5vZGVcbiAqL1xuXG5jb25zdCBWZXJzaW9uUmVzdWx0ID0gdHlwZSh7XG4gICdzb2xhbmEtY29yZSc6IHN0cmluZygpLFxuICAnZmVhdHVyZS1zZXQnOiBvcHRpb25hbChudW1iZXIoKSlcbn0pO1xuY29uc3QgU2ltdWxhdGVkVHJhbnNhY3Rpb25SZXNwb25zZVN0cnVjdCA9IGpzb25ScGNSZXN1bHRBbmRDb250ZXh0KHR5cGUoe1xuICBlcnI6IG51bGxhYmxlKHVuaW9uKFt0eXBlKHt9KSwgc3RyaW5nKCldKSksXG4gIGxvZ3M6IG51bGxhYmxlKGFycmF5KHN0cmluZygpKSksXG4gIGFjY291bnRzOiBvcHRpb25hbChudWxsYWJsZShhcnJheShudWxsYWJsZSh0eXBlKHtcbiAgICBleGVjdXRhYmxlOiBib29sZWFuKCksXG4gICAgb3duZXI6IHN0cmluZygpLFxuICAgIGxhbXBvcnRzOiBudW1iZXIoKSxcbiAgICBkYXRhOiBhcnJheShzdHJpbmcoKSksXG4gICAgcmVudEVwb2NoOiBvcHRpb25hbChudW1iZXIoKSlcbiAgfSkpKSkpLFxuICB1bml0c0NvbnN1bWVkOiBvcHRpb25hbChudW1iZXIoKSksXG4gIHJldHVybkRhdGE6IG9wdGlvbmFsKG51bGxhYmxlKHR5cGUoe1xuICAgIHByb2dyYW1JZDogc3RyaW5nKCksXG4gICAgZGF0YTogdHVwbGUoW3N0cmluZygpLCBsaXRlcmFsKCdiYXNlNjQnKV0pXG4gIH0pKSlcbn0pKTtcblxuLyoqXG4gKiBNZXRhZGF0YSBmb3IgYSBwYXJzZWQgY29uZmlybWVkIHRyYW5zYWN0aW9uIG9uIHRoZSBsZWRnZXJcbiAqXG4gKiBAZGVwcmVjYXRlZCBEZXByZWNhdGVkIHNpbmNlIFNvbGFuYSB2MS44LjAuIFBsZWFzZSB1c2Uge0BsaW5rIFBhcnNlZFRyYW5zYWN0aW9uTWV0YX0gaW5zdGVhZC5cbiAqL1xuXG4vKipcbiAqIENvbGxlY3Rpb24gb2YgYWRkcmVzc2VzIGxvYWRlZCBieSBhIHRyYW5zYWN0aW9uIHVzaW5nIGFkZHJlc3MgdGFibGUgbG9va3Vwc1xuICovXG5cbi8qKlxuICogTWV0YWRhdGEgZm9yIGEgcGFyc2VkIHRyYW5zYWN0aW9uIG9uIHRoZSBsZWRnZXJcbiAqL1xuXG4vKipcbiAqIE1ldGFkYXRhIGZvciBhIGNvbmZpcm1lZCB0cmFuc2FjdGlvbiBvbiB0aGUgbGVkZ2VyXG4gKi9cblxuLyoqXG4gKiBBIHByb2Nlc3NlZCB0cmFuc2FjdGlvbiBmcm9tIHRoZSBSUEMgQVBJXG4gKi9cblxuLyoqXG4gKiBBIHByb2Nlc3NlZCB0cmFuc2FjdGlvbiBmcm9tIHRoZSBSUEMgQVBJXG4gKi9cblxuLyoqXG4gKiBBIHByb2Nlc3NlZCB0cmFuc2FjdGlvbiBtZXNzYWdlIGZyb20gdGhlIFJQQyBBUElcbiAqL1xuXG4vKipcbiAqIEEgY29uZmlybWVkIHRyYW5zYWN0aW9uIG9uIHRoZSBsZWRnZXJcbiAqXG4gKiBAZGVwcmVjYXRlZCBEZXByZWNhdGVkIHNpbmNlIFNvbGFuYSB2MS44LjAuXG4gKi9cblxuLyoqXG4gKiBBIHBhcnRpYWxseSBkZWNvZGVkIHRyYW5zYWN0aW9uIGluc3RydWN0aW9uXG4gKi9cblxuLyoqXG4gKiBBIHBhcnNlZCB0cmFuc2FjdGlvbiBtZXNzYWdlIGFjY291bnRcbiAqL1xuXG4vKipcbiAqIEEgcGFyc2VkIHRyYW5zYWN0aW9uIGluc3RydWN0aW9uXG4gKi9cblxuLyoqXG4gKiBBIHBhcnNlZCBhZGRyZXNzIHRhYmxlIGxvb2t1cFxuICovXG5cbi8qKlxuICogQSBwYXJzZWQgdHJhbnNhY3Rpb24gbWVzc2FnZVxuICovXG5cbi8qKlxuICogQSBwYXJzZWQgdHJhbnNhY3Rpb25cbiAqL1xuXG4vKipcbiAqIEEgcGFyc2VkIGFuZCBjb25maXJtZWQgdHJhbnNhY3Rpb24gb24gdGhlIGxlZGdlclxuICpcbiAqIEBkZXByZWNhdGVkIERlcHJlY2F0ZWQgc2luY2UgU29sYW5hIHYxLjguMC4gUGxlYXNlIHVzZSB7QGxpbmsgUGFyc2VkVHJhbnNhY3Rpb25XaXRoTWV0YX0gaW5zdGVhZC5cbiAqL1xuXG4vKipcbiAqIEEgcGFyc2VkIHRyYW5zYWN0aW9uIG9uIHRoZSBsZWRnZXIgd2l0aCBtZXRhXG4gKi9cblxuLyoqXG4gKiBBIHByb2Nlc3NlZCBibG9jayBmZXRjaGVkIGZyb20gdGhlIFJQQyBBUElcbiAqL1xuXG4vKipcbiAqIEEgcHJvY2Vzc2VkIGJsb2NrIGZldGNoZWQgZnJvbSB0aGUgUlBDIEFQSSB3aGVyZSB0aGUgYHRyYW5zYWN0aW9uRGV0YWlsc2AgbW9kZSBpcyBgYWNjb3VudHNgXG4gKi9cblxuLyoqXG4gKiBBIHByb2Nlc3NlZCBibG9jayBmZXRjaGVkIGZyb20gdGhlIFJQQyBBUEkgd2hlcmUgdGhlIGB0cmFuc2FjdGlvbkRldGFpbHNgIG1vZGUgaXMgYG5vbmVgXG4gKi9cblxuLyoqXG4gKiBBIGJsb2NrIHdpdGggcGFyc2VkIHRyYW5zYWN0aW9uc1xuICovXG5cbi8qKlxuICogQSBibG9jayB3aXRoIHBhcnNlZCB0cmFuc2FjdGlvbnMgd2hlcmUgdGhlIGB0cmFuc2FjdGlvbkRldGFpbHNgIG1vZGUgaXMgYGFjY291bnRzYFxuICovXG5cbi8qKlxuICogQSBibG9jayB3aXRoIHBhcnNlZCB0cmFuc2FjdGlvbnMgd2hlcmUgdGhlIGB0cmFuc2FjdGlvbkRldGFpbHNgIG1vZGUgaXMgYG5vbmVgXG4gKi9cblxuLyoqXG4gKiBBIHByb2Nlc3NlZCBibG9jayBmZXRjaGVkIGZyb20gdGhlIFJQQyBBUElcbiAqL1xuXG4vKipcbiAqIEEgcHJvY2Vzc2VkIGJsb2NrIGZldGNoZWQgZnJvbSB0aGUgUlBDIEFQSSB3aGVyZSB0aGUgYHRyYW5zYWN0aW9uRGV0YWlsc2AgbW9kZSBpcyBgYWNjb3VudHNgXG4gKi9cblxuLyoqXG4gKiBBIHByb2Nlc3NlZCBibG9jayBmZXRjaGVkIGZyb20gdGhlIFJQQyBBUEkgd2hlcmUgdGhlIGB0cmFuc2FjdGlvbkRldGFpbHNgIG1vZGUgaXMgYG5vbmVgXG4gKi9cblxuLyoqXG4gKiBBIGNvbmZpcm1lZCBibG9jayBvbiB0aGUgbGVkZ2VyXG4gKlxuICogQGRlcHJlY2F0ZWQgRGVwcmVjYXRlZCBzaW5jZSBTb2xhbmEgdjEuOC4wLlxuICovXG5cbi8qKlxuICogQSBCbG9jayBvbiB0aGUgbGVkZ2VyIHdpdGggc2lnbmF0dXJlcyBvbmx5XG4gKi9cblxuLyoqXG4gKiByZWNlbnQgYmxvY2sgcHJvZHVjdGlvbiBpbmZvcm1hdGlvblxuICovXG5cbi8qKlxuICogRXhwZWN0ZWQgSlNPTiBSUEMgcmVzcG9uc2UgZm9yIHRoZSBcImdldEJsb2NrUHJvZHVjdGlvblwiIG1lc3NhZ2VcbiAqL1xuY29uc3QgQmxvY2tQcm9kdWN0aW9uUmVzcG9uc2VTdHJ1Y3QgPSBqc29uUnBjUmVzdWx0QW5kQ29udGV4dCh0eXBlKHtcbiAgYnlJZGVudGl0eTogcmVjb3JkKHN0cmluZygpLCBhcnJheShudW1iZXIoKSkpLFxuICByYW5nZTogdHlwZSh7XG4gICAgZmlyc3RTbG90OiBudW1iZXIoKSxcbiAgICBsYXN0U2xvdDogbnVtYmVyKClcbiAgfSlcbn0pKTtcblxuLyoqXG4gKiBBIHBlcmZvcm1hbmNlIHNhbXBsZVxuICovXG5cbmZ1bmN0aW9uIGNyZWF0ZVJwY0NsaWVudCh1cmwsIGh0dHBIZWFkZXJzLCBjdXN0b21GZXRjaCwgZmV0Y2hNaWRkbGV3YXJlLCBkaXNhYmxlUmV0cnlPblJhdGVMaW1pdCwgaHR0cEFnZW50KSB7XG4gIGNvbnN0IGZldGNoID0gY3VzdG9tRmV0Y2ggPyBjdXN0b21GZXRjaCA6IGZldGNoSW1wbDtcbiAgbGV0IGFnZW50O1xuICB7XG4gICAgaWYgKGh0dHBBZ2VudCA9PSBudWxsKSB7XG4gICAgICB7XG4gICAgICAgIGNvbnN0IGFnZW50T3B0aW9ucyA9IHtcbiAgICAgICAgICAvLyBPbmUgc2Vjb25kIGZld2VyIHRoYW4gdGhlIFNvbGFuYSBSUEMncyBrZWVwYWxpdmUgdGltZW91dC5cbiAgICAgICAgICAvLyBSZWFkIG1vcmU6IGh0dHBzOi8vZ2l0aHViLmNvbS9zb2xhbmEtbGFicy9zb2xhbmEvaXNzdWVzLzI3ODU5I2lzc3VlY29tbWVudC0xMzQwMDk3ODg5XG4gICAgICAgICAgZnJlZVNvY2tldFRpbWVvdXQ6IDE5MDAwLFxuICAgICAgICAgIGtlZXBBbGl2ZTogdHJ1ZSxcbiAgICAgICAgICBtYXhTb2NrZXRzOiAyNVxuICAgICAgICB9O1xuICAgICAgICBpZiAodXJsLnN0YXJ0c1dpdGgoJ2h0dHBzOicpKSB7XG4gICAgICAgICAgYWdlbnQgPSBuZXcgSHR0cHNBZ2VudChhZ2VudE9wdGlvbnMpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGFnZW50ID0gbmV3IEh0dHBLZWVwQWxpdmVBZ2VudChhZ2VudE9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChodHRwQWdlbnQgIT09IGZhbHNlKSB7XG4gICAgICAgIGNvbnN0IGlzSHR0cHMgPSB1cmwuc3RhcnRzV2l0aCgnaHR0cHM6Jyk7XG4gICAgICAgIGlmIChpc0h0dHBzICYmICEoaHR0cEFnZW50IGluc3RhbmNlb2YgQWdlbnQkMSkpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoZSBlbmRwb2ludCBgJyArIHVybCArICdgIGNhbiBvbmx5IGJlIHBhaXJlZCB3aXRoIGFuIGBodHRwcy5BZ2VudGAuIFlvdSBoYXZlLCBpbnN0ZWFkLCBzdXBwbGllZCBhbiAnICsgJ2BodHRwLkFnZW50YCB0aHJvdWdoIGBodHRwQWdlbnRgLicpO1xuICAgICAgICB9IGVsc2UgaWYgKCFpc0h0dHBzICYmIGh0dHBBZ2VudCBpbnN0YW5jZW9mIEFnZW50JDEpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoZSBlbmRwb2ludCBgJyArIHVybCArICdgIGNhbiBvbmx5IGJlIHBhaXJlZCB3aXRoIGFuIGBodHRwLkFnZW50YC4gWW91IGhhdmUsIGluc3RlYWQsIHN1cHBsaWVkIGFuICcgKyAnYGh0dHBzLkFnZW50YCB0aHJvdWdoIGBodHRwQWdlbnRgLicpO1xuICAgICAgICB9XG4gICAgICAgIGFnZW50ID0gaHR0cEFnZW50O1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBsZXQgZmV0Y2hXaXRoTWlkZGxld2FyZTtcbiAgaWYgKGZldGNoTWlkZGxld2FyZSkge1xuICAgIGZldGNoV2l0aE1pZGRsZXdhcmUgPSBhc3luYyAoaW5mbywgaW5pdCkgPT4ge1xuICAgICAgY29uc3QgbW9kaWZpZWRGZXRjaEFyZ3MgPSBhd2FpdCBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgZmV0Y2hNaWRkbGV3YXJlKGluZm8sIGluaXQsIChtb2RpZmllZEluZm8sIG1vZGlmaWVkSW5pdCkgPT4gcmVzb2x2ZShbbW9kaWZpZWRJbmZvLCBtb2RpZmllZEluaXRdKSk7XG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgcmVqZWN0KGVycm9yKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gYXdhaXQgZmV0Y2goLi4ubW9kaWZpZWRGZXRjaEFyZ3MpO1xuICAgIH07XG4gIH1cbiAgY29uc3QgY2xpZW50QnJvd3NlciA9IG5ldyBScGNDbGllbnQoYXN5bmMgKHJlcXVlc3QsIGNhbGxiYWNrKSA9PiB7XG4gICAgY29uc3Qgb3B0aW9ucyA9IHtcbiAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgYm9keTogcmVxdWVzdCxcbiAgICAgIGFnZW50LFxuICAgICAgaGVhZGVyczogT2JqZWN0LmFzc2lnbih7XG4gICAgICAgICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbidcbiAgICAgIH0sIGh0dHBIZWFkZXJzIHx8IHt9LCBDT01NT05fSFRUUF9IRUFERVJTKVxuICAgIH07XG4gICAgdHJ5IHtcbiAgICAgIGxldCB0b29fbWFueV9yZXF1ZXN0c19yZXRyaWVzID0gNTtcbiAgICAgIGxldCByZXM7XG4gICAgICBsZXQgd2FpdFRpbWUgPSA1MDA7XG4gICAgICBmb3IgKDs7KSB7XG4gICAgICAgIGlmIChmZXRjaFdpdGhNaWRkbGV3YXJlKSB7XG4gICAgICAgICAgcmVzID0gYXdhaXQgZmV0Y2hXaXRoTWlkZGxld2FyZSh1cmwsIG9wdGlvbnMpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlcyA9IGF3YWl0IGZldGNoKHVybCwgb3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlcy5zdGF0dXMgIT09IDQyOSAvKiBUb28gbWFueSByZXF1ZXN0cyAqLykge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGlmIChkaXNhYmxlUmV0cnlPblJhdGVMaW1pdCA9PT0gdHJ1ZSkge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIHRvb19tYW55X3JlcXVlc3RzX3JldHJpZXMgLT0gMTtcbiAgICAgICAgaWYgKHRvb19tYW55X3JlcXVlc3RzX3JldHJpZXMgPT09IDApIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBjb25zb2xlLmVycm9yKGBTZXJ2ZXIgcmVzcG9uZGVkIHdpdGggJHtyZXMuc3RhdHVzfSAke3Jlcy5zdGF0dXNUZXh0fS4gIFJldHJ5aW5nIGFmdGVyICR7d2FpdFRpbWV9bXMgZGVsYXkuLi5gKTtcbiAgICAgICAgYXdhaXQgc2xlZXAod2FpdFRpbWUpO1xuICAgICAgICB3YWl0VGltZSAqPSAyO1xuICAgICAgfVxuICAgICAgY29uc3QgdGV4dCA9IGF3YWl0IHJlcy50ZXh0KCk7XG4gICAgICBpZiAocmVzLm9rKSB7XG4gICAgICAgIGNhbGxiYWNrKG51bGwsIHRleHQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY2FsbGJhY2sobmV3IEVycm9yKGAke3Jlcy5zdGF0dXN9ICR7cmVzLnN0YXR1c1RleHR9OiAke3RleHR9YCkpO1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgaWYgKGVyciBpbnN0YW5jZW9mIEVycm9yKSBjYWxsYmFjayhlcnIpO1xuICAgIH1cbiAgfSwge30pO1xuICByZXR1cm4gY2xpZW50QnJvd3Nlcjtcbn1cbmZ1bmN0aW9uIGNyZWF0ZVJwY1JlcXVlc3QoY2xpZW50KSB7XG4gIHJldHVybiAobWV0aG9kLCBhcmdzKSA9PiB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIGNsaWVudC5yZXF1ZXN0KG1ldGhvZCwgYXJncywgKGVyciwgcmVzcG9uc2UpID0+IHtcbiAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgIHJlamVjdChlcnIpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICByZXNvbHZlKHJlc3BvbnNlKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9O1xufVxuZnVuY3Rpb24gY3JlYXRlUnBjQmF0Y2hSZXF1ZXN0KGNsaWVudCkge1xuICByZXR1cm4gcmVxdWVzdHMgPT4ge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAvLyBEbyBub3RoaW5nIGlmIHJlcXVlc3RzIGlzIGVtcHR5XG4gICAgICBpZiAocmVxdWVzdHMubGVuZ3RoID09PSAwKSByZXNvbHZlKFtdKTtcbiAgICAgIGNvbnN0IGJhdGNoID0gcmVxdWVzdHMubWFwKHBhcmFtcyA9PiB7XG4gICAgICAgIHJldHVybiBjbGllbnQucmVxdWVzdChwYXJhbXMubWV0aG9kTmFtZSwgcGFyYW1zLmFyZ3MpO1xuICAgICAgfSk7XG4gICAgICBjbGllbnQucmVxdWVzdChiYXRjaCwgKGVyciwgcmVzcG9uc2UpID0+IHtcbiAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgIHJlamVjdChlcnIpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICByZXNvbHZlKHJlc3BvbnNlKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9O1xufVxuXG4vKipcbiAqIEV4cGVjdGVkIEpTT04gUlBDIHJlc3BvbnNlIGZvciB0aGUgXCJnZXRJbmZsYXRpb25Hb3Zlcm5vclwiIG1lc3NhZ2VcbiAqL1xuY29uc3QgR2V0SW5mbGF0aW9uR292ZXJub3JScGNSZXN1bHQgPSBqc29uUnBjUmVzdWx0KEdldEluZmxhdGlvbkdvdmVybm9yUmVzdWx0KTtcblxuLyoqXG4gKiBFeHBlY3RlZCBKU09OIFJQQyByZXNwb25zZSBmb3IgdGhlIFwiZ2V0SW5mbGF0aW9uUmF0ZVwiIG1lc3NhZ2VcbiAqL1xuY29uc3QgR2V0SW5mbGF0aW9uUmF0ZVJwY1Jlc3VsdCA9IGpzb25ScGNSZXN1bHQoR2V0SW5mbGF0aW9uUmF0ZVJlc3VsdCk7XG5cbi8qKlxuICogRXhwZWN0ZWQgSlNPTiBSUEMgcmVzcG9uc2UgZm9yIHRoZSBcImdldFJlY2VudFByaW9yaXRpemF0aW9uRmVlc1wiIG1lc3NhZ2VcbiAqL1xuY29uc3QgR2V0UmVjZW50UHJpb3JpdGl6YXRpb25GZWVzUnBjUmVzdWx0ID0ganNvblJwY1Jlc3VsdChHZXRSZWNlbnRQcmlvcml0aXphdGlvbkZlZXNSZXN1bHQpO1xuXG4vKipcbiAqIEV4cGVjdGVkIEpTT04gUlBDIHJlc3BvbnNlIGZvciB0aGUgXCJnZXRFcG9jaEluZm9cIiBtZXNzYWdlXG4gKi9cbmNvbnN0IEdldEVwb2NoSW5mb1JwY1Jlc3VsdCA9IGpzb25ScGNSZXN1bHQoR2V0RXBvY2hJbmZvUmVzdWx0KTtcblxuLyoqXG4gKiBFeHBlY3RlZCBKU09OIFJQQyByZXNwb25zZSBmb3IgdGhlIFwiZ2V0RXBvY2hTY2hlZHVsZVwiIG1lc3NhZ2VcbiAqL1xuY29uc3QgR2V0RXBvY2hTY2hlZHVsZVJwY1Jlc3VsdCA9IGpzb25ScGNSZXN1bHQoR2V0RXBvY2hTY2hlZHVsZVJlc3VsdCk7XG5cbi8qKlxuICogRXhwZWN0ZWQgSlNPTiBSUEMgcmVzcG9uc2UgZm9yIHRoZSBcImdldExlYWRlclNjaGVkdWxlXCIgbWVzc2FnZVxuICovXG5jb25zdCBHZXRMZWFkZXJTY2hlZHVsZVJwY1Jlc3VsdCA9IGpzb25ScGNSZXN1bHQoR2V0TGVhZGVyU2NoZWR1bGVSZXN1bHQpO1xuXG4vKipcbiAqIEV4cGVjdGVkIEpTT04gUlBDIHJlc3BvbnNlIGZvciB0aGUgXCJtaW5pbXVtTGVkZ2VyU2xvdFwiIGFuZCBcImdldEZpcnN0QXZhaWxhYmxlQmxvY2tcIiBtZXNzYWdlc1xuICovXG5jb25zdCBTbG90UnBjUmVzdWx0ID0ganNvblJwY1Jlc3VsdChudW1iZXIoKSk7XG5cbi8qKlxuICogU3VwcGx5XG4gKi9cblxuLyoqXG4gKiBFeHBlY3RlZCBKU09OIFJQQyByZXNwb25zZSBmb3IgdGhlIFwiZ2V0U3VwcGx5XCIgbWVzc2FnZVxuICovXG5jb25zdCBHZXRTdXBwbHlScGNSZXN1bHQgPSBqc29uUnBjUmVzdWx0QW5kQ29udGV4dCh0eXBlKHtcbiAgdG90YWw6IG51bWJlcigpLFxuICBjaXJjdWxhdGluZzogbnVtYmVyKCksXG4gIG5vbkNpcmN1bGF0aW5nOiBudW1iZXIoKSxcbiAgbm9uQ2lyY3VsYXRpbmdBY2NvdW50czogYXJyYXkoUHVibGljS2V5RnJvbVN0cmluZylcbn0pKTtcblxuLyoqXG4gKiBUb2tlbiBhbW91bnQgb2JqZWN0IHdoaWNoIHJldHVybnMgYSB0b2tlbiBhbW91bnQgaW4gZGlmZmVyZW50IGZvcm1hdHNcbiAqIGZvciB2YXJpb3VzIGNsaWVudCB1c2UgY2FzZXMuXG4gKi9cblxuLyoqXG4gKiBFeHBlY3RlZCBKU09OIFJQQyBzdHJ1Y3R1cmUgZm9yIHRva2VuIGFtb3VudHNcbiAqL1xuY29uc3QgVG9rZW5BbW91bnRSZXN1bHQgPSB0eXBlKHtcbiAgYW1vdW50OiBzdHJpbmcoKSxcbiAgdWlBbW91bnQ6IG51bGxhYmxlKG51bWJlcigpKSxcbiAgZGVjaW1hbHM6IG51bWJlcigpLFxuICB1aUFtb3VudFN0cmluZzogb3B0aW9uYWwoc3RyaW5nKCkpXG59KTtcblxuLyoqXG4gKiBUb2tlbiBhZGRyZXNzIGFuZCBiYWxhbmNlLlxuICovXG5cbi8qKlxuICogRXhwZWN0ZWQgSlNPTiBSUEMgcmVzcG9uc2UgZm9yIHRoZSBcImdldFRva2VuTGFyZ2VzdEFjY291bnRzXCIgbWVzc2FnZVxuICovXG5jb25zdCBHZXRUb2tlbkxhcmdlc3RBY2NvdW50c1Jlc3VsdCA9IGpzb25ScGNSZXN1bHRBbmRDb250ZXh0KGFycmF5KHR5cGUoe1xuICBhZGRyZXNzOiBQdWJsaWNLZXlGcm9tU3RyaW5nLFxuICBhbW91bnQ6IHN0cmluZygpLFxuICB1aUFtb3VudDogbnVsbGFibGUobnVtYmVyKCkpLFxuICBkZWNpbWFsczogbnVtYmVyKCksXG4gIHVpQW1vdW50U3RyaW5nOiBvcHRpb25hbChzdHJpbmcoKSlcbn0pKSk7XG5cbi8qKlxuICogRXhwZWN0ZWQgSlNPTiBSUEMgcmVzcG9uc2UgZm9yIHRoZSBcImdldFRva2VuQWNjb3VudHNCeU93bmVyXCIgbWVzc2FnZVxuICovXG5jb25zdCBHZXRUb2tlbkFjY291bnRzQnlPd25lciA9IGpzb25ScGNSZXN1bHRBbmRDb250ZXh0KGFycmF5KHR5cGUoe1xuICBwdWJrZXk6IFB1YmxpY0tleUZyb21TdHJpbmcsXG4gIGFjY291bnQ6IHR5cGUoe1xuICAgIGV4ZWN1dGFibGU6IGJvb2xlYW4oKSxcbiAgICBvd25lcjogUHVibGljS2V5RnJvbVN0cmluZyxcbiAgICBsYW1wb3J0czogbnVtYmVyKCksXG4gICAgZGF0YTogQnVmZmVyRnJvbVJhd0FjY291bnREYXRhLFxuICAgIHJlbnRFcG9jaDogbnVtYmVyKClcbiAgfSlcbn0pKSk7XG5jb25zdCBQYXJzZWRBY2NvdW50RGF0YVJlc3VsdCA9IHR5cGUoe1xuICBwcm9ncmFtOiBzdHJpbmcoKSxcbiAgcGFyc2VkOiB1bmtub3duKCksXG4gIHNwYWNlOiBudW1iZXIoKVxufSk7XG5cbi8qKlxuICogRXhwZWN0ZWQgSlNPTiBSUEMgcmVzcG9uc2UgZm9yIHRoZSBcImdldFRva2VuQWNjb3VudHNCeU93bmVyXCIgbWVzc2FnZSB3aXRoIHBhcnNlZCBkYXRhXG4gKi9cbmNvbnN0IEdldFBhcnNlZFRva2VuQWNjb3VudHNCeU93bmVyID0ganNvblJwY1Jlc3VsdEFuZENvbnRleHQoYXJyYXkodHlwZSh7XG4gIHB1YmtleTogUHVibGljS2V5RnJvbVN0cmluZyxcbiAgYWNjb3VudDogdHlwZSh7XG4gICAgZXhlY3V0YWJsZTogYm9vbGVhbigpLFxuICAgIG93bmVyOiBQdWJsaWNLZXlGcm9tU3RyaW5nLFxuICAgIGxhbXBvcnRzOiBudW1iZXIoKSxcbiAgICBkYXRhOiBQYXJzZWRBY2NvdW50RGF0YVJlc3VsdCxcbiAgICByZW50RXBvY2g6IG51bWJlcigpXG4gIH0pXG59KSkpO1xuXG4vKipcbiAqIFBhaXIgb2YgYW4gYWNjb3VudCBhZGRyZXNzIGFuZCBpdHMgYmFsYW5jZVxuICovXG5cbi8qKlxuICogRXhwZWN0ZWQgSlNPTiBSUEMgcmVzcG9uc2UgZm9yIHRoZSBcImdldExhcmdlc3RBY2NvdW50c1wiIG1lc3NhZ2VcbiAqL1xuY29uc3QgR2V0TGFyZ2VzdEFjY291bnRzUnBjUmVzdWx0ID0ganNvblJwY1Jlc3VsdEFuZENvbnRleHQoYXJyYXkodHlwZSh7XG4gIGxhbXBvcnRzOiBudW1iZXIoKSxcbiAgYWRkcmVzczogUHVibGljS2V5RnJvbVN0cmluZ1xufSkpKTtcblxuLyoqXG4gKiBAaW50ZXJuYWxcbiAqL1xuY29uc3QgQWNjb3VudEluZm9SZXN1bHQgPSB0eXBlKHtcbiAgZXhlY3V0YWJsZTogYm9vbGVhbigpLFxuICBvd25lcjogUHVibGljS2V5RnJvbVN0cmluZyxcbiAgbGFtcG9ydHM6IG51bWJlcigpLFxuICBkYXRhOiBCdWZmZXJGcm9tUmF3QWNjb3VudERhdGEsXG4gIHJlbnRFcG9jaDogbnVtYmVyKClcbn0pO1xuXG4vKipcbiAqIEBpbnRlcm5hbFxuICovXG5jb25zdCBLZXllZEFjY291bnRJbmZvUmVzdWx0ID0gdHlwZSh7XG4gIHB1YmtleTogUHVibGljS2V5RnJvbVN0cmluZyxcbiAgYWNjb3VudDogQWNjb3VudEluZm9SZXN1bHRcbn0pO1xuY29uc3QgUGFyc2VkT3JSYXdBY2NvdW50RGF0YSA9IGNvZXJjZSh1bmlvbihbaW5zdGFuY2UoQnVmZmVyKSwgUGFyc2VkQWNjb3VudERhdGFSZXN1bHRdKSwgdW5pb24oW1Jhd0FjY291bnREYXRhUmVzdWx0LCBQYXJzZWRBY2NvdW50RGF0YVJlc3VsdF0pLCB2YWx1ZSA9PiB7XG4gIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgIHJldHVybiBjcmVhdGUodmFsdWUsIEJ1ZmZlckZyb21SYXdBY2NvdW50RGF0YSk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG59KTtcblxuLyoqXG4gKiBAaW50ZXJuYWxcbiAqL1xuY29uc3QgUGFyc2VkQWNjb3VudEluZm9SZXN1bHQgPSB0eXBlKHtcbiAgZXhlY3V0YWJsZTogYm9vbGVhbigpLFxuICBvd25lcjogUHVibGljS2V5RnJvbVN0cmluZyxcbiAgbGFtcG9ydHM6IG51bWJlcigpLFxuICBkYXRhOiBQYXJzZWRPclJhd0FjY291bnREYXRhLFxuICByZW50RXBvY2g6IG51bWJlcigpXG59KTtcbmNvbnN0IEtleWVkUGFyc2VkQWNjb3VudEluZm9SZXN1bHQgPSB0eXBlKHtcbiAgcHVia2V5OiBQdWJsaWNLZXlGcm9tU3RyaW5nLFxuICBhY2NvdW50OiBQYXJzZWRBY2NvdW50SW5mb1Jlc3VsdFxufSk7XG5cbi8qKlxuICogQGludGVybmFsXG4gKi9cbmNvbnN0IFN0YWtlQWN0aXZhdGlvblJlc3VsdCA9IHR5cGUoe1xuICBzdGF0ZTogdW5pb24oW2xpdGVyYWwoJ2FjdGl2ZScpLCBsaXRlcmFsKCdpbmFjdGl2ZScpLCBsaXRlcmFsKCdhY3RpdmF0aW5nJyksIGxpdGVyYWwoJ2RlYWN0aXZhdGluZycpXSksXG4gIGFjdGl2ZTogbnVtYmVyKCksXG4gIGluYWN0aXZlOiBudW1iZXIoKVxufSk7XG5cbi8qKlxuICogRXhwZWN0ZWQgSlNPTiBSUEMgcmVzcG9uc2UgZm9yIHRoZSBcImdldENvbmZpcm1lZFNpZ25hdHVyZXNGb3JBZGRyZXNzMlwiIG1lc3NhZ2VcbiAqL1xuXG5jb25zdCBHZXRDb25maXJtZWRTaWduYXR1cmVzRm9yQWRkcmVzczJScGNSZXN1bHQgPSBqc29uUnBjUmVzdWx0KGFycmF5KHR5cGUoe1xuICBzaWduYXR1cmU6IHN0cmluZygpLFxuICBzbG90OiBudW1iZXIoKSxcbiAgZXJyOiBUcmFuc2FjdGlvbkVycm9yUmVzdWx0LFxuICBtZW1vOiBudWxsYWJsZShzdHJpbmcoKSksXG4gIGJsb2NrVGltZTogb3B0aW9uYWwobnVsbGFibGUobnVtYmVyKCkpKVxufSkpKTtcblxuLyoqXG4gKiBFeHBlY3RlZCBKU09OIFJQQyByZXNwb25zZSBmb3IgdGhlIFwiZ2V0U2lnbmF0dXJlc0ZvckFkZHJlc3NcIiBtZXNzYWdlXG4gKi9cbmNvbnN0IEdldFNpZ25hdHVyZXNGb3JBZGRyZXNzUnBjUmVzdWx0ID0ganNvblJwY1Jlc3VsdChhcnJheSh0eXBlKHtcbiAgc2lnbmF0dXJlOiBzdHJpbmcoKSxcbiAgc2xvdDogbnVtYmVyKCksXG4gIGVycjogVHJhbnNhY3Rpb25FcnJvclJlc3VsdCxcbiAgbWVtbzogbnVsbGFibGUoc3RyaW5nKCkpLFxuICBibG9ja1RpbWU6IG9wdGlvbmFsKG51bGxhYmxlKG51bWJlcigpKSlcbn0pKSk7XG5cbi8qKipcbiAqIEV4cGVjdGVkIEpTT04gUlBDIHJlc3BvbnNlIGZvciB0aGUgXCJhY2NvdW50Tm90aWZpY2F0aW9uXCIgbWVzc2FnZVxuICovXG5jb25zdCBBY2NvdW50Tm90aWZpY2F0aW9uUmVzdWx0ID0gdHlwZSh7XG4gIHN1YnNjcmlwdGlvbjogbnVtYmVyKCksXG4gIHJlc3VsdDogbm90aWZpY2F0aW9uUmVzdWx0QW5kQ29udGV4dChBY2NvdW50SW5mb1Jlc3VsdClcbn0pO1xuXG4vKipcbiAqIEBpbnRlcm5hbFxuICovXG5jb25zdCBQcm9ncmFtQWNjb3VudEluZm9SZXN1bHQgPSB0eXBlKHtcbiAgcHVia2V5OiBQdWJsaWNLZXlGcm9tU3RyaW5nLFxuICBhY2NvdW50OiBBY2NvdW50SW5mb1Jlc3VsdFxufSk7XG5cbi8qKipcbiAqIEV4cGVjdGVkIEpTT04gUlBDIHJlc3BvbnNlIGZvciB0aGUgXCJwcm9ncmFtTm90aWZpY2F0aW9uXCIgbWVzc2FnZVxuICovXG5jb25zdCBQcm9ncmFtQWNjb3VudE5vdGlmaWNhdGlvblJlc3VsdCA9IHR5cGUoe1xuICBzdWJzY3JpcHRpb246IG51bWJlcigpLFxuICByZXN1bHQ6IG5vdGlmaWNhdGlvblJlc3VsdEFuZENvbnRleHQoUHJvZ3JhbUFjY291bnRJbmZvUmVzdWx0KVxufSk7XG5cbi8qKlxuICogQGludGVybmFsXG4gKi9cbmNvbnN0IFNsb3RJbmZvUmVzdWx0ID0gdHlwZSh7XG4gIHBhcmVudDogbnVtYmVyKCksXG4gIHNsb3Q6IG51bWJlcigpLFxuICByb290OiBudW1iZXIoKVxufSk7XG5cbi8qKlxuICogRXhwZWN0ZWQgSlNPTiBSUEMgcmVzcG9uc2UgZm9yIHRoZSBcInNsb3ROb3RpZmljYXRpb25cIiBtZXNzYWdlXG4gKi9cbmNvbnN0IFNsb3ROb3RpZmljYXRpb25SZXN1bHQgPSB0eXBlKHtcbiAgc3Vic2NyaXB0aW9uOiBudW1iZXIoKSxcbiAgcmVzdWx0OiBTbG90SW5mb1Jlc3VsdFxufSk7XG5cbi8qKlxuICogU2xvdCB1cGRhdGVzIHdoaWNoIGNhbiBiZSB1c2VkIGZvciB0cmFja2luZyB0aGUgbGl2ZSBwcm9ncmVzcyBvZiBhIGNsdXN0ZXIuXG4gKiAtIGBcImZpcnN0U2hyZWRSZWNlaXZlZFwiYDogY29ubmVjdGVkIG5vZGUgcmVjZWl2ZWQgdGhlIGZpcnN0IHNocmVkIG9mIGEgYmxvY2suXG4gKiBJbmRpY2F0ZXMgdGhhdCBhIG5ldyBibG9jayB0aGF0IGlzIGJlaW5nIHByb2R1Y2VkLlxuICogLSBgXCJjb21wbGV0ZWRcImA6IGNvbm5lY3RlZCBub2RlIGhhcyByZWNlaXZlZCBhbGwgc2hyZWRzIG9mIGEgYmxvY2suIEluZGljYXRlc1xuICogYSBibG9jayB3YXMgcmVjZW50bHkgcHJvZHVjZWQuXG4gKiAtIGBcIm9wdGltaXN0aWNDb25maXJtYXRpb25cImA6IGJsb2NrIHdhcyBvcHRpbWlzdGljYWxseSBjb25maXJtZWQgYnkgdGhlXG4gKiBjbHVzdGVyLiBJdCBpcyBub3QgZ3VhcmFudGVlZCB0aGF0IGFuIG9wdGltaXN0aWMgY29uZmlybWF0aW9uIG5vdGlmaWNhdGlvblxuICogd2lsbCBiZSBzZW50IGZvciBldmVyeSBmaW5hbGl6ZWQgYmxvY2tzLlxuICogLSBgXCJyb290XCJgOiB0aGUgY29ubmVjdGVkIG5vZGUgcm9vdGVkIHRoaXMgYmxvY2suXG4gKiAtIGBcImNyZWF0ZWRCYW5rXCJgOiB0aGUgY29ubmVjdGVkIG5vZGUgaGFzIHN0YXJ0ZWQgdmFsaWRhdGluZyB0aGlzIGJsb2NrLlxuICogLSBgXCJmcm96ZW5cImA6IHRoZSBjb25uZWN0ZWQgbm9kZSBoYXMgdmFsaWRhdGVkIHRoaXMgYmxvY2suXG4gKiAtIGBcImRlYWRcImA6IHRoZSBjb25uZWN0ZWQgbm9kZSBmYWlsZWQgdG8gdmFsaWRhdGUgdGhpcyBibG9jay5cbiAqL1xuXG4vKipcbiAqIEBpbnRlcm5hbFxuICovXG5jb25zdCBTbG90VXBkYXRlUmVzdWx0ID0gdW5pb24oW3R5cGUoe1xuICB0eXBlOiB1bmlvbihbbGl0ZXJhbCgnZmlyc3RTaHJlZFJlY2VpdmVkJyksIGxpdGVyYWwoJ2NvbXBsZXRlZCcpLCBsaXRlcmFsKCdvcHRpbWlzdGljQ29uZmlybWF0aW9uJyksIGxpdGVyYWwoJ3Jvb3QnKV0pLFxuICBzbG90OiBudW1iZXIoKSxcbiAgdGltZXN0YW1wOiBudW1iZXIoKVxufSksIHR5cGUoe1xuICB0eXBlOiBsaXRlcmFsKCdjcmVhdGVkQmFuaycpLFxuICBwYXJlbnQ6IG51bWJlcigpLFxuICBzbG90OiBudW1iZXIoKSxcbiAgdGltZXN0YW1wOiBudW1iZXIoKVxufSksIHR5cGUoe1xuICB0eXBlOiBsaXRlcmFsKCdmcm96ZW4nKSxcbiAgc2xvdDogbnVtYmVyKCksXG4gIHRpbWVzdGFtcDogbnVtYmVyKCksXG4gIHN0YXRzOiB0eXBlKHtcbiAgICBudW1UcmFuc2FjdGlvbkVudHJpZXM6IG51bWJlcigpLFxuICAgIG51bVN1Y2Nlc3NmdWxUcmFuc2FjdGlvbnM6IG51bWJlcigpLFxuICAgIG51bUZhaWxlZFRyYW5zYWN0aW9uczogbnVtYmVyKCksXG4gICAgbWF4VHJhbnNhY3Rpb25zUGVyRW50cnk6IG51bWJlcigpXG4gIH0pXG59KSwgdHlwZSh7XG4gIHR5cGU6IGxpdGVyYWwoJ2RlYWQnKSxcbiAgc2xvdDogbnVtYmVyKCksXG4gIHRpbWVzdGFtcDogbnVtYmVyKCksXG4gIGVycjogc3RyaW5nKClcbn0pXSk7XG5cbi8qKlxuICogRXhwZWN0ZWQgSlNPTiBSUEMgcmVzcG9uc2UgZm9yIHRoZSBcInNsb3RzVXBkYXRlc05vdGlmaWNhdGlvblwiIG1lc3NhZ2VcbiAqL1xuY29uc3QgU2xvdFVwZGF0ZU5vdGlmaWNhdGlvblJlc3VsdCA9IHR5cGUoe1xuICBzdWJzY3JpcHRpb246IG51bWJlcigpLFxuICByZXN1bHQ6IFNsb3RVcGRhdGVSZXN1bHRcbn0pO1xuXG4vKipcbiAqIEV4cGVjdGVkIEpTT04gUlBDIHJlc3BvbnNlIGZvciB0aGUgXCJzaWduYXR1cmVOb3RpZmljYXRpb25cIiBtZXNzYWdlXG4gKi9cbmNvbnN0IFNpZ25hdHVyZU5vdGlmaWNhdGlvblJlc3VsdCA9IHR5cGUoe1xuICBzdWJzY3JpcHRpb246IG51bWJlcigpLFxuICByZXN1bHQ6IG5vdGlmaWNhdGlvblJlc3VsdEFuZENvbnRleHQodW5pb24oW1NpZ25hdHVyZVN0YXR1c1Jlc3VsdCwgU2lnbmF0dXJlUmVjZWl2ZWRSZXN1bHRdKSlcbn0pO1xuXG4vKipcbiAqIEV4cGVjdGVkIEpTT04gUlBDIHJlc3BvbnNlIGZvciB0aGUgXCJyb290Tm90aWZpY2F0aW9uXCIgbWVzc2FnZVxuICovXG5jb25zdCBSb290Tm90aWZpY2F0aW9uUmVzdWx0ID0gdHlwZSh7XG4gIHN1YnNjcmlwdGlvbjogbnVtYmVyKCksXG4gIHJlc3VsdDogbnVtYmVyKClcbn0pO1xuY29uc3QgQ29udGFjdEluZm9SZXN1bHQgPSB0eXBlKHtcbiAgcHVia2V5OiBzdHJpbmcoKSxcbiAgZ29zc2lwOiBudWxsYWJsZShzdHJpbmcoKSksXG4gIHRwdTogbnVsbGFibGUoc3RyaW5nKCkpLFxuICBycGM6IG51bGxhYmxlKHN0cmluZygpKSxcbiAgdmVyc2lvbjogbnVsbGFibGUoc3RyaW5nKCkpXG59KTtcbmNvbnN0IFZvdGVBY2NvdW50SW5mb1Jlc3VsdCA9IHR5cGUoe1xuICB2b3RlUHVia2V5OiBzdHJpbmcoKSxcbiAgbm9kZVB1YmtleTogc3RyaW5nKCksXG4gIGFjdGl2YXRlZFN0YWtlOiBudW1iZXIoKSxcbiAgZXBvY2hWb3RlQWNjb3VudDogYm9vbGVhbigpLFxuICBlcG9jaENyZWRpdHM6IGFycmF5KHR1cGxlKFtudW1iZXIoKSwgbnVtYmVyKCksIG51bWJlcigpXSkpLFxuICBjb21taXNzaW9uOiBudW1iZXIoKSxcbiAgbGFzdFZvdGU6IG51bWJlcigpLFxuICByb290U2xvdDogbnVsbGFibGUobnVtYmVyKCkpXG59KTtcblxuLyoqXG4gKiBFeHBlY3RlZCBKU09OIFJQQyByZXNwb25zZSBmb3IgdGhlIFwiZ2V0Vm90ZUFjY291bnRzXCIgbWVzc2FnZVxuICovXG5jb25zdCBHZXRWb3RlQWNjb3VudHMgPSBqc29uUnBjUmVzdWx0KHR5cGUoe1xuICBjdXJyZW50OiBhcnJheShWb3RlQWNjb3VudEluZm9SZXN1bHQpLFxuICBkZWxpbnF1ZW50OiBhcnJheShWb3RlQWNjb3VudEluZm9SZXN1bHQpXG59KSk7XG5jb25zdCBDb25maXJtYXRpb25TdGF0dXMgPSB1bmlvbihbbGl0ZXJhbCgncHJvY2Vzc2VkJyksIGxpdGVyYWwoJ2NvbmZpcm1lZCcpLCBsaXRlcmFsKCdmaW5hbGl6ZWQnKV0pO1xuY29uc3QgU2lnbmF0dXJlU3RhdHVzUmVzcG9uc2UgPSB0eXBlKHtcbiAgc2xvdDogbnVtYmVyKCksXG4gIGNvbmZpcm1hdGlvbnM6IG51bGxhYmxlKG51bWJlcigpKSxcbiAgZXJyOiBUcmFuc2FjdGlvbkVycm9yUmVzdWx0LFxuICBjb25maXJtYXRpb25TdGF0dXM6IG9wdGlvbmFsKENvbmZpcm1hdGlvblN0YXR1cylcbn0pO1xuXG4vKipcbiAqIEV4cGVjdGVkIEpTT04gUlBDIHJlc3BvbnNlIGZvciB0aGUgXCJnZXRTaWduYXR1cmVTdGF0dXNlc1wiIG1lc3NhZ2VcbiAqL1xuY29uc3QgR2V0U2lnbmF0dXJlU3RhdHVzZXNScGNSZXN1bHQgPSBqc29uUnBjUmVzdWx0QW5kQ29udGV4dChhcnJheShudWxsYWJsZShTaWduYXR1cmVTdGF0dXNSZXNwb25zZSkpKTtcblxuLyoqXG4gKiBFeHBlY3RlZCBKU09OIFJQQyByZXNwb25zZSBmb3IgdGhlIFwiZ2V0TWluaW11bUJhbGFuY2VGb3JSZW50RXhlbXB0aW9uXCIgbWVzc2FnZVxuICovXG5jb25zdCBHZXRNaW5pbXVtQmFsYW5jZUZvclJlbnRFeGVtcHRpb25ScGNSZXN1bHQgPSBqc29uUnBjUmVzdWx0KG51bWJlcigpKTtcbmNvbnN0IEFkZHJlc3NUYWJsZUxvb2t1cFN0cnVjdCA9IHR5cGUoe1xuICBhY2NvdW50S2V5OiBQdWJsaWNLZXlGcm9tU3RyaW5nLFxuICB3cml0YWJsZUluZGV4ZXM6IGFycmF5KG51bWJlcigpKSxcbiAgcmVhZG9ubHlJbmRleGVzOiBhcnJheShudW1iZXIoKSlcbn0pO1xuY29uc3QgQ29uZmlybWVkVHJhbnNhY3Rpb25SZXN1bHQgPSB0eXBlKHtcbiAgc2lnbmF0dXJlczogYXJyYXkoc3RyaW5nKCkpLFxuICBtZXNzYWdlOiB0eXBlKHtcbiAgICBhY2NvdW50S2V5czogYXJyYXkoc3RyaW5nKCkpLFxuICAgIGhlYWRlcjogdHlwZSh7XG4gICAgICBudW1SZXF1aXJlZFNpZ25hdHVyZXM6IG51bWJlcigpLFxuICAgICAgbnVtUmVhZG9ubHlTaWduZWRBY2NvdW50czogbnVtYmVyKCksXG4gICAgICBudW1SZWFkb25seVVuc2lnbmVkQWNjb3VudHM6IG51bWJlcigpXG4gICAgfSksXG4gICAgaW5zdHJ1Y3Rpb25zOiBhcnJheSh0eXBlKHtcbiAgICAgIGFjY291bnRzOiBhcnJheShudW1iZXIoKSksXG4gICAgICBkYXRhOiBzdHJpbmcoKSxcbiAgICAgIHByb2dyYW1JZEluZGV4OiBudW1iZXIoKVxuICAgIH0pKSxcbiAgICByZWNlbnRCbG9ja2hhc2g6IHN0cmluZygpLFxuICAgIGFkZHJlc3NUYWJsZUxvb2t1cHM6IG9wdGlvbmFsKGFycmF5KEFkZHJlc3NUYWJsZUxvb2t1cFN0cnVjdCkpXG4gIH0pXG59KTtcbmNvbnN0IEFubm90YXRlZEFjY291bnRLZXkgPSB0eXBlKHtcbiAgcHVia2V5OiBQdWJsaWNLZXlGcm9tU3RyaW5nLFxuICBzaWduZXI6IGJvb2xlYW4oKSxcbiAgd3JpdGFibGU6IGJvb2xlYW4oKSxcbiAgc291cmNlOiBvcHRpb25hbCh1bmlvbihbbGl0ZXJhbCgndHJhbnNhY3Rpb24nKSwgbGl0ZXJhbCgnbG9va3VwVGFibGUnKV0pKVxufSk7XG5jb25zdCBDb25maXJtZWRUcmFuc2FjdGlvbkFjY291bnRzTW9kZVJlc3VsdCA9IHR5cGUoe1xuICBhY2NvdW50S2V5czogYXJyYXkoQW5ub3RhdGVkQWNjb3VudEtleSksXG4gIHNpZ25hdHVyZXM6IGFycmF5KHN0cmluZygpKVxufSk7XG5jb25zdCBQYXJzZWRJbnN0cnVjdGlvblJlc3VsdCA9IHR5cGUoe1xuICBwYXJzZWQ6IHVua25vd24oKSxcbiAgcHJvZ3JhbTogc3RyaW5nKCksXG4gIHByb2dyYW1JZDogUHVibGljS2V5RnJvbVN0cmluZ1xufSk7XG5jb25zdCBSYXdJbnN0cnVjdGlvblJlc3VsdCA9IHR5cGUoe1xuICBhY2NvdW50czogYXJyYXkoUHVibGljS2V5RnJvbVN0cmluZyksXG4gIGRhdGE6IHN0cmluZygpLFxuICBwcm9ncmFtSWQ6IFB1YmxpY0tleUZyb21TdHJpbmdcbn0pO1xuY29uc3QgSW5zdHJ1Y3Rpb25SZXN1bHQgPSB1bmlvbihbUmF3SW5zdHJ1Y3Rpb25SZXN1bHQsIFBhcnNlZEluc3RydWN0aW9uUmVzdWx0XSk7XG5jb25zdCBVbmtub3duSW5zdHJ1Y3Rpb25SZXN1bHQgPSB1bmlvbihbdHlwZSh7XG4gIHBhcnNlZDogdW5rbm93bigpLFxuICBwcm9ncmFtOiBzdHJpbmcoKSxcbiAgcHJvZ3JhbUlkOiBzdHJpbmcoKVxufSksIHR5cGUoe1xuICBhY2NvdW50czogYXJyYXkoc3RyaW5nKCkpLFxuICBkYXRhOiBzdHJpbmcoKSxcbiAgcHJvZ3JhbUlkOiBzdHJpbmcoKVxufSldKTtcbmNvbnN0IFBhcnNlZE9yUmF3SW5zdHJ1Y3Rpb24gPSBjb2VyY2UoSW5zdHJ1Y3Rpb25SZXN1bHQsIFVua25vd25JbnN0cnVjdGlvblJlc3VsdCwgdmFsdWUgPT4ge1xuICBpZiAoJ2FjY291bnRzJyBpbiB2YWx1ZSkge1xuICAgIHJldHVybiBjcmVhdGUodmFsdWUsIFJhd0luc3RydWN0aW9uUmVzdWx0KTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gY3JlYXRlKHZhbHVlLCBQYXJzZWRJbnN0cnVjdGlvblJlc3VsdCk7XG4gIH1cbn0pO1xuXG4vKipcbiAqIEBpbnRlcm5hbFxuICovXG5jb25zdCBQYXJzZWRDb25maXJtZWRUcmFuc2FjdGlvblJlc3VsdCA9IHR5cGUoe1xuICBzaWduYXR1cmVzOiBhcnJheShzdHJpbmcoKSksXG4gIG1lc3NhZ2U6IHR5cGUoe1xuICAgIGFjY291bnRLZXlzOiBhcnJheShBbm5vdGF0ZWRBY2NvdW50S2V5KSxcbiAgICBpbnN0cnVjdGlvbnM6IGFycmF5KFBhcnNlZE9yUmF3SW5zdHJ1Y3Rpb24pLFxuICAgIHJlY2VudEJsb2NraGFzaDogc3RyaW5nKCksXG4gICAgYWRkcmVzc1RhYmxlTG9va3Vwczogb3B0aW9uYWwobnVsbGFibGUoYXJyYXkoQWRkcmVzc1RhYmxlTG9va3VwU3RydWN0KSkpXG4gIH0pXG59KTtcbmNvbnN0IFRva2VuQmFsYW5jZVJlc3VsdCA9IHR5cGUoe1xuICBhY2NvdW50SW5kZXg6IG51bWJlcigpLFxuICBtaW50OiBzdHJpbmcoKSxcbiAgb3duZXI6IG9wdGlvbmFsKHN0cmluZygpKSxcbiAgdWlUb2tlbkFtb3VudDogVG9rZW5BbW91bnRSZXN1bHRcbn0pO1xuY29uc3QgTG9hZGVkQWRkcmVzc2VzUmVzdWx0ID0gdHlwZSh7XG4gIHdyaXRhYmxlOiBhcnJheShQdWJsaWNLZXlGcm9tU3RyaW5nKSxcbiAgcmVhZG9ubHk6IGFycmF5KFB1YmxpY0tleUZyb21TdHJpbmcpXG59KTtcblxuLyoqXG4gKiBAaW50ZXJuYWxcbiAqL1xuY29uc3QgQ29uZmlybWVkVHJhbnNhY3Rpb25NZXRhUmVzdWx0ID0gdHlwZSh7XG4gIGVycjogVHJhbnNhY3Rpb25FcnJvclJlc3VsdCxcbiAgZmVlOiBudW1iZXIoKSxcbiAgaW5uZXJJbnN0cnVjdGlvbnM6IG9wdGlvbmFsKG51bGxhYmxlKGFycmF5KHR5cGUoe1xuICAgIGluZGV4OiBudW1iZXIoKSxcbiAgICBpbnN0cnVjdGlvbnM6IGFycmF5KHR5cGUoe1xuICAgICAgYWNjb3VudHM6IGFycmF5KG51bWJlcigpKSxcbiAgICAgIGRhdGE6IHN0cmluZygpLFxuICAgICAgcHJvZ3JhbUlkSW5kZXg6IG51bWJlcigpXG4gICAgfSkpXG4gIH0pKSkpLFxuICBwcmVCYWxhbmNlczogYXJyYXkobnVtYmVyKCkpLFxuICBwb3N0QmFsYW5jZXM6IGFycmF5KG51bWJlcigpKSxcbiAgbG9nTWVzc2FnZXM6IG9wdGlvbmFsKG51bGxhYmxlKGFycmF5KHN0cmluZygpKSkpLFxuICBwcmVUb2tlbkJhbGFuY2VzOiBvcHRpb25hbChudWxsYWJsZShhcnJheShUb2tlbkJhbGFuY2VSZXN1bHQpKSksXG4gIHBvc3RUb2tlbkJhbGFuY2VzOiBvcHRpb25hbChudWxsYWJsZShhcnJheShUb2tlbkJhbGFuY2VSZXN1bHQpKSksXG4gIGxvYWRlZEFkZHJlc3Nlczogb3B0aW9uYWwoTG9hZGVkQWRkcmVzc2VzUmVzdWx0KSxcbiAgY29tcHV0ZVVuaXRzQ29uc3VtZWQ6IG9wdGlvbmFsKG51bWJlcigpKVxufSk7XG5cbi8qKlxuICogQGludGVybmFsXG4gKi9cbmNvbnN0IFBhcnNlZENvbmZpcm1lZFRyYW5zYWN0aW9uTWV0YVJlc3VsdCA9IHR5cGUoe1xuICBlcnI6IFRyYW5zYWN0aW9uRXJyb3JSZXN1bHQsXG4gIGZlZTogbnVtYmVyKCksXG4gIGlubmVySW5zdHJ1Y3Rpb25zOiBvcHRpb25hbChudWxsYWJsZShhcnJheSh0eXBlKHtcbiAgICBpbmRleDogbnVtYmVyKCksXG4gICAgaW5zdHJ1Y3Rpb25zOiBhcnJheShQYXJzZWRPclJhd0luc3RydWN0aW9uKVxuICB9KSkpKSxcbiAgcHJlQmFsYW5jZXM6IGFycmF5KG51bWJlcigpKSxcbiAgcG9zdEJhbGFuY2VzOiBhcnJheShudW1iZXIoKSksXG4gIGxvZ01lc3NhZ2VzOiBvcHRpb25hbChudWxsYWJsZShhcnJheShzdHJpbmcoKSkpKSxcbiAgcHJlVG9rZW5CYWxhbmNlczogb3B0aW9uYWwobnVsbGFibGUoYXJyYXkoVG9rZW5CYWxhbmNlUmVzdWx0KSkpLFxuICBwb3N0VG9rZW5CYWxhbmNlczogb3B0aW9uYWwobnVsbGFibGUoYXJyYXkoVG9rZW5CYWxhbmNlUmVzdWx0KSkpLFxuICBsb2FkZWRBZGRyZXNzZXM6IG9wdGlvbmFsKExvYWRlZEFkZHJlc3Nlc1Jlc3VsdCksXG4gIGNvbXB1dGVVbml0c0NvbnN1bWVkOiBvcHRpb25hbChudW1iZXIoKSlcbn0pO1xuY29uc3QgVHJhbnNhY3Rpb25WZXJzaW9uU3RydWN0ID0gdW5pb24oW2xpdGVyYWwoMCksIGxpdGVyYWwoJ2xlZ2FjeScpXSk7XG5cbi8qKiBAaW50ZXJuYWwgKi9cbmNvbnN0IFJld2FyZHNSZXN1bHQgPSB0eXBlKHtcbiAgcHVia2V5OiBzdHJpbmcoKSxcbiAgbGFtcG9ydHM6IG51bWJlcigpLFxuICBwb3N0QmFsYW5jZTogbnVsbGFibGUobnVtYmVyKCkpLFxuICByZXdhcmRUeXBlOiBudWxsYWJsZShzdHJpbmcoKSksXG4gIGNvbW1pc3Npb246IG9wdGlvbmFsKG51bGxhYmxlKG51bWJlcigpKSlcbn0pO1xuXG4vKipcbiAqIEV4cGVjdGVkIEpTT04gUlBDIHJlc3BvbnNlIGZvciB0aGUgXCJnZXRCbG9ja1wiIG1lc3NhZ2VcbiAqL1xuY29uc3QgR2V0QmxvY2tScGNSZXN1bHQgPSBqc29uUnBjUmVzdWx0KG51bGxhYmxlKHR5cGUoe1xuICBibG9ja2hhc2g6IHN0cmluZygpLFxuICBwcmV2aW91c0Jsb2NraGFzaDogc3RyaW5nKCksXG4gIHBhcmVudFNsb3Q6IG51bWJlcigpLFxuICB0cmFuc2FjdGlvbnM6IGFycmF5KHR5cGUoe1xuICAgIHRyYW5zYWN0aW9uOiBDb25maXJtZWRUcmFuc2FjdGlvblJlc3VsdCxcbiAgICBtZXRhOiBudWxsYWJsZShDb25maXJtZWRUcmFuc2FjdGlvbk1ldGFSZXN1bHQpLFxuICAgIHZlcnNpb246IG9wdGlvbmFsKFRyYW5zYWN0aW9uVmVyc2lvblN0cnVjdClcbiAgfSkpLFxuICByZXdhcmRzOiBvcHRpb25hbChhcnJheShSZXdhcmRzUmVzdWx0KSksXG4gIGJsb2NrVGltZTogbnVsbGFibGUobnVtYmVyKCkpLFxuICBibG9ja0hlaWdodDogbnVsbGFibGUobnVtYmVyKCkpXG59KSkpO1xuXG4vKipcbiAqIEV4cGVjdGVkIEpTT04gUlBDIHJlc3BvbnNlIGZvciB0aGUgXCJnZXRCbG9ja1wiIG1lc3NhZ2Ugd2hlbiBgdHJhbnNhY3Rpb25EZXRhaWxzYCBpcyBgbm9uZWBcbiAqL1xuY29uc3QgR2V0Tm9uZU1vZGVCbG9ja1JwY1Jlc3VsdCA9IGpzb25ScGNSZXN1bHQobnVsbGFibGUodHlwZSh7XG4gIGJsb2NraGFzaDogc3RyaW5nKCksXG4gIHByZXZpb3VzQmxvY2toYXNoOiBzdHJpbmcoKSxcbiAgcGFyZW50U2xvdDogbnVtYmVyKCksXG4gIHJld2FyZHM6IG9wdGlvbmFsKGFycmF5KFJld2FyZHNSZXN1bHQpKSxcbiAgYmxvY2tUaW1lOiBudWxsYWJsZShudW1iZXIoKSksXG4gIGJsb2NrSGVpZ2h0OiBudWxsYWJsZShudW1iZXIoKSlcbn0pKSk7XG5cbi8qKlxuICogRXhwZWN0ZWQgSlNPTiBSUEMgcmVzcG9uc2UgZm9yIHRoZSBcImdldEJsb2NrXCIgbWVzc2FnZSB3aGVuIGB0cmFuc2FjdGlvbkRldGFpbHNgIGlzIGBhY2NvdW50c2BcbiAqL1xuY29uc3QgR2V0QWNjb3VudHNNb2RlQmxvY2tScGNSZXN1bHQgPSBqc29uUnBjUmVzdWx0KG51bGxhYmxlKHR5cGUoe1xuICBibG9ja2hhc2g6IHN0cmluZygpLFxuICBwcmV2aW91c0Jsb2NraGFzaDogc3RyaW5nKCksXG4gIHBhcmVudFNsb3Q6IG51bWJlcigpLFxuICB0cmFuc2FjdGlvbnM6IGFycmF5KHR5cGUoe1xuICAgIHRyYW5zYWN0aW9uOiBDb25maXJtZWRUcmFuc2FjdGlvbkFjY291bnRzTW9kZVJlc3VsdCxcbiAgICBtZXRhOiBudWxsYWJsZShDb25maXJtZWRUcmFuc2FjdGlvbk1ldGFSZXN1bHQpLFxuICAgIHZlcnNpb246IG9wdGlvbmFsKFRyYW5zYWN0aW9uVmVyc2lvblN0cnVjdClcbiAgfSkpLFxuICByZXdhcmRzOiBvcHRpb25hbChhcnJheShSZXdhcmRzUmVzdWx0KSksXG4gIGJsb2NrVGltZTogbnVsbGFibGUobnVtYmVyKCkpLFxuICBibG9ja0hlaWdodDogbnVsbGFibGUobnVtYmVyKCkpXG59KSkpO1xuXG4vKipcbiAqIEV4cGVjdGVkIHBhcnNlZCBKU09OIFJQQyByZXNwb25zZSBmb3IgdGhlIFwiZ2V0QmxvY2tcIiBtZXNzYWdlXG4gKi9cbmNvbnN0IEdldFBhcnNlZEJsb2NrUnBjUmVzdWx0ID0ganNvblJwY1Jlc3VsdChudWxsYWJsZSh0eXBlKHtcbiAgYmxvY2toYXNoOiBzdHJpbmcoKSxcbiAgcHJldmlvdXNCbG9ja2hhc2g6IHN0cmluZygpLFxuICBwYXJlbnRTbG90OiBudW1iZXIoKSxcbiAgdHJhbnNhY3Rpb25zOiBhcnJheSh0eXBlKHtcbiAgICB0cmFuc2FjdGlvbjogUGFyc2VkQ29uZmlybWVkVHJhbnNhY3Rpb25SZXN1bHQsXG4gICAgbWV0YTogbnVsbGFibGUoUGFyc2VkQ29uZmlybWVkVHJhbnNhY3Rpb25NZXRhUmVzdWx0KSxcbiAgICB2ZXJzaW9uOiBvcHRpb25hbChUcmFuc2FjdGlvblZlcnNpb25TdHJ1Y3QpXG4gIH0pKSxcbiAgcmV3YXJkczogb3B0aW9uYWwoYXJyYXkoUmV3YXJkc1Jlc3VsdCkpLFxuICBibG9ja1RpbWU6IG51bGxhYmxlKG51bWJlcigpKSxcbiAgYmxvY2tIZWlnaHQ6IG51bGxhYmxlKG51bWJlcigpKVxufSkpKTtcblxuLyoqXG4gKiBFeHBlY3RlZCBwYXJzZWQgSlNPTiBSUEMgcmVzcG9uc2UgZm9yIHRoZSBcImdldEJsb2NrXCIgbWVzc2FnZSAgd2hlbiBgdHJhbnNhY3Rpb25EZXRhaWxzYCBpcyBgYWNjb3VudHNgXG4gKi9cbmNvbnN0IEdldFBhcnNlZEFjY291bnRzTW9kZUJsb2NrUnBjUmVzdWx0ID0ganNvblJwY1Jlc3VsdChudWxsYWJsZSh0eXBlKHtcbiAgYmxvY2toYXNoOiBzdHJpbmcoKSxcbiAgcHJldmlvdXNCbG9ja2hhc2g6IHN0cmluZygpLFxuICBwYXJlbnRTbG90OiBudW1iZXIoKSxcbiAgdHJhbnNhY3Rpb25zOiBhcnJheSh0eXBlKHtcbiAgICB0cmFuc2FjdGlvbjogQ29uZmlybWVkVHJhbnNhY3Rpb25BY2NvdW50c01vZGVSZXN1bHQsXG4gICAgbWV0YTogbnVsbGFibGUoUGFyc2VkQ29uZmlybWVkVHJhbnNhY3Rpb25NZXRhUmVzdWx0KSxcbiAgICB2ZXJzaW9uOiBvcHRpb25hbChUcmFuc2FjdGlvblZlcnNpb25TdHJ1Y3QpXG4gIH0pKSxcbiAgcmV3YXJkczogb3B0aW9uYWwoYXJyYXkoUmV3YXJkc1Jlc3VsdCkpLFxuICBibG9ja1RpbWU6IG51bGxhYmxlKG51bWJlcigpKSxcbiAgYmxvY2tIZWlnaHQ6IG51bGxhYmxlKG51bWJlcigpKVxufSkpKTtcblxuLyoqXG4gKiBFeHBlY3RlZCBwYXJzZWQgSlNPTiBSUEMgcmVzcG9uc2UgZm9yIHRoZSBcImdldEJsb2NrXCIgbWVzc2FnZSAgd2hlbiBgdHJhbnNhY3Rpb25EZXRhaWxzYCBpcyBgbm9uZWBcbiAqL1xuY29uc3QgR2V0UGFyc2VkTm9uZU1vZGVCbG9ja1JwY1Jlc3VsdCA9IGpzb25ScGNSZXN1bHQobnVsbGFibGUodHlwZSh7XG4gIGJsb2NraGFzaDogc3RyaW5nKCksXG4gIHByZXZpb3VzQmxvY2toYXNoOiBzdHJpbmcoKSxcbiAgcGFyZW50U2xvdDogbnVtYmVyKCksXG4gIHJld2FyZHM6IG9wdGlvbmFsKGFycmF5KFJld2FyZHNSZXN1bHQpKSxcbiAgYmxvY2tUaW1lOiBudWxsYWJsZShudW1iZXIoKSksXG4gIGJsb2NrSGVpZ2h0OiBudWxsYWJsZShudW1iZXIoKSlcbn0pKSk7XG5cbi8qKlxuICogRXhwZWN0ZWQgSlNPTiBSUEMgcmVzcG9uc2UgZm9yIHRoZSBcImdldENvbmZpcm1lZEJsb2NrXCIgbWVzc2FnZVxuICpcbiAqIEBkZXByZWNhdGVkIERlcHJlY2F0ZWQgc2luY2UgU29sYW5hIHYxLjguMC4gUGxlYXNlIHVzZSB7QGxpbmsgR2V0QmxvY2tScGNSZXN1bHR9IGluc3RlYWQuXG4gKi9cbmNvbnN0IEdldENvbmZpcm1lZEJsb2NrUnBjUmVzdWx0ID0ganNvblJwY1Jlc3VsdChudWxsYWJsZSh0eXBlKHtcbiAgYmxvY2toYXNoOiBzdHJpbmcoKSxcbiAgcHJldmlvdXNCbG9ja2hhc2g6IHN0cmluZygpLFxuICBwYXJlbnRTbG90OiBudW1iZXIoKSxcbiAgdHJhbnNhY3Rpb25zOiBhcnJheSh0eXBlKHtcbiAgICB0cmFuc2FjdGlvbjogQ29uZmlybWVkVHJhbnNhY3Rpb25SZXN1bHQsXG4gICAgbWV0YTogbnVsbGFibGUoQ29uZmlybWVkVHJhbnNhY3Rpb25NZXRhUmVzdWx0KVxuICB9KSksXG4gIHJld2FyZHM6IG9wdGlvbmFsKGFycmF5KFJld2FyZHNSZXN1bHQpKSxcbiAgYmxvY2tUaW1lOiBudWxsYWJsZShudW1iZXIoKSlcbn0pKSk7XG5cbi8qKlxuICogRXhwZWN0ZWQgSlNPTiBSUEMgcmVzcG9uc2UgZm9yIHRoZSBcImdldEJsb2NrXCIgbWVzc2FnZVxuICovXG5jb25zdCBHZXRCbG9ja1NpZ25hdHVyZXNScGNSZXN1bHQgPSBqc29uUnBjUmVzdWx0KG51bGxhYmxlKHR5cGUoe1xuICBibG9ja2hhc2g6IHN0cmluZygpLFxuICBwcmV2aW91c0Jsb2NraGFzaDogc3RyaW5nKCksXG4gIHBhcmVudFNsb3Q6IG51bWJlcigpLFxuICBzaWduYXR1cmVzOiBhcnJheShzdHJpbmcoKSksXG4gIGJsb2NrVGltZTogbnVsbGFibGUobnVtYmVyKCkpXG59KSkpO1xuXG4vKipcbiAqIEV4cGVjdGVkIEpTT04gUlBDIHJlc3BvbnNlIGZvciB0aGUgXCJnZXRUcmFuc2FjdGlvblwiIG1lc3NhZ2VcbiAqL1xuY29uc3QgR2V0VHJhbnNhY3Rpb25ScGNSZXN1bHQgPSBqc29uUnBjUmVzdWx0KG51bGxhYmxlKHR5cGUoe1xuICBzbG90OiBudW1iZXIoKSxcbiAgbWV0YTogbnVsbGFibGUoQ29uZmlybWVkVHJhbnNhY3Rpb25NZXRhUmVzdWx0KSxcbiAgYmxvY2tUaW1lOiBvcHRpb25hbChudWxsYWJsZShudW1iZXIoKSkpLFxuICB0cmFuc2FjdGlvbjogQ29uZmlybWVkVHJhbnNhY3Rpb25SZXN1bHQsXG4gIHZlcnNpb246IG9wdGlvbmFsKFRyYW5zYWN0aW9uVmVyc2lvblN0cnVjdClcbn0pKSk7XG5cbi8qKlxuICogRXhwZWN0ZWQgcGFyc2VkIEpTT04gUlBDIHJlc3BvbnNlIGZvciB0aGUgXCJnZXRUcmFuc2FjdGlvblwiIG1lc3NhZ2VcbiAqL1xuY29uc3QgR2V0UGFyc2VkVHJhbnNhY3Rpb25ScGNSZXN1bHQgPSBqc29uUnBjUmVzdWx0KG51bGxhYmxlKHR5cGUoe1xuICBzbG90OiBudW1iZXIoKSxcbiAgdHJhbnNhY3Rpb246IFBhcnNlZENvbmZpcm1lZFRyYW5zYWN0aW9uUmVzdWx0LFxuICBtZXRhOiBudWxsYWJsZShQYXJzZWRDb25maXJtZWRUcmFuc2FjdGlvbk1ldGFSZXN1bHQpLFxuICBibG9ja1RpbWU6IG9wdGlvbmFsKG51bGxhYmxlKG51bWJlcigpKSksXG4gIHZlcnNpb246IG9wdGlvbmFsKFRyYW5zYWN0aW9uVmVyc2lvblN0cnVjdClcbn0pKSk7XG5cbi8qKlxuICogRXhwZWN0ZWQgSlNPTiBSUEMgcmVzcG9uc2UgZm9yIHRoZSBcImdldFJlY2VudEJsb2NraGFzaFwiIG1lc3NhZ2VcbiAqXG4gKiBAZGVwcmVjYXRlZCBEZXByZWNhdGVkIHNpbmNlIFNvbGFuYSB2MS44LjAuIFBsZWFzZSB1c2Uge0BsaW5rIEdldExhdGVzdEJsb2NraGFzaFJwY1Jlc3VsdH0gaW5zdGVhZC5cbiAqL1xuY29uc3QgR2V0UmVjZW50QmxvY2toYXNoQW5kQ29udGV4dFJwY1Jlc3VsdCA9IGpzb25ScGNSZXN1bHRBbmRDb250ZXh0KHR5cGUoe1xuICBibG9ja2hhc2g6IHN0cmluZygpLFxuICBmZWVDYWxjdWxhdG9yOiB0eXBlKHtcbiAgICBsYW1wb3J0c1BlclNpZ25hdHVyZTogbnVtYmVyKClcbiAgfSlcbn0pKTtcblxuLyoqXG4gKiBFeHBlY3RlZCBKU09OIFJQQyByZXNwb25zZSBmb3IgdGhlIFwiZ2V0TGF0ZXN0QmxvY2toYXNoXCIgbWVzc2FnZVxuICovXG5jb25zdCBHZXRMYXRlc3RCbG9ja2hhc2hScGNSZXN1bHQgPSBqc29uUnBjUmVzdWx0QW5kQ29udGV4dCh0eXBlKHtcbiAgYmxvY2toYXNoOiBzdHJpbmcoKSxcbiAgbGFzdFZhbGlkQmxvY2tIZWlnaHQ6IG51bWJlcigpXG59KSk7XG5cbi8qKlxuICogRXhwZWN0ZWQgSlNPTiBSUEMgcmVzcG9uc2UgZm9yIHRoZSBcImlzQmxvY2toYXNoVmFsaWRcIiBtZXNzYWdlXG4gKi9cbmNvbnN0IElzQmxvY2toYXNoVmFsaWRScGNSZXN1bHQgPSBqc29uUnBjUmVzdWx0QW5kQ29udGV4dChib29sZWFuKCkpO1xuY29uc3QgUGVyZlNhbXBsZVJlc3VsdCA9IHR5cGUoe1xuICBzbG90OiBudW1iZXIoKSxcbiAgbnVtVHJhbnNhY3Rpb25zOiBudW1iZXIoKSxcbiAgbnVtU2xvdHM6IG51bWJlcigpLFxuICBzYW1wbGVQZXJpb2RTZWNzOiBudW1iZXIoKVxufSk7XG5cbi8qXG4gKiBFeHBlY3RlZCBKU09OIFJQQyByZXNwb25zZSBmb3IgXCJnZXRSZWNlbnRQZXJmb3JtYW5jZVNhbXBsZXNcIiBtZXNzYWdlXG4gKi9cbmNvbnN0IEdldFJlY2VudFBlcmZvcm1hbmNlU2FtcGxlc1JwY1Jlc3VsdCA9IGpzb25ScGNSZXN1bHQoYXJyYXkoUGVyZlNhbXBsZVJlc3VsdCkpO1xuXG4vKipcbiAqIEV4cGVjdGVkIEpTT04gUlBDIHJlc3BvbnNlIGZvciB0aGUgXCJnZXRGZWVDYWxjdWxhdG9yRm9yQmxvY2toYXNoXCIgbWVzc2FnZVxuICovXG5jb25zdCBHZXRGZWVDYWxjdWxhdG9yUnBjUmVzdWx0ID0ganNvblJwY1Jlc3VsdEFuZENvbnRleHQobnVsbGFibGUodHlwZSh7XG4gIGZlZUNhbGN1bGF0b3I6IHR5cGUoe1xuICAgIGxhbXBvcnRzUGVyU2lnbmF0dXJlOiBudW1iZXIoKVxuICB9KVxufSkpKTtcblxuLyoqXG4gKiBFeHBlY3RlZCBKU09OIFJQQyByZXNwb25zZSBmb3IgdGhlIFwicmVxdWVzdEFpcmRyb3BcIiBtZXNzYWdlXG4gKi9cbmNvbnN0IFJlcXVlc3RBaXJkcm9wUnBjUmVzdWx0ID0ganNvblJwY1Jlc3VsdChzdHJpbmcoKSk7XG5cbi8qKlxuICogRXhwZWN0ZWQgSlNPTiBSUEMgcmVzcG9uc2UgZm9yIHRoZSBcInNlbmRUcmFuc2FjdGlvblwiIG1lc3NhZ2VcbiAqL1xuY29uc3QgU2VuZFRyYW5zYWN0aW9uUnBjUmVzdWx0ID0ganNvblJwY1Jlc3VsdChzdHJpbmcoKSk7XG5cbi8qKlxuICogSW5mb3JtYXRpb24gYWJvdXQgdGhlIGxhdGVzdCBzbG90IGJlaW5nIHByb2Nlc3NlZCBieSBhIG5vZGVcbiAqL1xuXG4vKipcbiAqIFBhcnNlZCBhY2NvdW50IGRhdGFcbiAqL1xuXG4vKipcbiAqIFN0YWtlIEFjdGl2YXRpb24gZGF0YVxuICovXG5cbi8qKlxuICogRGF0YSBzbGljZSBhcmd1bWVudCBmb3IgZ2V0UHJvZ3JhbUFjY291bnRzXG4gKi9cblxuLyoqXG4gKiBNZW1vcnkgY29tcGFyaXNvbiBmaWx0ZXIgZm9yIGdldFByb2dyYW1BY2NvdW50c1xuICovXG5cbi8qKlxuICogRGF0YSBzaXplIGNvbXBhcmlzb24gZmlsdGVyIGZvciBnZXRQcm9ncmFtQWNjb3VudHNcbiAqL1xuXG4vKipcbiAqIEEgZmlsdGVyIG9iamVjdCBmb3IgZ2V0UHJvZ3JhbUFjY291bnRzXG4gKi9cblxuLyoqXG4gKiBDb25maWd1cmF0aW9uIG9iamVjdCBmb3IgZ2V0UHJvZ3JhbUFjY291bnRzIHJlcXVlc3RzXG4gKi9cblxuLyoqXG4gKiBDb25maWd1cmF0aW9uIG9iamVjdCBmb3IgZ2V0UGFyc2VkUHJvZ3JhbUFjY291bnRzXG4gKi9cblxuLyoqXG4gKiBDb25maWd1cmF0aW9uIG9iamVjdCBmb3IgZ2V0TXVsdGlwbGVBY2NvdW50c1xuICovXG5cbi8qKlxuICogQ29uZmlndXJhdGlvbiBvYmplY3QgZm9yIGBnZXRTdGFrZUFjdGl2YXRpb25gXG4gKi9cblxuLyoqXG4gKiBDb25maWd1cmF0aW9uIG9iamVjdCBmb3IgYGdldFN0YWtlQWN0aXZhdGlvbmBcbiAqL1xuXG4vKipcbiAqIENvbmZpZ3VyYXRpb24gb2JqZWN0IGZvciBgZ2V0U3Rha2VBY3RpdmF0aW9uYFxuICovXG5cbi8qKlxuICogQ29uZmlndXJhdGlvbiBvYmplY3QgZm9yIGBnZXROb25jZWBcbiAqL1xuXG4vKipcbiAqIENvbmZpZ3VyYXRpb24gb2JqZWN0IGZvciBgZ2V0Tm9uY2VBbmRDb250ZXh0YFxuICovXG5cbi8qKlxuICogSW5mb3JtYXRpb24gZGVzY3JpYmluZyBhbiBhY2NvdW50XG4gKi9cblxuLyoqXG4gKiBBY2NvdW50IGluZm9ybWF0aW9uIGlkZW50aWZpZWQgYnkgcHVia2V5XG4gKi9cblxuLyoqXG4gKiBDYWxsYmFjayBmdW5jdGlvbiBmb3IgYWNjb3VudCBjaGFuZ2Ugbm90aWZpY2F0aW9uc1xuICovXG5cbi8qKlxuICogQ2FsbGJhY2sgZnVuY3Rpb24gZm9yIHByb2dyYW0gYWNjb3VudCBjaGFuZ2Ugbm90aWZpY2F0aW9uc1xuICovXG5cbi8qKlxuICogQ2FsbGJhY2sgZnVuY3Rpb24gZm9yIHNsb3QgY2hhbmdlIG5vdGlmaWNhdGlvbnNcbiAqL1xuXG4vKipcbiAqIENhbGxiYWNrIGZ1bmN0aW9uIGZvciBzbG90IHVwZGF0ZSBub3RpZmljYXRpb25zXG4gKi9cblxuLyoqXG4gKiBDYWxsYmFjayBmdW5jdGlvbiBmb3Igc2lnbmF0dXJlIHN0YXR1cyBub3RpZmljYXRpb25zXG4gKi9cblxuLyoqXG4gKiBTaWduYXR1cmUgc3RhdHVzIG5vdGlmaWNhdGlvbiB3aXRoIHRyYW5zYWN0aW9uIHJlc3VsdFxuICovXG5cbi8qKlxuICogU2lnbmF0dXJlIHJlY2VpdmVkIG5vdGlmaWNhdGlvblxuICovXG5cbi8qKlxuICogQ2FsbGJhY2sgZnVuY3Rpb24gZm9yIHNpZ25hdHVyZSBub3RpZmljYXRpb25zXG4gKi9cblxuLyoqXG4gKiBTaWduYXR1cmUgc3Vic2NyaXB0aW9uIG9wdGlvbnNcbiAqL1xuXG4vKipcbiAqIENhbGxiYWNrIGZ1bmN0aW9uIGZvciByb290IGNoYW5nZSBub3RpZmljYXRpb25zXG4gKi9cblxuLyoqXG4gKiBAaW50ZXJuYWxcbiAqL1xuY29uc3QgTG9nc1Jlc3VsdCA9IHR5cGUoe1xuICBlcnI6IFRyYW5zYWN0aW9uRXJyb3JSZXN1bHQsXG4gIGxvZ3M6IGFycmF5KHN0cmluZygpKSxcbiAgc2lnbmF0dXJlOiBzdHJpbmcoKVxufSk7XG5cbi8qKlxuICogTG9ncyByZXN1bHQuXG4gKi9cblxuLyoqXG4gKiBFeHBlY3RlZCBKU09OIFJQQyByZXNwb25zZSBmb3IgdGhlIFwibG9nc05vdGlmaWNhdGlvblwiIG1lc3NhZ2UuXG4gKi9cbmNvbnN0IExvZ3NOb3RpZmljYXRpb25SZXN1bHQgPSB0eXBlKHtcbiAgcmVzdWx0OiBub3RpZmljYXRpb25SZXN1bHRBbmRDb250ZXh0KExvZ3NSZXN1bHQpLFxuICBzdWJzY3JpcHRpb246IG51bWJlcigpXG59KTtcblxuLyoqXG4gKiBGaWx0ZXIgZm9yIGxvZyBzdWJzY3JpcHRpb25zLlxuICovXG5cbi8qKlxuICogQ2FsbGJhY2sgZnVuY3Rpb24gZm9yIGxvZyBub3RpZmljYXRpb25zLlxuICovXG5cbi8qKlxuICogU2lnbmF0dXJlIHJlc3VsdFxuICovXG5cbi8qKlxuICogVHJhbnNhY3Rpb24gZXJyb3JcbiAqL1xuXG4vKipcbiAqIFRyYW5zYWN0aW9uIGNvbmZpcm1hdGlvbiBzdGF0dXNcbiAqIDxwcmU+XG4gKiAgICdwcm9jZXNzZWQnOiBUcmFuc2FjdGlvbiBsYW5kZWQgaW4gYSBibG9jayB3aGljaCBoYXMgcmVhY2hlZCAxIGNvbmZpcm1hdGlvbiBieSB0aGUgY29ubmVjdGVkIG5vZGVcbiAqICAgJ2NvbmZpcm1lZCc6IFRyYW5zYWN0aW9uIGxhbmRlZCBpbiBhIGJsb2NrIHdoaWNoIGhhcyByZWFjaGVkIDEgY29uZmlybWF0aW9uIGJ5IHRoZSBjbHVzdGVyXG4gKiAgICdmaW5hbGl6ZWQnOiBUcmFuc2FjdGlvbiBsYW5kZWQgaW4gYSBibG9jayB3aGljaCBoYXMgYmVlbiBmaW5hbGl6ZWQgYnkgdGhlIGNsdXN0ZXJcbiAqIDwvcHJlPlxuICovXG5cbi8qKlxuICogU2lnbmF0dXJlIHN0YXR1c1xuICovXG5cbi8qKlxuICogQSBjb25maXJtZWQgc2lnbmF0dXJlIHdpdGggaXRzIHN0YXR1c1xuICovXG5cbi8qKlxuICogQW4gb2JqZWN0IGRlZmluaW5nIGhlYWRlcnMgdG8gYmUgcGFzc2VkIHRvIHRoZSBSUEMgc2VydmVyXG4gKi9cblxuLyoqXG4gKiBUaGUgdHlwZSBvZiB0aGUgSmF2YVNjcmlwdCBgZmV0Y2goKWAgQVBJXG4gKi9cblxuLyoqXG4gKiBBIGNhbGxiYWNrIHVzZWQgdG8gYXVnbWVudCB0aGUgb3V0Z29pbmcgSFRUUCByZXF1ZXN0XG4gKi9cblxuLyoqXG4gKiBDb25maWd1cmF0aW9uIGZvciBpbnN0YW50aWF0aW5nIGEgQ29ubmVjdGlvblxuICovXG5cbi8qKiBAaW50ZXJuYWwgKi9cbmNvbnN0IENPTU1PTl9IVFRQX0hFQURFUlMgPSB7XG4gICdzb2xhbmEtY2xpZW50JzogYGpzLyR7XCIwLjAuMC1kZXZlbG9wbWVudFwiIH1gXG59O1xuXG4vKipcbiAqIEEgY29ubmVjdGlvbiB0byBhIGZ1bGxub2RlIEpTT04gUlBDIGVuZHBvaW50XG4gKi9cbmNsYXNzIENvbm5lY3Rpb24ge1xuICAvKipcbiAgICogRXN0YWJsaXNoIGEgSlNPTiBSUEMgY29ubmVjdGlvblxuICAgKlxuICAgKiBAcGFyYW0gZW5kcG9pbnQgVVJMIHRvIHRoZSBmdWxsbm9kZSBKU09OIFJQQyBlbmRwb2ludFxuICAgKiBAcGFyYW0gY29tbWl0bWVudE9yQ29uZmlnIG9wdGlvbmFsIGRlZmF1bHQgY29tbWl0bWVudCBsZXZlbCBvciBvcHRpb25hbCBDb25uZWN0aW9uQ29uZmlnIGNvbmZpZ3VyYXRpb24gb2JqZWN0XG4gICAqL1xuICBjb25zdHJ1Y3RvcihlbmRwb2ludCwgX2NvbW1pdG1lbnRPckNvbmZpZykge1xuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICB0aGlzLl9jb21taXRtZW50ID0gdm9pZCAwO1xuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICB0aGlzLl9jb25maXJtVHJhbnNhY3Rpb25Jbml0aWFsVGltZW91dCA9IHZvaWQgMDtcbiAgICAvKiogQGludGVybmFsICovXG4gICAgdGhpcy5fcnBjRW5kcG9pbnQgPSB2b2lkIDA7XG4gICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgIHRoaXMuX3JwY1dzRW5kcG9pbnQgPSB2b2lkIDA7XG4gICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgIHRoaXMuX3JwY0NsaWVudCA9IHZvaWQgMDtcbiAgICAvKiogQGludGVybmFsICovXG4gICAgdGhpcy5fcnBjUmVxdWVzdCA9IHZvaWQgMDtcbiAgICAvKiogQGludGVybmFsICovXG4gICAgdGhpcy5fcnBjQmF0Y2hSZXF1ZXN0ID0gdm9pZCAwO1xuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICB0aGlzLl9ycGNXZWJTb2NrZXQgPSB2b2lkIDA7XG4gICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgIHRoaXMuX3JwY1dlYlNvY2tldENvbm5lY3RlZCA9IGZhbHNlO1xuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICB0aGlzLl9ycGNXZWJTb2NrZXRIZWFydGJlYXQgPSBudWxsO1xuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICB0aGlzLl9ycGNXZWJTb2NrZXRJZGxlVGltZW91dCA9IG51bGw7XG4gICAgLyoqIEBpbnRlcm5hbFxuICAgICAqIEEgbnVtYmVyIHRoYXQgd2UgaW5jcmVtZW50IGV2ZXJ5IHRpbWUgYW4gYWN0aXZlIGNvbm5lY3Rpb24gY2xvc2VzLlxuICAgICAqIFVzZWQgdG8gZGV0ZXJtaW5lIHdoZXRoZXIgdGhlIHNhbWUgc29ja2V0IGNvbm5lY3Rpb24gdGhhdCB3YXMgb3BlblxuICAgICAqIHdoZW4gYW4gYXN5bmMgb3BlcmF0aW9uIHN0YXJ0ZWQgaXMgdGhlIHNhbWUgb25lIHRoYXQncyBhY3RpdmUgd2hlblxuICAgICAqIGl0cyBjb250aW51YXRpb24gZmlyZXMuXG4gICAgICpcbiAgICAgKi9cbiAgICB0aGlzLl9ycGNXZWJTb2NrZXRHZW5lcmF0aW9uID0gMDtcbiAgICAvKiogQGludGVybmFsICovXG4gICAgdGhpcy5fZGlzYWJsZUJsb2NraGFzaENhY2hpbmcgPSBmYWxzZTtcbiAgICAvKiogQGludGVybmFsICovXG4gICAgdGhpcy5fcG9sbGluZ0Jsb2NraGFzaCA9IGZhbHNlO1xuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICB0aGlzLl9ibG9ja2hhc2hJbmZvID0ge1xuICAgICAgbGF0ZXN0QmxvY2toYXNoOiBudWxsLFxuICAgICAgbGFzdEZldGNoOiAwLFxuICAgICAgdHJhbnNhY3Rpb25TaWduYXR1cmVzOiBbXSxcbiAgICAgIHNpbXVsYXRlZFNpZ25hdHVyZXM6IFtdXG4gICAgfTtcbiAgICAvKiogQGludGVybmFsICovXG4gICAgdGhpcy5fbmV4dENsaWVudFN1YnNjcmlwdGlvbklkID0gMDtcbiAgICAvKiogQGludGVybmFsICovXG4gICAgdGhpcy5fc3Vic2NyaXB0aW9uRGlzcG9zZUZ1bmN0aW9uc0J5Q2xpZW50U3Vic2NyaXB0aW9uSWQgPSB7fTtcbiAgICAvKiogQGludGVybmFsICovXG4gICAgdGhpcy5fc3Vic2NyaXB0aW9uSGFzaEJ5Q2xpZW50U3Vic2NyaXB0aW9uSWQgPSB7fTtcbiAgICAvKiogQGludGVybmFsICovXG4gICAgdGhpcy5fc3Vic2NyaXB0aW9uU3RhdGVDaGFuZ2VDYWxsYmFja3NCeUhhc2ggPSB7fTtcbiAgICAvKiogQGludGVybmFsICovXG4gICAgdGhpcy5fc3Vic2NyaXB0aW9uQ2FsbGJhY2tzQnlTZXJ2ZXJTdWJzY3JpcHRpb25JZCA9IHt9O1xuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICB0aGlzLl9zdWJzY3JpcHRpb25zQnlIYXNoID0ge307XG4gICAgLyoqXG4gICAgICogU3BlY2lhbCBjYXNlLlxuICAgICAqIEFmdGVyIGEgc2lnbmF0dXJlIGlzIHByb2Nlc3NlZCwgUlBDcyBhdXRvbWF0aWNhbGx5IGRpc3Bvc2Ugb2YgdGhlXG4gICAgICogc3Vic2NyaXB0aW9uIG9uIHRoZSBzZXJ2ZXIgc2lkZS4gV2UgbmVlZCB0byB0cmFjayB3aGljaCBvZiB0aGVzZVxuICAgICAqIHN1YnNjcmlwdGlvbnMgaGF2ZSBiZWVuIGRpc3Bvc2VkIGluIHN1Y2ggYSB3YXksIHNvIHRoYXQgd2Uga25vd1xuICAgICAqIHdoZXRoZXIgdGhlIGNsaWVudCBpcyBkZWFsaW5nIHdpdGggYSBub3QteWV0LXByb2Nlc3NlZCBzaWduYXR1cmVcbiAgICAgKiAoaW4gd2hpY2ggY2FzZSB3ZSBtdXN0IHRlYXIgZG93biB0aGUgc2VydmVyIHN1YnNjcmlwdGlvbikgb3IgYW5cbiAgICAgKiBhbHJlYWR5LXByb2Nlc3NlZCBzaWduYXR1cmUgKGluIHdoaWNoIGNhc2UgdGhlIGNsaWVudCBjYW4gc2ltcGx5XG4gICAgICogY2xlYXIgb3V0IHRoZSBzdWJzY3JpcHRpb24gbG9jYWxseSB3aXRob3V0IHRlbGxpbmcgdGhlIHNlcnZlcikuXG4gICAgICpcbiAgICAgKiBOT1RFOiBUaGVyZSBpcyBhIHByb3Bvc2FsIHRvIGVsaW1pbmF0ZSB0aGlzIHNwZWNpYWwgY2FzZSwgaGVyZTpcbiAgICAgKiBodHRwczovL2dpdGh1Yi5jb20vc29sYW5hLWxhYnMvc29sYW5hL2lzc3Vlcy8xODg5MlxuICAgICAqL1xuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICB0aGlzLl9zdWJzY3JpcHRpb25zQXV0b0Rpc3Bvc2VkQnlScGMgPSBuZXcgU2V0KCk7XG4gICAgLypcbiAgICAgKiBSZXR1cm5zIHRoZSBjdXJyZW50IGJsb2NrIGhlaWdodCBvZiB0aGUgbm9kZVxuICAgICAqL1xuICAgIHRoaXMuZ2V0QmxvY2tIZWlnaHQgPSAoKCkgPT4ge1xuICAgICAgY29uc3QgcmVxdWVzdFByb21pc2VzID0ge307XG4gICAgICByZXR1cm4gYXN5bmMgY29tbWl0bWVudE9yQ29uZmlnID0+IHtcbiAgICAgICAgY29uc3Qge1xuICAgICAgICAgIGNvbW1pdG1lbnQsXG4gICAgICAgICAgY29uZmlnXG4gICAgICAgIH0gPSBleHRyYWN0Q29tbWl0bWVudEZyb21Db25maWcoY29tbWl0bWVudE9yQ29uZmlnKTtcbiAgICAgICAgY29uc3QgYXJncyA9IHRoaXMuX2J1aWxkQXJncyhbXSwgY29tbWl0bWVudCwgdW5kZWZpbmVkIC8qIGVuY29kaW5nICovLCBjb25maWcpO1xuICAgICAgICBjb25zdCByZXF1ZXN0SGFzaCA9IGZhc3RTdGFibGVTdHJpbmdpZnkkMShhcmdzKTtcbiAgICAgICAgcmVxdWVzdFByb21pc2VzW3JlcXVlc3RIYXNoXSA9IHJlcXVlc3RQcm9taXNlc1tyZXF1ZXN0SGFzaF0gPz8gKGFzeW5jICgpID0+IHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgdW5zYWZlUmVzID0gYXdhaXQgdGhpcy5fcnBjUmVxdWVzdCgnZ2V0QmxvY2tIZWlnaHQnLCBhcmdzKTtcbiAgICAgICAgICAgIGNvbnN0IHJlcyA9IGNyZWF0ZSh1bnNhZmVSZXMsIGpzb25ScGNSZXN1bHQobnVtYmVyKCkpKTtcbiAgICAgICAgICAgIGlmICgnZXJyb3InIGluIHJlcykge1xuICAgICAgICAgICAgICB0aHJvdyBuZXcgU29sYW5hSlNPTlJQQ0Vycm9yKHJlcy5lcnJvciwgJ2ZhaWxlZCB0byBnZXQgYmxvY2sgaGVpZ2h0IGluZm9ybWF0aW9uJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVzLnJlc3VsdDtcbiAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgZGVsZXRlIHJlcXVlc3RQcm9taXNlc1tyZXF1ZXN0SGFzaF07XG4gICAgICAgICAgfVxuICAgICAgICB9KSgpO1xuICAgICAgICByZXR1cm4gYXdhaXQgcmVxdWVzdFByb21pc2VzW3JlcXVlc3RIYXNoXTtcbiAgICAgIH07XG4gICAgfSkoKTtcbiAgICBsZXQgd3NFbmRwb2ludDtcbiAgICBsZXQgaHR0cEhlYWRlcnM7XG4gICAgbGV0IGZldGNoO1xuICAgIGxldCBmZXRjaE1pZGRsZXdhcmU7XG4gICAgbGV0IGRpc2FibGVSZXRyeU9uUmF0ZUxpbWl0O1xuICAgIGxldCBodHRwQWdlbnQ7XG4gICAgaWYgKF9jb21taXRtZW50T3JDb25maWcgJiYgdHlwZW9mIF9jb21taXRtZW50T3JDb25maWcgPT09ICdzdHJpbmcnKSB7XG4gICAgICB0aGlzLl9jb21taXRtZW50ID0gX2NvbW1pdG1lbnRPckNvbmZpZztcbiAgICB9IGVsc2UgaWYgKF9jb21taXRtZW50T3JDb25maWcpIHtcbiAgICAgIHRoaXMuX2NvbW1pdG1lbnQgPSBfY29tbWl0bWVudE9yQ29uZmlnLmNvbW1pdG1lbnQ7XG4gICAgICB0aGlzLl9jb25maXJtVHJhbnNhY3Rpb25Jbml0aWFsVGltZW91dCA9IF9jb21taXRtZW50T3JDb25maWcuY29uZmlybVRyYW5zYWN0aW9uSW5pdGlhbFRpbWVvdXQ7XG4gICAgICB3c0VuZHBvaW50ID0gX2NvbW1pdG1lbnRPckNvbmZpZy53c0VuZHBvaW50O1xuICAgICAgaHR0cEhlYWRlcnMgPSBfY29tbWl0bWVudE9yQ29uZmlnLmh0dHBIZWFkZXJzO1xuICAgICAgZmV0Y2ggPSBfY29tbWl0bWVudE9yQ29uZmlnLmZldGNoO1xuICAgICAgZmV0Y2hNaWRkbGV3YXJlID0gX2NvbW1pdG1lbnRPckNvbmZpZy5mZXRjaE1pZGRsZXdhcmU7XG4gICAgICBkaXNhYmxlUmV0cnlPblJhdGVMaW1pdCA9IF9jb21taXRtZW50T3JDb25maWcuZGlzYWJsZVJldHJ5T25SYXRlTGltaXQ7XG4gICAgICBodHRwQWdlbnQgPSBfY29tbWl0bWVudE9yQ29uZmlnLmh0dHBBZ2VudDtcbiAgICB9XG4gICAgdGhpcy5fcnBjRW5kcG9pbnQgPSBhc3NlcnRFbmRwb2ludFVybChlbmRwb2ludCk7XG4gICAgdGhpcy5fcnBjV3NFbmRwb2ludCA9IHdzRW5kcG9pbnQgfHwgbWFrZVdlYnNvY2tldFVybChlbmRwb2ludCk7XG4gICAgdGhpcy5fcnBjQ2xpZW50ID0gY3JlYXRlUnBjQ2xpZW50KGVuZHBvaW50LCBodHRwSGVhZGVycywgZmV0Y2gsIGZldGNoTWlkZGxld2FyZSwgZGlzYWJsZVJldHJ5T25SYXRlTGltaXQsIGh0dHBBZ2VudCk7XG4gICAgdGhpcy5fcnBjUmVxdWVzdCA9IGNyZWF0ZVJwY1JlcXVlc3QodGhpcy5fcnBjQ2xpZW50KTtcbiAgICB0aGlzLl9ycGNCYXRjaFJlcXVlc3QgPSBjcmVhdGVScGNCYXRjaFJlcXVlc3QodGhpcy5fcnBjQ2xpZW50KTtcbiAgICB0aGlzLl9ycGNXZWJTb2NrZXQgPSBuZXcgUnBjV2ViU29ja2V0Q2xpZW50KHRoaXMuX3JwY1dzRW5kcG9pbnQsIHtcbiAgICAgIGF1dG9jb25uZWN0OiBmYWxzZSxcbiAgICAgIG1heF9yZWNvbm5lY3RzOiBJbmZpbml0eVxuICAgIH0pO1xuICAgIHRoaXMuX3JwY1dlYlNvY2tldC5vbignb3BlbicsIHRoaXMuX3dzT25PcGVuLmJpbmQodGhpcykpO1xuICAgIHRoaXMuX3JwY1dlYlNvY2tldC5vbignZXJyb3InLCB0aGlzLl93c09uRXJyb3IuYmluZCh0aGlzKSk7XG4gICAgdGhpcy5fcnBjV2ViU29ja2V0Lm9uKCdjbG9zZScsIHRoaXMuX3dzT25DbG9zZS5iaW5kKHRoaXMpKTtcbiAgICB0aGlzLl9ycGNXZWJTb2NrZXQub24oJ2FjY291bnROb3RpZmljYXRpb24nLCB0aGlzLl93c09uQWNjb3VudE5vdGlmaWNhdGlvbi5iaW5kKHRoaXMpKTtcbiAgICB0aGlzLl9ycGNXZWJTb2NrZXQub24oJ3Byb2dyYW1Ob3RpZmljYXRpb24nLCB0aGlzLl93c09uUHJvZ3JhbUFjY291bnROb3RpZmljYXRpb24uYmluZCh0aGlzKSk7XG4gICAgdGhpcy5fcnBjV2ViU29ja2V0Lm9uKCdzbG90Tm90aWZpY2F0aW9uJywgdGhpcy5fd3NPblNsb3ROb3RpZmljYXRpb24uYmluZCh0aGlzKSk7XG4gICAgdGhpcy5fcnBjV2ViU29ja2V0Lm9uKCdzbG90c1VwZGF0ZXNOb3RpZmljYXRpb24nLCB0aGlzLl93c09uU2xvdFVwZGF0ZXNOb3RpZmljYXRpb24uYmluZCh0aGlzKSk7XG4gICAgdGhpcy5fcnBjV2ViU29ja2V0Lm9uKCdzaWduYXR1cmVOb3RpZmljYXRpb24nLCB0aGlzLl93c09uU2lnbmF0dXJlTm90aWZpY2F0aW9uLmJpbmQodGhpcykpO1xuICAgIHRoaXMuX3JwY1dlYlNvY2tldC5vbigncm9vdE5vdGlmaWNhdGlvbicsIHRoaXMuX3dzT25Sb290Tm90aWZpY2F0aW9uLmJpbmQodGhpcykpO1xuICAgIHRoaXMuX3JwY1dlYlNvY2tldC5vbignbG9nc05vdGlmaWNhdGlvbicsIHRoaXMuX3dzT25Mb2dzTm90aWZpY2F0aW9uLmJpbmQodGhpcykpO1xuICB9XG5cbiAgLyoqXG4gICAqIFRoZSBkZWZhdWx0IGNvbW1pdG1lbnQgdXNlZCBmb3IgcmVxdWVzdHNcbiAgICovXG4gIGdldCBjb21taXRtZW50KCkge1xuICAgIHJldHVybiB0aGlzLl9jb21taXRtZW50O1xuICB9XG5cbiAgLyoqXG4gICAqIFRoZSBSUEMgZW5kcG9pbnRcbiAgICovXG4gIGdldCBycGNFbmRwb2ludCgpIHtcbiAgICByZXR1cm4gdGhpcy5fcnBjRW5kcG9pbnQ7XG4gIH1cblxuICAvKipcbiAgICogRmV0Y2ggdGhlIGJhbGFuY2UgZm9yIHRoZSBzcGVjaWZpZWQgcHVibGljIGtleSwgcmV0dXJuIHdpdGggY29udGV4dFxuICAgKi9cbiAgYXN5bmMgZ2V0QmFsYW5jZUFuZENvbnRleHQocHVibGljS2V5LCBjb21taXRtZW50T3JDb25maWcpIHtcbiAgICAvKiogQGludGVybmFsICovXG4gICAgY29uc3Qge1xuICAgICAgY29tbWl0bWVudCxcbiAgICAgIGNvbmZpZ1xuICAgIH0gPSBleHRyYWN0Q29tbWl0bWVudEZyb21Db25maWcoY29tbWl0bWVudE9yQ29uZmlnKTtcbiAgICBjb25zdCBhcmdzID0gdGhpcy5fYnVpbGRBcmdzKFtwdWJsaWNLZXkudG9CYXNlNTgoKV0sIGNvbW1pdG1lbnQsIHVuZGVmaW5lZCAvKiBlbmNvZGluZyAqLywgY29uZmlnKTtcbiAgICBjb25zdCB1bnNhZmVSZXMgPSBhd2FpdCB0aGlzLl9ycGNSZXF1ZXN0KCdnZXRCYWxhbmNlJywgYXJncyk7XG4gICAgY29uc3QgcmVzID0gY3JlYXRlKHVuc2FmZVJlcywganNvblJwY1Jlc3VsdEFuZENvbnRleHQobnVtYmVyKCkpKTtcbiAgICBpZiAoJ2Vycm9yJyBpbiByZXMpIHtcbiAgICAgIHRocm93IG5ldyBTb2xhbmFKU09OUlBDRXJyb3IocmVzLmVycm9yLCBgZmFpbGVkIHRvIGdldCBiYWxhbmNlIGZvciAke3B1YmxpY0tleS50b0Jhc2U1OCgpfWApO1xuICAgIH1cbiAgICByZXR1cm4gcmVzLnJlc3VsdDtcbiAgfVxuXG4gIC8qKlxuICAgKiBGZXRjaCB0aGUgYmFsYW5jZSBmb3IgdGhlIHNwZWNpZmllZCBwdWJsaWMga2V5XG4gICAqL1xuICBhc3luYyBnZXRCYWxhbmNlKHB1YmxpY0tleSwgY29tbWl0bWVudE9yQ29uZmlnKSB7XG4gICAgcmV0dXJuIGF3YWl0IHRoaXMuZ2V0QmFsYW5jZUFuZENvbnRleHQocHVibGljS2V5LCBjb21taXRtZW50T3JDb25maWcpLnRoZW4oeCA9PiB4LnZhbHVlKS5jYXRjaChlID0+IHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignZmFpbGVkIHRvIGdldCBiYWxhbmNlIG9mIGFjY291bnQgJyArIHB1YmxpY0tleS50b0Jhc2U1OCgpICsgJzogJyArIGUpO1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEZldGNoIHRoZSBlc3RpbWF0ZWQgcHJvZHVjdGlvbiB0aW1lIG9mIGEgYmxvY2tcbiAgICovXG4gIGFzeW5jIGdldEJsb2NrVGltZShzbG90KSB7XG4gICAgY29uc3QgdW5zYWZlUmVzID0gYXdhaXQgdGhpcy5fcnBjUmVxdWVzdCgnZ2V0QmxvY2tUaW1lJywgW3Nsb3RdKTtcbiAgICBjb25zdCByZXMgPSBjcmVhdGUodW5zYWZlUmVzLCBqc29uUnBjUmVzdWx0KG51bGxhYmxlKG51bWJlcigpKSkpO1xuICAgIGlmICgnZXJyb3InIGluIHJlcykge1xuICAgICAgdGhyb3cgbmV3IFNvbGFuYUpTT05SUENFcnJvcihyZXMuZXJyb3IsIGBmYWlsZWQgdG8gZ2V0IGJsb2NrIHRpbWUgZm9yIHNsb3QgJHtzbG90fWApO1xuICAgIH1cbiAgICByZXR1cm4gcmVzLnJlc3VsdDtcbiAgfVxuXG4gIC8qKlxuICAgKiBGZXRjaCB0aGUgbG93ZXN0IHNsb3QgdGhhdCB0aGUgbm9kZSBoYXMgaW5mb3JtYXRpb24gYWJvdXQgaW4gaXRzIGxlZGdlci5cbiAgICogVGhpcyB2YWx1ZSBtYXkgaW5jcmVhc2Ugb3ZlciB0aW1lIGlmIHRoZSBub2RlIGlzIGNvbmZpZ3VyZWQgdG8gcHVyZ2Ugb2xkZXIgbGVkZ2VyIGRhdGFcbiAgICovXG4gIGFzeW5jIGdldE1pbmltdW1MZWRnZXJTbG90KCkge1xuICAgIGNvbnN0IHVuc2FmZVJlcyA9IGF3YWl0IHRoaXMuX3JwY1JlcXVlc3QoJ21pbmltdW1MZWRnZXJTbG90JywgW10pO1xuICAgIGNvbnN0IHJlcyA9IGNyZWF0ZSh1bnNhZmVSZXMsIGpzb25ScGNSZXN1bHQobnVtYmVyKCkpKTtcbiAgICBpZiAoJ2Vycm9yJyBpbiByZXMpIHtcbiAgICAgIHRocm93IG5ldyBTb2xhbmFKU09OUlBDRXJyb3IocmVzLmVycm9yLCAnZmFpbGVkIHRvIGdldCBtaW5pbXVtIGxlZGdlciBzbG90Jyk7XG4gICAgfVxuICAgIHJldHVybiByZXMucmVzdWx0O1xuICB9XG5cbiAgLyoqXG4gICAqIEZldGNoIHRoZSBzbG90IG9mIHRoZSBsb3dlc3QgY29uZmlybWVkIGJsb2NrIHRoYXQgaGFzIG5vdCBiZWVuIHB1cmdlZCBmcm9tIHRoZSBsZWRnZXJcbiAgICovXG4gIGFzeW5jIGdldEZpcnN0QXZhaWxhYmxlQmxvY2soKSB7XG4gICAgY29uc3QgdW5zYWZlUmVzID0gYXdhaXQgdGhpcy5fcnBjUmVxdWVzdCgnZ2V0Rmlyc3RBdmFpbGFibGVCbG9jaycsIFtdKTtcbiAgICBjb25zdCByZXMgPSBjcmVhdGUodW5zYWZlUmVzLCBTbG90UnBjUmVzdWx0KTtcbiAgICBpZiAoJ2Vycm9yJyBpbiByZXMpIHtcbiAgICAgIHRocm93IG5ldyBTb2xhbmFKU09OUlBDRXJyb3IocmVzLmVycm9yLCAnZmFpbGVkIHRvIGdldCBmaXJzdCBhdmFpbGFibGUgYmxvY2snKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlcy5yZXN1bHQ7XG4gIH1cblxuICAvKipcbiAgICogRmV0Y2ggaW5mb3JtYXRpb24gYWJvdXQgdGhlIGN1cnJlbnQgc3VwcGx5XG4gICAqL1xuICBhc3luYyBnZXRTdXBwbHkoY29uZmlnKSB7XG4gICAgbGV0IGNvbmZpZ0FyZyA9IHt9O1xuICAgIGlmICh0eXBlb2YgY29uZmlnID09PSAnc3RyaW5nJykge1xuICAgICAgY29uZmlnQXJnID0ge1xuICAgICAgICBjb21taXRtZW50OiBjb25maWdcbiAgICAgIH07XG4gICAgfSBlbHNlIGlmIChjb25maWcpIHtcbiAgICAgIGNvbmZpZ0FyZyA9IHtcbiAgICAgICAgLi4uY29uZmlnLFxuICAgICAgICBjb21taXRtZW50OiBjb25maWcgJiYgY29uZmlnLmNvbW1pdG1lbnQgfHwgdGhpcy5jb21taXRtZW50XG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25maWdBcmcgPSB7XG4gICAgICAgIGNvbW1pdG1lbnQ6IHRoaXMuY29tbWl0bWVudFxuICAgICAgfTtcbiAgICB9XG4gICAgY29uc3QgdW5zYWZlUmVzID0gYXdhaXQgdGhpcy5fcnBjUmVxdWVzdCgnZ2V0U3VwcGx5JywgW2NvbmZpZ0FyZ10pO1xuICAgIGNvbnN0IHJlcyA9IGNyZWF0ZSh1bnNhZmVSZXMsIEdldFN1cHBseVJwY1Jlc3VsdCk7XG4gICAgaWYgKCdlcnJvcicgaW4gcmVzKSB7XG4gICAgICB0aHJvdyBuZXcgU29sYW5hSlNPTlJQQ0Vycm9yKHJlcy5lcnJvciwgJ2ZhaWxlZCB0byBnZXQgc3VwcGx5Jyk7XG4gICAgfVxuICAgIHJldHVybiByZXMucmVzdWx0O1xuICB9XG5cbiAgLyoqXG4gICAqIEZldGNoIHRoZSBjdXJyZW50IHN1cHBseSBvZiBhIHRva2VuIG1pbnRcbiAgICovXG4gIGFzeW5jIGdldFRva2VuU3VwcGx5KHRva2VuTWludEFkZHJlc3MsIGNvbW1pdG1lbnQpIHtcbiAgICBjb25zdCBhcmdzID0gdGhpcy5fYnVpbGRBcmdzKFt0b2tlbk1pbnRBZGRyZXNzLnRvQmFzZTU4KCldLCBjb21taXRtZW50KTtcbiAgICBjb25zdCB1bnNhZmVSZXMgPSBhd2FpdCB0aGlzLl9ycGNSZXF1ZXN0KCdnZXRUb2tlblN1cHBseScsIGFyZ3MpO1xuICAgIGNvbnN0IHJlcyA9IGNyZWF0ZSh1bnNhZmVSZXMsIGpzb25ScGNSZXN1bHRBbmRDb250ZXh0KFRva2VuQW1vdW50UmVzdWx0KSk7XG4gICAgaWYgKCdlcnJvcicgaW4gcmVzKSB7XG4gICAgICB0aHJvdyBuZXcgU29sYW5hSlNPTlJQQ0Vycm9yKHJlcy5lcnJvciwgJ2ZhaWxlZCB0byBnZXQgdG9rZW4gc3VwcGx5Jyk7XG4gICAgfVxuICAgIHJldHVybiByZXMucmVzdWx0O1xuICB9XG5cbiAgLyoqXG4gICAqIEZldGNoIHRoZSBjdXJyZW50IGJhbGFuY2Ugb2YgYSB0b2tlbiBhY2NvdW50XG4gICAqL1xuICBhc3luYyBnZXRUb2tlbkFjY291bnRCYWxhbmNlKHRva2VuQWRkcmVzcywgY29tbWl0bWVudCkge1xuICAgIGNvbnN0IGFyZ3MgPSB0aGlzLl9idWlsZEFyZ3MoW3Rva2VuQWRkcmVzcy50b0Jhc2U1OCgpXSwgY29tbWl0bWVudCk7XG4gICAgY29uc3QgdW5zYWZlUmVzID0gYXdhaXQgdGhpcy5fcnBjUmVxdWVzdCgnZ2V0VG9rZW5BY2NvdW50QmFsYW5jZScsIGFyZ3MpO1xuICAgIGNvbnN0IHJlcyA9IGNyZWF0ZSh1bnNhZmVSZXMsIGpzb25ScGNSZXN1bHRBbmRDb250ZXh0KFRva2VuQW1vdW50UmVzdWx0KSk7XG4gICAgaWYgKCdlcnJvcicgaW4gcmVzKSB7XG4gICAgICB0aHJvdyBuZXcgU29sYW5hSlNPTlJQQ0Vycm9yKHJlcy5lcnJvciwgJ2ZhaWxlZCB0byBnZXQgdG9rZW4gYWNjb3VudCBiYWxhbmNlJyk7XG4gICAgfVxuICAgIHJldHVybiByZXMucmVzdWx0O1xuICB9XG5cbiAgLyoqXG4gICAqIEZldGNoIGFsbCB0aGUgdG9rZW4gYWNjb3VudHMgb3duZWQgYnkgdGhlIHNwZWNpZmllZCBhY2NvdW50XG4gICAqXG4gICAqIEByZXR1cm4ge1Byb21pc2U8UnBjUmVzcG9uc2VBbmRDb250ZXh0PEdldFByb2dyYW1BY2NvdW50c1Jlc3BvbnNlPn1cbiAgICovXG4gIGFzeW5jIGdldFRva2VuQWNjb3VudHNCeU93bmVyKG93bmVyQWRkcmVzcywgZmlsdGVyLCBjb21taXRtZW50T3JDb25maWcpIHtcbiAgICBjb25zdCB7XG4gICAgICBjb21taXRtZW50LFxuICAgICAgY29uZmlnXG4gICAgfSA9IGV4dHJhY3RDb21taXRtZW50RnJvbUNvbmZpZyhjb21taXRtZW50T3JDb25maWcpO1xuICAgIGxldCBfYXJncyA9IFtvd25lckFkZHJlc3MudG9CYXNlNTgoKV07XG4gICAgaWYgKCdtaW50JyBpbiBmaWx0ZXIpIHtcbiAgICAgIF9hcmdzLnB1c2goe1xuICAgICAgICBtaW50OiBmaWx0ZXIubWludC50b0Jhc2U1OCgpXG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgX2FyZ3MucHVzaCh7XG4gICAgICAgIHByb2dyYW1JZDogZmlsdGVyLnByb2dyYW1JZC50b0Jhc2U1OCgpXG4gICAgICB9KTtcbiAgICB9XG4gICAgY29uc3QgYXJncyA9IHRoaXMuX2J1aWxkQXJncyhfYXJncywgY29tbWl0bWVudCwgJ2Jhc2U2NCcsIGNvbmZpZyk7XG4gICAgY29uc3QgdW5zYWZlUmVzID0gYXdhaXQgdGhpcy5fcnBjUmVxdWVzdCgnZ2V0VG9rZW5BY2NvdW50c0J5T3duZXInLCBhcmdzKTtcbiAgICBjb25zdCByZXMgPSBjcmVhdGUodW5zYWZlUmVzLCBHZXRUb2tlbkFjY291bnRzQnlPd25lcik7XG4gICAgaWYgKCdlcnJvcicgaW4gcmVzKSB7XG4gICAgICB0aHJvdyBuZXcgU29sYW5hSlNPTlJQQ0Vycm9yKHJlcy5lcnJvciwgYGZhaWxlZCB0byBnZXQgdG9rZW4gYWNjb3VudHMgb3duZWQgYnkgYWNjb3VudCAke293bmVyQWRkcmVzcy50b0Jhc2U1OCgpfWApO1xuICAgIH1cbiAgICByZXR1cm4gcmVzLnJlc3VsdDtcbiAgfVxuXG4gIC8qKlxuICAgKiBGZXRjaCBwYXJzZWQgdG9rZW4gYWNjb3VudHMgb3duZWQgYnkgdGhlIHNwZWNpZmllZCBhY2NvdW50XG4gICAqXG4gICAqIEByZXR1cm4ge1Byb21pc2U8UnBjUmVzcG9uc2VBbmRDb250ZXh0PEFycmF5PHtwdWJrZXk6IFB1YmxpY0tleSwgYWNjb3VudDogQWNjb3VudEluZm88UGFyc2VkQWNjb3VudERhdGE+fT4+Pn1cbiAgICovXG4gIGFzeW5jIGdldFBhcnNlZFRva2VuQWNjb3VudHNCeU93bmVyKG93bmVyQWRkcmVzcywgZmlsdGVyLCBjb21taXRtZW50KSB7XG4gICAgbGV0IF9hcmdzID0gW293bmVyQWRkcmVzcy50b0Jhc2U1OCgpXTtcbiAgICBpZiAoJ21pbnQnIGluIGZpbHRlcikge1xuICAgICAgX2FyZ3MucHVzaCh7XG4gICAgICAgIG1pbnQ6IGZpbHRlci5taW50LnRvQmFzZTU4KClcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBfYXJncy5wdXNoKHtcbiAgICAgICAgcHJvZ3JhbUlkOiBmaWx0ZXIucHJvZ3JhbUlkLnRvQmFzZTU4KClcbiAgICAgIH0pO1xuICAgIH1cbiAgICBjb25zdCBhcmdzID0gdGhpcy5fYnVpbGRBcmdzKF9hcmdzLCBjb21taXRtZW50LCAnanNvblBhcnNlZCcpO1xuICAgIGNvbnN0IHVuc2FmZVJlcyA9IGF3YWl0IHRoaXMuX3JwY1JlcXVlc3QoJ2dldFRva2VuQWNjb3VudHNCeU93bmVyJywgYXJncyk7XG4gICAgY29uc3QgcmVzID0gY3JlYXRlKHVuc2FmZVJlcywgR2V0UGFyc2VkVG9rZW5BY2NvdW50c0J5T3duZXIpO1xuICAgIGlmICgnZXJyb3InIGluIHJlcykge1xuICAgICAgdGhyb3cgbmV3IFNvbGFuYUpTT05SUENFcnJvcihyZXMuZXJyb3IsIGBmYWlsZWQgdG8gZ2V0IHRva2VuIGFjY291bnRzIG93bmVkIGJ5IGFjY291bnQgJHtvd25lckFkZHJlc3MudG9CYXNlNTgoKX1gKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlcy5yZXN1bHQ7XG4gIH1cblxuICAvKipcbiAgICogRmV0Y2ggdGhlIDIwIGxhcmdlc3QgYWNjb3VudHMgd2l0aCB0aGVpciBjdXJyZW50IGJhbGFuY2VzXG4gICAqL1xuICBhc3luYyBnZXRMYXJnZXN0QWNjb3VudHMoY29uZmlnKSB7XG4gICAgY29uc3QgYXJnID0ge1xuICAgICAgLi4uY29uZmlnLFxuICAgICAgY29tbWl0bWVudDogY29uZmlnICYmIGNvbmZpZy5jb21taXRtZW50IHx8IHRoaXMuY29tbWl0bWVudFxuICAgIH07XG4gICAgY29uc3QgYXJncyA9IGFyZy5maWx0ZXIgfHwgYXJnLmNvbW1pdG1lbnQgPyBbYXJnXSA6IFtdO1xuICAgIGNvbnN0IHVuc2FmZVJlcyA9IGF3YWl0IHRoaXMuX3JwY1JlcXVlc3QoJ2dldExhcmdlc3RBY2NvdW50cycsIGFyZ3MpO1xuICAgIGNvbnN0IHJlcyA9IGNyZWF0ZSh1bnNhZmVSZXMsIEdldExhcmdlc3RBY2NvdW50c1JwY1Jlc3VsdCk7XG4gICAgaWYgKCdlcnJvcicgaW4gcmVzKSB7XG4gICAgICB0aHJvdyBuZXcgU29sYW5hSlNPTlJQQ0Vycm9yKHJlcy5lcnJvciwgJ2ZhaWxlZCB0byBnZXQgbGFyZ2VzdCBhY2NvdW50cycpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzLnJlc3VsdDtcbiAgfVxuXG4gIC8qKlxuICAgKiBGZXRjaCB0aGUgMjAgbGFyZ2VzdCB0b2tlbiBhY2NvdW50cyB3aXRoIHRoZWlyIGN1cnJlbnQgYmFsYW5jZXNcbiAgICogZm9yIGEgZ2l2ZW4gbWludC5cbiAgICovXG4gIGFzeW5jIGdldFRva2VuTGFyZ2VzdEFjY291bnRzKG1pbnRBZGRyZXNzLCBjb21taXRtZW50KSB7XG4gICAgY29uc3QgYXJncyA9IHRoaXMuX2J1aWxkQXJncyhbbWludEFkZHJlc3MudG9CYXNlNTgoKV0sIGNvbW1pdG1lbnQpO1xuICAgIGNvbnN0IHVuc2FmZVJlcyA9IGF3YWl0IHRoaXMuX3JwY1JlcXVlc3QoJ2dldFRva2VuTGFyZ2VzdEFjY291bnRzJywgYXJncyk7XG4gICAgY29uc3QgcmVzID0gY3JlYXRlKHVuc2FmZVJlcywgR2V0VG9rZW5MYXJnZXN0QWNjb3VudHNSZXN1bHQpO1xuICAgIGlmICgnZXJyb3InIGluIHJlcykge1xuICAgICAgdGhyb3cgbmV3IFNvbGFuYUpTT05SUENFcnJvcihyZXMuZXJyb3IsICdmYWlsZWQgdG8gZ2V0IHRva2VuIGxhcmdlc3QgYWNjb3VudHMnKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlcy5yZXN1bHQ7XG4gIH1cblxuICAvKipcbiAgICogRmV0Y2ggYWxsIHRoZSBhY2NvdW50IGluZm8gZm9yIHRoZSBzcGVjaWZpZWQgcHVibGljIGtleSwgcmV0dXJuIHdpdGggY29udGV4dFxuICAgKi9cbiAgYXN5bmMgZ2V0QWNjb3VudEluZm9BbmRDb250ZXh0KHB1YmxpY0tleSwgY29tbWl0bWVudE9yQ29uZmlnKSB7XG4gICAgY29uc3Qge1xuICAgICAgY29tbWl0bWVudCxcbiAgICAgIGNvbmZpZ1xuICAgIH0gPSBleHRyYWN0Q29tbWl0bWVudEZyb21Db25maWcoY29tbWl0bWVudE9yQ29uZmlnKTtcbiAgICBjb25zdCBhcmdzID0gdGhpcy5fYnVpbGRBcmdzKFtwdWJsaWNLZXkudG9CYXNlNTgoKV0sIGNvbW1pdG1lbnQsICdiYXNlNjQnLCBjb25maWcpO1xuICAgIGNvbnN0IHVuc2FmZVJlcyA9IGF3YWl0IHRoaXMuX3JwY1JlcXVlc3QoJ2dldEFjY291bnRJbmZvJywgYXJncyk7XG4gICAgY29uc3QgcmVzID0gY3JlYXRlKHVuc2FmZVJlcywganNvblJwY1Jlc3VsdEFuZENvbnRleHQobnVsbGFibGUoQWNjb3VudEluZm9SZXN1bHQpKSk7XG4gICAgaWYgKCdlcnJvcicgaW4gcmVzKSB7XG4gICAgICB0aHJvdyBuZXcgU29sYW5hSlNPTlJQQ0Vycm9yKHJlcy5lcnJvciwgYGZhaWxlZCB0byBnZXQgaW5mbyBhYm91dCBhY2NvdW50ICR7cHVibGljS2V5LnRvQmFzZTU4KCl9YCk7XG4gICAgfVxuICAgIHJldHVybiByZXMucmVzdWx0O1xuICB9XG5cbiAgLyoqXG4gICAqIEZldGNoIHBhcnNlZCBhY2NvdW50IGluZm8gZm9yIHRoZSBzcGVjaWZpZWQgcHVibGljIGtleVxuICAgKi9cbiAgYXN5bmMgZ2V0UGFyc2VkQWNjb3VudEluZm8ocHVibGljS2V5LCBjb21taXRtZW50T3JDb25maWcpIHtcbiAgICBjb25zdCB7XG4gICAgICBjb21taXRtZW50LFxuICAgICAgY29uZmlnXG4gICAgfSA9IGV4dHJhY3RDb21taXRtZW50RnJvbUNvbmZpZyhjb21taXRtZW50T3JDb25maWcpO1xuICAgIGNvbnN0IGFyZ3MgPSB0aGlzLl9idWlsZEFyZ3MoW3B1YmxpY0tleS50b0Jhc2U1OCgpXSwgY29tbWl0bWVudCwgJ2pzb25QYXJzZWQnLCBjb25maWcpO1xuICAgIGNvbnN0IHVuc2FmZVJlcyA9IGF3YWl0IHRoaXMuX3JwY1JlcXVlc3QoJ2dldEFjY291bnRJbmZvJywgYXJncyk7XG4gICAgY29uc3QgcmVzID0gY3JlYXRlKHVuc2FmZVJlcywganNvblJwY1Jlc3VsdEFuZENvbnRleHQobnVsbGFibGUoUGFyc2VkQWNjb3VudEluZm9SZXN1bHQpKSk7XG4gICAgaWYgKCdlcnJvcicgaW4gcmVzKSB7XG4gICAgICB0aHJvdyBuZXcgU29sYW5hSlNPTlJQQ0Vycm9yKHJlcy5lcnJvciwgYGZhaWxlZCB0byBnZXQgaW5mbyBhYm91dCBhY2NvdW50ICR7cHVibGljS2V5LnRvQmFzZTU4KCl9YCk7XG4gICAgfVxuICAgIHJldHVybiByZXMucmVzdWx0O1xuICB9XG5cbiAgLyoqXG4gICAqIEZldGNoIGFsbCB0aGUgYWNjb3VudCBpbmZvIGZvciB0aGUgc3BlY2lmaWVkIHB1YmxpYyBrZXlcbiAgICovXG4gIGFzeW5jIGdldEFjY291bnRJbmZvKHB1YmxpY0tleSwgY29tbWl0bWVudE9yQ29uZmlnKSB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHJlcyA9IGF3YWl0IHRoaXMuZ2V0QWNjb3VudEluZm9BbmRDb250ZXh0KHB1YmxpY0tleSwgY29tbWl0bWVudE9yQ29uZmlnKTtcbiAgICAgIHJldHVybiByZXMudmFsdWU7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdmYWlsZWQgdG8gZ2V0IGluZm8gYWJvdXQgYWNjb3VudCAnICsgcHVibGljS2V5LnRvQmFzZTU4KCkgKyAnOiAnICsgZSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEZldGNoIGFsbCB0aGUgYWNjb3VudCBpbmZvIGZvciBtdWx0aXBsZSBhY2NvdW50cyBzcGVjaWZpZWQgYnkgYW4gYXJyYXkgb2YgcHVibGljIGtleXMsIHJldHVybiB3aXRoIGNvbnRleHRcbiAgICovXG4gIGFzeW5jIGdldE11bHRpcGxlUGFyc2VkQWNjb3VudHMocHVibGljS2V5cywgcmF3Q29uZmlnKSB7XG4gICAgY29uc3Qge1xuICAgICAgY29tbWl0bWVudCxcbiAgICAgIGNvbmZpZ1xuICAgIH0gPSBleHRyYWN0Q29tbWl0bWVudEZyb21Db25maWcocmF3Q29uZmlnKTtcbiAgICBjb25zdCBrZXlzID0gcHVibGljS2V5cy5tYXAoa2V5ID0+IGtleS50b0Jhc2U1OCgpKTtcbiAgICBjb25zdCBhcmdzID0gdGhpcy5fYnVpbGRBcmdzKFtrZXlzXSwgY29tbWl0bWVudCwgJ2pzb25QYXJzZWQnLCBjb25maWcpO1xuICAgIGNvbnN0IHVuc2FmZVJlcyA9IGF3YWl0IHRoaXMuX3JwY1JlcXVlc3QoJ2dldE11bHRpcGxlQWNjb3VudHMnLCBhcmdzKTtcbiAgICBjb25zdCByZXMgPSBjcmVhdGUodW5zYWZlUmVzLCBqc29uUnBjUmVzdWx0QW5kQ29udGV4dChhcnJheShudWxsYWJsZShQYXJzZWRBY2NvdW50SW5mb1Jlc3VsdCkpKSk7XG4gICAgaWYgKCdlcnJvcicgaW4gcmVzKSB7XG4gICAgICB0aHJvdyBuZXcgU29sYW5hSlNPTlJQQ0Vycm9yKHJlcy5lcnJvciwgYGZhaWxlZCB0byBnZXQgaW5mbyBmb3IgYWNjb3VudHMgJHtrZXlzfWApO1xuICAgIH1cbiAgICByZXR1cm4gcmVzLnJlc3VsdDtcbiAgfVxuXG4gIC8qKlxuICAgKiBGZXRjaCBhbGwgdGhlIGFjY291bnQgaW5mbyBmb3IgbXVsdGlwbGUgYWNjb3VudHMgc3BlY2lmaWVkIGJ5IGFuIGFycmF5IG9mIHB1YmxpYyBrZXlzLCByZXR1cm4gd2l0aCBjb250ZXh0XG4gICAqL1xuICBhc3luYyBnZXRNdWx0aXBsZUFjY291bnRzSW5mb0FuZENvbnRleHQocHVibGljS2V5cywgY29tbWl0bWVudE9yQ29uZmlnKSB7XG4gICAgY29uc3Qge1xuICAgICAgY29tbWl0bWVudCxcbiAgICAgIGNvbmZpZ1xuICAgIH0gPSBleHRyYWN0Q29tbWl0bWVudEZyb21Db25maWcoY29tbWl0bWVudE9yQ29uZmlnKTtcbiAgICBjb25zdCBrZXlzID0gcHVibGljS2V5cy5tYXAoa2V5ID0+IGtleS50b0Jhc2U1OCgpKTtcbiAgICBjb25zdCBhcmdzID0gdGhpcy5fYnVpbGRBcmdzKFtrZXlzXSwgY29tbWl0bWVudCwgJ2Jhc2U2NCcsIGNvbmZpZyk7XG4gICAgY29uc3QgdW5zYWZlUmVzID0gYXdhaXQgdGhpcy5fcnBjUmVxdWVzdCgnZ2V0TXVsdGlwbGVBY2NvdW50cycsIGFyZ3MpO1xuICAgIGNvbnN0IHJlcyA9IGNyZWF0ZSh1bnNhZmVSZXMsIGpzb25ScGNSZXN1bHRBbmRDb250ZXh0KGFycmF5KG51bGxhYmxlKEFjY291bnRJbmZvUmVzdWx0KSkpKTtcbiAgICBpZiAoJ2Vycm9yJyBpbiByZXMpIHtcbiAgICAgIHRocm93IG5ldyBTb2xhbmFKU09OUlBDRXJyb3IocmVzLmVycm9yLCBgZmFpbGVkIHRvIGdldCBpbmZvIGZvciBhY2NvdW50cyAke2tleXN9YCk7XG4gICAgfVxuICAgIHJldHVybiByZXMucmVzdWx0O1xuICB9XG5cbiAgLyoqXG4gICAqIEZldGNoIGFsbCB0aGUgYWNjb3VudCBpbmZvIGZvciBtdWx0aXBsZSBhY2NvdW50cyBzcGVjaWZpZWQgYnkgYW4gYXJyYXkgb2YgcHVibGljIGtleXNcbiAgICovXG4gIGFzeW5jIGdldE11bHRpcGxlQWNjb3VudHNJbmZvKHB1YmxpY0tleXMsIGNvbW1pdG1lbnRPckNvbmZpZykge1xuICAgIGNvbnN0IHJlcyA9IGF3YWl0IHRoaXMuZ2V0TXVsdGlwbGVBY2NvdW50c0luZm9BbmRDb250ZXh0KHB1YmxpY0tleXMsIGNvbW1pdG1lbnRPckNvbmZpZyk7XG4gICAgcmV0dXJuIHJlcy52YWx1ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGVwb2NoIGFjdGl2YXRpb24gaW5mb3JtYXRpb24gZm9yIGEgc3Rha2UgYWNjb3VudCB0aGF0IGhhcyBiZWVuIGRlbGVnYXRlZFxuICAgKi9cbiAgYXN5bmMgZ2V0U3Rha2VBY3RpdmF0aW9uKHB1YmxpY0tleSwgY29tbWl0bWVudE9yQ29uZmlnLCBlcG9jaCkge1xuICAgIGNvbnN0IHtcbiAgICAgIGNvbW1pdG1lbnQsXG4gICAgICBjb25maWdcbiAgICB9ID0gZXh0cmFjdENvbW1pdG1lbnRGcm9tQ29uZmlnKGNvbW1pdG1lbnRPckNvbmZpZyk7XG4gICAgY29uc3QgYXJncyA9IHRoaXMuX2J1aWxkQXJncyhbcHVibGljS2V5LnRvQmFzZTU4KCldLCBjb21taXRtZW50LCB1bmRlZmluZWQgLyogZW5jb2RpbmcgKi8sIHtcbiAgICAgIC4uLmNvbmZpZyxcbiAgICAgIGVwb2NoOiBlcG9jaCAhPSBudWxsID8gZXBvY2ggOiBjb25maWc/LmVwb2NoXG4gICAgfSk7XG4gICAgY29uc3QgdW5zYWZlUmVzID0gYXdhaXQgdGhpcy5fcnBjUmVxdWVzdCgnZ2V0U3Rha2VBY3RpdmF0aW9uJywgYXJncyk7XG4gICAgY29uc3QgcmVzID0gY3JlYXRlKHVuc2FmZVJlcywganNvblJwY1Jlc3VsdChTdGFrZUFjdGl2YXRpb25SZXN1bHQpKTtcbiAgICBpZiAoJ2Vycm9yJyBpbiByZXMpIHtcbiAgICAgIHRocm93IG5ldyBTb2xhbmFKU09OUlBDRXJyb3IocmVzLmVycm9yLCBgZmFpbGVkIHRvIGdldCBTdGFrZSBBY3RpdmF0aW9uICR7cHVibGljS2V5LnRvQmFzZTU4KCl9YCk7XG4gICAgfVxuICAgIHJldHVybiByZXMucmVzdWx0O1xuICB9XG5cbiAgLyoqXG4gICAqIEZldGNoIGFsbCB0aGUgYWNjb3VudHMgb3duZWQgYnkgdGhlIHNwZWNpZmllZCBwcm9ncmFtIGlkXG4gICAqXG4gICAqIEByZXR1cm4ge1Byb21pc2U8QXJyYXk8e3B1YmtleTogUHVibGljS2V5LCBhY2NvdW50OiBBY2NvdW50SW5mbzxCdWZmZXI+fT4+fVxuICAgKi9cblxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tZHVwZS1jbGFzcy1tZW1iZXJzXG5cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWR1cGUtY2xhc3MtbWVtYmVyc1xuICBhc3luYyBnZXRQcm9ncmFtQWNjb3VudHMocHJvZ3JhbUlkLCBjb25maWdPckNvbW1pdG1lbnQpIHtcbiAgICBjb25zdCB7XG4gICAgICBjb21taXRtZW50LFxuICAgICAgY29uZmlnXG4gICAgfSA9IGV4dHJhY3RDb21taXRtZW50RnJvbUNvbmZpZyhjb25maWdPckNvbW1pdG1lbnQpO1xuICAgIGNvbnN0IHtcbiAgICAgIGVuY29kaW5nLFxuICAgICAgLi4uY29uZmlnV2l0aG91dEVuY29kaW5nXG4gICAgfSA9IGNvbmZpZyB8fCB7fTtcbiAgICBjb25zdCBhcmdzID0gdGhpcy5fYnVpbGRBcmdzKFtwcm9ncmFtSWQudG9CYXNlNTgoKV0sIGNvbW1pdG1lbnQsIGVuY29kaW5nIHx8ICdiYXNlNjQnLCBjb25maWdXaXRob3V0RW5jb2RpbmcpO1xuICAgIGNvbnN0IHVuc2FmZVJlcyA9IGF3YWl0IHRoaXMuX3JwY1JlcXVlc3QoJ2dldFByb2dyYW1BY2NvdW50cycsIGFyZ3MpO1xuICAgIGNvbnN0IGJhc2VTY2hlbWEgPSBhcnJheShLZXllZEFjY291bnRJbmZvUmVzdWx0KTtcbiAgICBjb25zdCByZXMgPSBjb25maWdXaXRob3V0RW5jb2Rpbmcud2l0aENvbnRleHQgPT09IHRydWUgPyBjcmVhdGUodW5zYWZlUmVzLCBqc29uUnBjUmVzdWx0QW5kQ29udGV4dChiYXNlU2NoZW1hKSkgOiBjcmVhdGUodW5zYWZlUmVzLCBqc29uUnBjUmVzdWx0KGJhc2VTY2hlbWEpKTtcbiAgICBpZiAoJ2Vycm9yJyBpbiByZXMpIHtcbiAgICAgIHRocm93IG5ldyBTb2xhbmFKU09OUlBDRXJyb3IocmVzLmVycm9yLCBgZmFpbGVkIHRvIGdldCBhY2NvdW50cyBvd25lZCBieSBwcm9ncmFtICR7cHJvZ3JhbUlkLnRvQmFzZTU4KCl9YCk7XG4gICAgfVxuICAgIHJldHVybiByZXMucmVzdWx0O1xuICB9XG5cbiAgLyoqXG4gICAqIEZldGNoIGFuZCBwYXJzZSBhbGwgdGhlIGFjY291bnRzIG93bmVkIGJ5IHRoZSBzcGVjaWZpZWQgcHJvZ3JhbSBpZFxuICAgKlxuICAgKiBAcmV0dXJuIHtQcm9taXNlPEFycmF5PHtwdWJrZXk6IFB1YmxpY0tleSwgYWNjb3VudDogQWNjb3VudEluZm88QnVmZmVyIHwgUGFyc2VkQWNjb3VudERhdGE+fT4+fVxuICAgKi9cbiAgYXN5bmMgZ2V0UGFyc2VkUHJvZ3JhbUFjY291bnRzKHByb2dyYW1JZCwgY29uZmlnT3JDb21taXRtZW50KSB7XG4gICAgY29uc3Qge1xuICAgICAgY29tbWl0bWVudCxcbiAgICAgIGNvbmZpZ1xuICAgIH0gPSBleHRyYWN0Q29tbWl0bWVudEZyb21Db25maWcoY29uZmlnT3JDb21taXRtZW50KTtcbiAgICBjb25zdCBhcmdzID0gdGhpcy5fYnVpbGRBcmdzKFtwcm9ncmFtSWQudG9CYXNlNTgoKV0sIGNvbW1pdG1lbnQsICdqc29uUGFyc2VkJywgY29uZmlnKTtcbiAgICBjb25zdCB1bnNhZmVSZXMgPSBhd2FpdCB0aGlzLl9ycGNSZXF1ZXN0KCdnZXRQcm9ncmFtQWNjb3VudHMnLCBhcmdzKTtcbiAgICBjb25zdCByZXMgPSBjcmVhdGUodW5zYWZlUmVzLCBqc29uUnBjUmVzdWx0KGFycmF5KEtleWVkUGFyc2VkQWNjb3VudEluZm9SZXN1bHQpKSk7XG4gICAgaWYgKCdlcnJvcicgaW4gcmVzKSB7XG4gICAgICB0aHJvdyBuZXcgU29sYW5hSlNPTlJQQ0Vycm9yKHJlcy5lcnJvciwgYGZhaWxlZCB0byBnZXQgYWNjb3VudHMgb3duZWQgYnkgcHJvZ3JhbSAke3Byb2dyYW1JZC50b0Jhc2U1OCgpfWApO1xuICAgIH1cbiAgICByZXR1cm4gcmVzLnJlc3VsdDtcbiAgfVxuXG4gIC8qKiBAZGVwcmVjYXRlZCBJbnN0ZWFkLCBjYWxsIGBjb25maXJtVHJhbnNhY3Rpb25gIGFuZCBwYXNzIGluIHtAbGluayBUcmFuc2FjdGlvbkNvbmZpcm1hdGlvblN0cmF0ZWd5fSAqL1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tZHVwZS1jbGFzcy1tZW1iZXJzXG5cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWR1cGUtY2xhc3MtbWVtYmVyc1xuICBhc3luYyBjb25maXJtVHJhbnNhY3Rpb24oc3RyYXRlZ3ksIGNvbW1pdG1lbnQpIHtcbiAgICBsZXQgcmF3U2lnbmF0dXJlO1xuICAgIGlmICh0eXBlb2Ygc3RyYXRlZ3kgPT0gJ3N0cmluZycpIHtcbiAgICAgIHJhd1NpZ25hdHVyZSA9IHN0cmF0ZWd5O1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBjb25maWcgPSBzdHJhdGVneTtcbiAgICAgIGlmIChjb25maWcuYWJvcnRTaWduYWw/LmFib3J0ZWQpIHtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KGNvbmZpZy5hYm9ydFNpZ25hbC5yZWFzb24pO1xuICAgICAgfVxuICAgICAgcmF3U2lnbmF0dXJlID0gY29uZmlnLnNpZ25hdHVyZTtcbiAgICB9XG4gICAgbGV0IGRlY29kZWRTaWduYXR1cmU7XG4gICAgdHJ5IHtcbiAgICAgIGRlY29kZWRTaWduYXR1cmUgPSBiczU4LmRlY29kZShyYXdTaWduYXR1cmUpO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdzaWduYXR1cmUgbXVzdCBiZSBiYXNlNTggZW5jb2RlZDogJyArIHJhd1NpZ25hdHVyZSk7XG4gICAgfVxuICAgIGFzc2VydChkZWNvZGVkU2lnbmF0dXJlLmxlbmd0aCA9PT0gNjQsICdzaWduYXR1cmUgaGFzIGludmFsaWQgbGVuZ3RoJyk7XG4gICAgaWYgKHR5cGVvZiBzdHJhdGVneSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHJldHVybiBhd2FpdCB0aGlzLmNvbmZpcm1UcmFuc2FjdGlvblVzaW5nTGVnYWN5VGltZW91dFN0cmF0ZWd5KHtcbiAgICAgICAgY29tbWl0bWVudDogY29tbWl0bWVudCB8fCB0aGlzLmNvbW1pdG1lbnQsXG4gICAgICAgIHNpZ25hdHVyZTogcmF3U2lnbmF0dXJlXG4gICAgICB9KTtcbiAgICB9IGVsc2UgaWYgKCdsYXN0VmFsaWRCbG9ja0hlaWdodCcgaW4gc3RyYXRlZ3kpIHtcbiAgICAgIHJldHVybiBhd2FpdCB0aGlzLmNvbmZpcm1UcmFuc2FjdGlvblVzaW5nQmxvY2tIZWlnaHRFeGNlZWRhbmNlU3RyYXRlZ3koe1xuICAgICAgICBjb21taXRtZW50OiBjb21taXRtZW50IHx8IHRoaXMuY29tbWl0bWVudCxcbiAgICAgICAgc3RyYXRlZ3lcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gYXdhaXQgdGhpcy5jb25maXJtVHJhbnNhY3Rpb25Vc2luZ0R1cmFibGVOb25jZVN0cmF0ZWd5KHtcbiAgICAgICAgY29tbWl0bWVudDogY29tbWl0bWVudCB8fCB0aGlzLmNvbW1pdG1lbnQsXG4gICAgICAgIHN0cmF0ZWd5XG4gICAgICB9KTtcbiAgICB9XG4gIH1cbiAgZ2V0Q2FuY2VsbGF0aW9uUHJvbWlzZShzaWduYWwpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKF8sIHJlamVjdCkgPT4ge1xuICAgICAgaWYgKHNpZ25hbCA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmIChzaWduYWwuYWJvcnRlZCkge1xuICAgICAgICByZWplY3Qoc2lnbmFsLnJlYXNvbik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzaWduYWwuYWRkRXZlbnRMaXN0ZW5lcignYWJvcnQnLCAoKSA9PiB7XG4gICAgICAgICAgcmVqZWN0KHNpZ25hbC5yZWFzb24pO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICBnZXRUcmFuc2FjdGlvbkNvbmZpcm1hdGlvblByb21pc2Uoe1xuICAgIGNvbW1pdG1lbnQsXG4gICAgc2lnbmF0dXJlXG4gIH0pIHtcbiAgICBsZXQgc2lnbmF0dXJlU3Vic2NyaXB0aW9uSWQ7XG4gICAgbGV0IGRpc3Bvc2VTaWduYXR1cmVTdWJzY3JpcHRpb25TdGF0ZUNoYW5nZU9ic2VydmVyO1xuICAgIGxldCBkb25lID0gZmFsc2U7XG4gICAgY29uc3QgY29uZmlybWF0aW9uUHJvbWlzZSA9IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHNpZ25hdHVyZVN1YnNjcmlwdGlvbklkID0gdGhpcy5vblNpZ25hdHVyZShzaWduYXR1cmUsIChyZXN1bHQsIGNvbnRleHQpID0+IHtcbiAgICAgICAgICBzaWduYXR1cmVTdWJzY3JpcHRpb25JZCA9IHVuZGVmaW5lZDtcbiAgICAgICAgICBjb25zdCByZXNwb25zZSA9IHtcbiAgICAgICAgICAgIGNvbnRleHQsXG4gICAgICAgICAgICB2YWx1ZTogcmVzdWx0XG4gICAgICAgICAgfTtcbiAgICAgICAgICByZXNvbHZlKHtcbiAgICAgICAgICAgIF9fdHlwZTogVHJhbnNhY3Rpb25TdGF0dXMuUFJPQ0VTU0VELFxuICAgICAgICAgICAgcmVzcG9uc2VcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSwgY29tbWl0bWVudCk7XG4gICAgICAgIGNvbnN0IHN1YnNjcmlwdGlvblNldHVwUHJvbWlzZSA9IG5ldyBQcm9taXNlKHJlc29sdmVTdWJzY3JpcHRpb25TZXR1cCA9PiB7XG4gICAgICAgICAgaWYgKHNpZ25hdHVyZVN1YnNjcmlwdGlvbklkID09IG51bGwpIHtcbiAgICAgICAgICAgIHJlc29sdmVTdWJzY3JpcHRpb25TZXR1cCgpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBkaXNwb3NlU2lnbmF0dXJlU3Vic2NyaXB0aW9uU3RhdGVDaGFuZ2VPYnNlcnZlciA9IHRoaXMuX29uU3Vic2NyaXB0aW9uU3RhdGVDaGFuZ2Uoc2lnbmF0dXJlU3Vic2NyaXB0aW9uSWQsIG5leHRTdGF0ZSA9PiB7XG4gICAgICAgICAgICAgIGlmIChuZXh0U3RhdGUgPT09ICdzdWJzY3JpYmVkJykge1xuICAgICAgICAgICAgICAgIHJlc29sdmVTdWJzY3JpcHRpb25TZXR1cCgpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICAoYXN5bmMgKCkgPT4ge1xuICAgICAgICAgIGF3YWl0IHN1YnNjcmlwdGlvblNldHVwUHJvbWlzZTtcbiAgICAgICAgICBpZiAoZG9uZSkgcmV0dXJuO1xuICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5nZXRTaWduYXR1cmVTdGF0dXMoc2lnbmF0dXJlKTtcbiAgICAgICAgICBpZiAoZG9uZSkgcmV0dXJuO1xuICAgICAgICAgIGlmIChyZXNwb25zZSA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnN0IHtcbiAgICAgICAgICAgIGNvbnRleHQsXG4gICAgICAgICAgICB2YWx1ZVxuICAgICAgICAgIH0gPSByZXNwb25zZTtcbiAgICAgICAgICBpZiAodmFsdWUgPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAodmFsdWU/LmVycikge1xuICAgICAgICAgICAgcmVqZWN0KHZhbHVlLmVycik7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHN3aXRjaCAoY29tbWl0bWVudCkge1xuICAgICAgICAgICAgICBjYXNlICdjb25maXJtZWQnOlxuICAgICAgICAgICAgICBjYXNlICdzaW5nbGUnOlxuICAgICAgICAgICAgICBjYXNlICdzaW5nbGVHb3NzaXAnOlxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZS5jb25maXJtYXRpb25TdGF0dXMgPT09ICdwcm9jZXNzZWQnKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgY2FzZSAnZmluYWxpemVkJzpcbiAgICAgICAgICAgICAgY2FzZSAnbWF4JzpcbiAgICAgICAgICAgICAgY2FzZSAncm9vdCc6XG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlLmNvbmZpcm1hdGlvblN0YXR1cyA9PT0gJ3Byb2Nlc3NlZCcgfHwgdmFsdWUuY29uZmlybWF0aW9uU3RhdHVzID09PSAnY29uZmlybWVkJykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIC8vIGV4aGF1c3QgZW51bXMgdG8gZW5zdXJlIGZ1bGwgY292ZXJhZ2VcbiAgICAgICAgICAgICAgY2FzZSAncHJvY2Vzc2VkJzpcbiAgICAgICAgICAgICAgY2FzZSAncmVjZW50JzpcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRvbmUgPSB0cnVlO1xuICAgICAgICAgICAgcmVzb2x2ZSh7XG4gICAgICAgICAgICAgIF9fdHlwZTogVHJhbnNhY3Rpb25TdGF0dXMuUFJPQ0VTU0VELFxuICAgICAgICAgICAgICByZXNwb25zZToge1xuICAgICAgICAgICAgICAgIGNvbnRleHQsXG4gICAgICAgICAgICAgICAgdmFsdWVcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9KSgpO1xuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIHJlamVjdChlcnIpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIGNvbnN0IGFib3J0Q29uZmlybWF0aW9uID0gKCkgPT4ge1xuICAgICAgaWYgKGRpc3Bvc2VTaWduYXR1cmVTdWJzY3JpcHRpb25TdGF0ZUNoYW5nZU9ic2VydmVyKSB7XG4gICAgICAgIGRpc3Bvc2VTaWduYXR1cmVTdWJzY3JpcHRpb25TdGF0ZUNoYW5nZU9ic2VydmVyKCk7XG4gICAgICAgIGRpc3Bvc2VTaWduYXR1cmVTdWJzY3JpcHRpb25TdGF0ZUNoYW5nZU9ic2VydmVyID0gdW5kZWZpbmVkO1xuICAgICAgfVxuICAgICAgaWYgKHNpZ25hdHVyZVN1YnNjcmlwdGlvbklkICE9IG51bGwpIHtcbiAgICAgICAgdGhpcy5yZW1vdmVTaWduYXR1cmVMaXN0ZW5lcihzaWduYXR1cmVTdWJzY3JpcHRpb25JZCk7XG4gICAgICAgIHNpZ25hdHVyZVN1YnNjcmlwdGlvbklkID0gdW5kZWZpbmVkO1xuICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIHtcbiAgICAgIGFib3J0Q29uZmlybWF0aW9uLFxuICAgICAgY29uZmlybWF0aW9uUHJvbWlzZVxuICAgIH07XG4gIH1cbiAgYXN5bmMgY29uZmlybVRyYW5zYWN0aW9uVXNpbmdCbG9ja0hlaWdodEV4Y2VlZGFuY2VTdHJhdGVneSh7XG4gICAgY29tbWl0bWVudCxcbiAgICBzdHJhdGVneToge1xuICAgICAgYWJvcnRTaWduYWwsXG4gICAgICBsYXN0VmFsaWRCbG9ja0hlaWdodCxcbiAgICAgIHNpZ25hdHVyZVxuICAgIH1cbiAgfSkge1xuICAgIGxldCBkb25lID0gZmFsc2U7XG4gICAgY29uc3QgZXhwaXJ5UHJvbWlzZSA9IG5ldyBQcm9taXNlKHJlc29sdmUgPT4ge1xuICAgICAgY29uc3QgY2hlY2tCbG9ja0hlaWdodCA9IGFzeW5jICgpID0+IHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBjb25zdCBibG9ja0hlaWdodCA9IGF3YWl0IHRoaXMuZ2V0QmxvY2tIZWlnaHQoY29tbWl0bWVudCk7XG4gICAgICAgICAgcmV0dXJuIGJsb2NrSGVpZ2h0O1xuICAgICAgICB9IGNhdGNoIChfZSkge1xuICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIChhc3luYyAoKSA9PiB7XG4gICAgICAgIGxldCBjdXJyZW50QmxvY2tIZWlnaHQgPSBhd2FpdCBjaGVja0Jsb2NrSGVpZ2h0KCk7XG4gICAgICAgIGlmIChkb25lKSByZXR1cm47XG4gICAgICAgIHdoaWxlIChjdXJyZW50QmxvY2tIZWlnaHQgPD0gbGFzdFZhbGlkQmxvY2tIZWlnaHQpIHtcbiAgICAgICAgICBhd2FpdCBzbGVlcCgxMDAwKTtcbiAgICAgICAgICBpZiAoZG9uZSkgcmV0dXJuO1xuICAgICAgICAgIGN1cnJlbnRCbG9ja0hlaWdodCA9IGF3YWl0IGNoZWNrQmxvY2tIZWlnaHQoKTtcbiAgICAgICAgICBpZiAoZG9uZSkgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHJlc29sdmUoe1xuICAgICAgICAgIF9fdHlwZTogVHJhbnNhY3Rpb25TdGF0dXMuQkxPQ0tIRUlHSFRfRVhDRUVERURcbiAgICAgICAgfSk7XG4gICAgICB9KSgpO1xuICAgIH0pO1xuICAgIGNvbnN0IHtcbiAgICAgIGFib3J0Q29uZmlybWF0aW9uLFxuICAgICAgY29uZmlybWF0aW9uUHJvbWlzZVxuICAgIH0gPSB0aGlzLmdldFRyYW5zYWN0aW9uQ29uZmlybWF0aW9uUHJvbWlzZSh7XG4gICAgICBjb21taXRtZW50LFxuICAgICAgc2lnbmF0dXJlXG4gICAgfSk7XG4gICAgY29uc3QgY2FuY2VsbGF0aW9uUHJvbWlzZSA9IHRoaXMuZ2V0Q2FuY2VsbGF0aW9uUHJvbWlzZShhYm9ydFNpZ25hbCk7XG4gICAgbGV0IHJlc3VsdDtcbiAgICB0cnkge1xuICAgICAgY29uc3Qgb3V0Y29tZSA9IGF3YWl0IFByb21pc2UucmFjZShbY2FuY2VsbGF0aW9uUHJvbWlzZSwgY29uZmlybWF0aW9uUHJvbWlzZSwgZXhwaXJ5UHJvbWlzZV0pO1xuICAgICAgaWYgKG91dGNvbWUuX190eXBlID09PSBUcmFuc2FjdGlvblN0YXR1cy5QUk9DRVNTRUQpIHtcbiAgICAgICAgcmVzdWx0ID0gb3V0Y29tZS5yZXNwb25zZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBUcmFuc2FjdGlvbkV4cGlyZWRCbG9ja2hlaWdodEV4Y2VlZGVkRXJyb3Ioc2lnbmF0dXJlKTtcbiAgICAgIH1cbiAgICB9IGZpbmFsbHkge1xuICAgICAgZG9uZSA9IHRydWU7XG4gICAgICBhYm9ydENvbmZpcm1hdGlvbigpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG4gIGFzeW5jIGNvbmZpcm1UcmFuc2FjdGlvblVzaW5nRHVyYWJsZU5vbmNlU3RyYXRlZ3koe1xuICAgIGNvbW1pdG1lbnQsXG4gICAgc3RyYXRlZ3k6IHtcbiAgICAgIGFib3J0U2lnbmFsLFxuICAgICAgbWluQ29udGV4dFNsb3QsXG4gICAgICBub25jZUFjY291bnRQdWJrZXksXG4gICAgICBub25jZVZhbHVlLFxuICAgICAgc2lnbmF0dXJlXG4gICAgfVxuICB9KSB7XG4gICAgbGV0IGRvbmUgPSBmYWxzZTtcbiAgICBjb25zdCBleHBpcnlQcm9taXNlID0gbmV3IFByb21pc2UocmVzb2x2ZSA9PiB7XG4gICAgICBsZXQgY3VycmVudE5vbmNlVmFsdWUgPSBub25jZVZhbHVlO1xuICAgICAgbGV0IGxhc3RDaGVja2VkU2xvdCA9IG51bGw7XG4gICAgICBjb25zdCBnZXRDdXJyZW50Tm9uY2VWYWx1ZSA9IGFzeW5jICgpID0+IHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBjb25zdCB7XG4gICAgICAgICAgICBjb250ZXh0LFxuICAgICAgICAgICAgdmFsdWU6IG5vbmNlQWNjb3VudFxuICAgICAgICAgIH0gPSBhd2FpdCB0aGlzLmdldE5vbmNlQW5kQ29udGV4dChub25jZUFjY291bnRQdWJrZXksIHtcbiAgICAgICAgICAgIGNvbW1pdG1lbnQsXG4gICAgICAgICAgICBtaW5Db250ZXh0U2xvdFxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGxhc3RDaGVja2VkU2xvdCA9IGNvbnRleHQuc2xvdDtcbiAgICAgICAgICByZXR1cm4gbm9uY2VBY2NvdW50Py5ub25jZTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIC8vIElmIGZvciB3aGF0ZXZlciByZWFzb24gd2UgY2FuJ3QgcmVhY2gvcmVhZCB0aGUgbm9uY2VcbiAgICAgICAgICAvLyBhY2NvdW50LCBqdXN0IGtlZXAgdXNpbmcgdGhlIGxhc3Qta25vd24gdmFsdWUuXG4gICAgICAgICAgcmV0dXJuIGN1cnJlbnROb25jZVZhbHVlO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgKGFzeW5jICgpID0+IHtcbiAgICAgICAgY3VycmVudE5vbmNlVmFsdWUgPSBhd2FpdCBnZXRDdXJyZW50Tm9uY2VWYWx1ZSgpO1xuICAgICAgICBpZiAoZG9uZSkgcmV0dXJuO1xuICAgICAgICB3aGlsZSAodHJ1ZSAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLWNvbnN0YW50LWNvbmRpdGlvblxuICAgICAgICApIHtcbiAgICAgICAgICBpZiAobm9uY2VWYWx1ZSAhPT0gY3VycmVudE5vbmNlVmFsdWUpIHtcbiAgICAgICAgICAgIHJlc29sdmUoe1xuICAgICAgICAgICAgICBfX3R5cGU6IFRyYW5zYWN0aW9uU3RhdHVzLk5PTkNFX0lOVkFMSUQsXG4gICAgICAgICAgICAgIHNsb3RJbldoaWNoTm9uY2VEaWRBZHZhbmNlOiBsYXN0Q2hlY2tlZFNsb3RcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICBhd2FpdCBzbGVlcCgyMDAwKTtcbiAgICAgICAgICBpZiAoZG9uZSkgcmV0dXJuO1xuICAgICAgICAgIGN1cnJlbnROb25jZVZhbHVlID0gYXdhaXQgZ2V0Q3VycmVudE5vbmNlVmFsdWUoKTtcbiAgICAgICAgICBpZiAoZG9uZSkgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICB9KSgpO1xuICAgIH0pO1xuICAgIGNvbnN0IHtcbiAgICAgIGFib3J0Q29uZmlybWF0aW9uLFxuICAgICAgY29uZmlybWF0aW9uUHJvbWlzZVxuICAgIH0gPSB0aGlzLmdldFRyYW5zYWN0aW9uQ29uZmlybWF0aW9uUHJvbWlzZSh7XG4gICAgICBjb21taXRtZW50LFxuICAgICAgc2lnbmF0dXJlXG4gICAgfSk7XG4gICAgY29uc3QgY2FuY2VsbGF0aW9uUHJvbWlzZSA9IHRoaXMuZ2V0Q2FuY2VsbGF0aW9uUHJvbWlzZShhYm9ydFNpZ25hbCk7XG4gICAgbGV0IHJlc3VsdDtcbiAgICB0cnkge1xuICAgICAgY29uc3Qgb3V0Y29tZSA9IGF3YWl0IFByb21pc2UucmFjZShbY2FuY2VsbGF0aW9uUHJvbWlzZSwgY29uZmlybWF0aW9uUHJvbWlzZSwgZXhwaXJ5UHJvbWlzZV0pO1xuICAgICAgaWYgKG91dGNvbWUuX190eXBlID09PSBUcmFuc2FjdGlvblN0YXR1cy5QUk9DRVNTRUQpIHtcbiAgICAgICAgcmVzdWx0ID0gb3V0Y29tZS5yZXNwb25zZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIERvdWJsZSBjaGVjayB0aGF0IHRoZSB0cmFuc2FjdGlvbiBpcyBpbmRlZWQgdW5jb25maXJtZWQuXG4gICAgICAgIGxldCBzaWduYXR1cmVTdGF0dXM7XG4gICAgICAgIHdoaWxlICh0cnVlIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tY29uc3RhbnQtY29uZGl0aW9uXG4gICAgICAgICkge1xuICAgICAgICAgIGNvbnN0IHN0YXR1cyA9IGF3YWl0IHRoaXMuZ2V0U2lnbmF0dXJlU3RhdHVzKHNpZ25hdHVyZSk7XG4gICAgICAgICAgaWYgKHN0YXR1cyA9PSBudWxsKSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHN0YXR1cy5jb250ZXh0LnNsb3QgPCAob3V0Y29tZS5zbG90SW5XaGljaE5vbmNlRGlkQWR2YW5jZSA/PyBtaW5Db250ZXh0U2xvdCkpIHtcbiAgICAgICAgICAgIGF3YWl0IHNsZWVwKDQwMCk7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgc2lnbmF0dXJlU3RhdHVzID0gc3RhdHVzO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzaWduYXR1cmVTdGF0dXM/LnZhbHVlKSB7XG4gICAgICAgICAgY29uc3QgY29tbWl0bWVudEZvclN0YXR1cyA9IGNvbW1pdG1lbnQgfHwgJ2ZpbmFsaXplZCc7XG4gICAgICAgICAgY29uc3Qge1xuICAgICAgICAgICAgY29uZmlybWF0aW9uU3RhdHVzXG4gICAgICAgICAgfSA9IHNpZ25hdHVyZVN0YXR1cy52YWx1ZTtcbiAgICAgICAgICBzd2l0Y2ggKGNvbW1pdG1lbnRGb3JTdGF0dXMpIHtcbiAgICAgICAgICAgIGNhc2UgJ3Byb2Nlc3NlZCc6XG4gICAgICAgICAgICBjYXNlICdyZWNlbnQnOlxuICAgICAgICAgICAgICBpZiAoY29uZmlybWF0aW9uU3RhdHVzICE9PSAncHJvY2Vzc2VkJyAmJiBjb25maXJtYXRpb25TdGF0dXMgIT09ICdjb25maXJtZWQnICYmIGNvbmZpcm1hdGlvblN0YXR1cyAhPT0gJ2ZpbmFsaXplZCcpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHJhbnNhY3Rpb25FeHBpcmVkTm9uY2VJbnZhbGlkRXJyb3Ioc2lnbmF0dXJlKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ2NvbmZpcm1lZCc6XG4gICAgICAgICAgICBjYXNlICdzaW5nbGUnOlxuICAgICAgICAgICAgY2FzZSAnc2luZ2xlR29zc2lwJzpcbiAgICAgICAgICAgICAgaWYgKGNvbmZpcm1hdGlvblN0YXR1cyAhPT0gJ2NvbmZpcm1lZCcgJiYgY29uZmlybWF0aW9uU3RhdHVzICE9PSAnZmluYWxpemVkJykge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBUcmFuc2FjdGlvbkV4cGlyZWROb25jZUludmFsaWRFcnJvcihzaWduYXR1cmUpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnZmluYWxpemVkJzpcbiAgICAgICAgICAgIGNhc2UgJ21heCc6XG4gICAgICAgICAgICBjYXNlICdyb290JzpcbiAgICAgICAgICAgICAgaWYgKGNvbmZpcm1hdGlvblN0YXR1cyAhPT0gJ2ZpbmFsaXplZCcpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHJhbnNhY3Rpb25FeHBpcmVkTm9uY2VJbnZhbGlkRXJyb3Ioc2lnbmF0dXJlKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgIC8vIEV4aGF1c3RpdmUgc3dpdGNoLlxuICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVudXNlZC12YXJzXG4gICAgICAgICAgICAgIChfID0+IHt9KShjb21taXRtZW50Rm9yU3RhdHVzKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmVzdWx0ID0ge1xuICAgICAgICAgICAgY29udGV4dDogc2lnbmF0dXJlU3RhdHVzLmNvbnRleHQsXG4gICAgICAgICAgICB2YWx1ZToge1xuICAgICAgICAgICAgICBlcnI6IHNpZ25hdHVyZVN0YXR1cy52YWx1ZS5lcnJcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRocm93IG5ldyBUcmFuc2FjdGlvbkV4cGlyZWROb25jZUludmFsaWRFcnJvcihzaWduYXR1cmUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIGRvbmUgPSB0cnVlO1xuICAgICAgYWJvcnRDb25maXJtYXRpb24oKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuICBhc3luYyBjb25maXJtVHJhbnNhY3Rpb25Vc2luZ0xlZ2FjeVRpbWVvdXRTdHJhdGVneSh7XG4gICAgY29tbWl0bWVudCxcbiAgICBzaWduYXR1cmVcbiAgfSkge1xuICAgIGxldCB0aW1lb3V0SWQ7XG4gICAgY29uc3QgZXhwaXJ5UHJvbWlzZSA9IG5ldyBQcm9taXNlKHJlc29sdmUgPT4ge1xuICAgICAgbGV0IHRpbWVvdXRNcyA9IHRoaXMuX2NvbmZpcm1UcmFuc2FjdGlvbkluaXRpYWxUaW1lb3V0IHx8IDYwICogMTAwMDtcbiAgICAgIHN3aXRjaCAoY29tbWl0bWVudCkge1xuICAgICAgICBjYXNlICdwcm9jZXNzZWQnOlxuICAgICAgICBjYXNlICdyZWNlbnQnOlxuICAgICAgICBjYXNlICdzaW5nbGUnOlxuICAgICAgICBjYXNlICdjb25maXJtZWQnOlxuICAgICAgICBjYXNlICdzaW5nbGVHb3NzaXAnOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIHRpbWVvdXRNcyA9IHRoaXMuX2NvbmZpcm1UcmFuc2FjdGlvbkluaXRpYWxUaW1lb3V0IHx8IDMwICogMTAwMDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHRpbWVvdXRJZCA9IHNldFRpbWVvdXQoKCkgPT4gcmVzb2x2ZSh7XG4gICAgICAgIF9fdHlwZTogVHJhbnNhY3Rpb25TdGF0dXMuVElNRURfT1VULFxuICAgICAgICB0aW1lb3V0TXNcbiAgICAgIH0pLCB0aW1lb3V0TXMpO1xuICAgIH0pO1xuICAgIGNvbnN0IHtcbiAgICAgIGFib3J0Q29uZmlybWF0aW9uLFxuICAgICAgY29uZmlybWF0aW9uUHJvbWlzZVxuICAgIH0gPSB0aGlzLmdldFRyYW5zYWN0aW9uQ29uZmlybWF0aW9uUHJvbWlzZSh7XG4gICAgICBjb21taXRtZW50LFxuICAgICAgc2lnbmF0dXJlXG4gICAgfSk7XG4gICAgbGV0IHJlc3VsdDtcbiAgICB0cnkge1xuICAgICAgY29uc3Qgb3V0Y29tZSA9IGF3YWl0IFByb21pc2UucmFjZShbY29uZmlybWF0aW9uUHJvbWlzZSwgZXhwaXJ5UHJvbWlzZV0pO1xuICAgICAgaWYgKG91dGNvbWUuX190eXBlID09PSBUcmFuc2FjdGlvblN0YXR1cy5QUk9DRVNTRUQpIHtcbiAgICAgICAgcmVzdWx0ID0gb3V0Y29tZS5yZXNwb25zZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBUcmFuc2FjdGlvbkV4cGlyZWRUaW1lb3V0RXJyb3Ioc2lnbmF0dXJlLCBvdXRjb21lLnRpbWVvdXRNcyAvIDEwMDApO1xuICAgICAgfVxuICAgIH0gZmluYWxseSB7XG4gICAgICBjbGVhclRpbWVvdXQodGltZW91dElkKTtcbiAgICAgIGFib3J0Q29uZmlybWF0aW9uKCk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJuIHRoZSBsaXN0IG9mIG5vZGVzIHRoYXQgYXJlIGN1cnJlbnRseSBwYXJ0aWNpcGF0aW5nIGluIHRoZSBjbHVzdGVyXG4gICAqL1xuICBhc3luYyBnZXRDbHVzdGVyTm9kZXMoKSB7XG4gICAgY29uc3QgdW5zYWZlUmVzID0gYXdhaXQgdGhpcy5fcnBjUmVxdWVzdCgnZ2V0Q2x1c3Rlck5vZGVzJywgW10pO1xuICAgIGNvbnN0IHJlcyA9IGNyZWF0ZSh1bnNhZmVSZXMsIGpzb25ScGNSZXN1bHQoYXJyYXkoQ29udGFjdEluZm9SZXN1bHQpKSk7XG4gICAgaWYgKCdlcnJvcicgaW4gcmVzKSB7XG4gICAgICB0aHJvdyBuZXcgU29sYW5hSlNPTlJQQ0Vycm9yKHJlcy5lcnJvciwgJ2ZhaWxlZCB0byBnZXQgY2x1c3RlciBub2RlcycpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzLnJlc3VsdDtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gdGhlIGxpc3Qgb2Ygbm9kZXMgdGhhdCBhcmUgY3VycmVudGx5IHBhcnRpY2lwYXRpbmcgaW4gdGhlIGNsdXN0ZXJcbiAgICovXG4gIGFzeW5jIGdldFZvdGVBY2NvdW50cyhjb21taXRtZW50KSB7XG4gICAgY29uc3QgYXJncyA9IHRoaXMuX2J1aWxkQXJncyhbXSwgY29tbWl0bWVudCk7XG4gICAgY29uc3QgdW5zYWZlUmVzID0gYXdhaXQgdGhpcy5fcnBjUmVxdWVzdCgnZ2V0Vm90ZUFjY291bnRzJywgYXJncyk7XG4gICAgY29uc3QgcmVzID0gY3JlYXRlKHVuc2FmZVJlcywgR2V0Vm90ZUFjY291bnRzKTtcbiAgICBpZiAoJ2Vycm9yJyBpbiByZXMpIHtcbiAgICAgIHRocm93IG5ldyBTb2xhbmFKU09OUlBDRXJyb3IocmVzLmVycm9yLCAnZmFpbGVkIHRvIGdldCB2b3RlIGFjY291bnRzJyk7XG4gICAgfVxuICAgIHJldHVybiByZXMucmVzdWx0O1xuICB9XG5cbiAgLyoqXG4gICAqIEZldGNoIHRoZSBjdXJyZW50IHNsb3QgdGhhdCB0aGUgbm9kZSBpcyBwcm9jZXNzaW5nXG4gICAqL1xuICBhc3luYyBnZXRTbG90KGNvbW1pdG1lbnRPckNvbmZpZykge1xuICAgIGNvbnN0IHtcbiAgICAgIGNvbW1pdG1lbnQsXG4gICAgICBjb25maWdcbiAgICB9ID0gZXh0cmFjdENvbW1pdG1lbnRGcm9tQ29uZmlnKGNvbW1pdG1lbnRPckNvbmZpZyk7XG4gICAgY29uc3QgYXJncyA9IHRoaXMuX2J1aWxkQXJncyhbXSwgY29tbWl0bWVudCwgdW5kZWZpbmVkIC8qIGVuY29kaW5nICovLCBjb25maWcpO1xuICAgIGNvbnN0IHVuc2FmZVJlcyA9IGF3YWl0IHRoaXMuX3JwY1JlcXVlc3QoJ2dldFNsb3QnLCBhcmdzKTtcbiAgICBjb25zdCByZXMgPSBjcmVhdGUodW5zYWZlUmVzLCBqc29uUnBjUmVzdWx0KG51bWJlcigpKSk7XG4gICAgaWYgKCdlcnJvcicgaW4gcmVzKSB7XG4gICAgICB0aHJvdyBuZXcgU29sYW5hSlNPTlJQQ0Vycm9yKHJlcy5lcnJvciwgJ2ZhaWxlZCB0byBnZXQgc2xvdCcpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzLnJlc3VsdDtcbiAgfVxuXG4gIC8qKlxuICAgKiBGZXRjaCB0aGUgY3VycmVudCBzbG90IGxlYWRlciBvZiB0aGUgY2x1c3RlclxuICAgKi9cbiAgYXN5bmMgZ2V0U2xvdExlYWRlcihjb21taXRtZW50T3JDb25maWcpIHtcbiAgICBjb25zdCB7XG4gICAgICBjb21taXRtZW50LFxuICAgICAgY29uZmlnXG4gICAgfSA9IGV4dHJhY3RDb21taXRtZW50RnJvbUNvbmZpZyhjb21taXRtZW50T3JDb25maWcpO1xuICAgIGNvbnN0IGFyZ3MgPSB0aGlzLl9idWlsZEFyZ3MoW10sIGNvbW1pdG1lbnQsIHVuZGVmaW5lZCAvKiBlbmNvZGluZyAqLywgY29uZmlnKTtcbiAgICBjb25zdCB1bnNhZmVSZXMgPSBhd2FpdCB0aGlzLl9ycGNSZXF1ZXN0KCdnZXRTbG90TGVhZGVyJywgYXJncyk7XG4gICAgY29uc3QgcmVzID0gY3JlYXRlKHVuc2FmZVJlcywganNvblJwY1Jlc3VsdChzdHJpbmcoKSkpO1xuICAgIGlmICgnZXJyb3InIGluIHJlcykge1xuICAgICAgdGhyb3cgbmV3IFNvbGFuYUpTT05SUENFcnJvcihyZXMuZXJyb3IsICdmYWlsZWQgdG8gZ2V0IHNsb3QgbGVhZGVyJyk7XG4gICAgfVxuICAgIHJldHVybiByZXMucmVzdWx0O1xuICB9XG5cbiAgLyoqXG4gICAqIEZldGNoIGBsaW1pdGAgbnVtYmVyIG9mIHNsb3QgbGVhZGVycyBzdGFydGluZyBmcm9tIGBzdGFydFNsb3RgXG4gICAqXG4gICAqIEBwYXJhbSBzdGFydFNsb3QgZmV0Y2ggc2xvdCBsZWFkZXJzIHN0YXJ0aW5nIGZyb20gdGhpcyBzbG90XG4gICAqIEBwYXJhbSBsaW1pdCBudW1iZXIgb2Ygc2xvdCBsZWFkZXJzIHRvIHJldHVyblxuICAgKi9cbiAgYXN5bmMgZ2V0U2xvdExlYWRlcnMoc3RhcnRTbG90LCBsaW1pdCkge1xuICAgIGNvbnN0IGFyZ3MgPSBbc3RhcnRTbG90LCBsaW1pdF07XG4gICAgY29uc3QgdW5zYWZlUmVzID0gYXdhaXQgdGhpcy5fcnBjUmVxdWVzdCgnZ2V0U2xvdExlYWRlcnMnLCBhcmdzKTtcbiAgICBjb25zdCByZXMgPSBjcmVhdGUodW5zYWZlUmVzLCBqc29uUnBjUmVzdWx0KGFycmF5KFB1YmxpY0tleUZyb21TdHJpbmcpKSk7XG4gICAgaWYgKCdlcnJvcicgaW4gcmVzKSB7XG4gICAgICB0aHJvdyBuZXcgU29sYW5hSlNPTlJQQ0Vycm9yKHJlcy5lcnJvciwgJ2ZhaWxlZCB0byBnZXQgc2xvdCBsZWFkZXJzJyk7XG4gICAgfVxuICAgIHJldHVybiByZXMucmVzdWx0O1xuICB9XG5cbiAgLyoqXG4gICAqIEZldGNoIHRoZSBjdXJyZW50IHN0YXR1cyBvZiBhIHNpZ25hdHVyZVxuICAgKi9cbiAgYXN5bmMgZ2V0U2lnbmF0dXJlU3RhdHVzKHNpZ25hdHVyZSwgY29uZmlnKSB7XG4gICAgY29uc3Qge1xuICAgICAgY29udGV4dCxcbiAgICAgIHZhbHVlOiB2YWx1ZXNcbiAgICB9ID0gYXdhaXQgdGhpcy5nZXRTaWduYXR1cmVTdGF0dXNlcyhbc2lnbmF0dXJlXSwgY29uZmlnKTtcbiAgICBhc3NlcnQodmFsdWVzLmxlbmd0aCA9PT0gMSk7XG4gICAgY29uc3QgdmFsdWUgPSB2YWx1ZXNbMF07XG4gICAgcmV0dXJuIHtcbiAgICAgIGNvbnRleHQsXG4gICAgICB2YWx1ZVxuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogRmV0Y2ggdGhlIGN1cnJlbnQgc3RhdHVzZXMgb2YgYSBiYXRjaCBvZiBzaWduYXR1cmVzXG4gICAqL1xuICBhc3luYyBnZXRTaWduYXR1cmVTdGF0dXNlcyhzaWduYXR1cmVzLCBjb25maWcpIHtcbiAgICBjb25zdCBwYXJhbXMgPSBbc2lnbmF0dXJlc107XG4gICAgaWYgKGNvbmZpZykge1xuICAgICAgcGFyYW1zLnB1c2goY29uZmlnKTtcbiAgICB9XG4gICAgY29uc3QgdW5zYWZlUmVzID0gYXdhaXQgdGhpcy5fcnBjUmVxdWVzdCgnZ2V0U2lnbmF0dXJlU3RhdHVzZXMnLCBwYXJhbXMpO1xuICAgIGNvbnN0IHJlcyA9IGNyZWF0ZSh1bnNhZmVSZXMsIEdldFNpZ25hdHVyZVN0YXR1c2VzUnBjUmVzdWx0KTtcbiAgICBpZiAoJ2Vycm9yJyBpbiByZXMpIHtcbiAgICAgIHRocm93IG5ldyBTb2xhbmFKU09OUlBDRXJyb3IocmVzLmVycm9yLCAnZmFpbGVkIHRvIGdldCBzaWduYXR1cmUgc3RhdHVzJyk7XG4gICAgfVxuICAgIHJldHVybiByZXMucmVzdWx0O1xuICB9XG5cbiAgLyoqXG4gICAqIEZldGNoIHRoZSBjdXJyZW50IHRyYW5zYWN0aW9uIGNvdW50IG9mIHRoZSBjbHVzdGVyXG4gICAqL1xuICBhc3luYyBnZXRUcmFuc2FjdGlvbkNvdW50KGNvbW1pdG1lbnRPckNvbmZpZykge1xuICAgIGNvbnN0IHtcbiAgICAgIGNvbW1pdG1lbnQsXG4gICAgICBjb25maWdcbiAgICB9ID0gZXh0cmFjdENvbW1pdG1lbnRGcm9tQ29uZmlnKGNvbW1pdG1lbnRPckNvbmZpZyk7XG4gICAgY29uc3QgYXJncyA9IHRoaXMuX2J1aWxkQXJncyhbXSwgY29tbWl0bWVudCwgdW5kZWZpbmVkIC8qIGVuY29kaW5nICovLCBjb25maWcpO1xuICAgIGNvbnN0IHVuc2FmZVJlcyA9IGF3YWl0IHRoaXMuX3JwY1JlcXVlc3QoJ2dldFRyYW5zYWN0aW9uQ291bnQnLCBhcmdzKTtcbiAgICBjb25zdCByZXMgPSBjcmVhdGUodW5zYWZlUmVzLCBqc29uUnBjUmVzdWx0KG51bWJlcigpKSk7XG4gICAgaWYgKCdlcnJvcicgaW4gcmVzKSB7XG4gICAgICB0aHJvdyBuZXcgU29sYW5hSlNPTlJQQ0Vycm9yKHJlcy5lcnJvciwgJ2ZhaWxlZCB0byBnZXQgdHJhbnNhY3Rpb24gY291bnQnKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlcy5yZXN1bHQ7XG4gIH1cblxuICAvKipcbiAgICogRmV0Y2ggdGhlIGN1cnJlbnQgdG90YWwgY3VycmVuY3kgc3VwcGx5IG9mIHRoZSBjbHVzdGVyIGluIGxhbXBvcnRzXG4gICAqXG4gICAqIEBkZXByZWNhdGVkIERlcHJlY2F0ZWQgc2luY2UgdjEuMi44LiBQbGVhc2UgdXNlIHtAbGluayBnZXRTdXBwbHl9IGluc3RlYWQuXG4gICAqL1xuICBhc3luYyBnZXRUb3RhbFN1cHBseShjb21taXRtZW50KSB7XG4gICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgdGhpcy5nZXRTdXBwbHkoe1xuICAgICAgY29tbWl0bWVudCxcbiAgICAgIGV4Y2x1ZGVOb25DaXJjdWxhdGluZ0FjY291bnRzTGlzdDogdHJ1ZVxuICAgIH0pO1xuICAgIHJldHVybiByZXN1bHQudmFsdWUudG90YWw7XG4gIH1cblxuICAvKipcbiAgICogRmV0Y2ggdGhlIGNsdXN0ZXIgSW5mbGF0aW9uR292ZXJub3IgcGFyYW1ldGVyc1xuICAgKi9cbiAgYXN5bmMgZ2V0SW5mbGF0aW9uR292ZXJub3IoY29tbWl0bWVudCkge1xuICAgIGNvbnN0IGFyZ3MgPSB0aGlzLl9idWlsZEFyZ3MoW10sIGNvbW1pdG1lbnQpO1xuICAgIGNvbnN0IHVuc2FmZVJlcyA9IGF3YWl0IHRoaXMuX3JwY1JlcXVlc3QoJ2dldEluZmxhdGlvbkdvdmVybm9yJywgYXJncyk7XG4gICAgY29uc3QgcmVzID0gY3JlYXRlKHVuc2FmZVJlcywgR2V0SW5mbGF0aW9uR292ZXJub3JScGNSZXN1bHQpO1xuICAgIGlmICgnZXJyb3InIGluIHJlcykge1xuICAgICAgdGhyb3cgbmV3IFNvbGFuYUpTT05SUENFcnJvcihyZXMuZXJyb3IsICdmYWlsZWQgdG8gZ2V0IGluZmxhdGlvbicpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzLnJlc3VsdDtcbiAgfVxuXG4gIC8qKlxuICAgKiBGZXRjaCB0aGUgaW5mbGF0aW9uIHJld2FyZCBmb3IgYSBsaXN0IG9mIGFkZHJlc3NlcyBmb3IgYW4gZXBvY2hcbiAgICovXG4gIGFzeW5jIGdldEluZmxhdGlvblJld2FyZChhZGRyZXNzZXMsIGVwb2NoLCBjb21taXRtZW50T3JDb25maWcpIHtcbiAgICBjb25zdCB7XG4gICAgICBjb21taXRtZW50LFxuICAgICAgY29uZmlnXG4gICAgfSA9IGV4dHJhY3RDb21taXRtZW50RnJvbUNvbmZpZyhjb21taXRtZW50T3JDb25maWcpO1xuICAgIGNvbnN0IGFyZ3MgPSB0aGlzLl9idWlsZEFyZ3MoW2FkZHJlc3Nlcy5tYXAocHVia2V5ID0+IHB1YmtleS50b0Jhc2U1OCgpKV0sIGNvbW1pdG1lbnQsIHVuZGVmaW5lZCAvKiBlbmNvZGluZyAqLywge1xuICAgICAgLi4uY29uZmlnLFxuICAgICAgZXBvY2g6IGVwb2NoICE9IG51bGwgPyBlcG9jaCA6IGNvbmZpZz8uZXBvY2hcbiAgICB9KTtcbiAgICBjb25zdCB1bnNhZmVSZXMgPSBhd2FpdCB0aGlzLl9ycGNSZXF1ZXN0KCdnZXRJbmZsYXRpb25SZXdhcmQnLCBhcmdzKTtcbiAgICBjb25zdCByZXMgPSBjcmVhdGUodW5zYWZlUmVzLCBHZXRJbmZsYXRpb25SZXdhcmRSZXN1bHQpO1xuICAgIGlmICgnZXJyb3InIGluIHJlcykge1xuICAgICAgdGhyb3cgbmV3IFNvbGFuYUpTT05SUENFcnJvcihyZXMuZXJyb3IsICdmYWlsZWQgdG8gZ2V0IGluZmxhdGlvbiByZXdhcmQnKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlcy5yZXN1bHQ7XG4gIH1cblxuICAvKipcbiAgICogRmV0Y2ggdGhlIHNwZWNpZmljIGluZmxhdGlvbiB2YWx1ZXMgZm9yIHRoZSBjdXJyZW50IGVwb2NoXG4gICAqL1xuICBhc3luYyBnZXRJbmZsYXRpb25SYXRlKCkge1xuICAgIGNvbnN0IHVuc2FmZVJlcyA9IGF3YWl0IHRoaXMuX3JwY1JlcXVlc3QoJ2dldEluZmxhdGlvblJhdGUnLCBbXSk7XG4gICAgY29uc3QgcmVzID0gY3JlYXRlKHVuc2FmZVJlcywgR2V0SW5mbGF0aW9uUmF0ZVJwY1Jlc3VsdCk7XG4gICAgaWYgKCdlcnJvcicgaW4gcmVzKSB7XG4gICAgICB0aHJvdyBuZXcgU29sYW5hSlNPTlJQQ0Vycm9yKHJlcy5lcnJvciwgJ2ZhaWxlZCB0byBnZXQgaW5mbGF0aW9uIHJhdGUnKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlcy5yZXN1bHQ7XG4gIH1cblxuICAvKipcbiAgICogRmV0Y2ggdGhlIEVwb2NoIEluZm8gcGFyYW1ldGVyc1xuICAgKi9cbiAgYXN5bmMgZ2V0RXBvY2hJbmZvKGNvbW1pdG1lbnRPckNvbmZpZykge1xuICAgIGNvbnN0IHtcbiAgICAgIGNvbW1pdG1lbnQsXG4gICAgICBjb25maWdcbiAgICB9ID0gZXh0cmFjdENvbW1pdG1lbnRGcm9tQ29uZmlnKGNvbW1pdG1lbnRPckNvbmZpZyk7XG4gICAgY29uc3QgYXJncyA9IHRoaXMuX2J1aWxkQXJncyhbXSwgY29tbWl0bWVudCwgdW5kZWZpbmVkIC8qIGVuY29kaW5nICovLCBjb25maWcpO1xuICAgIGNvbnN0IHVuc2FmZVJlcyA9IGF3YWl0IHRoaXMuX3JwY1JlcXVlc3QoJ2dldEVwb2NoSW5mbycsIGFyZ3MpO1xuICAgIGNvbnN0IHJlcyA9IGNyZWF0ZSh1bnNhZmVSZXMsIEdldEVwb2NoSW5mb1JwY1Jlc3VsdCk7XG4gICAgaWYgKCdlcnJvcicgaW4gcmVzKSB7XG4gICAgICB0aHJvdyBuZXcgU29sYW5hSlNPTlJQQ0Vycm9yKHJlcy5lcnJvciwgJ2ZhaWxlZCB0byBnZXQgZXBvY2ggaW5mbycpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzLnJlc3VsdDtcbiAgfVxuXG4gIC8qKlxuICAgKiBGZXRjaCB0aGUgRXBvY2ggU2NoZWR1bGUgcGFyYW1ldGVyc1xuICAgKi9cbiAgYXN5bmMgZ2V0RXBvY2hTY2hlZHVsZSgpIHtcbiAgICBjb25zdCB1bnNhZmVSZXMgPSBhd2FpdCB0aGlzLl9ycGNSZXF1ZXN0KCdnZXRFcG9jaFNjaGVkdWxlJywgW10pO1xuICAgIGNvbnN0IHJlcyA9IGNyZWF0ZSh1bnNhZmVSZXMsIEdldEVwb2NoU2NoZWR1bGVScGNSZXN1bHQpO1xuICAgIGlmICgnZXJyb3InIGluIHJlcykge1xuICAgICAgdGhyb3cgbmV3IFNvbGFuYUpTT05SUENFcnJvcihyZXMuZXJyb3IsICdmYWlsZWQgdG8gZ2V0IGVwb2NoIHNjaGVkdWxlJyk7XG4gICAgfVxuICAgIGNvbnN0IGVwb2NoU2NoZWR1bGUgPSByZXMucmVzdWx0O1xuICAgIHJldHVybiBuZXcgRXBvY2hTY2hlZHVsZShlcG9jaFNjaGVkdWxlLnNsb3RzUGVyRXBvY2gsIGVwb2NoU2NoZWR1bGUubGVhZGVyU2NoZWR1bGVTbG90T2Zmc2V0LCBlcG9jaFNjaGVkdWxlLndhcm11cCwgZXBvY2hTY2hlZHVsZS5maXJzdE5vcm1hbEVwb2NoLCBlcG9jaFNjaGVkdWxlLmZpcnN0Tm9ybWFsU2xvdCk7XG4gIH1cblxuICAvKipcbiAgICogRmV0Y2ggdGhlIGxlYWRlciBzY2hlZHVsZSBmb3IgdGhlIGN1cnJlbnQgZXBvY2hcbiAgICogQHJldHVybiB7UHJvbWlzZTxScGNSZXNwb25zZUFuZENvbnRleHQ8TGVhZGVyU2NoZWR1bGU+Pn1cbiAgICovXG4gIGFzeW5jIGdldExlYWRlclNjaGVkdWxlKCkge1xuICAgIGNvbnN0IHVuc2FmZVJlcyA9IGF3YWl0IHRoaXMuX3JwY1JlcXVlc3QoJ2dldExlYWRlclNjaGVkdWxlJywgW10pO1xuICAgIGNvbnN0IHJlcyA9IGNyZWF0ZSh1bnNhZmVSZXMsIEdldExlYWRlclNjaGVkdWxlUnBjUmVzdWx0KTtcbiAgICBpZiAoJ2Vycm9yJyBpbiByZXMpIHtcbiAgICAgIHRocm93IG5ldyBTb2xhbmFKU09OUlBDRXJyb3IocmVzLmVycm9yLCAnZmFpbGVkIHRvIGdldCBsZWFkZXIgc2NoZWR1bGUnKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlcy5yZXN1bHQ7XG4gIH1cblxuICAvKipcbiAgICogRmV0Y2ggdGhlIG1pbmltdW0gYmFsYW5jZSBuZWVkZWQgdG8gZXhlbXB0IGFuIGFjY291bnQgb2YgYGRhdGFMZW5ndGhgXG4gICAqIHNpemUgZnJvbSByZW50XG4gICAqL1xuICBhc3luYyBnZXRNaW5pbXVtQmFsYW5jZUZvclJlbnRFeGVtcHRpb24oZGF0YUxlbmd0aCwgY29tbWl0bWVudCkge1xuICAgIGNvbnN0IGFyZ3MgPSB0aGlzLl9idWlsZEFyZ3MoW2RhdGFMZW5ndGhdLCBjb21taXRtZW50KTtcbiAgICBjb25zdCB1bnNhZmVSZXMgPSBhd2FpdCB0aGlzLl9ycGNSZXF1ZXN0KCdnZXRNaW5pbXVtQmFsYW5jZUZvclJlbnRFeGVtcHRpb24nLCBhcmdzKTtcbiAgICBjb25zdCByZXMgPSBjcmVhdGUodW5zYWZlUmVzLCBHZXRNaW5pbXVtQmFsYW5jZUZvclJlbnRFeGVtcHRpb25ScGNSZXN1bHQpO1xuICAgIGlmICgnZXJyb3InIGluIHJlcykge1xuICAgICAgY29uc29sZS53YXJuKCdVbmFibGUgdG8gZmV0Y2ggbWluaW11bSBiYWxhbmNlIGZvciByZW50IGV4ZW1wdGlvbicpO1xuICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICAgIHJldHVybiByZXMucmVzdWx0O1xuICB9XG5cbiAgLyoqXG4gICAqIEZldGNoIGEgcmVjZW50IGJsb2NraGFzaCBmcm9tIHRoZSBjbHVzdGVyLCByZXR1cm4gd2l0aCBjb250ZXh0XG4gICAqIEByZXR1cm4ge1Byb21pc2U8UnBjUmVzcG9uc2VBbmRDb250ZXh0PHtibG9ja2hhc2g6IEJsb2NraGFzaCwgZmVlQ2FsY3VsYXRvcjogRmVlQ2FsY3VsYXRvcn0+Pn1cbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgRGVwcmVjYXRlZCBzaW5jZSBTb2xhbmEgdjEuOC4wLiBQbGVhc2UgdXNlIHtAbGluayBnZXRMYXRlc3RCbG9ja2hhc2h9IGluc3RlYWQuXG4gICAqL1xuICBhc3luYyBnZXRSZWNlbnRCbG9ja2hhc2hBbmRDb250ZXh0KGNvbW1pdG1lbnQpIHtcbiAgICBjb25zdCBhcmdzID0gdGhpcy5fYnVpbGRBcmdzKFtdLCBjb21taXRtZW50KTtcbiAgICBjb25zdCB1bnNhZmVSZXMgPSBhd2FpdCB0aGlzLl9ycGNSZXF1ZXN0KCdnZXRSZWNlbnRCbG9ja2hhc2gnLCBhcmdzKTtcbiAgICBjb25zdCByZXMgPSBjcmVhdGUodW5zYWZlUmVzLCBHZXRSZWNlbnRCbG9ja2hhc2hBbmRDb250ZXh0UnBjUmVzdWx0KTtcbiAgICBpZiAoJ2Vycm9yJyBpbiByZXMpIHtcbiAgICAgIHRocm93IG5ldyBTb2xhbmFKU09OUlBDRXJyb3IocmVzLmVycm9yLCAnZmFpbGVkIHRvIGdldCByZWNlbnQgYmxvY2toYXNoJyk7XG4gICAgfVxuICAgIHJldHVybiByZXMucmVzdWx0O1xuICB9XG5cbiAgLyoqXG4gICAqIEZldGNoIHJlY2VudCBwZXJmb3JtYW5jZSBzYW1wbGVzXG4gICAqIEByZXR1cm4ge1Byb21pc2U8QXJyYXk8UGVyZlNhbXBsZT4+fVxuICAgKi9cbiAgYXN5bmMgZ2V0UmVjZW50UGVyZm9ybWFuY2VTYW1wbGVzKGxpbWl0KSB7XG4gICAgY29uc3QgdW5zYWZlUmVzID0gYXdhaXQgdGhpcy5fcnBjUmVxdWVzdCgnZ2V0UmVjZW50UGVyZm9ybWFuY2VTYW1wbGVzJywgbGltaXQgPyBbbGltaXRdIDogW10pO1xuICAgIGNvbnN0IHJlcyA9IGNyZWF0ZSh1bnNhZmVSZXMsIEdldFJlY2VudFBlcmZvcm1hbmNlU2FtcGxlc1JwY1Jlc3VsdCk7XG4gICAgaWYgKCdlcnJvcicgaW4gcmVzKSB7XG4gICAgICB0aHJvdyBuZXcgU29sYW5hSlNPTlJQQ0Vycm9yKHJlcy5lcnJvciwgJ2ZhaWxlZCB0byBnZXQgcmVjZW50IHBlcmZvcm1hbmNlIHNhbXBsZXMnKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlcy5yZXN1bHQ7XG4gIH1cblxuICAvKipcbiAgICogRmV0Y2ggdGhlIGZlZSBjYWxjdWxhdG9yIGZvciBhIHJlY2VudCBibG9ja2hhc2ggZnJvbSB0aGUgY2x1c3RlciwgcmV0dXJuIHdpdGggY29udGV4dFxuICAgKlxuICAgKiBAZGVwcmVjYXRlZCBEZXByZWNhdGVkIHNpbmNlIFNvbGFuYSB2MS44LjAuIFBsZWFzZSB1c2Uge0BsaW5rIGdldEZlZUZvck1lc3NhZ2V9IGluc3RlYWQuXG4gICAqL1xuICBhc3luYyBnZXRGZWVDYWxjdWxhdG9yRm9yQmxvY2toYXNoKGJsb2NraGFzaCwgY29tbWl0bWVudCkge1xuICAgIGNvbnN0IGFyZ3MgPSB0aGlzLl9idWlsZEFyZ3MoW2Jsb2NraGFzaF0sIGNvbW1pdG1lbnQpO1xuICAgIGNvbnN0IHVuc2FmZVJlcyA9IGF3YWl0IHRoaXMuX3JwY1JlcXVlc3QoJ2dldEZlZUNhbGN1bGF0b3JGb3JCbG9ja2hhc2gnLCBhcmdzKTtcbiAgICBjb25zdCByZXMgPSBjcmVhdGUodW5zYWZlUmVzLCBHZXRGZWVDYWxjdWxhdG9yUnBjUmVzdWx0KTtcbiAgICBpZiAoJ2Vycm9yJyBpbiByZXMpIHtcbiAgICAgIHRocm93IG5ldyBTb2xhbmFKU09OUlBDRXJyb3IocmVzLmVycm9yLCAnZmFpbGVkIHRvIGdldCBmZWUgY2FsY3VsYXRvcicpO1xuICAgIH1cbiAgICBjb25zdCB7XG4gICAgICBjb250ZXh0LFxuICAgICAgdmFsdWVcbiAgICB9ID0gcmVzLnJlc3VsdDtcbiAgICByZXR1cm4ge1xuICAgICAgY29udGV4dCxcbiAgICAgIHZhbHVlOiB2YWx1ZSAhPT0gbnVsbCA/IHZhbHVlLmZlZUNhbGN1bGF0b3IgOiBudWxsXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBGZXRjaCB0aGUgZmVlIGZvciBhIG1lc3NhZ2UgZnJvbSB0aGUgY2x1c3RlciwgcmV0dXJuIHdpdGggY29udGV4dFxuICAgKi9cbiAgYXN5bmMgZ2V0RmVlRm9yTWVzc2FnZShtZXNzYWdlLCBjb21taXRtZW50KSB7XG4gICAgY29uc3Qgd2lyZU1lc3NhZ2UgPSB0b0J1ZmZlcihtZXNzYWdlLnNlcmlhbGl6ZSgpKS50b1N0cmluZygnYmFzZTY0Jyk7XG4gICAgY29uc3QgYXJncyA9IHRoaXMuX2J1aWxkQXJncyhbd2lyZU1lc3NhZ2VdLCBjb21taXRtZW50KTtcbiAgICBjb25zdCB1bnNhZmVSZXMgPSBhd2FpdCB0aGlzLl9ycGNSZXF1ZXN0KCdnZXRGZWVGb3JNZXNzYWdlJywgYXJncyk7XG4gICAgY29uc3QgcmVzID0gY3JlYXRlKHVuc2FmZVJlcywganNvblJwY1Jlc3VsdEFuZENvbnRleHQobnVsbGFibGUobnVtYmVyKCkpKSk7XG4gICAgaWYgKCdlcnJvcicgaW4gcmVzKSB7XG4gICAgICB0aHJvdyBuZXcgU29sYW5hSlNPTlJQQ0Vycm9yKHJlcy5lcnJvciwgJ2ZhaWxlZCB0byBnZXQgZmVlIGZvciBtZXNzYWdlJyk7XG4gICAgfVxuICAgIGlmIChyZXMucmVzdWx0ID09PSBudWxsKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgYmxvY2toYXNoJyk7XG4gICAgfVxuICAgIHJldHVybiByZXMucmVzdWx0O1xuICB9XG5cbiAgLyoqXG4gICAqIEZldGNoIGEgbGlzdCBvZiBwcmlvcml0aXphdGlvbiBmZWVzIGZyb20gcmVjZW50IGJsb2Nrcy5cbiAgICovXG4gIGFzeW5jIGdldFJlY2VudFByaW9yaXRpemF0aW9uRmVlcyhjb25maWcpIHtcbiAgICBjb25zdCBhY2NvdW50cyA9IGNvbmZpZz8ubG9ja2VkV3JpdGFibGVBY2NvdW50cz8ubWFwKGtleSA9PiBrZXkudG9CYXNlNTgoKSk7XG4gICAgY29uc3QgYXJncyA9IGFjY291bnRzPy5sZW5ndGggPyBbYWNjb3VudHNdIDogW107XG4gICAgY29uc3QgdW5zYWZlUmVzID0gYXdhaXQgdGhpcy5fcnBjUmVxdWVzdCgnZ2V0UmVjZW50UHJpb3JpdGl6YXRpb25GZWVzJywgYXJncyk7XG4gICAgY29uc3QgcmVzID0gY3JlYXRlKHVuc2FmZVJlcywgR2V0UmVjZW50UHJpb3JpdGl6YXRpb25GZWVzUnBjUmVzdWx0KTtcbiAgICBpZiAoJ2Vycm9yJyBpbiByZXMpIHtcbiAgICAgIHRocm93IG5ldyBTb2xhbmFKU09OUlBDRXJyb3IocmVzLmVycm9yLCAnZmFpbGVkIHRvIGdldCByZWNlbnQgcHJpb3JpdGl6YXRpb24gZmVlcycpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzLnJlc3VsdDtcbiAgfVxuICAvKipcbiAgICogRmV0Y2ggYSByZWNlbnQgYmxvY2toYXNoIGZyb20gdGhlIGNsdXN0ZXJcbiAgICogQHJldHVybiB7UHJvbWlzZTx7YmxvY2toYXNoOiBCbG9ja2hhc2gsIGZlZUNhbGN1bGF0b3I6IEZlZUNhbGN1bGF0b3J9Pn1cbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgRGVwcmVjYXRlZCBzaW5jZSBTb2xhbmEgdjEuOC4wLiBQbGVhc2UgdXNlIHtAbGluayBnZXRMYXRlc3RCbG9ja2hhc2h9IGluc3RlYWQuXG4gICAqL1xuICBhc3luYyBnZXRSZWNlbnRCbG9ja2hhc2goY29tbWl0bWVudCkge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCByZXMgPSBhd2FpdCB0aGlzLmdldFJlY2VudEJsb2NraGFzaEFuZENvbnRleHQoY29tbWl0bWVudCk7XG4gICAgICByZXR1cm4gcmVzLnZhbHVlO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignZmFpbGVkIHRvIGdldCByZWNlbnQgYmxvY2toYXNoOiAnICsgZSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEZldGNoIHRoZSBsYXRlc3QgYmxvY2toYXNoIGZyb20gdGhlIGNsdXN0ZXJcbiAgICogQHJldHVybiB7UHJvbWlzZTxCbG9ja2hhc2hXaXRoRXhwaXJ5QmxvY2tIZWlnaHQ+fVxuICAgKi9cbiAgYXN5bmMgZ2V0TGF0ZXN0QmxvY2toYXNoKGNvbW1pdG1lbnRPckNvbmZpZykge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCByZXMgPSBhd2FpdCB0aGlzLmdldExhdGVzdEJsb2NraGFzaEFuZENvbnRleHQoY29tbWl0bWVudE9yQ29uZmlnKTtcbiAgICAgIHJldHVybiByZXMudmFsdWU7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdmYWlsZWQgdG8gZ2V0IHJlY2VudCBibG9ja2hhc2g6ICcgKyBlKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogRmV0Y2ggdGhlIGxhdGVzdCBibG9ja2hhc2ggZnJvbSB0aGUgY2x1c3RlclxuICAgKiBAcmV0dXJuIHtQcm9taXNlPEJsb2NraGFzaFdpdGhFeHBpcnlCbG9ja0hlaWdodD59XG4gICAqL1xuICBhc3luYyBnZXRMYXRlc3RCbG9ja2hhc2hBbmRDb250ZXh0KGNvbW1pdG1lbnRPckNvbmZpZykge1xuICAgIGNvbnN0IHtcbiAgICAgIGNvbW1pdG1lbnQsXG4gICAgICBjb25maWdcbiAgICB9ID0gZXh0cmFjdENvbW1pdG1lbnRGcm9tQ29uZmlnKGNvbW1pdG1lbnRPckNvbmZpZyk7XG4gICAgY29uc3QgYXJncyA9IHRoaXMuX2J1aWxkQXJncyhbXSwgY29tbWl0bWVudCwgdW5kZWZpbmVkIC8qIGVuY29kaW5nICovLCBjb25maWcpO1xuICAgIGNvbnN0IHVuc2FmZVJlcyA9IGF3YWl0IHRoaXMuX3JwY1JlcXVlc3QoJ2dldExhdGVzdEJsb2NraGFzaCcsIGFyZ3MpO1xuICAgIGNvbnN0IHJlcyA9IGNyZWF0ZSh1bnNhZmVSZXMsIEdldExhdGVzdEJsb2NraGFzaFJwY1Jlc3VsdCk7XG4gICAgaWYgKCdlcnJvcicgaW4gcmVzKSB7XG4gICAgICB0aHJvdyBuZXcgU29sYW5hSlNPTlJQQ0Vycm9yKHJlcy5lcnJvciwgJ2ZhaWxlZCB0byBnZXQgbGF0ZXN0IGJsb2NraGFzaCcpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzLnJlc3VsdDtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHdoZXRoZXIgYSBibG9ja2hhc2ggaXMgc3RpbGwgdmFsaWQgb3Igbm90XG4gICAqL1xuICBhc3luYyBpc0Jsb2NraGFzaFZhbGlkKGJsb2NraGFzaCwgcmF3Q29uZmlnKSB7XG4gICAgY29uc3Qge1xuICAgICAgY29tbWl0bWVudCxcbiAgICAgIGNvbmZpZ1xuICAgIH0gPSBleHRyYWN0Q29tbWl0bWVudEZyb21Db25maWcocmF3Q29uZmlnKTtcbiAgICBjb25zdCBhcmdzID0gdGhpcy5fYnVpbGRBcmdzKFtibG9ja2hhc2hdLCBjb21taXRtZW50LCB1bmRlZmluZWQgLyogZW5jb2RpbmcgKi8sIGNvbmZpZyk7XG4gICAgY29uc3QgdW5zYWZlUmVzID0gYXdhaXQgdGhpcy5fcnBjUmVxdWVzdCgnaXNCbG9ja2hhc2hWYWxpZCcsIGFyZ3MpO1xuICAgIGNvbnN0IHJlcyA9IGNyZWF0ZSh1bnNhZmVSZXMsIElzQmxvY2toYXNoVmFsaWRScGNSZXN1bHQpO1xuICAgIGlmICgnZXJyb3InIGluIHJlcykge1xuICAgICAgdGhyb3cgbmV3IFNvbGFuYUpTT05SUENFcnJvcihyZXMuZXJyb3IsICdmYWlsZWQgdG8gZGV0ZXJtaW5lIGlmIHRoZSBibG9ja2hhc2ggYCcgKyBibG9ja2hhc2ggKyAnYGlzIHZhbGlkJyk7XG4gICAgfVxuICAgIHJldHVybiByZXMucmVzdWx0O1xuICB9XG5cbiAgLyoqXG4gICAqIEZldGNoIHRoZSBub2RlIHZlcnNpb25cbiAgICovXG4gIGFzeW5jIGdldFZlcnNpb24oKSB7XG4gICAgY29uc3QgdW5zYWZlUmVzID0gYXdhaXQgdGhpcy5fcnBjUmVxdWVzdCgnZ2V0VmVyc2lvbicsIFtdKTtcbiAgICBjb25zdCByZXMgPSBjcmVhdGUodW5zYWZlUmVzLCBqc29uUnBjUmVzdWx0KFZlcnNpb25SZXN1bHQpKTtcbiAgICBpZiAoJ2Vycm9yJyBpbiByZXMpIHtcbiAgICAgIHRocm93IG5ldyBTb2xhbmFKU09OUlBDRXJyb3IocmVzLmVycm9yLCAnZmFpbGVkIHRvIGdldCB2ZXJzaW9uJyk7XG4gICAgfVxuICAgIHJldHVybiByZXMucmVzdWx0O1xuICB9XG5cbiAgLyoqXG4gICAqIEZldGNoIHRoZSBnZW5lc2lzIGhhc2hcbiAgICovXG4gIGFzeW5jIGdldEdlbmVzaXNIYXNoKCkge1xuICAgIGNvbnN0IHVuc2FmZVJlcyA9IGF3YWl0IHRoaXMuX3JwY1JlcXVlc3QoJ2dldEdlbmVzaXNIYXNoJywgW10pO1xuICAgIGNvbnN0IHJlcyA9IGNyZWF0ZSh1bnNhZmVSZXMsIGpzb25ScGNSZXN1bHQoc3RyaW5nKCkpKTtcbiAgICBpZiAoJ2Vycm9yJyBpbiByZXMpIHtcbiAgICAgIHRocm93IG5ldyBTb2xhbmFKU09OUlBDRXJyb3IocmVzLmVycm9yLCAnZmFpbGVkIHRvIGdldCBnZW5lc2lzIGhhc2gnKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlcy5yZXN1bHQ7XG4gIH1cblxuICAvKipcbiAgICogRmV0Y2ggYSBwcm9jZXNzZWQgYmxvY2sgZnJvbSB0aGUgY2x1c3Rlci5cbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgSW5zdGVhZCwgY2FsbCBgZ2V0QmxvY2tgIHVzaW5nIGEgYEdldFZlcnNpb25lZEJsb2NrQ29uZmlnYCBieVxuICAgKiBzZXR0aW5nIHRoZSBgbWF4U3VwcG9ydGVkVHJhbnNhY3Rpb25WZXJzaW9uYCBwcm9wZXJ0eS5cbiAgICovXG5cbiAgLyoqXG4gICAqIEBkZXByZWNhdGVkIEluc3RlYWQsIGNhbGwgYGdldEJsb2NrYCB1c2luZyBhIGBHZXRWZXJzaW9uZWRCbG9ja0NvbmZpZ2AgYnlcbiAgICogc2V0dGluZyB0aGUgYG1heFN1cHBvcnRlZFRyYW5zYWN0aW9uVmVyc2lvbmAgcHJvcGVydHkuXG4gICAqL1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tZHVwZS1jbGFzcy1tZW1iZXJzXG5cbiAgLyoqXG4gICAqIEBkZXByZWNhdGVkIEluc3RlYWQsIGNhbGwgYGdldEJsb2NrYCB1c2luZyBhIGBHZXRWZXJzaW9uZWRCbG9ja0NvbmZpZ2AgYnlcbiAgICogc2V0dGluZyB0aGUgYG1heFN1cHBvcnRlZFRyYW5zYWN0aW9uVmVyc2lvbmAgcHJvcGVydHkuXG4gICAqL1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tZHVwZS1jbGFzcy1tZW1iZXJzXG5cbiAgLyoqXG4gICAqIEZldGNoIGEgcHJvY2Vzc2VkIGJsb2NrIGZyb20gdGhlIGNsdXN0ZXIuXG4gICAqL1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tZHVwZS1jbGFzcy1tZW1iZXJzXG5cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWR1cGUtY2xhc3MtbWVtYmVyc1xuXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1kdXBlLWNsYXNzLW1lbWJlcnNcblxuICAvKipcbiAgICogRmV0Y2ggYSBwcm9jZXNzZWQgYmxvY2sgZnJvbSB0aGUgY2x1c3Rlci5cbiAgICovXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1kdXBlLWNsYXNzLW1lbWJlcnNcbiAgYXN5bmMgZ2V0QmxvY2soc2xvdCwgcmF3Q29uZmlnKSB7XG4gICAgY29uc3Qge1xuICAgICAgY29tbWl0bWVudCxcbiAgICAgIGNvbmZpZ1xuICAgIH0gPSBleHRyYWN0Q29tbWl0bWVudEZyb21Db25maWcocmF3Q29uZmlnKTtcbiAgICBjb25zdCBhcmdzID0gdGhpcy5fYnVpbGRBcmdzQXRMZWFzdENvbmZpcm1lZChbc2xvdF0sIGNvbW1pdG1lbnQsIHVuZGVmaW5lZCAvKiBlbmNvZGluZyAqLywgY29uZmlnKTtcbiAgICBjb25zdCB1bnNhZmVSZXMgPSBhd2FpdCB0aGlzLl9ycGNSZXF1ZXN0KCdnZXRCbG9jaycsIGFyZ3MpO1xuICAgIHRyeSB7XG4gICAgICBzd2l0Y2ggKGNvbmZpZz8udHJhbnNhY3Rpb25EZXRhaWxzKSB7XG4gICAgICAgIGNhc2UgJ2FjY291bnRzJzpcbiAgICAgICAgICB7XG4gICAgICAgICAgICBjb25zdCByZXMgPSBjcmVhdGUodW5zYWZlUmVzLCBHZXRBY2NvdW50c01vZGVCbG9ja1JwY1Jlc3VsdCk7XG4gICAgICAgICAgICBpZiAoJ2Vycm9yJyBpbiByZXMpIHtcbiAgICAgICAgICAgICAgdGhyb3cgcmVzLmVycm9yO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlcy5yZXN1bHQ7XG4gICAgICAgICAgfVxuICAgICAgICBjYXNlICdub25lJzpcbiAgICAgICAgICB7XG4gICAgICAgICAgICBjb25zdCByZXMgPSBjcmVhdGUodW5zYWZlUmVzLCBHZXROb25lTW9kZUJsb2NrUnBjUmVzdWx0KTtcbiAgICAgICAgICAgIGlmICgnZXJyb3InIGluIHJlcykge1xuICAgICAgICAgICAgICB0aHJvdyByZXMuZXJyb3I7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVzLnJlc3VsdDtcbiAgICAgICAgICB9XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAge1xuICAgICAgICAgICAgY29uc3QgcmVzID0gY3JlYXRlKHVuc2FmZVJlcywgR2V0QmxvY2tScGNSZXN1bHQpO1xuICAgICAgICAgICAgaWYgKCdlcnJvcicgaW4gcmVzKSB7XG4gICAgICAgICAgICAgIHRocm93IHJlcy5lcnJvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHtcbiAgICAgICAgICAgICAgcmVzdWx0XG4gICAgICAgICAgICB9ID0gcmVzO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdCA/IHtcbiAgICAgICAgICAgICAgLi4ucmVzdWx0LFxuICAgICAgICAgICAgICB0cmFuc2FjdGlvbnM6IHJlc3VsdC50cmFuc2FjdGlvbnMubWFwKCh7XG4gICAgICAgICAgICAgICAgdHJhbnNhY3Rpb24sXG4gICAgICAgICAgICAgICAgbWV0YSxcbiAgICAgICAgICAgICAgICB2ZXJzaW9uXG4gICAgICAgICAgICAgIH0pID0+ICh7XG4gICAgICAgICAgICAgICAgbWV0YSxcbiAgICAgICAgICAgICAgICB0cmFuc2FjdGlvbjoge1xuICAgICAgICAgICAgICAgICAgLi4udHJhbnNhY3Rpb24sXG4gICAgICAgICAgICAgICAgICBtZXNzYWdlOiB2ZXJzaW9uZWRNZXNzYWdlRnJvbVJlc3BvbnNlKHZlcnNpb24sIHRyYW5zYWN0aW9uLm1lc3NhZ2UpXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB2ZXJzaW9uXG4gICAgICAgICAgICAgIH0pKVxuICAgICAgICAgICAgfSA6IG51bGw7XG4gICAgICAgICAgfVxuICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHRocm93IG5ldyBTb2xhbmFKU09OUlBDRXJyb3IoZSwgJ2ZhaWxlZCB0byBnZXQgY29uZmlybWVkIGJsb2NrJyk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEZldGNoIHBhcnNlZCB0cmFuc2FjdGlvbiBkZXRhaWxzIGZvciBhIGNvbmZpcm1lZCBvciBmaW5hbGl6ZWQgYmxvY2tcbiAgICovXG5cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWR1cGUtY2xhc3MtbWVtYmVyc1xuXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1kdXBlLWNsYXNzLW1lbWJlcnNcblxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tZHVwZS1jbGFzcy1tZW1iZXJzXG4gIGFzeW5jIGdldFBhcnNlZEJsb2NrKHNsb3QsIHJhd0NvbmZpZykge1xuICAgIGNvbnN0IHtcbiAgICAgIGNvbW1pdG1lbnQsXG4gICAgICBjb25maWdcbiAgICB9ID0gZXh0cmFjdENvbW1pdG1lbnRGcm9tQ29uZmlnKHJhd0NvbmZpZyk7XG4gICAgY29uc3QgYXJncyA9IHRoaXMuX2J1aWxkQXJnc0F0TGVhc3RDb25maXJtZWQoW3Nsb3RdLCBjb21taXRtZW50LCAnanNvblBhcnNlZCcsIGNvbmZpZyk7XG4gICAgY29uc3QgdW5zYWZlUmVzID0gYXdhaXQgdGhpcy5fcnBjUmVxdWVzdCgnZ2V0QmxvY2snLCBhcmdzKTtcbiAgICB0cnkge1xuICAgICAgc3dpdGNoIChjb25maWc/LnRyYW5zYWN0aW9uRGV0YWlscykge1xuICAgICAgICBjYXNlICdhY2NvdW50cyc6XG4gICAgICAgICAge1xuICAgICAgICAgICAgY29uc3QgcmVzID0gY3JlYXRlKHVuc2FmZVJlcywgR2V0UGFyc2VkQWNjb3VudHNNb2RlQmxvY2tScGNSZXN1bHQpO1xuICAgICAgICAgICAgaWYgKCdlcnJvcicgaW4gcmVzKSB7XG4gICAgICAgICAgICAgIHRocm93IHJlcy5lcnJvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXMucmVzdWx0O1xuICAgICAgICAgIH1cbiAgICAgICAgY2FzZSAnbm9uZSc6XG4gICAgICAgICAge1xuICAgICAgICAgICAgY29uc3QgcmVzID0gY3JlYXRlKHVuc2FmZVJlcywgR2V0UGFyc2VkTm9uZU1vZGVCbG9ja1JwY1Jlc3VsdCk7XG4gICAgICAgICAgICBpZiAoJ2Vycm9yJyBpbiByZXMpIHtcbiAgICAgICAgICAgICAgdGhyb3cgcmVzLmVycm9yO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlcy5yZXN1bHQ7XG4gICAgICAgICAgfVxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGNvbnN0IHJlcyA9IGNyZWF0ZSh1bnNhZmVSZXMsIEdldFBhcnNlZEJsb2NrUnBjUmVzdWx0KTtcbiAgICAgICAgICAgIGlmICgnZXJyb3InIGluIHJlcykge1xuICAgICAgICAgICAgICB0aHJvdyByZXMuZXJyb3I7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVzLnJlc3VsdDtcbiAgICAgICAgICB9XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgdGhyb3cgbmV3IFNvbGFuYUpTT05SUENFcnJvcihlLCAnZmFpbGVkIHRvIGdldCBibG9jaycpO1xuICAgIH1cbiAgfVxuICAvKlxuICAgKiBSZXR1cm5zIHJlY2VudCBibG9jayBwcm9kdWN0aW9uIGluZm9ybWF0aW9uIGZyb20gdGhlIGN1cnJlbnQgb3IgcHJldmlvdXMgZXBvY2hcbiAgICovXG4gIGFzeW5jIGdldEJsb2NrUHJvZHVjdGlvbihjb25maWdPckNvbW1pdG1lbnQpIHtcbiAgICBsZXQgZXh0cmE7XG4gICAgbGV0IGNvbW1pdG1lbnQ7XG4gICAgaWYgKHR5cGVvZiBjb25maWdPckNvbW1pdG1lbnQgPT09ICdzdHJpbmcnKSB7XG4gICAgICBjb21taXRtZW50ID0gY29uZmlnT3JDb21taXRtZW50O1xuICAgIH0gZWxzZSBpZiAoY29uZmlnT3JDb21taXRtZW50KSB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIGNvbW1pdG1lbnQ6IGMsXG4gICAgICAgIC4uLnJlc3RcbiAgICAgIH0gPSBjb25maWdPckNvbW1pdG1lbnQ7XG4gICAgICBjb21taXRtZW50ID0gYztcbiAgICAgIGV4dHJhID0gcmVzdDtcbiAgICB9XG4gICAgY29uc3QgYXJncyA9IHRoaXMuX2J1aWxkQXJncyhbXSwgY29tbWl0bWVudCwgJ2Jhc2U2NCcsIGV4dHJhKTtcbiAgICBjb25zdCB1bnNhZmVSZXMgPSBhd2FpdCB0aGlzLl9ycGNSZXF1ZXN0KCdnZXRCbG9ja1Byb2R1Y3Rpb24nLCBhcmdzKTtcbiAgICBjb25zdCByZXMgPSBjcmVhdGUodW5zYWZlUmVzLCBCbG9ja1Byb2R1Y3Rpb25SZXNwb25zZVN0cnVjdCk7XG4gICAgaWYgKCdlcnJvcicgaW4gcmVzKSB7XG4gICAgICB0aHJvdyBuZXcgU29sYW5hSlNPTlJQQ0Vycm9yKHJlcy5lcnJvciwgJ2ZhaWxlZCB0byBnZXQgYmxvY2sgcHJvZHVjdGlvbiBpbmZvcm1hdGlvbicpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzLnJlc3VsdDtcbiAgfVxuXG4gIC8qKlxuICAgKiBGZXRjaCBhIGNvbmZpcm1lZCBvciBmaW5hbGl6ZWQgdHJhbnNhY3Rpb24gZnJvbSB0aGUgY2x1c3Rlci5cbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgSW5zdGVhZCwgY2FsbCBgZ2V0VHJhbnNhY3Rpb25gIHVzaW5nIGFcbiAgICogYEdldFZlcnNpb25lZFRyYW5zYWN0aW9uQ29uZmlnYCBieSBzZXR0aW5nIHRoZVxuICAgKiBgbWF4U3VwcG9ydGVkVHJhbnNhY3Rpb25WZXJzaW9uYCBwcm9wZXJ0eS5cbiAgICovXG5cbiAgLyoqXG4gICAqIEZldGNoIGEgY29uZmlybWVkIG9yIGZpbmFsaXplZCB0cmFuc2FjdGlvbiBmcm9tIHRoZSBjbHVzdGVyLlxuICAgKi9cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWR1cGUtY2xhc3MtbWVtYmVyc1xuXG4gIC8qKlxuICAgKiBGZXRjaCBhIGNvbmZpcm1lZCBvciBmaW5hbGl6ZWQgdHJhbnNhY3Rpb24gZnJvbSB0aGUgY2x1c3Rlci5cbiAgICovXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1kdXBlLWNsYXNzLW1lbWJlcnNcbiAgYXN5bmMgZ2V0VHJhbnNhY3Rpb24oc2lnbmF0dXJlLCByYXdDb25maWcpIHtcbiAgICBjb25zdCB7XG4gICAgICBjb21taXRtZW50LFxuICAgICAgY29uZmlnXG4gICAgfSA9IGV4dHJhY3RDb21taXRtZW50RnJvbUNvbmZpZyhyYXdDb25maWcpO1xuICAgIGNvbnN0IGFyZ3MgPSB0aGlzLl9idWlsZEFyZ3NBdExlYXN0Q29uZmlybWVkKFtzaWduYXR1cmVdLCBjb21taXRtZW50LCB1bmRlZmluZWQgLyogZW5jb2RpbmcgKi8sIGNvbmZpZyk7XG4gICAgY29uc3QgdW5zYWZlUmVzID0gYXdhaXQgdGhpcy5fcnBjUmVxdWVzdCgnZ2V0VHJhbnNhY3Rpb24nLCBhcmdzKTtcbiAgICBjb25zdCByZXMgPSBjcmVhdGUodW5zYWZlUmVzLCBHZXRUcmFuc2FjdGlvblJwY1Jlc3VsdCk7XG4gICAgaWYgKCdlcnJvcicgaW4gcmVzKSB7XG4gICAgICB0aHJvdyBuZXcgU29sYW5hSlNPTlJQQ0Vycm9yKHJlcy5lcnJvciwgJ2ZhaWxlZCB0byBnZXQgdHJhbnNhY3Rpb24nKTtcbiAgICB9XG4gICAgY29uc3QgcmVzdWx0ID0gcmVzLnJlc3VsdDtcbiAgICBpZiAoIXJlc3VsdCkgcmV0dXJuIHJlc3VsdDtcbiAgICByZXR1cm4ge1xuICAgICAgLi4ucmVzdWx0LFxuICAgICAgdHJhbnNhY3Rpb246IHtcbiAgICAgICAgLi4ucmVzdWx0LnRyYW5zYWN0aW9uLFxuICAgICAgICBtZXNzYWdlOiB2ZXJzaW9uZWRNZXNzYWdlRnJvbVJlc3BvbnNlKHJlc3VsdC52ZXJzaW9uLCByZXN1bHQudHJhbnNhY3Rpb24ubWVzc2FnZSlcbiAgICAgIH1cbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIEZldGNoIHBhcnNlZCB0cmFuc2FjdGlvbiBkZXRhaWxzIGZvciBhIGNvbmZpcm1lZCBvciBmaW5hbGl6ZWQgdHJhbnNhY3Rpb25cbiAgICovXG4gIGFzeW5jIGdldFBhcnNlZFRyYW5zYWN0aW9uKHNpZ25hdHVyZSwgY29tbWl0bWVudE9yQ29uZmlnKSB7XG4gICAgY29uc3Qge1xuICAgICAgY29tbWl0bWVudCxcbiAgICAgIGNvbmZpZ1xuICAgIH0gPSBleHRyYWN0Q29tbWl0bWVudEZyb21Db25maWcoY29tbWl0bWVudE9yQ29uZmlnKTtcbiAgICBjb25zdCBhcmdzID0gdGhpcy5fYnVpbGRBcmdzQXRMZWFzdENvbmZpcm1lZChbc2lnbmF0dXJlXSwgY29tbWl0bWVudCwgJ2pzb25QYXJzZWQnLCBjb25maWcpO1xuICAgIGNvbnN0IHVuc2FmZVJlcyA9IGF3YWl0IHRoaXMuX3JwY1JlcXVlc3QoJ2dldFRyYW5zYWN0aW9uJywgYXJncyk7XG4gICAgY29uc3QgcmVzID0gY3JlYXRlKHVuc2FmZVJlcywgR2V0UGFyc2VkVHJhbnNhY3Rpb25ScGNSZXN1bHQpO1xuICAgIGlmICgnZXJyb3InIGluIHJlcykge1xuICAgICAgdGhyb3cgbmV3IFNvbGFuYUpTT05SUENFcnJvcihyZXMuZXJyb3IsICdmYWlsZWQgdG8gZ2V0IHRyYW5zYWN0aW9uJyk7XG4gICAgfVxuICAgIHJldHVybiByZXMucmVzdWx0O1xuICB9XG5cbiAgLyoqXG4gICAqIEZldGNoIHBhcnNlZCB0cmFuc2FjdGlvbiBkZXRhaWxzIGZvciBhIGJhdGNoIG9mIGNvbmZpcm1lZCB0cmFuc2FjdGlvbnNcbiAgICovXG4gIGFzeW5jIGdldFBhcnNlZFRyYW5zYWN0aW9ucyhzaWduYXR1cmVzLCBjb21taXRtZW50T3JDb25maWcpIHtcbiAgICBjb25zdCB7XG4gICAgICBjb21taXRtZW50LFxuICAgICAgY29uZmlnXG4gICAgfSA9IGV4dHJhY3RDb21taXRtZW50RnJvbUNvbmZpZyhjb21taXRtZW50T3JDb25maWcpO1xuICAgIGNvbnN0IGJhdGNoID0gc2lnbmF0dXJlcy5tYXAoc2lnbmF0dXJlID0+IHtcbiAgICAgIGNvbnN0IGFyZ3MgPSB0aGlzLl9idWlsZEFyZ3NBdExlYXN0Q29uZmlybWVkKFtzaWduYXR1cmVdLCBjb21taXRtZW50LCAnanNvblBhcnNlZCcsIGNvbmZpZyk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBtZXRob2ROYW1lOiAnZ2V0VHJhbnNhY3Rpb24nLFxuICAgICAgICBhcmdzXG4gICAgICB9O1xuICAgIH0pO1xuICAgIGNvbnN0IHVuc2FmZVJlcyA9IGF3YWl0IHRoaXMuX3JwY0JhdGNoUmVxdWVzdChiYXRjaCk7XG4gICAgY29uc3QgcmVzID0gdW5zYWZlUmVzLm1hcCh1bnNhZmVSZXMgPT4ge1xuICAgICAgY29uc3QgcmVzID0gY3JlYXRlKHVuc2FmZVJlcywgR2V0UGFyc2VkVHJhbnNhY3Rpb25ScGNSZXN1bHQpO1xuICAgICAgaWYgKCdlcnJvcicgaW4gcmVzKSB7XG4gICAgICAgIHRocm93IG5ldyBTb2xhbmFKU09OUlBDRXJyb3IocmVzLmVycm9yLCAnZmFpbGVkIHRvIGdldCB0cmFuc2FjdGlvbnMnKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXMucmVzdWx0O1xuICAgIH0pO1xuICAgIHJldHVybiByZXM7XG4gIH1cblxuICAvKipcbiAgICogRmV0Y2ggdHJhbnNhY3Rpb24gZGV0YWlscyBmb3IgYSBiYXRjaCBvZiBjb25maXJtZWQgdHJhbnNhY3Rpb25zLlxuICAgKiBTaW1pbGFyIHRvIHtAbGluayBnZXRQYXJzZWRUcmFuc2FjdGlvbnN9IGJ1dCByZXR1cm5zIGEge0BsaW5rIFRyYW5zYWN0aW9uUmVzcG9uc2V9LlxuICAgKlxuICAgKiBAZGVwcmVjYXRlZCBJbnN0ZWFkLCBjYWxsIGBnZXRUcmFuc2FjdGlvbnNgIHVzaW5nIGFcbiAgICogYEdldFZlcnNpb25lZFRyYW5zYWN0aW9uQ29uZmlnYCBieSBzZXR0aW5nIHRoZVxuICAgKiBgbWF4U3VwcG9ydGVkVHJhbnNhY3Rpb25WZXJzaW9uYCBwcm9wZXJ0eS5cbiAgICovXG5cbiAgLyoqXG4gICAqIEZldGNoIHRyYW5zYWN0aW9uIGRldGFpbHMgZm9yIGEgYmF0Y2ggb2YgY29uZmlybWVkIHRyYW5zYWN0aW9ucy5cbiAgICogU2ltaWxhciB0byB7QGxpbmsgZ2V0UGFyc2VkVHJhbnNhY3Rpb25zfSBidXQgcmV0dXJucyBhIHtAbGlua1xuICAgKiBWZXJzaW9uZWRUcmFuc2FjdGlvblJlc3BvbnNlfS5cbiAgICovXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1kdXBlLWNsYXNzLW1lbWJlcnNcblxuICAvKipcbiAgICogRmV0Y2ggdHJhbnNhY3Rpb24gZGV0YWlscyBmb3IgYSBiYXRjaCBvZiBjb25maXJtZWQgdHJhbnNhY3Rpb25zLlxuICAgKiBTaW1pbGFyIHRvIHtAbGluayBnZXRQYXJzZWRUcmFuc2FjdGlvbnN9IGJ1dCByZXR1cm5zIGEge0BsaW5rXG4gICAqIFZlcnNpb25lZFRyYW5zYWN0aW9uUmVzcG9uc2V9LlxuICAgKi9cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWR1cGUtY2xhc3MtbWVtYmVyc1xuICBhc3luYyBnZXRUcmFuc2FjdGlvbnMoc2lnbmF0dXJlcywgY29tbWl0bWVudE9yQ29uZmlnKSB7XG4gICAgY29uc3Qge1xuICAgICAgY29tbWl0bWVudCxcbiAgICAgIGNvbmZpZ1xuICAgIH0gPSBleHRyYWN0Q29tbWl0bWVudEZyb21Db25maWcoY29tbWl0bWVudE9yQ29uZmlnKTtcbiAgICBjb25zdCBiYXRjaCA9IHNpZ25hdHVyZXMubWFwKHNpZ25hdHVyZSA9PiB7XG4gICAgICBjb25zdCBhcmdzID0gdGhpcy5fYnVpbGRBcmdzQXRMZWFzdENvbmZpcm1lZChbc2lnbmF0dXJlXSwgY29tbWl0bWVudCwgdW5kZWZpbmVkIC8qIGVuY29kaW5nICovLCBjb25maWcpO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgbWV0aG9kTmFtZTogJ2dldFRyYW5zYWN0aW9uJyxcbiAgICAgICAgYXJnc1xuICAgICAgfTtcbiAgICB9KTtcbiAgICBjb25zdCB1bnNhZmVSZXMgPSBhd2FpdCB0aGlzLl9ycGNCYXRjaFJlcXVlc3QoYmF0Y2gpO1xuICAgIGNvbnN0IHJlcyA9IHVuc2FmZVJlcy5tYXAodW5zYWZlUmVzID0+IHtcbiAgICAgIGNvbnN0IHJlcyA9IGNyZWF0ZSh1bnNhZmVSZXMsIEdldFRyYW5zYWN0aW9uUnBjUmVzdWx0KTtcbiAgICAgIGlmICgnZXJyb3InIGluIHJlcykge1xuICAgICAgICB0aHJvdyBuZXcgU29sYW5hSlNPTlJQQ0Vycm9yKHJlcy5lcnJvciwgJ2ZhaWxlZCB0byBnZXQgdHJhbnNhY3Rpb25zJyk7XG4gICAgICB9XG4gICAgICBjb25zdCByZXN1bHQgPSByZXMucmVzdWx0O1xuICAgICAgaWYgKCFyZXN1bHQpIHJldHVybiByZXN1bHQ7XG4gICAgICByZXR1cm4ge1xuICAgICAgICAuLi5yZXN1bHQsXG4gICAgICAgIHRyYW5zYWN0aW9uOiB7XG4gICAgICAgICAgLi4ucmVzdWx0LnRyYW5zYWN0aW9uLFxuICAgICAgICAgIG1lc3NhZ2U6IHZlcnNpb25lZE1lc3NhZ2VGcm9tUmVzcG9uc2UocmVzdWx0LnZlcnNpb24sIHJlc3VsdC50cmFuc2FjdGlvbi5tZXNzYWdlKVxuICAgICAgICB9XG4gICAgICB9O1xuICAgIH0pO1xuICAgIHJldHVybiByZXM7XG4gIH1cblxuICAvKipcbiAgICogRmV0Y2ggYSBsaXN0IG9mIFRyYW5zYWN0aW9ucyBhbmQgdHJhbnNhY3Rpb24gc3RhdHVzZXMgZnJvbSB0aGUgY2x1c3RlclxuICAgKiBmb3IgYSBjb25maXJtZWQgYmxvY2suXG4gICAqXG4gICAqIEBkZXByZWNhdGVkIERlcHJlY2F0ZWQgc2luY2UgdjEuMTMuMC4gUGxlYXNlIHVzZSB7QGxpbmsgZ2V0QmxvY2t9IGluc3RlYWQuXG4gICAqL1xuICBhc3luYyBnZXRDb25maXJtZWRCbG9jayhzbG90LCBjb21taXRtZW50KSB7XG4gICAgY29uc3QgYXJncyA9IHRoaXMuX2J1aWxkQXJnc0F0TGVhc3RDb25maXJtZWQoW3Nsb3RdLCBjb21taXRtZW50KTtcbiAgICBjb25zdCB1bnNhZmVSZXMgPSBhd2FpdCB0aGlzLl9ycGNSZXF1ZXN0KCdnZXRDb25maXJtZWRCbG9jaycsIGFyZ3MpO1xuICAgIGNvbnN0IHJlcyA9IGNyZWF0ZSh1bnNhZmVSZXMsIEdldENvbmZpcm1lZEJsb2NrUnBjUmVzdWx0KTtcbiAgICBpZiAoJ2Vycm9yJyBpbiByZXMpIHtcbiAgICAgIHRocm93IG5ldyBTb2xhbmFKU09OUlBDRXJyb3IocmVzLmVycm9yLCAnZmFpbGVkIHRvIGdldCBjb25maXJtZWQgYmxvY2snKTtcbiAgICB9XG4gICAgY29uc3QgcmVzdWx0ID0gcmVzLnJlc3VsdDtcbiAgICBpZiAoIXJlc3VsdCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdDb25maXJtZWQgYmxvY2sgJyArIHNsb3QgKyAnIG5vdCBmb3VuZCcpO1xuICAgIH1cbiAgICBjb25zdCBibG9jayA9IHtcbiAgICAgIC4uLnJlc3VsdCxcbiAgICAgIHRyYW5zYWN0aW9uczogcmVzdWx0LnRyYW5zYWN0aW9ucy5tYXAoKHtcbiAgICAgICAgdHJhbnNhY3Rpb24sXG4gICAgICAgIG1ldGFcbiAgICAgIH0pID0+IHtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IG5ldyBNZXNzYWdlKHRyYW5zYWN0aW9uLm1lc3NhZ2UpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIG1ldGEsXG4gICAgICAgICAgdHJhbnNhY3Rpb246IHtcbiAgICAgICAgICAgIC4uLnRyYW5zYWN0aW9uLFxuICAgICAgICAgICAgbWVzc2FnZVxuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgIH0pXG4gICAgfTtcbiAgICByZXR1cm4ge1xuICAgICAgLi4uYmxvY2ssXG4gICAgICB0cmFuc2FjdGlvbnM6IGJsb2NrLnRyYW5zYWN0aW9ucy5tYXAoKHtcbiAgICAgICAgdHJhbnNhY3Rpb24sXG4gICAgICAgIG1ldGFcbiAgICAgIH0pID0+IHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBtZXRhLFxuICAgICAgICAgIHRyYW5zYWN0aW9uOiBUcmFuc2FjdGlvbi5wb3B1bGF0ZSh0cmFuc2FjdGlvbi5tZXNzYWdlLCB0cmFuc2FjdGlvbi5zaWduYXR1cmVzKVxuICAgICAgICB9O1xuICAgICAgfSlcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIEZldGNoIGNvbmZpcm1lZCBibG9ja3MgYmV0d2VlbiB0d28gc2xvdHNcbiAgICovXG4gIGFzeW5jIGdldEJsb2NrcyhzdGFydFNsb3QsIGVuZFNsb3QsIGNvbW1pdG1lbnQpIHtcbiAgICBjb25zdCBhcmdzID0gdGhpcy5fYnVpbGRBcmdzQXRMZWFzdENvbmZpcm1lZChlbmRTbG90ICE9PSB1bmRlZmluZWQgPyBbc3RhcnRTbG90LCBlbmRTbG90XSA6IFtzdGFydFNsb3RdLCBjb21taXRtZW50KTtcbiAgICBjb25zdCB1bnNhZmVSZXMgPSBhd2FpdCB0aGlzLl9ycGNSZXF1ZXN0KCdnZXRCbG9ja3MnLCBhcmdzKTtcbiAgICBjb25zdCByZXMgPSBjcmVhdGUodW5zYWZlUmVzLCBqc29uUnBjUmVzdWx0KGFycmF5KG51bWJlcigpKSkpO1xuICAgIGlmICgnZXJyb3InIGluIHJlcykge1xuICAgICAgdGhyb3cgbmV3IFNvbGFuYUpTT05SUENFcnJvcihyZXMuZXJyb3IsICdmYWlsZWQgdG8gZ2V0IGJsb2NrcycpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzLnJlc3VsdDtcbiAgfVxuXG4gIC8qKlxuICAgKiBGZXRjaCBhIGxpc3Qgb2YgU2lnbmF0dXJlcyBmcm9tIHRoZSBjbHVzdGVyIGZvciBhIGJsb2NrLCBleGNsdWRpbmcgcmV3YXJkc1xuICAgKi9cbiAgYXN5bmMgZ2V0QmxvY2tTaWduYXR1cmVzKHNsb3QsIGNvbW1pdG1lbnQpIHtcbiAgICBjb25zdCBhcmdzID0gdGhpcy5fYnVpbGRBcmdzQXRMZWFzdENvbmZpcm1lZChbc2xvdF0sIGNvbW1pdG1lbnQsIHVuZGVmaW5lZCwge1xuICAgICAgdHJhbnNhY3Rpb25EZXRhaWxzOiAnc2lnbmF0dXJlcycsXG4gICAgICByZXdhcmRzOiBmYWxzZVxuICAgIH0pO1xuICAgIGNvbnN0IHVuc2FmZVJlcyA9IGF3YWl0IHRoaXMuX3JwY1JlcXVlc3QoJ2dldEJsb2NrJywgYXJncyk7XG4gICAgY29uc3QgcmVzID0gY3JlYXRlKHVuc2FmZVJlcywgR2V0QmxvY2tTaWduYXR1cmVzUnBjUmVzdWx0KTtcbiAgICBpZiAoJ2Vycm9yJyBpbiByZXMpIHtcbiAgICAgIHRocm93IG5ldyBTb2xhbmFKU09OUlBDRXJyb3IocmVzLmVycm9yLCAnZmFpbGVkIHRvIGdldCBibG9jaycpO1xuICAgIH1cbiAgICBjb25zdCByZXN1bHQgPSByZXMucmVzdWx0O1xuICAgIGlmICghcmVzdWx0KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Jsb2NrICcgKyBzbG90ICsgJyBub3QgZm91bmQnKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIC8qKlxuICAgKiBGZXRjaCBhIGxpc3Qgb2YgU2lnbmF0dXJlcyBmcm9tIHRoZSBjbHVzdGVyIGZvciBhIGNvbmZpcm1lZCBibG9jaywgZXhjbHVkaW5nIHJld2FyZHNcbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgRGVwcmVjYXRlZCBzaW5jZSBTb2xhbmEgdjEuOC4wLiBQbGVhc2UgdXNlIHtAbGluayBnZXRCbG9ja1NpZ25hdHVyZXN9IGluc3RlYWQuXG4gICAqL1xuICBhc3luYyBnZXRDb25maXJtZWRCbG9ja1NpZ25hdHVyZXMoc2xvdCwgY29tbWl0bWVudCkge1xuICAgIGNvbnN0IGFyZ3MgPSB0aGlzLl9idWlsZEFyZ3NBdExlYXN0Q29uZmlybWVkKFtzbG90XSwgY29tbWl0bWVudCwgdW5kZWZpbmVkLCB7XG4gICAgICB0cmFuc2FjdGlvbkRldGFpbHM6ICdzaWduYXR1cmVzJyxcbiAgICAgIHJld2FyZHM6IGZhbHNlXG4gICAgfSk7XG4gICAgY29uc3QgdW5zYWZlUmVzID0gYXdhaXQgdGhpcy5fcnBjUmVxdWVzdCgnZ2V0Q29uZmlybWVkQmxvY2snLCBhcmdzKTtcbiAgICBjb25zdCByZXMgPSBjcmVhdGUodW5zYWZlUmVzLCBHZXRCbG9ja1NpZ25hdHVyZXNScGNSZXN1bHQpO1xuICAgIGlmICgnZXJyb3InIGluIHJlcykge1xuICAgICAgdGhyb3cgbmV3IFNvbGFuYUpTT05SUENFcnJvcihyZXMuZXJyb3IsICdmYWlsZWQgdG8gZ2V0IGNvbmZpcm1lZCBibG9jaycpO1xuICAgIH1cbiAgICBjb25zdCByZXN1bHQgPSByZXMucmVzdWx0O1xuICAgIGlmICghcmVzdWx0KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NvbmZpcm1lZCBibG9jayAnICsgc2xvdCArICcgbm90IGZvdW5kJyk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICAvKipcbiAgICogRmV0Y2ggYSB0cmFuc2FjdGlvbiBkZXRhaWxzIGZvciBhIGNvbmZpcm1lZCB0cmFuc2FjdGlvblxuICAgKlxuICAgKiBAZGVwcmVjYXRlZCBEZXByZWNhdGVkIHNpbmNlIFNvbGFuYSB2MS44LjAuIFBsZWFzZSB1c2Uge0BsaW5rIGdldFRyYW5zYWN0aW9ufSBpbnN0ZWFkLlxuICAgKi9cbiAgYXN5bmMgZ2V0Q29uZmlybWVkVHJhbnNhY3Rpb24oc2lnbmF0dXJlLCBjb21taXRtZW50KSB7XG4gICAgY29uc3QgYXJncyA9IHRoaXMuX2J1aWxkQXJnc0F0TGVhc3RDb25maXJtZWQoW3NpZ25hdHVyZV0sIGNvbW1pdG1lbnQpO1xuICAgIGNvbnN0IHVuc2FmZVJlcyA9IGF3YWl0IHRoaXMuX3JwY1JlcXVlc3QoJ2dldENvbmZpcm1lZFRyYW5zYWN0aW9uJywgYXJncyk7XG4gICAgY29uc3QgcmVzID0gY3JlYXRlKHVuc2FmZVJlcywgR2V0VHJhbnNhY3Rpb25ScGNSZXN1bHQpO1xuICAgIGlmICgnZXJyb3InIGluIHJlcykge1xuICAgICAgdGhyb3cgbmV3IFNvbGFuYUpTT05SUENFcnJvcihyZXMuZXJyb3IsICdmYWlsZWQgdG8gZ2V0IHRyYW5zYWN0aW9uJyk7XG4gICAgfVxuICAgIGNvbnN0IHJlc3VsdCA9IHJlcy5yZXN1bHQ7XG4gICAgaWYgKCFyZXN1bHQpIHJldHVybiByZXN1bHQ7XG4gICAgY29uc3QgbWVzc2FnZSA9IG5ldyBNZXNzYWdlKHJlc3VsdC50cmFuc2FjdGlvbi5tZXNzYWdlKTtcbiAgICBjb25zdCBzaWduYXR1cmVzID0gcmVzdWx0LnRyYW5zYWN0aW9uLnNpZ25hdHVyZXM7XG4gICAgcmV0dXJuIHtcbiAgICAgIC4uLnJlc3VsdCxcbiAgICAgIHRyYW5zYWN0aW9uOiBUcmFuc2FjdGlvbi5wb3B1bGF0ZShtZXNzYWdlLCBzaWduYXR1cmVzKVxuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogRmV0Y2ggcGFyc2VkIHRyYW5zYWN0aW9uIGRldGFpbHMgZm9yIGEgY29uZmlybWVkIHRyYW5zYWN0aW9uXG4gICAqXG4gICAqIEBkZXByZWNhdGVkIERlcHJlY2F0ZWQgc2luY2UgU29sYW5hIHYxLjguMC4gUGxlYXNlIHVzZSB7QGxpbmsgZ2V0UGFyc2VkVHJhbnNhY3Rpb259IGluc3RlYWQuXG4gICAqL1xuICBhc3luYyBnZXRQYXJzZWRDb25maXJtZWRUcmFuc2FjdGlvbihzaWduYXR1cmUsIGNvbW1pdG1lbnQpIHtcbiAgICBjb25zdCBhcmdzID0gdGhpcy5fYnVpbGRBcmdzQXRMZWFzdENvbmZpcm1lZChbc2lnbmF0dXJlXSwgY29tbWl0bWVudCwgJ2pzb25QYXJzZWQnKTtcbiAgICBjb25zdCB1bnNhZmVSZXMgPSBhd2FpdCB0aGlzLl9ycGNSZXF1ZXN0KCdnZXRDb25maXJtZWRUcmFuc2FjdGlvbicsIGFyZ3MpO1xuICAgIGNvbnN0IHJlcyA9IGNyZWF0ZSh1bnNhZmVSZXMsIEdldFBhcnNlZFRyYW5zYWN0aW9uUnBjUmVzdWx0KTtcbiAgICBpZiAoJ2Vycm9yJyBpbiByZXMpIHtcbiAgICAgIHRocm93IG5ldyBTb2xhbmFKU09OUlBDRXJyb3IocmVzLmVycm9yLCAnZmFpbGVkIHRvIGdldCBjb25maXJtZWQgdHJhbnNhY3Rpb24nKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlcy5yZXN1bHQ7XG4gIH1cblxuICAvKipcbiAgICogRmV0Y2ggcGFyc2VkIHRyYW5zYWN0aW9uIGRldGFpbHMgZm9yIGEgYmF0Y2ggb2YgY29uZmlybWVkIHRyYW5zYWN0aW9uc1xuICAgKlxuICAgKiBAZGVwcmVjYXRlZCBEZXByZWNhdGVkIHNpbmNlIFNvbGFuYSB2MS44LjAuIFBsZWFzZSB1c2Uge0BsaW5rIGdldFBhcnNlZFRyYW5zYWN0aW9uc30gaW5zdGVhZC5cbiAgICovXG4gIGFzeW5jIGdldFBhcnNlZENvbmZpcm1lZFRyYW5zYWN0aW9ucyhzaWduYXR1cmVzLCBjb21taXRtZW50KSB7XG4gICAgY29uc3QgYmF0Y2ggPSBzaWduYXR1cmVzLm1hcChzaWduYXR1cmUgPT4ge1xuICAgICAgY29uc3QgYXJncyA9IHRoaXMuX2J1aWxkQXJnc0F0TGVhc3RDb25maXJtZWQoW3NpZ25hdHVyZV0sIGNvbW1pdG1lbnQsICdqc29uUGFyc2VkJyk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBtZXRob2ROYW1lOiAnZ2V0Q29uZmlybWVkVHJhbnNhY3Rpb24nLFxuICAgICAgICBhcmdzXG4gICAgICB9O1xuICAgIH0pO1xuICAgIGNvbnN0IHVuc2FmZVJlcyA9IGF3YWl0IHRoaXMuX3JwY0JhdGNoUmVxdWVzdChiYXRjaCk7XG4gICAgY29uc3QgcmVzID0gdW5zYWZlUmVzLm1hcCh1bnNhZmVSZXMgPT4ge1xuICAgICAgY29uc3QgcmVzID0gY3JlYXRlKHVuc2FmZVJlcywgR2V0UGFyc2VkVHJhbnNhY3Rpb25ScGNSZXN1bHQpO1xuICAgICAgaWYgKCdlcnJvcicgaW4gcmVzKSB7XG4gICAgICAgIHRocm93IG5ldyBTb2xhbmFKU09OUlBDRXJyb3IocmVzLmVycm9yLCAnZmFpbGVkIHRvIGdldCBjb25maXJtZWQgdHJhbnNhY3Rpb25zJyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzLnJlc3VsdDtcbiAgICB9KTtcbiAgICByZXR1cm4gcmVzO1xuICB9XG5cbiAgLyoqXG4gICAqIEZldGNoIGEgbGlzdCBvZiBhbGwgdGhlIGNvbmZpcm1lZCBzaWduYXR1cmVzIGZvciB0cmFuc2FjdGlvbnMgaW52b2x2aW5nIGFuIGFkZHJlc3NcbiAgICogd2l0aGluIGEgc3BlY2lmaWVkIHNsb3QgcmFuZ2UuIE1heCByYW5nZSBhbGxvd2VkIGlzIDEwLDAwMCBzbG90cy5cbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgRGVwcmVjYXRlZCBzaW5jZSB2MS4zLiBQbGVhc2UgdXNlIHtAbGluayBnZXRDb25maXJtZWRTaWduYXR1cmVzRm9yQWRkcmVzczJ9IGluc3RlYWQuXG4gICAqXG4gICAqIEBwYXJhbSBhZGRyZXNzIHF1ZXJpZWQgYWRkcmVzc1xuICAgKiBAcGFyYW0gc3RhcnRTbG90IHN0YXJ0IHNsb3QsIGluY2x1c2l2ZVxuICAgKiBAcGFyYW0gZW5kU2xvdCBlbmQgc2xvdCwgaW5jbHVzaXZlXG4gICAqL1xuICBhc3luYyBnZXRDb25maXJtZWRTaWduYXR1cmVzRm9yQWRkcmVzcyhhZGRyZXNzLCBzdGFydFNsb3QsIGVuZFNsb3QpIHtcbiAgICBsZXQgb3B0aW9ucyA9IHt9O1xuICAgIGxldCBmaXJzdEF2YWlsYWJsZUJsb2NrID0gYXdhaXQgdGhpcy5nZXRGaXJzdEF2YWlsYWJsZUJsb2NrKCk7XG4gICAgd2hpbGUgKCEoJ3VudGlsJyBpbiBvcHRpb25zKSkge1xuICAgICAgc3RhcnRTbG90LS07XG4gICAgICBpZiAoc3RhcnRTbG90IDw9IDAgfHwgc3RhcnRTbG90IDwgZmlyc3RBdmFpbGFibGVCbG9jaykge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IGJsb2NrID0gYXdhaXQgdGhpcy5nZXRDb25maXJtZWRCbG9ja1NpZ25hdHVyZXMoc3RhcnRTbG90LCAnZmluYWxpemVkJyk7XG4gICAgICAgIGlmIChibG9jay5zaWduYXR1cmVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICBvcHRpb25zLnVudGlsID0gYmxvY2suc2lnbmF0dXJlc1tibG9jay5zaWduYXR1cmVzLmxlbmd0aCAtIDFdLnRvU3RyaW5nKCk7XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBpZiAoZXJyIGluc3RhbmNlb2YgRXJyb3IgJiYgZXJyLm1lc3NhZ2UuaW5jbHVkZXMoJ3NraXBwZWQnKSkge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBsZXQgaGlnaGVzdENvbmZpcm1lZFJvb3QgPSBhd2FpdCB0aGlzLmdldFNsb3QoJ2ZpbmFsaXplZCcpO1xuICAgIHdoaWxlICghKCdiZWZvcmUnIGluIG9wdGlvbnMpKSB7XG4gICAgICBlbmRTbG90Kys7XG4gICAgICBpZiAoZW5kU2xvdCA+IGhpZ2hlc3RDb25maXJtZWRSb290KSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3QgYmxvY2sgPSBhd2FpdCB0aGlzLmdldENvbmZpcm1lZEJsb2NrU2lnbmF0dXJlcyhlbmRTbG90KTtcbiAgICAgICAgaWYgKGJsb2NrLnNpZ25hdHVyZXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgIG9wdGlvbnMuYmVmb3JlID0gYmxvY2suc2lnbmF0dXJlc1tibG9jay5zaWduYXR1cmVzLmxlbmd0aCAtIDFdLnRvU3RyaW5nKCk7XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBpZiAoZXJyIGluc3RhbmNlb2YgRXJyb3IgJiYgZXJyLm1lc3NhZ2UuaW5jbHVkZXMoJ3NraXBwZWQnKSkge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBjb25maXJtZWRTaWduYXR1cmVJbmZvID0gYXdhaXQgdGhpcy5nZXRDb25maXJtZWRTaWduYXR1cmVzRm9yQWRkcmVzczIoYWRkcmVzcywgb3B0aW9ucyk7XG4gICAgcmV0dXJuIGNvbmZpcm1lZFNpZ25hdHVyZUluZm8ubWFwKGluZm8gPT4gaW5mby5zaWduYXR1cmUpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgY29uZmlybWVkIHNpZ25hdHVyZXMgZm9yIHRyYW5zYWN0aW9ucyBpbnZvbHZpbmcgYW5cbiAgICogYWRkcmVzcyBiYWNrd2FyZHMgaW4gdGltZSBmcm9tIHRoZSBwcm92aWRlZCBzaWduYXR1cmUgb3IgbW9zdCByZWNlbnQgY29uZmlybWVkIGJsb2NrXG4gICAqXG4gICAqXG4gICAqIEBwYXJhbSBhZGRyZXNzIHF1ZXJpZWQgYWRkcmVzc1xuICAgKiBAcGFyYW0gb3B0aW9uc1xuICAgKi9cbiAgYXN5bmMgZ2V0Q29uZmlybWVkU2lnbmF0dXJlc0ZvckFkZHJlc3MyKGFkZHJlc3MsIG9wdGlvbnMsIGNvbW1pdG1lbnQpIHtcbiAgICBjb25zdCBhcmdzID0gdGhpcy5fYnVpbGRBcmdzQXRMZWFzdENvbmZpcm1lZChbYWRkcmVzcy50b0Jhc2U1OCgpXSwgY29tbWl0bWVudCwgdW5kZWZpbmVkLCBvcHRpb25zKTtcbiAgICBjb25zdCB1bnNhZmVSZXMgPSBhd2FpdCB0aGlzLl9ycGNSZXF1ZXN0KCdnZXRDb25maXJtZWRTaWduYXR1cmVzRm9yQWRkcmVzczInLCBhcmdzKTtcbiAgICBjb25zdCByZXMgPSBjcmVhdGUodW5zYWZlUmVzLCBHZXRDb25maXJtZWRTaWduYXR1cmVzRm9yQWRkcmVzczJScGNSZXN1bHQpO1xuICAgIGlmICgnZXJyb3InIGluIHJlcykge1xuICAgICAgdGhyb3cgbmV3IFNvbGFuYUpTT05SUENFcnJvcihyZXMuZXJyb3IsICdmYWlsZWQgdG8gZ2V0IGNvbmZpcm1lZCBzaWduYXR1cmVzIGZvciBhZGRyZXNzJyk7XG4gICAgfVxuICAgIHJldHVybiByZXMucmVzdWx0O1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgY29uZmlybWVkIHNpZ25hdHVyZXMgZm9yIHRyYW5zYWN0aW9ucyBpbnZvbHZpbmcgYW5cbiAgICogYWRkcmVzcyBiYWNrd2FyZHMgaW4gdGltZSBmcm9tIHRoZSBwcm92aWRlZCBzaWduYXR1cmUgb3IgbW9zdCByZWNlbnQgY29uZmlybWVkIGJsb2NrXG4gICAqXG4gICAqXG4gICAqIEBwYXJhbSBhZGRyZXNzIHF1ZXJpZWQgYWRkcmVzc1xuICAgKiBAcGFyYW0gb3B0aW9uc1xuICAgKi9cbiAgYXN5bmMgZ2V0U2lnbmF0dXJlc0ZvckFkZHJlc3MoYWRkcmVzcywgb3B0aW9ucywgY29tbWl0bWVudCkge1xuICAgIGNvbnN0IGFyZ3MgPSB0aGlzLl9idWlsZEFyZ3NBdExlYXN0Q29uZmlybWVkKFthZGRyZXNzLnRvQmFzZTU4KCldLCBjb21taXRtZW50LCB1bmRlZmluZWQsIG9wdGlvbnMpO1xuICAgIGNvbnN0IHVuc2FmZVJlcyA9IGF3YWl0IHRoaXMuX3JwY1JlcXVlc3QoJ2dldFNpZ25hdHVyZXNGb3JBZGRyZXNzJywgYXJncyk7XG4gICAgY29uc3QgcmVzID0gY3JlYXRlKHVuc2FmZVJlcywgR2V0U2lnbmF0dXJlc0ZvckFkZHJlc3NScGNSZXN1bHQpO1xuICAgIGlmICgnZXJyb3InIGluIHJlcykge1xuICAgICAgdGhyb3cgbmV3IFNvbGFuYUpTT05SUENFcnJvcihyZXMuZXJyb3IsICdmYWlsZWQgdG8gZ2V0IHNpZ25hdHVyZXMgZm9yIGFkZHJlc3MnKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlcy5yZXN1bHQ7XG4gIH1cbiAgYXN5bmMgZ2V0QWRkcmVzc0xvb2t1cFRhYmxlKGFjY291bnRLZXksIGNvbmZpZykge1xuICAgIGNvbnN0IHtcbiAgICAgIGNvbnRleHQsXG4gICAgICB2YWx1ZTogYWNjb3VudEluZm9cbiAgICB9ID0gYXdhaXQgdGhpcy5nZXRBY2NvdW50SW5mb0FuZENvbnRleHQoYWNjb3VudEtleSwgY29uZmlnKTtcbiAgICBsZXQgdmFsdWUgPSBudWxsO1xuICAgIGlmIChhY2NvdW50SW5mbyAhPT0gbnVsbCkge1xuICAgICAgdmFsdWUgPSBuZXcgQWRkcmVzc0xvb2t1cFRhYmxlQWNjb3VudCh7XG4gICAgICAgIGtleTogYWNjb3VudEtleSxcbiAgICAgICAgc3RhdGU6IEFkZHJlc3NMb29rdXBUYWJsZUFjY291bnQuZGVzZXJpYWxpemUoYWNjb3VudEluZm8uZGF0YSlcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgY29udGV4dCxcbiAgICAgIHZhbHVlXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBGZXRjaCB0aGUgY29udGVudHMgb2YgYSBOb25jZSBhY2NvdW50IGZyb20gdGhlIGNsdXN0ZXIsIHJldHVybiB3aXRoIGNvbnRleHRcbiAgICovXG4gIGFzeW5jIGdldE5vbmNlQW5kQ29udGV4dChub25jZUFjY291bnQsIGNvbW1pdG1lbnRPckNvbmZpZykge1xuICAgIGNvbnN0IHtcbiAgICAgIGNvbnRleHQsXG4gICAgICB2YWx1ZTogYWNjb3VudEluZm9cbiAgICB9ID0gYXdhaXQgdGhpcy5nZXRBY2NvdW50SW5mb0FuZENvbnRleHQobm9uY2VBY2NvdW50LCBjb21taXRtZW50T3JDb25maWcpO1xuICAgIGxldCB2YWx1ZSA9IG51bGw7XG4gICAgaWYgKGFjY291bnRJbmZvICE9PSBudWxsKSB7XG4gICAgICB2YWx1ZSA9IE5vbmNlQWNjb3VudC5mcm9tQWNjb3VudERhdGEoYWNjb3VudEluZm8uZGF0YSk7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICBjb250ZXh0LFxuICAgICAgdmFsdWVcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIEZldGNoIHRoZSBjb250ZW50cyBvZiBhIE5vbmNlIGFjY291bnQgZnJvbSB0aGUgY2x1c3RlclxuICAgKi9cbiAgYXN5bmMgZ2V0Tm9uY2Uobm9uY2VBY2NvdW50LCBjb21taXRtZW50T3JDb25maWcpIHtcbiAgICByZXR1cm4gYXdhaXQgdGhpcy5nZXROb25jZUFuZENvbnRleHQobm9uY2VBY2NvdW50LCBjb21taXRtZW50T3JDb25maWcpLnRoZW4oeCA9PiB4LnZhbHVlKS5jYXRjaChlID0+IHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignZmFpbGVkIHRvIGdldCBub25jZSBmb3IgYWNjb3VudCAnICsgbm9uY2VBY2NvdW50LnRvQmFzZTU4KCkgKyAnOiAnICsgZSk7XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogUmVxdWVzdCBhbiBhbGxvY2F0aW9uIG9mIGxhbXBvcnRzIHRvIHRoZSBzcGVjaWZpZWQgYWRkcmVzc1xuICAgKlxuICAgKiBgYGB0eXBlc2NyaXB0XG4gICAqIGltcG9ydCB7IENvbm5lY3Rpb24sIFB1YmxpY0tleSwgTEFNUE9SVFNfUEVSX1NPTCB9IGZyb20gXCJAc29sYW5hL3dlYjMuanNcIjtcbiAgICpcbiAgICogKGFzeW5jICgpID0+IHtcbiAgICogICBjb25zdCBjb25uZWN0aW9uID0gbmV3IENvbm5lY3Rpb24oXCJodHRwczovL2FwaS50ZXN0bmV0LnNvbGFuYS5jb21cIiwgXCJjb25maXJtZWRcIik7XG4gICAqICAgY29uc3QgbXlBZGRyZXNzID0gbmV3IFB1YmxpY0tleShcIjJucjFiSEZUODZXOXRHbnl2bVlXNHZjSEtzUUIzc1ZRZm5kZGFzejRrRXhNXCIpO1xuICAgKiAgIGNvbnN0IHNpZ25hdHVyZSA9IGF3YWl0IGNvbm5lY3Rpb24ucmVxdWVzdEFpcmRyb3AobXlBZGRyZXNzLCBMQU1QT1JUU19QRVJfU09MKTtcbiAgICogICBhd2FpdCBjb25uZWN0aW9uLmNvbmZpcm1UcmFuc2FjdGlvbihzaWduYXR1cmUpO1xuICAgKiB9KSgpO1xuICAgKiBgYGBcbiAgICovXG4gIGFzeW5jIHJlcXVlc3RBaXJkcm9wKHRvLCBsYW1wb3J0cykge1xuICAgIGNvbnN0IHVuc2FmZVJlcyA9IGF3YWl0IHRoaXMuX3JwY1JlcXVlc3QoJ3JlcXVlc3RBaXJkcm9wJywgW3RvLnRvQmFzZTU4KCksIGxhbXBvcnRzXSk7XG4gICAgY29uc3QgcmVzID0gY3JlYXRlKHVuc2FmZVJlcywgUmVxdWVzdEFpcmRyb3BScGNSZXN1bHQpO1xuICAgIGlmICgnZXJyb3InIGluIHJlcykge1xuICAgICAgdGhyb3cgbmV3IFNvbGFuYUpTT05SUENFcnJvcihyZXMuZXJyb3IsIGBhaXJkcm9wIHRvICR7dG8udG9CYXNlNTgoKX0gZmFpbGVkYCk7XG4gICAgfVxuICAgIHJldHVybiByZXMucmVzdWx0O1xuICB9XG5cbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgYXN5bmMgX2Jsb2NraGFzaFdpdGhFeHBpcnlCbG9ja0hlaWdodChkaXNhYmxlQ2FjaGUpIHtcbiAgICBpZiAoIWRpc2FibGVDYWNoZSkge1xuICAgICAgLy8gV2FpdCBmb3IgcG9sbGluZyB0byBmaW5pc2hcbiAgICAgIHdoaWxlICh0aGlzLl9wb2xsaW5nQmxvY2toYXNoKSB7XG4gICAgICAgIGF3YWl0IHNsZWVwKDEwMCk7XG4gICAgICB9XG4gICAgICBjb25zdCB0aW1lU2luY2VGZXRjaCA9IERhdGUubm93KCkgLSB0aGlzLl9ibG9ja2hhc2hJbmZvLmxhc3RGZXRjaDtcbiAgICAgIGNvbnN0IGV4cGlyZWQgPSB0aW1lU2luY2VGZXRjaCA+PSBCTE9DS0hBU0hfQ0FDSEVfVElNRU9VVF9NUztcbiAgICAgIGlmICh0aGlzLl9ibG9ja2hhc2hJbmZvLmxhdGVzdEJsb2NraGFzaCAhPT0gbnVsbCAmJiAhZXhwaXJlZCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fYmxvY2toYXNoSW5mby5sYXRlc3RCbG9ja2hhc2g7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBhd2FpdCB0aGlzLl9wb2xsTmV3QmxvY2toYXNoKCk7XG4gIH1cblxuICAvKipcbiAgICogQGludGVybmFsXG4gICAqL1xuICBhc3luYyBfcG9sbE5ld0Jsb2NraGFzaCgpIHtcbiAgICB0aGlzLl9wb2xsaW5nQmxvY2toYXNoID0gdHJ1ZTtcbiAgICB0cnkge1xuICAgICAgY29uc3Qgc3RhcnRUaW1lID0gRGF0ZS5ub3coKTtcbiAgICAgIGNvbnN0IGNhY2hlZExhdGVzdEJsb2NraGFzaCA9IHRoaXMuX2Jsb2NraGFzaEluZm8ubGF0ZXN0QmxvY2toYXNoO1xuICAgICAgY29uc3QgY2FjaGVkQmxvY2toYXNoID0gY2FjaGVkTGF0ZXN0QmxvY2toYXNoID8gY2FjaGVkTGF0ZXN0QmxvY2toYXNoLmJsb2NraGFzaCA6IG51bGw7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDUwOyBpKyspIHtcbiAgICAgICAgY29uc3QgbGF0ZXN0QmxvY2toYXNoID0gYXdhaXQgdGhpcy5nZXRMYXRlc3RCbG9ja2hhc2goJ2ZpbmFsaXplZCcpO1xuICAgICAgICBpZiAoY2FjaGVkQmxvY2toYXNoICE9PSBsYXRlc3RCbG9ja2hhc2guYmxvY2toYXNoKSB7XG4gICAgICAgICAgdGhpcy5fYmxvY2toYXNoSW5mbyA9IHtcbiAgICAgICAgICAgIGxhdGVzdEJsb2NraGFzaCxcbiAgICAgICAgICAgIGxhc3RGZXRjaDogRGF0ZS5ub3coKSxcbiAgICAgICAgICAgIHRyYW5zYWN0aW9uU2lnbmF0dXJlczogW10sXG4gICAgICAgICAgICBzaW11bGF0ZWRTaWduYXR1cmVzOiBbXVxuICAgICAgICAgIH07XG4gICAgICAgICAgcmV0dXJuIGxhdGVzdEJsb2NraGFzaDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFNsZWVwIGZvciBhcHByb3hpbWF0ZWx5IGhhbGYgYSBzbG90XG4gICAgICAgIGF3YWl0IHNsZWVwKE1TX1BFUl9TTE9UIC8gMik7XG4gICAgICB9XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFVuYWJsZSB0byBvYnRhaW4gYSBuZXcgYmxvY2toYXNoIGFmdGVyICR7RGF0ZS5ub3coKSAtIHN0YXJ0VGltZX1tc2ApO1xuICAgIH0gZmluYWxseSB7XG4gICAgICB0aGlzLl9wb2xsaW5nQmxvY2toYXNoID0gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIGdldCB0aGUgc3Rha2UgbWluaW11bSBkZWxlZ2F0aW9uXG4gICAqL1xuICBhc3luYyBnZXRTdGFrZU1pbmltdW1EZWxlZ2F0aW9uKGNvbmZpZykge1xuICAgIGNvbnN0IHtcbiAgICAgIGNvbW1pdG1lbnQsXG4gICAgICBjb25maWc6IGNvbmZpZ0FyZ1xuICAgIH0gPSBleHRyYWN0Q29tbWl0bWVudEZyb21Db25maWcoY29uZmlnKTtcbiAgICBjb25zdCBhcmdzID0gdGhpcy5fYnVpbGRBcmdzKFtdLCBjb21taXRtZW50LCAnYmFzZTY0JywgY29uZmlnQXJnKTtcbiAgICBjb25zdCB1bnNhZmVSZXMgPSBhd2FpdCB0aGlzLl9ycGNSZXF1ZXN0KCdnZXRTdGFrZU1pbmltdW1EZWxlZ2F0aW9uJywgYXJncyk7XG4gICAgY29uc3QgcmVzID0gY3JlYXRlKHVuc2FmZVJlcywganNvblJwY1Jlc3VsdEFuZENvbnRleHQobnVtYmVyKCkpKTtcbiAgICBpZiAoJ2Vycm9yJyBpbiByZXMpIHtcbiAgICAgIHRocm93IG5ldyBTb2xhbmFKU09OUlBDRXJyb3IocmVzLmVycm9yLCBgZmFpbGVkIHRvIGdldCBzdGFrZSBtaW5pbXVtIGRlbGVnYXRpb25gKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlcy5yZXN1bHQ7XG4gIH1cblxuICAvKipcbiAgICogU2ltdWxhdGUgYSB0cmFuc2FjdGlvblxuICAgKlxuICAgKiBAZGVwcmVjYXRlZCBJbnN0ZWFkLCBjYWxsIHtAbGluayBzaW11bGF0ZVRyYW5zYWN0aW9ufSB3aXRoIHtAbGlua1xuICAgKiBWZXJzaW9uZWRUcmFuc2FjdGlvbn0gYW5kIHtAbGluayBTaW11bGF0ZVRyYW5zYWN0aW9uQ29uZmlnfSBwYXJhbWV0ZXJzXG4gICAqL1xuXG4gIC8qKlxuICAgKiBTaW11bGF0ZSBhIHRyYW5zYWN0aW9uXG4gICAqL1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tZHVwZS1jbGFzcy1tZW1iZXJzXG5cbiAgLyoqXG4gICAqIFNpbXVsYXRlIGEgdHJhbnNhY3Rpb25cbiAgICovXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1kdXBlLWNsYXNzLW1lbWJlcnNcbiAgYXN5bmMgc2ltdWxhdGVUcmFuc2FjdGlvbih0cmFuc2FjdGlvbk9yTWVzc2FnZSwgY29uZmlnT3JTaWduZXJzLCBpbmNsdWRlQWNjb3VudHMpIHtcbiAgICBpZiAoJ21lc3NhZ2UnIGluIHRyYW5zYWN0aW9uT3JNZXNzYWdlKSB7XG4gICAgICBjb25zdCB2ZXJzaW9uZWRUeCA9IHRyYW5zYWN0aW9uT3JNZXNzYWdlO1xuICAgICAgY29uc3Qgd2lyZVRyYW5zYWN0aW9uID0gdmVyc2lvbmVkVHguc2VyaWFsaXplKCk7XG4gICAgICBjb25zdCBlbmNvZGVkVHJhbnNhY3Rpb24gPSBCdWZmZXIuZnJvbSh3aXJlVHJhbnNhY3Rpb24pLnRvU3RyaW5nKCdiYXNlNjQnKTtcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KGNvbmZpZ09yU2lnbmVycykgfHwgaW5jbHVkZUFjY291bnRzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGFyZ3VtZW50cycpO1xuICAgICAgfVxuICAgICAgY29uc3QgY29uZmlnID0gY29uZmlnT3JTaWduZXJzIHx8IHt9O1xuICAgICAgY29uZmlnLmVuY29kaW5nID0gJ2Jhc2U2NCc7XG4gICAgICBpZiAoISgnY29tbWl0bWVudCcgaW4gY29uZmlnKSkge1xuICAgICAgICBjb25maWcuY29tbWl0bWVudCA9IHRoaXMuY29tbWl0bWVudDtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGFyZ3MgPSBbZW5jb2RlZFRyYW5zYWN0aW9uLCBjb25maWddO1xuICAgICAgY29uc3QgdW5zYWZlUmVzID0gYXdhaXQgdGhpcy5fcnBjUmVxdWVzdCgnc2ltdWxhdGVUcmFuc2FjdGlvbicsIGFyZ3MpO1xuICAgICAgY29uc3QgcmVzID0gY3JlYXRlKHVuc2FmZVJlcywgU2ltdWxhdGVkVHJhbnNhY3Rpb25SZXNwb25zZVN0cnVjdCk7XG4gICAgICBpZiAoJ2Vycm9yJyBpbiByZXMpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdmYWlsZWQgdG8gc2ltdWxhdGUgdHJhbnNhY3Rpb246ICcgKyByZXMuZXJyb3IubWVzc2FnZSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzLnJlc3VsdDtcbiAgICB9XG4gICAgbGV0IHRyYW5zYWN0aW9uO1xuICAgIGlmICh0cmFuc2FjdGlvbk9yTWVzc2FnZSBpbnN0YW5jZW9mIFRyYW5zYWN0aW9uKSB7XG4gICAgICBsZXQgb3JpZ2luYWxUeCA9IHRyYW5zYWN0aW9uT3JNZXNzYWdlO1xuICAgICAgdHJhbnNhY3Rpb24gPSBuZXcgVHJhbnNhY3Rpb24oKTtcbiAgICAgIHRyYW5zYWN0aW9uLmZlZVBheWVyID0gb3JpZ2luYWxUeC5mZWVQYXllcjtcbiAgICAgIHRyYW5zYWN0aW9uLmluc3RydWN0aW9ucyA9IHRyYW5zYWN0aW9uT3JNZXNzYWdlLmluc3RydWN0aW9ucztcbiAgICAgIHRyYW5zYWN0aW9uLm5vbmNlSW5mbyA9IG9yaWdpbmFsVHgubm9uY2VJbmZvO1xuICAgICAgdHJhbnNhY3Rpb24uc2lnbmF0dXJlcyA9IG9yaWdpbmFsVHguc2lnbmF0dXJlcztcbiAgICB9IGVsc2Uge1xuICAgICAgdHJhbnNhY3Rpb24gPSBUcmFuc2FjdGlvbi5wb3B1bGF0ZSh0cmFuc2FjdGlvbk9yTWVzc2FnZSk7XG4gICAgICAvLyBIQUNLOiB0aGlzIGZ1bmN0aW9uIHJlbGllcyBvbiBtdXRhdGluZyB0aGUgcG9wdWxhdGVkIHRyYW5zYWN0aW9uXG4gICAgICB0cmFuc2FjdGlvbi5fbWVzc2FnZSA9IHRyYW5zYWN0aW9uLl9qc29uID0gdW5kZWZpbmVkO1xuICAgIH1cbiAgICBpZiAoY29uZmlnT3JTaWduZXJzICE9PSB1bmRlZmluZWQgJiYgIUFycmF5LmlzQXJyYXkoY29uZmlnT3JTaWduZXJzKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGFyZ3VtZW50cycpO1xuICAgIH1cbiAgICBjb25zdCBzaWduZXJzID0gY29uZmlnT3JTaWduZXJzO1xuICAgIGlmICh0cmFuc2FjdGlvbi5ub25jZUluZm8gJiYgc2lnbmVycykge1xuICAgICAgdHJhbnNhY3Rpb24uc2lnbiguLi5zaWduZXJzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbGV0IGRpc2FibGVDYWNoZSA9IHRoaXMuX2Rpc2FibGVCbG9ja2hhc2hDYWNoaW5nO1xuICAgICAgZm9yICg7Oykge1xuICAgICAgICBjb25zdCBsYXRlc3RCbG9ja2hhc2ggPSBhd2FpdCB0aGlzLl9ibG9ja2hhc2hXaXRoRXhwaXJ5QmxvY2tIZWlnaHQoZGlzYWJsZUNhY2hlKTtcbiAgICAgICAgdHJhbnNhY3Rpb24ubGFzdFZhbGlkQmxvY2tIZWlnaHQgPSBsYXRlc3RCbG9ja2hhc2gubGFzdFZhbGlkQmxvY2tIZWlnaHQ7XG4gICAgICAgIHRyYW5zYWN0aW9uLnJlY2VudEJsb2NraGFzaCA9IGxhdGVzdEJsb2NraGFzaC5ibG9ja2hhc2g7XG4gICAgICAgIGlmICghc2lnbmVycykgYnJlYWs7XG4gICAgICAgIHRyYW5zYWN0aW9uLnNpZ24oLi4uc2lnbmVycyk7XG4gICAgICAgIGlmICghdHJhbnNhY3Rpb24uc2lnbmF0dXJlKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCchc2lnbmF0dXJlJyk7IC8vIHNob3VsZCBuZXZlciBoYXBwZW5cbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzaWduYXR1cmUgPSB0cmFuc2FjdGlvbi5zaWduYXR1cmUudG9TdHJpbmcoJ2Jhc2U2NCcpO1xuICAgICAgICBpZiAoIXRoaXMuX2Jsb2NraGFzaEluZm8uc2ltdWxhdGVkU2lnbmF0dXJlcy5pbmNsdWRlcyhzaWduYXR1cmUpICYmICF0aGlzLl9ibG9ja2hhc2hJbmZvLnRyYW5zYWN0aW9uU2lnbmF0dXJlcy5pbmNsdWRlcyhzaWduYXR1cmUpKSB7XG4gICAgICAgICAgLy8gVGhlIHNpZ25hdHVyZSBvZiB0aGlzIHRyYW5zYWN0aW9uIGhhcyBub3QgYmVlbiBzZWVuIGJlZm9yZSB3aXRoIHRoZVxuICAgICAgICAgIC8vIGN1cnJlbnQgcmVjZW50QmxvY2toYXNoLCBhbGwgZG9uZS4gTGV0J3MgYnJlYWtcbiAgICAgICAgICB0aGlzLl9ibG9ja2hhc2hJbmZvLnNpbXVsYXRlZFNpZ25hdHVyZXMucHVzaChzaWduYXR1cmUpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIFRoaXMgdHJhbnNhY3Rpb24gd291bGQgYmUgdHJlYXRlZCBhcyBkdXBsaWNhdGUgKGl0cyBkZXJpdmVkIHNpZ25hdHVyZVxuICAgICAgICAgIC8vIG1hdGNoZWQgdG8gb25lIG9mIGFscmVhZHkgcmVjb3JkZWQgc2lnbmF0dXJlcykuXG4gICAgICAgICAgLy8gU28sIHdlIG11c3QgZmV0Y2ggYSBuZXcgYmxvY2toYXNoIGZvciBhIGRpZmZlcmVudCBzaWduYXR1cmUgYnkgZGlzYWJsaW5nXG4gICAgICAgICAgLy8gb3VyIGNhY2hlIG5vdCB0byB3YWl0IGZvciB0aGUgY2FjaGUgZXhwaXJhdGlvbiAoQkxPQ0tIQVNIX0NBQ0hFX1RJTUVPVVRfTVMpLlxuICAgICAgICAgIGRpc2FibGVDYWNoZSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgbWVzc2FnZSA9IHRyYW5zYWN0aW9uLl9jb21waWxlKCk7XG4gICAgY29uc3Qgc2lnbkRhdGEgPSBtZXNzYWdlLnNlcmlhbGl6ZSgpO1xuICAgIGNvbnN0IHdpcmVUcmFuc2FjdGlvbiA9IHRyYW5zYWN0aW9uLl9zZXJpYWxpemUoc2lnbkRhdGEpO1xuICAgIGNvbnN0IGVuY29kZWRUcmFuc2FjdGlvbiA9IHdpcmVUcmFuc2FjdGlvbi50b1N0cmluZygnYmFzZTY0Jyk7XG4gICAgY29uc3QgY29uZmlnID0ge1xuICAgICAgZW5jb2Rpbmc6ICdiYXNlNjQnLFxuICAgICAgY29tbWl0bWVudDogdGhpcy5jb21taXRtZW50XG4gICAgfTtcbiAgICBpZiAoaW5jbHVkZUFjY291bnRzKSB7XG4gICAgICBjb25zdCBhZGRyZXNzZXMgPSAoQXJyYXkuaXNBcnJheShpbmNsdWRlQWNjb3VudHMpID8gaW5jbHVkZUFjY291bnRzIDogbWVzc2FnZS5ub25Qcm9ncmFtSWRzKCkpLm1hcChrZXkgPT4ga2V5LnRvQmFzZTU4KCkpO1xuICAgICAgY29uZmlnWydhY2NvdW50cyddID0ge1xuICAgICAgICBlbmNvZGluZzogJ2Jhc2U2NCcsXG4gICAgICAgIGFkZHJlc3Nlc1xuICAgICAgfTtcbiAgICB9XG4gICAgaWYgKHNpZ25lcnMpIHtcbiAgICAgIGNvbmZpZy5zaWdWZXJpZnkgPSB0cnVlO1xuICAgIH1cbiAgICBjb25zdCBhcmdzID0gW2VuY29kZWRUcmFuc2FjdGlvbiwgY29uZmlnXTtcbiAgICBjb25zdCB1bnNhZmVSZXMgPSBhd2FpdCB0aGlzLl9ycGNSZXF1ZXN0KCdzaW11bGF0ZVRyYW5zYWN0aW9uJywgYXJncyk7XG4gICAgY29uc3QgcmVzID0gY3JlYXRlKHVuc2FmZVJlcywgU2ltdWxhdGVkVHJhbnNhY3Rpb25SZXNwb25zZVN0cnVjdCk7XG4gICAgaWYgKCdlcnJvcicgaW4gcmVzKSB7XG4gICAgICBsZXQgbG9ncztcbiAgICAgIGlmICgnZGF0YScgaW4gcmVzLmVycm9yKSB7XG4gICAgICAgIGxvZ3MgPSByZXMuZXJyb3IuZGF0YS5sb2dzO1xuICAgICAgICBpZiAobG9ncyAmJiBBcnJheS5pc0FycmF5KGxvZ3MpKSB7XG4gICAgICAgICAgY29uc3QgdHJhY2VJbmRlbnQgPSAnXFxuICAgICc7XG4gICAgICAgICAgY29uc3QgbG9nVHJhY2UgPSB0cmFjZUluZGVudCArIGxvZ3Muam9pbih0cmFjZUluZGVudCk7XG4gICAgICAgICAgY29uc29sZS5lcnJvcihyZXMuZXJyb3IubWVzc2FnZSwgbG9nVHJhY2UpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB0aHJvdyBuZXcgU2VuZFRyYW5zYWN0aW9uRXJyb3IoJ2ZhaWxlZCB0byBzaW11bGF0ZSB0cmFuc2FjdGlvbjogJyArIHJlcy5lcnJvci5tZXNzYWdlLCBsb2dzKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlcy5yZXN1bHQ7XG4gIH1cblxuICAvKipcbiAgICogU2lnbiBhbmQgc2VuZCBhIHRyYW5zYWN0aW9uXG4gICAqXG4gICAqIEBkZXByZWNhdGVkIEluc3RlYWQsIGNhbGwge0BsaW5rIHNlbmRUcmFuc2FjdGlvbn0gd2l0aCBhIHtAbGlua1xuICAgKiBWZXJzaW9uZWRUcmFuc2FjdGlvbn1cbiAgICovXG5cbiAgLyoqXG4gICAqIFNlbmQgYSBzaWduZWQgdHJhbnNhY3Rpb25cbiAgICovXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1kdXBlLWNsYXNzLW1lbWJlcnNcblxuICAvKipcbiAgICogU2lnbiBhbmQgc2VuZCBhIHRyYW5zYWN0aW9uXG4gICAqL1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tZHVwZS1jbGFzcy1tZW1iZXJzXG4gIGFzeW5jIHNlbmRUcmFuc2FjdGlvbih0cmFuc2FjdGlvbiwgc2lnbmVyc09yT3B0aW9ucywgb3B0aW9ucykge1xuICAgIGlmICgndmVyc2lvbicgaW4gdHJhbnNhY3Rpb24pIHtcbiAgICAgIGlmIChzaWduZXJzT3JPcHRpb25zICYmIEFycmF5LmlzQXJyYXkoc2lnbmVyc09yT3B0aW9ucykpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGFyZ3VtZW50cycpO1xuICAgICAgfVxuICAgICAgY29uc3Qgd2lyZVRyYW5zYWN0aW9uID0gdHJhbnNhY3Rpb24uc2VyaWFsaXplKCk7XG4gICAgICByZXR1cm4gYXdhaXQgdGhpcy5zZW5kUmF3VHJhbnNhY3Rpb24od2lyZVRyYW5zYWN0aW9uLCBzaWduZXJzT3JPcHRpb25zKTtcbiAgICB9XG4gICAgaWYgKHNpZ25lcnNPck9wdGlvbnMgPT09IHVuZGVmaW5lZCB8fCAhQXJyYXkuaXNBcnJheShzaWduZXJzT3JPcHRpb25zKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGFyZ3VtZW50cycpO1xuICAgIH1cbiAgICBjb25zdCBzaWduZXJzID0gc2lnbmVyc09yT3B0aW9ucztcbiAgICBpZiAodHJhbnNhY3Rpb24ubm9uY2VJbmZvKSB7XG4gICAgICB0cmFuc2FjdGlvbi5zaWduKC4uLnNpZ25lcnMpO1xuICAgIH0gZWxzZSB7XG4gICAgICBsZXQgZGlzYWJsZUNhY2hlID0gdGhpcy5fZGlzYWJsZUJsb2NraGFzaENhY2hpbmc7XG4gICAgICBmb3IgKDs7KSB7XG4gICAgICAgIGNvbnN0IGxhdGVzdEJsb2NraGFzaCA9IGF3YWl0IHRoaXMuX2Jsb2NraGFzaFdpdGhFeHBpcnlCbG9ja0hlaWdodChkaXNhYmxlQ2FjaGUpO1xuICAgICAgICB0cmFuc2FjdGlvbi5sYXN0VmFsaWRCbG9ja0hlaWdodCA9IGxhdGVzdEJsb2NraGFzaC5sYXN0VmFsaWRCbG9ja0hlaWdodDtcbiAgICAgICAgdHJhbnNhY3Rpb24ucmVjZW50QmxvY2toYXNoID0gbGF0ZXN0QmxvY2toYXNoLmJsb2NraGFzaDtcbiAgICAgICAgdHJhbnNhY3Rpb24uc2lnbiguLi5zaWduZXJzKTtcbiAgICAgICAgaWYgKCF0cmFuc2FjdGlvbi5zaWduYXR1cmUpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJyFzaWduYXR1cmUnKTsgLy8gc2hvdWxkIG5ldmVyIGhhcHBlblxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHNpZ25hdHVyZSA9IHRyYW5zYWN0aW9uLnNpZ25hdHVyZS50b1N0cmluZygnYmFzZTY0Jyk7XG4gICAgICAgIGlmICghdGhpcy5fYmxvY2toYXNoSW5mby50cmFuc2FjdGlvblNpZ25hdHVyZXMuaW5jbHVkZXMoc2lnbmF0dXJlKSkge1xuICAgICAgICAgIC8vIFRoZSBzaWduYXR1cmUgb2YgdGhpcyB0cmFuc2FjdGlvbiBoYXMgbm90IGJlZW4gc2VlbiBiZWZvcmUgd2l0aCB0aGVcbiAgICAgICAgICAvLyBjdXJyZW50IHJlY2VudEJsb2NraGFzaCwgYWxsIGRvbmUuIExldCdzIGJyZWFrXG4gICAgICAgICAgdGhpcy5fYmxvY2toYXNoSW5mby50cmFuc2FjdGlvblNpZ25hdHVyZXMucHVzaChzaWduYXR1cmUpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIFRoaXMgdHJhbnNhY3Rpb24gd291bGQgYmUgdHJlYXRlZCBhcyBkdXBsaWNhdGUgKGl0cyBkZXJpdmVkIHNpZ25hdHVyZVxuICAgICAgICAgIC8vIG1hdGNoZWQgdG8gb25lIG9mIGFscmVhZHkgcmVjb3JkZWQgc2lnbmF0dXJlcykuXG4gICAgICAgICAgLy8gU28sIHdlIG11c3QgZmV0Y2ggYSBuZXcgYmxvY2toYXNoIGZvciBhIGRpZmZlcmVudCBzaWduYXR1cmUgYnkgZGlzYWJsaW5nXG4gICAgICAgICAgLy8gb3VyIGNhY2hlIG5vdCB0byB3YWl0IGZvciB0aGUgY2FjaGUgZXhwaXJhdGlvbiAoQkxPQ0tIQVNIX0NBQ0hFX1RJTUVPVVRfTVMpLlxuICAgICAgICAgIGRpc2FibGVDYWNoZSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3Qgd2lyZVRyYW5zYWN0aW9uID0gdHJhbnNhY3Rpb24uc2VyaWFsaXplKCk7XG4gICAgcmV0dXJuIGF3YWl0IHRoaXMuc2VuZFJhd1RyYW5zYWN0aW9uKHdpcmVUcmFuc2FjdGlvbiwgb3B0aW9ucyk7XG4gIH1cblxuICAvKipcbiAgICogU2VuZCBhIHRyYW5zYWN0aW9uIHRoYXQgaGFzIGFscmVhZHkgYmVlbiBzaWduZWQgYW5kIHNlcmlhbGl6ZWQgaW50byB0aGVcbiAgICogd2lyZSBmb3JtYXRcbiAgICovXG4gIGFzeW5jIHNlbmRSYXdUcmFuc2FjdGlvbihyYXdUcmFuc2FjdGlvbiwgb3B0aW9ucykge1xuICAgIGNvbnN0IGVuY29kZWRUcmFuc2FjdGlvbiA9IHRvQnVmZmVyKHJhd1RyYW5zYWN0aW9uKS50b1N0cmluZygnYmFzZTY0Jyk7XG4gICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgdGhpcy5zZW5kRW5jb2RlZFRyYW5zYWN0aW9uKGVuY29kZWRUcmFuc2FjdGlvbiwgb3B0aW9ucyk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZW5kIGEgdHJhbnNhY3Rpb24gdGhhdCBoYXMgYWxyZWFkeSBiZWVuIHNpZ25lZCwgc2VyaWFsaXplZCBpbnRvIHRoZVxuICAgKiB3aXJlIGZvcm1hdCwgYW5kIGVuY29kZWQgYXMgYSBiYXNlNjQgc3RyaW5nXG4gICAqL1xuICBhc3luYyBzZW5kRW5jb2RlZFRyYW5zYWN0aW9uKGVuY29kZWRUcmFuc2FjdGlvbiwgb3B0aW9ucykge1xuICAgIGNvbnN0IGNvbmZpZyA9IHtcbiAgICAgIGVuY29kaW5nOiAnYmFzZTY0J1xuICAgIH07XG4gICAgY29uc3Qgc2tpcFByZWZsaWdodCA9IG9wdGlvbnMgJiYgb3B0aW9ucy5za2lwUHJlZmxpZ2h0O1xuICAgIGNvbnN0IHByZWZsaWdodENvbW1pdG1lbnQgPSBza2lwUHJlZmxpZ2h0ID09PSB0cnVlID8gJ3Byb2Nlc3NlZCcgLy8gRklYTUUgUmVtb3ZlIHdoZW4gaHR0cHM6Ly9naXRodWIuY29tL2FuemEteHl6L2FnYXZlL3B1bGwvNDgzIGlzIGRlcGxveWVkLlxuICAgIDogb3B0aW9ucyAmJiBvcHRpb25zLnByZWZsaWdodENvbW1pdG1lbnQgfHwgdGhpcy5jb21taXRtZW50O1xuICAgIGlmIChvcHRpb25zICYmIG9wdGlvbnMubWF4UmV0cmllcyAhPSBudWxsKSB7XG4gICAgICBjb25maWcubWF4UmV0cmllcyA9IG9wdGlvbnMubWF4UmV0cmllcztcbiAgICB9XG4gICAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5taW5Db250ZXh0U2xvdCAhPSBudWxsKSB7XG4gICAgICBjb25maWcubWluQ29udGV4dFNsb3QgPSBvcHRpb25zLm1pbkNvbnRleHRTbG90O1xuICAgIH1cbiAgICBpZiAoc2tpcFByZWZsaWdodCkge1xuICAgICAgY29uZmlnLnNraXBQcmVmbGlnaHQgPSBza2lwUHJlZmxpZ2h0O1xuICAgIH1cbiAgICBpZiAocHJlZmxpZ2h0Q29tbWl0bWVudCkge1xuICAgICAgY29uZmlnLnByZWZsaWdodENvbW1pdG1lbnQgPSBwcmVmbGlnaHRDb21taXRtZW50O1xuICAgIH1cbiAgICBjb25zdCBhcmdzID0gW2VuY29kZWRUcmFuc2FjdGlvbiwgY29uZmlnXTtcbiAgICBjb25zdCB1bnNhZmVSZXMgPSBhd2FpdCB0aGlzLl9ycGNSZXF1ZXN0KCdzZW5kVHJhbnNhY3Rpb24nLCBhcmdzKTtcbiAgICBjb25zdCByZXMgPSBjcmVhdGUodW5zYWZlUmVzLCBTZW5kVHJhbnNhY3Rpb25ScGNSZXN1bHQpO1xuICAgIGlmICgnZXJyb3InIGluIHJlcykge1xuICAgICAgbGV0IGxvZ3M7XG4gICAgICBpZiAoJ2RhdGEnIGluIHJlcy5lcnJvcikge1xuICAgICAgICBsb2dzID0gcmVzLmVycm9yLmRhdGEubG9ncztcbiAgICAgIH1cbiAgICAgIHRocm93IG5ldyBTZW5kVHJhbnNhY3Rpb25FcnJvcignZmFpbGVkIHRvIHNlbmQgdHJhbnNhY3Rpb246ICcgKyByZXMuZXJyb3IubWVzc2FnZSwgbG9ncyk7XG4gICAgfVxuICAgIHJldHVybiByZXMucmVzdWx0O1xuICB9XG5cbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgX3dzT25PcGVuKCkge1xuICAgIHRoaXMuX3JwY1dlYlNvY2tldENvbm5lY3RlZCA9IHRydWU7XG4gICAgdGhpcy5fcnBjV2ViU29ja2V0SGVhcnRiZWF0ID0gc2V0SW50ZXJ2YWwoKCkgPT4ge1xuICAgICAgLy8gUGluZyBzZXJ2ZXIgZXZlcnkgNXMgdG8gcHJldmVudCBpZGxlIHRpbWVvdXRzXG4gICAgICAoYXN5bmMgKCkgPT4ge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGF3YWl0IHRoaXMuX3JwY1dlYlNvY2tldC5ub3RpZnkoJ3BpbmcnKTtcbiAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tZW1wdHlcbiAgICAgICAgfSBjYXRjaCB7fVxuICAgICAgfSkoKTtcbiAgICB9LCA1MDAwKTtcbiAgICB0aGlzLl91cGRhdGVTdWJzY3JpcHRpb25zKCk7XG4gIH1cblxuICAvKipcbiAgICogQGludGVybmFsXG4gICAqL1xuICBfd3NPbkVycm9yKGVycikge1xuICAgIHRoaXMuX3JwY1dlYlNvY2tldENvbm5lY3RlZCA9IGZhbHNlO1xuICAgIGNvbnNvbGUuZXJyb3IoJ3dzIGVycm9yOicsIGVyci5tZXNzYWdlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIF93c09uQ2xvc2UoY29kZSkge1xuICAgIHRoaXMuX3JwY1dlYlNvY2tldENvbm5lY3RlZCA9IGZhbHNlO1xuICAgIHRoaXMuX3JwY1dlYlNvY2tldEdlbmVyYXRpb24gPSAodGhpcy5fcnBjV2ViU29ja2V0R2VuZXJhdGlvbiArIDEpICUgTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVI7XG4gICAgaWYgKHRoaXMuX3JwY1dlYlNvY2tldElkbGVUaW1lb3V0KSB7XG4gICAgICBjbGVhclRpbWVvdXQodGhpcy5fcnBjV2ViU29ja2V0SWRsZVRpbWVvdXQpO1xuICAgICAgdGhpcy5fcnBjV2ViU29ja2V0SWRsZVRpbWVvdXQgPSBudWxsO1xuICAgIH1cbiAgICBpZiAodGhpcy5fcnBjV2ViU29ja2V0SGVhcnRiZWF0KSB7XG4gICAgICBjbGVhckludGVydmFsKHRoaXMuX3JwY1dlYlNvY2tldEhlYXJ0YmVhdCk7XG4gICAgICB0aGlzLl9ycGNXZWJTb2NrZXRIZWFydGJlYXQgPSBudWxsO1xuICAgIH1cbiAgICBpZiAoY29kZSA9PT0gMTAwMCkge1xuICAgICAgLy8gZXhwbGljaXQgY2xvc2UsIGNoZWNrIGlmIGFueSBzdWJzY3JpcHRpb25zIGhhdmUgYmVlbiBtYWRlIHNpbmNlIGNsb3NlXG4gICAgICB0aGlzLl91cGRhdGVTdWJzY3JpcHRpb25zKCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gaW1wbGljaXQgY2xvc2UsIHByZXBhcmUgc3Vic2NyaXB0aW9ucyBmb3IgYXV0by1yZWNvbm5lY3RcbiAgICB0aGlzLl9zdWJzY3JpcHRpb25DYWxsYmFja3NCeVNlcnZlclN1YnNjcmlwdGlvbklkID0ge307XG4gICAgT2JqZWN0LmVudHJpZXModGhpcy5fc3Vic2NyaXB0aW9uc0J5SGFzaCkuZm9yRWFjaCgoW2hhc2gsIHN1YnNjcmlwdGlvbl0pID0+IHtcbiAgICAgIHRoaXMuX3NldFN1YnNjcmlwdGlvbihoYXNoLCB7XG4gICAgICAgIC4uLnN1YnNjcmlwdGlvbixcbiAgICAgICAgc3RhdGU6ICdwZW5kaW5nJ1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogQGludGVybmFsXG4gICAqL1xuICBfc2V0U3Vic2NyaXB0aW9uKGhhc2gsIG5leHRTdWJzY3JpcHRpb24pIHtcbiAgICBjb25zdCBwcmV2U3RhdGUgPSB0aGlzLl9zdWJzY3JpcHRpb25zQnlIYXNoW2hhc2hdPy5zdGF0ZTtcbiAgICB0aGlzLl9zdWJzY3JpcHRpb25zQnlIYXNoW2hhc2hdID0gbmV4dFN1YnNjcmlwdGlvbjtcbiAgICBpZiAocHJldlN0YXRlICE9PSBuZXh0U3Vic2NyaXB0aW9uLnN0YXRlKSB7XG4gICAgICBjb25zdCBzdGF0ZUNoYW5nZUNhbGxiYWNrcyA9IHRoaXMuX3N1YnNjcmlwdGlvblN0YXRlQ2hhbmdlQ2FsbGJhY2tzQnlIYXNoW2hhc2hdO1xuICAgICAgaWYgKHN0YXRlQ2hhbmdlQ2FsbGJhY2tzKSB7XG4gICAgICAgIHN0YXRlQ2hhbmdlQ2FsbGJhY2tzLmZvckVhY2goY2IgPT4ge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjYihuZXh0U3Vic2NyaXB0aW9uLnN0YXRlKTtcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1lbXB0eVxuICAgICAgICAgIH0gY2F0Y2gge31cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgX29uU3Vic2NyaXB0aW9uU3RhdGVDaGFuZ2UoY2xpZW50U3Vic2NyaXB0aW9uSWQsIGNhbGxiYWNrKSB7XG4gICAgY29uc3QgaGFzaCA9IHRoaXMuX3N1YnNjcmlwdGlvbkhhc2hCeUNsaWVudFN1YnNjcmlwdGlvbklkW2NsaWVudFN1YnNjcmlwdGlvbklkXTtcbiAgICBpZiAoaGFzaCA9PSBudWxsKSB7XG4gICAgICByZXR1cm4gKCkgPT4ge307XG4gICAgfVxuICAgIGNvbnN0IHN0YXRlQ2hhbmdlQ2FsbGJhY2tzID0gdGhpcy5fc3Vic2NyaXB0aW9uU3RhdGVDaGFuZ2VDYWxsYmFja3NCeUhhc2hbaGFzaF0gfHw9IG5ldyBTZXQoKTtcbiAgICBzdGF0ZUNoYW5nZUNhbGxiYWNrcy5hZGQoY2FsbGJhY2spO1xuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICBzdGF0ZUNoYW5nZUNhbGxiYWNrcy5kZWxldGUoY2FsbGJhY2spO1xuICAgICAgaWYgKHN0YXRlQ2hhbmdlQ2FsbGJhY2tzLnNpemUgPT09IDApIHtcbiAgICAgICAgZGVsZXRlIHRoaXMuX3N1YnNjcmlwdGlvblN0YXRlQ2hhbmdlQ2FsbGJhY2tzQnlIYXNoW2hhc2hdO1xuICAgICAgfVxuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogQGludGVybmFsXG4gICAqL1xuICBhc3luYyBfdXBkYXRlU3Vic2NyaXB0aW9ucygpIHtcbiAgICBpZiAoT2JqZWN0LmtleXModGhpcy5fc3Vic2NyaXB0aW9uc0J5SGFzaCkubGVuZ3RoID09PSAwKSB7XG4gICAgICBpZiAodGhpcy5fcnBjV2ViU29ja2V0Q29ubmVjdGVkKSB7XG4gICAgICAgIHRoaXMuX3JwY1dlYlNvY2tldENvbm5lY3RlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9ycGNXZWJTb2NrZXRJZGxlVGltZW91dCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgIHRoaXMuX3JwY1dlYlNvY2tldElkbGVUaW1lb3V0ID0gbnVsbDtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgdGhpcy5fcnBjV2ViU29ja2V0LmNsb3NlKCk7XG4gICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAvLyBzd2FsbG93IGVycm9yIGlmIHNvY2tldCBoYXMgYWxyZWFkeSBiZWVuIGNsb3NlZC5cbiAgICAgICAgICAgIGlmIChlcnIgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICAgICAgICBjb25zb2xlLmxvZyhgRXJyb3Igd2hlbiBjbG9zaW5nIHNvY2tldCBjb25uZWN0aW9uOiAke2Vyci5tZXNzYWdlfWApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSwgNTAwKTtcbiAgICAgIH1cbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHRoaXMuX3JwY1dlYlNvY2tldElkbGVUaW1lb3V0ICE9PSBudWxsKSB7XG4gICAgICBjbGVhclRpbWVvdXQodGhpcy5fcnBjV2ViU29ja2V0SWRsZVRpbWVvdXQpO1xuICAgICAgdGhpcy5fcnBjV2ViU29ja2V0SWRsZVRpbWVvdXQgPSBudWxsO1xuICAgICAgdGhpcy5fcnBjV2ViU29ja2V0Q29ubmVjdGVkID0gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKCF0aGlzLl9ycGNXZWJTb2NrZXRDb25uZWN0ZWQpIHtcbiAgICAgIHRoaXMuX3JwY1dlYlNvY2tldC5jb25uZWN0KCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGFjdGl2ZVdlYlNvY2tldEdlbmVyYXRpb24gPSB0aGlzLl9ycGNXZWJTb2NrZXRHZW5lcmF0aW9uO1xuICAgIGNvbnN0IGlzQ3VycmVudENvbm5lY3Rpb25TdGlsbEFjdGl2ZSA9ICgpID0+IHtcbiAgICAgIHJldHVybiBhY3RpdmVXZWJTb2NrZXRHZW5lcmF0aW9uID09PSB0aGlzLl9ycGNXZWJTb2NrZXRHZW5lcmF0aW9uO1xuICAgIH07XG4gICAgYXdhaXQgUHJvbWlzZS5hbGwoXG4gICAgLy8gRG9uJ3QgYmUgdGVtcHRlZCB0byBjaGFuZ2UgdGhpcyB0byBgT2JqZWN0LmVudHJpZXNgLiBXZSBjYWxsXG4gICAgLy8gYF91cGRhdGVTdWJzY3JpcHRpb25zYCByZWN1cnNpdmVseSB3aGVuIHByb2Nlc3NpbmcgdGhlIHN0YXRlLFxuICAgIC8vIHNvIGl0J3MgaW1wb3J0YW50IHRoYXQgd2UgbG9vayB1cCB0aGUgKmN1cnJlbnQqIHZlcnNpb24gb2ZcbiAgICAvLyBlYWNoIHN1YnNjcmlwdGlvbiwgZXZlcnkgdGltZSB3ZSBwcm9jZXNzIGEgaGFzaC5cbiAgICBPYmplY3Qua2V5cyh0aGlzLl9zdWJzY3JpcHRpb25zQnlIYXNoKS5tYXAoYXN5bmMgaGFzaCA9PiB7XG4gICAgICBjb25zdCBzdWJzY3JpcHRpb24gPSB0aGlzLl9zdWJzY3JpcHRpb25zQnlIYXNoW2hhc2hdO1xuICAgICAgaWYgKHN1YnNjcmlwdGlvbiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIC8vIFRoaXMgZW50cnkgaGFzIHNpbmNlIGJlZW4gZGVsZXRlZC4gU2tpcC5cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgc3dpdGNoIChzdWJzY3JpcHRpb24uc3RhdGUpIHtcbiAgICAgICAgY2FzZSAncGVuZGluZyc6XG4gICAgICAgIGNhc2UgJ3Vuc3Vic2NyaWJlZCc6XG4gICAgICAgICAgaWYgKHN1YnNjcmlwdGlvbi5jYWxsYmFja3Muc2l6ZSA9PT0gMCkge1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBZb3UgY2FuIGVuZCB1cCBoZXJlIHdoZW46XG4gICAgICAgICAgICAgKlxuICAgICAgICAgICAgICogLSBhIHN1YnNjcmlwdGlvbiBoYXMgcmVjZW50bHkgdW5zdWJzY3JpYmVkXG4gICAgICAgICAgICAgKiAgIHdpdGhvdXQgaGF2aW5nIG5ldyBjYWxsYmFja3MgYWRkZWQgdG8gaXRcbiAgICAgICAgICAgICAqICAgd2hpbGUgdGhlIHVuc3Vic2NyaWJlIHdhcyBpbiBmbGlnaHQsIG9yXG4gICAgICAgICAgICAgKiAtIHdoZW4gYSBwZW5kaW5nIHN1YnNjcmlwdGlvbiBoYXMgaXRzXG4gICAgICAgICAgICAgKiAgIGxpc3RlbmVycyByZW1vdmVkIGJlZm9yZSBhIHJlcXVlc3Qgd2FzXG4gICAgICAgICAgICAgKiAgIHNlbnQgdG8gdGhlIHNlcnZlci5cbiAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgKiBCZWluZyB0aGF0IG5vYm9keSBpcyBpbnRlcmVzdGVkIGluIHRoaXNcbiAgICAgICAgICAgICAqIHN1YnNjcmlwdGlvbiBhbnkgbG9uZ2VyLCBkZWxldGUgaXQuXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGRlbGV0ZSB0aGlzLl9zdWJzY3JpcHRpb25zQnlIYXNoW2hhc2hdO1xuICAgICAgICAgICAgaWYgKHN1YnNjcmlwdGlvbi5zdGF0ZSA9PT0gJ3Vuc3Vic2NyaWJlZCcpIHtcbiAgICAgICAgICAgICAgZGVsZXRlIHRoaXMuX3N1YnNjcmlwdGlvbkNhbGxiYWNrc0J5U2VydmVyU3Vic2NyaXB0aW9uSWRbc3Vic2NyaXB0aW9uLnNlcnZlclN1YnNjcmlwdGlvbklkXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGF3YWl0IHRoaXMuX3VwZGF0ZVN1YnNjcmlwdGlvbnMoKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgYXdhaXQgKGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHtcbiAgICAgICAgICAgICAgYXJncyxcbiAgICAgICAgICAgICAgbWV0aG9kXG4gICAgICAgICAgICB9ID0gc3Vic2NyaXB0aW9uO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgdGhpcy5fc2V0U3Vic2NyaXB0aW9uKGhhc2gsIHtcbiAgICAgICAgICAgICAgICAuLi5zdWJzY3JpcHRpb24sXG4gICAgICAgICAgICAgICAgc3RhdGU6ICdzdWJzY3JpYmluZydcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIGNvbnN0IHNlcnZlclN1YnNjcmlwdGlvbklkID0gYXdhaXQgdGhpcy5fcnBjV2ViU29ja2V0LmNhbGwobWV0aG9kLCBhcmdzKTtcbiAgICAgICAgICAgICAgdGhpcy5fc2V0U3Vic2NyaXB0aW9uKGhhc2gsIHtcbiAgICAgICAgICAgICAgICAuLi5zdWJzY3JpcHRpb24sXG4gICAgICAgICAgICAgICAgc2VydmVyU3Vic2NyaXB0aW9uSWQsXG4gICAgICAgICAgICAgICAgc3RhdGU6ICdzdWJzY3JpYmVkJ1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgdGhpcy5fc3Vic2NyaXB0aW9uQ2FsbGJhY2tzQnlTZXJ2ZXJTdWJzY3JpcHRpb25JZFtzZXJ2ZXJTdWJzY3JpcHRpb25JZF0gPSBzdWJzY3JpcHRpb24uY2FsbGJhY2tzO1xuICAgICAgICAgICAgICBhd2FpdCB0aGlzLl91cGRhdGVTdWJzY3JpcHRpb25zKCk7XG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgIGlmIChlIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKGAke21ldGhvZH0gZXJyb3IgZm9yIGFyZ3VtZW50YCwgYXJncywgZS5tZXNzYWdlKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAoIWlzQ3VycmVudENvbm5lY3Rpb25TdGlsbEFjdGl2ZSgpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIC8vIFRPRE86IE1heWJlIGFkZCBhbiAnZXJyb3JlZCcgc3RhdGUgb3IgYSByZXRyeSBsaW1pdD9cbiAgICAgICAgICAgICAgdGhpcy5fc2V0U3Vic2NyaXB0aW9uKGhhc2gsIHtcbiAgICAgICAgICAgICAgICAuLi5zdWJzY3JpcHRpb24sXG4gICAgICAgICAgICAgICAgc3RhdGU6ICdwZW5kaW5nJ1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgYXdhaXQgdGhpcy5fdXBkYXRlU3Vic2NyaXB0aW9ucygpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pKCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ3N1YnNjcmliZWQnOlxuICAgICAgICAgIGlmIChzdWJzY3JpcHRpb24uY2FsbGJhY2tzLnNpemUgPT09IDApIHtcbiAgICAgICAgICAgIC8vIEJ5IHRoZSB0aW1lIHdlIHN1Y2Nlc3NmdWxseSBzZXQgdXAgYSBzdWJzY3JpcHRpb25cbiAgICAgICAgICAgIC8vIHdpdGggdGhlIHNlcnZlciwgdGhlIGNsaWVudCBzdG9wcGVkIGNhcmluZyBhYm91dCBpdC5cbiAgICAgICAgICAgIC8vIFRlYXIgaXQgZG93biBub3cuXG4gICAgICAgICAgICBhd2FpdCAoYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgICBjb25zdCB7XG4gICAgICAgICAgICAgICAgc2VydmVyU3Vic2NyaXB0aW9uSWQsXG4gICAgICAgICAgICAgICAgdW5zdWJzY3JpYmVNZXRob2RcbiAgICAgICAgICAgICAgfSA9IHN1YnNjcmlwdGlvbjtcbiAgICAgICAgICAgICAgaWYgKHRoaXMuX3N1YnNjcmlwdGlvbnNBdXRvRGlzcG9zZWRCeVJwYy5oYXMoc2VydmVyU3Vic2NyaXB0aW9uSWQpKSB7XG4gICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICogU3BlY2lhbCBjYXNlLlxuICAgICAgICAgICAgICAgICAqIElmIHdlJ3JlIGRlYWxpbmcgd2l0aCBhIHN1YnNjcmlwdGlvbiB0aGF0IGhhcyBiZWVuIGF1dG8tXG4gICAgICAgICAgICAgICAgICogZGlzcG9zZWQgYnkgdGhlIFJQQywgdGhlbiB3ZSBjYW4gc2tpcCB0aGUgUlBDIGNhbGwgdG9cbiAgICAgICAgICAgICAgICAgKiB0ZWFyIGRvd24gdGhlIHN1YnNjcmlwdGlvbiBoZXJlLlxuICAgICAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgICAgICogTk9URTogVGhlcmUgaXMgYSBwcm9wb3NhbCB0byBlbGltaW5hdGUgdGhpcyBzcGVjaWFsIGNhc2UsIGhlcmU6XG4gICAgICAgICAgICAgICAgICogaHR0cHM6Ly9naXRodWIuY29tL3NvbGFuYS1sYWJzL3NvbGFuYS9pc3N1ZXMvMTg4OTJcbiAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICB0aGlzLl9zdWJzY3JpcHRpb25zQXV0b0Rpc3Bvc2VkQnlScGMuZGVsZXRlKHNlcnZlclN1YnNjcmlwdGlvbklkKTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9zZXRTdWJzY3JpcHRpb24oaGFzaCwge1xuICAgICAgICAgICAgICAgICAgLi4uc3Vic2NyaXB0aW9uLFxuICAgICAgICAgICAgICAgICAgc3RhdGU6ICd1bnN1YnNjcmliaW5nJ1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHRoaXMuX3NldFN1YnNjcmlwdGlvbihoYXNoLCB7XG4gICAgICAgICAgICAgICAgICAuLi5zdWJzY3JpcHRpb24sXG4gICAgICAgICAgICAgICAgICBzdGF0ZTogJ3Vuc3Vic2NyaWJpbmcnXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMuX3JwY1dlYlNvY2tldC5jYWxsKHVuc3Vic2NyaWJlTWV0aG9kLCBbc2VydmVyU3Vic2NyaXB0aW9uSWRdKTtcbiAgICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICBpZiAoZSBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoYCR7dW5zdWJzY3JpYmVNZXRob2R9IGVycm9yOmAsIGUubWVzc2FnZSk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBpZiAoIWlzQ3VycmVudENvbm5lY3Rpb25TdGlsbEFjdGl2ZSgpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIC8vIFRPRE86IE1heWJlIGFkZCBhbiAnZXJyb3JlZCcgc3RhdGUgb3IgYSByZXRyeSBsaW1pdD9cbiAgICAgICAgICAgICAgICAgIHRoaXMuX3NldFN1YnNjcmlwdGlvbihoYXNoLCB7XG4gICAgICAgICAgICAgICAgICAgIC4uLnN1YnNjcmlwdGlvbixcbiAgICAgICAgICAgICAgICAgICAgc3RhdGU6ICdzdWJzY3JpYmVkJ1xuICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLl91cGRhdGVTdWJzY3JpcHRpb25zKCk7XG4gICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHRoaXMuX3NldFN1YnNjcmlwdGlvbihoYXNoLCB7XG4gICAgICAgICAgICAgICAgLi4uc3Vic2NyaXB0aW9uLFxuICAgICAgICAgICAgICAgIHN0YXRlOiAndW5zdWJzY3JpYmVkJ1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgYXdhaXQgdGhpcy5fdXBkYXRlU3Vic2NyaXB0aW9ucygpO1xuICAgICAgICAgICAgfSkoKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfSkpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgX2hhbmRsZVNlcnZlck5vdGlmaWNhdGlvbihzZXJ2ZXJTdWJzY3JpcHRpb25JZCwgY2FsbGJhY2tBcmdzKSB7XG4gICAgY29uc3QgY2FsbGJhY2tzID0gdGhpcy5fc3Vic2NyaXB0aW9uQ2FsbGJhY2tzQnlTZXJ2ZXJTdWJzY3JpcHRpb25JZFtzZXJ2ZXJTdWJzY3JpcHRpb25JZF07XG4gICAgaWYgKGNhbGxiYWNrcyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNhbGxiYWNrcy5mb3JFYWNoKGNiID0+IHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGNiKFxuICAgICAgICAvLyBJIGZhaWxlZCB0byBmaW5kIGEgd2F5IHRvIGNvbnZpbmNlIFR5cGVTY3JpcHQgdGhhdCBgY2JgIGlzIG9mIHR5cGVcbiAgICAgICAgLy8gYFRDYWxsYmFja2Agd2hpY2ggaXMgY2VydGFpbmx5IGNvbXBhdGlibGUgd2l0aCBgUGFyYW1ldGVyczxUQ2FsbGJhY2s+YC5cbiAgICAgICAgLy8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9taWNyb3NvZnQvVHlwZVNjcmlwdC9pc3N1ZXMvNDc2MTVcbiAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICAuLi5jYWxsYmFja0FyZ3MpO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBjb25zb2xlLmVycm9yKGUpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgX3dzT25BY2NvdW50Tm90aWZpY2F0aW9uKG5vdGlmaWNhdGlvbikge1xuICAgIGNvbnN0IHtcbiAgICAgIHJlc3VsdCxcbiAgICAgIHN1YnNjcmlwdGlvblxuICAgIH0gPSBjcmVhdGUobm90aWZpY2F0aW9uLCBBY2NvdW50Tm90aWZpY2F0aW9uUmVzdWx0KTtcbiAgICB0aGlzLl9oYW5kbGVTZXJ2ZXJOb3RpZmljYXRpb24oc3Vic2NyaXB0aW9uLCBbcmVzdWx0LnZhbHVlLCByZXN1bHQuY29udGV4dF0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgX21ha2VTdWJzY3JpcHRpb24oc3Vic2NyaXB0aW9uQ29uZmlnLFxuICAvKipcbiAgICogV2hlbiBwcmVwYXJpbmcgYGFyZ3NgIGZvciBhIGNhbGwgdG8gYF9tYWtlU3Vic2NyaXB0aW9uYCwgYmUgc3VyZVxuICAgKiB0byBjYXJlZnVsbHkgYXBwbHkgYSBkZWZhdWx0IGBjb21taXRtZW50YCBwcm9wZXJ0eSwgaWYgbmVjZXNzYXJ5LlxuICAgKlxuICAgKiAtIElmIHRoZSB1c2VyIHN1cHBsaWVkIGEgYGNvbW1pdG1lbnRgIHVzZSB0aGF0LlxuICAgKiAtIE90aGVyd2lzZSwgaWYgdGhlIGBDb25uZWN0aW9uOjpjb21taXRtZW50YCBpcyBzZXQsIHVzZSB0aGF0LlxuICAgKiAtIE90aGVyd2lzZSwgc2V0IGl0IHRvIHRoZSBSUEMgc2VydmVyIGRlZmF1bHQ6IGBmaW5hbGl6ZWRgLlxuICAgKlxuICAgKiBUaGlzIGlzIGV4dHJlbWVseSBpbXBvcnRhbnQgdG8gZW5zdXJlIHRoYXQgdGhlc2UgdHdvIGZ1bmRhbWVudGFsbHlcbiAgICogaWRlbnRpY2FsIHN1YnNjcmlwdGlvbnMgcHJvZHVjZSB0aGUgc2FtZSBpZGVudGlmeWluZyBoYXNoOlxuICAgKlxuICAgKiAtIEEgc3Vic2NyaXB0aW9uIG1hZGUgd2l0aG91dCBzcGVjaWZ5aW5nIGEgY29tbWl0bWVudC5cbiAgICogLSBBIHN1YnNjcmlwdGlvbiBtYWRlIHdoZXJlIHRoZSBjb21taXRtZW50IHNwZWNpZmllZCBpcyB0aGUgc2FtZVxuICAgKiAgIGFzIHRoZSBkZWZhdWx0IGFwcGxpZWQgdG8gdGhlIHN1YnNjcmlwdGlvbiBhYm92ZS5cbiAgICpcbiAgICogRXhhbXBsZTsgdGhlc2UgdHdvIHN1YnNjcmlwdGlvbnMgbXVzdCBwcm9kdWNlIHRoZSBzYW1lIGhhc2g6XG4gICAqXG4gICAqIC0gQW4gYGFjY291bnRTdWJzY3JpYmVgIHN1YnNjcmlwdGlvbiBmb3IgYCdQVUJLRVknYFxuICAgKiAtIEFuIGBhY2NvdW50U3Vic2NyaWJlYCBzdWJzY3JpcHRpb24gZm9yIGAnUFVCS0VZJ2Agd2l0aCBjb21taXRtZW50XG4gICAqICAgYCdmaW5hbGl6ZWQnYC5cbiAgICpcbiAgICogU2VlIHRoZSAnbWFraW5nIGEgc3Vic2NyaXB0aW9uIHdpdGggZGVmYXVsdGVkIHBhcmFtcyBvbWl0dGVkJyB0ZXN0XG4gICAqIGluIGBjb25uZWN0aW9uLXN1YnNjcmlwdGlvbnMudHNgIGZvciBtb3JlLlxuICAgKi9cbiAgYXJncykge1xuICAgIGNvbnN0IGNsaWVudFN1YnNjcmlwdGlvbklkID0gdGhpcy5fbmV4dENsaWVudFN1YnNjcmlwdGlvbklkKys7XG4gICAgY29uc3QgaGFzaCA9IGZhc3RTdGFibGVTdHJpbmdpZnkkMShbc3Vic2NyaXB0aW9uQ29uZmlnLm1ldGhvZCwgYXJnc10pO1xuICAgIGNvbnN0IGV4aXN0aW5nU3Vic2NyaXB0aW9uID0gdGhpcy5fc3Vic2NyaXB0aW9uc0J5SGFzaFtoYXNoXTtcbiAgICBpZiAoZXhpc3RpbmdTdWJzY3JpcHRpb24gPT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhpcy5fc3Vic2NyaXB0aW9uc0J5SGFzaFtoYXNoXSA9IHtcbiAgICAgICAgLi4uc3Vic2NyaXB0aW9uQ29uZmlnLFxuICAgICAgICBhcmdzLFxuICAgICAgICBjYWxsYmFja3M6IG5ldyBTZXQoW3N1YnNjcmlwdGlvbkNvbmZpZy5jYWxsYmFja10pLFxuICAgICAgICBzdGF0ZTogJ3BlbmRpbmcnXG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICBleGlzdGluZ1N1YnNjcmlwdGlvbi5jYWxsYmFja3MuYWRkKHN1YnNjcmlwdGlvbkNvbmZpZy5jYWxsYmFjayk7XG4gICAgfVxuICAgIHRoaXMuX3N1YnNjcmlwdGlvbkhhc2hCeUNsaWVudFN1YnNjcmlwdGlvbklkW2NsaWVudFN1YnNjcmlwdGlvbklkXSA9IGhhc2g7XG4gICAgdGhpcy5fc3Vic2NyaXB0aW9uRGlzcG9zZUZ1bmN0aW9uc0J5Q2xpZW50U3Vic2NyaXB0aW9uSWRbY2xpZW50U3Vic2NyaXB0aW9uSWRdID0gYXN5bmMgKCkgPT4ge1xuICAgICAgZGVsZXRlIHRoaXMuX3N1YnNjcmlwdGlvbkRpc3Bvc2VGdW5jdGlvbnNCeUNsaWVudFN1YnNjcmlwdGlvbklkW2NsaWVudFN1YnNjcmlwdGlvbklkXTtcbiAgICAgIGRlbGV0ZSB0aGlzLl9zdWJzY3JpcHRpb25IYXNoQnlDbGllbnRTdWJzY3JpcHRpb25JZFtjbGllbnRTdWJzY3JpcHRpb25JZF07XG4gICAgICBjb25zdCBzdWJzY3JpcHRpb24gPSB0aGlzLl9zdWJzY3JpcHRpb25zQnlIYXNoW2hhc2hdO1xuICAgICAgYXNzZXJ0KHN1YnNjcmlwdGlvbiAhPT0gdW5kZWZpbmVkLCBgQ291bGQgbm90IGZpbmQgYSBcXGBTdWJzY3JpcHRpb25cXGAgd2hlbiB0ZWFyaW5nIGRvd24gY2xpZW50IHN1YnNjcmlwdGlvbiAjJHtjbGllbnRTdWJzY3JpcHRpb25JZH1gKTtcbiAgICAgIHN1YnNjcmlwdGlvbi5jYWxsYmFja3MuZGVsZXRlKHN1YnNjcmlwdGlvbkNvbmZpZy5jYWxsYmFjayk7XG4gICAgICBhd2FpdCB0aGlzLl91cGRhdGVTdWJzY3JpcHRpb25zKCk7XG4gICAgfTtcbiAgICB0aGlzLl91cGRhdGVTdWJzY3JpcHRpb25zKCk7XG4gICAgcmV0dXJuIGNsaWVudFN1YnNjcmlwdGlvbklkO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlZ2lzdGVyIGEgY2FsbGJhY2sgdG8gYmUgaW52b2tlZCB3aGVuZXZlciB0aGUgc3BlY2lmaWVkIGFjY291bnQgY2hhbmdlc1xuICAgKlxuICAgKiBAcGFyYW0gcHVibGljS2V5IFB1YmxpYyBrZXkgb2YgdGhlIGFjY291bnQgdG8gbW9uaXRvclxuICAgKiBAcGFyYW0gY2FsbGJhY2sgRnVuY3Rpb24gdG8gaW52b2tlIHdoZW5ldmVyIHRoZSBhY2NvdW50IGlzIGNoYW5nZWRcbiAgICogQHBhcmFtIGNvbW1pdG1lbnQgU3BlY2lmeSB0aGUgY29tbWl0bWVudCBsZXZlbCBhY2NvdW50IGNoYW5nZXMgbXVzdCByZWFjaCBiZWZvcmUgbm90aWZpY2F0aW9uXG4gICAqIEByZXR1cm4gc3Vic2NyaXB0aW9uIGlkXG4gICAqL1xuICBvbkFjY291bnRDaGFuZ2UocHVibGljS2V5LCBjYWxsYmFjaywgY29tbWl0bWVudCkge1xuICAgIGNvbnN0IGFyZ3MgPSB0aGlzLl9idWlsZEFyZ3MoW3B1YmxpY0tleS50b0Jhc2U1OCgpXSwgY29tbWl0bWVudCB8fCB0aGlzLl9jb21taXRtZW50IHx8ICdmaW5hbGl6ZWQnLFxuICAgIC8vIEFwcGx5IGNvbm5lY3Rpb24vc2VydmVyIGRlZmF1bHQuXG4gICAgJ2Jhc2U2NCcpO1xuICAgIHJldHVybiB0aGlzLl9tYWtlU3Vic2NyaXB0aW9uKHtcbiAgICAgIGNhbGxiYWNrLFxuICAgICAgbWV0aG9kOiAnYWNjb3VudFN1YnNjcmliZScsXG4gICAgICB1bnN1YnNjcmliZU1ldGhvZDogJ2FjY291bnRVbnN1YnNjcmliZSdcbiAgICB9LCBhcmdzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZXJlZ2lzdGVyIGFuIGFjY291bnQgbm90aWZpY2F0aW9uIGNhbGxiYWNrXG4gICAqXG4gICAqIEBwYXJhbSBjbGllbnRTdWJzY3JpcHRpb25JZCBjbGllbnQgc3Vic2NyaXB0aW9uIGlkIHRvIGRlcmVnaXN0ZXJcbiAgICovXG4gIGFzeW5jIHJlbW92ZUFjY291bnRDaGFuZ2VMaXN0ZW5lcihjbGllbnRTdWJzY3JpcHRpb25JZCkge1xuICAgIGF3YWl0IHRoaXMuX3Vuc3Vic2NyaWJlQ2xpZW50U3Vic2NyaXB0aW9uKGNsaWVudFN1YnNjcmlwdGlvbklkLCAnYWNjb3VudCBjaGFuZ2UnKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIF93c09uUHJvZ3JhbUFjY291bnROb3RpZmljYXRpb24obm90aWZpY2F0aW9uKSB7XG4gICAgY29uc3Qge1xuICAgICAgcmVzdWx0LFxuICAgICAgc3Vic2NyaXB0aW9uXG4gICAgfSA9IGNyZWF0ZShub3RpZmljYXRpb24sIFByb2dyYW1BY2NvdW50Tm90aWZpY2F0aW9uUmVzdWx0KTtcbiAgICB0aGlzLl9oYW5kbGVTZXJ2ZXJOb3RpZmljYXRpb24oc3Vic2NyaXB0aW9uLCBbe1xuICAgICAgYWNjb3VudElkOiByZXN1bHQudmFsdWUucHVia2V5LFxuICAgICAgYWNjb3VudEluZm86IHJlc3VsdC52YWx1ZS5hY2NvdW50XG4gICAgfSwgcmVzdWx0LmNvbnRleHRdKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZWdpc3RlciBhIGNhbGxiYWNrIHRvIGJlIGludm9rZWQgd2hlbmV2ZXIgYWNjb3VudHMgb3duZWQgYnkgdGhlXG4gICAqIHNwZWNpZmllZCBwcm9ncmFtIGNoYW5nZVxuICAgKlxuICAgKiBAcGFyYW0gcHJvZ3JhbUlkIFB1YmxpYyBrZXkgb2YgdGhlIHByb2dyYW0gdG8gbW9uaXRvclxuICAgKiBAcGFyYW0gY2FsbGJhY2sgRnVuY3Rpb24gdG8gaW52b2tlIHdoZW5ldmVyIHRoZSBhY2NvdW50IGlzIGNoYW5nZWRcbiAgICogQHBhcmFtIGNvbW1pdG1lbnQgU3BlY2lmeSB0aGUgY29tbWl0bWVudCBsZXZlbCBhY2NvdW50IGNoYW5nZXMgbXVzdCByZWFjaCBiZWZvcmUgbm90aWZpY2F0aW9uXG4gICAqIEBwYXJhbSBmaWx0ZXJzIFRoZSBwcm9ncmFtIGFjY291bnQgZmlsdGVycyB0byBwYXNzIGludG8gdGhlIFJQQyBtZXRob2RcbiAgICogQHJldHVybiBzdWJzY3JpcHRpb24gaWRcbiAgICovXG4gIG9uUHJvZ3JhbUFjY291bnRDaGFuZ2UocHJvZ3JhbUlkLCBjYWxsYmFjaywgY29tbWl0bWVudCwgZmlsdGVycykge1xuICAgIGNvbnN0IGFyZ3MgPSB0aGlzLl9idWlsZEFyZ3MoW3Byb2dyYW1JZC50b0Jhc2U1OCgpXSwgY29tbWl0bWVudCB8fCB0aGlzLl9jb21taXRtZW50IHx8ICdmaW5hbGl6ZWQnLFxuICAgIC8vIEFwcGx5IGNvbm5lY3Rpb24vc2VydmVyIGRlZmF1bHQuXG4gICAgJ2Jhc2U2NCcgLyogZW5jb2RpbmcgKi8sIGZpbHRlcnMgPyB7XG4gICAgICBmaWx0ZXJzOiBmaWx0ZXJzXG4gICAgfSA6IHVuZGVmaW5lZCAvKiBleHRyYSAqLyk7XG4gICAgcmV0dXJuIHRoaXMuX21ha2VTdWJzY3JpcHRpb24oe1xuICAgICAgY2FsbGJhY2ssXG4gICAgICBtZXRob2Q6ICdwcm9ncmFtU3Vic2NyaWJlJyxcbiAgICAgIHVuc3Vic2NyaWJlTWV0aG9kOiAncHJvZ3JhbVVuc3Vic2NyaWJlJ1xuICAgIH0sIGFyZ3MpO1xuICB9XG5cbiAgLyoqXG4gICAqIERlcmVnaXN0ZXIgYW4gYWNjb3VudCBub3RpZmljYXRpb24gY2FsbGJhY2tcbiAgICpcbiAgICogQHBhcmFtIGNsaWVudFN1YnNjcmlwdGlvbklkIGNsaWVudCBzdWJzY3JpcHRpb24gaWQgdG8gZGVyZWdpc3RlclxuICAgKi9cbiAgYXN5bmMgcmVtb3ZlUHJvZ3JhbUFjY291bnRDaGFuZ2VMaXN0ZW5lcihjbGllbnRTdWJzY3JpcHRpb25JZCkge1xuICAgIGF3YWl0IHRoaXMuX3Vuc3Vic2NyaWJlQ2xpZW50U3Vic2NyaXB0aW9uKGNsaWVudFN1YnNjcmlwdGlvbklkLCAncHJvZ3JhbSBhY2NvdW50IGNoYW5nZScpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlZ2lzdGVycyBhIGNhbGxiYWNrIHRvIGJlIGludm9rZWQgd2hlbmV2ZXIgbG9ncyBhcmUgZW1pdHRlZC5cbiAgICovXG4gIG9uTG9ncyhmaWx0ZXIsIGNhbGxiYWNrLCBjb21taXRtZW50KSB7XG4gICAgY29uc3QgYXJncyA9IHRoaXMuX2J1aWxkQXJncyhbdHlwZW9mIGZpbHRlciA9PT0gJ29iamVjdCcgPyB7XG4gICAgICBtZW50aW9uczogW2ZpbHRlci50b1N0cmluZygpXVxuICAgIH0gOiBmaWx0ZXJdLCBjb21taXRtZW50IHx8IHRoaXMuX2NvbW1pdG1lbnQgfHwgJ2ZpbmFsaXplZCcgLy8gQXBwbHkgY29ubmVjdGlvbi9zZXJ2ZXIgZGVmYXVsdC5cbiAgICApO1xuICAgIHJldHVybiB0aGlzLl9tYWtlU3Vic2NyaXB0aW9uKHtcbiAgICAgIGNhbGxiYWNrLFxuICAgICAgbWV0aG9kOiAnbG9nc1N1YnNjcmliZScsXG4gICAgICB1bnN1YnNjcmliZU1ldGhvZDogJ2xvZ3NVbnN1YnNjcmliZSdcbiAgICB9LCBhcmdzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZXJlZ2lzdGVyIGEgbG9ncyBjYWxsYmFjay5cbiAgICpcbiAgICogQHBhcmFtIGNsaWVudFN1YnNjcmlwdGlvbklkIGNsaWVudCBzdWJzY3JpcHRpb24gaWQgdG8gZGVyZWdpc3Rlci5cbiAgICovXG4gIGFzeW5jIHJlbW92ZU9uTG9nc0xpc3RlbmVyKGNsaWVudFN1YnNjcmlwdGlvbklkKSB7XG4gICAgYXdhaXQgdGhpcy5fdW5zdWJzY3JpYmVDbGllbnRTdWJzY3JpcHRpb24oY2xpZW50U3Vic2NyaXB0aW9uSWQsICdsb2dzJyk7XG4gIH1cblxuICAvKipcbiAgICogQGludGVybmFsXG4gICAqL1xuICBfd3NPbkxvZ3NOb3RpZmljYXRpb24obm90aWZpY2F0aW9uKSB7XG4gICAgY29uc3Qge1xuICAgICAgcmVzdWx0LFxuICAgICAgc3Vic2NyaXB0aW9uXG4gICAgfSA9IGNyZWF0ZShub3RpZmljYXRpb24sIExvZ3NOb3RpZmljYXRpb25SZXN1bHQpO1xuICAgIHRoaXMuX2hhbmRsZVNlcnZlck5vdGlmaWNhdGlvbihzdWJzY3JpcHRpb24sIFtyZXN1bHQudmFsdWUsIHJlc3VsdC5jb250ZXh0XSk7XG4gIH1cblxuICAvKipcbiAgICogQGludGVybmFsXG4gICAqL1xuICBfd3NPblNsb3ROb3RpZmljYXRpb24obm90aWZpY2F0aW9uKSB7XG4gICAgY29uc3Qge1xuICAgICAgcmVzdWx0LFxuICAgICAgc3Vic2NyaXB0aW9uXG4gICAgfSA9IGNyZWF0ZShub3RpZmljYXRpb24sIFNsb3ROb3RpZmljYXRpb25SZXN1bHQpO1xuICAgIHRoaXMuX2hhbmRsZVNlcnZlck5vdGlmaWNhdGlvbihzdWJzY3JpcHRpb24sIFtyZXN1bHRdKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZWdpc3RlciBhIGNhbGxiYWNrIHRvIGJlIGludm9rZWQgdXBvbiBzbG90IGNoYW5nZXNcbiAgICpcbiAgICogQHBhcmFtIGNhbGxiYWNrIEZ1bmN0aW9uIHRvIGludm9rZSB3aGVuZXZlciB0aGUgc2xvdCBjaGFuZ2VzXG4gICAqIEByZXR1cm4gc3Vic2NyaXB0aW9uIGlkXG4gICAqL1xuICBvblNsb3RDaGFuZ2UoY2FsbGJhY2spIHtcbiAgICByZXR1cm4gdGhpcy5fbWFrZVN1YnNjcmlwdGlvbih7XG4gICAgICBjYWxsYmFjayxcbiAgICAgIG1ldGhvZDogJ3Nsb3RTdWJzY3JpYmUnLFxuICAgICAgdW5zdWJzY3JpYmVNZXRob2Q6ICdzbG90VW5zdWJzY3JpYmUnXG4gICAgfSwgW10gLyogYXJncyAqLyk7XG4gIH1cblxuICAvKipcbiAgICogRGVyZWdpc3RlciBhIHNsb3Qgbm90aWZpY2F0aW9uIGNhbGxiYWNrXG4gICAqXG4gICAqIEBwYXJhbSBjbGllbnRTdWJzY3JpcHRpb25JZCBjbGllbnQgc3Vic2NyaXB0aW9uIGlkIHRvIGRlcmVnaXN0ZXJcbiAgICovXG4gIGFzeW5jIHJlbW92ZVNsb3RDaGFuZ2VMaXN0ZW5lcihjbGllbnRTdWJzY3JpcHRpb25JZCkge1xuICAgIGF3YWl0IHRoaXMuX3Vuc3Vic2NyaWJlQ2xpZW50U3Vic2NyaXB0aW9uKGNsaWVudFN1YnNjcmlwdGlvbklkLCAnc2xvdCBjaGFuZ2UnKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIF93c09uU2xvdFVwZGF0ZXNOb3RpZmljYXRpb24obm90aWZpY2F0aW9uKSB7XG4gICAgY29uc3Qge1xuICAgICAgcmVzdWx0LFxuICAgICAgc3Vic2NyaXB0aW9uXG4gICAgfSA9IGNyZWF0ZShub3RpZmljYXRpb24sIFNsb3RVcGRhdGVOb3RpZmljYXRpb25SZXN1bHQpO1xuICAgIHRoaXMuX2hhbmRsZVNlcnZlck5vdGlmaWNhdGlvbihzdWJzY3JpcHRpb24sIFtyZXN1bHRdKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZWdpc3RlciBhIGNhbGxiYWNrIHRvIGJlIGludm9rZWQgdXBvbiBzbG90IHVwZGF0ZXMuIHtAbGluayBTbG90VXBkYXRlfSdzXG4gICAqIG1heSBiZSB1c2VmdWwgdG8gdHJhY2sgbGl2ZSBwcm9ncmVzcyBvZiBhIGNsdXN0ZXIuXG4gICAqXG4gICAqIEBwYXJhbSBjYWxsYmFjayBGdW5jdGlvbiB0byBpbnZva2Ugd2hlbmV2ZXIgdGhlIHNsb3QgdXBkYXRlc1xuICAgKiBAcmV0dXJuIHN1YnNjcmlwdGlvbiBpZFxuICAgKi9cbiAgb25TbG90VXBkYXRlKGNhbGxiYWNrKSB7XG4gICAgcmV0dXJuIHRoaXMuX21ha2VTdWJzY3JpcHRpb24oe1xuICAgICAgY2FsbGJhY2ssXG4gICAgICBtZXRob2Q6ICdzbG90c1VwZGF0ZXNTdWJzY3JpYmUnLFxuICAgICAgdW5zdWJzY3JpYmVNZXRob2Q6ICdzbG90c1VwZGF0ZXNVbnN1YnNjcmliZSdcbiAgICB9LCBbXSAvKiBhcmdzICovKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZXJlZ2lzdGVyIGEgc2xvdCB1cGRhdGUgbm90aWZpY2F0aW9uIGNhbGxiYWNrXG4gICAqXG4gICAqIEBwYXJhbSBjbGllbnRTdWJzY3JpcHRpb25JZCBjbGllbnQgc3Vic2NyaXB0aW9uIGlkIHRvIGRlcmVnaXN0ZXJcbiAgICovXG4gIGFzeW5jIHJlbW92ZVNsb3RVcGRhdGVMaXN0ZW5lcihjbGllbnRTdWJzY3JpcHRpb25JZCkge1xuICAgIGF3YWl0IHRoaXMuX3Vuc3Vic2NyaWJlQ2xpZW50U3Vic2NyaXB0aW9uKGNsaWVudFN1YnNjcmlwdGlvbklkLCAnc2xvdCB1cGRhdGUnKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG5cbiAgYXN5bmMgX3Vuc3Vic2NyaWJlQ2xpZW50U3Vic2NyaXB0aW9uKGNsaWVudFN1YnNjcmlwdGlvbklkLCBzdWJzY3JpcHRpb25OYW1lKSB7XG4gICAgY29uc3QgZGlzcG9zZSA9IHRoaXMuX3N1YnNjcmlwdGlvbkRpc3Bvc2VGdW5jdGlvbnNCeUNsaWVudFN1YnNjcmlwdGlvbklkW2NsaWVudFN1YnNjcmlwdGlvbklkXTtcbiAgICBpZiAoZGlzcG9zZSkge1xuICAgICAgYXdhaXQgZGlzcG9zZSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zb2xlLndhcm4oJ0lnbm9yZWQgdW5zdWJzY3JpYmUgcmVxdWVzdCBiZWNhdXNlIGFuIGFjdGl2ZSBzdWJzY3JpcHRpb24gd2l0aCBpZCAnICsgYFxcYCR7Y2xpZW50U3Vic2NyaXB0aW9uSWR9XFxgIGZvciAnJHtzdWJzY3JpcHRpb25OYW1lfScgZXZlbnRzIGAgKyAnY291bGQgbm90IGJlIGZvdW5kLicpO1xuICAgIH1cbiAgfVxuICBfYnVpbGRBcmdzKGFyZ3MsIG92ZXJyaWRlLCBlbmNvZGluZywgZXh0cmEpIHtcbiAgICBjb25zdCBjb21taXRtZW50ID0gb3ZlcnJpZGUgfHwgdGhpcy5fY29tbWl0bWVudDtcbiAgICBpZiAoY29tbWl0bWVudCB8fCBlbmNvZGluZyB8fCBleHRyYSkge1xuICAgICAgbGV0IG9wdGlvbnMgPSB7fTtcbiAgICAgIGlmIChlbmNvZGluZykge1xuICAgICAgICBvcHRpb25zLmVuY29kaW5nID0gZW5jb2Rpbmc7XG4gICAgICB9XG4gICAgICBpZiAoY29tbWl0bWVudCkge1xuICAgICAgICBvcHRpb25zLmNvbW1pdG1lbnQgPSBjb21taXRtZW50O1xuICAgICAgfVxuICAgICAgaWYgKGV4dHJhKSB7XG4gICAgICAgIG9wdGlvbnMgPSBPYmplY3QuYXNzaWduKG9wdGlvbnMsIGV4dHJhKTtcbiAgICAgIH1cbiAgICAgIGFyZ3MucHVzaChvcHRpb25zKTtcbiAgICB9XG4gICAgcmV0dXJuIGFyZ3M7XG4gIH1cblxuICAvKipcbiAgICogQGludGVybmFsXG4gICAqL1xuICBfYnVpbGRBcmdzQXRMZWFzdENvbmZpcm1lZChhcmdzLCBvdmVycmlkZSwgZW5jb2RpbmcsIGV4dHJhKSB7XG4gICAgY29uc3QgY29tbWl0bWVudCA9IG92ZXJyaWRlIHx8IHRoaXMuX2NvbW1pdG1lbnQ7XG4gICAgaWYgKGNvbW1pdG1lbnQgJiYgIVsnY29uZmlybWVkJywgJ2ZpbmFsaXplZCddLmluY2x1ZGVzKGNvbW1pdG1lbnQpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1VzaW5nIENvbm5lY3Rpb24gd2l0aCBkZWZhdWx0IGNvbW1pdG1lbnQ6IGAnICsgdGhpcy5fY29tbWl0bWVudCArICdgLCBidXQgbWV0aG9kIHJlcXVpcmVzIGF0IGxlYXN0IGBjb25maXJtZWRgJyk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9idWlsZEFyZ3MoYXJncywgb3ZlcnJpZGUsIGVuY29kaW5nLCBleHRyYSk7XG4gIH1cblxuICAvKipcbiAgICogQGludGVybmFsXG4gICAqL1xuICBfd3NPblNpZ25hdHVyZU5vdGlmaWNhdGlvbihub3RpZmljYXRpb24pIHtcbiAgICBjb25zdCB7XG4gICAgICByZXN1bHQsXG4gICAgICBzdWJzY3JpcHRpb25cbiAgICB9ID0gY3JlYXRlKG5vdGlmaWNhdGlvbiwgU2lnbmF0dXJlTm90aWZpY2F0aW9uUmVzdWx0KTtcbiAgICBpZiAocmVzdWx0LnZhbHVlICE9PSAncmVjZWl2ZWRTaWduYXR1cmUnKSB7XG4gICAgICAvKipcbiAgICAgICAqIFNwZWNpYWwgY2FzZS5cbiAgICAgICAqIEFmdGVyIGEgc2lnbmF0dXJlIGlzIHByb2Nlc3NlZCwgUlBDcyBhdXRvbWF0aWNhbGx5IGRpc3Bvc2Ugb2YgdGhlXG4gICAgICAgKiBzdWJzY3JpcHRpb24gb24gdGhlIHNlcnZlciBzaWRlLiBXZSBuZWVkIHRvIHRyYWNrIHdoaWNoIG9mIHRoZXNlXG4gICAgICAgKiBzdWJzY3JpcHRpb25zIGhhdmUgYmVlbiBkaXNwb3NlZCBpbiBzdWNoIGEgd2F5LCBzbyB0aGF0IHdlIGtub3dcbiAgICAgICAqIHdoZXRoZXIgdGhlIGNsaWVudCBpcyBkZWFsaW5nIHdpdGggYSBub3QteWV0LXByb2Nlc3NlZCBzaWduYXR1cmVcbiAgICAgICAqIChpbiB3aGljaCBjYXNlIHdlIG11c3QgdGVhciBkb3duIHRoZSBzZXJ2ZXIgc3Vic2NyaXB0aW9uKSBvciBhblxuICAgICAgICogYWxyZWFkeS1wcm9jZXNzZWQgc2lnbmF0dXJlIChpbiB3aGljaCBjYXNlIHRoZSBjbGllbnQgY2FuIHNpbXBseVxuICAgICAgICogY2xlYXIgb3V0IHRoZSBzdWJzY3JpcHRpb24gbG9jYWxseSB3aXRob3V0IHRlbGxpbmcgdGhlIHNlcnZlcikuXG4gICAgICAgKlxuICAgICAgICogTk9URTogVGhlcmUgaXMgYSBwcm9wb3NhbCB0byBlbGltaW5hdGUgdGhpcyBzcGVjaWFsIGNhc2UsIGhlcmU6XG4gICAgICAgKiBodHRwczovL2dpdGh1Yi5jb20vc29sYW5hLWxhYnMvc29sYW5hL2lzc3Vlcy8xODg5MlxuICAgICAgICovXG4gICAgICB0aGlzLl9zdWJzY3JpcHRpb25zQXV0b0Rpc3Bvc2VkQnlScGMuYWRkKHN1YnNjcmlwdGlvbik7XG4gICAgfVxuICAgIHRoaXMuX2hhbmRsZVNlcnZlck5vdGlmaWNhdGlvbihzdWJzY3JpcHRpb24sIHJlc3VsdC52YWx1ZSA9PT0gJ3JlY2VpdmVkU2lnbmF0dXJlJyA/IFt7XG4gICAgICB0eXBlOiAncmVjZWl2ZWQnXG4gICAgfSwgcmVzdWx0LmNvbnRleHRdIDogW3tcbiAgICAgIHR5cGU6ICdzdGF0dXMnLFxuICAgICAgcmVzdWx0OiByZXN1bHQudmFsdWVcbiAgICB9LCByZXN1bHQuY29udGV4dF0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlZ2lzdGVyIGEgY2FsbGJhY2sgdG8gYmUgaW52b2tlZCB1cG9uIHNpZ25hdHVyZSB1cGRhdGVzXG4gICAqXG4gICAqIEBwYXJhbSBzaWduYXR1cmUgVHJhbnNhY3Rpb24gc2lnbmF0dXJlIHN0cmluZyBpbiBiYXNlIDU4XG4gICAqIEBwYXJhbSBjYWxsYmFjayBGdW5jdGlvbiB0byBpbnZva2Ugb24gc2lnbmF0dXJlIG5vdGlmaWNhdGlvbnNcbiAgICogQHBhcmFtIGNvbW1pdG1lbnQgU3BlY2lmeSB0aGUgY29tbWl0bWVudCBsZXZlbCBzaWduYXR1cmUgbXVzdCByZWFjaCBiZWZvcmUgbm90aWZpY2F0aW9uXG4gICAqIEByZXR1cm4gc3Vic2NyaXB0aW9uIGlkXG4gICAqL1xuICBvblNpZ25hdHVyZShzaWduYXR1cmUsIGNhbGxiYWNrLCBjb21taXRtZW50KSB7XG4gICAgY29uc3QgYXJncyA9IHRoaXMuX2J1aWxkQXJncyhbc2lnbmF0dXJlXSwgY29tbWl0bWVudCB8fCB0aGlzLl9jb21taXRtZW50IHx8ICdmaW5hbGl6ZWQnIC8vIEFwcGx5IGNvbm5lY3Rpb24vc2VydmVyIGRlZmF1bHQuXG4gICAgKTtcbiAgICBjb25zdCBjbGllbnRTdWJzY3JpcHRpb25JZCA9IHRoaXMuX21ha2VTdWJzY3JpcHRpb24oe1xuICAgICAgY2FsbGJhY2s6IChub3RpZmljYXRpb24sIGNvbnRleHQpID0+IHtcbiAgICAgICAgaWYgKG5vdGlmaWNhdGlvbi50eXBlID09PSAnc3RhdHVzJykge1xuICAgICAgICAgIGNhbGxiYWNrKG5vdGlmaWNhdGlvbi5yZXN1bHQsIGNvbnRleHQpO1xuICAgICAgICAgIC8vIFNpZ25hdHVyZXMgc3Vic2NyaXB0aW9ucyBhcmUgYXV0by1yZW1vdmVkIGJ5IHRoZSBSUEMgc2VydmljZVxuICAgICAgICAgIC8vIHNvIG5vIG5lZWQgdG8gZXhwbGljaXRseSBzZW5kIGFuIHVuc3Vic2NyaWJlIG1lc3NhZ2UuXG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHRoaXMucmVtb3ZlU2lnbmF0dXJlTGlzdGVuZXIoY2xpZW50U3Vic2NyaXB0aW9uSWQpO1xuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWVtcHR5XG4gICAgICAgICAgfSBjYXRjaCAoX2Vycikge1xuICAgICAgICAgICAgLy8gQWxyZWFkeSByZW1vdmVkLlxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIG1ldGhvZDogJ3NpZ25hdHVyZVN1YnNjcmliZScsXG4gICAgICB1bnN1YnNjcmliZU1ldGhvZDogJ3NpZ25hdHVyZVVuc3Vic2NyaWJlJ1xuICAgIH0sIGFyZ3MpO1xuICAgIHJldHVybiBjbGllbnRTdWJzY3JpcHRpb25JZDtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZWdpc3RlciBhIGNhbGxiYWNrIHRvIGJlIGludm9rZWQgd2hlbiBhIHRyYW5zYWN0aW9uIGlzXG4gICAqIHJlY2VpdmVkIGFuZC9vciBwcm9jZXNzZWQuXG4gICAqXG4gICAqIEBwYXJhbSBzaWduYXR1cmUgVHJhbnNhY3Rpb24gc2lnbmF0dXJlIHN0cmluZyBpbiBiYXNlIDU4XG4gICAqIEBwYXJhbSBjYWxsYmFjayBGdW5jdGlvbiB0byBpbnZva2Ugb24gc2lnbmF0dXJlIG5vdGlmaWNhdGlvbnNcbiAgICogQHBhcmFtIG9wdGlvbnMgRW5hYmxlIHJlY2VpdmVkIG5vdGlmaWNhdGlvbnMgYW5kIHNldCB0aGUgY29tbWl0bWVudFxuICAgKiAgIGxldmVsIHRoYXQgc2lnbmF0dXJlIG11c3QgcmVhY2ggYmVmb3JlIG5vdGlmaWNhdGlvblxuICAgKiBAcmV0dXJuIHN1YnNjcmlwdGlvbiBpZFxuICAgKi9cbiAgb25TaWduYXR1cmVXaXRoT3B0aW9ucyhzaWduYXR1cmUsIGNhbGxiYWNrLCBvcHRpb25zKSB7XG4gICAgY29uc3Qge1xuICAgICAgY29tbWl0bWVudCxcbiAgICAgIC4uLmV4dHJhXG4gICAgfSA9IHtcbiAgICAgIC4uLm9wdGlvbnMsXG4gICAgICBjb21taXRtZW50OiBvcHRpb25zICYmIG9wdGlvbnMuY29tbWl0bWVudCB8fCB0aGlzLl9jb21taXRtZW50IHx8ICdmaW5hbGl6ZWQnIC8vIEFwcGx5IGNvbm5lY3Rpb24vc2VydmVyIGRlZmF1bHQuXG4gICAgfTtcbiAgICBjb25zdCBhcmdzID0gdGhpcy5fYnVpbGRBcmdzKFtzaWduYXR1cmVdLCBjb21taXRtZW50LCB1bmRlZmluZWQgLyogZW5jb2RpbmcgKi8sIGV4dHJhKTtcbiAgICBjb25zdCBjbGllbnRTdWJzY3JpcHRpb25JZCA9IHRoaXMuX21ha2VTdWJzY3JpcHRpb24oe1xuICAgICAgY2FsbGJhY2s6IChub3RpZmljYXRpb24sIGNvbnRleHQpID0+IHtcbiAgICAgICAgY2FsbGJhY2sobm90aWZpY2F0aW9uLCBjb250ZXh0KTtcbiAgICAgICAgLy8gU2lnbmF0dXJlcyBzdWJzY3JpcHRpb25zIGFyZSBhdXRvLXJlbW92ZWQgYnkgdGhlIFJQQyBzZXJ2aWNlXG4gICAgICAgIC8vIHNvIG5vIG5lZWQgdG8gZXhwbGljaXRseSBzZW5kIGFuIHVuc3Vic2NyaWJlIG1lc3NhZ2UuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgdGhpcy5yZW1vdmVTaWduYXR1cmVMaXN0ZW5lcihjbGllbnRTdWJzY3JpcHRpb25JZCk7XG4gICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWVtcHR5XG4gICAgICAgIH0gY2F0Y2ggKF9lcnIpIHtcbiAgICAgICAgICAvLyBBbHJlYWR5IHJlbW92ZWQuXG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBtZXRob2Q6ICdzaWduYXR1cmVTdWJzY3JpYmUnLFxuICAgICAgdW5zdWJzY3JpYmVNZXRob2Q6ICdzaWduYXR1cmVVbnN1YnNjcmliZSdcbiAgICB9LCBhcmdzKTtcbiAgICByZXR1cm4gY2xpZW50U3Vic2NyaXB0aW9uSWQ7XG4gIH1cblxuICAvKipcbiAgICogRGVyZWdpc3RlciBhIHNpZ25hdHVyZSBub3RpZmljYXRpb24gY2FsbGJhY2tcbiAgICpcbiAgICogQHBhcmFtIGNsaWVudFN1YnNjcmlwdGlvbklkIGNsaWVudCBzdWJzY3JpcHRpb24gaWQgdG8gZGVyZWdpc3RlclxuICAgKi9cbiAgYXN5bmMgcmVtb3ZlU2lnbmF0dXJlTGlzdGVuZXIoY2xpZW50U3Vic2NyaXB0aW9uSWQpIHtcbiAgICBhd2FpdCB0aGlzLl91bnN1YnNjcmliZUNsaWVudFN1YnNjcmlwdGlvbihjbGllbnRTdWJzY3JpcHRpb25JZCwgJ3NpZ25hdHVyZSByZXN1bHQnKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIF93c09uUm9vdE5vdGlmaWNhdGlvbihub3RpZmljYXRpb24pIHtcbiAgICBjb25zdCB7XG4gICAgICByZXN1bHQsXG4gICAgICBzdWJzY3JpcHRpb25cbiAgICB9ID0gY3JlYXRlKG5vdGlmaWNhdGlvbiwgUm9vdE5vdGlmaWNhdGlvblJlc3VsdCk7XG4gICAgdGhpcy5faGFuZGxlU2VydmVyTm90aWZpY2F0aW9uKHN1YnNjcmlwdGlvbiwgW3Jlc3VsdF0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlZ2lzdGVyIGEgY2FsbGJhY2sgdG8gYmUgaW52b2tlZCB1cG9uIHJvb3QgY2hhbmdlc1xuICAgKlxuICAgKiBAcGFyYW0gY2FsbGJhY2sgRnVuY3Rpb24gdG8gaW52b2tlIHdoZW5ldmVyIHRoZSByb290IGNoYW5nZXNcbiAgICogQHJldHVybiBzdWJzY3JpcHRpb24gaWRcbiAgICovXG4gIG9uUm9vdENoYW5nZShjYWxsYmFjaykge1xuICAgIHJldHVybiB0aGlzLl9tYWtlU3Vic2NyaXB0aW9uKHtcbiAgICAgIGNhbGxiYWNrLFxuICAgICAgbWV0aG9kOiAncm9vdFN1YnNjcmliZScsXG4gICAgICB1bnN1YnNjcmliZU1ldGhvZDogJ3Jvb3RVbnN1YnNjcmliZSdcbiAgICB9LCBbXSAvKiBhcmdzICovKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZXJlZ2lzdGVyIGEgcm9vdCBub3RpZmljYXRpb24gY2FsbGJhY2tcbiAgICpcbiAgICogQHBhcmFtIGNsaWVudFN1YnNjcmlwdGlvbklkIGNsaWVudCBzdWJzY3JpcHRpb24gaWQgdG8gZGVyZWdpc3RlclxuICAgKi9cbiAgYXN5bmMgcmVtb3ZlUm9vdENoYW5nZUxpc3RlbmVyKGNsaWVudFN1YnNjcmlwdGlvbklkKSB7XG4gICAgYXdhaXQgdGhpcy5fdW5zdWJzY3JpYmVDbGllbnRTdWJzY3JpcHRpb24oY2xpZW50U3Vic2NyaXB0aW9uSWQsICdyb290IGNoYW5nZScpO1xuICB9XG59XG5cbi8qKlxuICogS2V5cGFpciBzaWduZXIgaW50ZXJmYWNlXG4gKi9cblxuLyoqXG4gKiBBbiBhY2NvdW50IGtleXBhaXIgdXNlZCBmb3Igc2lnbmluZyB0cmFuc2FjdGlvbnMuXG4gKi9cbmNsYXNzIEtleXBhaXIge1xuICAvKipcbiAgICogQ3JlYXRlIGEgbmV3IGtleXBhaXIgaW5zdGFuY2UuXG4gICAqIEdlbmVyYXRlIHJhbmRvbSBrZXlwYWlyIGlmIG5vIHtAbGluayBFZDI1NTE5S2V5cGFpcn0gaXMgcHJvdmlkZWQuXG4gICAqXG4gICAqIEBwYXJhbSB7RWQyNTUxOUtleXBhaXJ9IGtleXBhaXIgZWQyNTUxOSBrZXlwYWlyXG4gICAqL1xuICBjb25zdHJ1Y3RvcihrZXlwYWlyKSB7XG4gICAgdGhpcy5fa2V5cGFpciA9IHZvaWQgMDtcbiAgICB0aGlzLl9rZXlwYWlyID0ga2V5cGFpciA/PyBnZW5lcmF0ZUtleXBhaXIoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZW5lcmF0ZSBhIG5ldyByYW5kb20ga2V5cGFpclxuICAgKlxuICAgKiBAcmV0dXJucyB7S2V5cGFpcn0gS2V5cGFpclxuICAgKi9cbiAgc3RhdGljIGdlbmVyYXRlKCkge1xuICAgIHJldHVybiBuZXcgS2V5cGFpcihnZW5lcmF0ZUtleXBhaXIoKSk7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlIGEga2V5cGFpciBmcm9tIGEgcmF3IHNlY3JldCBrZXkgYnl0ZSBhcnJheS5cbiAgICpcbiAgICogVGhpcyBtZXRob2Qgc2hvdWxkIG9ubHkgYmUgdXNlZCB0byByZWNyZWF0ZSBhIGtleXBhaXIgZnJvbSBhIHByZXZpb3VzbHlcbiAgICogZ2VuZXJhdGVkIHNlY3JldCBrZXkuIEdlbmVyYXRpbmcga2V5cGFpcnMgZnJvbSBhIHJhbmRvbSBzZWVkIHNob3VsZCBiZSBkb25lXG4gICAqIHdpdGggdGhlIHtAbGluayBLZXlwYWlyLmZyb21TZWVkfSBtZXRob2QuXG4gICAqXG4gICAqIEB0aHJvd3MgZXJyb3IgaWYgdGhlIHByb3ZpZGVkIHNlY3JldCBrZXkgaXMgaW52YWxpZCBhbmQgdmFsaWRhdGlvbiBpcyBub3Qgc2tpcHBlZC5cbiAgICpcbiAgICogQHBhcmFtIHNlY3JldEtleSBzZWNyZXQga2V5IGJ5dGUgYXJyYXlcbiAgICogQHBhcmFtIG9wdGlvbnMgc2tpcCBzZWNyZXQga2V5IHZhbGlkYXRpb25cbiAgICpcbiAgICogQHJldHVybnMge0tleXBhaXJ9IEtleXBhaXJcbiAgICovXG4gIHN0YXRpYyBmcm9tU2VjcmV0S2V5KHNlY3JldEtleSwgb3B0aW9ucykge1xuICAgIGlmIChzZWNyZXRLZXkuYnl0ZUxlbmd0aCAhPT0gNjQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignYmFkIHNlY3JldCBrZXkgc2l6ZScpO1xuICAgIH1cbiAgICBjb25zdCBwdWJsaWNLZXkgPSBzZWNyZXRLZXkuc2xpY2UoMzIsIDY0KTtcbiAgICBpZiAoIW9wdGlvbnMgfHwgIW9wdGlvbnMuc2tpcFZhbGlkYXRpb24pIHtcbiAgICAgIGNvbnN0IHByaXZhdGVTY2FsYXIgPSBzZWNyZXRLZXkuc2xpY2UoMCwgMzIpO1xuICAgICAgY29uc3QgY29tcHV0ZWRQdWJsaWNLZXkgPSBnZXRQdWJsaWNLZXkocHJpdmF0ZVNjYWxhcik7XG4gICAgICBmb3IgKGxldCBpaSA9IDA7IGlpIDwgMzI7IGlpKyspIHtcbiAgICAgICAgaWYgKHB1YmxpY0tleVtpaV0gIT09IGNvbXB1dGVkUHVibGljS2V5W2lpXSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcigncHJvdmlkZWQgc2VjcmV0S2V5IGlzIGludmFsaWQnKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbmV3IEtleXBhaXIoe1xuICAgICAgcHVibGljS2V5LFxuICAgICAgc2VjcmV0S2V5XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogR2VuZXJhdGUgYSBrZXlwYWlyIGZyb20gYSAzMiBieXRlIHNlZWQuXG4gICAqXG4gICAqIEBwYXJhbSBzZWVkIHNlZWQgYnl0ZSBhcnJheVxuICAgKlxuICAgKiBAcmV0dXJucyB7S2V5cGFpcn0gS2V5cGFpclxuICAgKi9cbiAgc3RhdGljIGZyb21TZWVkKHNlZWQpIHtcbiAgICBjb25zdCBwdWJsaWNLZXkgPSBnZXRQdWJsaWNLZXkoc2VlZCk7XG4gICAgY29uc3Qgc2VjcmV0S2V5ID0gbmV3IFVpbnQ4QXJyYXkoNjQpO1xuICAgIHNlY3JldEtleS5zZXQoc2VlZCk7XG4gICAgc2VjcmV0S2V5LnNldChwdWJsaWNLZXksIDMyKTtcbiAgICByZXR1cm4gbmV3IEtleXBhaXIoe1xuICAgICAgcHVibGljS2V5LFxuICAgICAgc2VjcmV0S2V5XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogVGhlIHB1YmxpYyBrZXkgZm9yIHRoaXMga2V5cGFpclxuICAgKlxuICAgKiBAcmV0dXJucyB7UHVibGljS2V5fSBQdWJsaWNLZXlcbiAgICovXG4gIGdldCBwdWJsaWNLZXkoKSB7XG4gICAgcmV0dXJuIG5ldyBQdWJsaWNLZXkodGhpcy5fa2V5cGFpci5wdWJsaWNLZXkpO1xuICB9XG5cbiAgLyoqXG4gICAqIFRoZSByYXcgc2VjcmV0IGtleSBmb3IgdGhpcyBrZXlwYWlyXG4gICAqIEByZXR1cm5zIHtVaW50OEFycmF5fSBTZWNyZXQga2V5IGluIGFuIGFycmF5IG9mIFVpbnQ4IGJ5dGVzXG4gICAqL1xuICBnZXQgc2VjcmV0S2V5KCkge1xuICAgIHJldHVybiBuZXcgVWludDhBcnJheSh0aGlzLl9rZXlwYWlyLnNlY3JldEtleSk7XG4gIH1cbn1cblxuLyoqXG4gKiBBbiBlbnVtZXJhdGlvbiBvZiB2YWxpZCBMb29rdXBUYWJsZUluc3RydWN0aW9uVHlwZSdzXG4gKi9cblxuLyoqXG4gKiBBbiBlbnVtZXJhdGlvbiBvZiB2YWxpZCBhZGRyZXNzIGxvb2t1cCB0YWJsZSBJbnN0cnVjdGlvblR5cGUnc1xuICogQGludGVybmFsXG4gKi9cbmNvbnN0IExPT0tVUF9UQUJMRV9JTlNUUlVDVElPTl9MQVlPVVRTID0gT2JqZWN0LmZyZWV6ZSh7XG4gIENyZWF0ZUxvb2t1cFRhYmxlOiB7XG4gICAgaW5kZXg6IDAsXG4gICAgbGF5b3V0OiBCdWZmZXJMYXlvdXQuc3RydWN0KFtCdWZmZXJMYXlvdXQudTMyKCdpbnN0cnVjdGlvbicpLCB1NjQoJ3JlY2VudFNsb3QnKSwgQnVmZmVyTGF5b3V0LnU4KCdidW1wU2VlZCcpXSlcbiAgfSxcbiAgRnJlZXplTG9va3VwVGFibGU6IHtcbiAgICBpbmRleDogMSxcbiAgICBsYXlvdXQ6IEJ1ZmZlckxheW91dC5zdHJ1Y3QoW0J1ZmZlckxheW91dC51MzIoJ2luc3RydWN0aW9uJyldKVxuICB9LFxuICBFeHRlbmRMb29rdXBUYWJsZToge1xuICAgIGluZGV4OiAyLFxuICAgIGxheW91dDogQnVmZmVyTGF5b3V0LnN0cnVjdChbQnVmZmVyTGF5b3V0LnUzMignaW5zdHJ1Y3Rpb24nKSwgdTY0KCksIEJ1ZmZlckxheW91dC5zZXEocHVibGljS2V5KCksIEJ1ZmZlckxheW91dC5vZmZzZXQoQnVmZmVyTGF5b3V0LnUzMigpLCAtOCksICdhZGRyZXNzZXMnKV0pXG4gIH0sXG4gIERlYWN0aXZhdGVMb29rdXBUYWJsZToge1xuICAgIGluZGV4OiAzLFxuICAgIGxheW91dDogQnVmZmVyTGF5b3V0LnN0cnVjdChbQnVmZmVyTGF5b3V0LnUzMignaW5zdHJ1Y3Rpb24nKV0pXG4gIH0sXG4gIENsb3NlTG9va3VwVGFibGU6IHtcbiAgICBpbmRleDogNCxcbiAgICBsYXlvdXQ6IEJ1ZmZlckxheW91dC5zdHJ1Y3QoW0J1ZmZlckxheW91dC51MzIoJ2luc3RydWN0aW9uJyldKVxuICB9XG59KTtcbmNsYXNzIEFkZHJlc3NMb29rdXBUYWJsZUluc3RydWN0aW9uIHtcbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgY29uc3RydWN0b3IoKSB7fVxuICBzdGF0aWMgZGVjb2RlSW5zdHJ1Y3Rpb25UeXBlKGluc3RydWN0aW9uKSB7XG4gICAgdGhpcy5jaGVja1Byb2dyYW1JZChpbnN0cnVjdGlvbi5wcm9ncmFtSWQpO1xuICAgIGNvbnN0IGluc3RydWN0aW9uVHlwZUxheW91dCA9IEJ1ZmZlckxheW91dC51MzIoJ2luc3RydWN0aW9uJyk7XG4gICAgY29uc3QgaW5kZXggPSBpbnN0cnVjdGlvblR5cGVMYXlvdXQuZGVjb2RlKGluc3RydWN0aW9uLmRhdGEpO1xuICAgIGxldCB0eXBlO1xuICAgIGZvciAoY29uc3QgW2xheW91dFR5cGUsIGxheW91dF0gb2YgT2JqZWN0LmVudHJpZXMoTE9PS1VQX1RBQkxFX0lOU1RSVUNUSU9OX0xBWU9VVFMpKSB7XG4gICAgICBpZiAobGF5b3V0LmluZGV4ID09IGluZGV4KSB7XG4gICAgICAgIHR5cGUgPSBsYXlvdXRUeXBlO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKCF0eXBlKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgSW5zdHJ1Y3Rpb24uIFNob3VsZCBiZSBhIExvb2t1cFRhYmxlIEluc3RydWN0aW9uJyk7XG4gICAgfVxuICAgIHJldHVybiB0eXBlO1xuICB9XG4gIHN0YXRpYyBkZWNvZGVDcmVhdGVMb29rdXBUYWJsZShpbnN0cnVjdGlvbikge1xuICAgIHRoaXMuY2hlY2tQcm9ncmFtSWQoaW5zdHJ1Y3Rpb24ucHJvZ3JhbUlkKTtcbiAgICB0aGlzLmNoZWNrS2V5c0xlbmd0aChpbnN0cnVjdGlvbi5rZXlzLCA0KTtcbiAgICBjb25zdCB7XG4gICAgICByZWNlbnRTbG90XG4gICAgfSA9IGRlY29kZURhdGEkMShMT09LVVBfVEFCTEVfSU5TVFJVQ1RJT05fTEFZT1VUUy5DcmVhdGVMb29rdXBUYWJsZSwgaW5zdHJ1Y3Rpb24uZGF0YSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIGF1dGhvcml0eTogaW5zdHJ1Y3Rpb24ua2V5c1sxXS5wdWJrZXksXG4gICAgICBwYXllcjogaW5zdHJ1Y3Rpb24ua2V5c1syXS5wdWJrZXksXG4gICAgICByZWNlbnRTbG90OiBOdW1iZXIocmVjZW50U2xvdClcbiAgICB9O1xuICB9XG4gIHN0YXRpYyBkZWNvZGVFeHRlbmRMb29rdXBUYWJsZShpbnN0cnVjdGlvbikge1xuICAgIHRoaXMuY2hlY2tQcm9ncmFtSWQoaW5zdHJ1Y3Rpb24ucHJvZ3JhbUlkKTtcbiAgICBpZiAoaW5zdHJ1Y3Rpb24ua2V5cy5sZW5ndGggPCAyKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYGludmFsaWQgaW5zdHJ1Y3Rpb247IGZvdW5kICR7aW5zdHJ1Y3Rpb24ua2V5cy5sZW5ndGh9IGtleXMsIGV4cGVjdGVkIGF0IGxlYXN0IDJgKTtcbiAgICB9XG4gICAgY29uc3Qge1xuICAgICAgYWRkcmVzc2VzXG4gICAgfSA9IGRlY29kZURhdGEkMShMT09LVVBfVEFCTEVfSU5TVFJVQ1RJT05fTEFZT1VUUy5FeHRlbmRMb29rdXBUYWJsZSwgaW5zdHJ1Y3Rpb24uZGF0YSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIGxvb2t1cFRhYmxlOiBpbnN0cnVjdGlvbi5rZXlzWzBdLnB1YmtleSxcbiAgICAgIGF1dGhvcml0eTogaW5zdHJ1Y3Rpb24ua2V5c1sxXS5wdWJrZXksXG4gICAgICBwYXllcjogaW5zdHJ1Y3Rpb24ua2V5cy5sZW5ndGggPiAyID8gaW5zdHJ1Y3Rpb24ua2V5c1syXS5wdWJrZXkgOiB1bmRlZmluZWQsXG4gICAgICBhZGRyZXNzZXM6IGFkZHJlc3Nlcy5tYXAoYnVmZmVyID0+IG5ldyBQdWJsaWNLZXkoYnVmZmVyKSlcbiAgICB9O1xuICB9XG4gIHN0YXRpYyBkZWNvZGVDbG9zZUxvb2t1cFRhYmxlKGluc3RydWN0aW9uKSB7XG4gICAgdGhpcy5jaGVja1Byb2dyYW1JZChpbnN0cnVjdGlvbi5wcm9ncmFtSWQpO1xuICAgIHRoaXMuY2hlY2tLZXlzTGVuZ3RoKGluc3RydWN0aW9uLmtleXMsIDMpO1xuICAgIHJldHVybiB7XG4gICAgICBsb29rdXBUYWJsZTogaW5zdHJ1Y3Rpb24ua2V5c1swXS5wdWJrZXksXG4gICAgICBhdXRob3JpdHk6IGluc3RydWN0aW9uLmtleXNbMV0ucHVia2V5LFxuICAgICAgcmVjaXBpZW50OiBpbnN0cnVjdGlvbi5rZXlzWzJdLnB1YmtleVxuICAgIH07XG4gIH1cbiAgc3RhdGljIGRlY29kZUZyZWV6ZUxvb2t1cFRhYmxlKGluc3RydWN0aW9uKSB7XG4gICAgdGhpcy5jaGVja1Byb2dyYW1JZChpbnN0cnVjdGlvbi5wcm9ncmFtSWQpO1xuICAgIHRoaXMuY2hlY2tLZXlzTGVuZ3RoKGluc3RydWN0aW9uLmtleXMsIDIpO1xuICAgIHJldHVybiB7XG4gICAgICBsb29rdXBUYWJsZTogaW5zdHJ1Y3Rpb24ua2V5c1swXS5wdWJrZXksXG4gICAgICBhdXRob3JpdHk6IGluc3RydWN0aW9uLmtleXNbMV0ucHVia2V5XG4gICAgfTtcbiAgfVxuICBzdGF0aWMgZGVjb2RlRGVhY3RpdmF0ZUxvb2t1cFRhYmxlKGluc3RydWN0aW9uKSB7XG4gICAgdGhpcy5jaGVja1Byb2dyYW1JZChpbnN0cnVjdGlvbi5wcm9ncmFtSWQpO1xuICAgIHRoaXMuY2hlY2tLZXlzTGVuZ3RoKGluc3RydWN0aW9uLmtleXMsIDIpO1xuICAgIHJldHVybiB7XG4gICAgICBsb29rdXBUYWJsZTogaW5zdHJ1Y3Rpb24ua2V5c1swXS5wdWJrZXksXG4gICAgICBhdXRob3JpdHk6IGluc3RydWN0aW9uLmtleXNbMV0ucHVia2V5XG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIHN0YXRpYyBjaGVja1Byb2dyYW1JZChwcm9ncmFtSWQpIHtcbiAgICBpZiAoIXByb2dyYW1JZC5lcXVhbHMoQWRkcmVzc0xvb2t1cFRhYmxlUHJvZ3JhbS5wcm9ncmFtSWQpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgaW5zdHJ1Y3Rpb247IHByb2dyYW1JZCBpcyBub3QgQWRkcmVzc0xvb2t1cFRhYmxlIFByb2dyYW0nKTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgc3RhdGljIGNoZWNrS2V5c0xlbmd0aChrZXlzLCBleHBlY3RlZExlbmd0aCkge1xuICAgIGlmIChrZXlzLmxlbmd0aCA8IGV4cGVjdGVkTGVuZ3RoKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYGludmFsaWQgaW5zdHJ1Y3Rpb247IGZvdW5kICR7a2V5cy5sZW5ndGh9IGtleXMsIGV4cGVjdGVkIGF0IGxlYXN0ICR7ZXhwZWN0ZWRMZW5ndGh9YCk7XG4gICAgfVxuICB9XG59XG5jbGFzcyBBZGRyZXNzTG9va3VwVGFibGVQcm9ncmFtIHtcbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgY29uc3RydWN0b3IoKSB7fVxuICBzdGF0aWMgY3JlYXRlTG9va3VwVGFibGUocGFyYW1zKSB7XG4gICAgY29uc3QgW2xvb2t1cFRhYmxlQWRkcmVzcywgYnVtcFNlZWRdID0gUHVibGljS2V5LmZpbmRQcm9ncmFtQWRkcmVzc1N5bmMoW3BhcmFtcy5hdXRob3JpdHkudG9CdWZmZXIoKSwgdG9CdWZmZXJMRShCaWdJbnQocGFyYW1zLnJlY2VudFNsb3QpLCA4KV0sIHRoaXMucHJvZ3JhbUlkKTtcbiAgICBjb25zdCB0eXBlID0gTE9PS1VQX1RBQkxFX0lOU1RSVUNUSU9OX0xBWU9VVFMuQ3JlYXRlTG9va3VwVGFibGU7XG4gICAgY29uc3QgZGF0YSA9IGVuY29kZURhdGEodHlwZSwge1xuICAgICAgcmVjZW50U2xvdDogQmlnSW50KHBhcmFtcy5yZWNlbnRTbG90KSxcbiAgICAgIGJ1bXBTZWVkOiBidW1wU2VlZFxuICAgIH0pO1xuICAgIGNvbnN0IGtleXMgPSBbe1xuICAgICAgcHVia2V5OiBsb29rdXBUYWJsZUFkZHJlc3MsXG4gICAgICBpc1NpZ25lcjogZmFsc2UsXG4gICAgICBpc1dyaXRhYmxlOiB0cnVlXG4gICAgfSwge1xuICAgICAgcHVia2V5OiBwYXJhbXMuYXV0aG9yaXR5LFxuICAgICAgaXNTaWduZXI6IHRydWUsXG4gICAgICBpc1dyaXRhYmxlOiBmYWxzZVxuICAgIH0sIHtcbiAgICAgIHB1YmtleTogcGFyYW1zLnBheWVyLFxuICAgICAgaXNTaWduZXI6IHRydWUsXG4gICAgICBpc1dyaXRhYmxlOiB0cnVlXG4gICAgfSwge1xuICAgICAgcHVia2V5OiBTeXN0ZW1Qcm9ncmFtLnByb2dyYW1JZCxcbiAgICAgIGlzU2lnbmVyOiBmYWxzZSxcbiAgICAgIGlzV3JpdGFibGU6IGZhbHNlXG4gICAgfV07XG4gICAgcmV0dXJuIFtuZXcgVHJhbnNhY3Rpb25JbnN0cnVjdGlvbih7XG4gICAgICBwcm9ncmFtSWQ6IHRoaXMucHJvZ3JhbUlkLFxuICAgICAga2V5czoga2V5cyxcbiAgICAgIGRhdGE6IGRhdGFcbiAgICB9KSwgbG9va3VwVGFibGVBZGRyZXNzXTtcbiAgfVxuICBzdGF0aWMgZnJlZXplTG9va3VwVGFibGUocGFyYW1zKSB7XG4gICAgY29uc3QgdHlwZSA9IExPT0tVUF9UQUJMRV9JTlNUUlVDVElPTl9MQVlPVVRTLkZyZWV6ZUxvb2t1cFRhYmxlO1xuICAgIGNvbnN0IGRhdGEgPSBlbmNvZGVEYXRhKHR5cGUpO1xuICAgIGNvbnN0IGtleXMgPSBbe1xuICAgICAgcHVia2V5OiBwYXJhbXMubG9va3VwVGFibGUsXG4gICAgICBpc1NpZ25lcjogZmFsc2UsXG4gICAgICBpc1dyaXRhYmxlOiB0cnVlXG4gICAgfSwge1xuICAgICAgcHVia2V5OiBwYXJhbXMuYXV0aG9yaXR5LFxuICAgICAgaXNTaWduZXI6IHRydWUsXG4gICAgICBpc1dyaXRhYmxlOiBmYWxzZVxuICAgIH1dO1xuICAgIHJldHVybiBuZXcgVHJhbnNhY3Rpb25JbnN0cnVjdGlvbih7XG4gICAgICBwcm9ncmFtSWQ6IHRoaXMucHJvZ3JhbUlkLFxuICAgICAga2V5czoga2V5cyxcbiAgICAgIGRhdGE6IGRhdGFcbiAgICB9KTtcbiAgfVxuICBzdGF0aWMgZXh0ZW5kTG9va3VwVGFibGUocGFyYW1zKSB7XG4gICAgY29uc3QgdHlwZSA9IExPT0tVUF9UQUJMRV9JTlNUUlVDVElPTl9MQVlPVVRTLkV4dGVuZExvb2t1cFRhYmxlO1xuICAgIGNvbnN0IGRhdGEgPSBlbmNvZGVEYXRhKHR5cGUsIHtcbiAgICAgIGFkZHJlc3NlczogcGFyYW1zLmFkZHJlc3Nlcy5tYXAoYWRkciA9PiBhZGRyLnRvQnl0ZXMoKSlcbiAgICB9KTtcbiAgICBjb25zdCBrZXlzID0gW3tcbiAgICAgIHB1YmtleTogcGFyYW1zLmxvb2t1cFRhYmxlLFxuICAgICAgaXNTaWduZXI6IGZhbHNlLFxuICAgICAgaXNXcml0YWJsZTogdHJ1ZVxuICAgIH0sIHtcbiAgICAgIHB1YmtleTogcGFyYW1zLmF1dGhvcml0eSxcbiAgICAgIGlzU2lnbmVyOiB0cnVlLFxuICAgICAgaXNXcml0YWJsZTogZmFsc2VcbiAgICB9XTtcbiAgICBpZiAocGFyYW1zLnBheWVyKSB7XG4gICAgICBrZXlzLnB1c2goe1xuICAgICAgICBwdWJrZXk6IHBhcmFtcy5wYXllcixcbiAgICAgICAgaXNTaWduZXI6IHRydWUsXG4gICAgICAgIGlzV3JpdGFibGU6IHRydWVcbiAgICAgIH0sIHtcbiAgICAgICAgcHVia2V5OiBTeXN0ZW1Qcm9ncmFtLnByb2dyYW1JZCxcbiAgICAgICAgaXNTaWduZXI6IGZhbHNlLFxuICAgICAgICBpc1dyaXRhYmxlOiBmYWxzZVxuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBuZXcgVHJhbnNhY3Rpb25JbnN0cnVjdGlvbih7XG4gICAgICBwcm9ncmFtSWQ6IHRoaXMucHJvZ3JhbUlkLFxuICAgICAga2V5czoga2V5cyxcbiAgICAgIGRhdGE6IGRhdGFcbiAgICB9KTtcbiAgfVxuICBzdGF0aWMgZGVhY3RpdmF0ZUxvb2t1cFRhYmxlKHBhcmFtcykge1xuICAgIGNvbnN0IHR5cGUgPSBMT09LVVBfVEFCTEVfSU5TVFJVQ1RJT05fTEFZT1VUUy5EZWFjdGl2YXRlTG9va3VwVGFibGU7XG4gICAgY29uc3QgZGF0YSA9IGVuY29kZURhdGEodHlwZSk7XG4gICAgY29uc3Qga2V5cyA9IFt7XG4gICAgICBwdWJrZXk6IHBhcmFtcy5sb29rdXBUYWJsZSxcbiAgICAgIGlzU2lnbmVyOiBmYWxzZSxcbiAgICAgIGlzV3JpdGFibGU6IHRydWVcbiAgICB9LCB7XG4gICAgICBwdWJrZXk6IHBhcmFtcy5hdXRob3JpdHksXG4gICAgICBpc1NpZ25lcjogdHJ1ZSxcbiAgICAgIGlzV3JpdGFibGU6IGZhbHNlXG4gICAgfV07XG4gICAgcmV0dXJuIG5ldyBUcmFuc2FjdGlvbkluc3RydWN0aW9uKHtcbiAgICAgIHByb2dyYW1JZDogdGhpcy5wcm9ncmFtSWQsXG4gICAgICBrZXlzOiBrZXlzLFxuICAgICAgZGF0YTogZGF0YVxuICAgIH0pO1xuICB9XG4gIHN0YXRpYyBjbG9zZUxvb2t1cFRhYmxlKHBhcmFtcykge1xuICAgIGNvbnN0IHR5cGUgPSBMT09LVVBfVEFCTEVfSU5TVFJVQ1RJT05fTEFZT1VUUy5DbG9zZUxvb2t1cFRhYmxlO1xuICAgIGNvbnN0IGRhdGEgPSBlbmNvZGVEYXRhKHR5cGUpO1xuICAgIGNvbnN0IGtleXMgPSBbe1xuICAgICAgcHVia2V5OiBwYXJhbXMubG9va3VwVGFibGUsXG4gICAgICBpc1NpZ25lcjogZmFsc2UsXG4gICAgICBpc1dyaXRhYmxlOiB0cnVlXG4gICAgfSwge1xuICAgICAgcHVia2V5OiBwYXJhbXMuYXV0aG9yaXR5LFxuICAgICAgaXNTaWduZXI6IHRydWUsXG4gICAgICBpc1dyaXRhYmxlOiBmYWxzZVxuICAgIH0sIHtcbiAgICAgIHB1YmtleTogcGFyYW1zLnJlY2lwaWVudCxcbiAgICAgIGlzU2lnbmVyOiBmYWxzZSxcbiAgICAgIGlzV3JpdGFibGU6IHRydWVcbiAgICB9XTtcbiAgICByZXR1cm4gbmV3IFRyYW5zYWN0aW9uSW5zdHJ1Y3Rpb24oe1xuICAgICAgcHJvZ3JhbUlkOiB0aGlzLnByb2dyYW1JZCxcbiAgICAgIGtleXM6IGtleXMsXG4gICAgICBkYXRhOiBkYXRhXG4gICAgfSk7XG4gIH1cbn1cbkFkZHJlc3NMb29rdXBUYWJsZVByb2dyYW0ucHJvZ3JhbUlkID0gbmV3IFB1YmxpY0tleSgnQWRkcmVzc0xvb2t1cFRhYjFlMTExMTExMTExMTExMTExMTExMTExMTExMScpO1xuXG4vKipcbiAqIENvbXB1dGUgQnVkZ2V0IEluc3RydWN0aW9uIGNsYXNzXG4gKi9cbmNsYXNzIENvbXB1dGVCdWRnZXRJbnN0cnVjdGlvbiB7XG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIGNvbnN0cnVjdG9yKCkge31cblxuICAvKipcbiAgICogRGVjb2RlIGEgY29tcHV0ZSBidWRnZXQgaW5zdHJ1Y3Rpb24gYW5kIHJldHJpZXZlIHRoZSBpbnN0cnVjdGlvbiB0eXBlLlxuICAgKi9cbiAgc3RhdGljIGRlY29kZUluc3RydWN0aW9uVHlwZShpbnN0cnVjdGlvbikge1xuICAgIHRoaXMuY2hlY2tQcm9ncmFtSWQoaW5zdHJ1Y3Rpb24ucHJvZ3JhbUlkKTtcbiAgICBjb25zdCBpbnN0cnVjdGlvblR5cGVMYXlvdXQgPSBCdWZmZXJMYXlvdXQudTgoJ2luc3RydWN0aW9uJyk7XG4gICAgY29uc3QgdHlwZUluZGV4ID0gaW5zdHJ1Y3Rpb25UeXBlTGF5b3V0LmRlY29kZShpbnN0cnVjdGlvbi5kYXRhKTtcbiAgICBsZXQgdHlwZTtcbiAgICBmb3IgKGNvbnN0IFtpeFR5cGUsIGxheW91dF0gb2YgT2JqZWN0LmVudHJpZXMoQ09NUFVURV9CVURHRVRfSU5TVFJVQ1RJT05fTEFZT1VUUykpIHtcbiAgICAgIGlmIChsYXlvdXQuaW5kZXggPT0gdHlwZUluZGV4KSB7XG4gICAgICAgIHR5cGUgPSBpeFR5cGU7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoIXR5cGUpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW5zdHJ1Y3Rpb24gdHlwZSBpbmNvcnJlY3Q7IG5vdCBhIENvbXB1dGVCdWRnZXRJbnN0cnVjdGlvbicpO1xuICAgIH1cbiAgICByZXR1cm4gdHlwZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZWNvZGUgcmVxdWVzdCB1bml0cyBjb21wdXRlIGJ1ZGdldCBpbnN0cnVjdGlvbiBhbmQgcmV0cmlldmUgdGhlIGluc3RydWN0aW9uIHBhcmFtcy5cbiAgICovXG4gIHN0YXRpYyBkZWNvZGVSZXF1ZXN0VW5pdHMoaW5zdHJ1Y3Rpb24pIHtcbiAgICB0aGlzLmNoZWNrUHJvZ3JhbUlkKGluc3RydWN0aW9uLnByb2dyYW1JZCk7XG4gICAgY29uc3Qge1xuICAgICAgdW5pdHMsXG4gICAgICBhZGRpdGlvbmFsRmVlXG4gICAgfSA9IGRlY29kZURhdGEkMShDT01QVVRFX0JVREdFVF9JTlNUUlVDVElPTl9MQVlPVVRTLlJlcXVlc3RVbml0cywgaW5zdHJ1Y3Rpb24uZGF0YSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHVuaXRzLFxuICAgICAgYWRkaXRpb25hbEZlZVxuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogRGVjb2RlIHJlcXVlc3QgaGVhcCBmcmFtZSBjb21wdXRlIGJ1ZGdldCBpbnN0cnVjdGlvbiBhbmQgcmV0cmlldmUgdGhlIGluc3RydWN0aW9uIHBhcmFtcy5cbiAgICovXG4gIHN0YXRpYyBkZWNvZGVSZXF1ZXN0SGVhcEZyYW1lKGluc3RydWN0aW9uKSB7XG4gICAgdGhpcy5jaGVja1Byb2dyYW1JZChpbnN0cnVjdGlvbi5wcm9ncmFtSWQpO1xuICAgIGNvbnN0IHtcbiAgICAgIGJ5dGVzXG4gICAgfSA9IGRlY29kZURhdGEkMShDT01QVVRFX0JVREdFVF9JTlNUUlVDVElPTl9MQVlPVVRTLlJlcXVlc3RIZWFwRnJhbWUsIGluc3RydWN0aW9uLmRhdGEpO1xuICAgIHJldHVybiB7XG4gICAgICBieXRlc1xuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogRGVjb2RlIHNldCBjb21wdXRlIHVuaXQgbGltaXQgY29tcHV0ZSBidWRnZXQgaW5zdHJ1Y3Rpb24gYW5kIHJldHJpZXZlIHRoZSBpbnN0cnVjdGlvbiBwYXJhbXMuXG4gICAqL1xuICBzdGF0aWMgZGVjb2RlU2V0Q29tcHV0ZVVuaXRMaW1pdChpbnN0cnVjdGlvbikge1xuICAgIHRoaXMuY2hlY2tQcm9ncmFtSWQoaW5zdHJ1Y3Rpb24ucHJvZ3JhbUlkKTtcbiAgICBjb25zdCB7XG4gICAgICB1bml0c1xuICAgIH0gPSBkZWNvZGVEYXRhJDEoQ09NUFVURV9CVURHRVRfSU5TVFJVQ1RJT05fTEFZT1VUUy5TZXRDb21wdXRlVW5pdExpbWl0LCBpbnN0cnVjdGlvbi5kYXRhKTtcbiAgICByZXR1cm4ge1xuICAgICAgdW5pdHNcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIERlY29kZSBzZXQgY29tcHV0ZSB1bml0IHByaWNlIGNvbXB1dGUgYnVkZ2V0IGluc3RydWN0aW9uIGFuZCByZXRyaWV2ZSB0aGUgaW5zdHJ1Y3Rpb24gcGFyYW1zLlxuICAgKi9cbiAgc3RhdGljIGRlY29kZVNldENvbXB1dGVVbml0UHJpY2UoaW5zdHJ1Y3Rpb24pIHtcbiAgICB0aGlzLmNoZWNrUHJvZ3JhbUlkKGluc3RydWN0aW9uLnByb2dyYW1JZCk7XG4gICAgY29uc3Qge1xuICAgICAgbWljcm9MYW1wb3J0c1xuICAgIH0gPSBkZWNvZGVEYXRhJDEoQ09NUFVURV9CVURHRVRfSU5TVFJVQ1RJT05fTEFZT1VUUy5TZXRDb21wdXRlVW5pdFByaWNlLCBpbnN0cnVjdGlvbi5kYXRhKTtcbiAgICByZXR1cm4ge1xuICAgICAgbWljcm9MYW1wb3J0c1xuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogQGludGVybmFsXG4gICAqL1xuICBzdGF0aWMgY2hlY2tQcm9ncmFtSWQocHJvZ3JhbUlkKSB7XG4gICAgaWYgKCFwcm9ncmFtSWQuZXF1YWxzKENvbXB1dGVCdWRnZXRQcm9ncmFtLnByb2dyYW1JZCkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBpbnN0cnVjdGlvbjsgcHJvZ3JhbUlkIGlzIG5vdCBDb21wdXRlQnVkZ2V0UHJvZ3JhbScpO1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIEFuIGVudW1lcmF0aW9uIG9mIHZhbGlkIENvbXB1dGVCdWRnZXRJbnN0cnVjdGlvblR5cGUnc1xuICovXG5cbi8qKlxuICogUmVxdWVzdCB1bml0cyBpbnN0cnVjdGlvbiBwYXJhbXNcbiAqL1xuXG4vKipcbiAqIFJlcXVlc3QgaGVhcCBmcmFtZSBpbnN0cnVjdGlvbiBwYXJhbXNcbiAqL1xuXG4vKipcbiAqIFNldCBjb21wdXRlIHVuaXQgbGltaXQgaW5zdHJ1Y3Rpb24gcGFyYW1zXG4gKi9cblxuLyoqXG4gKiBTZXQgY29tcHV0ZSB1bml0IHByaWNlIGluc3RydWN0aW9uIHBhcmFtc1xuICovXG5cbi8qKlxuICogQW4gZW51bWVyYXRpb24gb2YgdmFsaWQgQ29tcHV0ZUJ1ZGdldCBJbnN0cnVjdGlvblR5cGUnc1xuICogQGludGVybmFsXG4gKi9cbmNvbnN0IENPTVBVVEVfQlVER0VUX0lOU1RSVUNUSU9OX0xBWU9VVFMgPSBPYmplY3QuZnJlZXplKHtcbiAgUmVxdWVzdFVuaXRzOiB7XG4gICAgaW5kZXg6IDAsXG4gICAgbGF5b3V0OiBCdWZmZXJMYXlvdXQuc3RydWN0KFtCdWZmZXJMYXlvdXQudTgoJ2luc3RydWN0aW9uJyksIEJ1ZmZlckxheW91dC51MzIoJ3VuaXRzJyksIEJ1ZmZlckxheW91dC51MzIoJ2FkZGl0aW9uYWxGZWUnKV0pXG4gIH0sXG4gIFJlcXVlc3RIZWFwRnJhbWU6IHtcbiAgICBpbmRleDogMSxcbiAgICBsYXlvdXQ6IEJ1ZmZlckxheW91dC5zdHJ1Y3QoW0J1ZmZlckxheW91dC51OCgnaW5zdHJ1Y3Rpb24nKSwgQnVmZmVyTGF5b3V0LnUzMignYnl0ZXMnKV0pXG4gIH0sXG4gIFNldENvbXB1dGVVbml0TGltaXQ6IHtcbiAgICBpbmRleDogMixcbiAgICBsYXlvdXQ6IEJ1ZmZlckxheW91dC5zdHJ1Y3QoW0J1ZmZlckxheW91dC51OCgnaW5zdHJ1Y3Rpb24nKSwgQnVmZmVyTGF5b3V0LnUzMigndW5pdHMnKV0pXG4gIH0sXG4gIFNldENvbXB1dGVVbml0UHJpY2U6IHtcbiAgICBpbmRleDogMyxcbiAgICBsYXlvdXQ6IEJ1ZmZlckxheW91dC5zdHJ1Y3QoW0J1ZmZlckxheW91dC51OCgnaW5zdHJ1Y3Rpb24nKSwgdTY0KCdtaWNyb0xhbXBvcnRzJyldKVxuICB9XG59KTtcblxuLyoqXG4gKiBGYWN0b3J5IGNsYXNzIGZvciB0cmFuc2FjdGlvbiBpbnN0cnVjdGlvbnMgdG8gaW50ZXJhY3Qgd2l0aCB0aGUgQ29tcHV0ZSBCdWRnZXQgcHJvZ3JhbVxuICovXG5jbGFzcyBDb21wdXRlQnVkZ2V0UHJvZ3JhbSB7XG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIGNvbnN0cnVjdG9yKCkge31cblxuICAvKipcbiAgICogUHVibGljIGtleSB0aGF0IGlkZW50aWZpZXMgdGhlIENvbXB1dGUgQnVkZ2V0IHByb2dyYW1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBkZXByZWNhdGVkIEluc3RlYWQsIGNhbGwge0BsaW5rIHNldENvbXB1dGVVbml0TGltaXR9IGFuZC9vciB7QGxpbmsgc2V0Q29tcHV0ZVVuaXRQcmljZX1cbiAgICovXG4gIHN0YXRpYyByZXF1ZXN0VW5pdHMocGFyYW1zKSB7XG4gICAgY29uc3QgdHlwZSA9IENPTVBVVEVfQlVER0VUX0lOU1RSVUNUSU9OX0xBWU9VVFMuUmVxdWVzdFVuaXRzO1xuICAgIGNvbnN0IGRhdGEgPSBlbmNvZGVEYXRhKHR5cGUsIHBhcmFtcyk7XG4gICAgcmV0dXJuIG5ldyBUcmFuc2FjdGlvbkluc3RydWN0aW9uKHtcbiAgICAgIGtleXM6IFtdLFxuICAgICAgcHJvZ3JhbUlkOiB0aGlzLnByb2dyYW1JZCxcbiAgICAgIGRhdGFcbiAgICB9KTtcbiAgfVxuICBzdGF0aWMgcmVxdWVzdEhlYXBGcmFtZShwYXJhbXMpIHtcbiAgICBjb25zdCB0eXBlID0gQ09NUFVURV9CVURHRVRfSU5TVFJVQ1RJT05fTEFZT1VUUy5SZXF1ZXN0SGVhcEZyYW1lO1xuICAgIGNvbnN0IGRhdGEgPSBlbmNvZGVEYXRhKHR5cGUsIHBhcmFtcyk7XG4gICAgcmV0dXJuIG5ldyBUcmFuc2FjdGlvbkluc3RydWN0aW9uKHtcbiAgICAgIGtleXM6IFtdLFxuICAgICAgcHJvZ3JhbUlkOiB0aGlzLnByb2dyYW1JZCxcbiAgICAgIGRhdGFcbiAgICB9KTtcbiAgfVxuICBzdGF0aWMgc2V0Q29tcHV0ZVVuaXRMaW1pdChwYXJhbXMpIHtcbiAgICBjb25zdCB0eXBlID0gQ09NUFVURV9CVURHRVRfSU5TVFJVQ1RJT05fTEFZT1VUUy5TZXRDb21wdXRlVW5pdExpbWl0O1xuICAgIGNvbnN0IGRhdGEgPSBlbmNvZGVEYXRhKHR5cGUsIHBhcmFtcyk7XG4gICAgcmV0dXJuIG5ldyBUcmFuc2FjdGlvbkluc3RydWN0aW9uKHtcbiAgICAgIGtleXM6IFtdLFxuICAgICAgcHJvZ3JhbUlkOiB0aGlzLnByb2dyYW1JZCxcbiAgICAgIGRhdGFcbiAgICB9KTtcbiAgfVxuICBzdGF0aWMgc2V0Q29tcHV0ZVVuaXRQcmljZShwYXJhbXMpIHtcbiAgICBjb25zdCB0eXBlID0gQ09NUFVURV9CVURHRVRfSU5TVFJVQ1RJT05fTEFZT1VUUy5TZXRDb21wdXRlVW5pdFByaWNlO1xuICAgIGNvbnN0IGRhdGEgPSBlbmNvZGVEYXRhKHR5cGUsIHtcbiAgICAgIG1pY3JvTGFtcG9ydHM6IEJpZ0ludChwYXJhbXMubWljcm9MYW1wb3J0cylcbiAgICB9KTtcbiAgICByZXR1cm4gbmV3IFRyYW5zYWN0aW9uSW5zdHJ1Y3Rpb24oe1xuICAgICAga2V5czogW10sXG4gICAgICBwcm9ncmFtSWQ6IHRoaXMucHJvZ3JhbUlkLFxuICAgICAgZGF0YVxuICAgIH0pO1xuICB9XG59XG5Db21wdXRlQnVkZ2V0UHJvZ3JhbS5wcm9ncmFtSWQgPSBuZXcgUHVibGljS2V5KCdDb21wdXRlQnVkZ2V0MTExMTExMTExMTExMTExMTExMTExMTExMTExMTExJyk7XG5cbmNvbnN0IFBSSVZBVEVfS0VZX0JZVEVTJDEgPSA2NDtcbmNvbnN0IFBVQkxJQ19LRVlfQllURVMkMSA9IDMyO1xuY29uc3QgU0lHTkFUVVJFX0JZVEVTID0gNjQ7XG5cbi8qKlxuICogUGFyYW1zIGZvciBjcmVhdGluZyBhbiBlZDI1NTE5IGluc3RydWN0aW9uIHVzaW5nIGEgcHVibGljIGtleVxuICovXG5cbi8qKlxuICogUGFyYW1zIGZvciBjcmVhdGluZyBhbiBlZDI1NTE5IGluc3RydWN0aW9uIHVzaW5nIGEgcHJpdmF0ZSBrZXlcbiAqL1xuXG5jb25zdCBFRDI1NTE5X0lOU1RSVUNUSU9OX0xBWU9VVCA9IEJ1ZmZlckxheW91dC5zdHJ1Y3QoW0J1ZmZlckxheW91dC51OCgnbnVtU2lnbmF0dXJlcycpLCBCdWZmZXJMYXlvdXQudTgoJ3BhZGRpbmcnKSwgQnVmZmVyTGF5b3V0LnUxNignc2lnbmF0dXJlT2Zmc2V0JyksIEJ1ZmZlckxheW91dC51MTYoJ3NpZ25hdHVyZUluc3RydWN0aW9uSW5kZXgnKSwgQnVmZmVyTGF5b3V0LnUxNigncHVibGljS2V5T2Zmc2V0JyksIEJ1ZmZlckxheW91dC51MTYoJ3B1YmxpY0tleUluc3RydWN0aW9uSW5kZXgnKSwgQnVmZmVyTGF5b3V0LnUxNignbWVzc2FnZURhdGFPZmZzZXQnKSwgQnVmZmVyTGF5b3V0LnUxNignbWVzc2FnZURhdGFTaXplJyksIEJ1ZmZlckxheW91dC51MTYoJ21lc3NhZ2VJbnN0cnVjdGlvbkluZGV4JyldKTtcbmNsYXNzIEVkMjU1MTlQcm9ncmFtIHtcbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgY29uc3RydWN0b3IoKSB7fVxuXG4gIC8qKlxuICAgKiBQdWJsaWMga2V5IHRoYXQgaWRlbnRpZmllcyB0aGUgZWQyNTUxOSBwcm9ncmFtXG4gICAqL1xuXG4gIC8qKlxuICAgKiBDcmVhdGUgYW4gZWQyNTUxOSBpbnN0cnVjdGlvbiB3aXRoIGEgcHVibGljIGtleSBhbmQgc2lnbmF0dXJlLiBUaGVcbiAgICogcHVibGljIGtleSBtdXN0IGJlIGEgYnVmZmVyIHRoYXQgaXMgMzIgYnl0ZXMgbG9uZywgYW5kIHRoZSBzaWduYXR1cmVcbiAgICogbXVzdCBiZSBhIGJ1ZmZlciBvZiA2NCBieXRlcy5cbiAgICovXG4gIHN0YXRpYyBjcmVhdGVJbnN0cnVjdGlvbldpdGhQdWJsaWNLZXkocGFyYW1zKSB7XG4gICAgY29uc3Qge1xuICAgICAgcHVibGljS2V5LFxuICAgICAgbWVzc2FnZSxcbiAgICAgIHNpZ25hdHVyZSxcbiAgICAgIGluc3RydWN0aW9uSW5kZXhcbiAgICB9ID0gcGFyYW1zO1xuICAgIGFzc2VydChwdWJsaWNLZXkubGVuZ3RoID09PSBQVUJMSUNfS0VZX0JZVEVTJDEsIGBQdWJsaWMgS2V5IG11c3QgYmUgJHtQVUJMSUNfS0VZX0JZVEVTJDF9IGJ5dGVzIGJ1dCByZWNlaXZlZCAke3B1YmxpY0tleS5sZW5ndGh9IGJ5dGVzYCk7XG4gICAgYXNzZXJ0KHNpZ25hdHVyZS5sZW5ndGggPT09IFNJR05BVFVSRV9CWVRFUywgYFNpZ25hdHVyZSBtdXN0IGJlICR7U0lHTkFUVVJFX0JZVEVTfSBieXRlcyBidXQgcmVjZWl2ZWQgJHtzaWduYXR1cmUubGVuZ3RofSBieXRlc2ApO1xuICAgIGNvbnN0IHB1YmxpY0tleU9mZnNldCA9IEVEMjU1MTlfSU5TVFJVQ1RJT05fTEFZT1VULnNwYW47XG4gICAgY29uc3Qgc2lnbmF0dXJlT2Zmc2V0ID0gcHVibGljS2V5T2Zmc2V0ICsgcHVibGljS2V5Lmxlbmd0aDtcbiAgICBjb25zdCBtZXNzYWdlRGF0YU9mZnNldCA9IHNpZ25hdHVyZU9mZnNldCArIHNpZ25hdHVyZS5sZW5ndGg7XG4gICAgY29uc3QgbnVtU2lnbmF0dXJlcyA9IDE7XG4gICAgY29uc3QgaW5zdHJ1Y3Rpb25EYXRhID0gQnVmZmVyLmFsbG9jKG1lc3NhZ2VEYXRhT2Zmc2V0ICsgbWVzc2FnZS5sZW5ndGgpO1xuICAgIGNvbnN0IGluZGV4ID0gaW5zdHJ1Y3Rpb25JbmRleCA9PSBudWxsID8gMHhmZmZmIC8vIEFuIGluZGV4IG9mIGB1MTY6Ok1BWGAgbWFrZXMgaXQgZGVmYXVsdCB0byB0aGUgY3VycmVudCBpbnN0cnVjdGlvbi5cbiAgICA6IGluc3RydWN0aW9uSW5kZXg7XG4gICAgRUQyNTUxOV9JTlNUUlVDVElPTl9MQVlPVVQuZW5jb2RlKHtcbiAgICAgIG51bVNpZ25hdHVyZXMsXG4gICAgICBwYWRkaW5nOiAwLFxuICAgICAgc2lnbmF0dXJlT2Zmc2V0LFxuICAgICAgc2lnbmF0dXJlSW5zdHJ1Y3Rpb25JbmRleDogaW5kZXgsXG4gICAgICBwdWJsaWNLZXlPZmZzZXQsXG4gICAgICBwdWJsaWNLZXlJbnN0cnVjdGlvbkluZGV4OiBpbmRleCxcbiAgICAgIG1lc3NhZ2VEYXRhT2Zmc2V0LFxuICAgICAgbWVzc2FnZURhdGFTaXplOiBtZXNzYWdlLmxlbmd0aCxcbiAgICAgIG1lc3NhZ2VJbnN0cnVjdGlvbkluZGV4OiBpbmRleFxuICAgIH0sIGluc3RydWN0aW9uRGF0YSk7XG4gICAgaW5zdHJ1Y3Rpb25EYXRhLmZpbGwocHVibGljS2V5LCBwdWJsaWNLZXlPZmZzZXQpO1xuICAgIGluc3RydWN0aW9uRGF0YS5maWxsKHNpZ25hdHVyZSwgc2lnbmF0dXJlT2Zmc2V0KTtcbiAgICBpbnN0cnVjdGlvbkRhdGEuZmlsbChtZXNzYWdlLCBtZXNzYWdlRGF0YU9mZnNldCk7XG4gICAgcmV0dXJuIG5ldyBUcmFuc2FjdGlvbkluc3RydWN0aW9uKHtcbiAgICAgIGtleXM6IFtdLFxuICAgICAgcHJvZ3JhbUlkOiBFZDI1NTE5UHJvZ3JhbS5wcm9ncmFtSWQsXG4gICAgICBkYXRhOiBpbnN0cnVjdGlvbkRhdGFcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGUgYW4gZWQyNTUxOSBpbnN0cnVjdGlvbiB3aXRoIGEgcHJpdmF0ZSBrZXkuIFRoZSBwcml2YXRlIGtleVxuICAgKiBtdXN0IGJlIGEgYnVmZmVyIHRoYXQgaXMgNjQgYnl0ZXMgbG9uZy5cbiAgICovXG4gIHN0YXRpYyBjcmVhdGVJbnN0cnVjdGlvbldpdGhQcml2YXRlS2V5KHBhcmFtcykge1xuICAgIGNvbnN0IHtcbiAgICAgIHByaXZhdGVLZXksXG4gICAgICBtZXNzYWdlLFxuICAgICAgaW5zdHJ1Y3Rpb25JbmRleFxuICAgIH0gPSBwYXJhbXM7XG4gICAgYXNzZXJ0KHByaXZhdGVLZXkubGVuZ3RoID09PSBQUklWQVRFX0tFWV9CWVRFUyQxLCBgUHJpdmF0ZSBrZXkgbXVzdCBiZSAke1BSSVZBVEVfS0VZX0JZVEVTJDF9IGJ5dGVzIGJ1dCByZWNlaXZlZCAke3ByaXZhdGVLZXkubGVuZ3RofSBieXRlc2ApO1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBrZXlwYWlyID0gS2V5cGFpci5mcm9tU2VjcmV0S2V5KHByaXZhdGVLZXkpO1xuICAgICAgY29uc3QgcHVibGljS2V5ID0ga2V5cGFpci5wdWJsaWNLZXkudG9CeXRlcygpO1xuICAgICAgY29uc3Qgc2lnbmF0dXJlID0gc2lnbihtZXNzYWdlLCBrZXlwYWlyLnNlY3JldEtleSk7XG4gICAgICByZXR1cm4gdGhpcy5jcmVhdGVJbnN0cnVjdGlvbldpdGhQdWJsaWNLZXkoe1xuICAgICAgICBwdWJsaWNLZXksXG4gICAgICAgIG1lc3NhZ2UsXG4gICAgICAgIHNpZ25hdHVyZSxcbiAgICAgICAgaW5zdHJ1Y3Rpb25JbmRleFxuICAgICAgfSk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgRXJyb3IgY3JlYXRpbmcgaW5zdHJ1Y3Rpb247ICR7ZXJyb3J9YCk7XG4gICAgfVxuICB9XG59XG5FZDI1NTE5UHJvZ3JhbS5wcm9ncmFtSWQgPSBuZXcgUHVibGljS2V5KCdFZDI1NTE5U2lnVmVyaWZ5MTExMTExMTExMTExMTExMTExMTExMTExMTExJyk7XG5cbmNvbnN0IGVjZHNhU2lnbiA9IChtc2dIYXNoLCBwcml2S2V5KSA9PiB7XG4gIGNvbnN0IHNpZ25hdHVyZSA9IHNlY3AyNTZrMS5zaWduKG1zZ0hhc2gsIHByaXZLZXkpO1xuICByZXR1cm4gW3NpZ25hdHVyZS50b0NvbXBhY3RSYXdCeXRlcygpLCBzaWduYXR1cmUucmVjb3ZlcnldO1xufTtcbnNlY3AyNTZrMS51dGlscy5pc1ZhbGlkUHJpdmF0ZUtleTtcbmNvbnN0IHB1YmxpY0tleUNyZWF0ZSA9IHNlY3AyNTZrMS5nZXRQdWJsaWNLZXk7XG5cbmNvbnN0IFBSSVZBVEVfS0VZX0JZVEVTID0gMzI7XG5jb25zdCBFVEhFUkVVTV9BRERSRVNTX0JZVEVTID0gMjA7XG5jb25zdCBQVUJMSUNfS0VZX0JZVEVTID0gNjQ7XG5jb25zdCBTSUdOQVRVUkVfT0ZGU0VUU19TRVJJQUxJWkVEX1NJWkUgPSAxMTtcblxuLyoqXG4gKiBQYXJhbXMgZm9yIGNyZWF0aW5nIGFuIHNlY3AyNTZrMSBpbnN0cnVjdGlvbiB1c2luZyBhIHB1YmxpYyBrZXlcbiAqL1xuXG4vKipcbiAqIFBhcmFtcyBmb3IgY3JlYXRpbmcgYW4gc2VjcDI1NmsxIGluc3RydWN0aW9uIHVzaW5nIGFuIEV0aGVyZXVtIGFkZHJlc3NcbiAqL1xuXG4vKipcbiAqIFBhcmFtcyBmb3IgY3JlYXRpbmcgYW4gc2VjcDI1NmsxIGluc3RydWN0aW9uIHVzaW5nIGEgcHJpdmF0ZSBrZXlcbiAqL1xuXG5jb25zdCBTRUNQMjU2SzFfSU5TVFJVQ1RJT05fTEFZT1VUID0gQnVmZmVyTGF5b3V0LnN0cnVjdChbQnVmZmVyTGF5b3V0LnU4KCdudW1TaWduYXR1cmVzJyksIEJ1ZmZlckxheW91dC51MTYoJ3NpZ25hdHVyZU9mZnNldCcpLCBCdWZmZXJMYXlvdXQudTgoJ3NpZ25hdHVyZUluc3RydWN0aW9uSW5kZXgnKSwgQnVmZmVyTGF5b3V0LnUxNignZXRoQWRkcmVzc09mZnNldCcpLCBCdWZmZXJMYXlvdXQudTgoJ2V0aEFkZHJlc3NJbnN0cnVjdGlvbkluZGV4JyksIEJ1ZmZlckxheW91dC51MTYoJ21lc3NhZ2VEYXRhT2Zmc2V0JyksIEJ1ZmZlckxheW91dC51MTYoJ21lc3NhZ2VEYXRhU2l6ZScpLCBCdWZmZXJMYXlvdXQudTgoJ21lc3NhZ2VJbnN0cnVjdGlvbkluZGV4JyksIEJ1ZmZlckxheW91dC5ibG9iKDIwLCAnZXRoQWRkcmVzcycpLCBCdWZmZXJMYXlvdXQuYmxvYig2NCwgJ3NpZ25hdHVyZScpLCBCdWZmZXJMYXlvdXQudTgoJ3JlY292ZXJ5SWQnKV0pO1xuY2xhc3MgU2VjcDI1NmsxUHJvZ3JhbSB7XG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIGNvbnN0cnVjdG9yKCkge31cblxuICAvKipcbiAgICogUHVibGljIGtleSB0aGF0IGlkZW50aWZpZXMgdGhlIHNlY3AyNTZrMSBwcm9ncmFtXG4gICAqL1xuXG4gIC8qKlxuICAgKiBDb25zdHJ1Y3QgYW4gRXRoZXJldW0gYWRkcmVzcyBmcm9tIGEgc2VjcDI1NmsxIHB1YmxpYyBrZXkgYnVmZmVyLlxuICAgKiBAcGFyYW0ge0J1ZmZlcn0gcHVibGljS2V5IGEgNjQgYnl0ZSBzZWNwMjU2azEgcHVibGljIGtleSBidWZmZXJcbiAgICovXG4gIHN0YXRpYyBwdWJsaWNLZXlUb0V0aEFkZHJlc3MocHVibGljS2V5KSB7XG4gICAgYXNzZXJ0KHB1YmxpY0tleS5sZW5ndGggPT09IFBVQkxJQ19LRVlfQllURVMsIGBQdWJsaWMga2V5IG11c3QgYmUgJHtQVUJMSUNfS0VZX0JZVEVTfSBieXRlcyBidXQgcmVjZWl2ZWQgJHtwdWJsaWNLZXkubGVuZ3RofSBieXRlc2ApO1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gQnVmZmVyLmZyb20oa2VjY2FrXzI1Nih0b0J1ZmZlcihwdWJsaWNLZXkpKSkuc2xpY2UoLUVUSEVSRVVNX0FERFJFU1NfQllURVMpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEVycm9yIGNvbnN0cnVjdGluZyBFdGhlcmV1bSBhZGRyZXNzOiAke2Vycm9yfWApO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGUgYW4gc2VjcDI1NmsxIGluc3RydWN0aW9uIHdpdGggYSBwdWJsaWMga2V5LiBUaGUgcHVibGljIGtleVxuICAgKiBtdXN0IGJlIGEgYnVmZmVyIHRoYXQgaXMgNjQgYnl0ZXMgbG9uZy5cbiAgICovXG4gIHN0YXRpYyBjcmVhdGVJbnN0cnVjdGlvbldpdGhQdWJsaWNLZXkocGFyYW1zKSB7XG4gICAgY29uc3Qge1xuICAgICAgcHVibGljS2V5LFxuICAgICAgbWVzc2FnZSxcbiAgICAgIHNpZ25hdHVyZSxcbiAgICAgIHJlY292ZXJ5SWQsXG4gICAgICBpbnN0cnVjdGlvbkluZGV4XG4gICAgfSA9IHBhcmFtcztcbiAgICByZXR1cm4gU2VjcDI1NmsxUHJvZ3JhbS5jcmVhdGVJbnN0cnVjdGlvbldpdGhFdGhBZGRyZXNzKHtcbiAgICAgIGV0aEFkZHJlc3M6IFNlY3AyNTZrMVByb2dyYW0ucHVibGljS2V5VG9FdGhBZGRyZXNzKHB1YmxpY0tleSksXG4gICAgICBtZXNzYWdlLFxuICAgICAgc2lnbmF0dXJlLFxuICAgICAgcmVjb3ZlcnlJZCxcbiAgICAgIGluc3RydWN0aW9uSW5kZXhcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGUgYW4gc2VjcDI1NmsxIGluc3RydWN0aW9uIHdpdGggYW4gRXRoZXJldW0gYWRkcmVzcy4gVGhlIGFkZHJlc3NcbiAgICogbXVzdCBiZSBhIGhleCBzdHJpbmcgb3IgYSBidWZmZXIgdGhhdCBpcyAyMCBieXRlcyBsb25nLlxuICAgKi9cbiAgc3RhdGljIGNyZWF0ZUluc3RydWN0aW9uV2l0aEV0aEFkZHJlc3MocGFyYW1zKSB7XG4gICAgY29uc3Qge1xuICAgICAgZXRoQWRkcmVzczogcmF3QWRkcmVzcyxcbiAgICAgIG1lc3NhZ2UsXG4gICAgICBzaWduYXR1cmUsXG4gICAgICByZWNvdmVyeUlkLFxuICAgICAgaW5zdHJ1Y3Rpb25JbmRleCA9IDBcbiAgICB9ID0gcGFyYW1zO1xuICAgIGxldCBldGhBZGRyZXNzO1xuICAgIGlmICh0eXBlb2YgcmF3QWRkcmVzcyA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGlmIChyYXdBZGRyZXNzLnN0YXJ0c1dpdGgoJzB4JykpIHtcbiAgICAgICAgZXRoQWRkcmVzcyA9IEJ1ZmZlci5mcm9tKHJhd0FkZHJlc3Muc3Vic3RyKDIpLCAnaGV4Jyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBldGhBZGRyZXNzID0gQnVmZmVyLmZyb20ocmF3QWRkcmVzcywgJ2hleCcpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBldGhBZGRyZXNzID0gcmF3QWRkcmVzcztcbiAgICB9XG4gICAgYXNzZXJ0KGV0aEFkZHJlc3MubGVuZ3RoID09PSBFVEhFUkVVTV9BRERSRVNTX0JZVEVTLCBgQWRkcmVzcyBtdXN0IGJlICR7RVRIRVJFVU1fQUREUkVTU19CWVRFU30gYnl0ZXMgYnV0IHJlY2VpdmVkICR7ZXRoQWRkcmVzcy5sZW5ndGh9IGJ5dGVzYCk7XG4gICAgY29uc3QgZGF0YVN0YXJ0ID0gMSArIFNJR05BVFVSRV9PRkZTRVRTX1NFUklBTElaRURfU0laRTtcbiAgICBjb25zdCBldGhBZGRyZXNzT2Zmc2V0ID0gZGF0YVN0YXJ0O1xuICAgIGNvbnN0IHNpZ25hdHVyZU9mZnNldCA9IGRhdGFTdGFydCArIGV0aEFkZHJlc3MubGVuZ3RoO1xuICAgIGNvbnN0IG1lc3NhZ2VEYXRhT2Zmc2V0ID0gc2lnbmF0dXJlT2Zmc2V0ICsgc2lnbmF0dXJlLmxlbmd0aCArIDE7XG4gICAgY29uc3QgbnVtU2lnbmF0dXJlcyA9IDE7XG4gICAgY29uc3QgaW5zdHJ1Y3Rpb25EYXRhID0gQnVmZmVyLmFsbG9jKFNFQ1AyNTZLMV9JTlNUUlVDVElPTl9MQVlPVVQuc3BhbiArIG1lc3NhZ2UubGVuZ3RoKTtcbiAgICBTRUNQMjU2SzFfSU5TVFJVQ1RJT05fTEFZT1VULmVuY29kZSh7XG4gICAgICBudW1TaWduYXR1cmVzLFxuICAgICAgc2lnbmF0dXJlT2Zmc2V0LFxuICAgICAgc2lnbmF0dXJlSW5zdHJ1Y3Rpb25JbmRleDogaW5zdHJ1Y3Rpb25JbmRleCxcbiAgICAgIGV0aEFkZHJlc3NPZmZzZXQsXG4gICAgICBldGhBZGRyZXNzSW5zdHJ1Y3Rpb25JbmRleDogaW5zdHJ1Y3Rpb25JbmRleCxcbiAgICAgIG1lc3NhZ2VEYXRhT2Zmc2V0LFxuICAgICAgbWVzc2FnZURhdGFTaXplOiBtZXNzYWdlLmxlbmd0aCxcbiAgICAgIG1lc3NhZ2VJbnN0cnVjdGlvbkluZGV4OiBpbnN0cnVjdGlvbkluZGV4LFxuICAgICAgc2lnbmF0dXJlOiB0b0J1ZmZlcihzaWduYXR1cmUpLFxuICAgICAgZXRoQWRkcmVzczogdG9CdWZmZXIoZXRoQWRkcmVzcyksXG4gICAgICByZWNvdmVyeUlkXG4gICAgfSwgaW5zdHJ1Y3Rpb25EYXRhKTtcbiAgICBpbnN0cnVjdGlvbkRhdGEuZmlsbCh0b0J1ZmZlcihtZXNzYWdlKSwgU0VDUDI1NksxX0lOU1RSVUNUSU9OX0xBWU9VVC5zcGFuKTtcbiAgICByZXR1cm4gbmV3IFRyYW5zYWN0aW9uSW5zdHJ1Y3Rpb24oe1xuICAgICAga2V5czogW10sXG4gICAgICBwcm9ncmFtSWQ6IFNlY3AyNTZrMVByb2dyYW0ucHJvZ3JhbUlkLFxuICAgICAgZGF0YTogaW5zdHJ1Y3Rpb25EYXRhXG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlIGFuIHNlY3AyNTZrMSBpbnN0cnVjdGlvbiB3aXRoIGEgcHJpdmF0ZSBrZXkuIFRoZSBwcml2YXRlIGtleVxuICAgKiBtdXN0IGJlIGEgYnVmZmVyIHRoYXQgaXMgMzIgYnl0ZXMgbG9uZy5cbiAgICovXG4gIHN0YXRpYyBjcmVhdGVJbnN0cnVjdGlvbldpdGhQcml2YXRlS2V5KHBhcmFtcykge1xuICAgIGNvbnN0IHtcbiAgICAgIHByaXZhdGVLZXk6IHBrZXksXG4gICAgICBtZXNzYWdlLFxuICAgICAgaW5zdHJ1Y3Rpb25JbmRleFxuICAgIH0gPSBwYXJhbXM7XG4gICAgYXNzZXJ0KHBrZXkubGVuZ3RoID09PSBQUklWQVRFX0tFWV9CWVRFUywgYFByaXZhdGUga2V5IG11c3QgYmUgJHtQUklWQVRFX0tFWV9CWVRFU30gYnl0ZXMgYnV0IHJlY2VpdmVkICR7cGtleS5sZW5ndGh9IGJ5dGVzYCk7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHByaXZhdGVLZXkgPSB0b0J1ZmZlcihwa2V5KTtcbiAgICAgIGNvbnN0IHB1YmxpY0tleSA9IHB1YmxpY0tleUNyZWF0ZShwcml2YXRlS2V5LCBmYWxzZSAvKiBpc0NvbXByZXNzZWQgKi8pLnNsaWNlKDEpOyAvLyB0aHJvdyBhd2F5IGxlYWRpbmcgYnl0ZVxuICAgICAgY29uc3QgbWVzc2FnZUhhc2ggPSBCdWZmZXIuZnJvbShrZWNjYWtfMjU2KHRvQnVmZmVyKG1lc3NhZ2UpKSk7XG4gICAgICBjb25zdCBbc2lnbmF0dXJlLCByZWNvdmVyeUlkXSA9IGVjZHNhU2lnbihtZXNzYWdlSGFzaCwgcHJpdmF0ZUtleSk7XG4gICAgICByZXR1cm4gdGhpcy5jcmVhdGVJbnN0cnVjdGlvbldpdGhQdWJsaWNLZXkoe1xuICAgICAgICBwdWJsaWNLZXksXG4gICAgICAgIG1lc3NhZ2UsXG4gICAgICAgIHNpZ25hdHVyZSxcbiAgICAgICAgcmVjb3ZlcnlJZCxcbiAgICAgICAgaW5zdHJ1Y3Rpb25JbmRleFxuICAgICAgfSk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgRXJyb3IgY3JlYXRpbmcgaW5zdHJ1Y3Rpb247ICR7ZXJyb3J9YCk7XG4gICAgfVxuICB9XG59XG5TZWNwMjU2azFQcm9ncmFtLnByb2dyYW1JZCA9IG5ldyBQdWJsaWNLZXkoJ0tlY2Nha1NlY3AyNTZrMTExMTExMTExMTExMTExMTExMTExMTExMTExMTEnKTtcblxudmFyIF9Mb2NrdXA7XG5cbi8qKlxuICogQWRkcmVzcyBvZiB0aGUgc3Rha2UgY29uZmlnIGFjY291bnQgd2hpY2ggY29uZmlndXJlcyB0aGUgcmF0ZVxuICogb2Ygc3Rha2Ugd2FybXVwIGFuZCBjb29sZG93biBhcyB3ZWxsIGFzIHRoZSBzbGFzaGluZyBwZW5hbHR5LlxuICovXG5jb25zdCBTVEFLRV9DT05GSUdfSUQgPSBuZXcgUHVibGljS2V5KCdTdGFrZUNvbmZpZzExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExJyk7XG5cbi8qKlxuICogU3Rha2UgYWNjb3VudCBhdXRob3JpdHkgaW5mb1xuICovXG5jbGFzcyBBdXRob3JpemVkIHtcbiAgLyoqXG4gICAqIENyZWF0ZSBhIG5ldyBBdXRob3JpemVkIG9iamVjdFxuICAgKiBAcGFyYW0gc3Rha2VyIHRoZSBzdGFrZSBhdXRob3JpdHlcbiAgICogQHBhcmFtIHdpdGhkcmF3ZXIgdGhlIHdpdGhkcmF3IGF1dGhvcml0eVxuICAgKi9cbiAgY29uc3RydWN0b3Ioc3Rha2VyLCB3aXRoZHJhd2VyKSB7XG4gICAgLyoqIHN0YWtlIGF1dGhvcml0eSAqL1xuICAgIHRoaXMuc3Rha2VyID0gdm9pZCAwO1xuICAgIC8qKiB3aXRoZHJhdyBhdXRob3JpdHkgKi9cbiAgICB0aGlzLndpdGhkcmF3ZXIgPSB2b2lkIDA7XG4gICAgdGhpcy5zdGFrZXIgPSBzdGFrZXI7XG4gICAgdGhpcy53aXRoZHJhd2VyID0gd2l0aGRyYXdlcjtcbiAgfVxufVxuLyoqXG4gKiBTdGFrZSBhY2NvdW50IGxvY2t1cCBpbmZvXG4gKi9cbmNsYXNzIExvY2t1cCB7XG4gIC8qKlxuICAgKiBDcmVhdGUgYSBuZXcgTG9ja3VwIG9iamVjdFxuICAgKi9cbiAgY29uc3RydWN0b3IodW5peFRpbWVzdGFtcCwgZXBvY2gsIGN1c3RvZGlhbikge1xuICAgIC8qKiBVbml4IHRpbWVzdGFtcCBvZiBsb2NrdXAgZXhwaXJhdGlvbiAqL1xuICAgIHRoaXMudW5peFRpbWVzdGFtcCA9IHZvaWQgMDtcbiAgICAvKiogRXBvY2ggb2YgbG9ja3VwIGV4cGlyYXRpb24gKi9cbiAgICB0aGlzLmVwb2NoID0gdm9pZCAwO1xuICAgIC8qKiBMb2NrdXAgY3VzdG9kaWFuIGF1dGhvcml0eSAqL1xuICAgIHRoaXMuY3VzdG9kaWFuID0gdm9pZCAwO1xuICAgIHRoaXMudW5peFRpbWVzdGFtcCA9IHVuaXhUaW1lc3RhbXA7XG4gICAgdGhpcy5lcG9jaCA9IGVwb2NoO1xuICAgIHRoaXMuY3VzdG9kaWFuID0gY3VzdG9kaWFuO1xuICB9XG5cbiAgLyoqXG4gICAqIERlZmF1bHQsIGluYWN0aXZlIExvY2t1cCB2YWx1ZVxuICAgKi9cbn1cbl9Mb2NrdXAgPSBMb2NrdXA7XG5Mb2NrdXAuZGVmYXVsdCA9IG5ldyBfTG9ja3VwKDAsIDAsIFB1YmxpY0tleS5kZWZhdWx0KTtcbi8qKlxuICogQ3JlYXRlIHN0YWtlIGFjY291bnQgdHJhbnNhY3Rpb24gcGFyYW1zXG4gKi9cbi8qKlxuICogQ3JlYXRlIHN0YWtlIGFjY291bnQgd2l0aCBzZWVkIHRyYW5zYWN0aW9uIHBhcmFtc1xuICovXG4vKipcbiAqIEluaXRpYWxpemUgc3Rha2UgaW5zdHJ1Y3Rpb24gcGFyYW1zXG4gKi9cbi8qKlxuICogRGVsZWdhdGUgc3Rha2UgaW5zdHJ1Y3Rpb24gcGFyYW1zXG4gKi9cbi8qKlxuICogQXV0aG9yaXplIHN0YWtlIGluc3RydWN0aW9uIHBhcmFtc1xuICovXG4vKipcbiAqIEF1dGhvcml6ZSBzdGFrZSBpbnN0cnVjdGlvbiBwYXJhbXMgdXNpbmcgYSBkZXJpdmVkIGtleVxuICovXG4vKipcbiAqIFNwbGl0IHN0YWtlIGluc3RydWN0aW9uIHBhcmFtc1xuICovXG4vKipcbiAqIFNwbGl0IHdpdGggc2VlZCB0cmFuc2FjdGlvbiBwYXJhbXNcbiAqL1xuLyoqXG4gKiBXaXRoZHJhdyBzdGFrZSBpbnN0cnVjdGlvbiBwYXJhbXNcbiAqL1xuLyoqXG4gKiBEZWFjdGl2YXRlIHN0YWtlIGluc3RydWN0aW9uIHBhcmFtc1xuICovXG4vKipcbiAqIE1lcmdlIHN0YWtlIGluc3RydWN0aW9uIHBhcmFtc1xuICovXG4vKipcbiAqIFN0YWtlIEluc3RydWN0aW9uIGNsYXNzXG4gKi9cbmNsYXNzIFN0YWtlSW5zdHJ1Y3Rpb24ge1xuICAvKipcbiAgICogQGludGVybmFsXG4gICAqL1xuICBjb25zdHJ1Y3RvcigpIHt9XG5cbiAgLyoqXG4gICAqIERlY29kZSBhIHN0YWtlIGluc3RydWN0aW9uIGFuZCByZXRyaWV2ZSB0aGUgaW5zdHJ1Y3Rpb24gdHlwZS5cbiAgICovXG4gIHN0YXRpYyBkZWNvZGVJbnN0cnVjdGlvblR5cGUoaW5zdHJ1Y3Rpb24pIHtcbiAgICB0aGlzLmNoZWNrUHJvZ3JhbUlkKGluc3RydWN0aW9uLnByb2dyYW1JZCk7XG4gICAgY29uc3QgaW5zdHJ1Y3Rpb25UeXBlTGF5b3V0ID0gQnVmZmVyTGF5b3V0LnUzMignaW5zdHJ1Y3Rpb24nKTtcbiAgICBjb25zdCB0eXBlSW5kZXggPSBpbnN0cnVjdGlvblR5cGVMYXlvdXQuZGVjb2RlKGluc3RydWN0aW9uLmRhdGEpO1xuICAgIGxldCB0eXBlO1xuICAgIGZvciAoY29uc3QgW2l4VHlwZSwgbGF5b3V0XSBvZiBPYmplY3QuZW50cmllcyhTVEFLRV9JTlNUUlVDVElPTl9MQVlPVVRTKSkge1xuICAgICAgaWYgKGxheW91dC5pbmRleCA9PSB0eXBlSW5kZXgpIHtcbiAgICAgICAgdHlwZSA9IGl4VHlwZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICghdHlwZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnN0cnVjdGlvbiB0eXBlIGluY29ycmVjdDsgbm90IGEgU3Rha2VJbnN0cnVjdGlvbicpO1xuICAgIH1cbiAgICByZXR1cm4gdHlwZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZWNvZGUgYSBpbml0aWFsaXplIHN0YWtlIGluc3RydWN0aW9uIGFuZCByZXRyaWV2ZSB0aGUgaW5zdHJ1Y3Rpb24gcGFyYW1zLlxuICAgKi9cbiAgc3RhdGljIGRlY29kZUluaXRpYWxpemUoaW5zdHJ1Y3Rpb24pIHtcbiAgICB0aGlzLmNoZWNrUHJvZ3JhbUlkKGluc3RydWN0aW9uLnByb2dyYW1JZCk7XG4gICAgdGhpcy5jaGVja0tleUxlbmd0aChpbnN0cnVjdGlvbi5rZXlzLCAyKTtcbiAgICBjb25zdCB7XG4gICAgICBhdXRob3JpemVkLFxuICAgICAgbG9ja3VwXG4gICAgfSA9IGRlY29kZURhdGEkMShTVEFLRV9JTlNUUlVDVElPTl9MQVlPVVRTLkluaXRpYWxpemUsIGluc3RydWN0aW9uLmRhdGEpO1xuICAgIHJldHVybiB7XG4gICAgICBzdGFrZVB1YmtleTogaW5zdHJ1Y3Rpb24ua2V5c1swXS5wdWJrZXksXG4gICAgICBhdXRob3JpemVkOiBuZXcgQXV0aG9yaXplZChuZXcgUHVibGljS2V5KGF1dGhvcml6ZWQuc3Rha2VyKSwgbmV3IFB1YmxpY0tleShhdXRob3JpemVkLndpdGhkcmF3ZXIpKSxcbiAgICAgIGxvY2t1cDogbmV3IExvY2t1cChsb2NrdXAudW5peFRpbWVzdGFtcCwgbG9ja3VwLmVwb2NoLCBuZXcgUHVibGljS2V5KGxvY2t1cC5jdXN0b2RpYW4pKVxuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogRGVjb2RlIGEgZGVsZWdhdGUgc3Rha2UgaW5zdHJ1Y3Rpb24gYW5kIHJldHJpZXZlIHRoZSBpbnN0cnVjdGlvbiBwYXJhbXMuXG4gICAqL1xuICBzdGF0aWMgZGVjb2RlRGVsZWdhdGUoaW5zdHJ1Y3Rpb24pIHtcbiAgICB0aGlzLmNoZWNrUHJvZ3JhbUlkKGluc3RydWN0aW9uLnByb2dyYW1JZCk7XG4gICAgdGhpcy5jaGVja0tleUxlbmd0aChpbnN0cnVjdGlvbi5rZXlzLCA2KTtcbiAgICBkZWNvZGVEYXRhJDEoU1RBS0VfSU5TVFJVQ1RJT05fTEFZT1VUUy5EZWxlZ2F0ZSwgaW5zdHJ1Y3Rpb24uZGF0YSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHN0YWtlUHVia2V5OiBpbnN0cnVjdGlvbi5rZXlzWzBdLnB1YmtleSxcbiAgICAgIHZvdGVQdWJrZXk6IGluc3RydWN0aW9uLmtleXNbMV0ucHVia2V5LFxuICAgICAgYXV0aG9yaXplZFB1YmtleTogaW5zdHJ1Y3Rpb24ua2V5c1s1XS5wdWJrZXlcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIERlY29kZSBhbiBhdXRob3JpemUgc3Rha2UgaW5zdHJ1Y3Rpb24gYW5kIHJldHJpZXZlIHRoZSBpbnN0cnVjdGlvbiBwYXJhbXMuXG4gICAqL1xuICBzdGF0aWMgZGVjb2RlQXV0aG9yaXplKGluc3RydWN0aW9uKSB7XG4gICAgdGhpcy5jaGVja1Byb2dyYW1JZChpbnN0cnVjdGlvbi5wcm9ncmFtSWQpO1xuICAgIHRoaXMuY2hlY2tLZXlMZW5ndGgoaW5zdHJ1Y3Rpb24ua2V5cywgMyk7XG4gICAgY29uc3Qge1xuICAgICAgbmV3QXV0aG9yaXplZCxcbiAgICAgIHN0YWtlQXV0aG9yaXphdGlvblR5cGVcbiAgICB9ID0gZGVjb2RlRGF0YSQxKFNUQUtFX0lOU1RSVUNUSU9OX0xBWU9VVFMuQXV0aG9yaXplLCBpbnN0cnVjdGlvbi5kYXRhKTtcbiAgICBjb25zdCBvID0ge1xuICAgICAgc3Rha2VQdWJrZXk6IGluc3RydWN0aW9uLmtleXNbMF0ucHVia2V5LFxuICAgICAgYXV0aG9yaXplZFB1YmtleTogaW5zdHJ1Y3Rpb24ua2V5c1syXS5wdWJrZXksXG4gICAgICBuZXdBdXRob3JpemVkUHVia2V5OiBuZXcgUHVibGljS2V5KG5ld0F1dGhvcml6ZWQpLFxuICAgICAgc3Rha2VBdXRob3JpemF0aW9uVHlwZToge1xuICAgICAgICBpbmRleDogc3Rha2VBdXRob3JpemF0aW9uVHlwZVxuICAgICAgfVxuICAgIH07XG4gICAgaWYgKGluc3RydWN0aW9uLmtleXMubGVuZ3RoID4gMykge1xuICAgICAgby5jdXN0b2RpYW5QdWJrZXkgPSBpbnN0cnVjdGlvbi5rZXlzWzNdLnB1YmtleTtcbiAgICB9XG4gICAgcmV0dXJuIG87XG4gIH1cblxuICAvKipcbiAgICogRGVjb2RlIGFuIGF1dGhvcml6ZS13aXRoLXNlZWQgc3Rha2UgaW5zdHJ1Y3Rpb24gYW5kIHJldHJpZXZlIHRoZSBpbnN0cnVjdGlvbiBwYXJhbXMuXG4gICAqL1xuICBzdGF0aWMgZGVjb2RlQXV0aG9yaXplV2l0aFNlZWQoaW5zdHJ1Y3Rpb24pIHtcbiAgICB0aGlzLmNoZWNrUHJvZ3JhbUlkKGluc3RydWN0aW9uLnByb2dyYW1JZCk7XG4gICAgdGhpcy5jaGVja0tleUxlbmd0aChpbnN0cnVjdGlvbi5rZXlzLCAyKTtcbiAgICBjb25zdCB7XG4gICAgICBuZXdBdXRob3JpemVkLFxuICAgICAgc3Rha2VBdXRob3JpemF0aW9uVHlwZSxcbiAgICAgIGF1dGhvcml0eVNlZWQsXG4gICAgICBhdXRob3JpdHlPd25lclxuICAgIH0gPSBkZWNvZGVEYXRhJDEoU1RBS0VfSU5TVFJVQ1RJT05fTEFZT1VUUy5BdXRob3JpemVXaXRoU2VlZCwgaW5zdHJ1Y3Rpb24uZGF0YSk7XG4gICAgY29uc3QgbyA9IHtcbiAgICAgIHN0YWtlUHVia2V5OiBpbnN0cnVjdGlvbi5rZXlzWzBdLnB1YmtleSxcbiAgICAgIGF1dGhvcml0eUJhc2U6IGluc3RydWN0aW9uLmtleXNbMV0ucHVia2V5LFxuICAgICAgYXV0aG9yaXR5U2VlZDogYXV0aG9yaXR5U2VlZCxcbiAgICAgIGF1dGhvcml0eU93bmVyOiBuZXcgUHVibGljS2V5KGF1dGhvcml0eU93bmVyKSxcbiAgICAgIG5ld0F1dGhvcml6ZWRQdWJrZXk6IG5ldyBQdWJsaWNLZXkobmV3QXV0aG9yaXplZCksXG4gICAgICBzdGFrZUF1dGhvcml6YXRpb25UeXBlOiB7XG4gICAgICAgIGluZGV4OiBzdGFrZUF1dGhvcml6YXRpb25UeXBlXG4gICAgICB9XG4gICAgfTtcbiAgICBpZiAoaW5zdHJ1Y3Rpb24ua2V5cy5sZW5ndGggPiAzKSB7XG4gICAgICBvLmN1c3RvZGlhblB1YmtleSA9IGluc3RydWN0aW9uLmtleXNbM10ucHVia2V5O1xuICAgIH1cbiAgICByZXR1cm4gbztcbiAgfVxuXG4gIC8qKlxuICAgKiBEZWNvZGUgYSBzcGxpdCBzdGFrZSBpbnN0cnVjdGlvbiBhbmQgcmV0cmlldmUgdGhlIGluc3RydWN0aW9uIHBhcmFtcy5cbiAgICovXG4gIHN0YXRpYyBkZWNvZGVTcGxpdChpbnN0cnVjdGlvbikge1xuICAgIHRoaXMuY2hlY2tQcm9ncmFtSWQoaW5zdHJ1Y3Rpb24ucHJvZ3JhbUlkKTtcbiAgICB0aGlzLmNoZWNrS2V5TGVuZ3RoKGluc3RydWN0aW9uLmtleXMsIDMpO1xuICAgIGNvbnN0IHtcbiAgICAgIGxhbXBvcnRzXG4gICAgfSA9IGRlY29kZURhdGEkMShTVEFLRV9JTlNUUlVDVElPTl9MQVlPVVRTLlNwbGl0LCBpbnN0cnVjdGlvbi5kYXRhKTtcbiAgICByZXR1cm4ge1xuICAgICAgc3Rha2VQdWJrZXk6IGluc3RydWN0aW9uLmtleXNbMF0ucHVia2V5LFxuICAgICAgc3BsaXRTdGFrZVB1YmtleTogaW5zdHJ1Y3Rpb24ua2V5c1sxXS5wdWJrZXksXG4gICAgICBhdXRob3JpemVkUHVia2V5OiBpbnN0cnVjdGlvbi5rZXlzWzJdLnB1YmtleSxcbiAgICAgIGxhbXBvcnRzXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZWNvZGUgYSBtZXJnZSBzdGFrZSBpbnN0cnVjdGlvbiBhbmQgcmV0cmlldmUgdGhlIGluc3RydWN0aW9uIHBhcmFtcy5cbiAgICovXG4gIHN0YXRpYyBkZWNvZGVNZXJnZShpbnN0cnVjdGlvbikge1xuICAgIHRoaXMuY2hlY2tQcm9ncmFtSWQoaW5zdHJ1Y3Rpb24ucHJvZ3JhbUlkKTtcbiAgICB0aGlzLmNoZWNrS2V5TGVuZ3RoKGluc3RydWN0aW9uLmtleXMsIDMpO1xuICAgIGRlY29kZURhdGEkMShTVEFLRV9JTlNUUlVDVElPTl9MQVlPVVRTLk1lcmdlLCBpbnN0cnVjdGlvbi5kYXRhKTtcbiAgICByZXR1cm4ge1xuICAgICAgc3Rha2VQdWJrZXk6IGluc3RydWN0aW9uLmtleXNbMF0ucHVia2V5LFxuICAgICAgc291cmNlU3Rha2VQdWJLZXk6IGluc3RydWN0aW9uLmtleXNbMV0ucHVia2V5LFxuICAgICAgYXV0aG9yaXplZFB1YmtleTogaW5zdHJ1Y3Rpb24ua2V5c1s0XS5wdWJrZXlcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIERlY29kZSBhIHdpdGhkcmF3IHN0YWtlIGluc3RydWN0aW9uIGFuZCByZXRyaWV2ZSB0aGUgaW5zdHJ1Y3Rpb24gcGFyYW1zLlxuICAgKi9cbiAgc3RhdGljIGRlY29kZVdpdGhkcmF3KGluc3RydWN0aW9uKSB7XG4gICAgdGhpcy5jaGVja1Byb2dyYW1JZChpbnN0cnVjdGlvbi5wcm9ncmFtSWQpO1xuICAgIHRoaXMuY2hlY2tLZXlMZW5ndGgoaW5zdHJ1Y3Rpb24ua2V5cywgNSk7XG4gICAgY29uc3Qge1xuICAgICAgbGFtcG9ydHNcbiAgICB9ID0gZGVjb2RlRGF0YSQxKFNUQUtFX0lOU1RSVUNUSU9OX0xBWU9VVFMuV2l0aGRyYXcsIGluc3RydWN0aW9uLmRhdGEpO1xuICAgIGNvbnN0IG8gPSB7XG4gICAgICBzdGFrZVB1YmtleTogaW5zdHJ1Y3Rpb24ua2V5c1swXS5wdWJrZXksXG4gICAgICB0b1B1YmtleTogaW5zdHJ1Y3Rpb24ua2V5c1sxXS5wdWJrZXksXG4gICAgICBhdXRob3JpemVkUHVia2V5OiBpbnN0cnVjdGlvbi5rZXlzWzRdLnB1YmtleSxcbiAgICAgIGxhbXBvcnRzXG4gICAgfTtcbiAgICBpZiAoaW5zdHJ1Y3Rpb24ua2V5cy5sZW5ndGggPiA1KSB7XG4gICAgICBvLmN1c3RvZGlhblB1YmtleSA9IGluc3RydWN0aW9uLmtleXNbNV0ucHVia2V5O1xuICAgIH1cbiAgICByZXR1cm4gbztcbiAgfVxuXG4gIC8qKlxuICAgKiBEZWNvZGUgYSBkZWFjdGl2YXRlIHN0YWtlIGluc3RydWN0aW9uIGFuZCByZXRyaWV2ZSB0aGUgaW5zdHJ1Y3Rpb24gcGFyYW1zLlxuICAgKi9cbiAgc3RhdGljIGRlY29kZURlYWN0aXZhdGUoaW5zdHJ1Y3Rpb24pIHtcbiAgICB0aGlzLmNoZWNrUHJvZ3JhbUlkKGluc3RydWN0aW9uLnByb2dyYW1JZCk7XG4gICAgdGhpcy5jaGVja0tleUxlbmd0aChpbnN0cnVjdGlvbi5rZXlzLCAzKTtcbiAgICBkZWNvZGVEYXRhJDEoU1RBS0VfSU5TVFJVQ1RJT05fTEFZT1VUUy5EZWFjdGl2YXRlLCBpbnN0cnVjdGlvbi5kYXRhKTtcbiAgICByZXR1cm4ge1xuICAgICAgc3Rha2VQdWJrZXk6IGluc3RydWN0aW9uLmtleXNbMF0ucHVia2V5LFxuICAgICAgYXV0aG9yaXplZFB1YmtleTogaW5zdHJ1Y3Rpb24ua2V5c1syXS5wdWJrZXlcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgc3RhdGljIGNoZWNrUHJvZ3JhbUlkKHByb2dyYW1JZCkge1xuICAgIGlmICghcHJvZ3JhbUlkLmVxdWFscyhTdGFrZVByb2dyYW0ucHJvZ3JhbUlkKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIGluc3RydWN0aW9uOyBwcm9ncmFtSWQgaXMgbm90IFN0YWtlUHJvZ3JhbScpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIHN0YXRpYyBjaGVja0tleUxlbmd0aChrZXlzLCBleHBlY3RlZExlbmd0aCkge1xuICAgIGlmIChrZXlzLmxlbmd0aCA8IGV4cGVjdGVkTGVuZ3RoKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYGludmFsaWQgaW5zdHJ1Y3Rpb247IGZvdW5kICR7a2V5cy5sZW5ndGh9IGtleXMsIGV4cGVjdGVkIGF0IGxlYXN0ICR7ZXhwZWN0ZWRMZW5ndGh9YCk7XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogQW4gZW51bWVyYXRpb24gb2YgdmFsaWQgU3Rha2VJbnN0cnVjdGlvblR5cGUnc1xuICovXG5cbi8qKlxuICogQW4gZW51bWVyYXRpb24gb2YgdmFsaWQgc3Rha2UgSW5zdHJ1Y3Rpb25UeXBlJ3NcbiAqIEBpbnRlcm5hbFxuICovXG5jb25zdCBTVEFLRV9JTlNUUlVDVElPTl9MQVlPVVRTID0gT2JqZWN0LmZyZWV6ZSh7XG4gIEluaXRpYWxpemU6IHtcbiAgICBpbmRleDogMCxcbiAgICBsYXlvdXQ6IEJ1ZmZlckxheW91dC5zdHJ1Y3QoW0J1ZmZlckxheW91dC51MzIoJ2luc3RydWN0aW9uJyksIGF1dGhvcml6ZWQoKSwgbG9ja3VwKCldKVxuICB9LFxuICBBdXRob3JpemU6IHtcbiAgICBpbmRleDogMSxcbiAgICBsYXlvdXQ6IEJ1ZmZlckxheW91dC5zdHJ1Y3QoW0J1ZmZlckxheW91dC51MzIoJ2luc3RydWN0aW9uJyksIHB1YmxpY0tleSgnbmV3QXV0aG9yaXplZCcpLCBCdWZmZXJMYXlvdXQudTMyKCdzdGFrZUF1dGhvcml6YXRpb25UeXBlJyldKVxuICB9LFxuICBEZWxlZ2F0ZToge1xuICAgIGluZGV4OiAyLFxuICAgIGxheW91dDogQnVmZmVyTGF5b3V0LnN0cnVjdChbQnVmZmVyTGF5b3V0LnUzMignaW5zdHJ1Y3Rpb24nKV0pXG4gIH0sXG4gIFNwbGl0OiB7XG4gICAgaW5kZXg6IDMsXG4gICAgbGF5b3V0OiBCdWZmZXJMYXlvdXQuc3RydWN0KFtCdWZmZXJMYXlvdXQudTMyKCdpbnN0cnVjdGlvbicpLCBCdWZmZXJMYXlvdXQubnM2NCgnbGFtcG9ydHMnKV0pXG4gIH0sXG4gIFdpdGhkcmF3OiB7XG4gICAgaW5kZXg6IDQsXG4gICAgbGF5b3V0OiBCdWZmZXJMYXlvdXQuc3RydWN0KFtCdWZmZXJMYXlvdXQudTMyKCdpbnN0cnVjdGlvbicpLCBCdWZmZXJMYXlvdXQubnM2NCgnbGFtcG9ydHMnKV0pXG4gIH0sXG4gIERlYWN0aXZhdGU6IHtcbiAgICBpbmRleDogNSxcbiAgICBsYXlvdXQ6IEJ1ZmZlckxheW91dC5zdHJ1Y3QoW0J1ZmZlckxheW91dC51MzIoJ2luc3RydWN0aW9uJyldKVxuICB9LFxuICBNZXJnZToge1xuICAgIGluZGV4OiA3LFxuICAgIGxheW91dDogQnVmZmVyTGF5b3V0LnN0cnVjdChbQnVmZmVyTGF5b3V0LnUzMignaW5zdHJ1Y3Rpb24nKV0pXG4gIH0sXG4gIEF1dGhvcml6ZVdpdGhTZWVkOiB7XG4gICAgaW5kZXg6IDgsXG4gICAgbGF5b3V0OiBCdWZmZXJMYXlvdXQuc3RydWN0KFtCdWZmZXJMYXlvdXQudTMyKCdpbnN0cnVjdGlvbicpLCBwdWJsaWNLZXkoJ25ld0F1dGhvcml6ZWQnKSwgQnVmZmVyTGF5b3V0LnUzMignc3Rha2VBdXRob3JpemF0aW9uVHlwZScpLCBydXN0U3RyaW5nKCdhdXRob3JpdHlTZWVkJyksIHB1YmxpY0tleSgnYXV0aG9yaXR5T3duZXInKV0pXG4gIH1cbn0pO1xuXG4vKipcbiAqIFN0YWtlIGF1dGhvcml6YXRpb24gdHlwZVxuICovXG5cbi8qKlxuICogQW4gZW51bWVyYXRpb24gb2YgdmFsaWQgU3Rha2VBdXRob3JpemF0aW9uTGF5b3V0J3NcbiAqL1xuY29uc3QgU3Rha2VBdXRob3JpemF0aW9uTGF5b3V0ID0gT2JqZWN0LmZyZWV6ZSh7XG4gIFN0YWtlcjoge1xuICAgIGluZGV4OiAwXG4gIH0sXG4gIFdpdGhkcmF3ZXI6IHtcbiAgICBpbmRleDogMVxuICB9XG59KTtcblxuLyoqXG4gKiBGYWN0b3J5IGNsYXNzIGZvciB0cmFuc2FjdGlvbnMgdG8gaW50ZXJhY3Qgd2l0aCB0aGUgU3Rha2UgcHJvZ3JhbVxuICovXG5jbGFzcyBTdGFrZVByb2dyYW0ge1xuICAvKipcbiAgICogQGludGVybmFsXG4gICAqL1xuICBjb25zdHJ1Y3RvcigpIHt9XG5cbiAgLyoqXG4gICAqIFB1YmxpYyBrZXkgdGhhdCBpZGVudGlmaWVzIHRoZSBTdGFrZSBwcm9ncmFtXG4gICAqL1xuXG4gIC8qKlxuICAgKiBHZW5lcmF0ZSBhbiBJbml0aWFsaXplIGluc3RydWN0aW9uIHRvIGFkZCB0byBhIFN0YWtlIENyZWF0ZSB0cmFuc2FjdGlvblxuICAgKi9cbiAgc3RhdGljIGluaXRpYWxpemUocGFyYW1zKSB7XG4gICAgY29uc3Qge1xuICAgICAgc3Rha2VQdWJrZXksXG4gICAgICBhdXRob3JpemVkLFxuICAgICAgbG9ja3VwOiBtYXliZUxvY2t1cFxuICAgIH0gPSBwYXJhbXM7XG4gICAgY29uc3QgbG9ja3VwID0gbWF5YmVMb2NrdXAgfHwgTG9ja3VwLmRlZmF1bHQ7XG4gICAgY29uc3QgdHlwZSA9IFNUQUtFX0lOU1RSVUNUSU9OX0xBWU9VVFMuSW5pdGlhbGl6ZTtcbiAgICBjb25zdCBkYXRhID0gZW5jb2RlRGF0YSh0eXBlLCB7XG4gICAgICBhdXRob3JpemVkOiB7XG4gICAgICAgIHN0YWtlcjogdG9CdWZmZXIoYXV0aG9yaXplZC5zdGFrZXIudG9CdWZmZXIoKSksXG4gICAgICAgIHdpdGhkcmF3ZXI6IHRvQnVmZmVyKGF1dGhvcml6ZWQud2l0aGRyYXdlci50b0J1ZmZlcigpKVxuICAgICAgfSxcbiAgICAgIGxvY2t1cDoge1xuICAgICAgICB1bml4VGltZXN0YW1wOiBsb2NrdXAudW5peFRpbWVzdGFtcCxcbiAgICAgICAgZXBvY2g6IGxvY2t1cC5lcG9jaCxcbiAgICAgICAgY3VzdG9kaWFuOiB0b0J1ZmZlcihsb2NrdXAuY3VzdG9kaWFuLnRvQnVmZmVyKCkpXG4gICAgICB9XG4gICAgfSk7XG4gICAgY29uc3QgaW5zdHJ1Y3Rpb25EYXRhID0ge1xuICAgICAga2V5czogW3tcbiAgICAgICAgcHVia2V5OiBzdGFrZVB1YmtleSxcbiAgICAgICAgaXNTaWduZXI6IGZhbHNlLFxuICAgICAgICBpc1dyaXRhYmxlOiB0cnVlXG4gICAgICB9LCB7XG4gICAgICAgIHB1YmtleTogU1lTVkFSX1JFTlRfUFVCS0VZLFxuICAgICAgICBpc1NpZ25lcjogZmFsc2UsXG4gICAgICAgIGlzV3JpdGFibGU6IGZhbHNlXG4gICAgICB9XSxcbiAgICAgIHByb2dyYW1JZDogdGhpcy5wcm9ncmFtSWQsXG4gICAgICBkYXRhXG4gICAgfTtcbiAgICByZXR1cm4gbmV3IFRyYW5zYWN0aW9uSW5zdHJ1Y3Rpb24oaW5zdHJ1Y3Rpb25EYXRhKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZW5lcmF0ZSBhIFRyYW5zYWN0aW9uIHRoYXQgY3JlYXRlcyBhIG5ldyBTdGFrZSBhY2NvdW50IGF0XG4gICAqICAgYW4gYWRkcmVzcyBnZW5lcmF0ZWQgd2l0aCBgZnJvbWAsIGEgc2VlZCwgYW5kIHRoZSBTdGFrZSBwcm9ncmFtSWRcbiAgICovXG4gIHN0YXRpYyBjcmVhdGVBY2NvdW50V2l0aFNlZWQocGFyYW1zKSB7XG4gICAgY29uc3QgdHJhbnNhY3Rpb24gPSBuZXcgVHJhbnNhY3Rpb24oKTtcbiAgICB0cmFuc2FjdGlvbi5hZGQoU3lzdGVtUHJvZ3JhbS5jcmVhdGVBY2NvdW50V2l0aFNlZWQoe1xuICAgICAgZnJvbVB1YmtleTogcGFyYW1zLmZyb21QdWJrZXksXG4gICAgICBuZXdBY2NvdW50UHVia2V5OiBwYXJhbXMuc3Rha2VQdWJrZXksXG4gICAgICBiYXNlUHVia2V5OiBwYXJhbXMuYmFzZVB1YmtleSxcbiAgICAgIHNlZWQ6IHBhcmFtcy5zZWVkLFxuICAgICAgbGFtcG9ydHM6IHBhcmFtcy5sYW1wb3J0cyxcbiAgICAgIHNwYWNlOiB0aGlzLnNwYWNlLFxuICAgICAgcHJvZ3JhbUlkOiB0aGlzLnByb2dyYW1JZFxuICAgIH0pKTtcbiAgICBjb25zdCB7XG4gICAgICBzdGFrZVB1YmtleSxcbiAgICAgIGF1dGhvcml6ZWQsXG4gICAgICBsb2NrdXBcbiAgICB9ID0gcGFyYW1zO1xuICAgIHJldHVybiB0cmFuc2FjdGlvbi5hZGQodGhpcy5pbml0aWFsaXplKHtcbiAgICAgIHN0YWtlUHVia2V5LFxuICAgICAgYXV0aG9yaXplZCxcbiAgICAgIGxvY2t1cFxuICAgIH0pKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZW5lcmF0ZSBhIFRyYW5zYWN0aW9uIHRoYXQgY3JlYXRlcyBhIG5ldyBTdGFrZSBhY2NvdW50XG4gICAqL1xuICBzdGF0aWMgY3JlYXRlQWNjb3VudChwYXJhbXMpIHtcbiAgICBjb25zdCB0cmFuc2FjdGlvbiA9IG5ldyBUcmFuc2FjdGlvbigpO1xuICAgIHRyYW5zYWN0aW9uLmFkZChTeXN0ZW1Qcm9ncmFtLmNyZWF0ZUFjY291bnQoe1xuICAgICAgZnJvbVB1YmtleTogcGFyYW1zLmZyb21QdWJrZXksXG4gICAgICBuZXdBY2NvdW50UHVia2V5OiBwYXJhbXMuc3Rha2VQdWJrZXksXG4gICAgICBsYW1wb3J0czogcGFyYW1zLmxhbXBvcnRzLFxuICAgICAgc3BhY2U6IHRoaXMuc3BhY2UsXG4gICAgICBwcm9ncmFtSWQ6IHRoaXMucHJvZ3JhbUlkXG4gICAgfSkpO1xuICAgIGNvbnN0IHtcbiAgICAgIHN0YWtlUHVia2V5LFxuICAgICAgYXV0aG9yaXplZCxcbiAgICAgIGxvY2t1cFxuICAgIH0gPSBwYXJhbXM7XG4gICAgcmV0dXJuIHRyYW5zYWN0aW9uLmFkZCh0aGlzLmluaXRpYWxpemUoe1xuICAgICAgc3Rha2VQdWJrZXksXG4gICAgICBhdXRob3JpemVkLFxuICAgICAgbG9ja3VwXG4gICAgfSkpO1xuICB9XG5cbiAgLyoqXG4gICAqIEdlbmVyYXRlIGEgVHJhbnNhY3Rpb24gdGhhdCBkZWxlZ2F0ZXMgU3Rha2UgdG9rZW5zIHRvIGEgdmFsaWRhdG9yXG4gICAqIFZvdGUgUHVibGljS2V5LiBUaGlzIHRyYW5zYWN0aW9uIGNhbiBhbHNvIGJlIHVzZWQgdG8gcmVkZWxlZ2F0ZSBTdGFrZVxuICAgKiB0byBhIG5ldyB2YWxpZGF0b3IgVm90ZSBQdWJsaWNLZXkuXG4gICAqL1xuICBzdGF0aWMgZGVsZWdhdGUocGFyYW1zKSB7XG4gICAgY29uc3Qge1xuICAgICAgc3Rha2VQdWJrZXksXG4gICAgICBhdXRob3JpemVkUHVia2V5LFxuICAgICAgdm90ZVB1YmtleVxuICAgIH0gPSBwYXJhbXM7XG4gICAgY29uc3QgdHlwZSA9IFNUQUtFX0lOU1RSVUNUSU9OX0xBWU9VVFMuRGVsZWdhdGU7XG4gICAgY29uc3QgZGF0YSA9IGVuY29kZURhdGEodHlwZSk7XG4gICAgcmV0dXJuIG5ldyBUcmFuc2FjdGlvbigpLmFkZCh7XG4gICAgICBrZXlzOiBbe1xuICAgICAgICBwdWJrZXk6IHN0YWtlUHVia2V5LFxuICAgICAgICBpc1NpZ25lcjogZmFsc2UsXG4gICAgICAgIGlzV3JpdGFibGU6IHRydWVcbiAgICAgIH0sIHtcbiAgICAgICAgcHVia2V5OiB2b3RlUHVia2V5LFxuICAgICAgICBpc1NpZ25lcjogZmFsc2UsXG4gICAgICAgIGlzV3JpdGFibGU6IGZhbHNlXG4gICAgICB9LCB7XG4gICAgICAgIHB1YmtleTogU1lTVkFSX0NMT0NLX1BVQktFWSxcbiAgICAgICAgaXNTaWduZXI6IGZhbHNlLFxuICAgICAgICBpc1dyaXRhYmxlOiBmYWxzZVxuICAgICAgfSwge1xuICAgICAgICBwdWJrZXk6IFNZU1ZBUl9TVEFLRV9ISVNUT1JZX1BVQktFWSxcbiAgICAgICAgaXNTaWduZXI6IGZhbHNlLFxuICAgICAgICBpc1dyaXRhYmxlOiBmYWxzZVxuICAgICAgfSwge1xuICAgICAgICBwdWJrZXk6IFNUQUtFX0NPTkZJR19JRCxcbiAgICAgICAgaXNTaWduZXI6IGZhbHNlLFxuICAgICAgICBpc1dyaXRhYmxlOiBmYWxzZVxuICAgICAgfSwge1xuICAgICAgICBwdWJrZXk6IGF1dGhvcml6ZWRQdWJrZXksXG4gICAgICAgIGlzU2lnbmVyOiB0cnVlLFxuICAgICAgICBpc1dyaXRhYmxlOiBmYWxzZVxuICAgICAgfV0sXG4gICAgICBwcm9ncmFtSWQ6IHRoaXMucHJvZ3JhbUlkLFxuICAgICAgZGF0YVxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEdlbmVyYXRlIGEgVHJhbnNhY3Rpb24gdGhhdCBhdXRob3JpemVzIGEgbmV3IFB1YmxpY0tleSBhcyBTdGFrZXJcbiAgICogb3IgV2l0aGRyYXdlciBvbiB0aGUgU3Rha2UgYWNjb3VudC5cbiAgICovXG4gIHN0YXRpYyBhdXRob3JpemUocGFyYW1zKSB7XG4gICAgY29uc3Qge1xuICAgICAgc3Rha2VQdWJrZXksXG4gICAgICBhdXRob3JpemVkUHVia2V5LFxuICAgICAgbmV3QXV0aG9yaXplZFB1YmtleSxcbiAgICAgIHN0YWtlQXV0aG9yaXphdGlvblR5cGUsXG4gICAgICBjdXN0b2RpYW5QdWJrZXlcbiAgICB9ID0gcGFyYW1zO1xuICAgIGNvbnN0IHR5cGUgPSBTVEFLRV9JTlNUUlVDVElPTl9MQVlPVVRTLkF1dGhvcml6ZTtcbiAgICBjb25zdCBkYXRhID0gZW5jb2RlRGF0YSh0eXBlLCB7XG4gICAgICBuZXdBdXRob3JpemVkOiB0b0J1ZmZlcihuZXdBdXRob3JpemVkUHVia2V5LnRvQnVmZmVyKCkpLFxuICAgICAgc3Rha2VBdXRob3JpemF0aW9uVHlwZTogc3Rha2VBdXRob3JpemF0aW9uVHlwZS5pbmRleFxuICAgIH0pO1xuICAgIGNvbnN0IGtleXMgPSBbe1xuICAgICAgcHVia2V5OiBzdGFrZVB1YmtleSxcbiAgICAgIGlzU2lnbmVyOiBmYWxzZSxcbiAgICAgIGlzV3JpdGFibGU6IHRydWVcbiAgICB9LCB7XG4gICAgICBwdWJrZXk6IFNZU1ZBUl9DTE9DS19QVUJLRVksXG4gICAgICBpc1NpZ25lcjogZmFsc2UsXG4gICAgICBpc1dyaXRhYmxlOiB0cnVlXG4gICAgfSwge1xuICAgICAgcHVia2V5OiBhdXRob3JpemVkUHVia2V5LFxuICAgICAgaXNTaWduZXI6IHRydWUsXG4gICAgICBpc1dyaXRhYmxlOiBmYWxzZVxuICAgIH1dO1xuICAgIGlmIChjdXN0b2RpYW5QdWJrZXkpIHtcbiAgICAgIGtleXMucHVzaCh7XG4gICAgICAgIHB1YmtleTogY3VzdG9kaWFuUHVia2V5LFxuICAgICAgICBpc1NpZ25lcjogdHJ1ZSxcbiAgICAgICAgaXNXcml0YWJsZTogZmFsc2VcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IFRyYW5zYWN0aW9uKCkuYWRkKHtcbiAgICAgIGtleXMsXG4gICAgICBwcm9ncmFtSWQ6IHRoaXMucHJvZ3JhbUlkLFxuICAgICAgZGF0YVxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEdlbmVyYXRlIGEgVHJhbnNhY3Rpb24gdGhhdCBhdXRob3JpemVzIGEgbmV3IFB1YmxpY0tleSBhcyBTdGFrZXJcbiAgICogb3IgV2l0aGRyYXdlciBvbiB0aGUgU3Rha2UgYWNjb3VudC5cbiAgICovXG4gIHN0YXRpYyBhdXRob3JpemVXaXRoU2VlZChwYXJhbXMpIHtcbiAgICBjb25zdCB7XG4gICAgICBzdGFrZVB1YmtleSxcbiAgICAgIGF1dGhvcml0eUJhc2UsXG4gICAgICBhdXRob3JpdHlTZWVkLFxuICAgICAgYXV0aG9yaXR5T3duZXIsXG4gICAgICBuZXdBdXRob3JpemVkUHVia2V5LFxuICAgICAgc3Rha2VBdXRob3JpemF0aW9uVHlwZSxcbiAgICAgIGN1c3RvZGlhblB1YmtleVxuICAgIH0gPSBwYXJhbXM7XG4gICAgY29uc3QgdHlwZSA9IFNUQUtFX0lOU1RSVUNUSU9OX0xBWU9VVFMuQXV0aG9yaXplV2l0aFNlZWQ7XG4gICAgY29uc3QgZGF0YSA9IGVuY29kZURhdGEodHlwZSwge1xuICAgICAgbmV3QXV0aG9yaXplZDogdG9CdWZmZXIobmV3QXV0aG9yaXplZFB1YmtleS50b0J1ZmZlcigpKSxcbiAgICAgIHN0YWtlQXV0aG9yaXphdGlvblR5cGU6IHN0YWtlQXV0aG9yaXphdGlvblR5cGUuaW5kZXgsXG4gICAgICBhdXRob3JpdHlTZWVkOiBhdXRob3JpdHlTZWVkLFxuICAgICAgYXV0aG9yaXR5T3duZXI6IHRvQnVmZmVyKGF1dGhvcml0eU93bmVyLnRvQnVmZmVyKCkpXG4gICAgfSk7XG4gICAgY29uc3Qga2V5cyA9IFt7XG4gICAgICBwdWJrZXk6IHN0YWtlUHVia2V5LFxuICAgICAgaXNTaWduZXI6IGZhbHNlLFxuICAgICAgaXNXcml0YWJsZTogdHJ1ZVxuICAgIH0sIHtcbiAgICAgIHB1YmtleTogYXV0aG9yaXR5QmFzZSxcbiAgICAgIGlzU2lnbmVyOiB0cnVlLFxuICAgICAgaXNXcml0YWJsZTogZmFsc2VcbiAgICB9LCB7XG4gICAgICBwdWJrZXk6IFNZU1ZBUl9DTE9DS19QVUJLRVksXG4gICAgICBpc1NpZ25lcjogZmFsc2UsXG4gICAgICBpc1dyaXRhYmxlOiBmYWxzZVxuICAgIH1dO1xuICAgIGlmIChjdXN0b2RpYW5QdWJrZXkpIHtcbiAgICAgIGtleXMucHVzaCh7XG4gICAgICAgIHB1YmtleTogY3VzdG9kaWFuUHVia2V5LFxuICAgICAgICBpc1NpZ25lcjogdHJ1ZSxcbiAgICAgICAgaXNXcml0YWJsZTogZmFsc2VcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IFRyYW5zYWN0aW9uKCkuYWRkKHtcbiAgICAgIGtleXMsXG4gICAgICBwcm9ncmFtSWQ6IHRoaXMucHJvZ3JhbUlkLFxuICAgICAgZGF0YVxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgc3RhdGljIHNwbGl0SW5zdHJ1Y3Rpb24ocGFyYW1zKSB7XG4gICAgY29uc3Qge1xuICAgICAgc3Rha2VQdWJrZXksXG4gICAgICBhdXRob3JpemVkUHVia2V5LFxuICAgICAgc3BsaXRTdGFrZVB1YmtleSxcbiAgICAgIGxhbXBvcnRzXG4gICAgfSA9IHBhcmFtcztcbiAgICBjb25zdCB0eXBlID0gU1RBS0VfSU5TVFJVQ1RJT05fTEFZT1VUUy5TcGxpdDtcbiAgICBjb25zdCBkYXRhID0gZW5jb2RlRGF0YSh0eXBlLCB7XG4gICAgICBsYW1wb3J0c1xuICAgIH0pO1xuICAgIHJldHVybiBuZXcgVHJhbnNhY3Rpb25JbnN0cnVjdGlvbih7XG4gICAgICBrZXlzOiBbe1xuICAgICAgICBwdWJrZXk6IHN0YWtlUHVia2V5LFxuICAgICAgICBpc1NpZ25lcjogZmFsc2UsXG4gICAgICAgIGlzV3JpdGFibGU6IHRydWVcbiAgICAgIH0sIHtcbiAgICAgICAgcHVia2V5OiBzcGxpdFN0YWtlUHVia2V5LFxuICAgICAgICBpc1NpZ25lcjogZmFsc2UsXG4gICAgICAgIGlzV3JpdGFibGU6IHRydWVcbiAgICAgIH0sIHtcbiAgICAgICAgcHVia2V5OiBhdXRob3JpemVkUHVia2V5LFxuICAgICAgICBpc1NpZ25lcjogdHJ1ZSxcbiAgICAgICAgaXNXcml0YWJsZTogZmFsc2VcbiAgICAgIH1dLFxuICAgICAgcHJvZ3JhbUlkOiB0aGlzLnByb2dyYW1JZCxcbiAgICAgIGRhdGFcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZW5lcmF0ZSBhIFRyYW5zYWN0aW9uIHRoYXQgc3BsaXRzIFN0YWtlIHRva2VucyBpbnRvIGFub3RoZXIgc3Rha2UgYWNjb3VudFxuICAgKi9cbiAgc3RhdGljIHNwbGl0KHBhcmFtcyxcbiAgLy8gQ29tcHV0ZSB0aGUgY29zdCBvZiBhbGxvY2F0aW5nIHRoZSBuZXcgc3Rha2UgYWNjb3VudCBpbiBsYW1wb3J0c1xuICByZW50RXhlbXB0UmVzZXJ2ZSkge1xuICAgIGNvbnN0IHRyYW5zYWN0aW9uID0gbmV3IFRyYW5zYWN0aW9uKCk7XG4gICAgdHJhbnNhY3Rpb24uYWRkKFN5c3RlbVByb2dyYW0uY3JlYXRlQWNjb3VudCh7XG4gICAgICBmcm9tUHVia2V5OiBwYXJhbXMuYXV0aG9yaXplZFB1YmtleSxcbiAgICAgIG5ld0FjY291bnRQdWJrZXk6IHBhcmFtcy5zcGxpdFN0YWtlUHVia2V5LFxuICAgICAgbGFtcG9ydHM6IHJlbnRFeGVtcHRSZXNlcnZlLFxuICAgICAgc3BhY2U6IHRoaXMuc3BhY2UsXG4gICAgICBwcm9ncmFtSWQ6IHRoaXMucHJvZ3JhbUlkXG4gICAgfSkpO1xuICAgIHJldHVybiB0cmFuc2FjdGlvbi5hZGQodGhpcy5zcGxpdEluc3RydWN0aW9uKHBhcmFtcykpO1xuICB9XG5cbiAgLyoqXG4gICAqIEdlbmVyYXRlIGEgVHJhbnNhY3Rpb24gdGhhdCBzcGxpdHMgU3Rha2UgdG9rZW5zIGludG8gYW5vdGhlciBhY2NvdW50XG4gICAqIGRlcml2ZWQgZnJvbSBhIGJhc2UgcHVibGljIGtleSBhbmQgc2VlZFxuICAgKi9cbiAgc3RhdGljIHNwbGl0V2l0aFNlZWQocGFyYW1zLFxuICAvLyBJZiB0aGlzIHN0YWtlIGFjY291bnQgaXMgbmV3LCBjb21wdXRlIHRoZSBjb3N0IG9mIGFsbG9jYXRpbmcgaXQgaW4gbGFtcG9ydHNcbiAgcmVudEV4ZW1wdFJlc2VydmUpIHtcbiAgICBjb25zdCB7XG4gICAgICBzdGFrZVB1YmtleSxcbiAgICAgIGF1dGhvcml6ZWRQdWJrZXksXG4gICAgICBzcGxpdFN0YWtlUHVia2V5LFxuICAgICAgYmFzZVB1YmtleSxcbiAgICAgIHNlZWQsXG4gICAgICBsYW1wb3J0c1xuICAgIH0gPSBwYXJhbXM7XG4gICAgY29uc3QgdHJhbnNhY3Rpb24gPSBuZXcgVHJhbnNhY3Rpb24oKTtcbiAgICB0cmFuc2FjdGlvbi5hZGQoU3lzdGVtUHJvZ3JhbS5hbGxvY2F0ZSh7XG4gICAgICBhY2NvdW50UHVia2V5OiBzcGxpdFN0YWtlUHVia2V5LFxuICAgICAgYmFzZVB1YmtleSxcbiAgICAgIHNlZWQsXG4gICAgICBzcGFjZTogdGhpcy5zcGFjZSxcbiAgICAgIHByb2dyYW1JZDogdGhpcy5wcm9ncmFtSWRcbiAgICB9KSk7XG4gICAgaWYgKHJlbnRFeGVtcHRSZXNlcnZlICYmIHJlbnRFeGVtcHRSZXNlcnZlID4gMCkge1xuICAgICAgdHJhbnNhY3Rpb24uYWRkKFN5c3RlbVByb2dyYW0udHJhbnNmZXIoe1xuICAgICAgICBmcm9tUHVia2V5OiBwYXJhbXMuYXV0aG9yaXplZFB1YmtleSxcbiAgICAgICAgdG9QdWJrZXk6IHNwbGl0U3Rha2VQdWJrZXksXG4gICAgICAgIGxhbXBvcnRzOiByZW50RXhlbXB0UmVzZXJ2ZVxuICAgICAgfSkpO1xuICAgIH1cbiAgICByZXR1cm4gdHJhbnNhY3Rpb24uYWRkKHRoaXMuc3BsaXRJbnN0cnVjdGlvbih7XG4gICAgICBzdGFrZVB1YmtleSxcbiAgICAgIGF1dGhvcml6ZWRQdWJrZXksXG4gICAgICBzcGxpdFN0YWtlUHVia2V5LFxuICAgICAgbGFtcG9ydHNcbiAgICB9KSk7XG4gIH1cblxuICAvKipcbiAgICogR2VuZXJhdGUgYSBUcmFuc2FjdGlvbiB0aGF0IG1lcmdlcyBTdGFrZSBhY2NvdW50cy5cbiAgICovXG4gIHN0YXRpYyBtZXJnZShwYXJhbXMpIHtcbiAgICBjb25zdCB7XG4gICAgICBzdGFrZVB1YmtleSxcbiAgICAgIHNvdXJjZVN0YWtlUHViS2V5LFxuICAgICAgYXV0aG9yaXplZFB1YmtleVxuICAgIH0gPSBwYXJhbXM7XG4gICAgY29uc3QgdHlwZSA9IFNUQUtFX0lOU1RSVUNUSU9OX0xBWU9VVFMuTWVyZ2U7XG4gICAgY29uc3QgZGF0YSA9IGVuY29kZURhdGEodHlwZSk7XG4gICAgcmV0dXJuIG5ldyBUcmFuc2FjdGlvbigpLmFkZCh7XG4gICAgICBrZXlzOiBbe1xuICAgICAgICBwdWJrZXk6IHN0YWtlUHVia2V5LFxuICAgICAgICBpc1NpZ25lcjogZmFsc2UsXG4gICAgICAgIGlzV3JpdGFibGU6IHRydWVcbiAgICAgIH0sIHtcbiAgICAgICAgcHVia2V5OiBzb3VyY2VTdGFrZVB1YktleSxcbiAgICAgICAgaXNTaWduZXI6IGZhbHNlLFxuICAgICAgICBpc1dyaXRhYmxlOiB0cnVlXG4gICAgICB9LCB7XG4gICAgICAgIHB1YmtleTogU1lTVkFSX0NMT0NLX1BVQktFWSxcbiAgICAgICAgaXNTaWduZXI6IGZhbHNlLFxuICAgICAgICBpc1dyaXRhYmxlOiBmYWxzZVxuICAgICAgfSwge1xuICAgICAgICBwdWJrZXk6IFNZU1ZBUl9TVEFLRV9ISVNUT1JZX1BVQktFWSxcbiAgICAgICAgaXNTaWduZXI6IGZhbHNlLFxuICAgICAgICBpc1dyaXRhYmxlOiBmYWxzZVxuICAgICAgfSwge1xuICAgICAgICBwdWJrZXk6IGF1dGhvcml6ZWRQdWJrZXksXG4gICAgICAgIGlzU2lnbmVyOiB0cnVlLFxuICAgICAgICBpc1dyaXRhYmxlOiBmYWxzZVxuICAgICAgfV0sXG4gICAgICBwcm9ncmFtSWQ6IHRoaXMucHJvZ3JhbUlkLFxuICAgICAgZGF0YVxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEdlbmVyYXRlIGEgVHJhbnNhY3Rpb24gdGhhdCB3aXRoZHJhd3MgZGVhY3RpdmF0ZWQgU3Rha2UgdG9rZW5zLlxuICAgKi9cbiAgc3RhdGljIHdpdGhkcmF3KHBhcmFtcykge1xuICAgIGNvbnN0IHtcbiAgICAgIHN0YWtlUHVia2V5LFxuICAgICAgYXV0aG9yaXplZFB1YmtleSxcbiAgICAgIHRvUHVia2V5LFxuICAgICAgbGFtcG9ydHMsXG4gICAgICBjdXN0b2RpYW5QdWJrZXlcbiAgICB9ID0gcGFyYW1zO1xuICAgIGNvbnN0IHR5cGUgPSBTVEFLRV9JTlNUUlVDVElPTl9MQVlPVVRTLldpdGhkcmF3O1xuICAgIGNvbnN0IGRhdGEgPSBlbmNvZGVEYXRhKHR5cGUsIHtcbiAgICAgIGxhbXBvcnRzXG4gICAgfSk7XG4gICAgY29uc3Qga2V5cyA9IFt7XG4gICAgICBwdWJrZXk6IHN0YWtlUHVia2V5LFxuICAgICAgaXNTaWduZXI6IGZhbHNlLFxuICAgICAgaXNXcml0YWJsZTogdHJ1ZVxuICAgIH0sIHtcbiAgICAgIHB1YmtleTogdG9QdWJrZXksXG4gICAgICBpc1NpZ25lcjogZmFsc2UsXG4gICAgICBpc1dyaXRhYmxlOiB0cnVlXG4gICAgfSwge1xuICAgICAgcHVia2V5OiBTWVNWQVJfQ0xPQ0tfUFVCS0VZLFxuICAgICAgaXNTaWduZXI6IGZhbHNlLFxuICAgICAgaXNXcml0YWJsZTogZmFsc2VcbiAgICB9LCB7XG4gICAgICBwdWJrZXk6IFNZU1ZBUl9TVEFLRV9ISVNUT1JZX1BVQktFWSxcbiAgICAgIGlzU2lnbmVyOiBmYWxzZSxcbiAgICAgIGlzV3JpdGFibGU6IGZhbHNlXG4gICAgfSwge1xuICAgICAgcHVia2V5OiBhdXRob3JpemVkUHVia2V5LFxuICAgICAgaXNTaWduZXI6IHRydWUsXG4gICAgICBpc1dyaXRhYmxlOiBmYWxzZVxuICAgIH1dO1xuICAgIGlmIChjdXN0b2RpYW5QdWJrZXkpIHtcbiAgICAgIGtleXMucHVzaCh7XG4gICAgICAgIHB1YmtleTogY3VzdG9kaWFuUHVia2V5LFxuICAgICAgICBpc1NpZ25lcjogdHJ1ZSxcbiAgICAgICAgaXNXcml0YWJsZTogZmFsc2VcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IFRyYW5zYWN0aW9uKCkuYWRkKHtcbiAgICAgIGtleXMsXG4gICAgICBwcm9ncmFtSWQ6IHRoaXMucHJvZ3JhbUlkLFxuICAgICAgZGF0YVxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEdlbmVyYXRlIGEgVHJhbnNhY3Rpb24gdGhhdCBkZWFjdGl2YXRlcyBTdGFrZSB0b2tlbnMuXG4gICAqL1xuICBzdGF0aWMgZGVhY3RpdmF0ZShwYXJhbXMpIHtcbiAgICBjb25zdCB7XG4gICAgICBzdGFrZVB1YmtleSxcbiAgICAgIGF1dGhvcml6ZWRQdWJrZXlcbiAgICB9ID0gcGFyYW1zO1xuICAgIGNvbnN0IHR5cGUgPSBTVEFLRV9JTlNUUlVDVElPTl9MQVlPVVRTLkRlYWN0aXZhdGU7XG4gICAgY29uc3QgZGF0YSA9IGVuY29kZURhdGEodHlwZSk7XG4gICAgcmV0dXJuIG5ldyBUcmFuc2FjdGlvbigpLmFkZCh7XG4gICAgICBrZXlzOiBbe1xuICAgICAgICBwdWJrZXk6IHN0YWtlUHVia2V5LFxuICAgICAgICBpc1NpZ25lcjogZmFsc2UsXG4gICAgICAgIGlzV3JpdGFibGU6IHRydWVcbiAgICAgIH0sIHtcbiAgICAgICAgcHVia2V5OiBTWVNWQVJfQ0xPQ0tfUFVCS0VZLFxuICAgICAgICBpc1NpZ25lcjogZmFsc2UsXG4gICAgICAgIGlzV3JpdGFibGU6IGZhbHNlXG4gICAgICB9LCB7XG4gICAgICAgIHB1YmtleTogYXV0aG9yaXplZFB1YmtleSxcbiAgICAgICAgaXNTaWduZXI6IHRydWUsXG4gICAgICAgIGlzV3JpdGFibGU6IGZhbHNlXG4gICAgICB9XSxcbiAgICAgIHByb2dyYW1JZDogdGhpcy5wcm9ncmFtSWQsXG4gICAgICBkYXRhXG4gICAgfSk7XG4gIH1cbn1cblN0YWtlUHJvZ3JhbS5wcm9ncmFtSWQgPSBuZXcgUHVibGljS2V5KCdTdGFrZTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExJyk7XG4vKipcbiAqIE1heCBzcGFjZSBvZiBhIFN0YWtlIGFjY291bnRcbiAqXG4gKiBUaGlzIGlzIGdlbmVyYXRlZCBmcm9tIHRoZSBzb2xhbmEtc3Rha2UtcHJvZ3JhbSBTdGFrZVN0YXRlIHN0cnVjdCBhc1xuICogYFN0YWtlU3RhdGVWMjo6c2l6ZV9vZigpYDpcbiAqIGh0dHBzOi8vZG9jcy5ycy9zb2xhbmEtc3Rha2UtcHJvZ3JhbS9sYXRlc3Qvc29sYW5hX3N0YWtlX3Byb2dyYW0vc3Rha2Vfc3RhdGUvZW51bS5TdGFrZVN0YXRlVjIuaHRtbFxuICovXG5TdGFrZVByb2dyYW0uc3BhY2UgPSAyMDA7XG5cbi8qKlxuICogVm90ZSBhY2NvdW50IGluZm9cbiAqL1xuY2xhc3MgVm90ZUluaXQge1xuICAvKiogWzAsIDEwMF0gKi9cblxuICBjb25zdHJ1Y3Rvcihub2RlUHVia2V5LCBhdXRob3JpemVkVm90ZXIsIGF1dGhvcml6ZWRXaXRoZHJhd2VyLCBjb21taXNzaW9uKSB7XG4gICAgdGhpcy5ub2RlUHVia2V5ID0gdm9pZCAwO1xuICAgIHRoaXMuYXV0aG9yaXplZFZvdGVyID0gdm9pZCAwO1xuICAgIHRoaXMuYXV0aG9yaXplZFdpdGhkcmF3ZXIgPSB2b2lkIDA7XG4gICAgdGhpcy5jb21taXNzaW9uID0gdm9pZCAwO1xuICAgIHRoaXMubm9kZVB1YmtleSA9IG5vZGVQdWJrZXk7XG4gICAgdGhpcy5hdXRob3JpemVkVm90ZXIgPSBhdXRob3JpemVkVm90ZXI7XG4gICAgdGhpcy5hdXRob3JpemVkV2l0aGRyYXdlciA9IGF1dGhvcml6ZWRXaXRoZHJhd2VyO1xuICAgIHRoaXMuY29tbWlzc2lvbiA9IGNvbW1pc3Npb247XG4gIH1cbn1cblxuLyoqXG4gKiBDcmVhdGUgdm90ZSBhY2NvdW50IHRyYW5zYWN0aW9uIHBhcmFtc1xuICovXG5cbi8qKlxuICogSW5pdGlhbGl6ZUFjY291bnQgaW5zdHJ1Y3Rpb24gcGFyYW1zXG4gKi9cblxuLyoqXG4gKiBBdXRob3JpemUgaW5zdHJ1Y3Rpb24gcGFyYW1zXG4gKi9cblxuLyoqXG4gKiBBdXRob3JpemVXaXRoU2VlZCBpbnN0cnVjdGlvbiBwYXJhbXNcbiAqL1xuXG4vKipcbiAqIFdpdGhkcmF3IGZyb20gdm90ZSBhY2NvdW50IHRyYW5zYWN0aW9uIHBhcmFtc1xuICovXG5cbi8qKlxuICogVXBkYXRlIHZhbGlkYXRvciBpZGVudGl0eSAobm9kZSBwdWJrZXkpIHZvdGUgYWNjb3VudCBpbnN0cnVjdGlvbiBwYXJhbXMuXG4gKi9cblxuLyoqXG4gKiBWb3RlIEluc3RydWN0aW9uIGNsYXNzXG4gKi9cbmNsYXNzIFZvdGVJbnN0cnVjdGlvbiB7XG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIGNvbnN0cnVjdG9yKCkge31cblxuICAvKipcbiAgICogRGVjb2RlIGEgdm90ZSBpbnN0cnVjdGlvbiBhbmQgcmV0cmlldmUgdGhlIGluc3RydWN0aW9uIHR5cGUuXG4gICAqL1xuICBzdGF0aWMgZGVjb2RlSW5zdHJ1Y3Rpb25UeXBlKGluc3RydWN0aW9uKSB7XG4gICAgdGhpcy5jaGVja1Byb2dyYW1JZChpbnN0cnVjdGlvbi5wcm9ncmFtSWQpO1xuICAgIGNvbnN0IGluc3RydWN0aW9uVHlwZUxheW91dCA9IEJ1ZmZlckxheW91dC51MzIoJ2luc3RydWN0aW9uJyk7XG4gICAgY29uc3QgdHlwZUluZGV4ID0gaW5zdHJ1Y3Rpb25UeXBlTGF5b3V0LmRlY29kZShpbnN0cnVjdGlvbi5kYXRhKTtcbiAgICBsZXQgdHlwZTtcbiAgICBmb3IgKGNvbnN0IFtpeFR5cGUsIGxheW91dF0gb2YgT2JqZWN0LmVudHJpZXMoVk9URV9JTlNUUlVDVElPTl9MQVlPVVRTKSkge1xuICAgICAgaWYgKGxheW91dC5pbmRleCA9PSB0eXBlSW5kZXgpIHtcbiAgICAgICAgdHlwZSA9IGl4VHlwZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICghdHlwZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnN0cnVjdGlvbiB0eXBlIGluY29ycmVjdDsgbm90IGEgVm90ZUluc3RydWN0aW9uJyk7XG4gICAgfVxuICAgIHJldHVybiB0eXBlO1xuICB9XG5cbiAgLyoqXG4gICAqIERlY29kZSBhbiBpbml0aWFsaXplIHZvdGUgaW5zdHJ1Y3Rpb24gYW5kIHJldHJpZXZlIHRoZSBpbnN0cnVjdGlvbiBwYXJhbXMuXG4gICAqL1xuICBzdGF0aWMgZGVjb2RlSW5pdGlhbGl6ZUFjY291bnQoaW5zdHJ1Y3Rpb24pIHtcbiAgICB0aGlzLmNoZWNrUHJvZ3JhbUlkKGluc3RydWN0aW9uLnByb2dyYW1JZCk7XG4gICAgdGhpcy5jaGVja0tleUxlbmd0aChpbnN0cnVjdGlvbi5rZXlzLCA0KTtcbiAgICBjb25zdCB7XG4gICAgICB2b3RlSW5pdFxuICAgIH0gPSBkZWNvZGVEYXRhJDEoVk9URV9JTlNUUlVDVElPTl9MQVlPVVRTLkluaXRpYWxpemVBY2NvdW50LCBpbnN0cnVjdGlvbi5kYXRhKTtcbiAgICByZXR1cm4ge1xuICAgICAgdm90ZVB1YmtleTogaW5zdHJ1Y3Rpb24ua2V5c1swXS5wdWJrZXksXG4gICAgICBub2RlUHVia2V5OiBpbnN0cnVjdGlvbi5rZXlzWzNdLnB1YmtleSxcbiAgICAgIHZvdGVJbml0OiBuZXcgVm90ZUluaXQobmV3IFB1YmxpY0tleSh2b3RlSW5pdC5ub2RlUHVia2V5KSwgbmV3IFB1YmxpY0tleSh2b3RlSW5pdC5hdXRob3JpemVkVm90ZXIpLCBuZXcgUHVibGljS2V5KHZvdGVJbml0LmF1dGhvcml6ZWRXaXRoZHJhd2VyKSwgdm90ZUluaXQuY29tbWlzc2lvbilcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIERlY29kZSBhbiBhdXRob3JpemUgaW5zdHJ1Y3Rpb24gYW5kIHJldHJpZXZlIHRoZSBpbnN0cnVjdGlvbiBwYXJhbXMuXG4gICAqL1xuICBzdGF0aWMgZGVjb2RlQXV0aG9yaXplKGluc3RydWN0aW9uKSB7XG4gICAgdGhpcy5jaGVja1Byb2dyYW1JZChpbnN0cnVjdGlvbi5wcm9ncmFtSWQpO1xuICAgIHRoaXMuY2hlY2tLZXlMZW5ndGgoaW5zdHJ1Y3Rpb24ua2V5cywgMyk7XG4gICAgY29uc3Qge1xuICAgICAgbmV3QXV0aG9yaXplZCxcbiAgICAgIHZvdGVBdXRob3JpemF0aW9uVHlwZVxuICAgIH0gPSBkZWNvZGVEYXRhJDEoVk9URV9JTlNUUlVDVElPTl9MQVlPVVRTLkF1dGhvcml6ZSwgaW5zdHJ1Y3Rpb24uZGF0YSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHZvdGVQdWJrZXk6IGluc3RydWN0aW9uLmtleXNbMF0ucHVia2V5LFxuICAgICAgYXV0aG9yaXplZFB1YmtleTogaW5zdHJ1Y3Rpb24ua2V5c1syXS5wdWJrZXksXG4gICAgICBuZXdBdXRob3JpemVkUHVia2V5OiBuZXcgUHVibGljS2V5KG5ld0F1dGhvcml6ZWQpLFxuICAgICAgdm90ZUF1dGhvcml6YXRpb25UeXBlOiB7XG4gICAgICAgIGluZGV4OiB2b3RlQXV0aG9yaXphdGlvblR5cGVcbiAgICAgIH1cbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIERlY29kZSBhbiBhdXRob3JpemUgaW5zdHJ1Y3Rpb24gYW5kIHJldHJpZXZlIHRoZSBpbnN0cnVjdGlvbiBwYXJhbXMuXG4gICAqL1xuICBzdGF0aWMgZGVjb2RlQXV0aG9yaXplV2l0aFNlZWQoaW5zdHJ1Y3Rpb24pIHtcbiAgICB0aGlzLmNoZWNrUHJvZ3JhbUlkKGluc3RydWN0aW9uLnByb2dyYW1JZCk7XG4gICAgdGhpcy5jaGVja0tleUxlbmd0aChpbnN0cnVjdGlvbi5rZXlzLCAzKTtcbiAgICBjb25zdCB7XG4gICAgICB2b3RlQXV0aG9yaXplV2l0aFNlZWRBcmdzOiB7XG4gICAgICAgIGN1cnJlbnRBdXRob3JpdHlEZXJpdmVkS2V5T3duZXJQdWJrZXksXG4gICAgICAgIGN1cnJlbnRBdXRob3JpdHlEZXJpdmVkS2V5U2VlZCxcbiAgICAgICAgbmV3QXV0aG9yaXplZCxcbiAgICAgICAgdm90ZUF1dGhvcml6YXRpb25UeXBlXG4gICAgICB9XG4gICAgfSA9IGRlY29kZURhdGEkMShWT1RFX0lOU1RSVUNUSU9OX0xBWU9VVFMuQXV0aG9yaXplV2l0aFNlZWQsIGluc3RydWN0aW9uLmRhdGEpO1xuICAgIHJldHVybiB7XG4gICAgICBjdXJyZW50QXV0aG9yaXR5RGVyaXZlZEtleUJhc2VQdWJrZXk6IGluc3RydWN0aW9uLmtleXNbMl0ucHVia2V5LFxuICAgICAgY3VycmVudEF1dGhvcml0eURlcml2ZWRLZXlPd25lclB1YmtleTogbmV3IFB1YmxpY0tleShjdXJyZW50QXV0aG9yaXR5RGVyaXZlZEtleU93bmVyUHVia2V5KSxcbiAgICAgIGN1cnJlbnRBdXRob3JpdHlEZXJpdmVkS2V5U2VlZDogY3VycmVudEF1dGhvcml0eURlcml2ZWRLZXlTZWVkLFxuICAgICAgbmV3QXV0aG9yaXplZFB1YmtleTogbmV3IFB1YmxpY0tleShuZXdBdXRob3JpemVkKSxcbiAgICAgIHZvdGVBdXRob3JpemF0aW9uVHlwZToge1xuICAgICAgICBpbmRleDogdm90ZUF1dGhvcml6YXRpb25UeXBlXG4gICAgICB9LFxuICAgICAgdm90ZVB1YmtleTogaW5zdHJ1Y3Rpb24ua2V5c1swXS5wdWJrZXlcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIERlY29kZSBhIHdpdGhkcmF3IGluc3RydWN0aW9uIGFuZCByZXRyaWV2ZSB0aGUgaW5zdHJ1Y3Rpb24gcGFyYW1zLlxuICAgKi9cbiAgc3RhdGljIGRlY29kZVdpdGhkcmF3KGluc3RydWN0aW9uKSB7XG4gICAgdGhpcy5jaGVja1Byb2dyYW1JZChpbnN0cnVjdGlvbi5wcm9ncmFtSWQpO1xuICAgIHRoaXMuY2hlY2tLZXlMZW5ndGgoaW5zdHJ1Y3Rpb24ua2V5cywgMyk7XG4gICAgY29uc3Qge1xuICAgICAgbGFtcG9ydHNcbiAgICB9ID0gZGVjb2RlRGF0YSQxKFZPVEVfSU5TVFJVQ1RJT05fTEFZT1VUUy5XaXRoZHJhdywgaW5zdHJ1Y3Rpb24uZGF0YSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHZvdGVQdWJrZXk6IGluc3RydWN0aW9uLmtleXNbMF0ucHVia2V5LFxuICAgICAgYXV0aG9yaXplZFdpdGhkcmF3ZXJQdWJrZXk6IGluc3RydWN0aW9uLmtleXNbMl0ucHVia2V5LFxuICAgICAgbGFtcG9ydHMsXG4gICAgICB0b1B1YmtleTogaW5zdHJ1Y3Rpb24ua2V5c1sxXS5wdWJrZXlcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgc3RhdGljIGNoZWNrUHJvZ3JhbUlkKHByb2dyYW1JZCkge1xuICAgIGlmICghcHJvZ3JhbUlkLmVxdWFscyhWb3RlUHJvZ3JhbS5wcm9ncmFtSWQpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgaW5zdHJ1Y3Rpb247IHByb2dyYW1JZCBpcyBub3QgVm90ZVByb2dyYW0nKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQGludGVybmFsXG4gICAqL1xuICBzdGF0aWMgY2hlY2tLZXlMZW5ndGgoa2V5cywgZXhwZWN0ZWRMZW5ndGgpIHtcbiAgICBpZiAoa2V5cy5sZW5ndGggPCBleHBlY3RlZExlbmd0aCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBpbnZhbGlkIGluc3RydWN0aW9uOyBmb3VuZCAke2tleXMubGVuZ3RofSBrZXlzLCBleHBlY3RlZCBhdCBsZWFzdCAke2V4cGVjdGVkTGVuZ3RofWApO1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIEFuIGVudW1lcmF0aW9uIG9mIHZhbGlkIFZvdGVJbnN0cnVjdGlvblR5cGUnc1xuICovXG5cbi8qKiBAaW50ZXJuYWwgKi9cblxuY29uc3QgVk9URV9JTlNUUlVDVElPTl9MQVlPVVRTID0gT2JqZWN0LmZyZWV6ZSh7XG4gIEluaXRpYWxpemVBY2NvdW50OiB7XG4gICAgaW5kZXg6IDAsXG4gICAgbGF5b3V0OiBCdWZmZXJMYXlvdXQuc3RydWN0KFtCdWZmZXJMYXlvdXQudTMyKCdpbnN0cnVjdGlvbicpLCB2b3RlSW5pdCgpXSlcbiAgfSxcbiAgQXV0aG9yaXplOiB7XG4gICAgaW5kZXg6IDEsXG4gICAgbGF5b3V0OiBCdWZmZXJMYXlvdXQuc3RydWN0KFtCdWZmZXJMYXlvdXQudTMyKCdpbnN0cnVjdGlvbicpLCBwdWJsaWNLZXkoJ25ld0F1dGhvcml6ZWQnKSwgQnVmZmVyTGF5b3V0LnUzMigndm90ZUF1dGhvcml6YXRpb25UeXBlJyldKVxuICB9LFxuICBXaXRoZHJhdzoge1xuICAgIGluZGV4OiAzLFxuICAgIGxheW91dDogQnVmZmVyTGF5b3V0LnN0cnVjdChbQnVmZmVyTGF5b3V0LnUzMignaW5zdHJ1Y3Rpb24nKSwgQnVmZmVyTGF5b3V0Lm5zNjQoJ2xhbXBvcnRzJyldKVxuICB9LFxuICBVcGRhdGVWYWxpZGF0b3JJZGVudGl0eToge1xuICAgIGluZGV4OiA0LFxuICAgIGxheW91dDogQnVmZmVyTGF5b3V0LnN0cnVjdChbQnVmZmVyTGF5b3V0LnUzMignaW5zdHJ1Y3Rpb24nKV0pXG4gIH0sXG4gIEF1dGhvcml6ZVdpdGhTZWVkOiB7XG4gICAgaW5kZXg6IDEwLFxuICAgIGxheW91dDogQnVmZmVyTGF5b3V0LnN0cnVjdChbQnVmZmVyTGF5b3V0LnUzMignaW5zdHJ1Y3Rpb24nKSwgdm90ZUF1dGhvcml6ZVdpdGhTZWVkQXJncygpXSlcbiAgfVxufSk7XG5cbi8qKlxuICogVm90ZUF1dGhvcml6ZSB0eXBlXG4gKi9cblxuLyoqXG4gKiBBbiBlbnVtZXJhdGlvbiBvZiB2YWxpZCBWb3RlQXV0aG9yaXphdGlvbiBsYXlvdXRzLlxuICovXG5jb25zdCBWb3RlQXV0aG9yaXphdGlvbkxheW91dCA9IE9iamVjdC5mcmVlemUoe1xuICBWb3Rlcjoge1xuICAgIGluZGV4OiAwXG4gIH0sXG4gIFdpdGhkcmF3ZXI6IHtcbiAgICBpbmRleDogMVxuICB9XG59KTtcblxuLyoqXG4gKiBGYWN0b3J5IGNsYXNzIGZvciB0cmFuc2FjdGlvbnMgdG8gaW50ZXJhY3Qgd2l0aCB0aGUgVm90ZSBwcm9ncmFtXG4gKi9cbmNsYXNzIFZvdGVQcm9ncmFtIHtcbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgY29uc3RydWN0b3IoKSB7fVxuXG4gIC8qKlxuICAgKiBQdWJsaWMga2V5IHRoYXQgaWRlbnRpZmllcyB0aGUgVm90ZSBwcm9ncmFtXG4gICAqL1xuXG4gIC8qKlxuICAgKiBHZW5lcmF0ZSBhbiBJbml0aWFsaXplIGluc3RydWN0aW9uLlxuICAgKi9cbiAgc3RhdGljIGluaXRpYWxpemVBY2NvdW50KHBhcmFtcykge1xuICAgIGNvbnN0IHtcbiAgICAgIHZvdGVQdWJrZXksXG4gICAgICBub2RlUHVia2V5LFxuICAgICAgdm90ZUluaXRcbiAgICB9ID0gcGFyYW1zO1xuICAgIGNvbnN0IHR5cGUgPSBWT1RFX0lOU1RSVUNUSU9OX0xBWU9VVFMuSW5pdGlhbGl6ZUFjY291bnQ7XG4gICAgY29uc3QgZGF0YSA9IGVuY29kZURhdGEodHlwZSwge1xuICAgICAgdm90ZUluaXQ6IHtcbiAgICAgICAgbm9kZVB1YmtleTogdG9CdWZmZXIodm90ZUluaXQubm9kZVB1YmtleS50b0J1ZmZlcigpKSxcbiAgICAgICAgYXV0aG9yaXplZFZvdGVyOiB0b0J1ZmZlcih2b3RlSW5pdC5hdXRob3JpemVkVm90ZXIudG9CdWZmZXIoKSksXG4gICAgICAgIGF1dGhvcml6ZWRXaXRoZHJhd2VyOiB0b0J1ZmZlcih2b3RlSW5pdC5hdXRob3JpemVkV2l0aGRyYXdlci50b0J1ZmZlcigpKSxcbiAgICAgICAgY29tbWlzc2lvbjogdm90ZUluaXQuY29tbWlzc2lvblxuICAgICAgfVxuICAgIH0pO1xuICAgIGNvbnN0IGluc3RydWN0aW9uRGF0YSA9IHtcbiAgICAgIGtleXM6IFt7XG4gICAgICAgIHB1YmtleTogdm90ZVB1YmtleSxcbiAgICAgICAgaXNTaWduZXI6IGZhbHNlLFxuICAgICAgICBpc1dyaXRhYmxlOiB0cnVlXG4gICAgICB9LCB7XG4gICAgICAgIHB1YmtleTogU1lTVkFSX1JFTlRfUFVCS0VZLFxuICAgICAgICBpc1NpZ25lcjogZmFsc2UsXG4gICAgICAgIGlzV3JpdGFibGU6IGZhbHNlXG4gICAgICB9LCB7XG4gICAgICAgIHB1YmtleTogU1lTVkFSX0NMT0NLX1BVQktFWSxcbiAgICAgICAgaXNTaWduZXI6IGZhbHNlLFxuICAgICAgICBpc1dyaXRhYmxlOiBmYWxzZVxuICAgICAgfSwge1xuICAgICAgICBwdWJrZXk6IG5vZGVQdWJrZXksXG4gICAgICAgIGlzU2lnbmVyOiB0cnVlLFxuICAgICAgICBpc1dyaXRhYmxlOiBmYWxzZVxuICAgICAgfV0sXG4gICAgICBwcm9ncmFtSWQ6IHRoaXMucHJvZ3JhbUlkLFxuICAgICAgZGF0YVxuICAgIH07XG4gICAgcmV0dXJuIG5ldyBUcmFuc2FjdGlvbkluc3RydWN0aW9uKGluc3RydWN0aW9uRGF0YSk7XG4gIH1cblxuICAvKipcbiAgICogR2VuZXJhdGUgYSB0cmFuc2FjdGlvbiB0aGF0IGNyZWF0ZXMgYSBuZXcgVm90ZSBhY2NvdW50LlxuICAgKi9cbiAgc3RhdGljIGNyZWF0ZUFjY291bnQocGFyYW1zKSB7XG4gICAgY29uc3QgdHJhbnNhY3Rpb24gPSBuZXcgVHJhbnNhY3Rpb24oKTtcbiAgICB0cmFuc2FjdGlvbi5hZGQoU3lzdGVtUHJvZ3JhbS5jcmVhdGVBY2NvdW50KHtcbiAgICAgIGZyb21QdWJrZXk6IHBhcmFtcy5mcm9tUHVia2V5LFxuICAgICAgbmV3QWNjb3VudFB1YmtleTogcGFyYW1zLnZvdGVQdWJrZXksXG4gICAgICBsYW1wb3J0czogcGFyYW1zLmxhbXBvcnRzLFxuICAgICAgc3BhY2U6IHRoaXMuc3BhY2UsXG4gICAgICBwcm9ncmFtSWQ6IHRoaXMucHJvZ3JhbUlkXG4gICAgfSkpO1xuICAgIHJldHVybiB0cmFuc2FjdGlvbi5hZGQodGhpcy5pbml0aWFsaXplQWNjb3VudCh7XG4gICAgICB2b3RlUHVia2V5OiBwYXJhbXMudm90ZVB1YmtleSxcbiAgICAgIG5vZGVQdWJrZXk6IHBhcmFtcy52b3RlSW5pdC5ub2RlUHVia2V5LFxuICAgICAgdm90ZUluaXQ6IHBhcmFtcy52b3RlSW5pdFxuICAgIH0pKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZW5lcmF0ZSBhIHRyYW5zYWN0aW9uIHRoYXQgYXV0aG9yaXplcyBhIG5ldyBWb3RlciBvciBXaXRoZHJhd2VyIG9uIHRoZSBWb3RlIGFjY291bnQuXG4gICAqL1xuICBzdGF0aWMgYXV0aG9yaXplKHBhcmFtcykge1xuICAgIGNvbnN0IHtcbiAgICAgIHZvdGVQdWJrZXksXG4gICAgICBhdXRob3JpemVkUHVia2V5LFxuICAgICAgbmV3QXV0aG9yaXplZFB1YmtleSxcbiAgICAgIHZvdGVBdXRob3JpemF0aW9uVHlwZVxuICAgIH0gPSBwYXJhbXM7XG4gICAgY29uc3QgdHlwZSA9IFZPVEVfSU5TVFJVQ1RJT05fTEFZT1VUUy5BdXRob3JpemU7XG4gICAgY29uc3QgZGF0YSA9IGVuY29kZURhdGEodHlwZSwge1xuICAgICAgbmV3QXV0aG9yaXplZDogdG9CdWZmZXIobmV3QXV0aG9yaXplZFB1YmtleS50b0J1ZmZlcigpKSxcbiAgICAgIHZvdGVBdXRob3JpemF0aW9uVHlwZTogdm90ZUF1dGhvcml6YXRpb25UeXBlLmluZGV4XG4gICAgfSk7XG4gICAgY29uc3Qga2V5cyA9IFt7XG4gICAgICBwdWJrZXk6IHZvdGVQdWJrZXksXG4gICAgICBpc1NpZ25lcjogZmFsc2UsXG4gICAgICBpc1dyaXRhYmxlOiB0cnVlXG4gICAgfSwge1xuICAgICAgcHVia2V5OiBTWVNWQVJfQ0xPQ0tfUFVCS0VZLFxuICAgICAgaXNTaWduZXI6IGZhbHNlLFxuICAgICAgaXNXcml0YWJsZTogZmFsc2VcbiAgICB9LCB7XG4gICAgICBwdWJrZXk6IGF1dGhvcml6ZWRQdWJrZXksXG4gICAgICBpc1NpZ25lcjogdHJ1ZSxcbiAgICAgIGlzV3JpdGFibGU6IGZhbHNlXG4gICAgfV07XG4gICAgcmV0dXJuIG5ldyBUcmFuc2FjdGlvbigpLmFkZCh7XG4gICAgICBrZXlzLFxuICAgICAgcHJvZ3JhbUlkOiB0aGlzLnByb2dyYW1JZCxcbiAgICAgIGRhdGFcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZW5lcmF0ZSBhIHRyYW5zYWN0aW9uIHRoYXQgYXV0aG9yaXplcyBhIG5ldyBWb3RlciBvciBXaXRoZHJhd2VyIG9uIHRoZSBWb3RlIGFjY291bnRcbiAgICogd2hlcmUgdGhlIGN1cnJlbnQgVm90ZXIgb3IgV2l0aGRyYXdlciBhdXRob3JpdHkgaXMgYSBkZXJpdmVkIGtleS5cbiAgICovXG4gIHN0YXRpYyBhdXRob3JpemVXaXRoU2VlZChwYXJhbXMpIHtcbiAgICBjb25zdCB7XG4gICAgICBjdXJyZW50QXV0aG9yaXR5RGVyaXZlZEtleUJhc2VQdWJrZXksXG4gICAgICBjdXJyZW50QXV0aG9yaXR5RGVyaXZlZEtleU93bmVyUHVia2V5LFxuICAgICAgY3VycmVudEF1dGhvcml0eURlcml2ZWRLZXlTZWVkLFxuICAgICAgbmV3QXV0aG9yaXplZFB1YmtleSxcbiAgICAgIHZvdGVBdXRob3JpemF0aW9uVHlwZSxcbiAgICAgIHZvdGVQdWJrZXlcbiAgICB9ID0gcGFyYW1zO1xuICAgIGNvbnN0IHR5cGUgPSBWT1RFX0lOU1RSVUNUSU9OX0xBWU9VVFMuQXV0aG9yaXplV2l0aFNlZWQ7XG4gICAgY29uc3QgZGF0YSA9IGVuY29kZURhdGEodHlwZSwge1xuICAgICAgdm90ZUF1dGhvcml6ZVdpdGhTZWVkQXJnczoge1xuICAgICAgICBjdXJyZW50QXV0aG9yaXR5RGVyaXZlZEtleU93bmVyUHVia2V5OiB0b0J1ZmZlcihjdXJyZW50QXV0aG9yaXR5RGVyaXZlZEtleU93bmVyUHVia2V5LnRvQnVmZmVyKCkpLFxuICAgICAgICBjdXJyZW50QXV0aG9yaXR5RGVyaXZlZEtleVNlZWQ6IGN1cnJlbnRBdXRob3JpdHlEZXJpdmVkS2V5U2VlZCxcbiAgICAgICAgbmV3QXV0aG9yaXplZDogdG9CdWZmZXIobmV3QXV0aG9yaXplZFB1YmtleS50b0J1ZmZlcigpKSxcbiAgICAgICAgdm90ZUF1dGhvcml6YXRpb25UeXBlOiB2b3RlQXV0aG9yaXphdGlvblR5cGUuaW5kZXhcbiAgICAgIH1cbiAgICB9KTtcbiAgICBjb25zdCBrZXlzID0gW3tcbiAgICAgIHB1YmtleTogdm90ZVB1YmtleSxcbiAgICAgIGlzU2lnbmVyOiBmYWxzZSxcbiAgICAgIGlzV3JpdGFibGU6IHRydWVcbiAgICB9LCB7XG4gICAgICBwdWJrZXk6IFNZU1ZBUl9DTE9DS19QVUJLRVksXG4gICAgICBpc1NpZ25lcjogZmFsc2UsXG4gICAgICBpc1dyaXRhYmxlOiBmYWxzZVxuICAgIH0sIHtcbiAgICAgIHB1YmtleTogY3VycmVudEF1dGhvcml0eURlcml2ZWRLZXlCYXNlUHVia2V5LFxuICAgICAgaXNTaWduZXI6IHRydWUsXG4gICAgICBpc1dyaXRhYmxlOiBmYWxzZVxuICAgIH1dO1xuICAgIHJldHVybiBuZXcgVHJhbnNhY3Rpb24oKS5hZGQoe1xuICAgICAga2V5cyxcbiAgICAgIHByb2dyYW1JZDogdGhpcy5wcm9ncmFtSWQsXG4gICAgICBkYXRhXG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogR2VuZXJhdGUgYSB0cmFuc2FjdGlvbiB0byB3aXRoZHJhdyBmcm9tIGEgVm90ZSBhY2NvdW50LlxuICAgKi9cbiAgc3RhdGljIHdpdGhkcmF3KHBhcmFtcykge1xuICAgIGNvbnN0IHtcbiAgICAgIHZvdGVQdWJrZXksXG4gICAgICBhdXRob3JpemVkV2l0aGRyYXdlclB1YmtleSxcbiAgICAgIGxhbXBvcnRzLFxuICAgICAgdG9QdWJrZXlcbiAgICB9ID0gcGFyYW1zO1xuICAgIGNvbnN0IHR5cGUgPSBWT1RFX0lOU1RSVUNUSU9OX0xBWU9VVFMuV2l0aGRyYXc7XG4gICAgY29uc3QgZGF0YSA9IGVuY29kZURhdGEodHlwZSwge1xuICAgICAgbGFtcG9ydHNcbiAgICB9KTtcbiAgICBjb25zdCBrZXlzID0gW3tcbiAgICAgIHB1YmtleTogdm90ZVB1YmtleSxcbiAgICAgIGlzU2lnbmVyOiBmYWxzZSxcbiAgICAgIGlzV3JpdGFibGU6IHRydWVcbiAgICB9LCB7XG4gICAgICBwdWJrZXk6IHRvUHVia2V5LFxuICAgICAgaXNTaWduZXI6IGZhbHNlLFxuICAgICAgaXNXcml0YWJsZTogdHJ1ZVxuICAgIH0sIHtcbiAgICAgIHB1YmtleTogYXV0aG9yaXplZFdpdGhkcmF3ZXJQdWJrZXksXG4gICAgICBpc1NpZ25lcjogdHJ1ZSxcbiAgICAgIGlzV3JpdGFibGU6IGZhbHNlXG4gICAgfV07XG4gICAgcmV0dXJuIG5ldyBUcmFuc2FjdGlvbigpLmFkZCh7XG4gICAgICBrZXlzLFxuICAgICAgcHJvZ3JhbUlkOiB0aGlzLnByb2dyYW1JZCxcbiAgICAgIGRhdGFcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZW5lcmF0ZSBhIHRyYW5zYWN0aW9uIHRvIHdpdGhkcmF3IHNhZmVseSBmcm9tIGEgVm90ZSBhY2NvdW50LlxuICAgKlxuICAgKiBUaGlzIGZ1bmN0aW9uIHdhcyBjcmVhdGVkIGFzIGEgc2FmZWd1YXJkIGZvciB2b3RlIGFjY291bnRzIHJ1bm5pbmcgdmFsaWRhdG9ycywgYHNhZmVXaXRoZHJhd2BcbiAgICogY2hlY2tzIHRoYXQgdGhlIHdpdGhkcmF3IGFtb3VudCB3aWxsIG5vdCBleGNlZWQgdGhlIHNwZWNpZmllZCBiYWxhbmNlIHdoaWxlIGxlYXZpbmcgZW5vdWdoIGxlZnRcbiAgICogdG8gY292ZXIgcmVudC4gSWYgeW91IHdpc2ggdG8gY2xvc2UgdGhlIHZvdGUgYWNjb3VudCBieSB3aXRoZHJhd2luZyB0aGUgZnVsbCBhbW91bnQsIGNhbGwgdGhlXG4gICAqIGB3aXRoZHJhd2AgbWV0aG9kIGRpcmVjdGx5LlxuICAgKi9cbiAgc3RhdGljIHNhZmVXaXRoZHJhdyhwYXJhbXMsIGN1cnJlbnRWb3RlQWNjb3VudEJhbGFuY2UsIHJlbnRFeGVtcHRNaW5pbXVtKSB7XG4gICAgaWYgKHBhcmFtcy5sYW1wb3J0cyA+IGN1cnJlbnRWb3RlQWNjb3VudEJhbGFuY2UgLSByZW50RXhlbXB0TWluaW11bSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdXaXRoZHJhdyB3aWxsIGxlYXZlIHZvdGUgYWNjb3VudCB3aXRoIGluc3VmZmljaWVudCBmdW5kcy4nKTtcbiAgICB9XG4gICAgcmV0dXJuIFZvdGVQcm9ncmFtLndpdGhkcmF3KHBhcmFtcyk7XG4gIH1cblxuICAvKipcbiAgICogR2VuZXJhdGUgYSB0cmFuc2FjdGlvbiB0byB1cGRhdGUgdGhlIHZhbGlkYXRvciBpZGVudGl0eSAobm9kZSBwdWJrZXkpIG9mIGEgVm90ZSBhY2NvdW50LlxuICAgKi9cbiAgc3RhdGljIHVwZGF0ZVZhbGlkYXRvcklkZW50aXR5KHBhcmFtcykge1xuICAgIGNvbnN0IHtcbiAgICAgIHZvdGVQdWJrZXksXG4gICAgICBhdXRob3JpemVkV2l0aGRyYXdlclB1YmtleSxcbiAgICAgIG5vZGVQdWJrZXlcbiAgICB9ID0gcGFyYW1zO1xuICAgIGNvbnN0IHR5cGUgPSBWT1RFX0lOU1RSVUNUSU9OX0xBWU9VVFMuVXBkYXRlVmFsaWRhdG9ySWRlbnRpdHk7XG4gICAgY29uc3QgZGF0YSA9IGVuY29kZURhdGEodHlwZSk7XG4gICAgY29uc3Qga2V5cyA9IFt7XG4gICAgICBwdWJrZXk6IHZvdGVQdWJrZXksXG4gICAgICBpc1NpZ25lcjogZmFsc2UsXG4gICAgICBpc1dyaXRhYmxlOiB0cnVlXG4gICAgfSwge1xuICAgICAgcHVia2V5OiBub2RlUHVia2V5LFxuICAgICAgaXNTaWduZXI6IHRydWUsXG4gICAgICBpc1dyaXRhYmxlOiBmYWxzZVxuICAgIH0sIHtcbiAgICAgIHB1YmtleTogYXV0aG9yaXplZFdpdGhkcmF3ZXJQdWJrZXksXG4gICAgICBpc1NpZ25lcjogdHJ1ZSxcbiAgICAgIGlzV3JpdGFibGU6IGZhbHNlXG4gICAgfV07XG4gICAgcmV0dXJuIG5ldyBUcmFuc2FjdGlvbigpLmFkZCh7XG4gICAgICBrZXlzLFxuICAgICAgcHJvZ3JhbUlkOiB0aGlzLnByb2dyYW1JZCxcbiAgICAgIGRhdGFcbiAgICB9KTtcbiAgfVxufVxuVm90ZVByb2dyYW0ucHJvZ3JhbUlkID0gbmV3IFB1YmxpY0tleSgnVm90ZTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMScpO1xuLyoqXG4gKiBNYXggc3BhY2Ugb2YgYSBWb3RlIGFjY291bnRcbiAqXG4gKiBUaGlzIGlzIGdlbmVyYXRlZCBmcm9tIHRoZSBzb2xhbmEtdm90ZS1wcm9ncmFtIFZvdGVTdGF0ZSBzdHJ1Y3QgYXNcbiAqIGBWb3RlU3RhdGU6OnNpemVfb2YoKWA6XG4gKiBodHRwczovL2RvY3MucnMvc29sYW5hLXZvdGUtcHJvZ3JhbS8xLjkuNS9zb2xhbmFfdm90ZV9wcm9ncmFtL3ZvdGVfc3RhdGUvc3RydWN0LlZvdGVTdGF0ZS5odG1sI21ldGhvZC5zaXplX29mXG4gKlxuICogS0VFUCBJTiBTWU5DIFdJVEggYFZvdGVTdGF0ZTo6c2l6ZV9vZigpYCBpbiBodHRwczovL2dpdGh1Yi5jb20vc29sYW5hLWxhYnMvc29sYW5hL2Jsb2IvYTQ3NGNiMjRiOTIzOGY1ZWRjYzk4MmY2NWMwYjM3ZDRhMTA0NmY3ZS9zZGsvcHJvZ3JhbS9zcmMvdm90ZS9zdGF0ZS9tb2QucnMjTDM0MC1MMzQyXG4gKi9cblZvdGVQcm9ncmFtLnNwYWNlID0gMzc2MjtcblxuY29uc3QgVkFMSURBVE9SX0lORk9fS0VZID0gbmV3IFB1YmxpY0tleSgnVmExaWRhdG9yMW5mbzExMTExMTExMTExMTExMTExMTExMTExMTExMTExMScpO1xuXG4vKipcbiAqIEBpbnRlcm5hbFxuICovXG5cbi8qKlxuICogSW5mbyB1c2VkIHRvIGlkZW50aXR5IHZhbGlkYXRvcnMuXG4gKi9cblxuY29uc3QgSW5mb1N0cmluZyA9IHR5cGUoe1xuICBuYW1lOiBzdHJpbmcoKSxcbiAgd2Vic2l0ZTogb3B0aW9uYWwoc3RyaW5nKCkpLFxuICBkZXRhaWxzOiBvcHRpb25hbChzdHJpbmcoKSksXG4gIGtleWJhc2VVc2VybmFtZTogb3B0aW9uYWwoc3RyaW5nKCkpXG59KTtcblxuLyoqXG4gKiBWYWxpZGF0b3JJbmZvIGNsYXNzXG4gKi9cbmNsYXNzIFZhbGlkYXRvckluZm8ge1xuICAvKipcbiAgICogQ29uc3RydWN0IGEgdmFsaWQgVmFsaWRhdG9ySW5mb1xuICAgKlxuICAgKiBAcGFyYW0ga2V5IHZhbGlkYXRvciBwdWJsaWMga2V5XG4gICAqIEBwYXJhbSBpbmZvIHZhbGlkYXRvciBpbmZvcm1hdGlvblxuICAgKi9cbiAgY29uc3RydWN0b3Ioa2V5LCBpbmZvKSB7XG4gICAgLyoqXG4gICAgICogdmFsaWRhdG9yIHB1YmxpYyBrZXlcbiAgICAgKi9cbiAgICB0aGlzLmtleSA9IHZvaWQgMDtcbiAgICAvKipcbiAgICAgKiB2YWxpZGF0b3IgaW5mb3JtYXRpb25cbiAgICAgKi9cbiAgICB0aGlzLmluZm8gPSB2b2lkIDA7XG4gICAgdGhpcy5rZXkgPSBrZXk7XG4gICAgdGhpcy5pbmZvID0gaW5mbztcbiAgfVxuXG4gIC8qKlxuICAgKiBEZXNlcmlhbGl6ZSBWYWxpZGF0b3JJbmZvIGZyb20gdGhlIGNvbmZpZyBhY2NvdW50IGRhdGEuIEV4YWN0bHkgdHdvIGNvbmZpZ1xuICAgKiBrZXlzIGFyZSByZXF1aXJlZCBpbiB0aGUgZGF0YS5cbiAgICpcbiAgICogQHBhcmFtIGJ1ZmZlciBjb25maWcgYWNjb3VudCBkYXRhXG4gICAqIEByZXR1cm4gbnVsbCBpZiBpbmZvIHdhcyBub3QgZm91bmRcbiAgICovXG4gIHN0YXRpYyBmcm9tQ29uZmlnRGF0YShidWZmZXIpIHtcbiAgICBsZXQgYnl0ZUFycmF5ID0gWy4uLmJ1ZmZlcl07XG4gICAgY29uc3QgY29uZmlnS2V5Q291bnQgPSBkZWNvZGVMZW5ndGgoYnl0ZUFycmF5KTtcbiAgICBpZiAoY29uZmlnS2V5Q291bnQgIT09IDIpIHJldHVybiBudWxsO1xuICAgIGNvbnN0IGNvbmZpZ0tleXMgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IDI7IGkrKykge1xuICAgICAgY29uc3QgcHVibGljS2V5ID0gbmV3IFB1YmxpY0tleShndWFyZGVkU3BsaWNlKGJ5dGVBcnJheSwgMCwgUFVCTElDX0tFWV9MRU5HVEgpKTtcbiAgICAgIGNvbnN0IGlzU2lnbmVyID0gZ3VhcmRlZFNoaWZ0KGJ5dGVBcnJheSkgPT09IDE7XG4gICAgICBjb25maWdLZXlzLnB1c2goe1xuICAgICAgICBwdWJsaWNLZXksXG4gICAgICAgIGlzU2lnbmVyXG4gICAgICB9KTtcbiAgICB9XG4gICAgaWYgKGNvbmZpZ0tleXNbMF0ucHVibGljS2V5LmVxdWFscyhWQUxJREFUT1JfSU5GT19LRVkpKSB7XG4gICAgICBpZiAoY29uZmlnS2V5c1sxXS5pc1NpZ25lcikge1xuICAgICAgICBjb25zdCByYXdJbmZvID0gcnVzdFN0cmluZygpLmRlY29kZShCdWZmZXIuZnJvbShieXRlQXJyYXkpKTtcbiAgICAgICAgY29uc3QgaW5mbyA9IEpTT04ucGFyc2UocmF3SW5mbyk7XG4gICAgICAgIGFzc2VydCQxKGluZm8sIEluZm9TdHJpbmcpO1xuICAgICAgICByZXR1cm4gbmV3IFZhbGlkYXRvckluZm8oY29uZmlnS2V5c1sxXS5wdWJsaWNLZXksIGluZm8pO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxufVxuXG5jb25zdCBWT1RFX1BST0dSQU1fSUQgPSBuZXcgUHVibGljS2V5KCdWb3RlMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExJyk7XG5cbi8qKlxuICogSGlzdG9yeSBvZiBob3cgbWFueSBjcmVkaXRzIGVhcm5lZCBieSB0aGUgZW5kIG9mIGVhY2ggZXBvY2hcbiAqL1xuXG4vKipcbiAqIFNlZSBodHRwczovL2dpdGh1Yi5jb20vc29sYW5hLWxhYnMvc29sYW5hL2Jsb2IvOGExMmVkMDI5Y2ZhMzhkNGE0NTQwMDkxNmMyNDYzZmI4MmJiZWM4Yy9wcm9ncmFtcy92b3RlX2FwaS9zcmMvdm90ZV9zdGF0ZS5ycyNMNjgtTDg4XG4gKlxuICogQGludGVybmFsXG4gKi9cbmNvbnN0IFZvdGVBY2NvdW50TGF5b3V0ID0gQnVmZmVyTGF5b3V0LnN0cnVjdChbcHVibGljS2V5KCdub2RlUHVia2V5JyksIHB1YmxpY0tleSgnYXV0aG9yaXplZFdpdGhkcmF3ZXInKSwgQnVmZmVyTGF5b3V0LnU4KCdjb21taXNzaW9uJyksIEJ1ZmZlckxheW91dC5udTY0KCksXG4vLyB2b3Rlcy5sZW5ndGhcbkJ1ZmZlckxheW91dC5zZXEoQnVmZmVyTGF5b3V0LnN0cnVjdChbQnVmZmVyTGF5b3V0Lm51NjQoJ3Nsb3QnKSwgQnVmZmVyTGF5b3V0LnUzMignY29uZmlybWF0aW9uQ291bnQnKV0pLCBCdWZmZXJMYXlvdXQub2Zmc2V0KEJ1ZmZlckxheW91dC51MzIoKSwgLTgpLCAndm90ZXMnKSwgQnVmZmVyTGF5b3V0LnU4KCdyb290U2xvdFZhbGlkJyksIEJ1ZmZlckxheW91dC5udTY0KCdyb290U2xvdCcpLCBCdWZmZXJMYXlvdXQubnU2NCgpLFxuLy8gYXV0aG9yaXplZFZvdGVycy5sZW5ndGhcbkJ1ZmZlckxheW91dC5zZXEoQnVmZmVyTGF5b3V0LnN0cnVjdChbQnVmZmVyTGF5b3V0Lm51NjQoJ2Vwb2NoJyksIHB1YmxpY0tleSgnYXV0aG9yaXplZFZvdGVyJyldKSwgQnVmZmVyTGF5b3V0Lm9mZnNldChCdWZmZXJMYXlvdXQudTMyKCksIC04KSwgJ2F1dGhvcml6ZWRWb3RlcnMnKSwgQnVmZmVyTGF5b3V0LnN0cnVjdChbQnVmZmVyTGF5b3V0LnNlcShCdWZmZXJMYXlvdXQuc3RydWN0KFtwdWJsaWNLZXkoJ2F1dGhvcml6ZWRQdWJrZXknKSwgQnVmZmVyTGF5b3V0Lm51NjQoJ2Vwb2NoT2ZMYXN0QXV0aG9yaXplZFN3aXRjaCcpLCBCdWZmZXJMYXlvdXQubnU2NCgndGFyZ2V0RXBvY2gnKV0pLCAzMiwgJ2J1ZicpLCBCdWZmZXJMYXlvdXQubnU2NCgnaWR4JyksIEJ1ZmZlckxheW91dC51OCgnaXNFbXB0eScpXSwgJ3ByaW9yVm90ZXJzJyksIEJ1ZmZlckxheW91dC5udTY0KCksXG4vLyBlcG9jaENyZWRpdHMubGVuZ3RoXG5CdWZmZXJMYXlvdXQuc2VxKEJ1ZmZlckxheW91dC5zdHJ1Y3QoW0J1ZmZlckxheW91dC5udTY0KCdlcG9jaCcpLCBCdWZmZXJMYXlvdXQubnU2NCgnY3JlZGl0cycpLCBCdWZmZXJMYXlvdXQubnU2NCgncHJldkNyZWRpdHMnKV0pLCBCdWZmZXJMYXlvdXQub2Zmc2V0KEJ1ZmZlckxheW91dC51MzIoKSwgLTgpLCAnZXBvY2hDcmVkaXRzJyksIEJ1ZmZlckxheW91dC5zdHJ1Y3QoW0J1ZmZlckxheW91dC5udTY0KCdzbG90JyksIEJ1ZmZlckxheW91dC5udTY0KCd0aW1lc3RhbXAnKV0sICdsYXN0VGltZXN0YW1wJyldKTtcbi8qKlxuICogVm90ZUFjY291bnQgY2xhc3NcbiAqL1xuY2xhc3MgVm90ZUFjY291bnQge1xuICAvKipcbiAgICogQGludGVybmFsXG4gICAqL1xuICBjb25zdHJ1Y3RvcihhcmdzKSB7XG4gICAgdGhpcy5ub2RlUHVia2V5ID0gdm9pZCAwO1xuICAgIHRoaXMuYXV0aG9yaXplZFdpdGhkcmF3ZXIgPSB2b2lkIDA7XG4gICAgdGhpcy5jb21taXNzaW9uID0gdm9pZCAwO1xuICAgIHRoaXMucm9vdFNsb3QgPSB2b2lkIDA7XG4gICAgdGhpcy52b3RlcyA9IHZvaWQgMDtcbiAgICB0aGlzLmF1dGhvcml6ZWRWb3RlcnMgPSB2b2lkIDA7XG4gICAgdGhpcy5wcmlvclZvdGVycyA9IHZvaWQgMDtcbiAgICB0aGlzLmVwb2NoQ3JlZGl0cyA9IHZvaWQgMDtcbiAgICB0aGlzLmxhc3RUaW1lc3RhbXAgPSB2b2lkIDA7XG4gICAgdGhpcy5ub2RlUHVia2V5ID0gYXJncy5ub2RlUHVia2V5O1xuICAgIHRoaXMuYXV0aG9yaXplZFdpdGhkcmF3ZXIgPSBhcmdzLmF1dGhvcml6ZWRXaXRoZHJhd2VyO1xuICAgIHRoaXMuY29tbWlzc2lvbiA9IGFyZ3MuY29tbWlzc2lvbjtcbiAgICB0aGlzLnJvb3RTbG90ID0gYXJncy5yb290U2xvdDtcbiAgICB0aGlzLnZvdGVzID0gYXJncy52b3RlcztcbiAgICB0aGlzLmF1dGhvcml6ZWRWb3RlcnMgPSBhcmdzLmF1dGhvcml6ZWRWb3RlcnM7XG4gICAgdGhpcy5wcmlvclZvdGVycyA9IGFyZ3MucHJpb3JWb3RlcnM7XG4gICAgdGhpcy5lcG9jaENyZWRpdHMgPSBhcmdzLmVwb2NoQ3JlZGl0cztcbiAgICB0aGlzLmxhc3RUaW1lc3RhbXAgPSBhcmdzLmxhc3RUaW1lc3RhbXA7XG4gIH1cblxuICAvKipcbiAgICogRGVzZXJpYWxpemUgVm90ZUFjY291bnQgZnJvbSB0aGUgYWNjb3VudCBkYXRhLlxuICAgKlxuICAgKiBAcGFyYW0gYnVmZmVyIGFjY291bnQgZGF0YVxuICAgKiBAcmV0dXJuIFZvdGVBY2NvdW50XG4gICAqL1xuICBzdGF0aWMgZnJvbUFjY291bnREYXRhKGJ1ZmZlcikge1xuICAgIGNvbnN0IHZlcnNpb25PZmZzZXQgPSA0O1xuICAgIGNvbnN0IHZhID0gVm90ZUFjY291bnRMYXlvdXQuZGVjb2RlKHRvQnVmZmVyKGJ1ZmZlciksIHZlcnNpb25PZmZzZXQpO1xuICAgIGxldCByb290U2xvdCA9IHZhLnJvb3RTbG90O1xuICAgIGlmICghdmEucm9vdFNsb3RWYWxpZCkge1xuICAgICAgcm9vdFNsb3QgPSBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IFZvdGVBY2NvdW50KHtcbiAgICAgIG5vZGVQdWJrZXk6IG5ldyBQdWJsaWNLZXkodmEubm9kZVB1YmtleSksXG4gICAgICBhdXRob3JpemVkV2l0aGRyYXdlcjogbmV3IFB1YmxpY0tleSh2YS5hdXRob3JpemVkV2l0aGRyYXdlciksXG4gICAgICBjb21taXNzaW9uOiB2YS5jb21taXNzaW9uLFxuICAgICAgdm90ZXM6IHZhLnZvdGVzLFxuICAgICAgcm9vdFNsb3QsXG4gICAgICBhdXRob3JpemVkVm90ZXJzOiB2YS5hdXRob3JpemVkVm90ZXJzLm1hcChwYXJzZUF1dGhvcml6ZWRWb3RlciksXG4gICAgICBwcmlvclZvdGVyczogZ2V0UHJpb3JWb3RlcnModmEucHJpb3JWb3RlcnMpLFxuICAgICAgZXBvY2hDcmVkaXRzOiB2YS5lcG9jaENyZWRpdHMsXG4gICAgICBsYXN0VGltZXN0YW1wOiB2YS5sYXN0VGltZXN0YW1wXG4gICAgfSk7XG4gIH1cbn1cbmZ1bmN0aW9uIHBhcnNlQXV0aG9yaXplZFZvdGVyKHtcbiAgYXV0aG9yaXplZFZvdGVyLFxuICBlcG9jaFxufSkge1xuICByZXR1cm4ge1xuICAgIGVwb2NoLFxuICAgIGF1dGhvcml6ZWRWb3RlcjogbmV3IFB1YmxpY0tleShhdXRob3JpemVkVm90ZXIpXG4gIH07XG59XG5mdW5jdGlvbiBwYXJzZVByaW9yVm90ZXJzKHtcbiAgYXV0aG9yaXplZFB1YmtleSxcbiAgZXBvY2hPZkxhc3RBdXRob3JpemVkU3dpdGNoLFxuICB0YXJnZXRFcG9jaFxufSkge1xuICByZXR1cm4ge1xuICAgIGF1dGhvcml6ZWRQdWJrZXk6IG5ldyBQdWJsaWNLZXkoYXV0aG9yaXplZFB1YmtleSksXG4gICAgZXBvY2hPZkxhc3RBdXRob3JpemVkU3dpdGNoLFxuICAgIHRhcmdldEVwb2NoXG4gIH07XG59XG5mdW5jdGlvbiBnZXRQcmlvclZvdGVycyh7XG4gIGJ1ZixcbiAgaWR4LFxuICBpc0VtcHR5XG59KSB7XG4gIGlmIChpc0VtcHR5KSB7XG4gICAgcmV0dXJuIFtdO1xuICB9XG4gIHJldHVybiBbLi4uYnVmLnNsaWNlKGlkeCArIDEpLm1hcChwYXJzZVByaW9yVm90ZXJzKSwgLi4uYnVmLnNsaWNlKDAsIGlkeCkubWFwKHBhcnNlUHJpb3JWb3RlcnMpXTtcbn1cblxuY29uc3QgZW5kcG9pbnQgPSB7XG4gIGh0dHA6IHtcbiAgICBkZXZuZXQ6ICdodHRwOi8vYXBpLmRldm5ldC5zb2xhbmEuY29tJyxcbiAgICB0ZXN0bmV0OiAnaHR0cDovL2FwaS50ZXN0bmV0LnNvbGFuYS5jb20nLFxuICAgICdtYWlubmV0LWJldGEnOiAnaHR0cDovL2FwaS5tYWlubmV0LWJldGEuc29sYW5hLmNvbS8nXG4gIH0sXG4gIGh0dHBzOiB7XG4gICAgZGV2bmV0OiAnaHR0cHM6Ly9hcGkuZGV2bmV0LnNvbGFuYS5jb20nLFxuICAgIHRlc3RuZXQ6ICdodHRwczovL2FwaS50ZXN0bmV0LnNvbGFuYS5jb20nLFxuICAgICdtYWlubmV0LWJldGEnOiAnaHR0cHM6Ly9hcGkubWFpbm5ldC1iZXRhLnNvbGFuYS5jb20vJ1xuICB9XG59O1xuLyoqXG4gKiBSZXRyaWV2ZXMgdGhlIFJQQyBBUEkgVVJMIGZvciB0aGUgc3BlY2lmaWVkIGNsdXN0ZXJcbiAqIEBwYXJhbSB7Q2x1c3Rlcn0gW2NsdXN0ZXI9XCJkZXZuZXRcIl0gLSBUaGUgY2x1c3RlciBuYW1lIG9mIHRoZSBSUEMgQVBJIFVSTCB0byB1c2UuIFBvc3NpYmxlIG9wdGlvbnM6ICdkZXZuZXQnIHwgJ3Rlc3RuZXQnIHwgJ21haW5uZXQtYmV0YSdcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW3Rscz1cImh0dHBcIl0gLSBVc2UgVExTIHdoZW4gY29ubmVjdGluZyB0byBjbHVzdGVyLlxuICpcbiAqIEByZXR1cm5zIHtzdHJpbmd9IFVSTCBzdHJpbmcgb2YgdGhlIFJQQyBlbmRwb2ludFxuICovXG5mdW5jdGlvbiBjbHVzdGVyQXBpVXJsKGNsdXN0ZXIsIHRscykge1xuICBjb25zdCBrZXkgPSB0bHMgPT09IGZhbHNlID8gJ2h0dHAnIDogJ2h0dHBzJztcbiAgaWYgKCFjbHVzdGVyKSB7XG4gICAgcmV0dXJuIGVuZHBvaW50W2tleV1bJ2Rldm5ldCddO1xuICB9XG4gIGNvbnN0IHVybCA9IGVuZHBvaW50W2tleV1bY2x1c3Rlcl07XG4gIGlmICghdXJsKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBVbmtub3duICR7a2V5fSBjbHVzdGVyOiAke2NsdXN0ZXJ9YCk7XG4gIH1cbiAgcmV0dXJuIHVybDtcbn1cblxuLyoqXG4gKiBTZW5kIGFuZCBjb25maXJtIGEgcmF3IHRyYW5zYWN0aW9uXG4gKlxuICogSWYgYGNvbW1pdG1lbnRgIG9wdGlvbiBpcyBub3Qgc3BlY2lmaWVkLCBkZWZhdWx0cyB0byAnbWF4JyBjb21taXRtZW50LlxuICpcbiAqIEBwYXJhbSB7Q29ubmVjdGlvbn0gY29ubmVjdGlvblxuICogQHBhcmFtIHtCdWZmZXJ9IHJhd1RyYW5zYWN0aW9uXG4gKiBAcGFyYW0ge1RyYW5zYWN0aW9uQ29uZmlybWF0aW9uU3RyYXRlZ3l9IGNvbmZpcm1hdGlvblN0cmF0ZWd5XG4gKiBAcGFyYW0ge0NvbmZpcm1PcHRpb25zfSBbb3B0aW9uc11cbiAqIEByZXR1cm5zIHtQcm9taXNlPFRyYW5zYWN0aW9uU2lnbmF0dXJlPn1cbiAqL1xuXG4vKipcbiAqIEBkZXByZWNhdGVkIENhbGxpbmcgYHNlbmRBbmRDb25maXJtUmF3VHJhbnNhY3Rpb24oKWAgd2l0aG91dCBhIGBjb25maXJtYXRpb25TdHJhdGVneWBcbiAqIGlzIG5vIGxvbmdlciBzdXBwb3J0ZWQgYW5kIHdpbGwgYmUgcmVtb3ZlZCBpbiBhIGZ1dHVyZSB2ZXJzaW9uLlxuICovXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcmVkZWNsYXJlXG5cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1yZWRlY2xhcmVcbmFzeW5jIGZ1bmN0aW9uIHNlbmRBbmRDb25maXJtUmF3VHJhbnNhY3Rpb24oY29ubmVjdGlvbiwgcmF3VHJhbnNhY3Rpb24sIGNvbmZpcm1hdGlvblN0cmF0ZWd5T3JDb25maXJtT3B0aW9ucywgbWF5YmVDb25maXJtT3B0aW9ucykge1xuICBsZXQgY29uZmlybWF0aW9uU3RyYXRlZ3k7XG4gIGxldCBvcHRpb25zO1xuICBpZiAoY29uZmlybWF0aW9uU3RyYXRlZ3lPckNvbmZpcm1PcHRpb25zICYmIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChjb25maXJtYXRpb25TdHJhdGVneU9yQ29uZmlybU9wdGlvbnMsICdsYXN0VmFsaWRCbG9ja0hlaWdodCcpKSB7XG4gICAgY29uZmlybWF0aW9uU3RyYXRlZ3kgPSBjb25maXJtYXRpb25TdHJhdGVneU9yQ29uZmlybU9wdGlvbnM7XG4gICAgb3B0aW9ucyA9IG1heWJlQ29uZmlybU9wdGlvbnM7XG4gIH0gZWxzZSBpZiAoY29uZmlybWF0aW9uU3RyYXRlZ3lPckNvbmZpcm1PcHRpb25zICYmIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChjb25maXJtYXRpb25TdHJhdGVneU9yQ29uZmlybU9wdGlvbnMsICdub25jZVZhbHVlJykpIHtcbiAgICBjb25maXJtYXRpb25TdHJhdGVneSA9IGNvbmZpcm1hdGlvblN0cmF0ZWd5T3JDb25maXJtT3B0aW9ucztcbiAgICBvcHRpb25zID0gbWF5YmVDb25maXJtT3B0aW9ucztcbiAgfSBlbHNlIHtcbiAgICBvcHRpb25zID0gY29uZmlybWF0aW9uU3RyYXRlZ3lPckNvbmZpcm1PcHRpb25zO1xuICB9XG4gIGNvbnN0IHNlbmRPcHRpb25zID0gb3B0aW9ucyAmJiB7XG4gICAgc2tpcFByZWZsaWdodDogb3B0aW9ucy5za2lwUHJlZmxpZ2h0LFxuICAgIHByZWZsaWdodENvbW1pdG1lbnQ6IG9wdGlvbnMucHJlZmxpZ2h0Q29tbWl0bWVudCB8fCBvcHRpb25zLmNvbW1pdG1lbnQsXG4gICAgbWluQ29udGV4dFNsb3Q6IG9wdGlvbnMubWluQ29udGV4dFNsb3RcbiAgfTtcbiAgY29uc3Qgc2lnbmF0dXJlID0gYXdhaXQgY29ubmVjdGlvbi5zZW5kUmF3VHJhbnNhY3Rpb24ocmF3VHJhbnNhY3Rpb24sIHNlbmRPcHRpb25zKTtcbiAgY29uc3QgY29tbWl0bWVudCA9IG9wdGlvbnMgJiYgb3B0aW9ucy5jb21taXRtZW50O1xuICBjb25zdCBjb25maXJtYXRpb25Qcm9taXNlID0gY29uZmlybWF0aW9uU3RyYXRlZ3kgPyBjb25uZWN0aW9uLmNvbmZpcm1UcmFuc2FjdGlvbihjb25maXJtYXRpb25TdHJhdGVneSwgY29tbWl0bWVudCkgOiBjb25uZWN0aW9uLmNvbmZpcm1UcmFuc2FjdGlvbihzaWduYXR1cmUsIGNvbW1pdG1lbnQpO1xuICBjb25zdCBzdGF0dXMgPSAoYXdhaXQgY29uZmlybWF0aW9uUHJvbWlzZSkudmFsdWU7XG4gIGlmIChzdGF0dXMuZXJyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBSYXcgdHJhbnNhY3Rpb24gJHtzaWduYXR1cmV9IGZhaWxlZCAoJHtKU09OLnN0cmluZ2lmeShzdGF0dXMpfSlgKTtcbiAgfVxuICByZXR1cm4gc2lnbmF0dXJlO1xufVxuXG4vKipcbiAqIFRoZXJlIGFyZSAxLWJpbGxpb24gbGFtcG9ydHMgaW4gb25lIFNPTFxuICovXG5jb25zdCBMQU1QT1JUU19QRVJfU09MID0gMTAwMDAwMDAwMDtcblxuZXhwb3J0IHsgQWNjb3VudCwgQWRkcmVzc0xvb2t1cFRhYmxlQWNjb3VudCwgQWRkcmVzc0xvb2t1cFRhYmxlSW5zdHJ1Y3Rpb24sIEFkZHJlc3NMb29rdXBUYWJsZVByb2dyYW0sIEF1dGhvcml6ZWQsIEJMT0NLSEFTSF9DQUNIRV9USU1FT1VUX01TLCBCUEZfTE9BREVSX0RFUFJFQ0FURURfUFJPR1JBTV9JRCwgQlBGX0xPQURFUl9QUk9HUkFNX0lELCBCcGZMb2FkZXIsIENPTVBVVEVfQlVER0VUX0lOU1RSVUNUSU9OX0xBWU9VVFMsIENvbXB1dGVCdWRnZXRJbnN0cnVjdGlvbiwgQ29tcHV0ZUJ1ZGdldFByb2dyYW0sIENvbm5lY3Rpb24sIEVkMjU1MTlQcm9ncmFtLCBFbnVtLCBFcG9jaFNjaGVkdWxlLCBGZWVDYWxjdWxhdG9yTGF5b3V0LCBLZXlwYWlyLCBMQU1QT1JUU19QRVJfU09MLCBMT09LVVBfVEFCTEVfSU5TVFJVQ1RJT05fTEFZT1VUUywgTG9hZGVyLCBMb2NrdXAsIE1BWF9TRUVEX0xFTkdUSCwgTWVzc2FnZSwgTWVzc2FnZUFjY291bnRLZXlzLCBNZXNzYWdlVjAsIE5PTkNFX0FDQ09VTlRfTEVOR1RILCBOb25jZUFjY291bnQsIFBBQ0tFVF9EQVRBX1NJWkUsIFBVQkxJQ19LRVlfTEVOR1RILCBQdWJsaWNLZXksIFNJR05BVFVSRV9MRU5HVEhfSU5fQllURVMsIFNPTEFOQV9TQ0hFTUEsIFNUQUtFX0NPTkZJR19JRCwgU1RBS0VfSU5TVFJVQ1RJT05fTEFZT1VUUywgU1lTVEVNX0lOU1RSVUNUSU9OX0xBWU9VVFMsIFNZU1ZBUl9DTE9DS19QVUJLRVksIFNZU1ZBUl9FUE9DSF9TQ0hFRFVMRV9QVUJLRVksIFNZU1ZBUl9JTlNUUlVDVElPTlNfUFVCS0VZLCBTWVNWQVJfUkVDRU5UX0JMT0NLSEFTSEVTX1BVQktFWSwgU1lTVkFSX1JFTlRfUFVCS0VZLCBTWVNWQVJfUkVXQVJEU19QVUJLRVksIFNZU1ZBUl9TTE9UX0hBU0hFU19QVUJLRVksIFNZU1ZBUl9TTE9UX0hJU1RPUllfUFVCS0VZLCBTWVNWQVJfU1RBS0VfSElTVE9SWV9QVUJLRVksIFNlY3AyNTZrMVByb2dyYW0sIFNlbmRUcmFuc2FjdGlvbkVycm9yLCBTb2xhbmFKU09OUlBDRXJyb3IsIFNvbGFuYUpTT05SUENFcnJvckNvZGUsIFN0YWtlQXV0aG9yaXphdGlvbkxheW91dCwgU3Rha2VJbnN0cnVjdGlvbiwgU3Rha2VQcm9ncmFtLCBTdHJ1Y3QsIFN5c3RlbUluc3RydWN0aW9uLCBTeXN0ZW1Qcm9ncmFtLCBUcmFuc2FjdGlvbiwgVHJhbnNhY3Rpb25FeHBpcmVkQmxvY2toZWlnaHRFeGNlZWRlZEVycm9yLCBUcmFuc2FjdGlvbkV4cGlyZWROb25jZUludmFsaWRFcnJvciwgVHJhbnNhY3Rpb25FeHBpcmVkVGltZW91dEVycm9yLCBUcmFuc2FjdGlvbkluc3RydWN0aW9uLCBUcmFuc2FjdGlvbk1lc3NhZ2UsIFRyYW5zYWN0aW9uU3RhdHVzLCBWQUxJREFUT1JfSU5GT19LRVksIFZFUlNJT05fUFJFRklYX01BU0ssIFZPVEVfUFJPR1JBTV9JRCwgVmFsaWRhdG9ySW5mbywgVmVyc2lvbmVkTWVzc2FnZSwgVmVyc2lvbmVkVHJhbnNhY3Rpb24sIFZvdGVBY2NvdW50LCBWb3RlQXV0aG9yaXphdGlvbkxheW91dCwgVm90ZUluaXQsIFZvdGVJbnN0cnVjdGlvbiwgVm90ZVByb2dyYW0sIGNsdXN0ZXJBcGlVcmwsIHNlbmRBbmRDb25maXJtUmF3VHJhbnNhY3Rpb24sIHNlbmRBbmRDb25maXJtVHJhbnNhY3Rpb24gfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmVzbS5qcy5tYXBcbiJdLCJuYW1lcyI6WyJCdWZmZXIiLCJlZDI1NTE5IiwiQk4iLCJiczU4Iiwic2hhMjU2Iiwic2VyaWFsaXplIiwiZGVzZXJpYWxpemUiLCJkZXNlcmlhbGl6ZVVuY2hlY2tlZCIsIkJ1ZmZlckxheW91dCIsImJsb2IiLCJ0b0JpZ0ludExFIiwidG9CdWZmZXJMRSIsInJlcXVpcmUkJDAiLCJyZXF1aXJlJCQwJDEiLCJyZXF1aXJlJCQwJDIiLCJBZ2VudCIsIkFnZW50JDEiLCJjb2VyY2UiLCJpbnN0YW5jZSIsInN0cmluZyIsInR1cGxlIiwibGl0ZXJhbCIsInVua25vd24iLCJ0eXBlIiwibnVtYmVyIiwiYXJyYXkiLCJudWxsYWJsZSIsIm9wdGlvbmFsIiwiYm9vbGVhbiIsInJlY29yZCIsInVuaW9uIiwiY3JlYXRlIiwiYW55IiwiYXNzZXJ0IiwiYXNzZXJ0JDEiLCJScGNDbGllbnQiLCJub2RlRmV0Y2giLCJScGNXZWJTb2NrZXRDb21tb25DbGllbnQiLCJXZWJzb2NrZXRGYWN0b3J5Iiwia2VjY2FrXzI1NiIsInNlY3AyNTZrMSIsImdlbmVyYXRlUHJpdmF0ZUtleSIsInV0aWxzIiwicmFuZG9tUHJpdmF0ZUtleSIsImdlbmVyYXRlS2V5cGFpciIsInByaXZhdGVTY2FsYXIiLCJwdWJsaWNLZXkiLCJnZXRQdWJsaWNLZXkiLCJzZWNyZXRLZXkiLCJVaW50OEFycmF5Iiwic2V0IiwiaXNPbkN1cnZlIiwiRXh0ZW5kZWRQb2ludCIsImZyb21IZXgiLCJzaWduIiwibWVzc2FnZSIsInNsaWNlIiwidmVyaWZ5IiwidG9CdWZmZXIiLCJhcnIiLCJpc0J1ZmZlciIsImZyb20iLCJidWZmZXIiLCJieXRlT2Zmc2V0IiwiYnl0ZUxlbmd0aCIsIlN0cnVjdCIsImNvbnN0cnVjdG9yIiwicHJvcGVydGllcyIsIk9iamVjdCIsImFzc2lnbiIsImVuY29kZSIsIlNPTEFOQV9TQ0hFTUEiLCJkZWNvZGUiLCJkYXRhIiwiZGVjb2RlVW5jaGVja2VkIiwiRW51bSIsImVudW0iLCJrZXlzIiwibGVuZ3RoIiwiRXJyb3IiLCJtYXAiLCJrZXkiLCJNYXAiLCJfUHVibGljS2V5IiwiTUFYX1NFRURfTEVOR1RIIiwiUFVCTElDX0tFWV9MRU5HVEgiLCJpc1B1YmxpY0tleURhdGEiLCJ2YWx1ZSIsIl9ibiIsInVuZGVmaW5lZCIsInVuaXF1ZVB1YmxpY0tleUNvdW50ZXIiLCJQdWJsaWNLZXkiLCJkZWNvZGVkIiwidW5pcXVlIiwiZXF1YWxzIiwiZXEiLCJ0b0Jhc2U1OCIsInRvQnl0ZXMiLCJ0b0pTT04iLCJidWYiLCJiIiwidG9BcnJheUxpa2UiLCJ6ZXJvUGFkIiwiYWxsb2MiLCJjb3B5IiwiU3ltYm9sIiwidG9TdHJpbmdUYWciLCJ0b1N0cmluZyIsImNyZWF0ZVdpdGhTZWVkIiwiZnJvbVB1YmxpY0tleSIsInNlZWQiLCJwcm9ncmFtSWQiLCJjb25jYXQiLCJwdWJsaWNLZXlCeXRlcyIsImNyZWF0ZVByb2dyYW1BZGRyZXNzU3luYyIsInNlZWRzIiwiZm9yRWFjaCIsIlR5cGVFcnJvciIsImNyZWF0ZVByb2dyYW1BZGRyZXNzIiwiZmluZFByb2dyYW1BZGRyZXNzU3luYyIsIm5vbmNlIiwiYWRkcmVzcyIsInNlZWRzV2l0aE5vbmNlIiwiZXJyIiwiZmluZFByb2dyYW1BZGRyZXNzIiwicHVia2V5RGF0YSIsInB1YmtleSIsImRlZmF1bHQiLCJraW5kIiwiZmllbGRzIiwiQWNjb3VudCIsIl9wdWJsaWNLZXkiLCJfc2VjcmV0S2V5Iiwic2VjcmV0S2V5QnVmZmVyIiwiQlBGX0xPQURFUl9ERVBSRUNBVEVEX1BST0dSQU1fSUQiLCJQQUNLRVRfREFUQV9TSVpFIiwiVkVSU0lPTl9QUkVGSVhfTUFTSyIsIlNJR05BVFVSRV9MRU5HVEhfSU5fQllURVMiLCJUcmFuc2FjdGlvbkV4cGlyZWRCbG9ja2hlaWdodEV4Y2VlZGVkRXJyb3IiLCJzaWduYXR1cmUiLCJkZWZpbmVQcm9wZXJ0eSIsInByb3RvdHlwZSIsIlRyYW5zYWN0aW9uRXhwaXJlZFRpbWVvdXRFcnJvciIsInRpbWVvdXRTZWNvbmRzIiwidG9GaXhlZCIsIlRyYW5zYWN0aW9uRXhwaXJlZE5vbmNlSW52YWxpZEVycm9yIiwiTWVzc2FnZUFjY291bnRLZXlzIiwic3RhdGljQWNjb3VudEtleXMiLCJhY2NvdW50S2V5c0Zyb21Mb29rdXBzIiwia2V5U2VnbWVudHMiLCJwdXNoIiwid3JpdGFibGUiLCJyZWFkb25seSIsImdldCIsImluZGV4Iiwia2V5U2VnbWVudCIsImZsYXQiLCJjb21waWxlSW5zdHJ1Y3Rpb25zIiwiaW5zdHJ1Y3Rpb25zIiwiVThfTUFYIiwia2V5SW5kZXhNYXAiLCJmaW5kS2V5SW5kZXgiLCJrZXlJbmRleCIsImluc3RydWN0aW9uIiwicHJvZ3JhbUlkSW5kZXgiLCJhY2NvdW50S2V5SW5kZXhlcyIsIm1ldGEiLCJwcm9wZXJ0eSIsInJ1c3RTdHJpbmciLCJyc2wiLCJzdHJ1Y3QiLCJ1MzIiLCJvZmZzZXQiLCJfZGVjb2RlIiwiYmluZCIsIl9lbmNvZGUiLCJyc2xTaGltIiwic3RyIiwiY2hhcnMiLCJzcGFuIiwiYXV0aG9yaXplZCIsImxvY2t1cCIsIm5zNjQiLCJ2b3RlSW5pdCIsInU4Iiwidm90ZUF1dGhvcml6ZVdpdGhTZWVkQXJncyIsImdldEFsbG9jIiwiZ2V0SXRlbUFsbG9jIiwiaXRlbSIsImZpZWxkIiwiQXJyYXkiLCJpc0FycmF5IiwiZWxlbWVudExheW91dCIsImxheW91dCIsImRlY29kZUxlbmd0aCIsImJ5dGVzIiwibGVuIiwic2l6ZSIsImVsZW0iLCJzaGlmdCIsImVuY29kZUxlbmd0aCIsInJlbV9sZW4iLCJjb25kaXRpb24iLCJDb21waWxlZEtleXMiLCJwYXllciIsImtleU1ldGFNYXAiLCJjb21waWxlIiwiZ2V0T3JJbnNlcnREZWZhdWx0Iiwia2V5TWV0YSIsImlzU2lnbmVyIiwiaXNXcml0YWJsZSIsImlzSW52b2tlZCIsInBheWVyS2V5TWV0YSIsIml4IiwiYWNjb3VudE1ldGEiLCJnZXRNZXNzYWdlQ29tcG9uZW50cyIsIm1hcEVudHJpZXMiLCJlbnRyaWVzIiwid3JpdGFibGVTaWduZXJzIiwiZmlsdGVyIiwicmVhZG9ubHlTaWduZXJzIiwid3JpdGFibGVOb25TaWduZXJzIiwicmVhZG9ubHlOb25TaWduZXJzIiwiaGVhZGVyIiwibnVtUmVxdWlyZWRTaWduYXR1cmVzIiwibnVtUmVhZG9ubHlTaWduZWRBY2NvdW50cyIsIm51bVJlYWRvbmx5VW5zaWduZWRBY2NvdW50cyIsInBheWVyQWRkcmVzcyIsImV4dHJhY3RUYWJsZUxvb2t1cCIsImxvb2t1cFRhYmxlIiwid3JpdGFibGVJbmRleGVzIiwiZHJhaW5lZFdyaXRhYmxlS2V5cyIsImRyYWluS2V5c0ZvdW5kSW5Mb29rdXBUYWJsZSIsInN0YXRlIiwiYWRkcmVzc2VzIiwicmVhZG9ubHlJbmRleGVzIiwiZHJhaW5lZFJlYWRvbmx5S2V5cyIsImFjY291bnRLZXkiLCJsb29rdXBUYWJsZUVudHJpZXMiLCJrZXlNZXRhRmlsdGVyIiwibG9va3VwVGFibGVJbmRleGVzIiwiZHJhaW5lZEtleXMiLCJsb29rdXBUYWJsZUluZGV4IiwiZmluZEluZGV4IiwiZW50cnkiLCJkZWxldGUiLCJFTkRfT0ZfQlVGRkVSX0VSUk9SX01FU1NBR0UiLCJndWFyZGVkU2hpZnQiLCJieXRlQXJyYXkiLCJndWFyZGVkU3BsaWNlIiwiYXJncyIsInN0YXJ0Iiwic3BsaWNlIiwiTWVzc2FnZSIsImFjY291bnRLZXlzIiwicmVjZW50QmxvY2toYXNoIiwiaW5kZXhUb1Byb2dyYW1JZHMiLCJhY2NvdW50IiwidmVyc2lvbiIsImNvbXBpbGVkSW5zdHJ1Y3Rpb25zIiwiYWNjb3VudHMiLCJhZGRyZXNzVGFibGVMb29rdXBzIiwiZ2V0QWNjb3VudEtleXMiLCJjb21waWxlZEtleXMiLCJwYXllcktleSIsImlzQWNjb3VudFNpZ25lciIsImlzQWNjb3VudFdyaXRhYmxlIiwibnVtU2lnbmVkQWNjb3VudHMiLCJ1bnNpZ25lZEFjY291bnRJbmRleCIsIm51bVVuc2lnbmVkQWNjb3VudHMiLCJudW1Xcml0YWJsZVVuc2lnbmVkQWNjb3VudHMiLCJudW1Xcml0YWJsZVNpZ25lZEFjY291bnRzIiwiaXNQcm9ncmFtSWQiLCJoYXMiLCJwcm9ncmFtSWRzIiwidmFsdWVzIiwibm9uUHJvZ3JhbUlkcyIsIl8iLCJudW1LZXlzIiwia2V5Q291bnQiLCJrZXlJbmRpY2VzQ291bnQiLCJkYXRhQ291bnQiLCJrZXlJbmRpY2VzIiwiZGF0YUxlbmd0aCIsImluc3RydWN0aW9uQ291bnQiLCJpbnN0cnVjdGlvbkJ1ZmZlciIsImluc3RydWN0aW9uQnVmZmVyTGVuZ3RoIiwiaW5zdHJ1Y3Rpb25MYXlvdXQiLCJzZXEiLCJzaWduRGF0YUxheW91dCIsInRyYW5zYWN0aW9uIiwic2lnbkRhdGEiLCJhY2NvdW50Q291bnQiLCJpIiwiZGF0YVNsaWNlIiwibWVzc2FnZUFyZ3MiLCJNZXNzYWdlVjAiLCJudW1BY2NvdW50S2V5c0Zyb21Mb29rdXBzIiwiY291bnQiLCJsb29rdXAiLCJhZGRyZXNzTG9va3VwVGFibGVBY2NvdW50cyIsInJlc29sdmVBZGRyZXNzVGFibGVMb29rdXBzIiwibnVtU3RhdGljQWNjb3VudEtleXMiLCJsb29rdXBBY2NvdW50S2V5c0luZGV4IiwibnVtV3JpdGFibGVMb29rdXBBY2NvdW50S2V5cyIsInJlZHVjZSIsInRhYmxlTG9va3VwIiwidGFibGVBY2NvdW50IiwiZmluZCIsImxvb2t1cFRhYmxlQWNjb3VudHMiLCJleHRyYWN0UmVzdWx0IiwiYWRkcmVzc1RhYmxlTG9va3VwIiwiZW5jb2RlZFN0YXRpY0FjY291bnRLZXlzTGVuZ3RoIiwic2VyaWFsaXplZEluc3RydWN0aW9ucyIsInNlcmlhbGl6ZUluc3RydWN0aW9ucyIsImVuY29kZWRJbnN0cnVjdGlvbnNMZW5ndGgiLCJzZXJpYWxpemVkQWRkcmVzc1RhYmxlTG9va3VwcyIsInNlcmlhbGl6ZUFkZHJlc3NUYWJsZUxvb2t1cHMiLCJlbmNvZGVkQWRkcmVzc1RhYmxlTG9va3Vwc0xlbmd0aCIsIm1lc3NhZ2VMYXlvdXQiLCJzZXJpYWxpemVkTWVzc2FnZSIsIk1FU1NBR0VfVkVSU0lPTl8wX1BSRUZJWCIsInNlcmlhbGl6ZWRNZXNzYWdlTGVuZ3RoIiwicHJlZml4Iiwic3RhdGljQWNjb3VudEtleXNMZW5ndGgiLCJpbnN0cnVjdGlvbnNMZW5ndGgiLCJhZGRyZXNzVGFibGVMb29rdXBzTGVuZ3RoIiwic2VyaWFsaXplZExlbmd0aCIsImVuY29kZWRBY2NvdW50S2V5SW5kZXhlc0xlbmd0aCIsImVuY29kZWREYXRhTGVuZ3RoIiwiZW5jb2RlZFdyaXRhYmxlSW5kZXhlc0xlbmd0aCIsImVuY29kZWRSZWFkb25seUluZGV4ZXNMZW5ndGgiLCJhZGRyZXNzVGFibGVMb29rdXBMYXlvdXQiLCJtYXNrZWRQcmVmaXgiLCJhY2NvdW50S2V5SW5kZXhlc0xlbmd0aCIsImFkZHJlc3NUYWJsZUxvb2t1cHNDb3VudCIsIndyaXRhYmxlSW5kZXhlc0xlbmd0aCIsInJlYWRvbmx5SW5kZXhlc0xlbmd0aCIsIlZlcnNpb25lZE1lc3NhZ2UiLCJkZXNlcmlhbGl6ZU1lc3NhZ2VWZXJzaW9uIiwiVHJhbnNhY3Rpb25TdGF0dXMiLCJERUZBVUxUX1NJR05BVFVSRSIsImZpbGwiLCJUcmFuc2FjdGlvbkluc3RydWN0aW9uIiwib3B0cyIsIlRyYW5zYWN0aW9uIiwic2lnbmF0dXJlcyIsImZlZVBheWVyIiwibGFzdFZhbGlkQmxvY2tIZWlnaHQiLCJub25jZUluZm8iLCJtaW5Ob25jZUNvbnRleHRTbG90IiwiX21lc3NhZ2UiLCJfanNvbiIsImhhc093blByb3BlcnR5IiwiY2FsbCIsIm1pbkNvbnRleHRTbG90IiwiYmxvY2toYXNoIiwibm9uY2VJbnN0cnVjdGlvbiIsInNpZ25lcnMiLCJhZGQiLCJpdGVtcyIsImNvbXBpbGVNZXNzYWdlIiwiSlNPTiIsInN0cmluZ2lmeSIsImNvbnNvbGUiLCJ3YXJuIiwiYWNjb3VudE1ldGFzIiwiaW5jbHVkZXMiLCJ1bmlxdWVNZXRhcyIsInB1YmtleVN0cmluZyIsInVuaXF1ZUluZGV4IiwieCIsInNvcnQiLCJ5Iiwib3B0aW9ucyIsImxvY2FsZU1hdGNoZXIiLCJ1c2FnZSIsInNlbnNpdGl2aXR5IiwiaWdub3JlUHVuY3R1YXRpb24iLCJudW1lcmljIiwiY2FzZUZpcnN0IiwibG9jYWxlQ29tcGFyZSIsImZlZVBheWVySW5kZXgiLCJwYXllck1ldGEiLCJ1bnNoaWZ0Iiwic2lnbmVkS2V5cyIsInVuc2lnbmVkS2V5cyIsImluZGV4T2YiLCJfY29tcGlsZSIsInZhbGlkIiwiZXZlcnkiLCJwYWlyIiwic2VyaWFsaXplTWVzc2FnZSIsImdldEVzdGltYXRlZEZlZSIsImNvbm5lY3Rpb24iLCJnZXRGZWVGb3JNZXNzYWdlIiwic2V0U2lnbmVycyIsInNlZW4iLCJTZXQiLCJ1bmlxdWVTaWduZXJzIiwic2lnbmVyIiwiX3BhcnRpYWxTaWduIiwicGFydGlhbFNpZ24iLCJfYWRkU2lnbmF0dXJlIiwiYWRkU2lnbmF0dXJlIiwic2lncGFpciIsInZlcmlmeVNpZ25hdHVyZXMiLCJyZXF1aXJlQWxsU2lnbmF0dXJlcyIsInNpZ25hdHVyZUVycm9ycyIsIl9nZXRNZXNzYWdlU2lnbmVkbmVzc0Vycm9ycyIsImVycm9ycyIsIm1pc3NpbmciLCJpbnZhbGlkIiwiY29uZmlnIiwic2lnRXJyb3JzIiwiZXJyb3JNZXNzYWdlIiwicCIsImpvaW4iLCJfc2VyaWFsaXplIiwic2lnbmF0dXJlQ291bnQiLCJ0cmFuc2FjdGlvbkxlbmd0aCIsIndpcmVUcmFuc2FjdGlvbiIsImtleU9iaiIsInBvcHVsYXRlIiwic2lnUHVia2V5UGFpciIsInNvbWUiLCJUcmFuc2FjdGlvbk1lc3NhZ2UiLCJkZWNvbXBpbGUiLCJjb21waWxlZEl4IiwiY29tcGlsZVRvTGVnYWN5TWVzc2FnZSIsImNvbXBpbGVUb1YwTWVzc2FnZSIsIlZlcnNpb25lZFRyYW5zYWN0aW9uIiwiZGVmYXVsdFNpZ25hdHVyZXMiLCJlbmNvZGVkU2lnbmF0dXJlc0xlbmd0aCIsInRyYW5zYWN0aW9uTGF5b3V0Iiwic2VyaWFsaXplZFRyYW5zYWN0aW9uIiwic2VyaWFsaXplZFRyYW5zYWN0aW9uTGVuZ3RoIiwic2lnbmF0dXJlc0xlbmd0aCIsIm1lc3NhZ2VEYXRhIiwic2lnbmVyUHVia2V5cyIsInNpZ25lckluZGV4IiwiTlVNX1RJQ0tTX1BFUl9TRUNPTkQiLCJERUZBVUxUX1RJQ0tTX1BFUl9TTE9UIiwiTlVNX1NMT1RTX1BFUl9TRUNPTkQiLCJNU19QRVJfU0xPVCIsIlNZU1ZBUl9DTE9DS19QVUJLRVkiLCJTWVNWQVJfRVBPQ0hfU0NIRURVTEVfUFVCS0VZIiwiU1lTVkFSX0lOU1RSVUNUSU9OU19QVUJLRVkiLCJTWVNWQVJfUkVDRU5UX0JMT0NLSEFTSEVTX1BVQktFWSIsIlNZU1ZBUl9SRU5UX1BVQktFWSIsIlNZU1ZBUl9SRVdBUkRTX1BVQktFWSIsIlNZU1ZBUl9TTE9UX0hBU0hFU19QVUJLRVkiLCJTWVNWQVJfU0xPVF9ISVNUT1JZX1BVQktFWSIsIlNZU1ZBUl9TVEFLRV9ISVNUT1JZX1BVQktFWSIsInNlbmRBbmRDb25maXJtVHJhbnNhY3Rpb24iLCJzZW5kT3B0aW9ucyIsInNraXBQcmVmbGlnaHQiLCJwcmVmbGlnaHRDb21taXRtZW50IiwiY29tbWl0bWVudCIsIm1heFJldHJpZXMiLCJzZW5kVHJhbnNhY3Rpb24iLCJzdGF0dXMiLCJjb25maXJtVHJhbnNhY3Rpb24iLCJhYm9ydFNpZ25hbCIsIm5vbmNlQWNjb3VudFB1YmtleSIsIm5vbmNlVmFsdWUiLCJzbGVlcCIsIm1zIiwiUHJvbWlzZSIsInJlc29sdmUiLCJzZXRUaW1lb3V0IiwiZW5jb2RlRGF0YSIsImFsbG9jTGVuZ3RoIiwibGF5b3V0RmllbGRzIiwiZGVjb2RlRGF0YSQxIiwiRmVlQ2FsY3VsYXRvckxheW91dCIsIm51NjQiLCJOb25jZUFjY291bnRMYXlvdXQiLCJOT05DRV9BQ0NPVU5UX0xFTkdUSCIsIk5vbmNlQWNjb3VudCIsImF1dGhvcml6ZWRQdWJrZXkiLCJmZWVDYWxjdWxhdG9yIiwiZnJvbUFjY291bnREYXRhIiwibm9uY2VBY2NvdW50IiwiZW5jb2RlRGVjb2RlIiwiYmlnSW50IiwiYmlnSW50TGF5b3V0Iiwic3JjIiwidTY0IiwiU3lzdGVtSW5zdHJ1Y3Rpb24iLCJkZWNvZGVJbnN0cnVjdGlvblR5cGUiLCJjaGVja1Byb2dyYW1JZCIsImluc3RydWN0aW9uVHlwZUxheW91dCIsInR5cGVJbmRleCIsIml4VHlwZSIsIlNZU1RFTV9JTlNUUlVDVElPTl9MQVlPVVRTIiwiZGVjb2RlQ3JlYXRlQWNjb3VudCIsImNoZWNrS2V5TGVuZ3RoIiwibGFtcG9ydHMiLCJzcGFjZSIsIkNyZWF0ZSIsImZyb21QdWJrZXkiLCJuZXdBY2NvdW50UHVia2V5IiwiZGVjb2RlVHJhbnNmZXIiLCJUcmFuc2ZlciIsInRvUHVia2V5IiwiZGVjb2RlVHJhbnNmZXJXaXRoU2VlZCIsIlRyYW5zZmVyV2l0aFNlZWQiLCJiYXNlUHVia2V5IiwiZGVjb2RlQWxsb2NhdGUiLCJBbGxvY2F0ZSIsImFjY291bnRQdWJrZXkiLCJkZWNvZGVBbGxvY2F0ZVdpdGhTZWVkIiwiYmFzZSIsIkFsbG9jYXRlV2l0aFNlZWQiLCJkZWNvZGVBc3NpZ24iLCJBc3NpZ24iLCJkZWNvZGVBc3NpZ25XaXRoU2VlZCIsIkFzc2lnbldpdGhTZWVkIiwiZGVjb2RlQ3JlYXRlV2l0aFNlZWQiLCJDcmVhdGVXaXRoU2VlZCIsImRlY29kZU5vbmNlSW5pdGlhbGl6ZSIsIkluaXRpYWxpemVOb25jZUFjY291bnQiLCJub25jZVB1YmtleSIsImRlY29kZU5vbmNlQWR2YW5jZSIsIkFkdmFuY2VOb25jZUFjY291bnQiLCJkZWNvZGVOb25jZVdpdGhkcmF3IiwiV2l0aGRyYXdOb25jZUFjY291bnQiLCJkZWNvZGVOb25jZUF1dGhvcml6ZSIsIkF1dGhvcml6ZU5vbmNlQWNjb3VudCIsIm5ld0F1dGhvcml6ZWRQdWJrZXkiLCJTeXN0ZW1Qcm9ncmFtIiwiZXhwZWN0ZWRMZW5ndGgiLCJmcmVlemUiLCJVcGdyYWRlTm9uY2VBY2NvdW50IiwiY3JlYXRlQWNjb3VudCIsInBhcmFtcyIsInRyYW5zZmVyIiwiQmlnSW50IiwiY3JlYXRlQWNjb3VudFdpdGhTZWVkIiwiY3JlYXRlTm9uY2VBY2NvdW50IiwiaW5pdFBhcmFtcyIsIm5vbmNlSW5pdGlhbGl6ZSIsImluc3RydWN0aW9uRGF0YSIsIm5vbmNlQWR2YW5jZSIsIm5vbmNlV2l0aGRyYXciLCJub25jZUF1dGhvcml6ZSIsImFsbG9jYXRlIiwiQ0hVTktfU0laRSIsIkxvYWRlciIsImdldE1pbk51bVNpZ25hdHVyZXMiLCJNYXRoIiwiY2VpbCIsImNodW5rU2l6ZSIsImxvYWQiLCJwcm9ncmFtIiwiYmFsYW5jZU5lZWRlZCIsImdldE1pbmltdW1CYWxhbmNlRm9yUmVudEV4ZW1wdGlvbiIsInByb2dyYW1JbmZvIiwiZ2V0QWNjb3VudEluZm8iLCJleGVjdXRhYmxlIiwiZXJyb3IiLCJvd25lciIsImRhdGFMYXlvdXQiLCJ0cmFuc2FjdGlvbnMiLCJieXRlc0xlbmd0aCIsImJ5dGVzTGVuZ3RoUGFkZGluZyIsIl9ycGNFbmRwb2ludCIsIlJFUVVFU1RTX1BFUl9TRUNPTkQiLCJhbGwiLCJkZXBsb3lDb21taXRtZW50IiwiZmluYWxpemVTaWduYXR1cmUiLCJjb250ZXh0IiwiY3VycmVudFNsb3QiLCJnZXRTbG90Iiwic2xvdCIsInJvdW5kIiwiQlBGX0xPQURFUl9QUk9HUkFNX0lEIiwiQnBmTG9hZGVyIiwiZWxmIiwibG9hZGVyUHJvZ3JhbUlkIiwiZ2V0RGVmYXVsdEV4cG9ydEZyb21DanMiLCJfX2VzTW9kdWxlIiwiYWdlbnRrZWVwYWxpdmUiLCJleHBvcnRzIiwicyIsIm0iLCJoIiwiZCIsInciLCJtcyQyIiwidmFsIiwicGFyc2UiLCJpc0Zpbml0ZSIsImxvbmciLCJmbXRMb25nIiwiZm10U2hvcnQiLCJTdHJpbmciLCJtYXRjaCIsImV4ZWMiLCJuIiwicGFyc2VGbG9hdCIsInRvTG93ZXJDYXNlIiwibXNBYnMiLCJhYnMiLCJwbHVyYWwiLCJuYW1lIiwiaXNQbHVyYWwiLCJ1dGlsIiwibXMkMSIsImh1bWFuaXplTXMiLCJ0IiwiciIsImZvcm1hdCIsInN0YWNrIiwiY29uc3RhbnRzIiwiQ1VSUkVOVF9JRCIsIkNSRUFURV9JRCIsIklOSVRfU09DS0VUIiwiQ1JFQVRFX0hUVFBTX0NPTk5FQ1RJT04iLCJTT0NLRVRfQ1JFQVRFRF9USU1FIiwiU09DS0VUX05BTUUiLCJTT0NLRVRfUkVRVUVTVF9DT1VOVCIsIlNPQ0tFVF9SRVFVRVNUX0ZJTklTSEVEX0NPVU5UIiwiT3JpZ2luYWxBZ2VudCIsImRlYnVnIiwiZGVidWdsb2ciLCJJTklUX1NPQ0tFVCQxIiwiZGVmYXVsdFRpbWVvdXRMaXN0ZW5lckNvdW50IiwibWFqb3JWZXJzaW9uIiwicGFyc2VJbnQiLCJwcm9jZXNzIiwic3BsaXQiLCJzdWJzdHJpbmciLCJkZXByZWNhdGUiLCJsb2ciLCJrZWVwQWxpdmUiLCJmcmVlU29ja2V0VGltZW91dCIsImtlZXBBbGl2ZVRpbWVvdXQiLCJmcmVlU29ja2V0S2VlcEFsaXZlVGltZW91dCIsInRpbWVvdXQiLCJtYXgiLCJzb2NrZXRBY3RpdmVUVEwiLCJjcmVhdGVTb2NrZXRDb3VudCIsImNyZWF0ZVNvY2tldENvdW50TGFzdENoZWNrIiwiY3JlYXRlU29ja2V0RXJyb3JDb3VudCIsImNyZWF0ZVNvY2tldEVycm9yQ291bnRMYXN0Q2hlY2siLCJjbG9zZVNvY2tldENvdW50IiwiY2xvc2VTb2NrZXRDb3VudExhc3RDaGVjayIsImVycm9yU29ja2V0Q291bnQiLCJlcnJvclNvY2tldENvdW50TGFzdENoZWNrIiwicmVxdWVzdENvdW50IiwicmVxdWVzdENvdW50TGFzdENoZWNrIiwidGltZW91dFNvY2tldENvdW50IiwidGltZW91dFNvY2tldENvdW50TGFzdENoZWNrIiwib24iLCJzb2NrZXQiLCJjYWxjU29ja2V0VGltZW91dCIsImFsaXZlVGltZSIsIkRhdGUiLCJub3ciLCJkaWZmIiwiY3VzdG9tRnJlZVNvY2tldFRpbWVvdXQiLCJrZWVwU29ja2V0QWxpdmUiLCJyZXN1bHQiLCJjdXN0b21UaW1lb3V0IiwicmV1c2VTb2NrZXQiLCJyZXEiLCJyZXVzZWRTb2NrZXQiLCJhZ2VudFRpbWVvdXQiLCJnZXRTb2NrZXRUaW1lb3V0IiwiaWQiLCJOdW1iZXIiLCJNQVhfU0FGRV9JTlRFR0VSIiwic2V0Tm9EZWxheSIsIl9hZ2VudEtleSIsImluc3RhbGxMaXN0ZW5lcnMiLCJjcmVhdGVDb25uZWN0aW9uIiwib25jcmVhdGUiLCJjYWxsZWQiLCJvbk5ld0NyZWF0ZSIsIm5ld1NvY2tldCIsInN0YXR1c0NoYW5nZWQiLCJjaGFuZ2VkIiwiZ2V0Q3VycmVudFN0YXR1cyIsImZyZWVTb2NrZXRzIiwiaW5zcGVjdCIsInNvY2tldHMiLCJyZXF1ZXN0cyIsIl9pZGxlVGltZW91dCIsImFnZW50Iiwib25GcmVlIiwiX2h0dHBNZXNzYWdlIiwiZ2V0TmFtZSIsIm9uQ2xvc2UiLCJpc0Vycm9yIiwib25UaW1lb3V0IiwibGlzdGVuZXJDb3VudCIsImxpc3RlbmVycyIsInJlcVRpbWVvdXRMaXN0ZW5lckNvdW50IiwiZW5hYmxlZCIsImYiLCJkZXN0cm95IiwicmVtb3ZlU29ja2V0IiwiY29kZSIsIm9uRXJyb3IiLCJyZW1vdmVMaXN0ZW5lciIsImVtaXQiLCJvblJlbW92ZSIsIm9iaiIsInJlcyIsIk9yaWdpbmFsSHR0cHNBZ2VudCIsIkh0dHBBZ2VudCIsIkh0dHBzQWdlbnQkMSIsIkh0dHBzQWdlbnQiLCJkZWZhdWx0UG9ydCIsInByb3RvY29sIiwibWF4Q2FjaGVkU2Vzc2lvbnMiLCJfc2Vzc2lvbkNhY2hlIiwibGlzdCIsIm1ldGhvZCIsImh0dHBzX2FnZW50IiwiYWdlbnRrZWVwYWxpdmVFeHBvcnRzIiwiSHR0cEtlZXBBbGl2ZUFnZW50Iiwib2JqVG9TdHJpbmciLCJvYmpLZXlzIiwiaXNBcnJheVByb3AiLCJwcm9wVmFsIiwidG9TdHIiLCJmYXN0U3RhYmxlU3RyaW5naWZ5IiwicmV0dXJuVmFsIiwiZmFzdFN0YWJsZVN0cmluZ2lmeSQxIiwiTUlOSU1VTV9TTE9UX1BFUl9FUE9DSCIsInRyYWlsaW5nWmVyb3MiLCJuZXh0UG93ZXJPZlR3byIsIkVwb2NoU2NoZWR1bGUiLCJzbG90c1BlckVwb2NoIiwibGVhZGVyU2NoZWR1bGVTbG90T2Zmc2V0Iiwid2FybXVwIiwiZmlyc3ROb3JtYWxFcG9jaCIsImZpcnN0Tm9ybWFsU2xvdCIsImdldEVwb2NoIiwiZ2V0RXBvY2hBbmRTbG90SW5kZXgiLCJlcG9jaCIsImVwb2NoTGVuIiwiZ2V0U2xvdHNJbkVwb2NoIiwic2xvdEluZGV4Iiwibm9ybWFsU2xvdEluZGV4Iiwibm9ybWFsRXBvY2hJbmRleCIsImZsb29yIiwiZ2V0Rmlyc3RTbG90SW5FcG9jaCIsInBvdyIsImdldExhc3RTbG90SW5FcG9jaCIsIlNlbmRUcmFuc2FjdGlvbkVycm9yIiwibG9ncyIsIlNvbGFuYUpTT05SUENFcnJvckNvZGUiLCJKU09OX1JQQ19TRVJWRVJfRVJST1JfQkxPQ0tfQ0xFQU5FRF9VUCIsIkpTT05fUlBDX1NFUlZFUl9FUlJPUl9TRU5EX1RSQU5TQUNUSU9OX1BSRUZMSUdIVF9GQUlMVVJFIiwiSlNPTl9SUENfU0VSVkVSX0VSUk9SX1RSQU5TQUNUSU9OX1NJR05BVFVSRV9WRVJJRklDQVRJT05fRkFJTFVSRSIsIkpTT05fUlBDX1NFUlZFUl9FUlJPUl9CTE9DS19OT1RfQVZBSUxBQkxFIiwiSlNPTl9SUENfU0VSVkVSX0VSUk9SX05PREVfVU5IRUFMVEhZIiwiSlNPTl9SUENfU0VSVkVSX0VSUk9SX1RSQU5TQUNUSU9OX1BSRUNPTVBJTEVfVkVSSUZJQ0FUSU9OX0ZBSUxVUkUiLCJKU09OX1JQQ19TRVJWRVJfRVJST1JfU0xPVF9TS0lQUEVEIiwiSlNPTl9SUENfU0VSVkVSX0VSUk9SX05PX1NOQVBTSE9UIiwiSlNPTl9SUENfU0VSVkVSX0VSUk9SX0xPTkdfVEVSTV9TVE9SQUdFX1NMT1RfU0tJUFBFRCIsIkpTT05fUlBDX1NFUlZFUl9FUlJPUl9LRVlfRVhDTFVERURfRlJPTV9TRUNPTkRBUllfSU5ERVgiLCJKU09OX1JQQ19TRVJWRVJfRVJST1JfVFJBTlNBQ1RJT05fSElTVE9SWV9OT1RfQVZBSUxBQkxFIiwiSlNPTl9SUENfU0NBTl9FUlJPUiIsIkpTT05fUlBDX1NFUlZFUl9FUlJPUl9UUkFOU0FDVElPTl9TSUdOQVRVUkVfTEVOX01JU01BVENIIiwiSlNPTl9SUENfU0VSVkVSX0VSUk9SX0JMT0NLX1NUQVRVU19OT1RfQVZBSUxBQkxFX1lFVCIsIkpTT05fUlBDX1NFUlZFUl9FUlJPUl9VTlNVUFBPUlRFRF9UUkFOU0FDVElPTl9WRVJTSU9OIiwiSlNPTl9SUENfU0VSVkVSX0VSUk9SX01JTl9DT05URVhUX1NMT1RfTk9UX1JFQUNIRUQiLCJTb2xhbmFKU09OUlBDRXJyb3IiLCJjdXN0b21NZXNzYWdlIiwiZmV0Y2hJbXBsIiwiZ2xvYmFsVGhpcyIsImZldGNoIiwiaW5wdXQiLCJpbml0IiwicHJvY2Vzc2VkSW5wdXQiLCJScGNXZWJTb2NrZXRDbGllbnQiLCJnZW5lcmF0ZV9yZXF1ZXN0X2lkIiwid2ViU29ja2V0RmFjdG9yeSIsInVybCIsInJwYyIsImF1dG9jb25uZWN0IiwibWF4X3JlY29ubmVjdHMiLCJyZWNvbm5lY3QiLCJyZWNvbm5lY3RfaW50ZXJ2YWwiLCJ1bmRlcmx5aW5nU29ja2V0IiwicmVhZHlTdGF0ZSIsInJlamVjdCIsIm5vdGlmeSIsImRlY29kZURhdGEiLCJMT09LVVBfVEFCTEVfTUVUQV9TSVpFIiwiQWRkcmVzc0xvb2t1cFRhYmxlQWNjb3VudCIsImlzQWN0aXZlIiwiVTY0X01BWCIsImRlYWN0aXZhdGlvblNsb3QiLCJhY2NvdW50RGF0YSIsIkxvb2t1cFRhYmxlTWV0YUxheW91dCIsInNlcmlhbGl6ZWRBZGRyZXNzZXNMZW4iLCJudW1TZXJpYWxpemVkQWRkcmVzc2VzIiwibGFzdEV4dGVuZGVkU2xvdCIsImxhc3RFeHRlbmRlZFNsb3RTdGFydEluZGV4IiwibGFzdEV4dGVuZGVkU3RhcnRJbmRleCIsImF1dGhvcml0eSIsIlVSTF9SRSIsIm1ha2VXZWJzb2NrZXRVcmwiLCJlbmRwb2ludCIsIm1hdGNoZXMiLCJob3N0aXNoIiwicG9ydFdpdGhDb2xvbiIsInJlc3QiLCJzdGFydHNXaXRoIiwic3RhcnRQb3J0Iiwid2Vic29ja2V0UG9ydCIsIlB1YmxpY0tleUZyb21TdHJpbmciLCJSYXdBY2NvdW50RGF0YVJlc3VsdCIsIkJ1ZmZlckZyb21SYXdBY2NvdW50RGF0YSIsIkJMT0NLSEFTSF9DQUNIRV9USU1FT1VUX01TIiwiYXNzZXJ0RW5kcG9pbnRVcmwiLCJwdXRhdGl2ZVVybCIsInRlc3QiLCJleHRyYWN0Q29tbWl0bWVudEZyb21Db25maWciLCJjb21taXRtZW50T3JDb25maWciLCJzcGVjaWZpZWRDb21taXRtZW50Iiwic3BlY2lmaWVkQ29uZmlnIiwiY3JlYXRlUnBjUmVzdWx0IiwianNvbnJwYyIsIlVua25vd25ScGNSZXN1bHQiLCJqc29uUnBjUmVzdWx0Iiwic2NoZW1hIiwianNvblJwY1Jlc3VsdEFuZENvbnRleHQiLCJub3RpZmljYXRpb25SZXN1bHRBbmRDb250ZXh0IiwidmVyc2lvbmVkTWVzc2FnZUZyb21SZXNwb25zZSIsInJlc3BvbnNlIiwiR2V0SW5mbGF0aW9uR292ZXJub3JSZXN1bHQiLCJmb3VuZGF0aW9uIiwiZm91bmRhdGlvblRlcm0iLCJpbml0aWFsIiwidGFwZXIiLCJ0ZXJtaW5hbCIsIkdldEluZmxhdGlvblJld2FyZFJlc3VsdCIsImVmZmVjdGl2ZVNsb3QiLCJhbW91bnQiLCJwb3N0QmFsYW5jZSIsImNvbW1pc3Npb24iLCJHZXRSZWNlbnRQcmlvcml0aXphdGlvbkZlZXNSZXN1bHQiLCJwcmlvcml0aXphdGlvbkZlZSIsIkdldEluZmxhdGlvblJhdGVSZXN1bHQiLCJ0b3RhbCIsInZhbGlkYXRvciIsIkdldEVwb2NoSW5mb1Jlc3VsdCIsInNsb3RzSW5FcG9jaCIsImFic29sdXRlU2xvdCIsImJsb2NrSGVpZ2h0IiwidHJhbnNhY3Rpb25Db3VudCIsIkdldEVwb2NoU2NoZWR1bGVSZXN1bHQiLCJHZXRMZWFkZXJTY2hlZHVsZVJlc3VsdCIsIlRyYW5zYWN0aW9uRXJyb3JSZXN1bHQiLCJTaWduYXR1cmVTdGF0dXNSZXN1bHQiLCJTaWduYXR1cmVSZWNlaXZlZFJlc3VsdCIsIlZlcnNpb25SZXN1bHQiLCJTaW11bGF0ZWRUcmFuc2FjdGlvblJlc3BvbnNlU3RydWN0IiwicmVudEVwb2NoIiwidW5pdHNDb25zdW1lZCIsInJldHVybkRhdGEiLCJCbG9ja1Byb2R1Y3Rpb25SZXNwb25zZVN0cnVjdCIsImJ5SWRlbnRpdHkiLCJyYW5nZSIsImZpcnN0U2xvdCIsImxhc3RTbG90IiwiY3JlYXRlUnBjQ2xpZW50IiwiaHR0cEhlYWRlcnMiLCJjdXN0b21GZXRjaCIsImZldGNoTWlkZGxld2FyZSIsImRpc2FibGVSZXRyeU9uUmF0ZUxpbWl0IiwiaHR0cEFnZW50IiwiYWdlbnRPcHRpb25zIiwibWF4U29ja2V0cyIsImlzSHR0cHMiLCJmZXRjaFdpdGhNaWRkbGV3YXJlIiwiaW5mbyIsIm1vZGlmaWVkRmV0Y2hBcmdzIiwibW9kaWZpZWRJbmZvIiwibW9kaWZpZWRJbml0IiwiY2xpZW50QnJvd3NlciIsInJlcXVlc3QiLCJjYWxsYmFjayIsImJvZHkiLCJoZWFkZXJzIiwiQ09NTU9OX0hUVFBfSEVBREVSUyIsInRvb19tYW55X3JlcXVlc3RzX3JldHJpZXMiLCJ3YWl0VGltZSIsInN0YXR1c1RleHQiLCJ0ZXh0Iiwib2siLCJjcmVhdGVScGNSZXF1ZXN0IiwiY2xpZW50IiwiY3JlYXRlUnBjQmF0Y2hSZXF1ZXN0IiwiYmF0Y2giLCJtZXRob2ROYW1lIiwiR2V0SW5mbGF0aW9uR292ZXJub3JScGNSZXN1bHQiLCJHZXRJbmZsYXRpb25SYXRlUnBjUmVzdWx0IiwiR2V0UmVjZW50UHJpb3JpdGl6YXRpb25GZWVzUnBjUmVzdWx0IiwiR2V0RXBvY2hJbmZvUnBjUmVzdWx0IiwiR2V0RXBvY2hTY2hlZHVsZVJwY1Jlc3VsdCIsIkdldExlYWRlclNjaGVkdWxlUnBjUmVzdWx0IiwiU2xvdFJwY1Jlc3VsdCIsIkdldFN1cHBseVJwY1Jlc3VsdCIsImNpcmN1bGF0aW5nIiwibm9uQ2lyY3VsYXRpbmciLCJub25DaXJjdWxhdGluZ0FjY291bnRzIiwiVG9rZW5BbW91bnRSZXN1bHQiLCJ1aUFtb3VudCIsImRlY2ltYWxzIiwidWlBbW91bnRTdHJpbmciLCJHZXRUb2tlbkxhcmdlc3RBY2NvdW50c1Jlc3VsdCIsIkdldFRva2VuQWNjb3VudHNCeU93bmVyIiwiUGFyc2VkQWNjb3VudERhdGFSZXN1bHQiLCJwYXJzZWQiLCJHZXRQYXJzZWRUb2tlbkFjY291bnRzQnlPd25lciIsIkdldExhcmdlc3RBY2NvdW50c1JwY1Jlc3VsdCIsIkFjY291bnRJbmZvUmVzdWx0IiwiS2V5ZWRBY2NvdW50SW5mb1Jlc3VsdCIsIlBhcnNlZE9yUmF3QWNjb3VudERhdGEiLCJQYXJzZWRBY2NvdW50SW5mb1Jlc3VsdCIsIktleWVkUGFyc2VkQWNjb3VudEluZm9SZXN1bHQiLCJTdGFrZUFjdGl2YXRpb25SZXN1bHQiLCJhY3RpdmUiLCJpbmFjdGl2ZSIsIkdldENvbmZpcm1lZFNpZ25hdHVyZXNGb3JBZGRyZXNzMlJwY1Jlc3VsdCIsIm1lbW8iLCJibG9ja1RpbWUiLCJHZXRTaWduYXR1cmVzRm9yQWRkcmVzc1JwY1Jlc3VsdCIsIkFjY291bnROb3RpZmljYXRpb25SZXN1bHQiLCJzdWJzY3JpcHRpb24iLCJQcm9ncmFtQWNjb3VudEluZm9SZXN1bHQiLCJQcm9ncmFtQWNjb3VudE5vdGlmaWNhdGlvblJlc3VsdCIsIlNsb3RJbmZvUmVzdWx0IiwicGFyZW50Iiwicm9vdCIsIlNsb3ROb3RpZmljYXRpb25SZXN1bHQiLCJTbG90VXBkYXRlUmVzdWx0IiwidGltZXN0YW1wIiwic3RhdHMiLCJudW1UcmFuc2FjdGlvbkVudHJpZXMiLCJudW1TdWNjZXNzZnVsVHJhbnNhY3Rpb25zIiwibnVtRmFpbGVkVHJhbnNhY3Rpb25zIiwibWF4VHJhbnNhY3Rpb25zUGVyRW50cnkiLCJTbG90VXBkYXRlTm90aWZpY2F0aW9uUmVzdWx0IiwiU2lnbmF0dXJlTm90aWZpY2F0aW9uUmVzdWx0IiwiUm9vdE5vdGlmaWNhdGlvblJlc3VsdCIsIkNvbnRhY3RJbmZvUmVzdWx0IiwiZ29zc2lwIiwidHB1IiwiVm90ZUFjY291bnRJbmZvUmVzdWx0Iiwidm90ZVB1YmtleSIsIm5vZGVQdWJrZXkiLCJhY3RpdmF0ZWRTdGFrZSIsImVwb2NoVm90ZUFjY291bnQiLCJlcG9jaENyZWRpdHMiLCJsYXN0Vm90ZSIsInJvb3RTbG90IiwiR2V0Vm90ZUFjY291bnRzIiwiY3VycmVudCIsImRlbGlucXVlbnQiLCJDb25maXJtYXRpb25TdGF0dXMiLCJTaWduYXR1cmVTdGF0dXNSZXNwb25zZSIsImNvbmZpcm1hdGlvbnMiLCJjb25maXJtYXRpb25TdGF0dXMiLCJHZXRTaWduYXR1cmVTdGF0dXNlc1JwY1Jlc3VsdCIsIkdldE1pbmltdW1CYWxhbmNlRm9yUmVudEV4ZW1wdGlvblJwY1Jlc3VsdCIsIkFkZHJlc3NUYWJsZUxvb2t1cFN0cnVjdCIsIkNvbmZpcm1lZFRyYW5zYWN0aW9uUmVzdWx0IiwiQW5ub3RhdGVkQWNjb3VudEtleSIsInNvdXJjZSIsIkNvbmZpcm1lZFRyYW5zYWN0aW9uQWNjb3VudHNNb2RlUmVzdWx0IiwiUGFyc2VkSW5zdHJ1Y3Rpb25SZXN1bHQiLCJSYXdJbnN0cnVjdGlvblJlc3VsdCIsIkluc3RydWN0aW9uUmVzdWx0IiwiVW5rbm93bkluc3RydWN0aW9uUmVzdWx0IiwiUGFyc2VkT3JSYXdJbnN0cnVjdGlvbiIsIlBhcnNlZENvbmZpcm1lZFRyYW5zYWN0aW9uUmVzdWx0IiwiVG9rZW5CYWxhbmNlUmVzdWx0IiwiYWNjb3VudEluZGV4IiwibWludCIsInVpVG9rZW5BbW91bnQiLCJMb2FkZWRBZGRyZXNzZXNSZXN1bHQiLCJDb25maXJtZWRUcmFuc2FjdGlvbk1ldGFSZXN1bHQiLCJmZWUiLCJpbm5lckluc3RydWN0aW9ucyIsInByZUJhbGFuY2VzIiwicG9zdEJhbGFuY2VzIiwibG9nTWVzc2FnZXMiLCJwcmVUb2tlbkJhbGFuY2VzIiwicG9zdFRva2VuQmFsYW5jZXMiLCJsb2FkZWRBZGRyZXNzZXMiLCJjb21wdXRlVW5pdHNDb25zdW1lZCIsIlBhcnNlZENvbmZpcm1lZFRyYW5zYWN0aW9uTWV0YVJlc3VsdCIsIlRyYW5zYWN0aW9uVmVyc2lvblN0cnVjdCIsIlJld2FyZHNSZXN1bHQiLCJyZXdhcmRUeXBlIiwiR2V0QmxvY2tScGNSZXN1bHQiLCJwcmV2aW91c0Jsb2NraGFzaCIsInBhcmVudFNsb3QiLCJyZXdhcmRzIiwiR2V0Tm9uZU1vZGVCbG9ja1JwY1Jlc3VsdCIsIkdldEFjY291bnRzTW9kZUJsb2NrUnBjUmVzdWx0IiwiR2V0UGFyc2VkQmxvY2tScGNSZXN1bHQiLCJHZXRQYXJzZWRBY2NvdW50c01vZGVCbG9ja1JwY1Jlc3VsdCIsIkdldFBhcnNlZE5vbmVNb2RlQmxvY2tScGNSZXN1bHQiLCJHZXRDb25maXJtZWRCbG9ja1JwY1Jlc3VsdCIsIkdldEJsb2NrU2lnbmF0dXJlc1JwY1Jlc3VsdCIsIkdldFRyYW5zYWN0aW9uUnBjUmVzdWx0IiwiR2V0UGFyc2VkVHJhbnNhY3Rpb25ScGNSZXN1bHQiLCJHZXRSZWNlbnRCbG9ja2hhc2hBbmRDb250ZXh0UnBjUmVzdWx0IiwibGFtcG9ydHNQZXJTaWduYXR1cmUiLCJHZXRMYXRlc3RCbG9ja2hhc2hScGNSZXN1bHQiLCJJc0Jsb2NraGFzaFZhbGlkUnBjUmVzdWx0IiwiUGVyZlNhbXBsZVJlc3VsdCIsIm51bVRyYW5zYWN0aW9ucyIsIm51bVNsb3RzIiwic2FtcGxlUGVyaW9kU2VjcyIsIkdldFJlY2VudFBlcmZvcm1hbmNlU2FtcGxlc1JwY1Jlc3VsdCIsIkdldEZlZUNhbGN1bGF0b3JScGNSZXN1bHQiLCJSZXF1ZXN0QWlyZHJvcFJwY1Jlc3VsdCIsIlNlbmRUcmFuc2FjdGlvblJwY1Jlc3VsdCIsIkxvZ3NSZXN1bHQiLCJMb2dzTm90aWZpY2F0aW9uUmVzdWx0IiwiQ29ubmVjdGlvbiIsIl9jb21taXRtZW50T3JDb25maWciLCJfY29tbWl0bWVudCIsIl9jb25maXJtVHJhbnNhY3Rpb25Jbml0aWFsVGltZW91dCIsIl9ycGNXc0VuZHBvaW50IiwiX3JwY0NsaWVudCIsIl9ycGNSZXF1ZXN0IiwiX3JwY0JhdGNoUmVxdWVzdCIsIl9ycGNXZWJTb2NrZXQiLCJfcnBjV2ViU29ja2V0Q29ubmVjdGVkIiwiX3JwY1dlYlNvY2tldEhlYXJ0YmVhdCIsIl9ycGNXZWJTb2NrZXRJZGxlVGltZW91dCIsIl9ycGNXZWJTb2NrZXRHZW5lcmF0aW9uIiwiX2Rpc2FibGVCbG9ja2hhc2hDYWNoaW5nIiwiX3BvbGxpbmdCbG9ja2hhc2giLCJfYmxvY2toYXNoSW5mbyIsImxhdGVzdEJsb2NraGFzaCIsImxhc3RGZXRjaCIsInRyYW5zYWN0aW9uU2lnbmF0dXJlcyIsInNpbXVsYXRlZFNpZ25hdHVyZXMiLCJfbmV4dENsaWVudFN1YnNjcmlwdGlvbklkIiwiX3N1YnNjcmlwdGlvbkRpc3Bvc2VGdW5jdGlvbnNCeUNsaWVudFN1YnNjcmlwdGlvbklkIiwiX3N1YnNjcmlwdGlvbkhhc2hCeUNsaWVudFN1YnNjcmlwdGlvbklkIiwiX3N1YnNjcmlwdGlvblN0YXRlQ2hhbmdlQ2FsbGJhY2tzQnlIYXNoIiwiX3N1YnNjcmlwdGlvbkNhbGxiYWNrc0J5U2VydmVyU3Vic2NyaXB0aW9uSWQiLCJfc3Vic2NyaXB0aW9uc0J5SGFzaCIsIl9zdWJzY3JpcHRpb25zQXV0b0Rpc3Bvc2VkQnlScGMiLCJnZXRCbG9ja0hlaWdodCIsInJlcXVlc3RQcm9taXNlcyIsIl9idWlsZEFyZ3MiLCJyZXF1ZXN0SGFzaCIsInVuc2FmZVJlcyIsIndzRW5kcG9pbnQiLCJjb25maXJtVHJhbnNhY3Rpb25Jbml0aWFsVGltZW91dCIsIkluZmluaXR5IiwiX3dzT25PcGVuIiwiX3dzT25FcnJvciIsIl93c09uQ2xvc2UiLCJfd3NPbkFjY291bnROb3RpZmljYXRpb24iLCJfd3NPblByb2dyYW1BY2NvdW50Tm90aWZpY2F0aW9uIiwiX3dzT25TbG90Tm90aWZpY2F0aW9uIiwiX3dzT25TbG90VXBkYXRlc05vdGlmaWNhdGlvbiIsIl93c09uU2lnbmF0dXJlTm90aWZpY2F0aW9uIiwiX3dzT25Sb290Tm90aWZpY2F0aW9uIiwiX3dzT25Mb2dzTm90aWZpY2F0aW9uIiwicnBjRW5kcG9pbnQiLCJnZXRCYWxhbmNlQW5kQ29udGV4dCIsImdldEJhbGFuY2UiLCJ0aGVuIiwiY2F0Y2giLCJlIiwiZ2V0QmxvY2tUaW1lIiwiZ2V0TWluaW11bUxlZGdlclNsb3QiLCJnZXRGaXJzdEF2YWlsYWJsZUJsb2NrIiwiZ2V0U3VwcGx5IiwiY29uZmlnQXJnIiwiZ2V0VG9rZW5TdXBwbHkiLCJ0b2tlbk1pbnRBZGRyZXNzIiwiZ2V0VG9rZW5BY2NvdW50QmFsYW5jZSIsInRva2VuQWRkcmVzcyIsImdldFRva2VuQWNjb3VudHNCeU93bmVyIiwib3duZXJBZGRyZXNzIiwiX2FyZ3MiLCJnZXRQYXJzZWRUb2tlbkFjY291bnRzQnlPd25lciIsImdldExhcmdlc3RBY2NvdW50cyIsImFyZyIsImdldFRva2VuTGFyZ2VzdEFjY291bnRzIiwibWludEFkZHJlc3MiLCJnZXRBY2NvdW50SW5mb0FuZENvbnRleHQiLCJnZXRQYXJzZWRBY2NvdW50SW5mbyIsImdldE11bHRpcGxlUGFyc2VkQWNjb3VudHMiLCJwdWJsaWNLZXlzIiwicmF3Q29uZmlnIiwiZ2V0TXVsdGlwbGVBY2NvdW50c0luZm9BbmRDb250ZXh0IiwiZ2V0TXVsdGlwbGVBY2NvdW50c0luZm8iLCJnZXRTdGFrZUFjdGl2YXRpb24iLCJnZXRQcm9ncmFtQWNjb3VudHMiLCJjb25maWdPckNvbW1pdG1lbnQiLCJlbmNvZGluZyIsImNvbmZpZ1dpdGhvdXRFbmNvZGluZyIsImJhc2VTY2hlbWEiLCJ3aXRoQ29udGV4dCIsImdldFBhcnNlZFByb2dyYW1BY2NvdW50cyIsInN0cmF0ZWd5IiwicmF3U2lnbmF0dXJlIiwiYWJvcnRlZCIsInJlYXNvbiIsImRlY29kZWRTaWduYXR1cmUiLCJjb25maXJtVHJhbnNhY3Rpb25Vc2luZ0xlZ2FjeVRpbWVvdXRTdHJhdGVneSIsImNvbmZpcm1UcmFuc2FjdGlvblVzaW5nQmxvY2tIZWlnaHRFeGNlZWRhbmNlU3RyYXRlZ3kiLCJjb25maXJtVHJhbnNhY3Rpb25Vc2luZ0R1cmFibGVOb25jZVN0cmF0ZWd5IiwiZ2V0Q2FuY2VsbGF0aW9uUHJvbWlzZSIsInNpZ25hbCIsImFkZEV2ZW50TGlzdGVuZXIiLCJnZXRUcmFuc2FjdGlvbkNvbmZpcm1hdGlvblByb21pc2UiLCJzaWduYXR1cmVTdWJzY3JpcHRpb25JZCIsImRpc3Bvc2VTaWduYXR1cmVTdWJzY3JpcHRpb25TdGF0ZUNoYW5nZU9ic2VydmVyIiwiZG9uZSIsImNvbmZpcm1hdGlvblByb21pc2UiLCJvblNpZ25hdHVyZSIsIl9fdHlwZSIsIlBST0NFU1NFRCIsInN1YnNjcmlwdGlvblNldHVwUHJvbWlzZSIsInJlc29sdmVTdWJzY3JpcHRpb25TZXR1cCIsIl9vblN1YnNjcmlwdGlvblN0YXRlQ2hhbmdlIiwibmV4dFN0YXRlIiwiZ2V0U2lnbmF0dXJlU3RhdHVzIiwiYWJvcnRDb25maXJtYXRpb24iLCJyZW1vdmVTaWduYXR1cmVMaXN0ZW5lciIsImV4cGlyeVByb21pc2UiLCJjaGVja0Jsb2NrSGVpZ2h0IiwiX2UiLCJjdXJyZW50QmxvY2tIZWlnaHQiLCJCTE9DS0hFSUdIVF9FWENFRURFRCIsImNhbmNlbGxhdGlvblByb21pc2UiLCJvdXRjb21lIiwicmFjZSIsImN1cnJlbnROb25jZVZhbHVlIiwibGFzdENoZWNrZWRTbG90IiwiZ2V0Q3VycmVudE5vbmNlVmFsdWUiLCJnZXROb25jZUFuZENvbnRleHQiLCJOT05DRV9JTlZBTElEIiwic2xvdEluV2hpY2hOb25jZURpZEFkdmFuY2UiLCJzaWduYXR1cmVTdGF0dXMiLCJjb21taXRtZW50Rm9yU3RhdHVzIiwidGltZW91dElkIiwidGltZW91dE1zIiwiVElNRURfT1VUIiwiY2xlYXJUaW1lb3V0IiwiZ2V0Q2x1c3Rlck5vZGVzIiwiZ2V0Vm90ZUFjY291bnRzIiwiZ2V0U2xvdExlYWRlciIsImdldFNsb3RMZWFkZXJzIiwic3RhcnRTbG90IiwibGltaXQiLCJnZXRTaWduYXR1cmVTdGF0dXNlcyIsImdldFRyYW5zYWN0aW9uQ291bnQiLCJnZXRUb3RhbFN1cHBseSIsImV4Y2x1ZGVOb25DaXJjdWxhdGluZ0FjY291bnRzTGlzdCIsImdldEluZmxhdGlvbkdvdmVybm9yIiwiZ2V0SW5mbGF0aW9uUmV3YXJkIiwiZ2V0SW5mbGF0aW9uUmF0ZSIsImdldEVwb2NoSW5mbyIsImdldEVwb2NoU2NoZWR1bGUiLCJlcG9jaFNjaGVkdWxlIiwiZ2V0TGVhZGVyU2NoZWR1bGUiLCJnZXRSZWNlbnRCbG9ja2hhc2hBbmRDb250ZXh0IiwiZ2V0UmVjZW50UGVyZm9ybWFuY2VTYW1wbGVzIiwiZ2V0RmVlQ2FsY3VsYXRvckZvckJsb2NraGFzaCIsIndpcmVNZXNzYWdlIiwiZ2V0UmVjZW50UHJpb3JpdGl6YXRpb25GZWVzIiwibG9ja2VkV3JpdGFibGVBY2NvdW50cyIsImdldFJlY2VudEJsb2NraGFzaCIsImdldExhdGVzdEJsb2NraGFzaCIsImdldExhdGVzdEJsb2NraGFzaEFuZENvbnRleHQiLCJpc0Jsb2NraGFzaFZhbGlkIiwiZ2V0VmVyc2lvbiIsImdldEdlbmVzaXNIYXNoIiwiZ2V0QmxvY2siLCJfYnVpbGRBcmdzQXRMZWFzdENvbmZpcm1lZCIsInRyYW5zYWN0aW9uRGV0YWlscyIsImdldFBhcnNlZEJsb2NrIiwiZ2V0QmxvY2tQcm9kdWN0aW9uIiwiZXh0cmEiLCJjIiwiZ2V0VHJhbnNhY3Rpb24iLCJnZXRQYXJzZWRUcmFuc2FjdGlvbiIsImdldFBhcnNlZFRyYW5zYWN0aW9ucyIsImdldFRyYW5zYWN0aW9ucyIsImdldENvbmZpcm1lZEJsb2NrIiwiYmxvY2siLCJnZXRCbG9ja3MiLCJlbmRTbG90IiwiZ2V0QmxvY2tTaWduYXR1cmVzIiwiZ2V0Q29uZmlybWVkQmxvY2tTaWduYXR1cmVzIiwiZ2V0Q29uZmlybWVkVHJhbnNhY3Rpb24iLCJnZXRQYXJzZWRDb25maXJtZWRUcmFuc2FjdGlvbiIsImdldFBhcnNlZENvbmZpcm1lZFRyYW5zYWN0aW9ucyIsImdldENvbmZpcm1lZFNpZ25hdHVyZXNGb3JBZGRyZXNzIiwiZmlyc3RBdmFpbGFibGVCbG9jayIsInVudGlsIiwiaGlnaGVzdENvbmZpcm1lZFJvb3QiLCJiZWZvcmUiLCJjb25maXJtZWRTaWduYXR1cmVJbmZvIiwiZ2V0Q29uZmlybWVkU2lnbmF0dXJlc0ZvckFkZHJlc3MyIiwiZ2V0U2lnbmF0dXJlc0ZvckFkZHJlc3MiLCJnZXRBZGRyZXNzTG9va3VwVGFibGUiLCJhY2NvdW50SW5mbyIsImdldE5vbmNlIiwicmVxdWVzdEFpcmRyb3AiLCJ0byIsIl9ibG9ja2hhc2hXaXRoRXhwaXJ5QmxvY2tIZWlnaHQiLCJkaXNhYmxlQ2FjaGUiLCJ0aW1lU2luY2VGZXRjaCIsImV4cGlyZWQiLCJfcG9sbE5ld0Jsb2NraGFzaCIsInN0YXJ0VGltZSIsImNhY2hlZExhdGVzdEJsb2NraGFzaCIsImNhY2hlZEJsb2NraGFzaCIsImdldFN0YWtlTWluaW11bURlbGVnYXRpb24iLCJzaW11bGF0ZVRyYW5zYWN0aW9uIiwidHJhbnNhY3Rpb25Pck1lc3NhZ2UiLCJjb25maWdPclNpZ25lcnMiLCJpbmNsdWRlQWNjb3VudHMiLCJ2ZXJzaW9uZWRUeCIsImVuY29kZWRUcmFuc2FjdGlvbiIsIm9yaWdpbmFsVHgiLCJzaWdWZXJpZnkiLCJ0cmFjZUluZGVudCIsImxvZ1RyYWNlIiwic2lnbmVyc09yT3B0aW9ucyIsInNlbmRSYXdUcmFuc2FjdGlvbiIsInJhd1RyYW5zYWN0aW9uIiwic2VuZEVuY29kZWRUcmFuc2FjdGlvbiIsInNldEludGVydmFsIiwiX3VwZGF0ZVN1YnNjcmlwdGlvbnMiLCJjbGVhckludGVydmFsIiwiaGFzaCIsIl9zZXRTdWJzY3JpcHRpb24iLCJuZXh0U3Vic2NyaXB0aW9uIiwicHJldlN0YXRlIiwic3RhdGVDaGFuZ2VDYWxsYmFja3MiLCJjYiIsImNsaWVudFN1YnNjcmlwdGlvbklkIiwiY2xvc2UiLCJjb25uZWN0IiwiYWN0aXZlV2ViU29ja2V0R2VuZXJhdGlvbiIsImlzQ3VycmVudENvbm5lY3Rpb25TdGlsbEFjdGl2ZSIsImNhbGxiYWNrcyIsInNlcnZlclN1YnNjcmlwdGlvbklkIiwidW5zdWJzY3JpYmVNZXRob2QiLCJfaGFuZGxlU2VydmVyTm90aWZpY2F0aW9uIiwiY2FsbGJhY2tBcmdzIiwibm90aWZpY2F0aW9uIiwiX21ha2VTdWJzY3JpcHRpb24iLCJzdWJzY3JpcHRpb25Db25maWciLCJleGlzdGluZ1N1YnNjcmlwdGlvbiIsIm9uQWNjb3VudENoYW5nZSIsInJlbW92ZUFjY291bnRDaGFuZ2VMaXN0ZW5lciIsIl91bnN1YnNjcmliZUNsaWVudFN1YnNjcmlwdGlvbiIsImFjY291bnRJZCIsIm9uUHJvZ3JhbUFjY291bnRDaGFuZ2UiLCJmaWx0ZXJzIiwicmVtb3ZlUHJvZ3JhbUFjY291bnRDaGFuZ2VMaXN0ZW5lciIsIm9uTG9ncyIsIm1lbnRpb25zIiwicmVtb3ZlT25Mb2dzTGlzdGVuZXIiLCJvblNsb3RDaGFuZ2UiLCJyZW1vdmVTbG90Q2hhbmdlTGlzdGVuZXIiLCJvblNsb3RVcGRhdGUiLCJyZW1vdmVTbG90VXBkYXRlTGlzdGVuZXIiLCJzdWJzY3JpcHRpb25OYW1lIiwiZGlzcG9zZSIsIm92ZXJyaWRlIiwiX2VyciIsIm9uU2lnbmF0dXJlV2l0aE9wdGlvbnMiLCJvblJvb3RDaGFuZ2UiLCJyZW1vdmVSb290Q2hhbmdlTGlzdGVuZXIiLCJLZXlwYWlyIiwia2V5cGFpciIsIl9rZXlwYWlyIiwiZ2VuZXJhdGUiLCJmcm9tU2VjcmV0S2V5Iiwic2tpcFZhbGlkYXRpb24iLCJjb21wdXRlZFB1YmxpY0tleSIsImlpIiwiZnJvbVNlZWQiLCJMT09LVVBfVEFCTEVfSU5TVFJVQ1RJT05fTEFZT1VUUyIsIkNyZWF0ZUxvb2t1cFRhYmxlIiwiRnJlZXplTG9va3VwVGFibGUiLCJFeHRlbmRMb29rdXBUYWJsZSIsIkRlYWN0aXZhdGVMb29rdXBUYWJsZSIsIkNsb3NlTG9va3VwVGFibGUiLCJBZGRyZXNzTG9va3VwVGFibGVJbnN0cnVjdGlvbiIsImxheW91dFR5cGUiLCJkZWNvZGVDcmVhdGVMb29rdXBUYWJsZSIsImNoZWNrS2V5c0xlbmd0aCIsInJlY2VudFNsb3QiLCJkZWNvZGVFeHRlbmRMb29rdXBUYWJsZSIsImRlY29kZUNsb3NlTG9va3VwVGFibGUiLCJyZWNpcGllbnQiLCJkZWNvZGVGcmVlemVMb29rdXBUYWJsZSIsImRlY29kZURlYWN0aXZhdGVMb29rdXBUYWJsZSIsIkFkZHJlc3NMb29rdXBUYWJsZVByb2dyYW0iLCJjcmVhdGVMb29rdXBUYWJsZSIsImxvb2t1cFRhYmxlQWRkcmVzcyIsImJ1bXBTZWVkIiwiZnJlZXplTG9va3VwVGFibGUiLCJleHRlbmRMb29rdXBUYWJsZSIsImFkZHIiLCJkZWFjdGl2YXRlTG9va3VwVGFibGUiLCJjbG9zZUxvb2t1cFRhYmxlIiwiQ29tcHV0ZUJ1ZGdldEluc3RydWN0aW9uIiwiQ09NUFVURV9CVURHRVRfSU5TVFJVQ1RJT05fTEFZT1VUUyIsImRlY29kZVJlcXVlc3RVbml0cyIsInVuaXRzIiwiYWRkaXRpb25hbEZlZSIsIlJlcXVlc3RVbml0cyIsImRlY29kZVJlcXVlc3RIZWFwRnJhbWUiLCJSZXF1ZXN0SGVhcEZyYW1lIiwiZGVjb2RlU2V0Q29tcHV0ZVVuaXRMaW1pdCIsIlNldENvbXB1dGVVbml0TGltaXQiLCJkZWNvZGVTZXRDb21wdXRlVW5pdFByaWNlIiwibWljcm9MYW1wb3J0cyIsIlNldENvbXB1dGVVbml0UHJpY2UiLCJDb21wdXRlQnVkZ2V0UHJvZ3JhbSIsInJlcXVlc3RVbml0cyIsInJlcXVlc3RIZWFwRnJhbWUiLCJzZXRDb21wdXRlVW5pdExpbWl0Iiwic2V0Q29tcHV0ZVVuaXRQcmljZSIsIlBSSVZBVEVfS0VZX0JZVEVTJDEiLCJQVUJMSUNfS0VZX0JZVEVTJDEiLCJTSUdOQVRVUkVfQllURVMiLCJFRDI1NTE5X0lOU1RSVUNUSU9OX0xBWU9VVCIsInUxNiIsIkVkMjU1MTlQcm9ncmFtIiwiY3JlYXRlSW5zdHJ1Y3Rpb25XaXRoUHVibGljS2V5IiwiaW5zdHJ1Y3Rpb25JbmRleCIsInB1YmxpY0tleU9mZnNldCIsInNpZ25hdHVyZU9mZnNldCIsIm1lc3NhZ2VEYXRhT2Zmc2V0IiwibnVtU2lnbmF0dXJlcyIsInBhZGRpbmciLCJzaWduYXR1cmVJbnN0cnVjdGlvbkluZGV4IiwicHVibGljS2V5SW5zdHJ1Y3Rpb25JbmRleCIsIm1lc3NhZ2VEYXRhU2l6ZSIsIm1lc3NhZ2VJbnN0cnVjdGlvbkluZGV4IiwiY3JlYXRlSW5zdHJ1Y3Rpb25XaXRoUHJpdmF0ZUtleSIsInByaXZhdGVLZXkiLCJlY2RzYVNpZ24iLCJtc2dIYXNoIiwicHJpdktleSIsInRvQ29tcGFjdFJhd0J5dGVzIiwicmVjb3ZlcnkiLCJpc1ZhbGlkUHJpdmF0ZUtleSIsInB1YmxpY0tleUNyZWF0ZSIsIlBSSVZBVEVfS0VZX0JZVEVTIiwiRVRIRVJFVU1fQUREUkVTU19CWVRFUyIsIlBVQkxJQ19LRVlfQllURVMiLCJTSUdOQVRVUkVfT0ZGU0VUU19TRVJJQUxJWkVEX1NJWkUiLCJTRUNQMjU2SzFfSU5TVFJVQ1RJT05fTEFZT1VUIiwiU2VjcDI1NmsxUHJvZ3JhbSIsInB1YmxpY0tleVRvRXRoQWRkcmVzcyIsInJlY292ZXJ5SWQiLCJjcmVhdGVJbnN0cnVjdGlvbldpdGhFdGhBZGRyZXNzIiwiZXRoQWRkcmVzcyIsInJhd0FkZHJlc3MiLCJzdWJzdHIiLCJkYXRhU3RhcnQiLCJldGhBZGRyZXNzT2Zmc2V0IiwiZXRoQWRkcmVzc0luc3RydWN0aW9uSW5kZXgiLCJwa2V5IiwibWVzc2FnZUhhc2giLCJfTG9ja3VwIiwiU1RBS0VfQ09ORklHX0lEIiwiQXV0aG9yaXplZCIsInN0YWtlciIsIndpdGhkcmF3ZXIiLCJMb2NrdXAiLCJ1bml4VGltZXN0YW1wIiwiY3VzdG9kaWFuIiwiU3Rha2VJbnN0cnVjdGlvbiIsIlNUQUtFX0lOU1RSVUNUSU9OX0xBWU9VVFMiLCJkZWNvZGVJbml0aWFsaXplIiwiSW5pdGlhbGl6ZSIsInN0YWtlUHVia2V5IiwiZGVjb2RlRGVsZWdhdGUiLCJEZWxlZ2F0ZSIsImRlY29kZUF1dGhvcml6ZSIsIm5ld0F1dGhvcml6ZWQiLCJzdGFrZUF1dGhvcml6YXRpb25UeXBlIiwiQXV0aG9yaXplIiwibyIsImN1c3RvZGlhblB1YmtleSIsImRlY29kZUF1dGhvcml6ZVdpdGhTZWVkIiwiYXV0aG9yaXR5U2VlZCIsImF1dGhvcml0eU93bmVyIiwiQXV0aG9yaXplV2l0aFNlZWQiLCJhdXRob3JpdHlCYXNlIiwiZGVjb2RlU3BsaXQiLCJTcGxpdCIsInNwbGl0U3Rha2VQdWJrZXkiLCJkZWNvZGVNZXJnZSIsIk1lcmdlIiwic291cmNlU3Rha2VQdWJLZXkiLCJkZWNvZGVXaXRoZHJhdyIsIldpdGhkcmF3IiwiZGVjb2RlRGVhY3RpdmF0ZSIsIkRlYWN0aXZhdGUiLCJTdGFrZVByb2dyYW0iLCJTdGFrZUF1dGhvcml6YXRpb25MYXlvdXQiLCJTdGFrZXIiLCJXaXRoZHJhd2VyIiwiaW5pdGlhbGl6ZSIsIm1heWJlTG9ja3VwIiwiZGVsZWdhdGUiLCJhdXRob3JpemUiLCJhdXRob3JpemVXaXRoU2VlZCIsInNwbGl0SW5zdHJ1Y3Rpb24iLCJyZW50RXhlbXB0UmVzZXJ2ZSIsInNwbGl0V2l0aFNlZWQiLCJtZXJnZSIsIndpdGhkcmF3IiwiZGVhY3RpdmF0ZSIsIlZvdGVJbml0IiwiYXV0aG9yaXplZFZvdGVyIiwiYXV0aG9yaXplZFdpdGhkcmF3ZXIiLCJWb3RlSW5zdHJ1Y3Rpb24iLCJWT1RFX0lOU1RSVUNUSU9OX0xBWU9VVFMiLCJkZWNvZGVJbml0aWFsaXplQWNjb3VudCIsIkluaXRpYWxpemVBY2NvdW50Iiwidm90ZUF1dGhvcml6YXRpb25UeXBlIiwiY3VycmVudEF1dGhvcml0eURlcml2ZWRLZXlPd25lclB1YmtleSIsImN1cnJlbnRBdXRob3JpdHlEZXJpdmVkS2V5U2VlZCIsImN1cnJlbnRBdXRob3JpdHlEZXJpdmVkS2V5QmFzZVB1YmtleSIsImF1dGhvcml6ZWRXaXRoZHJhd2VyUHVia2V5IiwiVm90ZVByb2dyYW0iLCJVcGRhdGVWYWxpZGF0b3JJZGVudGl0eSIsIlZvdGVBdXRob3JpemF0aW9uTGF5b3V0IiwiVm90ZXIiLCJpbml0aWFsaXplQWNjb3VudCIsInNhZmVXaXRoZHJhdyIsImN1cnJlbnRWb3RlQWNjb3VudEJhbGFuY2UiLCJyZW50RXhlbXB0TWluaW11bSIsInVwZGF0ZVZhbGlkYXRvcklkZW50aXR5IiwiVkFMSURBVE9SX0lORk9fS0VZIiwiSW5mb1N0cmluZyIsIndlYnNpdGUiLCJkZXRhaWxzIiwia2V5YmFzZVVzZXJuYW1lIiwiVmFsaWRhdG9ySW5mbyIsImZyb21Db25maWdEYXRhIiwiY29uZmlnS2V5Q291bnQiLCJjb25maWdLZXlzIiwicmF3SW5mbyIsIlZPVEVfUFJPR1JBTV9JRCIsIlZvdGVBY2NvdW50TGF5b3V0IiwiVm90ZUFjY291bnQiLCJ2b3RlcyIsImF1dGhvcml6ZWRWb3RlcnMiLCJwcmlvclZvdGVycyIsImxhc3RUaW1lc3RhbXAiLCJ2ZXJzaW9uT2Zmc2V0IiwidmEiLCJyb290U2xvdFZhbGlkIiwicGFyc2VBdXRob3JpemVkVm90ZXIiLCJnZXRQcmlvclZvdGVycyIsInBhcnNlUHJpb3JWb3RlcnMiLCJlcG9jaE9mTGFzdEF1dGhvcml6ZWRTd2l0Y2giLCJ0YXJnZXRFcG9jaCIsImlkeCIsImlzRW1wdHkiLCJodHRwIiwiZGV2bmV0IiwidGVzdG5ldCIsImh0dHBzIiwiY2x1c3RlckFwaVVybCIsImNsdXN0ZXIiLCJ0bHMiLCJzZW5kQW5kQ29uZmlybVJhd1RyYW5zYWN0aW9uIiwiY29uZmlybWF0aW9uU3RyYXRlZ3lPckNvbmZpcm1PcHRpb25zIiwibWF5YmVDb25maXJtT3B0aW9ucyIsImNvbmZpcm1hdGlvblN0cmF0ZWd5IiwiTEFNUE9SVFNfUEVSX1NPTCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/@solana/web3.js/lib/index.esm.js\n");

/***/ }),

/***/ "(ssr)/../node_modules/@solana/web3.js/node_modules/base-x/src/index.js":
/*!************************************************************************!*\
  !*** ../node_modules/@solana/web3.js/node_modules/base-x/src/index.js ***!
  \************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n// base-x encoding / decoding\n// Copyright (c) 2018 base-x contributors\n// Copyright (c) 2014-2018 The Bitcoin Core developers (base58.cpp)\n// Distributed under the MIT software license, see the accompanying\n// file LICENSE or http://www.opensource.org/licenses/mit-license.php.\n// @ts-ignore\nvar _Buffer = (__webpack_require__(/*! safe-buffer */ \"(ssr)/../node_modules/safe-buffer/index.js\").Buffer);\nfunction base(ALPHABET) {\n    if (ALPHABET.length >= 255) {\n        throw new TypeError(\"Alphabet too long\");\n    }\n    var BASE_MAP = new Uint8Array(256);\n    for(var j = 0; j < BASE_MAP.length; j++){\n        BASE_MAP[j] = 255;\n    }\n    for(var i = 0; i < ALPHABET.length; i++){\n        var x = ALPHABET.charAt(i);\n        var xc = x.charCodeAt(0);\n        if (BASE_MAP[xc] !== 255) {\n            throw new TypeError(x + \" is ambiguous\");\n        }\n        BASE_MAP[xc] = i;\n    }\n    var BASE = ALPHABET.length;\n    var LEADER = ALPHABET.charAt(0);\n    var FACTOR = Math.log(BASE) / Math.log(256) // log(BASE) / log(256), rounded up\n    ;\n    var iFACTOR = Math.log(256) / Math.log(BASE) // log(256) / log(BASE), rounded up\n    ;\n    function encode(source) {\n        if (Array.isArray(source) || source instanceof Uint8Array) {\n            source = _Buffer.from(source);\n        }\n        if (!_Buffer.isBuffer(source)) {\n            throw new TypeError(\"Expected Buffer\");\n        }\n        if (source.length === 0) {\n            return \"\";\n        }\n        // Skip & count leading zeroes.\n        var zeroes = 0;\n        var length = 0;\n        var pbegin = 0;\n        var pend = source.length;\n        while(pbegin !== pend && source[pbegin] === 0){\n            pbegin++;\n            zeroes++;\n        }\n        // Allocate enough space in big-endian base58 representation.\n        var size = (pend - pbegin) * iFACTOR + 1 >>> 0;\n        var b58 = new Uint8Array(size);\n        // Process the bytes.\n        while(pbegin !== pend){\n            var carry = source[pbegin];\n            // Apply \"b58 = b58 * 256 + ch\".\n            var i = 0;\n            for(var it1 = size - 1; (carry !== 0 || i < length) && it1 !== -1; it1--, i++){\n                carry += 256 * b58[it1] >>> 0;\n                b58[it1] = carry % BASE >>> 0;\n                carry = carry / BASE >>> 0;\n            }\n            if (carry !== 0) {\n                throw new Error(\"Non-zero carry\");\n            }\n            length = i;\n            pbegin++;\n        }\n        // Skip leading zeroes in base58 result.\n        var it2 = size - length;\n        while(it2 !== size && b58[it2] === 0){\n            it2++;\n        }\n        // Translate the result into a string.\n        var str = LEADER.repeat(zeroes);\n        for(; it2 < size; ++it2){\n            str += ALPHABET.charAt(b58[it2]);\n        }\n        return str;\n    }\n    function decodeUnsafe(source) {\n        if (typeof source !== \"string\") {\n            throw new TypeError(\"Expected String\");\n        }\n        if (source.length === 0) {\n            return _Buffer.alloc(0);\n        }\n        var psz = 0;\n        // Skip and count leading '1's.\n        var zeroes = 0;\n        var length = 0;\n        while(source[psz] === LEADER){\n            zeroes++;\n            psz++;\n        }\n        // Allocate enough space in big-endian base256 representation.\n        var size = (source.length - psz) * FACTOR + 1 >>> 0 // log(58) / log(256), rounded up.\n        ;\n        var b256 = new Uint8Array(size);\n        // Process the characters.\n        while(psz < source.length){\n            // Decode character\n            var carry = BASE_MAP[source.charCodeAt(psz)];\n            // Invalid character\n            if (carry === 255) {\n                return;\n            }\n            var i = 0;\n            for(var it3 = size - 1; (carry !== 0 || i < length) && it3 !== -1; it3--, i++){\n                carry += BASE * b256[it3] >>> 0;\n                b256[it3] = carry % 256 >>> 0;\n                carry = carry / 256 >>> 0;\n            }\n            if (carry !== 0) {\n                throw new Error(\"Non-zero carry\");\n            }\n            length = i;\n            psz++;\n        }\n        // Skip leading zeroes in b256.\n        var it4 = size - length;\n        while(it4 !== size && b256[it4] === 0){\n            it4++;\n        }\n        var vch = _Buffer.allocUnsafe(zeroes + (size - it4));\n        vch.fill(0x00, 0, zeroes);\n        var j = zeroes;\n        while(it4 !== size){\n            vch[j++] = b256[it4++];\n        }\n        return vch;\n    }\n    function decode(string) {\n        var buffer = decodeUnsafe(string);\n        if (buffer) {\n            return buffer;\n        }\n        throw new Error(\"Non-base\" + BASE + \" character\");\n    }\n    return {\n        encode: encode,\n        decodeUnsafe: decodeUnsafe,\n        decode: decode\n    };\n}\nmodule.exports = base;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL0Bzb2xhbmEvd2ViMy5qcy9ub2RlX21vZHVsZXMvYmFzZS14L3NyYy9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBLDZCQUE2QjtBQUM3Qix5Q0FBeUM7QUFDekMsbUVBQW1FO0FBQ25FLG1FQUFtRTtBQUNuRSxzRUFBc0U7QUFDdEUsYUFBYTtBQUNiLElBQUlBLFVBQVVDLDZGQUE2QjtBQUMzQyxTQUFTRSxLQUFNQyxRQUFRO0lBQ3JCLElBQUlBLFNBQVNDLE1BQU0sSUFBSSxLQUFLO1FBQUUsTUFBTSxJQUFJQyxVQUFVO0lBQXFCO0lBQ3ZFLElBQUlDLFdBQVcsSUFBSUMsV0FBVztJQUM5QixJQUFLLElBQUlDLElBQUksR0FBR0EsSUFBSUYsU0FBU0YsTUFBTSxFQUFFSSxJQUFLO1FBQ3hDRixRQUFRLENBQUNFLEVBQUUsR0FBRztJQUNoQjtJQUNBLElBQUssSUFBSUMsSUFBSSxHQUFHQSxJQUFJTixTQUFTQyxNQUFNLEVBQUVLLElBQUs7UUFDeEMsSUFBSUMsSUFBSVAsU0FBU1EsTUFBTSxDQUFDRjtRQUN4QixJQUFJRyxLQUFLRixFQUFFRyxVQUFVLENBQUM7UUFDdEIsSUFBSVAsUUFBUSxDQUFDTSxHQUFHLEtBQUssS0FBSztZQUFFLE1BQU0sSUFBSVAsVUFBVUssSUFBSTtRQUFpQjtRQUNyRUosUUFBUSxDQUFDTSxHQUFHLEdBQUdIO0lBQ2pCO0lBQ0EsSUFBSUssT0FBT1gsU0FBU0MsTUFBTTtJQUMxQixJQUFJVyxTQUFTWixTQUFTUSxNQUFNLENBQUM7SUFDN0IsSUFBSUssU0FBU0MsS0FBS0MsR0FBRyxDQUFDSixRQUFRRyxLQUFLQyxHQUFHLENBQUMsS0FBSyxtQ0FBbUM7O0lBQy9FLElBQUlDLFVBQVVGLEtBQUtDLEdBQUcsQ0FBQyxPQUFPRCxLQUFLQyxHQUFHLENBQUNKLE1BQU0sbUNBQW1DOztJQUNoRixTQUFTTSxPQUFRQyxNQUFNO1FBQ3JCLElBQUlDLE1BQU1DLE9BQU8sQ0FBQ0YsV0FBV0Es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UUFBUyxRQUFTO2dCQUM5QlYsUUFBUSxRQUFTLFFBQVM7WUFDNUI7WUFDQSxJQUFJQSxVQUFVLEdBQUc7Z0JBQUUsTUFBTSxJQUFJRSxNQUFNO1lBQWtCO1lBQ3JEN0IsU0FBU0s7WUFDVDhCO1FBQ0Y7UUFDSSwrQkFBK0I7UUFDbkMsSUFBSUcsTUFBTWIsT0FBT3pCO1FBQ2pCLE1BQU9zQyxRQUFRYixRQUFRVyxJQUFJLENBQUNFLElBQUksS0FBSyxFQUFHO1lBQ3RDQTtRQUNGO1FBQ0EsSUFBSUMsTUFBTTVDLFFBQVE2QyxXQUFXLENBQUNsQixTQUFVRyxDQUFBQSxPQUFPYSxHQUFFO1FBQ2pEQyxJQUFJRSxJQUFJLENBQUMsTUFBTSxHQUFHbkI7UUFDbEIsSUFBSWxCLElBQUlrQjtRQUNSLE1BQU9nQixRQUFRYixLQUFNO1lBQ25CYyxHQUFHLENBQUNuQyxJQUFJLEdBQUdnQyxJQUFJLENBQUNFLE1BQU07UUFDeEI7UUFDQSxPQUFPQztJQUNUO0lBQ0EsU0FBU0csT0FBUUMsTUFBTTtRQUNyQixJQUFJQyxTQUFTWCxhQUFhVTtRQUMxQixJQUFJQyxRQUFRO1lBQUUsT0FBT0E7UUFBTztRQUM1QixNQUFNLElBQUlmLE1BQU0sYUFBYW5CLE9BQU87SUFDdEM7SUFDQSxPQUFPO1FBQ0xNLFFBQVFBO1FBQ1JpQixjQUFjQTtRQUNkUyxRQUFRQTtJQUNWO0FBQ0Y7QUFDQUcsT0FBT0MsT0FBTyxHQUFHaEQiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL0Bzb2xhbmEvd2ViMy5qcy9ub2RlX21vZHVsZXMvYmFzZS14L3NyYy9pbmRleC5qcz80NmQ5Il0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0J1xuLy8gYmFzZS14IGVuY29kaW5nIC8gZGVjb2Rpbmdcbi8vIENvcHlyaWdodCAoYykgMjAxOCBiYXNlLXggY29udHJpYnV0b3JzXG4vLyBDb3B5cmlnaHQgKGMpIDIwMTQtMjAxOCBUaGUgQml0Y29pbiBDb3JlIGRldmVsb3BlcnMgKGJhc2U1OC5jcHApXG4vLyBEaXN0cmlidXRlZCB1bmRlciB0aGUgTUlUIHNvZnR3YXJlIGxpY2Vuc2UsIHNlZSB0aGUgYWNjb21wYW55aW5nXG4vLyBmaWxlIExJQ0VOU0Ugb3IgaHR0cDovL3d3dy5vcGVuc291cmNlLm9yZy9saWNlbnNlcy9taXQtbGljZW5zZS5waHAuXG4vLyBAdHMtaWdub3JlXG52YXIgX0J1ZmZlciA9IHJlcXVpcmUoJ3NhZmUtYnVmZmVyJykuQnVmZmVyXG5mdW5jdGlvbiBiYXNlIChBTFBIQUJFVCkge1xuICBpZiAoQUxQSEFCRVQubGVuZ3RoID49IDI1NSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKCdBbHBoYWJldCB0b28gbG9uZycpIH1cbiAgdmFyIEJBU0VfTUFQID0gbmV3IFVpbnQ4QXJyYXkoMjU2KVxuICBmb3IgKHZhciBqID0gMDsgaiA8IEJBU0VfTUFQLmxlbmd0aDsgaisrKSB7XG4gICAgQkFTRV9NQVBbal0gPSAyNTVcbiAgfVxuICBmb3IgKHZhciBpID0gMDsgaSA8IEFMUEhBQkVULmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHggPSBBTFBIQUJFVC5jaGFyQXQoaSlcbiAgICB2YXIgeGMgPSB4LmNoYXJDb2RlQXQoMClcbiAgICBpZiAoQkFTRV9NQVBbeGNdICE9PSAyNTUpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcih4ICsgJyBpcyBhbWJpZ3VvdXMnKSB9XG4gICAgQkFTRV9NQVBbeGNdID0gaVxuICB9XG4gIHZhciBCQVNFID0gQUxQSEFCRVQubGVuZ3RoXG4gIHZhciBMRUFERVIgPSBBTFBIQUJFVC5jaGFyQXQoMClcbiAgdmFyIEZBQ1RPUiA9IE1hdGgubG9nKEJBU0UpIC8gTWF0aC5sb2coMjU2KSAvLyBsb2coQkFTRSkgLyBsb2coMjU2KSwgcm91bmRlZCB1cFxuICB2YXIgaUZBQ1RPUiA9IE1hdGgubG9nKDI1NikgLyBNYXRoLmxvZyhCQVNFKSAvLyBsb2coMjU2KSAvIGxvZyhCQVNFKSwgcm91bmRlZCB1cFxuICBmdW5jdGlvbiBlbmNvZGUgKHNvdXJjZSkge1xuICAgIGlmIChBcnJheS5pc0FycmF5KHNvdXJjZSkgfHwgc291cmNlIGluc3RhbmNlb2YgVWludDhBcnJheSkgeyBzb3VyY2UgPSBfQnVmZmVyLmZyb20oc291cmNlKSB9XG4gICAgaWYgKCFfQnVmZmVyLmlzQnVmZmVyKHNvdXJjZSkpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcignRXhwZWN0ZWQgQnVmZmVyJykgfVxuICAgIGlmIChzb3VyY2UubGVuZ3RoID09PSAwKSB7IHJldHVybiAnJyB9XG4gICAgICAgIC8vIFNraXAgJiBjb3VudCBsZWFkaW5nIHplcm9lcy5cbiAgICB2YXIgemVyb2VzID0gMFxuICAgIHZhciBsZW5ndGggPSAwXG4gICAgdmFyIHBiZWdpbiA9IDBcbiAgICB2YXIgcGVuZCA9IHNvdXJjZS5sZW5ndGhcbiAgICB3aGlsZSAocGJlZ2luICE9PSBwZW5kICYmIHNvdXJjZVtwYmVnaW5dID09PSAwKSB7XG4gICAgICBwYmVnaW4rK1xuICAgICAgemVyb2VzKytcbiAgICB9XG4gICAgICAgIC8vIEFsbG9jYXRlIGVub3VnaCBzcGFjZSBpbiBiaWctZW5kaWFuIGJhc2U1OCByZXByZXNlbnRhdGlvbi5cbiAgICB2YXIgc2l6ZSA9ICgocGVuZCAtIHBiZWdpbikgKiBpRkFDVE9SICsgMSkgPj4+IDBcbiAgICB2YXIgYjU4ID0gbmV3IFVpbnQ4QXJyYXkoc2l6ZSlcbiAgICAgICAgLy8gUHJvY2VzcyB0aGUgYnl0ZXMuXG4gICAgd2hpbGUgKHBiZWdpbiAhPT0gcGVuZCkge1xuICAgICAgdmFyIGNhcnJ5ID0gc291cmNlW3BiZWdpbl1cbiAgICAgICAgICAgIC8vIEFwcGx5IFwiYjU4ID0gYjU4ICogMjU2ICsgY2hcIi5cbiAgICAgIHZhciBpID0gMFxuICAgICAgZm9yICh2YXIgaXQxID0gc2l6ZSAtIDE7IChjYXJyeSAhPT0gMCB8fCBpIDwgbGVuZ3RoKSAmJiAoaXQxICE9PSAtMSk7IGl0MS0tLCBpKyspIHtcbiAgICAgICAgY2FycnkgKz0gKDI1NiAqIGI1OFtpdDFdKSA+Pj4gMFxuICAgICAgICBiNThbaXQxXSA9IChjYXJyeSAlIEJBU0UpID4+PiAwXG4gICAgICAgIGNhcnJ5ID0gKGNhcnJ5IC8gQkFTRSkgPj4+IDBcbiAgICAgIH1cbiAgICAgIGlmIChjYXJyeSAhPT0gMCkgeyB0aHJvdyBuZXcgRXJyb3IoJ05vbi16ZXJvIGNhcnJ5JykgfVxuICAgICAgbGVuZ3RoID0gaVxuICAgICAgcGJlZ2luKytcbiAgICB9XG4gICAgICAgIC8vIFNraXAgbGVhZGluZyB6ZXJvZXMgaW4gYmFzZTU4IHJlc3VsdC5cbiAgICB2YXIgaXQyID0gc2l6ZSAtIGxlbmd0aFxuICAgIHdoaWxlIChpdDIgIT09IHNpemUgJiYgYjU4W2l0Ml0gPT09IDApIHtcbiAgICAgIGl0MisrXG4gICAgfVxuICAgICAgICAvLyBUcmFuc2xhdGUgdGhlIHJlc3VsdCBpbnRvIGEgc3RyaW5nLlxuICAgIHZhciBzdHIgPSBMRUFERVIucmVwZWF0KHplcm9lcylcbiAgICBmb3IgKDsgaXQyIDwgc2l6ZTsgKytpdDIpIHsgc3RyICs9IEFMUEhBQkVULmNoYXJBdChiNThbaXQyXSkgfVxuICAgIHJldHVybiBzdHJcbiAgfVxuICBmdW5jdGlvbiBkZWNvZGVVbnNhZmUgKHNvdXJjZSkge1xuICAgIGlmICh0eXBlb2Ygc291cmNlICE9PSAnc3RyaW5nJykgeyB0aHJvdyBuZXcgVHlwZUVycm9yKCdFeHBlY3RlZCBTdHJpbmcnKSB9XG4gICAgaWYgKHNvdXJjZS5sZW5ndGggPT09IDApIHsgcmV0dXJuIF9CdWZmZXIuYWxsb2MoMCkgfVxuICAgIHZhciBwc3ogPSAwXG4gICAgICAgIC8vIFNraXAgYW5kIGNvdW50IGxlYWRpbmcgJzEncy5cbiAgICB2YXIgemVyb2VzID0gMFxuICAgIHZhciBsZW5ndGggPSAwXG4gICAgd2hpbGUgKHNvdXJjZVtwc3pdID09PSBMRUFERVIpIHtcbiAgICAgIHplcm9lcysrXG4gICAgICBwc3orK1xuICAgIH1cbiAgICAgICAgLy8gQWxsb2NhdGUgZW5vdWdoIHNwYWNlIGluIGJpZy1lbmRpYW4gYmFzZTI1NiByZXByZXNlbnRhdGlvbi5cbiAgICB2YXIgc2l6ZSA9ICgoKHNvdXJjZS5sZW5ndGggLSBwc3opICogRkFDVE9SKSArIDEpID4+PiAwIC8vIGxvZyg1OCkgLyBsb2coMjU2KSwgcm91bmRlZCB1cC5cbiAgICB2YXIgYjI1NiA9IG5ldyBVaW50OEFycmF5KHNpemUpXG4gICAgICAgIC8vIFByb2Nlc3MgdGhlIGNoYXJhY3RlcnMuXG4gICAgd2hpbGUgKHBzeiA8IHNvdXJjZS5sZW5ndGgpIHtcbiAgICAgICAgICAgIC8vIERlY29kZSBjaGFyYWN0ZXJcbiAgICAgIHZhciBjYXJyeSA9IEJBU0VfTUFQW3NvdXJjZS5jaGFyQ29kZUF0KHBzeildXG4gICAgICAgICAgICAvLyBJbnZhbGlkIGNoYXJhY3RlclxuICAgICAgaWYgKGNhcnJ5ID09PSAyNTUpIHsgcmV0dXJuIH1cbiAgICAgIHZhciBpID0gMFxuICAgICAgZm9yICh2YXIgaXQzID0gc2l6ZSAtIDE7IChjYXJyeSAhPT0gMCB8fCBpIDwgbGVuZ3RoKSAmJiAoaXQzICE9PSAtMSk7IGl0My0tLCBpKyspIHtcbiAgICAgICAgY2FycnkgKz0gKEJBU0UgKiBiMjU2W2l0M10pID4+PiAwXG4gICAgICAgIGIyNTZbaXQzXSA9IChjYXJyeSAlIDI1NikgPj4+IDBcbiAgICAgICAgY2FycnkgPSAoY2FycnkgLyAyNTYpID4+PiAwXG4gICAgICB9XG4gICAgICBpZiAoY2FycnkgIT09IDApIHsgdGhyb3cgbmV3IEVycm9yKCdOb24temVybyBjYXJyeScpIH1cbiAgICAgIGxlbmd0aCA9IGlcbiAgICAgIHBzeisrXG4gICAgfVxuICAgICAgICAvLyBTa2lwIGxlYWRpbmcgemVyb2VzIGluIGIyNTYuXG4gICAgdmFyIGl0NCA9IHNpemUgLSBsZW5ndGhcbiAgICB3aGlsZSAoaXQ0ICE9PSBzaXplICYmIGIyNTZbaXQ0XSA9PT0gMCkge1xuICAgICAgaXQ0KytcbiAgICB9XG4gICAgdmFyIHZjaCA9IF9CdWZmZXIuYWxsb2NVbnNhZmUoemVyb2VzICsgKHNpemUgLSBpdDQpKVxuICAgIHZjaC5maWxsKDB4MDAsIDAsIHplcm9lcylcbiAgICB2YXIgaiA9IHplcm9lc1xuICAgIHdoaWxlIChpdDQgIT09IHNpemUpIHtcbiAgICAgIHZjaFtqKytdID0gYjI1NltpdDQrK11cbiAgICB9XG4gICAgcmV0dXJuIHZjaFxuICB9XG4gIGZ1bmN0aW9uIGRlY29kZSAoc3RyaW5nKSB7XG4gICAgdmFyIGJ1ZmZlciA9IGRlY29kZVVuc2FmZShzdHJpbmcpXG4gICAgaWYgKGJ1ZmZlcikgeyByZXR1cm4gYnVmZmVyIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoJ05vbi1iYXNlJyArIEJBU0UgKyAnIGNoYXJhY3RlcicpXG4gIH1cbiAgcmV0dXJuIHtcbiAgICBlbmNvZGU6IGVuY29kZSxcbiAgICBkZWNvZGVVbnNhZmU6IGRlY29kZVVuc2FmZSxcbiAgICBkZWNvZGU6IGRlY29kZVxuICB9XG59XG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VcbiJdLCJuYW1lcyI6WyJfQnVmZmVyIiwicmVxdWlyZSIsIkJ1ZmZlciIsImJhc2UiLCJBTFBIQUJFVCIsImxlbmd0aCIsIlR5cGVFcnJvciIsIkJBU0VfTUFQIiwiVWludDhBcnJheSIsImoiLCJpIiwieCIsImNoYXJBdCIsInhjIiwiY2hhckNvZGVBdCIsIkJBU0UiLCJMRUFERVIiLCJGQUNUT1IiLCJNYXRoIiwibG9nIiwiaUZBQ1RPUiIsImVuY29kZSIsInNvdXJjZSIsIkFycmF5IiwiaXNBcnJheSIsImZyb20iLCJpc0J1ZmZlciIsInplcm9lcyIsInBiZWdpbiIsInBlbmQiLCJzaXplIiwiYjU4IiwiY2FycnkiLCJpdDEiLCJFcnJvciIsIml0MiIsInN0ciIsInJlcGVhdCIsImRlY29kZVVuc2FmZSIsImFsbG9jIiwicHN6IiwiYjI1NiIsIml0MyIsIml0NCIsInZjaCIsImFsbG9jVW5zYWZlIiwiZmlsbCIsImRlY29kZSIsInN0cmluZyIsImJ1ZmZlciIsIm1vZHVsZSIsImV4cG9ydHMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/@solana/web3.js/node_modules/base-x/src/index.js\n");

/***/ }),

/***/ "(ssr)/../node_modules/@solana/web3.js/node_modules/bs58/index.js":
/*!******************************************************************!*\
  !*** ../node_modules/@solana/web3.js/node_modules/bs58/index.js ***!
  \******************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("var basex = __webpack_require__(/*! base-x */ \"(ssr)/../node_modules/@solana/web3.js/node_modules/base-x/src/index.js\");\nvar ALPHABET = \"123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz\";\nmodule.exports = basex(ALPHABET);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL0Bzb2xhbmEvd2ViMy5qcy9ub2RlX21vZHVsZXMvYnM1OC9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBQSxJQUFJQSxRQUFRQyxtQkFBT0EsQ0FBQztBQUNwQixJQUFJQyxXQUFXO0FBRWZDLE9BQU9DLE9BQU8sR0FBR0osTUFBTUUiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL0Bzb2xhbmEvd2ViMy5qcy9ub2RlX21vZHVsZXMvYnM1OC9pbmRleC5qcz83NjU0Il0sInNvdXJjZXNDb250ZW50IjpbInZhciBiYXNleCA9IHJlcXVpcmUoJ2Jhc2UteCcpXG52YXIgQUxQSEFCRVQgPSAnMTIzNDU2Nzg5QUJDREVGR0hKS0xNTlBRUlNUVVZXWFlaYWJjZGVmZ2hpamttbm9wcXJzdHV2d3h5eidcblxubW9kdWxlLmV4cG9ydHMgPSBiYXNleChBTFBIQUJFVClcbiJdLCJuYW1lcyI6WyJiYXNleCIsInJlcXVpcmUiLCJBTFBIQUJFVCIsIm1vZHVsZSIsImV4cG9ydHMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/@solana/web3.js/node_modules/bs58/index.js\n");

/***/ }),

/***/ "(ssr)/../node_modules/@solana/wallet-adapter-react-ui/styles.css":
/*!******************************************************************!*\
  !*** ../node_modules/@solana/wallet-adapter-react-ui/styles.css ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (\"210c0ed7ce31\");\nif (false) {}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL0Bzb2xhbmEvd2FsbGV0LWFkYXB0ZXItcmVhY3QtdWkvc3R5bGVzLmNzcyIsIm1hcHBpbmdzIjoiOzs7O0FBQUEsaUVBQWUsY0FBYztBQUM3QixJQUFJLEtBQVUsRUFBRSxFQUF1QiIsInNvdXJjZXMiOlsid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvQHNvbGFuYS93YWxsZXQtYWRhcHRlci1yZWFjdC11aS9zdHlsZXMuY3NzPzIwMjIiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGRlZmF1bHQgXCIyMTBjMGVkN2NlMzFcIlxuaWYgKG1vZHVsZS5ob3QpIHsgbW9kdWxlLmhvdC5hY2NlcHQoKSB9XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/@solana/wallet-adapter-react-ui/styles.css\n");

/***/ }),

/***/ "(ssr)/../anchor/node_modules/@solana/web3.js/node_modules/superstruct/dist/index.mjs":
/*!**************************************************************************************!*\
  !*** ../anchor/node_modules/@solana/web3.js/node_modules/superstruct/dist/index.mjs ***!
  \**************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Struct: () => (/* binding */ Struct),\n/* harmony export */   StructError: () => (/* binding */ StructError),\n/* harmony export */   any: () => (/* binding */ any),\n/* harmony export */   array: () => (/* binding */ array),\n/* harmony export */   assert: () => (/* binding */ assert),\n/* harmony export */   assign: () => (/* binding */ assign),\n/* harmony export */   bigint: () => (/* binding */ bigint),\n/* harmony export */   boolean: () => (/* binding */ boolean),\n/* harmony export */   coerce: () => (/* binding */ coerce),\n/* harmony export */   create: () => (/* binding */ create),\n/* harmony export */   date: () => (/* binding */ date),\n/* harmony export */   defaulted: () => (/* binding */ defaulted),\n/* harmony export */   define: () => (/* binding */ define),\n/* harmony export */   deprecated: () => (/* binding */ deprecated),\n/* harmony export */   dynamic: () => (/* binding */ dynamic),\n/* harmony export */   empty: () => (/* binding */ empty),\n/* harmony export */   enums: () => (/* binding */ enums),\n/* harmony export */   func: () => (/* binding */ func),\n/* harmony export */   instance: () => (/* binding */ instance),\n/* harmony export */   integer: () => (/* binding */ integer),\n/* harmony export */   intersection: () => (/* binding */ intersection),\n/* harmony export */   is: () => (/* binding */ is),\n/* harmony export */   lazy: () => (/* binding */ lazy),\n/* harmony export */   literal: () => (/* binding */ literal),\n/* harmony export */   map: () => (/* binding */ map),\n/* harmony export */   mask: () => (/* binding */ mask),\n/* harmony export */   max: () => (/* binding */ max),\n/* harmony export */   min: () => (/* binding */ min),\n/* harmony export */   never: () => (/* binding */ never),\n/* harmony export */   nonempty: () => (/* binding */ nonempty),\n/* harmony export */   nullable: () => (/* binding */ nullable),\n/* harmony export */   number: () => (/* binding */ number),\n/* harmony export */   object: () => (/* binding */ object),\n/* harmony export */   omit: () => (/* binding */ omit),\n/* harmony export */   optional: () => (/* binding */ optional),\n/* harmony export */   partial: () => (/* binding */ partial),\n/* harmony export */   pattern: () => (/* binding */ pattern),\n/* harmony export */   pick: () => (/* binding */ pick),\n/* harmony export */   record: () => (/* binding */ record),\n/* harmony export */   refine: () => (/* binding */ refine),\n/* harmony export */   regexp: () => (/* binding */ regexp),\n/* harmony export */   set: () => (/* binding */ set),\n/* harmony export */   size: () => (/* binding */ size),\n/* harmony export */   string: () => (/* binding */ string),\n/* harmony export */   struct: () => (/* binding */ struct),\n/* harmony export */   trimmed: () => (/* binding */ trimmed),\n/* harmony export */   tuple: () => (/* binding */ tuple),\n/* harmony export */   type: () => (/* binding */ type),\n/* harmony export */   union: () => (/* binding */ union),\n/* harmony export */   unknown: () => (/* binding */ unknown),\n/* harmony export */   validate: () => (/* binding */ validate)\n/* harmony export */ });\n/**\n * A `StructFailure` represents a single specific failure in validation.\n */ /**\n * `StructError` objects are thrown (or returned) when validation fails.\n *\n * Validation logic is design to exit early for maximum performance. The error\n * represents the first error encountered during validation. For more detail,\n * the `error.failures` property is a generator function that can be run to\n * continue validation and receive all the failures in the data.\n */ class StructError extends TypeError {\n    constructor(failure, failures){\n        let cached;\n        const { message, explanation, ...rest } = failure;\n        const { path } = failure;\n        const msg = path.length === 0 ? message : `At path: ${path.join(\".\")} -- ${message}`;\n        super(explanation ?? msg);\n        if (explanation != null) this.cause = msg;\n        Object.assign(this, rest);\n        this.name = this.constructor.name;\n        this.failures = ()=>{\n            return cached ?? (cached = [\n                failure,\n                ...failures()\n            ]);\n        };\n    }\n}\n/**\n * Check if a value is an iterator.\n */ function isIterable(x) {\n    return isObject(x) && typeof x[Symbol.iterator] === \"function\";\n}\n/**\n * Check if a value is a plain object.\n */ function isObject(x) {\n    return typeof x === \"object\" && x != null;\n}\n/**\n * Check if a value is a plain object.\n */ function isPlainObject(x) {\n    if (Object.prototype.toString.call(x) !== \"[object Object]\") {\n        return false;\n    }\n    const prototype = Object.getPrototypeOf(x);\n    return prototype === null || prototype === Object.prototype;\n}\n/**\n * Return a value as a printable string.\n */ function print(value) {\n    if (typeof value === \"symbol\") {\n        return value.toString();\n    }\n    return typeof value === \"string\" ? JSON.stringify(value) : `${value}`;\n}\n/**\n * Shifts (removes and returns) the first value from the `input` iterator.\n * Like `Array.prototype.shift()` but for an `Iterator`.\n */ function shiftIterator(input) {\n    const { done, value } = input.next();\n    return done ? undefined : value;\n}\n/**\n * Convert a single validation result to a failure.\n */ function toFailure(result, context, struct, value) {\n    if (result === true) {\n        return;\n    } else if (result === false) {\n        result = {};\n    } else if (typeof result === \"string\") {\n        result = {\n            message: result\n        };\n    }\n    const { path, branch } = context;\n    const { type } = struct;\n    const { refinement, message = `Expected a value of type \\`${type}\\`${refinement ? ` with refinement \\`${refinement}\\`` : \"\"}, but received: \\`${print(value)}\\`` } = result;\n    return {\n        value,\n        type,\n        refinement,\n        key: path[path.length - 1],\n        path,\n        branch,\n        ...result,\n        message\n    };\n}\n/**\n * Convert a validation result to an iterable of failures.\n */ function* toFailures(result, context, struct, value) {\n    if (!isIterable(result)) {\n        result = [\n            result\n        ];\n    }\n    for (const r of result){\n        const failure = toFailure(r, context, struct, value);\n        if (failure) {\n            yield failure;\n        }\n    }\n}\n/**\n * Check a value against a struct, traversing deeply into nested values, and\n * returning an iterator of failures or success.\n */ function* run(value, struct, options = {}) {\n    const { path = [], branch = [\n        value\n    ], coerce = false, mask = false } = options;\n    const ctx = {\n        path,\n        branch\n    };\n    if (coerce) {\n        value = struct.coercer(value, ctx);\n        if (mask && struct.type !== \"type\" && isObject(struct.schema) && isObject(value) && !Array.isArray(value)) {\n            for(const key in value){\n                if (struct.schema[key] === undefined) {\n                    delete value[key];\n                }\n            }\n        }\n    }\n    let status = \"valid\";\n    for (const failure of struct.validator(value, ctx)){\n        failure.explanation = options.message;\n        status = \"not_valid\";\n        yield [\n            failure,\n            undefined\n        ];\n    }\n    for (let [k, v, s] of struct.entries(value, ctx)){\n        const ts = run(v, s, {\n            path: k === undefined ? path : [\n                ...path,\n                k\n            ],\n            branch: k === undefined ? branch : [\n                ...branch,\n                v\n            ],\n            coerce,\n            mask,\n            message: options.message\n        });\n        for (const t of ts){\n            if (t[0]) {\n                status = t[0].refinement != null ? \"not_refined\" : \"not_valid\";\n                yield [\n                    t[0],\n                    undefined\n                ];\n            } else if (coerce) {\n                v = t[1];\n                if (k === undefined) {\n                    value = v;\n                } else if (value instanceof Map) {\n                    value.set(k, v);\n                } else if (value instanceof Set) {\n                    value.add(v);\n                } else if (isObject(value)) {\n                    if (v !== undefined || k in value) value[k] = v;\n                }\n            }\n        }\n    }\n    if (status !== \"not_valid\") {\n        for (const failure of struct.refiner(value, ctx)){\n            failure.explanation = options.message;\n            status = \"not_refined\";\n            yield [\n                failure,\n                undefined\n            ];\n        }\n    }\n    if (status === \"valid\") {\n        yield [\n            undefined,\n            value\n        ];\n    }\n}\n/**\n * `Struct` objects encapsulate the validation logic for a specific type of\n * values. Once constructed, you use the `assert`, `is` or `validate` helpers to\n * validate unknown input data against the struct.\n */ class Struct {\n    constructor(props){\n        const { type, schema, validator, refiner, coercer = (value)=>value, entries = function*() {} } = props;\n        this.type = type;\n        this.schema = schema;\n        this.entries = entries;\n        this.coercer = coercer;\n        if (validator) {\n            this.validator = (value, context)=>{\n                const result = validator(value, context);\n                return toFailures(result, context, this, value);\n            };\n        } else {\n            this.validator = ()=>[];\n        }\n        if (refiner) {\n            this.refiner = (value, context)=>{\n                const result = refiner(value, context);\n                return toFailures(result, context, this, value);\n            };\n        } else {\n            this.refiner = ()=>[];\n        }\n    }\n    /**\n     * Assert that a value passes the struct's validation, throwing if it doesn't.\n     */ assert(value, message) {\n        return assert(value, this, message);\n    }\n    /**\n     * Create a value with the struct's coercion logic, then validate it.\n     */ create(value, message) {\n        return create(value, this, message);\n    }\n    /**\n     * Check if a value passes the struct's validation.\n     */ is(value) {\n        return is(value, this);\n    }\n    /**\n     * Mask a value, coercing and validating it, but returning only the subset of\n     * properties defined by the struct's schema.\n     */ mask(value, message) {\n        return mask(value, this, message);\n    }\n    /**\n     * Validate a value with the struct's validation logic, returning a tuple\n     * representing the result.\n     *\n     * You may optionally pass `true` for the `withCoercion` argument to coerce\n     * the value before attempting to validate it. If you do, the result will\n     * contain the coerced result when successful.\n     */ validate(value, options = {}) {\n        return validate(value, this, options);\n    }\n}\n/**\n * Assert that a value passes a struct, throwing if it doesn't.\n */ function assert(value, struct, message) {\n    const result = validate(value, struct, {\n        message\n    });\n    if (result[0]) {\n        throw result[0];\n    }\n}\n/**\n * Create a value with the coercion logic of struct and validate it.\n */ function create(value, struct, message) {\n    const result = validate(value, struct, {\n        coerce: true,\n        message\n    });\n    if (result[0]) {\n        throw result[0];\n    } else {\n        return result[1];\n    }\n}\n/**\n * Mask a value, returning only the subset of properties defined by a struct.\n */ function mask(value, struct, message) {\n    const result = validate(value, struct, {\n        coerce: true,\n        mask: true,\n        message\n    });\n    if (result[0]) {\n        throw result[0];\n    } else {\n        return result[1];\n    }\n}\n/**\n * Check if a value passes a struct.\n */ function is(value, struct) {\n    const result = validate(value, struct);\n    return !result[0];\n}\n/**\n * Validate a value against a struct, returning an error if invalid, or the\n * value (with potential coercion) if valid.\n */ function validate(value, struct, options = {}) {\n    const tuples = run(value, struct, options);\n    const tuple = shiftIterator(tuples);\n    if (tuple[0]) {\n        const error = new StructError(tuple[0], function*() {\n            for (const t of tuples){\n                if (t[0]) {\n                    yield t[0];\n                }\n            }\n        });\n        return [\n            error,\n            undefined\n        ];\n    } else {\n        const v = tuple[1];\n        return [\n            undefined,\n            v\n        ];\n    }\n}\nfunction assign(...Structs) {\n    const isType = Structs[0].type === \"type\";\n    const schemas = Structs.map((s)=>s.schema);\n    const schema = Object.assign({}, ...schemas);\n    return isType ? type(schema) : object(schema);\n}\n/**\n * Define a new struct type with a custom validation function.\n */ function define(name, validator) {\n    return new Struct({\n        type: name,\n        schema: null,\n        validator\n    });\n}\n/**\n * Create a new struct based on an existing struct, but the value is allowed to\n * be `undefined`. `log` will be called if the value is not `undefined`.\n */ function deprecated(struct, log) {\n    return new Struct({\n        ...struct,\n        refiner: (value, ctx)=>value === undefined || struct.refiner(value, ctx),\n        validator (value, ctx) {\n            if (value === undefined) {\n                return true;\n            } else {\n                log(value, ctx);\n                return struct.validator(value, ctx);\n            }\n        }\n    });\n}\n/**\n * Create a struct with dynamic validation logic.\n *\n * The callback will receive the value currently being validated, and must\n * return a struct object to validate it with. This can be useful to model\n * validation logic that changes based on its input.\n */ function dynamic(fn) {\n    return new Struct({\n        type: \"dynamic\",\n        schema: null,\n        *entries (value, ctx) {\n            const struct = fn(value, ctx);\n            yield* struct.entries(value, ctx);\n        },\n        validator (value, ctx) {\n            const struct = fn(value, ctx);\n            return struct.validator(value, ctx);\n        },\n        coercer (value, ctx) {\n            const struct = fn(value, ctx);\n            return struct.coercer(value, ctx);\n        },\n        refiner (value, ctx) {\n            const struct = fn(value, ctx);\n            return struct.refiner(value, ctx);\n        }\n    });\n}\n/**\n * Create a struct with lazily evaluated validation logic.\n *\n * The first time validation is run with the struct, the callback will be called\n * and must return a struct object to use. This is useful for cases where you\n * want to have self-referential structs for nested data structures to avoid a\n * circular definition problem.\n */ function lazy(fn) {\n    let struct;\n    return new Struct({\n        type: \"lazy\",\n        schema: null,\n        *entries (value, ctx) {\n            struct ?? (struct = fn());\n            yield* struct.entries(value, ctx);\n        },\n        validator (value, ctx) {\n            struct ?? (struct = fn());\n            return struct.validator(value, ctx);\n        },\n        coercer (value, ctx) {\n            struct ?? (struct = fn());\n            return struct.coercer(value, ctx);\n        },\n        refiner (value, ctx) {\n            struct ?? (struct = fn());\n            return struct.refiner(value, ctx);\n        }\n    });\n}\n/**\n * Create a new struct based on an existing object struct, but excluding\n * specific properties.\n *\n * Like TypeScript's `Omit` utility.\n */ function omit(struct, keys) {\n    const { schema } = struct;\n    const subschema = {\n        ...schema\n    };\n    for (const key of keys){\n        delete subschema[key];\n    }\n    switch(struct.type){\n        case \"type\":\n            return type(subschema);\n        default:\n            return object(subschema);\n    }\n}\n/**\n * Create a new struct based on an existing object struct, but with all of its\n * properties allowed to be `undefined`.\n *\n * Like TypeScript's `Partial` utility.\n */ function partial(struct) {\n    const isStruct = struct instanceof Struct;\n    const schema = isStruct ? {\n        ...struct.schema\n    } : {\n        ...struct\n    };\n    for(const key in schema){\n        schema[key] = optional(schema[key]);\n    }\n    if (isStruct && struct.type === \"type\") {\n        return type(schema);\n    }\n    return object(schema);\n}\n/**\n * Create a new struct based on an existing object struct, but only including\n * specific properties.\n *\n * Like TypeScript's `Pick` utility.\n */ function pick(struct, keys) {\n    const { schema } = struct;\n    const subschema = {};\n    for (const key of keys){\n        subschema[key] = schema[key];\n    }\n    switch(struct.type){\n        case \"type\":\n            return type(subschema);\n        default:\n            return object(subschema);\n    }\n}\n/**\n * Define a new struct type with a custom validation function.\n *\n * @deprecated This function has been renamed to `define`.\n */ function struct(name, validator) {\n    console.warn(\"superstruct@0.11 - The `struct` helper has been renamed to `define`.\");\n    return define(name, validator);\n}\n/**\n * Ensure that any value passes validation.\n */ function any() {\n    return define(\"any\", ()=>true);\n}\nfunction array(Element) {\n    return new Struct({\n        type: \"array\",\n        schema: Element,\n        *entries (value) {\n            if (Element && Array.isArray(value)) {\n                for (const [i, v] of value.entries()){\n                    yield [\n                        i,\n                        v,\n                        Element\n                    ];\n                }\n            }\n        },\n        coercer (value) {\n            return Array.isArray(value) ? value.slice() : value;\n        },\n        validator (value) {\n            return Array.isArray(value) || `Expected an array value, but received: ${print(value)}`;\n        }\n    });\n}\n/**\n * Ensure that a value is a bigint.\n */ function bigint() {\n    return define(\"bigint\", (value)=>{\n        return typeof value === \"bigint\";\n    });\n}\n/**\n * Ensure that a value is a boolean.\n */ function boolean() {\n    return define(\"boolean\", (value)=>{\n        return typeof value === \"boolean\";\n    });\n}\n/**\n * Ensure that a value is a valid `Date`.\n *\n * Note: this also ensures that the value is *not* an invalid `Date` object,\n * which can occur when parsing a date fails but still returns a `Date`.\n */ function date() {\n    return define(\"date\", (value)=>{\n        return value instanceof Date && !isNaN(value.getTime()) || `Expected a valid \\`Date\\` object, but received: ${print(value)}`;\n    });\n}\nfunction enums(values) {\n    const schema = {};\n    const description = values.map((v)=>print(v)).join();\n    for (const key of values){\n        schema[key] = key;\n    }\n    return new Struct({\n        type: \"enums\",\n        schema,\n        validator (value) {\n            return values.includes(value) || `Expected one of \\`${description}\\`, but received: ${print(value)}`;\n        }\n    });\n}\n/**\n * Ensure that a value is a function.\n */ function func() {\n    return define(\"func\", (value)=>{\n        return typeof value === \"function\" || `Expected a function, but received: ${print(value)}`;\n    });\n}\n/**\n * Ensure that a value is an instance of a specific class.\n */ function instance(Class) {\n    return define(\"instance\", (value)=>{\n        return value instanceof Class || `Expected a \\`${Class.name}\\` instance, but received: ${print(value)}`;\n    });\n}\n/**\n * Ensure that a value is an integer.\n */ function integer() {\n    return define(\"integer\", (value)=>{\n        return typeof value === \"number\" && !isNaN(value) && Number.isInteger(value) || `Expected an integer, but received: ${print(value)}`;\n    });\n}\n/**\n * Ensure that a value matches all of a set of types.\n */ function intersection(Structs) {\n    return new Struct({\n        type: \"intersection\",\n        schema: null,\n        *entries (value, ctx) {\n            for (const S of Structs){\n                yield* S.entries(value, ctx);\n            }\n        },\n        *validator (value, ctx) {\n            for (const S of Structs){\n                yield* S.validator(value, ctx);\n            }\n        },\n        *refiner (value, ctx) {\n            for (const S of Structs){\n                yield* S.refiner(value, ctx);\n            }\n        }\n    });\n}\nfunction literal(constant) {\n    const description = print(constant);\n    const t = typeof constant;\n    return new Struct({\n        type: \"literal\",\n        schema: t === \"string\" || t === \"number\" || t === \"boolean\" ? constant : null,\n        validator (value) {\n            return value === constant || `Expected the literal \\`${description}\\`, but received: ${print(value)}`;\n        }\n    });\n}\nfunction map(Key, Value) {\n    return new Struct({\n        type: \"map\",\n        schema: null,\n        *entries (value) {\n            if (Key && Value && value instanceof Map) {\n                for (const [k, v] of value.entries()){\n                    yield [\n                        k,\n                        k,\n                        Key\n                    ];\n                    yield [\n                        k,\n                        v,\n                        Value\n                    ];\n                }\n            }\n        },\n        coercer (value) {\n            return value instanceof Map ? new Map(value) : value;\n        },\n        validator (value) {\n            return value instanceof Map || `Expected a \\`Map\\` object, but received: ${print(value)}`;\n        }\n    });\n}\n/**\n * Ensure that no value ever passes validation.\n */ function never() {\n    return define(\"never\", ()=>false);\n}\n/**\n * Augment an existing struct to allow `null` values.\n */ function nullable(struct) {\n    return new Struct({\n        ...struct,\n        validator: (value, ctx)=>value === null || struct.validator(value, ctx),\n        refiner: (value, ctx)=>value === null || struct.refiner(value, ctx)\n    });\n}\n/**\n * Ensure that a value is a number.\n */ function number() {\n    return define(\"number\", (value)=>{\n        return typeof value === \"number\" && !isNaN(value) || `Expected a number, but received: ${print(value)}`;\n    });\n}\nfunction object(schema) {\n    const knowns = schema ? Object.keys(schema) : [];\n    const Never = never();\n    return new Struct({\n        type: \"object\",\n        schema: schema ? schema : null,\n        *entries (value) {\n            if (schema && isObject(value)) {\n                const unknowns = new Set(Object.keys(value));\n                for (const key of knowns){\n                    unknowns.delete(key);\n                    yield [\n                        key,\n                        value[key],\n                        schema[key]\n                    ];\n                }\n                for (const key of unknowns){\n                    yield [\n                        key,\n                        value[key],\n                        Never\n                    ];\n                }\n            }\n        },\n        validator (value) {\n            return isObject(value) || `Expected an object, but received: ${print(value)}`;\n        },\n        coercer (value) {\n            return isObject(value) ? {\n                ...value\n            } : value;\n        }\n    });\n}\n/**\n * Augment a struct to allow `undefined` values.\n */ function optional(struct) {\n    return new Struct({\n        ...struct,\n        validator: (value, ctx)=>value === undefined || struct.validator(value, ctx),\n        refiner: (value, ctx)=>value === undefined || struct.refiner(value, ctx)\n    });\n}\n/**\n * Ensure that a value is an object with keys and values of specific types, but\n * without ensuring any specific shape of properties.\n *\n * Like TypeScript's `Record` utility.\n */ function record(Key, Value) {\n    return new Struct({\n        type: \"record\",\n        schema: null,\n        *entries (value) {\n            if (isObject(value)) {\n                for(const k in value){\n                    const v = value[k];\n                    yield [\n                        k,\n                        k,\n                        Key\n                    ];\n                    yield [\n                        k,\n                        v,\n                        Value\n                    ];\n                }\n            }\n        },\n        validator (value) {\n            return isObject(value) || `Expected an object, but received: ${print(value)}`;\n        }\n    });\n}\n/**\n * Ensure that a value is a `RegExp`.\n *\n * Note: this does not test the value against the regular expression! For that\n * you need to use the `pattern()` refinement.\n */ function regexp() {\n    return define(\"regexp\", (value)=>{\n        return value instanceof RegExp;\n    });\n}\nfunction set(Element) {\n    return new Struct({\n        type: \"set\",\n        schema: null,\n        *entries (value) {\n            if (Element && value instanceof Set) {\n                for (const v of value){\n                    yield [\n                        v,\n                        v,\n                        Element\n                    ];\n                }\n            }\n        },\n        coercer (value) {\n            return value instanceof Set ? new Set(value) : value;\n        },\n        validator (value) {\n            return value instanceof Set || `Expected a \\`Set\\` object, but received: ${print(value)}`;\n        }\n    });\n}\n/**\n * Ensure that a value is a string.\n */ function string() {\n    return define(\"string\", (value)=>{\n        return typeof value === \"string\" || `Expected a string, but received: ${print(value)}`;\n    });\n}\n/**\n * Ensure that a value is a tuple of a specific length, and that each of its\n * elements is of a specific type.\n */ function tuple(Structs) {\n    const Never = never();\n    return new Struct({\n        type: \"tuple\",\n        schema: null,\n        *entries (value) {\n            if (Array.isArray(value)) {\n                const length = Math.max(Structs.length, value.length);\n                for(let i = 0; i < length; i++){\n                    yield [\n                        i,\n                        value[i],\n                        Structs[i] || Never\n                    ];\n                }\n            }\n        },\n        validator (value) {\n            return Array.isArray(value) || `Expected an array, but received: ${print(value)}`;\n        }\n    });\n}\n/**\n * Ensure that a value has a set of known properties of specific types.\n *\n * Note: Unrecognized properties are allowed and untouched. This is similar to\n * how TypeScript's structural typing works.\n */ function type(schema) {\n    const keys = Object.keys(schema);\n    return new Struct({\n        type: \"type\",\n        schema,\n        *entries (value) {\n            if (isObject(value)) {\n                for (const k of keys){\n                    yield [\n                        k,\n                        value[k],\n                        schema[k]\n                    ];\n                }\n            }\n        },\n        validator (value) {\n            return isObject(value) || `Expected an object, but received: ${print(value)}`;\n        },\n        coercer (value) {\n            return isObject(value) ? {\n                ...value\n            } : value;\n        }\n    });\n}\n/**\n * Ensure that a value matches one of a set of types.\n */ function union(Structs) {\n    const description = Structs.map((s)=>s.type).join(\" | \");\n    return new Struct({\n        type: \"union\",\n        schema: null,\n        coercer (value) {\n            for (const S of Structs){\n                const [error, coerced] = S.validate(value, {\n                    coerce: true\n                });\n                if (!error) {\n                    return coerced;\n                }\n            }\n            return value;\n        },\n        validator (value, ctx) {\n            const failures = [];\n            for (const S of Structs){\n                const [...tuples] = run(value, S, ctx);\n                const [first] = tuples;\n                if (!first[0]) {\n                    return [];\n                } else {\n                    for (const [failure] of tuples){\n                        if (failure) {\n                            failures.push(failure);\n                        }\n                    }\n                }\n            }\n            return [\n                `Expected the value to satisfy a union of \\`${description}\\`, but received: ${print(value)}`,\n                ...failures\n            ];\n        }\n    });\n}\n/**\n * Ensure that any value passes validation, without widening its type to `any`.\n */ function unknown() {\n    return define(\"unknown\", ()=>true);\n}\n/**\n * Augment a `Struct` to add an additional coercion step to its input.\n *\n * This allows you to transform input data before validating it, to increase the\n * likelihood that it passes validation—for example for default values, parsing\n * different formats, etc.\n *\n * Note: You must use `create(value, Struct)` on the value to have the coercion\n * take effect! Using simply `assert()` or `is()` will not use coercion.\n */ function coerce(struct, condition, coercer) {\n    return new Struct({\n        ...struct,\n        coercer: (value, ctx)=>{\n            return is(value, condition) ? struct.coercer(coercer(value, ctx), ctx) : struct.coercer(value, ctx);\n        }\n    });\n}\n/**\n * Augment a struct to replace `undefined` values with a default.\n *\n * Note: You must use `create(value, Struct)` on the value to have the coercion\n * take effect! Using simply `assert()` or `is()` will not use coercion.\n */ function defaulted(struct, fallback, options = {}) {\n    return coerce(struct, unknown(), (x)=>{\n        const f = typeof fallback === \"function\" ? fallback() : fallback;\n        if (x === undefined) {\n            return f;\n        }\n        if (!options.strict && isPlainObject(x) && isPlainObject(f)) {\n            const ret = {\n                ...x\n            };\n            let changed = false;\n            for(const key in f){\n                if (ret[key] === undefined) {\n                    ret[key] = f[key];\n                    changed = true;\n                }\n            }\n            if (changed) {\n                return ret;\n            }\n        }\n        return x;\n    });\n}\n/**\n * Augment a struct to trim string inputs.\n *\n * Note: You must use `create(value, Struct)` on the value to have the coercion\n * take effect! Using simply `assert()` or `is()` will not use coercion.\n */ function trimmed(struct) {\n    return coerce(struct, string(), (x)=>x.trim());\n}\n/**\n * Ensure that a string, array, map, or set is empty.\n */ function empty(struct) {\n    return refine(struct, \"empty\", (value)=>{\n        const size = getSize(value);\n        return size === 0 || `Expected an empty ${struct.type} but received one with a size of \\`${size}\\``;\n    });\n}\nfunction getSize(value) {\n    if (value instanceof Map || value instanceof Set) {\n        return value.size;\n    } else {\n        return value.length;\n    }\n}\n/**\n * Ensure that a number or date is below a threshold.\n */ function max(struct, threshold, options = {}) {\n    const { exclusive } = options;\n    return refine(struct, \"max\", (value)=>{\n        return exclusive ? value < threshold : value <= threshold || `Expected a ${struct.type} less than ${exclusive ? \"\" : \"or equal to \"}${threshold} but received \\`${value}\\``;\n    });\n}\n/**\n * Ensure that a number or date is above a threshold.\n */ function min(struct, threshold, options = {}) {\n    const { exclusive } = options;\n    return refine(struct, \"min\", (value)=>{\n        return exclusive ? value > threshold : value >= threshold || `Expected a ${struct.type} greater than ${exclusive ? \"\" : \"or equal to \"}${threshold} but received \\`${value}\\``;\n    });\n}\n/**\n * Ensure that a string, array, map or set is not empty.\n */ function nonempty(struct) {\n    return refine(struct, \"nonempty\", (value)=>{\n        const size = getSize(value);\n        return size > 0 || `Expected a nonempty ${struct.type} but received an empty one`;\n    });\n}\n/**\n * Ensure that a string matches a regular expression.\n */ function pattern(struct, regexp) {\n    return refine(struct, \"pattern\", (value)=>{\n        return regexp.test(value) || `Expected a ${struct.type} matching \\`/${regexp.source}/\\` but received \"${value}\"`;\n    });\n}\n/**\n * Ensure that a string, array, number, date, map, or set has a size (or length, or time) between `min` and `max`.\n */ function size(struct, min, max = min) {\n    const expected = `Expected a ${struct.type}`;\n    const of = min === max ? `of \\`${min}\\`` : `between \\`${min}\\` and \\`${max}\\``;\n    return refine(struct, \"size\", (value)=>{\n        if (typeof value === \"number\" || value instanceof Date) {\n            return min <= value && value <= max || `${expected} ${of} but received \\`${value}\\``;\n        } else if (value instanceof Map || value instanceof Set) {\n            const { size } = value;\n            return min <= size && size <= max || `${expected} with a size ${of} but received one with a size of \\`${size}\\``;\n        } else {\n            const { length } = value;\n            return min <= length && length <= max || `${expected} with a length ${of} but received one with a length of \\`${length}\\``;\n        }\n    });\n}\n/**\n * Augment a `Struct` to add an additional refinement to the validation.\n *\n * The refiner function is guaranteed to receive a value of the struct's type,\n * because the struct's existing validation will already have passed. This\n * allows you to layer additional validation on top of existing structs.\n */ function refine(struct, name, refiner) {\n    return new Struct({\n        ...struct,\n        *refiner (value, ctx) {\n            yield* struct.refiner(value, ctx);\n            const result = refiner(value, ctx);\n            const failures = toFailures(result, ctx, struct, value);\n            for (const failure of failures){\n                yield {\n                    ...failure,\n                    refinement: name\n                };\n            }\n        }\n    });\n}\n //# sourceMappingURL=index.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vYW5jaG9yL25vZGVfbW9kdWxlcy9Ac29sYW5hL3dlYjMuanMvbm9kZV9tb2R1bGVzL3N1cGVyc3RydWN0L2Rpc3QvaW5kZXgubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBOztDQUVDLEdBQ0Q7Ozs7Ozs7Q0FPQyxHQUNELE1BQU1BLG9CQUFvQkM7SUFDdEJDLFlBQVlDLE9BQU8sRUFBRUMsUUFBUSxDQUFFO1FBQzNCLElBQUlDO1FBQ0osTUFBTSxFQUFFQyxPQUFPLEVBQUVDLFdBQVcsRUFBRSxHQUFHQyxNQUFNLEdBQUdMO1FBQzFDLE1BQU0sRUFBRU0sSUFBSSxFQUFFLEdBQUdOO1FBQ2pCLE1BQU1PLE1BQU1ELEtBQUtFLE1BQU0sS0FBSyxJQUFJTCxVQUFVLENBQUMsU0FBUyxFQUFFRyxLQUFLRyxJQUFJLENBQUMsS0FBSyxJQUFJLEVBQUVOLFFBQVEsQ0FBQztRQUNwRixLQUFLLENBQUNDLGVBQWVHO1FBQ3JCLElBQUlILGVBQWUsTUFDZixJQUFJLENBQUNNLEtBQUssR0FBR0g7UUFDakJJLE9BQU9DLE1BQU0sQ0FBQyxJQUFJLEVBQUVQO1FBQ3BCLElBQUksQ0FBQ1EsSUFBSSxHQUFHLElBQUksQ0FBQ2QsV0FBVyxDQUFDYyxJQUFJO1FBQ2pDLElBQUksQ0FBQ1osUUFBUSxHQUFHO1lBQ1osT0FBUUMsVUFBV0EsQ0FBQUEsU0FBUztnQkFBQ0Y7bUJBQVlDO2FBQVc7UUFDeEQ7SUFDSjtBQUNKO0FBRUE7O0NBRUMsR0FDRCxTQUFTYSxXQUFXQyxDQUFDO0lBQ2pCLE9BQU9DLFNBQVNELE1BQU0sT0FBT0EsQ0FBQyxDQUFDRSxPQUFPQyxRQUFRLENBQUMsS0FBSztBQUN4RDtBQUNBOztDQUVDLEdBQ0QsU0FBU0YsU0FBU0QsQ0FBQztJQUNmLE9BQU8sT0FBT0EsTUFBTSxZQUFZQSxLQUFLO0FBQ3pDO0FBQ0E7O0NBRUMsR0FDRCxTQUFTSSxjQUFjSixD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R0FBR0QsT0FBTztvQkFBRXVDLFlBQVkxQjtnQkFBSztZQUN6QztRQUNKO0lBQ0o7QUFDSjtBQUU2WixDQUM3WixrQ0FBa0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vYW5jaG9yL25vZGVfbW9kdWxlcy9Ac29sYW5hL3dlYjMuanMvbm9kZV9tb2R1bGVzL3N1cGVyc3RydWN0L2Rpc3QvaW5kZXgubWpzPzY4YjUiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBBIGBTdHJ1Y3RGYWlsdXJlYCByZXByZXNlbnRzIGEgc2luZ2xlIHNwZWNpZmljIGZhaWx1cmUgaW4gdmFsaWRhdGlvbi5cbiAqL1xuLyoqXG4gKiBgU3RydWN0RXJyb3JgIG9iamVjdHMgYXJlIHRocm93biAob3IgcmV0dXJuZWQpIHdoZW4gdmFsaWRhdGlvbiBmYWlscy5cbiAqXG4gKiBWYWxpZGF0aW9uIGxvZ2ljIGlzIGRlc2lnbiB0byBleGl0IGVhcmx5IGZvciBtYXhpbXVtIHBlcmZvcm1hbmNlLiBUaGUgZXJyb3JcbiAqIHJlcHJlc2VudHMgdGhlIGZpcnN0IGVycm9yIGVuY291bnRlcmVkIGR1cmluZyB2YWxpZGF0aW9uLiBGb3IgbW9yZSBkZXRhaWwsXG4gKiB0aGUgYGVycm9yLmZhaWx1cmVzYCBwcm9wZXJ0eSBpcyBhIGdlbmVyYXRvciBmdW5jdGlvbiB0aGF0IGNhbiBiZSBydW4gdG9cbiAqIGNvbnRpbnVlIHZhbGlkYXRpb24gYW5kIHJlY2VpdmUgYWxsIHRoZSBmYWlsdXJlcyBpbiB0aGUgZGF0YS5cbiAqL1xuY2xhc3MgU3RydWN0RXJyb3IgZXh0ZW5kcyBUeXBlRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKGZhaWx1cmUsIGZhaWx1cmVzKSB7XG4gICAgICAgIGxldCBjYWNoZWQ7XG4gICAgICAgIGNvbnN0IHsgbWVzc2FnZSwgZXhwbGFuYXRpb24sIC4uLnJlc3QgfSA9IGZhaWx1cmU7XG4gICAgICAgIGNvbnN0IHsgcGF0aCB9ID0gZmFpbHVyZTtcbiAgICAgICAgY29uc3QgbXNnID0gcGF0aC5sZW5ndGggPT09IDAgPyBtZXNzYWdlIDogYEF0IHBhdGg6ICR7cGF0aC5qb2luKCcuJyl9IC0tICR7bWVzc2FnZX1gO1xuICAgICAgICBzdXBlcihleHBsYW5hdGlvbiA/PyBtc2cpO1xuICAgICAgICBpZiAoZXhwbGFuYXRpb24gIT0gbnVsbClcbiAgICAgICAgICAgIHRoaXMuY2F1c2UgPSBtc2c7XG4gICAgICAgIE9iamVjdC5hc3NpZ24odGhpcywgcmVzdCk7XG4gICAgICAgIHRoaXMubmFtZSA9IHRoaXMuY29uc3RydWN0b3IubmFtZTtcbiAgICAgICAgdGhpcy5mYWlsdXJlcyA9ICgpID0+IHtcbiAgICAgICAgICAgIHJldHVybiAoY2FjaGVkID8/IChjYWNoZWQgPSBbZmFpbHVyZSwgLi4uZmFpbHVyZXMoKV0pKTtcbiAgICAgICAgfTtcbiAgICB9XG59XG5cbi8qKlxuICogQ2hlY2sgaWYgYSB2YWx1ZSBpcyBhbiBpdGVyYXRvci5cbiAqL1xuZnVuY3Rpb24gaXNJdGVyYWJsZSh4KSB7XG4gICAgcmV0dXJuIGlzT2JqZWN0KHgpICYmIHR5cGVvZiB4W1N5bWJvbC5pdGVyYXRvcl0gPT09ICdmdW5jdGlvbic7XG59XG4vKipcbiAqIENoZWNrIGlmIGEgdmFsdWUgaXMgYSBwbGFpbiBvYmplY3QuXG4gKi9cbmZ1bmN0aW9uIGlzT2JqZWN0KHgpIHtcbiAgICByZXR1cm4gdHlwZW9mIHggPT09ICdvYmplY3QnICYmIHggIT0gbnVsbDtcbn1cbi8qKlxuICogQ2hlY2sgaWYgYSB2YWx1ZSBpcyBhIHBsYWluIG9iamVjdC5cbiAqL1xuZnVuY3Rpb24gaXNQbGFpbk9iamVjdCh4KSB7XG4gICAgaWYgKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh4KSAhPT0gJ1tvYmplY3QgT2JqZWN0XScpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBjb25zdCBwcm90b3R5cGUgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YoeCk7XG4gICAgcmV0dXJuIHByb3RvdHlwZSA9PT0gbnVsbCB8fCBwcm90b3R5cGUgPT09IE9iamVjdC5wcm90b3R5cGU7XG59XG4vKipcbiAqIFJldHVybiBhIHZhbHVlIGFzIGEgcHJpbnRhYmxlIHN0cmluZy5cbiAqL1xuZnVuY3Rpb24gcHJpbnQodmFsdWUpIHtcbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3ltYm9sJykge1xuICAgICAgICByZXR1cm4gdmFsdWUudG9TdHJpbmcoKTtcbiAgICB9XG4gICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycgPyBKU09OLnN0cmluZ2lmeSh2YWx1ZSkgOiBgJHt2YWx1ZX1gO1xufVxuLyoqXG4gKiBTaGlmdHMgKHJlbW92ZXMgYW5kIHJldHVybnMpIHRoZSBmaXJzdCB2YWx1ZSBmcm9tIHRoZSBgaW5wdXRgIGl0ZXJhdG9yLlxuICogTGlrZSBgQXJyYXkucHJvdG90eXBlLnNoaWZ0KClgIGJ1dCBmb3IgYW4gYEl0ZXJhdG9yYC5cbiAqL1xuZnVuY3Rpb24gc2hpZnRJdGVyYXRvcihpbnB1dCkge1xuICAgIGNvbnN0IHsgZG9uZSwgdmFsdWUgfSA9IGlucHV0Lm5leHQoKTtcbiAgICByZXR1cm4gZG9uZSA/IHVuZGVmaW5lZCA6IHZhbHVlO1xufVxuLyoqXG4gKiBDb252ZXJ0IGEgc2luZ2xlIHZhbGlkYXRpb24gcmVzdWx0IHRvIGEgZmFpbHVyZS5cbiAqL1xuZnVuY3Rpb24gdG9GYWlsdXJlKHJlc3VsdCwgY29udGV4dCwgc3RydWN0LCB2YWx1ZSkge1xuICAgIGlmIChyZXN1bHQgPT09IHRydWUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBlbHNlIGlmIChyZXN1bHQgPT09IGZhbHNlKSB7XG4gICAgICAgIHJlc3VsdCA9IHt9O1xuICAgIH1cbiAgICBlbHNlIGlmICh0eXBlb2YgcmVzdWx0ID09PSAnc3RyaW5nJykge1xuICAgICAgICByZXN1bHQgPSB7IG1lc3NhZ2U6IHJlc3VsdCB9O1xuICAgIH1cbiAgICBjb25zdCB7IHBhdGgsIGJyYW5jaCB9ID0gY29udGV4dDtcbiAgICBjb25zdCB7IHR5cGUgfSA9IHN0cnVjdDtcbiAgICBjb25zdCB7IHJlZmluZW1lbnQsIG1lc3NhZ2UgPSBgRXhwZWN0ZWQgYSB2YWx1ZSBvZiB0eXBlIFxcYCR7dHlwZX1cXGAke3JlZmluZW1lbnQgPyBgIHdpdGggcmVmaW5lbWVudCBcXGAke3JlZmluZW1lbnR9XFxgYCA6ICcnfSwgYnV0IHJlY2VpdmVkOiBcXGAke3ByaW50KHZhbHVlKX1cXGBgLCB9ID0gcmVzdWx0O1xuICAgIHJldHVybiB7XG4gICAgICAgIHZhbHVlLFxuICAgICAgICB0eXBlLFxuICAgICAgICByZWZpbmVtZW50LFxuICAgICAgICBrZXk6IHBhdGhbcGF0aC5sZW5ndGggLSAxXSxcbiAgICAgICAgcGF0aCxcbiAgICAgICAgYnJhbmNoLFxuICAgICAgICAuLi5yZXN1bHQsXG4gICAgICAgIG1lc3NhZ2UsXG4gICAgfTtcbn1cbi8qKlxuICogQ29udmVydCBhIHZhbGlkYXRpb24gcmVzdWx0IHRvIGFuIGl0ZXJhYmxlIG9mIGZhaWx1cmVzLlxuICovXG5mdW5jdGlvbiogdG9GYWlsdXJlcyhyZXN1bHQsIGNvbnRleHQsIHN0cnVjdCwgdmFsdWUpIHtcbiAgICBpZiAoIWlzSXRlcmFibGUocmVzdWx0KSkge1xuICAgICAgICByZXN1bHQgPSBbcmVzdWx0XTtcbiAgICB9XG4gICAgZm9yIChjb25zdCByIG9mIHJlc3VsdCkge1xuICAgICAgICBjb25zdCBmYWlsdXJlID0gdG9GYWlsdXJlKHIsIGNvbnRleHQsIHN0cnVjdCwgdmFsdWUpO1xuICAgICAgICBpZiAoZmFpbHVyZSkge1xuICAgICAgICAgICAgeWllbGQgZmFpbHVyZTtcbiAgICAgICAgfVxuICAgIH1cbn1cbi8qKlxuICogQ2hlY2sgYSB2YWx1ZSBhZ2FpbnN0IGEgc3RydWN0LCB0cmF2ZXJzaW5nIGRlZXBseSBpbnRvIG5lc3RlZCB2YWx1ZXMsIGFuZFxuICogcmV0dXJuaW5nIGFuIGl0ZXJhdG9yIG9mIGZhaWx1cmVzIG9yIHN1Y2Nlc3MuXG4gKi9cbmZ1bmN0aW9uKiBydW4odmFsdWUsIHN0cnVjdCwgb3B0aW9ucyA9IHt9KSB7XG4gICAgY29uc3QgeyBwYXRoID0gW10sIGJyYW5jaCA9IFt2YWx1ZV0sIGNvZXJjZSA9IGZhbHNlLCBtYXNrID0gZmFsc2UgfSA9IG9wdGlvbnM7XG4gICAgY29uc3QgY3R4ID0geyBwYXRoLCBicmFuY2ggfTtcbiAgICBpZiAoY29lcmNlKSB7XG4gICAgICAgIHZhbHVlID0gc3RydWN0LmNvZXJjZXIodmFsdWUsIGN0eCk7XG4gICAgICAgIGlmIChtYXNrICYmXG4gICAgICAgICAgICBzdHJ1Y3QudHlwZSAhPT0gJ3R5cGUnICYmXG4gICAgICAgICAgICBpc09iamVjdChzdHJ1Y3Quc2NoZW1hKSAmJlxuICAgICAgICAgICAgaXNPYmplY3QodmFsdWUpICYmXG4gICAgICAgICAgICAhQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgICAgIGZvciAoY29uc3Qga2V5IGluIHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgaWYgKHN0cnVjdC5zY2hlbWFba2V5XSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSB2YWx1ZVtrZXldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBsZXQgc3RhdHVzID0gJ3ZhbGlkJztcbiAgICBmb3IgKGNvbnN0IGZhaWx1cmUgb2Ygc3RydWN0LnZhbGlkYXRvcih2YWx1ZSwgY3R4KSkge1xuICAgICAgICBmYWlsdXJlLmV4cGxhbmF0aW9uID0gb3B0aW9ucy5tZXNzYWdlO1xuICAgICAgICBzdGF0dXMgPSAnbm90X3ZhbGlkJztcbiAgICAgICAgeWllbGQgW2ZhaWx1cmUsIHVuZGVmaW5lZF07XG4gICAgfVxuICAgIGZvciAobGV0IFtrLCB2LCBzXSBvZiBzdHJ1Y3QuZW50cmllcyh2YWx1ZSwgY3R4KSkge1xuICAgICAgICBjb25zdCB0cyA9IHJ1bih2LCBzLCB7XG4gICAgICAgICAgICBwYXRoOiBrID09PSB1bmRlZmluZWQgPyBwYXRoIDogWy4uLnBhdGgsIGtdLFxuICAgICAgICAgICAgYnJhbmNoOiBrID09PSB1bmRlZmluZWQgPyBicmFuY2ggOiBbLi4uYnJhbmNoLCB2XSxcbiAgICAgICAgICAgIGNvZXJjZSxcbiAgICAgICAgICAgIG1hc2ssXG4gICAgICAgICAgICBtZXNzYWdlOiBvcHRpb25zLm1lc3NhZ2UsXG4gICAgICAgIH0pO1xuICAgICAgICBmb3IgKGNvbnN0IHQgb2YgdHMpIHtcbiAgICAgICAgICAgIGlmICh0WzBdKSB7XG4gICAgICAgICAgICAgICAgc3RhdHVzID0gdFswXS5yZWZpbmVtZW50ICE9IG51bGwgPyAnbm90X3JlZmluZWQnIDogJ25vdF92YWxpZCc7XG4gICAgICAgICAgICAgICAgeWllbGQgW3RbMF0sIHVuZGVmaW5lZF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjb2VyY2UpIHtcbiAgICAgICAgICAgICAgICB2ID0gdFsxXTtcbiAgICAgICAgICAgICAgICBpZiAoayA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gdjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAodmFsdWUgaW5zdGFuY2VvZiBNYXApIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUuc2V0KGssIHYpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICh2YWx1ZSBpbnN0YW5jZW9mIFNldCkge1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZS5hZGQodik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGlzT2JqZWN0KHZhbHVlKSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAodiAhPT0gdW5kZWZpbmVkIHx8IGsgaW4gdmFsdWUpXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZVtrXSA9IHY7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChzdGF0dXMgIT09ICdub3RfdmFsaWQnKSB7XG4gICAgICAgIGZvciAoY29uc3QgZmFpbHVyZSBvZiBzdHJ1Y3QucmVmaW5lcih2YWx1ZSwgY3R4KSkge1xuICAgICAgICAgICAgZmFpbHVyZS5leHBsYW5hdGlvbiA9IG9wdGlvbnMubWVzc2FnZTtcbiAgICAgICAgICAgIHN0YXR1cyA9ICdub3RfcmVmaW5lZCc7XG4gICAgICAgICAgICB5aWVsZCBbZmFpbHVyZSwgdW5kZWZpbmVkXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoc3RhdHVzID09PSAndmFsaWQnKSB7XG4gICAgICAgIHlpZWxkIFt1bmRlZmluZWQsIHZhbHVlXTtcbiAgICB9XG59XG5cbi8qKlxuICogYFN0cnVjdGAgb2JqZWN0cyBlbmNhcHN1bGF0ZSB0aGUgdmFsaWRhdGlvbiBsb2dpYyBmb3IgYSBzcGVjaWZpYyB0eXBlIG9mXG4gKiB2YWx1ZXMuIE9uY2UgY29uc3RydWN0ZWQsIHlvdSB1c2UgdGhlIGBhc3NlcnRgLCBgaXNgIG9yIGB2YWxpZGF0ZWAgaGVscGVycyB0b1xuICogdmFsaWRhdGUgdW5rbm93biBpbnB1dCBkYXRhIGFnYWluc3QgdGhlIHN0cnVjdC5cbiAqL1xuY2xhc3MgU3RydWN0IHtcbiAgICBjb25zdHJ1Y3Rvcihwcm9wcykge1xuICAgICAgICBjb25zdCB7IHR5cGUsIHNjaGVtYSwgdmFsaWRhdG9yLCByZWZpbmVyLCBjb2VyY2VyID0gKHZhbHVlKSA9PiB2YWx1ZSwgZW50cmllcyA9IGZ1bmN0aW9uKiAoKSB7IH0sIH0gPSBwcm9wcztcbiAgICAgICAgdGhpcy50eXBlID0gdHlwZTtcbiAgICAgICAgdGhpcy5zY2hlbWEgPSBzY2hlbWE7XG4gICAgICAgIHRoaXMuZW50cmllcyA9IGVudHJpZXM7XG4gICAgICAgIHRoaXMuY29lcmNlciA9IGNvZXJjZXI7XG4gICAgICAgIGlmICh2YWxpZGF0b3IpIHtcbiAgICAgICAgICAgIHRoaXMudmFsaWRhdG9yID0gKHZhbHVlLCBjb250ZXh0KSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gdmFsaWRhdG9yKHZhbHVlLCBjb250ZXh0KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdG9GYWlsdXJlcyhyZXN1bHQsIGNvbnRleHQsIHRoaXMsIHZhbHVlKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnZhbGlkYXRvciA9ICgpID0+IFtdO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyZWZpbmVyKSB7XG4gICAgICAgICAgICB0aGlzLnJlZmluZXIgPSAodmFsdWUsIGNvbnRleHQpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCByZXN1bHQgPSByZWZpbmVyKHZhbHVlLCBjb250ZXh0KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdG9GYWlsdXJlcyhyZXN1bHQsIGNvbnRleHQsIHRoaXMsIHZhbHVlKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnJlZmluZXIgPSAoKSA9PiBbXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBBc3NlcnQgdGhhdCBhIHZhbHVlIHBhc3NlcyB0aGUgc3RydWN0J3MgdmFsaWRhdGlvbiwgdGhyb3dpbmcgaWYgaXQgZG9lc24ndC5cbiAgICAgKi9cbiAgICBhc3NlcnQodmFsdWUsIG1lc3NhZ2UpIHtcbiAgICAgICAgcmV0dXJuIGFzc2VydCh2YWx1ZSwgdGhpcywgbWVzc2FnZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhIHZhbHVlIHdpdGggdGhlIHN0cnVjdCdzIGNvZXJjaW9uIGxvZ2ljLCB0aGVuIHZhbGlkYXRlIGl0LlxuICAgICAqL1xuICAgIGNyZWF0ZSh2YWx1ZSwgbWVzc2FnZSkge1xuICAgICAgICByZXR1cm4gY3JlYXRlKHZhbHVlLCB0aGlzLCBtZXNzYWdlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2hlY2sgaWYgYSB2YWx1ZSBwYXNzZXMgdGhlIHN0cnVjdCdzIHZhbGlkYXRpb24uXG4gICAgICovXG4gICAgaXModmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIGlzKHZhbHVlLCB0aGlzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTWFzayBhIHZhbHVlLCBjb2VyY2luZyBhbmQgdmFsaWRhdGluZyBpdCwgYnV0IHJldHVybmluZyBvbmx5IHRoZSBzdWJzZXQgb2ZcbiAgICAgKiBwcm9wZXJ0aWVzIGRlZmluZWQgYnkgdGhlIHN0cnVjdCdzIHNjaGVtYS5cbiAgICAgKi9cbiAgICBtYXNrKHZhbHVlLCBtZXNzYWdlKSB7XG4gICAgICAgIHJldHVybiBtYXNrKHZhbHVlLCB0aGlzLCBtZXNzYWdlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVmFsaWRhdGUgYSB2YWx1ZSB3aXRoIHRoZSBzdHJ1Y3QncyB2YWxpZGF0aW9uIGxvZ2ljLCByZXR1cm5pbmcgYSB0dXBsZVxuICAgICAqIHJlcHJlc2VudGluZyB0aGUgcmVzdWx0LlxuICAgICAqXG4gICAgICogWW91IG1heSBvcHRpb25hbGx5IHBhc3MgYHRydWVgIGZvciB0aGUgYHdpdGhDb2VyY2lvbmAgYXJndW1lbnQgdG8gY29lcmNlXG4gICAgICogdGhlIHZhbHVlIGJlZm9yZSBhdHRlbXB0aW5nIHRvIHZhbGlkYXRlIGl0LiBJZiB5b3UgZG8sIHRoZSByZXN1bHQgd2lsbFxuICAgICAqIGNvbnRhaW4gdGhlIGNvZXJjZWQgcmVzdWx0IHdoZW4gc3VjY2Vzc2Z1bC5cbiAgICAgKi9cbiAgICB2YWxpZGF0ZSh2YWx1ZSwgb3B0aW9ucyA9IHt9KSB7XG4gICAgICAgIHJldHVybiB2YWxpZGF0ZSh2YWx1ZSwgdGhpcywgb3B0aW9ucyk7XG4gICAgfVxufVxuLyoqXG4gKiBBc3NlcnQgdGhhdCBhIHZhbHVlIHBhc3NlcyBhIHN0cnVjdCwgdGhyb3dpbmcgaWYgaXQgZG9lc24ndC5cbiAqL1xuZnVuY3Rpb24gYXNzZXJ0KHZhbHVlLCBzdHJ1Y3QsIG1lc3NhZ2UpIHtcbiAgICBjb25zdCByZXN1bHQgPSB2YWxpZGF0ZSh2YWx1ZSwgc3RydWN0LCB7IG1lc3NhZ2UgfSk7XG4gICAgaWYgKHJlc3VsdFswXSkge1xuICAgICAgICB0aHJvdyByZXN1bHRbMF07XG4gICAgfVxufVxuLyoqXG4gKiBDcmVhdGUgYSB2YWx1ZSB3aXRoIHRoZSBjb2VyY2lvbiBsb2dpYyBvZiBzdHJ1Y3QgYW5kIHZhbGlkYXRlIGl0LlxuICovXG5mdW5jdGlvbiBjcmVhdGUodmFsdWUsIHN0cnVjdCwgbWVzc2FnZSkge1xuICAgIGNvbnN0IHJlc3VsdCA9IHZhbGlkYXRlKHZhbHVlLCBzdHJ1Y3QsIHsgY29lcmNlOiB0cnVlLCBtZXNzYWdlIH0pO1xuICAgIGlmIChyZXN1bHRbMF0pIHtcbiAgICAgICAgdGhyb3cgcmVzdWx0WzBdO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHJlc3VsdFsxXTtcbiAgICB9XG59XG4vKipcbiAqIE1hc2sgYSB2YWx1ZSwgcmV0dXJuaW5nIG9ubHkgdGhlIHN1YnNldCBvZiBwcm9wZXJ0aWVzIGRlZmluZWQgYnkgYSBzdHJ1Y3QuXG4gKi9cbmZ1bmN0aW9uIG1hc2sodmFsdWUsIHN0cnVjdCwgbWVzc2FnZSkge1xuICAgIGNvbnN0IHJlc3VsdCA9IHZhbGlkYXRlKHZhbHVlLCBzdHJ1Y3QsIHsgY29lcmNlOiB0cnVlLCBtYXNrOiB0cnVlLCBtZXNzYWdlIH0pO1xuICAgIGlmIChyZXN1bHRbMF0pIHtcbiAgICAgICAgdGhyb3cgcmVzdWx0WzBdO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHJlc3VsdFsxXTtcbiAgICB9XG59XG4vKipcbiAqIENoZWNrIGlmIGEgdmFsdWUgcGFzc2VzIGEgc3RydWN0LlxuICovXG5mdW5jdGlvbiBpcyh2YWx1ZSwgc3RydWN0KSB7XG4gICAgY29uc3QgcmVzdWx0ID0gdmFsaWRhdGUodmFsdWUsIHN0cnVjdCk7XG4gICAgcmV0dXJuICFyZXN1bHRbMF07XG59XG4vKipcbiAqIFZhbGlkYXRlIGEgdmFsdWUgYWdhaW5zdCBhIHN0cnVjdCwgcmV0dXJuaW5nIGFuIGVycm9yIGlmIGludmFsaWQsIG9yIHRoZVxuICogdmFsdWUgKHdpdGggcG90ZW50aWFsIGNvZXJjaW9uKSBpZiB2YWxpZC5cbiAqL1xuZnVuY3Rpb24gdmFsaWRhdGUodmFsdWUsIHN0cnVjdCwgb3B0aW9ucyA9IHt9KSB7XG4gICAgY29uc3QgdHVwbGVzID0gcnVuKHZhbHVlLCBzdHJ1Y3QsIG9wdGlvbnMpO1xuICAgIGNvbnN0IHR1cGxlID0gc2hpZnRJdGVyYXRvcih0dXBsZXMpO1xuICAgIGlmICh0dXBsZVswXSkge1xuICAgICAgICBjb25zdCBlcnJvciA9IG5ldyBTdHJ1Y3RFcnJvcih0dXBsZVswXSwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgdCBvZiB0dXBsZXMpIHtcbiAgICAgICAgICAgICAgICBpZiAodFswXSkge1xuICAgICAgICAgICAgICAgICAgICB5aWVsZCB0WzBdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBbZXJyb3IsIHVuZGVmaW5lZF07XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBjb25zdCB2ID0gdHVwbGVbMV07XG4gICAgICAgIHJldHVybiBbdW5kZWZpbmVkLCB2XTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGFzc2lnbiguLi5TdHJ1Y3RzKSB7XG4gICAgY29uc3QgaXNUeXBlID0gU3RydWN0c1swXS50eXBlID09PSAndHlwZSc7XG4gICAgY29uc3Qgc2NoZW1hcyA9IFN0cnVjdHMubWFwKChzKSA9PiBzLnNjaGVtYSk7XG4gICAgY29uc3Qgc2NoZW1hID0gT2JqZWN0LmFzc2lnbih7fSwgLi4uc2NoZW1hcyk7XG4gICAgcmV0dXJuIGlzVHlwZSA/IHR5cGUoc2NoZW1hKSA6IG9iamVjdChzY2hlbWEpO1xufVxuLyoqXG4gKiBEZWZpbmUgYSBuZXcgc3RydWN0IHR5cGUgd2l0aCBhIGN1c3RvbSB2YWxpZGF0aW9uIGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBkZWZpbmUobmFtZSwgdmFsaWRhdG9yKSB7XG4gICAgcmV0dXJuIG5ldyBTdHJ1Y3QoeyB0eXBlOiBuYW1lLCBzY2hlbWE6IG51bGwsIHZhbGlkYXRvciB9KTtcbn1cbi8qKlxuICogQ3JlYXRlIGEgbmV3IHN0cnVjdCBiYXNlZCBvbiBhbiBleGlzdGluZyBzdHJ1Y3QsIGJ1dCB0aGUgdmFsdWUgaXMgYWxsb3dlZCB0b1xuICogYmUgYHVuZGVmaW5lZGAuIGBsb2dgIHdpbGwgYmUgY2FsbGVkIGlmIHRoZSB2YWx1ZSBpcyBub3QgYHVuZGVmaW5lZGAuXG4gKi9cbmZ1bmN0aW9uIGRlcHJlY2F0ZWQoc3RydWN0LCBsb2cpIHtcbiAgICByZXR1cm4gbmV3IFN0cnVjdCh7XG4gICAgICAgIC4uLnN0cnVjdCxcbiAgICAgICAgcmVmaW5lcjogKHZhbHVlLCBjdHgpID0+IHZhbHVlID09PSB1bmRlZmluZWQgfHwgc3RydWN0LnJlZmluZXIodmFsdWUsIGN0eCksXG4gICAgICAgIHZhbGlkYXRvcih2YWx1ZSwgY3R4KSB7XG4gICAgICAgICAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbG9nKHZhbHVlLCBjdHgpO1xuICAgICAgICAgICAgICAgIHJldHVybiBzdHJ1Y3QudmFsaWRhdG9yKHZhbHVlLCBjdHgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgIH0pO1xufVxuLyoqXG4gKiBDcmVhdGUgYSBzdHJ1Y3Qgd2l0aCBkeW5hbWljIHZhbGlkYXRpb24gbG9naWMuXG4gKlxuICogVGhlIGNhbGxiYWNrIHdpbGwgcmVjZWl2ZSB0aGUgdmFsdWUgY3VycmVudGx5IGJlaW5nIHZhbGlkYXRlZCwgYW5kIG11c3RcbiAqIHJldHVybiBhIHN0cnVjdCBvYmplY3QgdG8gdmFsaWRhdGUgaXQgd2l0aC4gVGhpcyBjYW4gYmUgdXNlZnVsIHRvIG1vZGVsXG4gKiB2YWxpZGF0aW9uIGxvZ2ljIHRoYXQgY2hhbmdlcyBiYXNlZCBvbiBpdHMgaW5wdXQuXG4gKi9cbmZ1bmN0aW9uIGR5bmFtaWMoZm4pIHtcbiAgICByZXR1cm4gbmV3IFN0cnVjdCh7XG4gICAgICAgIHR5cGU6ICdkeW5hbWljJyxcbiAgICAgICAgc2NoZW1hOiBudWxsLFxuICAgICAgICAqZW50cmllcyh2YWx1ZSwgY3R4KSB7XG4gICAgICAgICAgICBjb25zdCBzdHJ1Y3QgPSBmbih2YWx1ZSwgY3R4KTtcbiAgICAgICAgICAgIHlpZWxkKiBzdHJ1Y3QuZW50cmllcyh2YWx1ZSwgY3R4KTtcbiAgICAgICAgfSxcbiAgICAgICAgdmFsaWRhdG9yKHZhbHVlLCBjdHgpIHtcbiAgICAgICAgICAgIGNvbnN0IHN0cnVjdCA9IGZuKHZhbHVlLCBjdHgpO1xuICAgICAgICAgICAgcmV0dXJuIHN0cnVjdC52YWxpZGF0b3IodmFsdWUsIGN0eCk7XG4gICAgICAgIH0sXG4gICAgICAgIGNvZXJjZXIodmFsdWUsIGN0eCkge1xuICAgICAgICAgICAgY29uc3Qgc3RydWN0ID0gZm4odmFsdWUsIGN0eCk7XG4gICAgICAgICAgICByZXR1cm4gc3RydWN0LmNvZXJjZXIodmFsdWUsIGN0eCk7XG4gICAgICAgIH0sXG4gICAgICAgIHJlZmluZXIodmFsdWUsIGN0eCkge1xuICAgICAgICAgICAgY29uc3Qgc3RydWN0ID0gZm4odmFsdWUsIGN0eCk7XG4gICAgICAgICAgICByZXR1cm4gc3RydWN0LnJlZmluZXIodmFsdWUsIGN0eCk7XG4gICAgICAgIH0sXG4gICAgfSk7XG59XG4vKipcbiAqIENyZWF0ZSBhIHN0cnVjdCB3aXRoIGxhemlseSBldmFsdWF0ZWQgdmFsaWRhdGlvbiBsb2dpYy5cbiAqXG4gKiBUaGUgZmlyc3QgdGltZSB2YWxpZGF0aW9uIGlzIHJ1biB3aXRoIHRoZSBzdHJ1Y3QsIHRoZSBjYWxsYmFjayB3aWxsIGJlIGNhbGxlZFxuICogYW5kIG11c3QgcmV0dXJuIGEgc3RydWN0IG9iamVjdCB0byB1c2UuIFRoaXMgaXMgdXNlZnVsIGZvciBjYXNlcyB3aGVyZSB5b3VcbiAqIHdhbnQgdG8gaGF2ZSBzZWxmLXJlZmVyZW50aWFsIHN0cnVjdHMgZm9yIG5lc3RlZCBkYXRhIHN0cnVjdHVyZXMgdG8gYXZvaWQgYVxuICogY2lyY3VsYXIgZGVmaW5pdGlvbiBwcm9ibGVtLlxuICovXG5mdW5jdGlvbiBsYXp5KGZuKSB7XG4gICAgbGV0IHN0cnVjdDtcbiAgICByZXR1cm4gbmV3IFN0cnVjdCh7XG4gICAgICAgIHR5cGU6ICdsYXp5JyxcbiAgICAgICAgc2NoZW1hOiBudWxsLFxuICAgICAgICAqZW50cmllcyh2YWx1ZSwgY3R4KSB7XG4gICAgICAgICAgICBzdHJ1Y3QgPz8gKHN0cnVjdCA9IGZuKCkpO1xuICAgICAgICAgICAgeWllbGQqIHN0cnVjdC5lbnRyaWVzKHZhbHVlLCBjdHgpO1xuICAgICAgICB9LFxuICAgICAgICB2YWxpZGF0b3IodmFsdWUsIGN0eCkge1xuICAgICAgICAgICAgc3RydWN0ID8/IChzdHJ1Y3QgPSBmbigpKTtcbiAgICAgICAgICAgIHJldHVybiBzdHJ1Y3QudmFsaWRhdG9yKHZhbHVlLCBjdHgpO1xuICAgICAgICB9LFxuICAgICAgICBjb2VyY2VyKHZhbHVlLCBjdHgpIHtcbiAgICAgICAgICAgIHN0cnVjdCA/PyAoc3RydWN0ID0gZm4oKSk7XG4gICAgICAgICAgICByZXR1cm4gc3RydWN0LmNvZXJjZXIodmFsdWUsIGN0eCk7XG4gICAgICAgIH0sXG4gICAgICAgIHJlZmluZXIodmFsdWUsIGN0eCkge1xuICAgICAgICAgICAgc3RydWN0ID8/IChzdHJ1Y3QgPSBmbigpKTtcbiAgICAgICAgICAgIHJldHVybiBzdHJ1Y3QucmVmaW5lcih2YWx1ZSwgY3R4KTtcbiAgICAgICAgfSxcbiAgICB9KTtcbn1cbi8qKlxuICogQ3JlYXRlIGEgbmV3IHN0cnVjdCBiYXNlZCBvbiBhbiBleGlzdGluZyBvYmplY3Qgc3RydWN0LCBidXQgZXhjbHVkaW5nXG4gKiBzcGVjaWZpYyBwcm9wZXJ0aWVzLlxuICpcbiAqIExpa2UgVHlwZVNjcmlwdCdzIGBPbWl0YCB1dGlsaXR5LlxuICovXG5mdW5jdGlvbiBvbWl0KHN0cnVjdCwga2V5cykge1xuICAgIGNvbnN0IHsgc2NoZW1hIH0gPSBzdHJ1Y3Q7XG4gICAgY29uc3Qgc3Vic2NoZW1hID0geyAuLi5zY2hlbWEgfTtcbiAgICBmb3IgKGNvbnN0IGtleSBvZiBrZXlzKSB7XG4gICAgICAgIGRlbGV0ZSBzdWJzY2hlbWFba2V5XTtcbiAgICB9XG4gICAgc3dpdGNoIChzdHJ1Y3QudHlwZSkge1xuICAgICAgICBjYXNlICd0eXBlJzpcbiAgICAgICAgICAgIHJldHVybiB0eXBlKHN1YnNjaGVtYSk7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZXR1cm4gb2JqZWN0KHN1YnNjaGVtYSk7XG4gICAgfVxufVxuLyoqXG4gKiBDcmVhdGUgYSBuZXcgc3RydWN0IGJhc2VkIG9uIGFuIGV4aXN0aW5nIG9iamVjdCBzdHJ1Y3QsIGJ1dCB3aXRoIGFsbCBvZiBpdHNcbiAqIHByb3BlcnRpZXMgYWxsb3dlZCB0byBiZSBgdW5kZWZpbmVkYC5cbiAqXG4gKiBMaWtlIFR5cGVTY3JpcHQncyBgUGFydGlhbGAgdXRpbGl0eS5cbiAqL1xuZnVuY3Rpb24gcGFydGlhbChzdHJ1Y3QpIHtcbiAgICBjb25zdCBpc1N0cnVjdCA9IHN0cnVjdCBpbnN0YW5jZW9mIFN0cnVjdDtcbiAgICBjb25zdCBzY2hlbWEgPSBpc1N0cnVjdCA/IHsgLi4uc3RydWN0LnNjaGVtYSB9IDogeyAuLi5zdHJ1Y3QgfTtcbiAgICBmb3IgKGNvbnN0IGtleSBpbiBzY2hlbWEpIHtcbiAgICAgICAgc2NoZW1hW2tleV0gPSBvcHRpb25hbChzY2hlbWFba2V5XSk7XG4gICAgfVxuICAgIGlmIChpc1N0cnVjdCAmJiBzdHJ1Y3QudHlwZSA9PT0gJ3R5cGUnKSB7XG4gICAgICAgIHJldHVybiB0eXBlKHNjaGVtYSk7XG4gICAgfVxuICAgIHJldHVybiBvYmplY3Qoc2NoZW1hKTtcbn1cbi8qKlxuICogQ3JlYXRlIGEgbmV3IHN0cnVjdCBiYXNlZCBvbiBhbiBleGlzdGluZyBvYmplY3Qgc3RydWN0LCBidXQgb25seSBpbmNsdWRpbmdcbiAqIHNwZWNpZmljIHByb3BlcnRpZXMuXG4gKlxuICogTGlrZSBUeXBlU2NyaXB0J3MgYFBpY2tgIHV0aWxpdHkuXG4gKi9cbmZ1bmN0aW9uIHBpY2soc3RydWN0LCBrZXlzKSB7XG4gICAgY29uc3QgeyBzY2hlbWEgfSA9IHN0cnVjdDtcbiAgICBjb25zdCBzdWJzY2hlbWEgPSB7fTtcbiAgICBmb3IgKGNvbnN0IGtleSBvZiBrZXlzKSB7XG4gICAgICAgIHN1YnNjaGVtYVtrZXldID0gc2NoZW1hW2tleV07XG4gICAgfVxuICAgIHN3aXRjaCAoc3RydWN0LnR5cGUpIHtcbiAgICAgICAgY2FzZSAndHlwZSc6XG4gICAgICAgICAgICByZXR1cm4gdHlwZShzdWJzY2hlbWEpO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgcmV0dXJuIG9iamVjdChzdWJzY2hlbWEpO1xuICAgIH1cbn1cbi8qKlxuICogRGVmaW5lIGEgbmV3IHN0cnVjdCB0eXBlIHdpdGggYSBjdXN0b20gdmFsaWRhdGlvbiBmdW5jdGlvbi5cbiAqXG4gKiBAZGVwcmVjYXRlZCBUaGlzIGZ1bmN0aW9uIGhhcyBiZWVuIHJlbmFtZWQgdG8gYGRlZmluZWAuXG4gKi9cbmZ1bmN0aW9uIHN0cnVjdChuYW1lLCB2YWxpZGF0b3IpIHtcbiAgICBjb25zb2xlLndhcm4oJ3N1cGVyc3RydWN0QDAuMTEgLSBUaGUgYHN0cnVjdGAgaGVscGVyIGhhcyBiZWVuIHJlbmFtZWQgdG8gYGRlZmluZWAuJyk7XG4gICAgcmV0dXJuIGRlZmluZShuYW1lLCB2YWxpZGF0b3IpO1xufVxuXG4vKipcbiAqIEVuc3VyZSB0aGF0IGFueSB2YWx1ZSBwYXNzZXMgdmFsaWRhdGlvbi5cbiAqL1xuZnVuY3Rpb24gYW55KCkge1xuICAgIHJldHVybiBkZWZpbmUoJ2FueScsICgpID0+IHRydWUpO1xufVxuZnVuY3Rpb24gYXJyYXkoRWxlbWVudCkge1xuICAgIHJldHVybiBuZXcgU3RydWN0KHtcbiAgICAgICAgdHlwZTogJ2FycmF5JyxcbiAgICAgICAgc2NoZW1hOiBFbGVtZW50LFxuICAgICAgICAqZW50cmllcyh2YWx1ZSkge1xuICAgICAgICAgICAgaWYgKEVsZW1lbnQgJiYgQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IFtpLCB2XSBvZiB2YWx1ZS5lbnRyaWVzKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgeWllbGQgW2ksIHYsIEVsZW1lbnRdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgY29lcmNlcih2YWx1ZSkge1xuICAgICAgICAgICAgcmV0dXJuIEFycmF5LmlzQXJyYXkodmFsdWUpID8gdmFsdWUuc2xpY2UoKSA6IHZhbHVlO1xuICAgICAgICB9LFxuICAgICAgICB2YWxpZGF0b3IodmFsdWUpIHtcbiAgICAgICAgICAgIHJldHVybiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkgfHxcbiAgICAgICAgICAgICAgICBgRXhwZWN0ZWQgYW4gYXJyYXkgdmFsdWUsIGJ1dCByZWNlaXZlZDogJHtwcmludCh2YWx1ZSl9YCk7XG4gICAgICAgIH0sXG4gICAgfSk7XG59XG4vKipcbiAqIEVuc3VyZSB0aGF0IGEgdmFsdWUgaXMgYSBiaWdpbnQuXG4gKi9cbmZ1bmN0aW9uIGJpZ2ludCgpIHtcbiAgICByZXR1cm4gZGVmaW5lKCdiaWdpbnQnLCAodmFsdWUpID0+IHtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ2JpZ2ludCc7XG4gICAgfSk7XG59XG4vKipcbiAqIEVuc3VyZSB0aGF0IGEgdmFsdWUgaXMgYSBib29sZWFuLlxuICovXG5mdW5jdGlvbiBib29sZWFuKCkge1xuICAgIHJldHVybiBkZWZpbmUoJ2Jvb2xlYW4nLCAodmFsdWUpID0+IHtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ2Jvb2xlYW4nO1xuICAgIH0pO1xufVxuLyoqXG4gKiBFbnN1cmUgdGhhdCBhIHZhbHVlIGlzIGEgdmFsaWQgYERhdGVgLlxuICpcbiAqIE5vdGU6IHRoaXMgYWxzbyBlbnN1cmVzIHRoYXQgdGhlIHZhbHVlIGlzICpub3QqIGFuIGludmFsaWQgYERhdGVgIG9iamVjdCxcbiAqIHdoaWNoIGNhbiBvY2N1ciB3aGVuIHBhcnNpbmcgYSBkYXRlIGZhaWxzIGJ1dCBzdGlsbCByZXR1cm5zIGEgYERhdGVgLlxuICovXG5mdW5jdGlvbiBkYXRlKCkge1xuICAgIHJldHVybiBkZWZpbmUoJ2RhdGUnLCAodmFsdWUpID0+IHtcbiAgICAgICAgcmV0dXJuICgodmFsdWUgaW5zdGFuY2VvZiBEYXRlICYmICFpc05hTih2YWx1ZS5nZXRUaW1lKCkpKSB8fFxuICAgICAgICAgICAgYEV4cGVjdGVkIGEgdmFsaWQgXFxgRGF0ZVxcYCBvYmplY3QsIGJ1dCByZWNlaXZlZDogJHtwcmludCh2YWx1ZSl9YCk7XG4gICAgfSk7XG59XG5mdW5jdGlvbiBlbnVtcyh2YWx1ZXMpIHtcbiAgICBjb25zdCBzY2hlbWEgPSB7fTtcbiAgICBjb25zdCBkZXNjcmlwdGlvbiA9IHZhbHVlcy5tYXAoKHYpID0+IHByaW50KHYpKS5qb2luKCk7XG4gICAgZm9yIChjb25zdCBrZXkgb2YgdmFsdWVzKSB7XG4gICAgICAgIHNjaGVtYVtrZXldID0ga2V5O1xuICAgIH1cbiAgICByZXR1cm4gbmV3IFN0cnVjdCh7XG4gICAgICAgIHR5cGU6ICdlbnVtcycsXG4gICAgICAgIHNjaGVtYSxcbiAgICAgICAgdmFsaWRhdG9yKHZhbHVlKSB7XG4gICAgICAgICAgICByZXR1cm4gKHZhbHVlcy5pbmNsdWRlcyh2YWx1ZSkgfHxcbiAgICAgICAgICAgICAgICBgRXhwZWN0ZWQgb25lIG9mIFxcYCR7ZGVzY3JpcHRpb259XFxgLCBidXQgcmVjZWl2ZWQ6ICR7cHJpbnQodmFsdWUpfWApO1xuICAgICAgICB9LFxuICAgIH0pO1xufVxuLyoqXG4gKiBFbnN1cmUgdGhhdCBhIHZhbHVlIGlzIGEgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIGZ1bmMoKSB7XG4gICAgcmV0dXJuIGRlZmluZSgnZnVuYycsICh2YWx1ZSkgPT4ge1xuICAgICAgICByZXR1cm4gKHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJyB8fFxuICAgICAgICAgICAgYEV4cGVjdGVkIGEgZnVuY3Rpb24sIGJ1dCByZWNlaXZlZDogJHtwcmludCh2YWx1ZSl9YCk7XG4gICAgfSk7XG59XG4vKipcbiAqIEVuc3VyZSB0aGF0IGEgdmFsdWUgaXMgYW4gaW5zdGFuY2Ugb2YgYSBzcGVjaWZpYyBjbGFzcy5cbiAqL1xuZnVuY3Rpb24gaW5zdGFuY2UoQ2xhc3MpIHtcbiAgICByZXR1cm4gZGVmaW5lKCdpbnN0YW5jZScsICh2YWx1ZSkgPT4ge1xuICAgICAgICByZXR1cm4gKHZhbHVlIGluc3RhbmNlb2YgQ2xhc3MgfHxcbiAgICAgICAgICAgIGBFeHBlY3RlZCBhIFxcYCR7Q2xhc3MubmFtZX1cXGAgaW5zdGFuY2UsIGJ1dCByZWNlaXZlZDogJHtwcmludCh2YWx1ZSl9YCk7XG4gICAgfSk7XG59XG4vKipcbiAqIEVuc3VyZSB0aGF0IGEgdmFsdWUgaXMgYW4gaW50ZWdlci5cbiAqL1xuZnVuY3Rpb24gaW50ZWdlcigpIHtcbiAgICByZXR1cm4gZGVmaW5lKCdpbnRlZ2VyJywgKHZhbHVlKSA9PiB7XG4gICAgICAgIHJldHVybiAoKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicgJiYgIWlzTmFOKHZhbHVlKSAmJiBOdW1iZXIuaXNJbnRlZ2VyKHZhbHVlKSkgfHxcbiAgICAgICAgICAgIGBFeHBlY3RlZCBhbiBpbnRlZ2VyLCBidXQgcmVjZWl2ZWQ6ICR7cHJpbnQodmFsdWUpfWApO1xuICAgIH0pO1xufVxuLyoqXG4gKiBFbnN1cmUgdGhhdCBhIHZhbHVlIG1hdGNoZXMgYWxsIG9mIGEgc2V0IG9mIHR5cGVzLlxuICovXG5mdW5jdGlvbiBpbnRlcnNlY3Rpb24oU3RydWN0cykge1xuICAgIHJldHVybiBuZXcgU3RydWN0KHtcbiAgICAgICAgdHlwZTogJ2ludGVyc2VjdGlvbicsXG4gICAgICAgIHNjaGVtYTogbnVsbCxcbiAgICAgICAgKmVudHJpZXModmFsdWUsIGN0eCkge1xuICAgICAgICAgICAgZm9yIChjb25zdCBTIG9mIFN0cnVjdHMpIHtcbiAgICAgICAgICAgICAgICB5aWVsZCogUy5lbnRyaWVzKHZhbHVlLCBjdHgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICAqdmFsaWRhdG9yKHZhbHVlLCBjdHgpIHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgUyBvZiBTdHJ1Y3RzKSB7XG4gICAgICAgICAgICAgICAgeWllbGQqIFMudmFsaWRhdG9yKHZhbHVlLCBjdHgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICAqcmVmaW5lcih2YWx1ZSwgY3R4KSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IFMgb2YgU3RydWN0cykge1xuICAgICAgICAgICAgICAgIHlpZWxkKiBTLnJlZmluZXIodmFsdWUsIGN0eCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgfSk7XG59XG5mdW5jdGlvbiBsaXRlcmFsKGNvbnN0YW50KSB7XG4gICAgY29uc3QgZGVzY3JpcHRpb24gPSBwcmludChjb25zdGFudCk7XG4gICAgY29uc3QgdCA9IHR5cGVvZiBjb25zdGFudDtcbiAgICByZXR1cm4gbmV3IFN0cnVjdCh7XG4gICAgICAgIHR5cGU6ICdsaXRlcmFsJyxcbiAgICAgICAgc2NoZW1hOiB0ID09PSAnc3RyaW5nJyB8fCB0ID09PSAnbnVtYmVyJyB8fCB0ID09PSAnYm9vbGVhbicgPyBjb25zdGFudCA6IG51bGwsXG4gICAgICAgIHZhbGlkYXRvcih2YWx1ZSkge1xuICAgICAgICAgICAgcmV0dXJuICh2YWx1ZSA9PT0gY29uc3RhbnQgfHxcbiAgICAgICAgICAgICAgICBgRXhwZWN0ZWQgdGhlIGxpdGVyYWwgXFxgJHtkZXNjcmlwdGlvbn1cXGAsIGJ1dCByZWNlaXZlZDogJHtwcmludCh2YWx1ZSl9YCk7XG4gICAgICAgIH0sXG4gICAgfSk7XG59XG5mdW5jdGlvbiBtYXAoS2V5LCBWYWx1ZSkge1xuICAgIHJldHVybiBuZXcgU3RydWN0KHtcbiAgICAgICAgdHlwZTogJ21hcCcsXG4gICAgICAgIHNjaGVtYTogbnVsbCxcbiAgICAgICAgKmVudHJpZXModmFsdWUpIHtcbiAgICAgICAgICAgIGlmIChLZXkgJiYgVmFsdWUgJiYgdmFsdWUgaW5zdGFuY2VvZiBNYXApIHtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IFtrLCB2XSBvZiB2YWx1ZS5lbnRyaWVzKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgeWllbGQgW2ssIGssIEtleV07XG4gICAgICAgICAgICAgICAgICAgIHlpZWxkIFtrLCB2LCBWYWx1ZV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBjb2VyY2VyKHZhbHVlKSB7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBNYXAgPyBuZXcgTWFwKHZhbHVlKSA6IHZhbHVlO1xuICAgICAgICB9LFxuICAgICAgICB2YWxpZGF0b3IodmFsdWUpIHtcbiAgICAgICAgICAgIHJldHVybiAodmFsdWUgaW5zdGFuY2VvZiBNYXAgfHxcbiAgICAgICAgICAgICAgICBgRXhwZWN0ZWQgYSBcXGBNYXBcXGAgb2JqZWN0LCBidXQgcmVjZWl2ZWQ6ICR7cHJpbnQodmFsdWUpfWApO1xuICAgICAgICB9LFxuICAgIH0pO1xufVxuLyoqXG4gKiBFbnN1cmUgdGhhdCBubyB2YWx1ZSBldmVyIHBhc3NlcyB2YWxpZGF0aW9uLlxuICovXG5mdW5jdGlvbiBuZXZlcigpIHtcbiAgICByZXR1cm4gZGVmaW5lKCduZXZlcicsICgpID0+IGZhbHNlKTtcbn1cbi8qKlxuICogQXVnbWVudCBhbiBleGlzdGluZyBzdHJ1Y3QgdG8gYWxsb3cgYG51bGxgIHZhbHVlcy5cbiAqL1xuZnVuY3Rpb24gbnVsbGFibGUoc3RydWN0KSB7XG4gICAgcmV0dXJuIG5ldyBTdHJ1Y3Qoe1xuICAgICAgICAuLi5zdHJ1Y3QsXG4gICAgICAgIHZhbGlkYXRvcjogKHZhbHVlLCBjdHgpID0+IHZhbHVlID09PSBudWxsIHx8IHN0cnVjdC52YWxpZGF0b3IodmFsdWUsIGN0eCksXG4gICAgICAgIHJlZmluZXI6ICh2YWx1ZSwgY3R4KSA9PiB2YWx1ZSA9PT0gbnVsbCB8fCBzdHJ1Y3QucmVmaW5lcih2YWx1ZSwgY3R4KSxcbiAgICB9KTtcbn1cbi8qKlxuICogRW5zdXJlIHRoYXQgYSB2YWx1ZSBpcyBhIG51bWJlci5cbiAqL1xuZnVuY3Rpb24gbnVtYmVyKCkge1xuICAgIHJldHVybiBkZWZpbmUoJ251bWJlcicsICh2YWx1ZSkgPT4ge1xuICAgICAgICByZXR1cm4gKCh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInICYmICFpc05hTih2YWx1ZSkpIHx8XG4gICAgICAgICAgICBgRXhwZWN0ZWQgYSBudW1iZXIsIGJ1dCByZWNlaXZlZDogJHtwcmludCh2YWx1ZSl9YCk7XG4gICAgfSk7XG59XG5mdW5jdGlvbiBvYmplY3Qoc2NoZW1hKSB7XG4gICAgY29uc3Qga25vd25zID0gc2NoZW1hID8gT2JqZWN0LmtleXMoc2NoZW1hKSA6IFtdO1xuICAgIGNvbnN0IE5ldmVyID0gbmV2ZXIoKTtcbiAgICByZXR1cm4gbmV3IFN0cnVjdCh7XG4gICAgICAgIHR5cGU6ICdvYmplY3QnLFxuICAgICAgICBzY2hlbWE6IHNjaGVtYSA/IHNjaGVtYSA6IG51bGwsXG4gICAgICAgICplbnRyaWVzKHZhbHVlKSB7XG4gICAgICAgICAgICBpZiAoc2NoZW1hICYmIGlzT2JqZWN0KHZhbHVlKSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHVua25vd25zID0gbmV3IFNldChPYmplY3Qua2V5cyh2YWx1ZSkpO1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3Qga2V5IG9mIGtub3ducykge1xuICAgICAgICAgICAgICAgICAgICB1bmtub3ducy5kZWxldGUoa2V5KTtcbiAgICAgICAgICAgICAgICAgICAgeWllbGQgW2tleSwgdmFsdWVba2V5XSwgc2NoZW1hW2tleV1dO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGtleSBvZiB1bmtub3ducykge1xuICAgICAgICAgICAgICAgICAgICB5aWVsZCBba2V5LCB2YWx1ZVtrZXldLCBOZXZlcl07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB2YWxpZGF0b3IodmFsdWUpIHtcbiAgICAgICAgICAgIHJldHVybiAoaXNPYmplY3QodmFsdWUpIHx8IGBFeHBlY3RlZCBhbiBvYmplY3QsIGJ1dCByZWNlaXZlZDogJHtwcmludCh2YWx1ZSl9YCk7XG4gICAgICAgIH0sXG4gICAgICAgIGNvZXJjZXIodmFsdWUpIHtcbiAgICAgICAgICAgIHJldHVybiBpc09iamVjdCh2YWx1ZSkgPyB7IC4uLnZhbHVlIH0gOiB2YWx1ZTtcbiAgICAgICAgfSxcbiAgICB9KTtcbn1cbi8qKlxuICogQXVnbWVudCBhIHN0cnVjdCB0byBhbGxvdyBgdW5kZWZpbmVkYCB2YWx1ZXMuXG4gKi9cbmZ1bmN0aW9uIG9wdGlvbmFsKHN0cnVjdCkge1xuICAgIHJldHVybiBuZXcgU3RydWN0KHtcbiAgICAgICAgLi4uc3RydWN0LFxuICAgICAgICB2YWxpZGF0b3I6ICh2YWx1ZSwgY3R4KSA9PiB2YWx1ZSA9PT0gdW5kZWZpbmVkIHx8IHN0cnVjdC52YWxpZGF0b3IodmFsdWUsIGN0eCksXG4gICAgICAgIHJlZmluZXI6ICh2YWx1ZSwgY3R4KSA9PiB2YWx1ZSA9PT0gdW5kZWZpbmVkIHx8IHN0cnVjdC5yZWZpbmVyKHZhbHVlLCBjdHgpLFxuICAgIH0pO1xufVxuLyoqXG4gKiBFbnN1cmUgdGhhdCBhIHZhbHVlIGlzIGFuIG9iamVjdCB3aXRoIGtleXMgYW5kIHZhbHVlcyBvZiBzcGVjaWZpYyB0eXBlcywgYnV0XG4gKiB3aXRob3V0IGVuc3VyaW5nIGFueSBzcGVjaWZpYyBzaGFwZSBvZiBwcm9wZXJ0aWVzLlxuICpcbiAqIExpa2UgVHlwZVNjcmlwdCdzIGBSZWNvcmRgIHV0aWxpdHkuXG4gKi9cbmZ1bmN0aW9uIHJlY29yZChLZXksIFZhbHVlKSB7XG4gICAgcmV0dXJuIG5ldyBTdHJ1Y3Qoe1xuICAgICAgICB0eXBlOiAncmVjb3JkJyxcbiAgICAgICAgc2NoZW1hOiBudWxsLFxuICAgICAgICAqZW50cmllcyh2YWx1ZSkge1xuICAgICAgICAgICAgaWYgKGlzT2JqZWN0KHZhbHVlKSkge1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgayBpbiB2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB2ID0gdmFsdWVba107XG4gICAgICAgICAgICAgICAgICAgIHlpZWxkIFtrLCBrLCBLZXldO1xuICAgICAgICAgICAgICAgICAgICB5aWVsZCBbaywgdiwgVmFsdWVdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgdmFsaWRhdG9yKHZhbHVlKSB7XG4gICAgICAgICAgICByZXR1cm4gKGlzT2JqZWN0KHZhbHVlKSB8fCBgRXhwZWN0ZWQgYW4gb2JqZWN0LCBidXQgcmVjZWl2ZWQ6ICR7cHJpbnQodmFsdWUpfWApO1xuICAgICAgICB9LFxuICAgIH0pO1xufVxuLyoqXG4gKiBFbnN1cmUgdGhhdCBhIHZhbHVlIGlzIGEgYFJlZ0V4cGAuXG4gKlxuICogTm90ZTogdGhpcyBkb2VzIG5vdCB0ZXN0IHRoZSB2YWx1ZSBhZ2FpbnN0IHRoZSByZWd1bGFyIGV4cHJlc3Npb24hIEZvciB0aGF0XG4gKiB5b3UgbmVlZCB0byB1c2UgdGhlIGBwYXR0ZXJuKClgIHJlZmluZW1lbnQuXG4gKi9cbmZ1bmN0aW9uIHJlZ2V4cCgpIHtcbiAgICByZXR1cm4gZGVmaW5lKCdyZWdleHAnLCAodmFsdWUpID0+IHtcbiAgICAgICAgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgUmVnRXhwO1xuICAgIH0pO1xufVxuZnVuY3Rpb24gc2V0KEVsZW1lbnQpIHtcbiAgICByZXR1cm4gbmV3IFN0cnVjdCh7XG4gICAgICAgIHR5cGU6ICdzZXQnLFxuICAgICAgICBzY2hlbWE6IG51bGwsXG4gICAgICAgICplbnRyaWVzKHZhbHVlKSB7XG4gICAgICAgICAgICBpZiAoRWxlbWVudCAmJiB2YWx1ZSBpbnN0YW5jZW9mIFNldCkge1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgdiBvZiB2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICB5aWVsZCBbdiwgdiwgRWxlbWVudF07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBjb2VyY2VyKHZhbHVlKSB7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBTZXQgPyBuZXcgU2V0KHZhbHVlKSA6IHZhbHVlO1xuICAgICAgICB9LFxuICAgICAgICB2YWxpZGF0b3IodmFsdWUpIHtcbiAgICAgICAgICAgIHJldHVybiAodmFsdWUgaW5zdGFuY2VvZiBTZXQgfHxcbiAgICAgICAgICAgICAgICBgRXhwZWN0ZWQgYSBcXGBTZXRcXGAgb2JqZWN0LCBidXQgcmVjZWl2ZWQ6ICR7cHJpbnQodmFsdWUpfWApO1xuICAgICAgICB9LFxuICAgIH0pO1xufVxuLyoqXG4gKiBFbnN1cmUgdGhhdCBhIHZhbHVlIGlzIGEgc3RyaW5nLlxuICovXG5mdW5jdGlvbiBzdHJpbmcoKSB7XG4gICAgcmV0dXJuIGRlZmluZSgnc3RyaW5nJywgKHZhbHVlKSA9PiB7XG4gICAgICAgIHJldHVybiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJyB8fFxuICAgICAgICAgICAgYEV4cGVjdGVkIGEgc3RyaW5nLCBidXQgcmVjZWl2ZWQ6ICR7cHJpbnQodmFsdWUpfWApO1xuICAgIH0pO1xufVxuLyoqXG4gKiBFbnN1cmUgdGhhdCBhIHZhbHVlIGlzIGEgdHVwbGUgb2YgYSBzcGVjaWZpYyBsZW5ndGgsIGFuZCB0aGF0IGVhY2ggb2YgaXRzXG4gKiBlbGVtZW50cyBpcyBvZiBhIHNwZWNpZmljIHR5cGUuXG4gKi9cbmZ1bmN0aW9uIHR1cGxlKFN0cnVjdHMpIHtcbiAgICBjb25zdCBOZXZlciA9IG5ldmVyKCk7XG4gICAgcmV0dXJuIG5ldyBTdHJ1Y3Qoe1xuICAgICAgICB0eXBlOiAndHVwbGUnLFxuICAgICAgICBzY2hlbWE6IG51bGwsXG4gICAgICAgICplbnRyaWVzKHZhbHVlKSB7XG4gICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBsZW5ndGggPSBNYXRoLm1heChTdHJ1Y3RzLmxlbmd0aCwgdmFsdWUubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIHlpZWxkIFtpLCB2YWx1ZVtpXSwgU3RydWN0c1tpXSB8fCBOZXZlcl07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB2YWxpZGF0b3IodmFsdWUpIHtcbiAgICAgICAgICAgIHJldHVybiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkgfHxcbiAgICAgICAgICAgICAgICBgRXhwZWN0ZWQgYW4gYXJyYXksIGJ1dCByZWNlaXZlZDogJHtwcmludCh2YWx1ZSl9YCk7XG4gICAgICAgIH0sXG4gICAgfSk7XG59XG4vKipcbiAqIEVuc3VyZSB0aGF0IGEgdmFsdWUgaGFzIGEgc2V0IG9mIGtub3duIHByb3BlcnRpZXMgb2Ygc3BlY2lmaWMgdHlwZXMuXG4gKlxuICogTm90ZTogVW5yZWNvZ25pemVkIHByb3BlcnRpZXMgYXJlIGFsbG93ZWQgYW5kIHVudG91Y2hlZC4gVGhpcyBpcyBzaW1pbGFyIHRvXG4gKiBob3cgVHlwZVNjcmlwdCdzIHN0cnVjdHVyYWwgdHlwaW5nIHdvcmtzLlxuICovXG5mdW5jdGlvbiB0eXBlKHNjaGVtYSkge1xuICAgIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyhzY2hlbWEpO1xuICAgIHJldHVybiBuZXcgU3RydWN0KHtcbiAgICAgICAgdHlwZTogJ3R5cGUnLFxuICAgICAgICBzY2hlbWEsXG4gICAgICAgICplbnRyaWVzKHZhbHVlKSB7XG4gICAgICAgICAgICBpZiAoaXNPYmplY3QodmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBrIG9mIGtleXMpIHtcbiAgICAgICAgICAgICAgICAgICAgeWllbGQgW2ssIHZhbHVlW2tdLCBzY2hlbWFba11dO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgdmFsaWRhdG9yKHZhbHVlKSB7XG4gICAgICAgICAgICByZXR1cm4gKGlzT2JqZWN0KHZhbHVlKSB8fCBgRXhwZWN0ZWQgYW4gb2JqZWN0LCBidXQgcmVjZWl2ZWQ6ICR7cHJpbnQodmFsdWUpfWApO1xuICAgICAgICB9LFxuICAgICAgICBjb2VyY2VyKHZhbHVlKSB7XG4gICAgICAgICAgICByZXR1cm4gaXNPYmplY3QodmFsdWUpID8geyAuLi52YWx1ZSB9IDogdmFsdWU7XG4gICAgICAgIH0sXG4gICAgfSk7XG59XG4vKipcbiAqIEVuc3VyZSB0aGF0IGEgdmFsdWUgbWF0Y2hlcyBvbmUgb2YgYSBzZXQgb2YgdHlwZXMuXG4gKi9cbmZ1bmN0aW9uIHVuaW9uKFN0cnVjdHMpIHtcbiAgICBjb25zdCBkZXNjcmlwdGlvbiA9IFN0cnVjdHMubWFwKChzKSA9PiBzLnR5cGUpLmpvaW4oJyB8ICcpO1xuICAgIHJldHVybiBuZXcgU3RydWN0KHtcbiAgICAgICAgdHlwZTogJ3VuaW9uJyxcbiAgICAgICAgc2NoZW1hOiBudWxsLFxuICAgICAgICBjb2VyY2VyKHZhbHVlKSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IFMgb2YgU3RydWN0cykge1xuICAgICAgICAgICAgICAgIGNvbnN0IFtlcnJvciwgY29lcmNlZF0gPSBTLnZhbGlkYXRlKHZhbHVlLCB7IGNvZXJjZTogdHJ1ZSB9KTtcbiAgICAgICAgICAgICAgICBpZiAoIWVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjb2VyY2VkO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgfSxcbiAgICAgICAgdmFsaWRhdG9yKHZhbHVlLCBjdHgpIHtcbiAgICAgICAgICAgIGNvbnN0IGZhaWx1cmVzID0gW107XG4gICAgICAgICAgICBmb3IgKGNvbnN0IFMgb2YgU3RydWN0cykge1xuICAgICAgICAgICAgICAgIGNvbnN0IFsuLi50dXBsZXNdID0gcnVuKHZhbHVlLCBTLCBjdHgpO1xuICAgICAgICAgICAgICAgIGNvbnN0IFtmaXJzdF0gPSB0dXBsZXM7XG4gICAgICAgICAgICAgICAgaWYgKCFmaXJzdFswXSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IFtmYWlsdXJlXSBvZiB0dXBsZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChmYWlsdXJlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZmFpbHVyZXMucHVzaChmYWlsdXJlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgICAgYEV4cGVjdGVkIHRoZSB2YWx1ZSB0byBzYXRpc2Z5IGEgdW5pb24gb2YgXFxgJHtkZXNjcmlwdGlvbn1cXGAsIGJ1dCByZWNlaXZlZDogJHtwcmludCh2YWx1ZSl9YCxcbiAgICAgICAgICAgICAgICAuLi5mYWlsdXJlcyxcbiAgICAgICAgICAgIF07XG4gICAgICAgIH0sXG4gICAgfSk7XG59XG4vKipcbiAqIEVuc3VyZSB0aGF0IGFueSB2YWx1ZSBwYXNzZXMgdmFsaWRhdGlvbiwgd2l0aG91dCB3aWRlbmluZyBpdHMgdHlwZSB0byBgYW55YC5cbiAqL1xuZnVuY3Rpb24gdW5rbm93bigpIHtcbiAgICByZXR1cm4gZGVmaW5lKCd1bmtub3duJywgKCkgPT4gdHJ1ZSk7XG59XG5cbi8qKlxuICogQXVnbWVudCBhIGBTdHJ1Y3RgIHRvIGFkZCBhbiBhZGRpdGlvbmFsIGNvZXJjaW9uIHN0ZXAgdG8gaXRzIGlucHV0LlxuICpcbiAqIFRoaXMgYWxsb3dzIHlvdSB0byB0cmFuc2Zvcm0gaW5wdXQgZGF0YSBiZWZvcmUgdmFsaWRhdGluZyBpdCwgdG8gaW5jcmVhc2UgdGhlXG4gKiBsaWtlbGlob29kIHRoYXQgaXQgcGFzc2VzIHZhbGlkYXRpb27igJRmb3IgZXhhbXBsZSBmb3IgZGVmYXVsdCB2YWx1ZXMsIHBhcnNpbmdcbiAqIGRpZmZlcmVudCBmb3JtYXRzLCBldGMuXG4gKlxuICogTm90ZTogWW91IG11c3QgdXNlIGBjcmVhdGUodmFsdWUsIFN0cnVjdClgIG9uIHRoZSB2YWx1ZSB0byBoYXZlIHRoZSBjb2VyY2lvblxuICogdGFrZSBlZmZlY3QhIFVzaW5nIHNpbXBseSBgYXNzZXJ0KClgIG9yIGBpcygpYCB3aWxsIG5vdCB1c2UgY29lcmNpb24uXG4gKi9cbmZ1bmN0aW9uIGNvZXJjZShzdHJ1Y3QsIGNvbmRpdGlvbiwgY29lcmNlcikge1xuICAgIHJldHVybiBuZXcgU3RydWN0KHtcbiAgICAgICAgLi4uc3RydWN0LFxuICAgICAgICBjb2VyY2VyOiAodmFsdWUsIGN0eCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIGlzKHZhbHVlLCBjb25kaXRpb24pXG4gICAgICAgICAgICAgICAgPyBzdHJ1Y3QuY29lcmNlcihjb2VyY2VyKHZhbHVlLCBjdHgpLCBjdHgpXG4gICAgICAgICAgICAgICAgOiBzdHJ1Y3QuY29lcmNlcih2YWx1ZSwgY3R4KTtcbiAgICAgICAgfSxcbiAgICB9KTtcbn1cbi8qKlxuICogQXVnbWVudCBhIHN0cnVjdCB0byByZXBsYWNlIGB1bmRlZmluZWRgIHZhbHVlcyB3aXRoIGEgZGVmYXVsdC5cbiAqXG4gKiBOb3RlOiBZb3UgbXVzdCB1c2UgYGNyZWF0ZSh2YWx1ZSwgU3RydWN0KWAgb24gdGhlIHZhbHVlIHRvIGhhdmUgdGhlIGNvZXJjaW9uXG4gKiB0YWtlIGVmZmVjdCEgVXNpbmcgc2ltcGx5IGBhc3NlcnQoKWAgb3IgYGlzKClgIHdpbGwgbm90IHVzZSBjb2VyY2lvbi5cbiAqL1xuZnVuY3Rpb24gZGVmYXVsdGVkKHN0cnVjdCwgZmFsbGJhY2ssIG9wdGlvbnMgPSB7fSkge1xuICAgIHJldHVybiBjb2VyY2Uoc3RydWN0LCB1bmtub3duKCksICh4KSA9PiB7XG4gICAgICAgIGNvbnN0IGYgPSB0eXBlb2YgZmFsbGJhY2sgPT09ICdmdW5jdGlvbicgPyBmYWxsYmFjaygpIDogZmFsbGJhY2s7XG4gICAgICAgIGlmICh4ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBmO1xuICAgICAgICB9XG4gICAgICAgIGlmICghb3B0aW9ucy5zdHJpY3QgJiYgaXNQbGFpbk9iamVjdCh4KSAmJiBpc1BsYWluT2JqZWN0KGYpKSB7XG4gICAgICAgICAgICBjb25zdCByZXQgPSB7IC4uLnggfTtcbiAgICAgICAgICAgIGxldCBjaGFuZ2VkID0gZmFsc2U7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBmKSB7XG4gICAgICAgICAgICAgICAgaWYgKHJldFtrZXldID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0W2tleV0gPSBmW2tleV07XG4gICAgICAgICAgICAgICAgICAgIGNoYW5nZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjaGFuZ2VkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJldDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geDtcbiAgICB9KTtcbn1cbi8qKlxuICogQXVnbWVudCBhIHN0cnVjdCB0byB0cmltIHN0cmluZyBpbnB1dHMuXG4gKlxuICogTm90ZTogWW91IG11c3QgdXNlIGBjcmVhdGUodmFsdWUsIFN0cnVjdClgIG9uIHRoZSB2YWx1ZSB0byBoYXZlIHRoZSBjb2VyY2lvblxuICogdGFrZSBlZmZlY3QhIFVzaW5nIHNpbXBseSBgYXNzZXJ0KClgIG9yIGBpcygpYCB3aWxsIG5vdCB1c2UgY29lcmNpb24uXG4gKi9cbmZ1bmN0aW9uIHRyaW1tZWQoc3RydWN0KSB7XG4gICAgcmV0dXJuIGNvZXJjZShzdHJ1Y3QsIHN0cmluZygpLCAoeCkgPT4geC50cmltKCkpO1xufVxuXG4vKipcbiAqIEVuc3VyZSB0aGF0IGEgc3RyaW5nLCBhcnJheSwgbWFwLCBvciBzZXQgaXMgZW1wdHkuXG4gKi9cbmZ1bmN0aW9uIGVtcHR5KHN0cnVjdCkge1xuICAgIHJldHVybiByZWZpbmUoc3RydWN0LCAnZW1wdHknLCAodmFsdWUpID0+IHtcbiAgICAgICAgY29uc3Qgc2l6ZSA9IGdldFNpemUodmFsdWUpO1xuICAgICAgICByZXR1cm4gKHNpemUgPT09IDAgfHxcbiAgICAgICAgICAgIGBFeHBlY3RlZCBhbiBlbXB0eSAke3N0cnVjdC50eXBlfSBidXQgcmVjZWl2ZWQgb25lIHdpdGggYSBzaXplIG9mIFxcYCR7c2l6ZX1cXGBgKTtcbiAgICB9KTtcbn1cbmZ1bmN0aW9uIGdldFNpemUodmFsdWUpIHtcbiAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBNYXAgfHwgdmFsdWUgaW5zdGFuY2VvZiBTZXQpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlLnNpemU7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gdmFsdWUubGVuZ3RoO1xuICAgIH1cbn1cbi8qKlxuICogRW5zdXJlIHRoYXQgYSBudW1iZXIgb3IgZGF0ZSBpcyBiZWxvdyBhIHRocmVzaG9sZC5cbiAqL1xuZnVuY3Rpb24gbWF4KHN0cnVjdCwgdGhyZXNob2xkLCBvcHRpb25zID0ge30pIHtcbiAgICBjb25zdCB7IGV4Y2x1c2l2ZSB9ID0gb3B0aW9ucztcbiAgICByZXR1cm4gcmVmaW5lKHN0cnVjdCwgJ21heCcsICh2YWx1ZSkgPT4ge1xuICAgICAgICByZXR1cm4gZXhjbHVzaXZlXG4gICAgICAgICAgICA/IHZhbHVlIDwgdGhyZXNob2xkXG4gICAgICAgICAgICA6IHZhbHVlIDw9IHRocmVzaG9sZCB8fFxuICAgICAgICAgICAgICAgIGBFeHBlY3RlZCBhICR7c3RydWN0LnR5cGV9IGxlc3MgdGhhbiAke2V4Y2x1c2l2ZSA/ICcnIDogJ29yIGVxdWFsIHRvICd9JHt0aHJlc2hvbGR9IGJ1dCByZWNlaXZlZCBcXGAke3ZhbHVlfVxcYGA7XG4gICAgfSk7XG59XG4vKipcbiAqIEVuc3VyZSB0aGF0IGEgbnVtYmVyIG9yIGRhdGUgaXMgYWJvdmUgYSB0aHJlc2hvbGQuXG4gKi9cbmZ1bmN0aW9uIG1pbihzdHJ1Y3QsIHRocmVzaG9sZCwgb3B0aW9ucyA9IHt9KSB7XG4gICAgY29uc3QgeyBleGNsdXNpdmUgfSA9IG9wdGlvbnM7XG4gICAgcmV0dXJuIHJlZmluZShzdHJ1Y3QsICdtaW4nLCAodmFsdWUpID0+IHtcbiAgICAgICAgcmV0dXJuIGV4Y2x1c2l2ZVxuICAgICAgICAgICAgPyB2YWx1ZSA+IHRocmVzaG9sZFxuICAgICAgICAgICAgOiB2YWx1ZSA+PSB0aHJlc2hvbGQgfHxcbiAgICAgICAgICAgICAgICBgRXhwZWN0ZWQgYSAke3N0cnVjdC50eXBlfSBncmVhdGVyIHRoYW4gJHtleGNsdXNpdmUgPyAnJyA6ICdvciBlcXVhbCB0byAnfSR7dGhyZXNob2xkfSBidXQgcmVjZWl2ZWQgXFxgJHt2YWx1ZX1cXGBgO1xuICAgIH0pO1xufVxuLyoqXG4gKiBFbnN1cmUgdGhhdCBhIHN0cmluZywgYXJyYXksIG1hcCBvciBzZXQgaXMgbm90IGVtcHR5LlxuICovXG5mdW5jdGlvbiBub25lbXB0eShzdHJ1Y3QpIHtcbiAgICByZXR1cm4gcmVmaW5lKHN0cnVjdCwgJ25vbmVtcHR5JywgKHZhbHVlKSA9PiB7XG4gICAgICAgIGNvbnN0IHNpemUgPSBnZXRTaXplKHZhbHVlKTtcbiAgICAgICAgcmV0dXJuIChzaXplID4gMCB8fCBgRXhwZWN0ZWQgYSBub25lbXB0eSAke3N0cnVjdC50eXBlfSBidXQgcmVjZWl2ZWQgYW4gZW1wdHkgb25lYCk7XG4gICAgfSk7XG59XG4vKipcbiAqIEVuc3VyZSB0aGF0IGEgc3RyaW5nIG1hdGNoZXMgYSByZWd1bGFyIGV4cHJlc3Npb24uXG4gKi9cbmZ1bmN0aW9uIHBhdHRlcm4oc3RydWN0LCByZWdleHApIHtcbiAgICByZXR1cm4gcmVmaW5lKHN0cnVjdCwgJ3BhdHRlcm4nLCAodmFsdWUpID0+IHtcbiAgICAgICAgcmV0dXJuIChyZWdleHAudGVzdCh2YWx1ZSkgfHxcbiAgICAgICAgICAgIGBFeHBlY3RlZCBhICR7c3RydWN0LnR5cGV9IG1hdGNoaW5nIFxcYC8ke3JlZ2V4cC5zb3VyY2V9L1xcYCBidXQgcmVjZWl2ZWQgXCIke3ZhbHVlfVwiYCk7XG4gICAgfSk7XG59XG4vKipcbiAqIEVuc3VyZSB0aGF0IGEgc3RyaW5nLCBhcnJheSwgbnVtYmVyLCBkYXRlLCBtYXAsIG9yIHNldCBoYXMgYSBzaXplIChvciBsZW5ndGgsIG9yIHRpbWUpIGJldHdlZW4gYG1pbmAgYW5kIGBtYXhgLlxuICovXG5mdW5jdGlvbiBzaXplKHN0cnVjdCwgbWluLCBtYXggPSBtaW4pIHtcbiAgICBjb25zdCBleHBlY3RlZCA9IGBFeHBlY3RlZCBhICR7c3RydWN0LnR5cGV9YDtcbiAgICBjb25zdCBvZiA9IG1pbiA9PT0gbWF4ID8gYG9mIFxcYCR7bWlufVxcYGAgOiBgYmV0d2VlbiBcXGAke21pbn1cXGAgYW5kIFxcYCR7bWF4fVxcYGA7XG4gICAgcmV0dXJuIHJlZmluZShzdHJ1Y3QsICdzaXplJywgKHZhbHVlKSA9PiB7XG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInIHx8IHZhbHVlIGluc3RhbmNlb2YgRGF0ZSkge1xuICAgICAgICAgICAgcmV0dXJuICgobWluIDw9IHZhbHVlICYmIHZhbHVlIDw9IG1heCkgfHxcbiAgICAgICAgICAgICAgICBgJHtleHBlY3RlZH0gJHtvZn0gYnV0IHJlY2VpdmVkIFxcYCR7dmFsdWV9XFxgYCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodmFsdWUgaW5zdGFuY2VvZiBNYXAgfHwgdmFsdWUgaW5zdGFuY2VvZiBTZXQpIHtcbiAgICAgICAgICAgIGNvbnN0IHsgc2l6ZSB9ID0gdmFsdWU7XG4gICAgICAgICAgICByZXR1cm4gKChtaW4gPD0gc2l6ZSAmJiBzaXplIDw9IG1heCkgfHxcbiAgICAgICAgICAgICAgICBgJHtleHBlY3RlZH0gd2l0aCBhIHNpemUgJHtvZn0gYnV0IHJlY2VpdmVkIG9uZSB3aXRoIGEgc2l6ZSBvZiBcXGAke3NpemV9XFxgYCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCB7IGxlbmd0aCB9ID0gdmFsdWU7XG4gICAgICAgICAgICByZXR1cm4gKChtaW4gPD0gbGVuZ3RoICYmIGxlbmd0aCA8PSBtYXgpIHx8XG4gICAgICAgICAgICAgICAgYCR7ZXhwZWN0ZWR9IHdpdGggYSBsZW5ndGggJHtvZn0gYnV0IHJlY2VpdmVkIG9uZSB3aXRoIGEgbGVuZ3RoIG9mIFxcYCR7bGVuZ3RofVxcYGApO1xuICAgICAgICB9XG4gICAgfSk7XG59XG4vKipcbiAqIEF1Z21lbnQgYSBgU3RydWN0YCB0byBhZGQgYW4gYWRkaXRpb25hbCByZWZpbmVtZW50IHRvIHRoZSB2YWxpZGF0aW9uLlxuICpcbiAqIFRoZSByZWZpbmVyIGZ1bmN0aW9uIGlzIGd1YXJhbnRlZWQgdG8gcmVjZWl2ZSBhIHZhbHVlIG9mIHRoZSBzdHJ1Y3QncyB0eXBlLFxuICogYmVjYXVzZSB0aGUgc3RydWN0J3MgZXhpc3RpbmcgdmFsaWRhdGlvbiB3aWxsIGFscmVhZHkgaGF2ZSBwYXNzZWQuIFRoaXNcbiAqIGFsbG93cyB5b3UgdG8gbGF5ZXIgYWRkaXRpb25hbCB2YWxpZGF0aW9uIG9uIHRvcCBvZiBleGlzdGluZyBzdHJ1Y3RzLlxuICovXG5mdW5jdGlvbiByZWZpbmUoc3RydWN0LCBuYW1lLCByZWZpbmVyKSB7XG4gICAgcmV0dXJuIG5ldyBTdHJ1Y3Qoe1xuICAgICAgICAuLi5zdHJ1Y3QsXG4gICAgICAgICpyZWZpbmVyKHZhbHVlLCBjdHgpIHtcbiAgICAgICAgICAgIHlpZWxkKiBzdHJ1Y3QucmVmaW5lcih2YWx1ZSwgY3R4KTtcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IHJlZmluZXIodmFsdWUsIGN0eCk7XG4gICAgICAgICAgICBjb25zdCBmYWlsdXJlcyA9IHRvRmFpbHVyZXMocmVzdWx0LCBjdHgsIHN0cnVjdCwgdmFsdWUpO1xuICAgICAgICAgICAgZm9yIChjb25zdCBmYWlsdXJlIG9mIGZhaWx1cmVzKSB7XG4gICAgICAgICAgICAgICAgeWllbGQgeyAuLi5mYWlsdXJlLCByZWZpbmVtZW50OiBuYW1lIH07XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgfSk7XG59XG5cbmV4cG9ydCB7IFN0cnVjdCwgU3RydWN0RXJyb3IsIGFueSwgYXJyYXksIGFzc2VydCwgYXNzaWduLCBiaWdpbnQsIGJvb2xlYW4sIGNvZXJjZSwgY3JlYXRlLCBkYXRlLCBkZWZhdWx0ZWQsIGRlZmluZSwgZGVwcmVjYXRlZCwgZHluYW1pYywgZW1wdHksIGVudW1zLCBmdW5jLCBpbnN0YW5jZSwgaW50ZWdlciwgaW50ZXJzZWN0aW9uLCBpcywgbGF6eSwgbGl0ZXJhbCwgbWFwLCBtYXNrLCBtYXgsIG1pbiwgbmV2ZXIsIG5vbmVtcHR5LCBudWxsYWJsZSwgbnVtYmVyLCBvYmplY3QsIG9taXQsIG9wdGlvbmFsLCBwYXJ0aWFsLCBwYXR0ZXJuLCBwaWNrLCByZWNvcmQsIHJlZmluZSwgcmVnZXhwLCBzZXQsIHNpemUsIHN0cmluZywgc3RydWN0LCB0cmltbWVkLCB0dXBsZSwgdHlwZSwgdW5pb24sIHVua25vd24sIHZhbGlkYXRlIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5tanMubWFwXG4iXSwibmFtZXMiOlsiU3RydWN0RXJyb3IiLCJUeXBlRXJyb3IiLCJjb25zdHJ1Y3RvciIsImZhaWx1cmUiLCJmYWlsdXJlcyIsImNhY2hlZCIsIm1lc3NhZ2UiLCJleHBsYW5hdGlvbiIsInJlc3QiLCJwYXRoIiwibXNnIiwibGVuZ3RoIiwiam9pbiIsImNhdXNlIiwiT2JqZWN0IiwiYXNzaWduIiwibmFtZSIsImlzSXRlcmFibGUiLCJ4IiwiaXNPYmplY3QiLCJTeW1ib2wiLCJpdGVyYXRvciIsImlzUGxhaW5PYmplY3QiLCJwcm90b3R5cGUiLCJ0b1N0cmluZyIsImNhbGwiLCJnZXRQcm90b3R5cGVPZiIsInByaW50IiwidmFsdWUiLCJKU09OIiwic3RyaW5naWZ5Iiwic2hpZnRJdGVyYXRvciIsImlucHV0IiwiZG9uZSIsIm5leHQiLCJ1bmRlZmluZWQiLCJ0b0ZhaWx1cmUiLCJyZXN1bHQiLCJjb250ZXh0Iiwic3RydWN0IiwiYnJhbmNoIiwidHlwZSIsInJlZmluZW1lbnQiLCJrZXkiLCJ0b0ZhaWx1cmVzIiwiciIsInJ1biIsIm9wdGlvbnMiLCJjb2VyY2UiLCJtYXNrIiwiY3R4IiwiY29lcmNlciIsInNjaGVtYSIsIkFycmF5IiwiaXNBcnJheSIsInN0YXR1cyIsInZhbGlkYXRvciIsImsiLCJ2IiwicyIsImVudHJpZXMiLCJ0cyIsInQiLCJNYXAiLCJzZXQiLCJTZXQiLCJhZGQiLCJyZWZpbmVyIiwiU3RydWN0IiwicHJvcHMiLCJhc3NlcnQiLCJjcmVhdGUiLCJpcyIsInZhbGlkYXRlIiwidHVwbGVzIiwidHVwbGUiLCJlcnJvciIsIlN0cnVjdHMiLCJpc1R5cGUiLCJzY2hlbWFzIiwibWFwIiwib2JqZWN0IiwiZGVmaW5lIiwiZGVwcmVjYXRlZCIsImxvZyIsImR5bmFtaWMiLCJmbiIsImxhenkiLCJvbWl0Iiwia2V5cyIsInN1YnNjaGVtYSIsInBhcnRpYWwiLCJpc1N0cnVjdCIsIm9wdGlvbmFsIiwicGljayIsImNvbnNvbGUiLCJ3YXJuIiwiYW55IiwiYXJyYXkiLCJFbGVtZW50IiwiaSIsInNsaWNlIiwiYmlnaW50IiwiYm9vbGVhbiIsImRhdGUiLCJEYXRlIiwiaXNOYU4iLCJnZXRUaW1lIiwiZW51bXMiLCJ2YWx1ZXMiLCJkZXNjcmlwdGlvbiIsImluY2x1ZGVzIiwiZnVuYyIsImluc3RhbmNlIiwiQ2xhc3MiLCJpbnRlZ2VyIiwiTnVtYmVyIiwiaXNJbnRlZ2VyIiwiaW50ZXJzZWN0aW9uIiwiUyIsImxpdGVyYWwiLCJjb25zdGFudCIsIktleSIsIlZhbHVlIiwibmV2ZXIiLCJudWxsYWJsZSIsIm51bWJlciIsImtub3ducyIsIk5ldmVyIiwidW5rbm93bnMiLCJkZWxldGUiLCJyZWNvcmQiLCJyZWdleHAiLCJSZWdFeHAiLCJzdHJpbmciLCJNYXRoIiwibWF4IiwidW5pb24iLCJjb2VyY2VkIiwiZmlyc3QiLCJwdXNoIiwidW5rbm93biIsImNvbmRpdGlvbiIsImRlZmF1bHRlZCIsImZhbGxiYWNrIiwiZiIsInN0cmljdCIsInJldCIsImNoYW5nZWQiLCJ0cmltbWVkIiwidHJpbSIsImVtcHR5IiwicmVmaW5lIiwic2l6ZSIsImdldFNpemUiLCJ0aHJlc2hvbGQiLCJleGNsdXNpdmUiLCJtaW4iLCJub25lbXB0eSIsInBhdHRlcm4iLCJ0ZXN0Iiwic291cmNlIiwiZXhwZWN0ZWQiLCJvZiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/../anchor/node_modules/@solana/web3.js/node_modules/superstruct/dist/index.mjs\n");

/***/ }),

/***/ "(ssr)/../node_modules/@solana/spl-token/lib/esm/constants.js":
/*!**************************************************************!*\
  !*** ../node_modules/@solana/spl-token/lib/esm/constants.js ***!
  \**************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ASSOCIATED_TOKEN_PROGRAM_ID: () => (/* binding */ ASSOCIATED_TOKEN_PROGRAM_ID),\n/* harmony export */   NATIVE_MINT: () => (/* binding */ NATIVE_MINT),\n/* harmony export */   NATIVE_MINT_2022: () => (/* binding */ NATIVE_MINT_2022),\n/* harmony export */   TOKEN_2022_PROGRAM_ID: () => (/* binding */ TOKEN_2022_PROGRAM_ID),\n/* harmony export */   TOKEN_PROGRAM_ID: () => (/* binding */ TOKEN_PROGRAM_ID),\n/* harmony export */   programSupportsExtensions: () => (/* binding */ programSupportsExtensions)\n/* harmony export */ });\n/* harmony import */ var _solana_web3_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @solana/web3.js */ \"(ssr)/../node_modules/@solana/web3.js/lib/index.esm.js\");\n\n/** Address of the SPL Token program */ const TOKEN_PROGRAM_ID = new _solana_web3_js__WEBPACK_IMPORTED_MODULE_0__.PublicKey(\"TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA\");\n/** Address of the SPL Token 2022 program */ const TOKEN_2022_PROGRAM_ID = new _solana_web3_js__WEBPACK_IMPORTED_MODULE_0__.PublicKey(\"TokenzQdBNbLqP5VEhdkAS6EPFLC1PHnBqCXEpPxuEb\");\n/** Address of the SPL Associated Token Account program */ const ASSOCIATED_TOKEN_PROGRAM_ID = new _solana_web3_js__WEBPACK_IMPORTED_MODULE_0__.PublicKey(\"ATokenGPvbdGVxr1b2hvZbsiqW5xWH25efTNsLJA8knL\");\n/** Address of the special mint for wrapped native SOL in spl-token */ const NATIVE_MINT = new _solana_web3_js__WEBPACK_IMPORTED_MODULE_0__.PublicKey(\"So11111111111111111111111111111111111111112\");\n/** Address of the special mint for wrapped native SOL in spl-token-2022 */ const NATIVE_MINT_2022 = new _solana_web3_js__WEBPACK_IMPORTED_MODULE_0__.PublicKey(\"9pan9bMn5HatX4EJdBwg9VgCa7Uz5HL8N1m5D3NdXejP\");\n/** Check that the token program provided is not `Tokenkeg...`, useful when using extensions */ function programSupportsExtensions(programId) {\n    if (programId.equals(TOKEN_PROGRAM_ID)) {\n        return false;\n    } else {\n        return true;\n    }\n} //# sourceMappingURL=constants.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL0Bzb2xhbmEvc3BsLXRva2VuL2xpYi9lc20vY29uc3RhbnRzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7QUFBNEM7QUFDNUMscUNBQXFDLEdBQzlCLE1BQU1DLG1CQUFtQixJQUFJRCxzREFBU0EsQ0FBQywrQ0FBK0M7QUFDN0YsMENBQTBDLEdBQ25DLE1BQU1FLHdCQUF3QixJQUFJRixzREFBU0EsQ0FBQywrQ0FBK0M7QUFDbEcsd0RBQXdELEdBQ2pELE1BQU1HLDhCQUE4QixJQUFJSCxzREFBU0EsQ0FBQyxnREFBZ0Q7QUFDekcsb0VBQW9FLEdBQzdELE1BQU1JLGNBQWMsSUFBSUosc0RBQVNBLENBQUMsK0NBQStDO0FBQ3hGLHlFQUF5RSxHQUNsRSxNQUFNSyxtQkFBbUIsSUFBSUwsc0RBQVNBLENBQUMsZ0RBQWdEO0FBQzlGLDZGQUE2RixHQUN0RixTQUFTTSwwQkFBMEJDLFNBQVM7SUFDL0MsSUFBSUEsVUFBVUMsTUFBTSxDQUFDUCxtQkFBbUI7UUFDcEMsT0FBTztJQUNYLE9BQ0s7UUFDRCxPQUFPO0lBQ1g7QUFDSixFQUNBLHFDQUFxQyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvQHNvbGFuYS9zcGwtdG9rZW4vbGliL2VzbS9jb25zdGFudHMuanM/YTBmNCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBQdWJsaWNLZXkgfSBmcm9tICdAc29sYW5hL3dlYjMuanMnO1xuLyoqIEFkZHJlc3Mgb2YgdGhlIFNQTCBUb2tlbiBwcm9ncmFtICovXG5leHBvcnQgY29uc3QgVE9LRU5fUFJPR1JBTV9JRCA9IG5ldyBQdWJsaWNLZXkoJ1Rva2Vua2VnUWZlWnlpTndBSmJOYkdLUEZYQ1d1QnZmOVNzNjIzVlE1REEnKTtcbi8qKiBBZGRyZXNzIG9mIHRoZSBTUEwgVG9rZW4gMjAyMiBwcm9ncmFtICovXG5leHBvcnQgY29uc3QgVE9LRU5fMjAyMl9QUk9HUkFNX0lEID0gbmV3IFB1YmxpY0tleSgnVG9rZW56UWRCTmJMcVA1VkVoZGtBUzZFUEZMQzFQSG5CcUNYRXBQeHVFYicpO1xuLyoqIEFkZHJlc3Mgb2YgdGhlIFNQTCBBc3NvY2lhdGVkIFRva2VuIEFjY291bnQgcHJvZ3JhbSAqL1xuZXhwb3J0IGNvbnN0IEFTU09DSUFURURfVE9LRU5fUFJPR1JBTV9JRCA9IG5ldyBQdWJsaWNLZXkoJ0FUb2tlbkdQdmJkR1Z4cjFiMmh2WmJzaXFXNXhXSDI1ZWZUTnNMSkE4a25MJyk7XG4vKiogQWRkcmVzcyBvZiB0aGUgc3BlY2lhbCBtaW50IGZvciB3cmFwcGVkIG5hdGl2ZSBTT0wgaW4gc3BsLXRva2VuICovXG5leHBvcnQgY29uc3QgTkFUSVZFX01JTlQgPSBuZXcgUHVibGljS2V5KCdTbzExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTEyJyk7XG4vKiogQWRkcmVzcyBvZiB0aGUgc3BlY2lhbCBtaW50IGZvciB3cmFwcGVkIG5hdGl2ZSBTT0wgaW4gc3BsLXRva2VuLTIwMjIgKi9cbmV4cG9ydCBjb25zdCBOQVRJVkVfTUlOVF8yMDIyID0gbmV3IFB1YmxpY0tleSgnOXBhbjliTW41SGF0WDRFSmRCd2c5VmdDYTdVejVITDhOMW01RDNOZFhlalAnKTtcbi8qKiBDaGVjayB0aGF0IHRoZSB0b2tlbiBwcm9ncmFtIHByb3ZpZGVkIGlzIG5vdCBgVG9rZW5rZWcuLi5gLCB1c2VmdWwgd2hlbiB1c2luZyBleHRlbnNpb25zICovXG5leHBvcnQgZnVuY3Rpb24gcHJvZ3JhbVN1cHBvcnRzRXh0ZW5zaW9ucyhwcm9ncmFtSWQpIHtcbiAgICBpZiAocHJvZ3JhbUlkLmVxdWFscyhUT0tFTl9QUk9HUkFNX0lEKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jb25zdGFudHMuanMubWFwIl0sIm5hbWVzIjpbIlB1YmxpY0tleSIsIlRPS0VOX1BST0dSQU1fSUQiLCJUT0tFTl8yMDIyX1BST0dSQU1fSUQiLCJBU1NPQ0lBVEVEX1RPS0VOX1BST0dSQU1fSUQiLCJOQVRJVkVfTUlOVCIsIk5BVElWRV9NSU5UXzIwMjIiLCJwcm9ncmFtU3VwcG9ydHNFeHRlbnNpb25zIiwicHJvZ3JhbUlkIiwiZXF1YWxzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/@solana/spl-token/lib/esm/constants.js\n");

/***/ }),

/***/ "(ssr)/../node_modules/@solana/wallet-adapter-base/lib/esm/adapter.js":
/*!**********************************************************************!*\
  !*** ../node_modules/@solana/wallet-adapter-base/lib/esm/adapter.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BaseWalletAdapter: () => (/* binding */ BaseWalletAdapter),\n/* harmony export */   EventEmitter: () => (/* reexport default export from named module */ eventemitter3__WEBPACK_IMPORTED_MODULE_0__),\n/* harmony export */   WalletReadyState: () => (/* binding */ WalletReadyState),\n/* harmony export */   isIosAndRedirectable: () => (/* binding */ isIosAndRedirectable),\n/* harmony export */   scopePollingDetectionStrategy: () => (/* binding */ scopePollingDetectionStrategy)\n/* harmony export */ });\n/* harmony import */ var eventemitter3__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! eventemitter3 */ \"(ssr)/../node_modules/eventemitter3/index.js\");\n/* harmony import */ var _errors_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./errors.js */ \"(ssr)/../node_modules/@solana/wallet-adapter-base/lib/esm/errors.js\");\n\n\n\n/**\n * A wallet's readiness describes a series of states that the wallet can be in,\n * depending on what kind of wallet it is. An installable wallet (eg. a browser\n * extension like Phantom) might be `Installed` if we've found the Phantom API\n * in the global scope, or `NotDetected` otherwise. A loadable, zero-install\n * runtime (eg. Torus Wallet) might simply signal that it's `Loadable`. Use this\n * metadata to personalize the wallet list for each user (eg. to show their\n * installed wallets first).\n */ var WalletReadyState;\n(function(WalletReadyState) {\n    /**\n     * User-installable wallets can typically be detected by scanning for an API\n     * that they've injected into the global context. If such an API is present,\n     * we consider the wallet to have been installed.\n     */ WalletReadyState[\"Installed\"] = \"Installed\";\n    WalletReadyState[\"NotDetected\"] = \"NotDetected\";\n    /**\n     * Loadable wallets are always available to you. Since you can load them at\n     * any time, it's meaningless to say that they have been detected.\n     */ WalletReadyState[\"Loadable\"] = \"Loadable\";\n    /**\n     * If a wallet is not supported on a given platform (eg. server-rendering, or\n     * mobile) then it will stay in the `Unsupported` state.\n     */ WalletReadyState[\"Unsupported\"] = \"Unsupported\";\n})(WalletReadyState || (WalletReadyState = {}));\nclass BaseWalletAdapter extends eventemitter3__WEBPACK_IMPORTED_MODULE_0__ {\n    get connected() {\n        return !!this.publicKey;\n    }\n    async autoConnect() {\n        await this.connect();\n    }\n    async prepareTransaction(transaction, connection, options = {}) {\n        const publicKey = this.publicKey;\n        if (!publicKey) throw new _errors_js__WEBPACK_IMPORTED_MODULE_1__.WalletNotConnectedError();\n        transaction.feePayer = transaction.feePayer || publicKey;\n        transaction.recentBlockhash = transaction.recentBlockhash || (await connection.getLatestBlockhash({\n            commitment: options.preflightCommitment,\n            minContextSlot: options.minContextSlot\n        })).blockhash;\n        return transaction;\n    }\n}\nfunction scopePollingDetectionStrategy(detect) {\n    // Early return when server-side rendering\n    if (true) return;\n    const disposers = [];\n    function detectAndDispose() {\n        const detected = detect();\n        if (detected) {\n            for (const dispose of disposers){\n                dispose();\n            }\n        }\n    }\n    // Strategy #1: Try detecting every second.\n    const interval = // TODO: #334 Replace with idle callback strategy.\n    setInterval(detectAndDispose, 1000);\n    disposers.push(()=>clearInterval(interval));\n    // Strategy #2: Detect as soon as the DOM becomes 'ready'/'interactive'.\n    if (// Implies that `DOMContentLoaded` has not yet fired.\n    document.readyState === \"loading\") {\n        document.addEventListener(\"DOMContentLoaded\", detectAndDispose, {\n            once: true\n        });\n        disposers.push(()=>document.removeEventListener(\"DOMContentLoaded\", detectAndDispose));\n    }\n    // Strategy #3: Detect after the `window` has fully loaded.\n    if (// If the `complete` state has been reached, we're too late.\n    document.readyState !== \"complete\") {\n        window.addEventListener(\"load\", detectAndDispose, {\n            once: true\n        });\n        disposers.push(()=>window.removeEventListener(\"load\", detectAndDispose));\n    }\n    // Strategy #4: Detect synchronously, now.\n    detectAndDispose();\n}\n/**\n * Users on iOS can be redirected into a wallet's in-app browser automatically,\n * if that wallet has a universal link configured to do so\n * But should not be redirected from within a webview, eg. if they're already\n * inside a wallet's browser\n * This function can be used to identify users who are on iOS and can be redirected\n *\n * @returns true if the user can be redirected\n */ function isIosAndRedirectable() {\n    // SSR: return false\n    if (!navigator) return false;\n    const userAgent = navigator.userAgent.toLowerCase();\n    // if on iOS the user agent will contain either iPhone or iPad\n    // caveat: if requesting desktop site then this won't work\n    const isIos = userAgent.includes(\"iphone\") || userAgent.includes(\"ipad\");\n    // if in a webview then it will not include Safari\n    // note that other iOS browsers also include Safari\n    // so we will redirect only if Safari is also included\n    const isSafari = userAgent.includes(\"safari\");\n    return isIos && isSafari;\n} //# sourceMappingURL=adapter.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL0Bzb2xhbmEvd2FsbGV0LWFkYXB0ZXItYmFzZS9saWIvZXNtL2FkYXB0ZXIuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7OztBQUF5QztBQUNhO0FBQzlCO0FBQ3hCOzs7Ozs7OztDQVFDLEdBQ00sSUFBSUUsaUJBQWlCO0FBQzNCLFVBQVVBLGdCQUFnQjtJQUN2Qjs7OztLQUlDLEdBQ0RBLGdCQUFnQixDQUFDLFlBQVksR0FBRztJQUNoQ0EsZ0JBQWdCLENBQUMsY0FBYyxHQUFHO0lBQ2xDOzs7S0FHQyxHQUNEQSxnQkFBZ0IsQ0FBQyxXQUFXLEdBQUc7SUFDL0I7OztLQUdDLEdBQ0RBLGdCQUFnQixDQUFDLGNBQWMsR0FBRztBQUN0QyxHQUFHQSxvQkFBcUJBLENBQUFBLG1CQUFtQixDQUFDO0FBQ3JDLE1BQU1DLDBCQUEwQkgsMENBQVlBO0lBQy9DLElBQUlJLFlBQVk7UUFDWixPQUFPLENBQUMsQ0FBQyxJQUFJLENBQUNDLFNBQVM7SUFDM0I7SUFDQSxNQUFNQyxjQUFjO1FBQ2hCLE1BQU0sSUFBSSxDQUFDQyxPQUFPO0lBQ3RCO0lBQ0EsTUFBTUMsbUJBQW1CQyxXQUFXLEVBQUVDLFVBQVUsRUFBRUMsVUFBVSxDQUFDLENBQUMsRUFBRTtRQUM1RCxNQUFNTixZQUFZLElBQUksQ0FBQ0EsU0FBUztRQUNoQyxJQUFJLENBQUNBLFdBQ0QsTUFBTSxJQUFJSiwrREFBdUJBO1FBQ3JDUSxZQUFZRyxRQUFRLEdBQUdILFlBQVlHLFFBQVEsSUFBSVA7UUFDL0NJLFlBQVlJLGVBQWUsR0FDdkJKLFlBQVlJLGVBQWUsSUFDdkIsQ0FBQyxNQUFNSCxXQUFXSSxrQkFBa0IsQ0FBQztZQUNqQ0MsWUFBWUosUUFBUUssbUJBQW1CO1lBQ3ZDQyxnQkFBZ0JOLFFBQVFNLGNBQWM7UUFDMUMsRUFBQyxFQUFHQyxTQUFTO1FBQ3JCLE9BQU9UO0lBQ1g7QUFDSjtBQUNPLFNBQVNVLDhCQUE4QkMsTUFBTTtJQUNoRCwwQ0FBMEM7SUFDMUMsSUFBSSxJQUFxRCxFQUNyRDtJQUNKLE1BQU1FLFlBQVksRUFBRTtJQUNwQixTQUFTQztRQUNMLE1BQU1DLFdBQVdKO1FBQ2pCLElBQUlJLFVBQVU7WUFDVixLQUFLLE1BQU1DLFdBQVdILFVBQVc7Z0JBQzdCRztZQUNKO1FBQ0o7SUFDSjtJQUNBLDJDQUEyQztJQUMzQyxNQUFNQyxXQUNOLGtEQUFrRDtJQUNsREMsWUFBWUosa0JBQWtCO0lBQzlCRCxVQUFVTSxJQUFJLENBQUMsSUFBTUMsY0FBY0g7SUFDbkMsd0VBQXdFO0lBQ3hFLElBQ0EscURBQXFEO0lBQ3JETCxTQUFTUyxVQUFVLEtBQUssV0FBVztRQUMvQlQsU0FBU1UsZ0JBQWdCLENBQUMsb0JBQW9CUixrQkFBa0I7WUFBRVMsTUFBTTtRQUFLO1FBQzdFVixVQUFVTSxJQUFJLENBQUMsSUFBTVAsU0FBU1ksbUJBQW1CLENBQUMsb0JBQW9CVjtJQUMxRTtJQUNBLDJEQUEyRDtJQUMzRCxJQUNBLDREQUE0RDtJQUM1REYsU0FBU1MsVUFBVSxLQUFLLFlBQVk7UUFDaENJLE9BQU9ILGdCQUFnQixDQUFDLFFBQVFSLGtCQUFrQjtZQUFFUyxNQUFNO1FBQUs7UUFDL0RWLFVBQVVNLElBQUksQ0FBQyxJQUFNTSxPQUFPRCxtQkFBbUIsQ0FBQyxRQUFRVjtJQUM1RDtJQUNBLDBDQUEwQztJQUMxQ0E7QUFDSjtBQUNBOzs7Ozs7OztDQVFDLEdBQ00sU0FBU1k7SUFDWixvQkFBb0I7SUFDcEIsSUFBSSxDQUFDQyxXQUNELE9BQU87SUFDWCxNQUFNQyxZQUFZRCxVQUFVQyxTQUFTLENBQUNDLFdBQVc7SUFDakQsOERBQThEO0lBQzlELDBEQUEwRDtJQUMxRCxNQUFNQyxRQUFRRixVQUFVRyxRQUFRLENBQUMsYUFBYUgsVUFBVUcsUUFBUSxDQUFDO0lBQ2pFLGtEQUFrRDtJQUNsRCxtREFBbUQ7SUFDbkQsc0RBQXNEO0lBQ3RELE1BQU1DLFdBQVdKLFVBQVVHLFFBQVEsQ0FBQztJQUNwQyxPQUFPRCxTQUFTRTtBQUNwQixFQUNBLG1DQUFtQyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvQHNvbGFuYS93YWxsZXQtYWRhcHRlci1iYXNlL2xpYi9lc20vYWRhcHRlci5qcz8zNzdiIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBFdmVudEVtaXR0ZXIgZnJvbSAnZXZlbnRlbWl0dGVyMyc7XG5pbXBvcnQgeyBXYWxsZXROb3RDb25uZWN0ZWRFcnJvciB9IGZyb20gJy4vZXJyb3JzLmpzJztcbmV4cG9ydCB7IEV2ZW50RW1pdHRlciB9O1xuLyoqXG4gKiBBIHdhbGxldCdzIHJlYWRpbmVzcyBkZXNjcmliZXMgYSBzZXJpZXMgb2Ygc3RhdGVzIHRoYXQgdGhlIHdhbGxldCBjYW4gYmUgaW4sXG4gKiBkZXBlbmRpbmcgb24gd2hhdCBraW5kIG9mIHdhbGxldCBpdCBpcy4gQW4gaW5zdGFsbGFibGUgd2FsbGV0IChlZy4gYSBicm93c2VyXG4gKiBleHRlbnNpb24gbGlrZSBQaGFudG9tKSBtaWdodCBiZSBgSW5zdGFsbGVkYCBpZiB3ZSd2ZSBmb3VuZCB0aGUgUGhhbnRvbSBBUElcbiAqIGluIHRoZSBnbG9iYWwgc2NvcGUsIG9yIGBOb3REZXRlY3RlZGAgb3RoZXJ3aXNlLiBBIGxvYWRhYmxlLCB6ZXJvLWluc3RhbGxcbiAqIHJ1bnRpbWUgKGVnLiBUb3J1cyBXYWxsZXQpIG1pZ2h0IHNpbXBseSBzaWduYWwgdGhhdCBpdCdzIGBMb2FkYWJsZWAuIFVzZSB0aGlzXG4gKiBtZXRhZGF0YSB0byBwZXJzb25hbGl6ZSB0aGUgd2FsbGV0IGxpc3QgZm9yIGVhY2ggdXNlciAoZWcuIHRvIHNob3cgdGhlaXJcbiAqIGluc3RhbGxlZCB3YWxsZXRzIGZpcnN0KS5cbiAqL1xuZXhwb3J0IHZhciBXYWxsZXRSZWFkeVN0YXRlO1xuKGZ1bmN0aW9uIChXYWxsZXRSZWFkeVN0YXRlKSB7XG4gICAgLyoqXG4gICAgICogVXNlci1pbnN0YWxsYWJsZSB3YWxsZXRzIGNhbiB0eXBpY2FsbHkgYmUgZGV0ZWN0ZWQgYnkgc2Nhbm5pbmcgZm9yIGFuIEFQSVxuICAgICAqIHRoYXQgdGhleSd2ZSBpbmplY3RlZCBpbnRvIHRoZSBnbG9iYWwgY29udGV4dC4gSWYgc3VjaCBhbiBBUEkgaXMgcHJlc2VudCxcbiAgICAgKiB3ZSBjb25zaWRlciB0aGUgd2FsbGV0IHRvIGhhdmUgYmVlbiBpbnN0YWxsZWQuXG4gICAgICovXG4gICAgV2FsbGV0UmVhZHlTdGF0ZVtcIkluc3RhbGxlZFwiXSA9IFwiSW5zdGFsbGVkXCI7XG4gICAgV2FsbGV0UmVhZHlTdGF0ZVtcIk5vdERldGVjdGVkXCJdID0gXCJOb3REZXRlY3RlZFwiO1xuICAgIC8qKlxuICAgICAqIExvYWRhYmxlIHdhbGxldHMgYXJlIGFsd2F5cyBhdmFpbGFibGUgdG8geW91LiBTaW5jZSB5b3UgY2FuIGxvYWQgdGhlbSBhdFxuICAgICAqIGFueSB0aW1lLCBpdCdzIG1lYW5pbmdsZXNzIHRvIHNheSB0aGF0IHRoZXkgaGF2ZSBiZWVuIGRldGVjdGVkLlxuICAgICAqL1xuICAgIFdhbGxldFJlYWR5U3RhdGVbXCJMb2FkYWJsZVwiXSA9IFwiTG9hZGFibGVcIjtcbiAgICAvKipcbiAgICAgKiBJZiBhIHdhbGxldCBpcyBub3Qgc3VwcG9ydGVkIG9uIGEgZ2l2ZW4gcGxhdGZvcm0gKGVnLiBzZXJ2ZXItcmVuZGVyaW5nLCBvclxuICAgICAqIG1vYmlsZSkgdGhlbiBpdCB3aWxsIHN0YXkgaW4gdGhlIGBVbnN1cHBvcnRlZGAgc3RhdGUuXG4gICAgICovXG4gICAgV2FsbGV0UmVhZHlTdGF0ZVtcIlVuc3VwcG9ydGVkXCJdID0gXCJVbnN1cHBvcnRlZFwiO1xufSkoV2FsbGV0UmVhZHlTdGF0ZSB8fCAoV2FsbGV0UmVhZHlTdGF0ZSA9IHt9KSk7XG5leHBvcnQgY2xhc3MgQmFzZVdhbGxldEFkYXB0ZXIgZXh0ZW5kcyBFdmVudEVtaXR0ZXIge1xuICAgIGdldCBjb25uZWN0ZWQoKSB7XG4gICAgICAgIHJldHVybiAhIXRoaXMucHVibGljS2V5O1xuICAgIH1cbiAgICBhc3luYyBhdXRvQ29ubmVjdCgpIHtcbiAgICAgICAgYXdhaXQgdGhpcy5jb25uZWN0KCk7XG4gICAgfVxuICAgIGFzeW5jIHByZXBhcmVUcmFuc2FjdGlvbih0cmFuc2FjdGlvbiwgY29ubmVjdGlvbiwgb3B0aW9ucyA9IHt9KSB7XG4gICAgICAgIGNvbnN0IHB1YmxpY0tleSA9IHRoaXMucHVibGljS2V5O1xuICAgICAgICBpZiAoIXB1YmxpY0tleSlcbiAgICAgICAgICAgIHRocm93IG5ldyBXYWxsZXROb3RDb25uZWN0ZWRFcnJvcigpO1xuICAgICAgICB0cmFuc2FjdGlvbi5mZWVQYXllciA9IHRyYW5zYWN0aW9uLmZlZVBheWVyIHx8IHB1YmxpY0tleTtcbiAgICAgICAgdHJhbnNhY3Rpb24ucmVjZW50QmxvY2toYXNoID1cbiAgICAgICAgICAgIHRyYW5zYWN0aW9uLnJlY2VudEJsb2NraGFzaCB8fFxuICAgICAgICAgICAgICAgIChhd2FpdCBjb25uZWN0aW9uLmdldExhdGVzdEJsb2NraGFzaCh7XG4gICAgICAgICAgICAgICAgICAgIGNvbW1pdG1lbnQ6IG9wdGlvbnMucHJlZmxpZ2h0Q29tbWl0bWVudCxcbiAgICAgICAgICAgICAgICAgICAgbWluQ29udGV4dFNsb3Q6IG9wdGlvbnMubWluQ29udGV4dFNsb3QsXG4gICAgICAgICAgICAgICAgfSkpLmJsb2NraGFzaDtcbiAgICAgICAgcmV0dXJuIHRyYW5zYWN0aW9uO1xuICAgIH1cbn1cbmV4cG9ydCBmdW5jdGlvbiBzY29wZVBvbGxpbmdEZXRlY3Rpb25TdHJhdGVneShkZXRlY3QpIHtcbiAgICAvLyBFYXJseSByZXR1cm4gd2hlbiBzZXJ2ZXItc2lkZSByZW5kZXJpbmdcbiAgICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcgfHwgdHlwZW9mIGRvY3VtZW50ID09PSAndW5kZWZpbmVkJylcbiAgICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IGRpc3Bvc2VycyA9IFtdO1xuICAgIGZ1bmN0aW9uIGRldGVjdEFuZERpc3Bvc2UoKSB7XG4gICAgICAgIGNvbnN0IGRldGVjdGVkID0gZGV0ZWN0KCk7XG4gICAgICAgIGlmIChkZXRlY3RlZCkge1xuICAgICAgICAgICAgZm9yIChjb25zdCBkaXNwb3NlIG9mIGRpc3Bvc2Vycykge1xuICAgICAgICAgICAgICAgIGRpc3Bvc2UoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBTdHJhdGVneSAjMTogVHJ5IGRldGVjdGluZyBldmVyeSBzZWNvbmQuXG4gICAgY29uc3QgaW50ZXJ2YWwgPSBcbiAgICAvLyBUT0RPOiAjMzM0IFJlcGxhY2Ugd2l0aCBpZGxlIGNhbGxiYWNrIHN0cmF0ZWd5LlxuICAgIHNldEludGVydmFsKGRldGVjdEFuZERpc3Bvc2UsIDEwMDApO1xuICAgIGRpc3Bvc2Vycy5wdXNoKCgpID0+IGNsZWFySW50ZXJ2YWwoaW50ZXJ2YWwpKTtcbiAgICAvLyBTdHJhdGVneSAjMjogRGV0ZWN0IGFzIHNvb24gYXMgdGhlIERPTSBiZWNvbWVzICdyZWFkeScvJ2ludGVyYWN0aXZlJy5cbiAgICBpZiAoXG4gICAgLy8gSW1wbGllcyB0aGF0IGBET01Db250ZW50TG9hZGVkYCBoYXMgbm90IHlldCBmaXJlZC5cbiAgICBkb2N1bWVudC5yZWFkeVN0YXRlID09PSAnbG9hZGluZycpIHtcbiAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignRE9NQ29udGVudExvYWRlZCcsIGRldGVjdEFuZERpc3Bvc2UsIHsgb25jZTogdHJ1ZSB9KTtcbiAgICAgICAgZGlzcG9zZXJzLnB1c2goKCkgPT4gZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignRE9NQ29udGVudExvYWRlZCcsIGRldGVjdEFuZERpc3Bvc2UpKTtcbiAgICB9XG4gICAgLy8gU3RyYXRlZ3kgIzM6IERldGVjdCBhZnRlciB0aGUgYHdpbmRvd2AgaGFzIGZ1bGx5IGxvYWRlZC5cbiAgICBpZiAoXG4gICAgLy8gSWYgdGhlIGBjb21wbGV0ZWAgc3RhdGUgaGFzIGJlZW4gcmVhY2hlZCwgd2UncmUgdG9vIGxhdGUuXG4gICAgZG9jdW1lbnQucmVhZHlTdGF0ZSAhPT0gJ2NvbXBsZXRlJykge1xuICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignbG9hZCcsIGRldGVjdEFuZERpc3Bvc2UsIHsgb25jZTogdHJ1ZSB9KTtcbiAgICAgICAgZGlzcG9zZXJzLnB1c2goKCkgPT4gd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2xvYWQnLCBkZXRlY3RBbmREaXNwb3NlKSk7XG4gICAgfVxuICAgIC8vIFN0cmF0ZWd5ICM0OiBEZXRlY3Qgc3luY2hyb25vdXNseSwgbm93LlxuICAgIGRldGVjdEFuZERpc3Bvc2UoKTtcbn1cbi8qKlxuICogVXNlcnMgb24gaU9TIGNhbiBiZSByZWRpcmVjdGVkIGludG8gYSB3YWxsZXQncyBpbi1hcHAgYnJvd3NlciBhdXRvbWF0aWNhbGx5LFxuICogaWYgdGhhdCB3YWxsZXQgaGFzIGEgdW5pdmVyc2FsIGxpbmsgY29uZmlndXJlZCB0byBkbyBzb1xuICogQnV0IHNob3VsZCBub3QgYmUgcmVkaXJlY3RlZCBmcm9tIHdpdGhpbiBhIHdlYnZpZXcsIGVnLiBpZiB0aGV5J3JlIGFscmVhZHlcbiAqIGluc2lkZSBhIHdhbGxldCdzIGJyb3dzZXJcbiAqIFRoaXMgZnVuY3Rpb24gY2FuIGJlIHVzZWQgdG8gaWRlbnRpZnkgdXNlcnMgd2hvIGFyZSBvbiBpT1MgYW5kIGNhbiBiZSByZWRpcmVjdGVkXG4gKlxuICogQHJldHVybnMgdHJ1ZSBpZiB0aGUgdXNlciBjYW4gYmUgcmVkaXJlY3RlZFxuICovXG5leHBvcnQgZnVuY3Rpb24gaXNJb3NBbmRSZWRpcmVjdGFibGUoKSB7XG4gICAgLy8gU1NSOiByZXR1cm4gZmFsc2VcbiAgICBpZiAoIW5hdmlnYXRvcilcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGNvbnN0IHVzZXJBZ2VudCA9IG5hdmlnYXRvci51c2VyQWdlbnQudG9Mb3dlckNhc2UoKTtcbiAgICAvLyBpZiBvbiBpT1MgdGhlIHVzZXIgYWdlbnQgd2lsbCBjb250YWluIGVpdGhlciBpUGhvbmUgb3IgaVBhZFxuICAgIC8vIGNhdmVhdDogaWYgcmVxdWVzdGluZyBkZXNrdG9wIHNpdGUgdGhlbiB0aGlzIHdvbid0IHdvcmtcbiAgICBjb25zdCBpc0lvcyA9IHVzZXJBZ2VudC5pbmNsdWRlcygnaXBob25lJykgfHwgdXNlckFnZW50LmluY2x1ZGVzKCdpcGFkJyk7XG4gICAgLy8gaWYgaW4gYSB3ZWJ2aWV3IHRoZW4gaXQgd2lsbCBub3QgaW5jbHVkZSBTYWZhcmlcbiAgICAvLyBub3RlIHRoYXQgb3RoZXIgaU9TIGJyb3dzZXJzIGFsc28gaW5jbHVkZSBTYWZhcmlcbiAgICAvLyBzbyB3ZSB3aWxsIHJlZGlyZWN0IG9ubHkgaWYgU2FmYXJpIGlzIGFsc28gaW5jbHVkZWRcbiAgICBjb25zdCBpc1NhZmFyaSA9IHVzZXJBZ2VudC5pbmNsdWRlcygnc2FmYXJpJyk7XG4gICAgcmV0dXJuIGlzSW9zICYmIGlzU2FmYXJpO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YWRhcHRlci5qcy5tYXAiXSwibmFtZXMiOlsiRXZlbnRFbWl0dGVyIiwiV2FsbGV0Tm90Q29ubmVjdGVkRXJyb3IiLCJXYWxsZXRSZWFkeVN0YXRlIiwiQmFzZVdhbGxldEFkYXB0ZXIiLCJjb25uZWN0ZWQiLCJwdWJsaWNLZXkiLCJhdXRvQ29ubmVjdCIsImNvbm5lY3QiLCJwcmVwYXJlVHJhbnNhY3Rpb24iLCJ0cmFuc2FjdGlvbiIsImNvbm5lY3Rpb24iLCJvcHRpb25zIiwiZmVlUGF5ZXIiLCJyZWNlbnRCbG9ja2hhc2giLCJnZXRMYXRlc3RCbG9ja2hhc2giLCJjb21taXRtZW50IiwicHJlZmxpZ2h0Q29tbWl0bWVudCIsIm1pbkNvbnRleHRTbG90IiwiYmxvY2toYXNoIiwic2NvcGVQb2xsaW5nRGV0ZWN0aW9uU3RyYXRlZ3kiLCJkZXRlY3QiLCJkb2N1bWVudCIsImRpc3Bvc2VycyIsImRldGVjdEFuZERpc3Bvc2UiLCJkZXRlY3RlZCIsImRpc3Bvc2UiLCJpbnRlcnZhbCIsInNldEludGVydmFsIiwicHVzaCIsImNsZWFySW50ZXJ2YWwiLCJyZWFkeVN0YXRlIiwiYWRkRXZlbnRMaXN0ZW5lciIsIm9uY2UiLCJyZW1vdmVFdmVudExpc3RlbmVyIiwid2luZG93IiwiaXNJb3NBbmRSZWRpcmVjdGFibGUiLCJuYXZpZ2F0b3IiLCJ1c2VyQWdlbnQiLCJ0b0xvd2VyQ2FzZSIsImlzSW9zIiwiaW5jbHVkZXMiLCJpc1NhZmFyaSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/@solana/wallet-adapter-base/lib/esm/adapter.js\n");

/***/ }),

/***/ "(ssr)/../node_modules/@solana/wallet-adapter-base/lib/esm/errors.js":
/*!*********************************************************************!*\
  !*** ../node_modules/@solana/wallet-adapter-base/lib/esm/errors.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   WalletAccountError: () => (/* binding */ WalletAccountError),\n/* harmony export */   WalletConfigError: () => (/* binding */ WalletConfigError),\n/* harmony export */   WalletConnectionError: () => (/* binding */ WalletConnectionError),\n/* harmony export */   WalletDisconnectedError: () => (/* binding */ WalletDisconnectedError),\n/* harmony export */   WalletDisconnectionError: () => (/* binding */ WalletDisconnectionError),\n/* harmony export */   WalletError: () => (/* binding */ WalletError),\n/* harmony export */   WalletKeypairError: () => (/* binding */ WalletKeypairError),\n/* harmony export */   WalletLoadError: () => (/* binding */ WalletLoadError),\n/* harmony export */   WalletNotConnectedError: () => (/* binding */ WalletNotConnectedError),\n/* harmony export */   WalletNotReadyError: () => (/* binding */ WalletNotReadyError),\n/* harmony export */   WalletPublicKeyError: () => (/* binding */ WalletPublicKeyError),\n/* harmony export */   WalletSendTransactionError: () => (/* binding */ WalletSendTransactionError),\n/* harmony export */   WalletSignInError: () => (/* binding */ WalletSignInError),\n/* harmony export */   WalletSignMessageError: () => (/* binding */ WalletSignMessageError),\n/* harmony export */   WalletSignTransactionError: () => (/* binding */ WalletSignTransactionError),\n/* harmony export */   WalletTimeoutError: () => (/* binding */ WalletTimeoutError),\n/* harmony export */   WalletWindowBlockedError: () => (/* binding */ WalletWindowBlockedError),\n/* harmony export */   WalletWindowClosedError: () => (/* binding */ WalletWindowClosedError)\n/* harmony export */ });\nclass WalletError extends Error {\n    // eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types\n    constructor(message, error){\n        super(message);\n        this.error = error;\n    }\n}\nclass WalletNotReadyError extends WalletError {\n    constructor(){\n        super(...arguments);\n        this.name = \"WalletNotReadyError\";\n    }\n}\nclass WalletLoadError extends WalletError {\n    constructor(){\n        super(...arguments);\n        this.name = \"WalletLoadError\";\n    }\n}\nclass WalletConfigError extends WalletError {\n    constructor(){\n        super(...arguments);\n        this.name = \"WalletConfigError\";\n    }\n}\nclass WalletConnectionError extends WalletError {\n    constructor(){\n        super(...arguments);\n        this.name = \"WalletConnectionError\";\n    }\n}\nclass WalletDisconnectedError extends WalletError {\n    constructor(){\n        super(...arguments);\n        this.name = \"WalletDisconnectedError\";\n    }\n}\nclass WalletDisconnectionError extends WalletError {\n    constructor(){\n        super(...arguments);\n        this.name = \"WalletDisconnectionError\";\n    }\n}\nclass WalletAccountError extends WalletError {\n    constructor(){\n        super(...arguments);\n        this.name = \"WalletAccountError\";\n    }\n}\nclass WalletPublicKeyError extends WalletError {\n    constructor(){\n        super(...arguments);\n        this.name = \"WalletPublicKeyError\";\n    }\n}\nclass WalletKeypairError extends WalletError {\n    constructor(){\n        super(...arguments);\n        this.name = \"WalletKeypairError\";\n    }\n}\nclass WalletNotConnectedError extends WalletError {\n    constructor(){\n        super(...arguments);\n        this.name = \"WalletNotConnectedError\";\n    }\n}\nclass WalletSendTransactionError extends WalletError {\n    constructor(){\n        super(...arguments);\n        this.name = \"WalletSendTransactionError\";\n    }\n}\nclass WalletSignTransactionError extends WalletError {\n    constructor(){\n        super(...arguments);\n        this.name = \"WalletSignTransactionError\";\n    }\n}\nclass WalletSignMessageError extends WalletError {\n    constructor(){\n        super(...arguments);\n        this.name = \"WalletSignMessageError\";\n    }\n}\nclass WalletSignInError extends WalletError {\n    constructor(){\n        super(...arguments);\n        this.name = \"WalletSignInError\";\n    }\n}\nclass WalletTimeoutError extends WalletError {\n    constructor(){\n        super(...arguments);\n        this.name = \"WalletTimeoutError\";\n    }\n}\nclass WalletWindowBlockedError extends WalletError {\n    constructor(){\n        super(...arguments);\n        this.name = \"WalletWindowBlockedError\";\n    }\n}\nclass WalletWindowClosedError extends WalletError {\n    constructor(){\n        super(...arguments);\n        this.name = \"WalletWindowClosedError\";\n    }\n} //# sourceMappingURL=errors.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL0Bzb2xhbmEvd2FsbGV0LWFkYXB0ZXItYmFzZS9saWIvZXNtL2Vycm9ycy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBTyxNQUFNQSxvQkFBb0JDO0lBQzdCLDZFQUE2RTtJQUM3RUMsWUFBWUMsT0FBTyxFQUFFQyxLQUFLLENBQUU7UUFDeEIsS0FBSyxDQUFDRDtRQUNOLElBQUksQ0FBQ0MsS0FBSyxHQUFHQTtJQUNqQjtBQUNKO0FBQ08sTUFBTUMsNEJBQTRCTDtJQUNyQ0UsYUFBYztRQUNWLEtBQUssSUFBSUk7UUFDVCxJQUFJLENBQUNDLElBQUksR0FBRztJQUNoQjtBQUNKO0FBQ08sTUFBTUMsd0JBQXdCUjtJQUNqQ0UsYUFBYztRQUNWLEtBQUssSUFBSUk7UUFDVCxJQUFJLENBQUNDLElBQUksR0FBRztJQUNoQjtBQUNKO0FBQ08sTUFBTUUsMEJBQTBCVDtJQUNuQ0UsYUFBYztRQUNWLEtBQUssSUFBSUk7UUFDVCxJQUFJLENBQUNDLElBQUksR0FBRztJQUNoQjtBQUNKO0FBQ08sTUFBTUcsOEJBQThCVjtJQUN2Q0UsYUFBYztRQUNWLEtBQUssSUFBSUk7UUFDVCxJQUFJLENBQUNDLElBQUksR0FBRztJQUNoQjtBQUNKO0FBQ08sTUFBTUksZ0NBQWdDWDtJQUN6Q0UsYUFBYztRQUNWLEtBQUssSUFBSUk7UUFDVCxJQUFJLENBQUNDLElBQUksR0FBRztJQUNoQjtBQUNKO0FBQ08sTUFBTUssaUNBQWlDWjtJQUMxQ0UsYUFBYztRQUNWLEtBQUssSUFBSUk7UUFDVCxJQUFJLENBQUNDLElBQUksR0FBRztJQUNoQjtBQUNKO0FBQ08sTUFBTU0sMkJBQTJCYjtJQUNwQ0UsYUFBYztRQUNWLEtBQUssSUFBSUk7UUFDVCxJQUFJLENBQUNDLElBQUksR0FBRztJQUNoQjtBQUNKO0FBQ08sTUFBTU8sNkJBQTZCZDtJQUN0Q0UsYUFBYztRQUNWLEtBQUssSUFBSUk7UUFDVCxJQUFJLENBQUNDLElBQUksR0FBRztJQUNoQjtBQUNKO0FBQ08sTUFBTVEsMkJBQTJCZjtJQUNwQ0UsYUFBYztRQUNWLEtBQUssSUFBSUk7UUFDVCxJQUFJLENBQUNDLElBQUksR0FBRztJQUNoQjtBQUNKO0FBQ08sTUFBTVMsZ0NBQWdDaEI7SUFDekNFLGFBQWM7UUFDVixLQUFLLElBQUlJO1FBQ1QsSUFBSSxDQUFDQyxJQUFJLEdBQUc7SUFDaEI7QUFDSjtBQUNPLE1BQU1VLG1DQUFtQ2pCO0lBQzVDRSxhQUFjO1FBQ1YsS0FBSyxJQUFJSTtRQUNULElBQUksQ0FBQ0MsSUFBSSxHQUFHO0lBQ2hCO0FBQ0o7QUFDTyxNQUFNVyxtQ0FBbUNsQjtJQUM1Q0UsYUFBYztRQUNWLEtBQUssSUFBSUk7UUFDVCxJQUFJLENBQUNDLElBQUksR0FBRztJQUNoQjtBQUNKO0FBQ08sTUFBTVksK0JBQStCbkI7SUFDeENFLGFBQWM7UUFDVixLQUFLLElBQUlJO1FBQ1QsSUFBSSxDQUFDQyxJQUFJLEdBQUc7SUFDaEI7QUFDSjtBQUNPLE1BQU1hLDBCQUEwQnBCO0lBQ25DRSxhQUFjO1FBQ1YsS0FBSyxJQUFJSTtRQUNULElBQUksQ0FBQ0MsSUFBSSxHQUFHO0lBQ2hCO0FBQ0o7QUFDTyxNQUFNYywyQkFBMkJyQjtJQUNwQ0UsYUFBYztRQUNWLEtBQUssSUFBSUk7UUFDVCxJQUFJLENBQUNDLElBQUksR0FBRztJQUNoQjtBQUNKO0FBQ08sTUFBTWUsaUNBQWlDdEI7SUFDMUNFLGFBQWM7UUFDVixLQUFLLElBQUlJO1FBQ1QsSUFBSSxDQUFDQyxJQUFJLEdBQUc7SUFDaEI7QUFDSjtBQUNPLE1BQU1nQixnQ0FBZ0N2QjtJQUN6Q0UsYUFBYztRQUNWLEtBQUssSUFBSUk7UUFDVCxJQUFJLENBQUNDLElBQUksR0FBRztJQUNoQjtBQUNKLEVBQ0Esa0NBQWtDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9Ac29sYW5hL3dhbGxldC1hZGFwdGVyLWJhc2UvbGliL2VzbS9lcnJvcnMuanM/OTVlYiJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgY2xhc3MgV2FsbGV0RXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9leHBsaWNpdC1tb2R1bGUtYm91bmRhcnktdHlwZXNcbiAgICBjb25zdHJ1Y3RvcihtZXNzYWdlLCBlcnJvcikge1xuICAgICAgICBzdXBlcihtZXNzYWdlKTtcbiAgICAgICAgdGhpcy5lcnJvciA9IGVycm9yO1xuICAgIH1cbn1cbmV4cG9ydCBjbGFzcyBXYWxsZXROb3RSZWFkeUVycm9yIGV4dGVuZHMgV2FsbGV0RXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgICAgICB0aGlzLm5hbWUgPSAnV2FsbGV0Tm90UmVhZHlFcnJvcic7XG4gICAgfVxufVxuZXhwb3J0IGNsYXNzIFdhbGxldExvYWRFcnJvciBleHRlbmRzIFdhbGxldEVycm9yIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICAgICAgdGhpcy5uYW1lID0gJ1dhbGxldExvYWRFcnJvcic7XG4gICAgfVxufVxuZXhwb3J0IGNsYXNzIFdhbGxldENvbmZpZ0Vycm9yIGV4dGVuZHMgV2FsbGV0RXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgICAgICB0aGlzLm5hbWUgPSAnV2FsbGV0Q29uZmlnRXJyb3InO1xuICAgIH1cbn1cbmV4cG9ydCBjbGFzcyBXYWxsZXRDb25uZWN0aW9uRXJyb3IgZXh0ZW5kcyBXYWxsZXRFcnJvciB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgICAgIHRoaXMubmFtZSA9ICdXYWxsZXRDb25uZWN0aW9uRXJyb3InO1xuICAgIH1cbn1cbmV4cG9ydCBjbGFzcyBXYWxsZXREaXNjb25uZWN0ZWRFcnJvciBleHRlbmRzIFdhbGxldEVycm9yIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICAgICAgdGhpcy5uYW1lID0gJ1dhbGxldERpc2Nvbm5lY3RlZEVycm9yJztcbiAgICB9XG59XG5leHBvcnQgY2xhc3MgV2FsbGV0RGlzY29ubmVjdGlvbkVycm9yIGV4dGVuZHMgV2FsbGV0RXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgICAgICB0aGlzLm5hbWUgPSAnV2FsbGV0RGlzY29ubmVjdGlvbkVycm9yJztcbiAgICB9XG59XG5leHBvcnQgY2xhc3MgV2FsbGV0QWNjb3VudEVycm9yIGV4dGVuZHMgV2FsbGV0RXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgICAgICB0aGlzLm5hbWUgPSAnV2FsbGV0QWNjb3VudEVycm9yJztcbiAgICB9XG59XG5leHBvcnQgY2xhc3MgV2FsbGV0UHVibGljS2V5RXJyb3IgZXh0ZW5kcyBXYWxsZXRFcnJvciB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgICAgIHRoaXMubmFtZSA9ICdXYWxsZXRQdWJsaWNLZXlFcnJvcic7XG4gICAgfVxufVxuZXhwb3J0IGNsYXNzIFdhbGxldEtleXBhaXJFcnJvciBleHRlbmRzIFdhbGxldEVycm9yIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICAgICAgdGhpcy5uYW1lID0gJ1dhbGxldEtleXBhaXJFcnJvcic7XG4gICAgfVxufVxuZXhwb3J0IGNsYXNzIFdhbGxldE5vdENvbm5lY3RlZEVycm9yIGV4dGVuZHMgV2FsbGV0RXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgICAgICB0aGlzLm5hbWUgPSAnV2FsbGV0Tm90Q29ubmVjdGVkRXJyb3InO1xuICAgIH1cbn1cbmV4cG9ydCBjbGFzcyBXYWxsZXRTZW5kVHJhbnNhY3Rpb25FcnJvciBleHRlbmRzIFdhbGxldEVycm9yIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICAgICAgdGhpcy5uYW1lID0gJ1dhbGxldFNlbmRUcmFuc2FjdGlvbkVycm9yJztcbiAgICB9XG59XG5leHBvcnQgY2xhc3MgV2FsbGV0U2lnblRyYW5zYWN0aW9uRXJyb3IgZXh0ZW5kcyBXYWxsZXRFcnJvciB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgICAgIHRoaXMubmFtZSA9ICdXYWxsZXRTaWduVHJhbnNhY3Rpb25FcnJvcic7XG4gICAgfVxufVxuZXhwb3J0IGNsYXNzIFdhbGxldFNpZ25NZXNzYWdlRXJyb3IgZXh0ZW5kcyBXYWxsZXRFcnJvciB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgICAgIHRoaXMubmFtZSA9ICdXYWxsZXRTaWduTWVzc2FnZUVycm9yJztcbiAgICB9XG59XG5leHBvcnQgY2xhc3MgV2FsbGV0U2lnbkluRXJyb3IgZXh0ZW5kcyBXYWxsZXRFcnJvciB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgICAgIHRoaXMubmFtZSA9ICdXYWxsZXRTaWduSW5FcnJvcic7XG4gICAgfVxufVxuZXhwb3J0IGNsYXNzIFdhbGxldFRpbWVvdXRFcnJvciBleHRlbmRzIFdhbGxldEVycm9yIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICAgICAgdGhpcy5uYW1lID0gJ1dhbGxldFRpbWVvdXRFcnJvcic7XG4gICAgfVxufVxuZXhwb3J0IGNsYXNzIFdhbGxldFdpbmRvd0Jsb2NrZWRFcnJvciBleHRlbmRzIFdhbGxldEVycm9yIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICAgICAgdGhpcy5uYW1lID0gJ1dhbGxldFdpbmRvd0Jsb2NrZWRFcnJvcic7XG4gICAgfVxufVxuZXhwb3J0IGNsYXNzIFdhbGxldFdpbmRvd0Nsb3NlZEVycm9yIGV4dGVuZHMgV2FsbGV0RXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgICAgICB0aGlzLm5hbWUgPSAnV2FsbGV0V2luZG93Q2xvc2VkRXJyb3InO1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWVycm9ycy5qcy5tYXAiXSwibmFtZXMiOlsiV2FsbGV0RXJyb3IiLCJFcnJvciIsImNvbnN0cnVjdG9yIiwibWVzc2FnZSIsImVycm9yIiwiV2FsbGV0Tm90UmVhZHlFcnJvciIsImFyZ3VtZW50cyIsIm5hbWUiLCJXYWxsZXRMb2FkRXJyb3IiLCJXYWxsZXRDb25maWdFcnJvciIsIldhbGxldENvbm5lY3Rpb25FcnJvciIsIldhbGxldERpc2Nvbm5lY3RlZEVycm9yIiwiV2FsbGV0RGlzY29ubmVjdGlvbkVycm9yIiwiV2FsbGV0QWNjb3VudEVycm9yIiwiV2FsbGV0UHVibGljS2V5RXJyb3IiLCJXYWxsZXRLZXlwYWlyRXJyb3IiLCJXYWxsZXROb3RDb25uZWN0ZWRFcnJvciIsIldhbGxldFNlbmRUcmFuc2FjdGlvbkVycm9yIiwiV2FsbGV0U2lnblRyYW5zYWN0aW9uRXJyb3IiLCJXYWxsZXRTaWduTWVzc2FnZUVycm9yIiwiV2FsbGV0U2lnbkluRXJyb3IiLCJXYWxsZXRUaW1lb3V0RXJyb3IiLCJXYWxsZXRXaW5kb3dCbG9ja2VkRXJyb3IiLCJXYWxsZXRXaW5kb3dDbG9zZWRFcnJvciJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/@solana/wallet-adapter-base/lib/esm/errors.js\n");

/***/ }),

/***/ "(ssr)/../node_modules/@solana/wallet-adapter-base/lib/esm/signer.js":
/*!*********************************************************************!*\
  !*** ../node_modules/@solana/wallet-adapter-base/lib/esm/signer.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BaseMessageSignerWalletAdapter: () => (/* binding */ BaseMessageSignerWalletAdapter),\n/* harmony export */   BaseSignInMessageSignerWalletAdapter: () => (/* binding */ BaseSignInMessageSignerWalletAdapter),\n/* harmony export */   BaseSignerWalletAdapter: () => (/* binding */ BaseSignerWalletAdapter)\n/* harmony export */ });\n/* harmony import */ var _adapter_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./adapter.js */ \"(ssr)/../node_modules/@solana/wallet-adapter-base/lib/esm/adapter.js\");\n/* harmony import */ var _errors_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./errors.js */ \"(ssr)/../node_modules/@solana/wallet-adapter-base/lib/esm/errors.js\");\n/* harmony import */ var _transaction_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./transaction.js */ \"(ssr)/../node_modules/@solana/wallet-adapter-base/lib/esm/transaction.js\");\n\n\n\nclass BaseSignerWalletAdapter extends _adapter_js__WEBPACK_IMPORTED_MODULE_0__.BaseWalletAdapter {\n    async sendTransaction(transaction, connection, options = {}) {\n        let emit = true;\n        try {\n            if ((0,_transaction_js__WEBPACK_IMPORTED_MODULE_1__.isVersionedTransaction)(transaction)) {\n                if (!this.supportedTransactionVersions) throw new _errors_js__WEBPACK_IMPORTED_MODULE_2__.WalletSendTransactionError(`Sending versioned transactions isn't supported by this wallet`);\n                if (!this.supportedTransactionVersions.has(transaction.version)) throw new _errors_js__WEBPACK_IMPORTED_MODULE_2__.WalletSendTransactionError(`Sending transaction version ${transaction.version} isn't supported by this wallet`);\n                try {\n                    transaction = await this.signTransaction(transaction);\n                    const rawTransaction = transaction.serialize();\n                    return await connection.sendRawTransaction(rawTransaction, options);\n                } catch (error) {\n                    // If the error was thrown by `signTransaction`, rethrow it and don't emit a duplicate event\n                    if (error instanceof _errors_js__WEBPACK_IMPORTED_MODULE_2__.WalletSignTransactionError) {\n                        emit = false;\n                        throw error;\n                    }\n                    throw new _errors_js__WEBPACK_IMPORTED_MODULE_2__.WalletSendTransactionError(error?.message, error);\n                }\n            } else {\n                try {\n                    const { signers, ...sendOptions } = options;\n                    transaction = await this.prepareTransaction(transaction, connection, sendOptions);\n                    signers?.length && transaction.partialSign(...signers);\n                    transaction = await this.signTransaction(transaction);\n                    const rawTransaction = transaction.serialize();\n                    return await connection.sendRawTransaction(rawTransaction, sendOptions);\n                } catch (error) {\n                    // If the error was thrown by `signTransaction`, rethrow it and don't emit a duplicate event\n                    if (error instanceof _errors_js__WEBPACK_IMPORTED_MODULE_2__.WalletSignTransactionError) {\n                        emit = false;\n                        throw error;\n                    }\n                    throw new _errors_js__WEBPACK_IMPORTED_MODULE_2__.WalletSendTransactionError(error?.message, error);\n                }\n            }\n        } catch (error) {\n            if (emit) {\n                this.emit(\"error\", error);\n            }\n            throw error;\n        }\n    }\n    async signAllTransactions(transactions) {\n        for (const transaction of transactions){\n            if ((0,_transaction_js__WEBPACK_IMPORTED_MODULE_1__.isVersionedTransaction)(transaction)) {\n                if (!this.supportedTransactionVersions) throw new _errors_js__WEBPACK_IMPORTED_MODULE_2__.WalletSignTransactionError(`Signing versioned transactions isn't supported by this wallet`);\n                if (!this.supportedTransactionVersions.has(transaction.version)) throw new _errors_js__WEBPACK_IMPORTED_MODULE_2__.WalletSignTransactionError(`Signing transaction version ${transaction.version} isn't supported by this wallet`);\n            }\n        }\n        const signedTransactions = [];\n        for (const transaction of transactions){\n            signedTransactions.push(await this.signTransaction(transaction));\n        }\n        return signedTransactions;\n    }\n}\nclass BaseMessageSignerWalletAdapter extends BaseSignerWalletAdapter {\n}\nclass BaseSignInMessageSignerWalletAdapter extends BaseMessageSignerWalletAdapter {\n} //# sourceMappingURL=signer.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL0Bzb2xhbmEvd2FsbGV0LWFkYXB0ZXItYmFzZS9saWIvZXNtL3NpZ25lci5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7QUFBa0Q7QUFDbUM7QUFDM0I7QUFDbkQsTUFBTUksZ0NBQWdDSiwwREFBaUJBO0lBQzFELE1BQU1LLGdCQUFnQkMsV0FBVyxFQUFFQyxVQUFVLEVBQUVDLFVBQVUsQ0FBQyxDQUFDLEVBQUU7UUFDekQsSUFBSUMsT0FBTztRQUNYLElBQUk7WUFDQSxJQUFJTix1RUFBc0JBLENBQUNHLGNBQWM7Z0JBQ3JDLElBQUksQ0FBQyxJQUFJLENBQUNJLDRCQUE0QixFQUNsQyxNQUFNLElBQUlULGtFQUEwQkEsQ0FBQyxDQUFDLDZEQUE2RCxDQUFDO2dCQUN4RyxJQUFJLENBQUMsSUFBSSxDQUFDUyw0QkFBNEIsQ0FBQ0MsR0FBRyxDQUFDTCxZQUFZTSxPQUFPLEdBQzFELE1BQU0sSUFBSVgsa0VBQTBCQSxDQUFDLENBQUMsNEJBQTRCLEVBQUVLLFlBQVlNLE9BQU8sQ0FBQywrQkFBK0IsQ0FBQztnQkFDNUgsSUFBSTtvQkFDQU4sY0FBYyxNQUFNLElBQUksQ0FBQ08sZUFBZSxDQUFDUDtvQkFDekMsTUFBTVEsaUJBQWlCUixZQUFZUyxTQUFTO29CQUM1QyxPQUFPLE1BQU1SLFdBQVdTLGtCQUFrQixDQUFDRixnQkFBZ0JOO2dCQUMvRCxFQUNBLE9BQU9TLE9BQU87b0JBQ1YsNEZBQTRGO29CQUM1RixJQUFJQSxpQkFBaUJmLGtFQUEwQkEsRUFBRTt3QkFDN0NPLE9BQU87d0JBQ1AsTUFBTVE7b0JBQ1Y7b0JBQ0EsTUFBTSxJQUFJaEIsa0VBQTBCQSxDQUFDZ0IsT0FBT0MsU0FBU0Q7Z0JBQ3pEO1lBQ0osT0FDSztnQkFDRCxJQUFJO29CQUNBLE1BQU0sRUFBRUUsT0FBTyxFQUFFLEdBQUdDLGFBQWEsR0FBR1o7b0JBQ3BDRixjQUFjLE1BQU0sSUFBSSxDQUFDZSxrQkFBa0IsQ0FBQ2YsYUFBYUMsWUFBWWE7b0JBQ3JFRCxTQUFTRyxVQUFVaEIsWUFBWWlCLFdBQVcsSUFBSUo7b0JBQzlDYixjQUFjLE1BQU0sSUFBSSxDQUFDTyxlQUFlLENBQUNQO29CQUN6QyxNQUFNUSxpQkFBaUJSLFlBQVlTLFNBQVM7b0JBQzVDLE9BQU8sTUFBTVIsV0FBV1Msa0JBQWtCLENBQUNGLGdCQUFnQk07Z0JBQy9ELEVBQ0EsT0FBT0gsT0FBTztvQkFDViw0RkFBNEY7b0JBQzVGLElBQUlBLGlCQUFpQmYsa0VBQTBCQSxFQUFFO3dCQUM3Q08sT0FBTzt3QkFDUCxNQUFNUTtvQkFDVjtvQkFDQSxNQUFNLElBQUloQixrRUFBMEJBLENBQUNnQixPQUFPQyxTQUFTRDtnQkFDekQ7WUFDSjtRQUNKLEVBQ0EsT0FBT0EsT0FBTztZQUNWLElBQUlSLE1BQU07Z0JBQ04sSUFBSSxDQUFDQSxJQUFJLENBQUMsU0FBU1E7WUFDdkI7WUFDQSxNQUFNQTtRQUNWO0lBQ0o7SUFDQSxNQUFNTyxvQkFBb0JDLFlBQVksRUFBRTtRQUNwQyxLQUFLLE1BQU1uQixlQUFlbUIsYUFBYztZQUNwQyxJQUFJdEIsdUVBQXNCQSxDQUFDRyxjQUFjO2dCQUNyQyxJQUFJLENBQUMsSUFBSSxDQUFDSSw0QkFBNEIsRUFDbEMsTUFBTSxJQUFJUixrRUFBMEJBLENBQUMsQ0FBQyw2REFBNkQsQ0FBQztnQkFDeEcsSUFBSSxDQUFDLElBQUksQ0FBQ1EsNEJBQTRCLENBQUNDLEdBQUcsQ0FBQ0wsWUFBWU0sT0FBTyxHQUMxRCxNQUFNLElBQUlWLGtFQUEwQkEsQ0FBQyxDQUFDLDRCQUE0QixFQUFFSSxZQUFZTSxPQUFPLENBQUMsK0JBQStCLENBQUM7WUFDaEk7UUFDSjtRQUNBLE1BQU1jLHFCQUFxQixFQUFFO1FBQzdCLEtBQUssTUFBTXBCLGVBQWVtQixhQUFjO1lBQ3BDQyxtQkFBbUJDLElBQUksQ0FBQyxNQUFNLElBQUksQ0FBQ2QsZUFBZSxDQUFDUDtRQUN2RDtRQUNBLE9BQU9vQjtJQUNYO0FBQ0o7QUFDTyxNQUFNRSx1Q0FBdUN4QjtBQUNwRDtBQUNPLE1BQU15Qiw2Q0FBNkNEO0FBQzFELEVBQ0Esa0NBQWtDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9Ac29sYW5hL3dhbGxldC1hZGFwdGVyLWJhc2UvbGliL2VzbS9zaWduZXIuanM/NDA0NyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBCYXNlV2FsbGV0QWRhcHRlciwgfSBmcm9tICcuL2FkYXB0ZXIuanMnO1xuaW1wb3J0IHsgV2FsbGV0U2VuZFRyYW5zYWN0aW9uRXJyb3IsIFdhbGxldFNpZ25UcmFuc2FjdGlvbkVycm9yIH0gZnJvbSAnLi9lcnJvcnMuanMnO1xuaW1wb3J0IHsgaXNWZXJzaW9uZWRUcmFuc2FjdGlvbiB9IGZyb20gJy4vdHJhbnNhY3Rpb24uanMnO1xuZXhwb3J0IGNsYXNzIEJhc2VTaWduZXJXYWxsZXRBZGFwdGVyIGV4dGVuZHMgQmFzZVdhbGxldEFkYXB0ZXIge1xuICAgIGFzeW5jIHNlbmRUcmFuc2FjdGlvbih0cmFuc2FjdGlvbiwgY29ubmVjdGlvbiwgb3B0aW9ucyA9IHt9KSB7XG4gICAgICAgIGxldCBlbWl0ID0gdHJ1ZTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGlmIChpc1ZlcnNpb25lZFRyYW5zYWN0aW9uKHRyYW5zYWN0aW9uKSkge1xuICAgICAgICAgICAgICAgIGlmICghdGhpcy5zdXBwb3J0ZWRUcmFuc2FjdGlvblZlcnNpb25zKVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgV2FsbGV0U2VuZFRyYW5zYWN0aW9uRXJyb3IoYFNlbmRpbmcgdmVyc2lvbmVkIHRyYW5zYWN0aW9ucyBpc24ndCBzdXBwb3J0ZWQgYnkgdGhpcyB3YWxsZXRgKTtcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuc3VwcG9ydGVkVHJhbnNhY3Rpb25WZXJzaW9ucy5oYXModHJhbnNhY3Rpb24udmVyc2lvbikpXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBXYWxsZXRTZW5kVHJhbnNhY3Rpb25FcnJvcihgU2VuZGluZyB0cmFuc2FjdGlvbiB2ZXJzaW9uICR7dHJhbnNhY3Rpb24udmVyc2lvbn0gaXNuJ3Qgc3VwcG9ydGVkIGJ5IHRoaXMgd2FsbGV0YCk7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgdHJhbnNhY3Rpb24gPSBhd2FpdCB0aGlzLnNpZ25UcmFuc2FjdGlvbih0cmFuc2FjdGlvbik7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJhd1RyYW5zYWN0aW9uID0gdHJhbnNhY3Rpb24uc2VyaWFsaXplKCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBhd2FpdCBjb25uZWN0aW9uLnNlbmRSYXdUcmFuc2FjdGlvbihyYXdUcmFuc2FjdGlvbiwgb3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICAvLyBJZiB0aGUgZXJyb3Igd2FzIHRocm93biBieSBgc2lnblRyYW5zYWN0aW9uYCwgcmV0aHJvdyBpdCBhbmQgZG9uJ3QgZW1pdCBhIGR1cGxpY2F0ZSBldmVudFxuICAgICAgICAgICAgICAgICAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBXYWxsZXRTaWduVHJhbnNhY3Rpb25FcnJvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgZW1pdCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFdhbGxldFNlbmRUcmFuc2FjdGlvbkVycm9yKGVycm9yPy5tZXNzYWdlLCBlcnJvcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgeyBzaWduZXJzLCAuLi5zZW5kT3B0aW9ucyB9ID0gb3B0aW9ucztcbiAgICAgICAgICAgICAgICAgICAgdHJhbnNhY3Rpb24gPSBhd2FpdCB0aGlzLnByZXBhcmVUcmFuc2FjdGlvbih0cmFuc2FjdGlvbiwgY29ubmVjdGlvbiwgc2VuZE9wdGlvbnMpO1xuICAgICAgICAgICAgICAgICAgICBzaWduZXJzPy5sZW5ndGggJiYgdHJhbnNhY3Rpb24ucGFydGlhbFNpZ24oLi4uc2lnbmVycyk7XG4gICAgICAgICAgICAgICAgICAgIHRyYW5zYWN0aW9uID0gYXdhaXQgdGhpcy5zaWduVHJhbnNhY3Rpb24odHJhbnNhY3Rpb24pO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCByYXdUcmFuc2FjdGlvbiA9IHRyYW5zYWN0aW9uLnNlcmlhbGl6ZSgpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYXdhaXQgY29ubmVjdGlvbi5zZW5kUmF3VHJhbnNhY3Rpb24ocmF3VHJhbnNhY3Rpb24sIHNlbmRPcHRpb25zKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIElmIHRoZSBlcnJvciB3YXMgdGhyb3duIGJ5IGBzaWduVHJhbnNhY3Rpb25gLCByZXRocm93IGl0IGFuZCBkb24ndCBlbWl0IGEgZHVwbGljYXRlIGV2ZW50XG4gICAgICAgICAgICAgICAgICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIFdhbGxldFNpZ25UcmFuc2FjdGlvbkVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlbWl0ID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgV2FsbGV0U2VuZFRyYW5zYWN0aW9uRXJyb3IoZXJyb3I/Lm1lc3NhZ2UsIGVycm9yKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBpZiAoZW1pdCkge1xuICAgICAgICAgICAgICAgIHRoaXMuZW1pdCgnZXJyb3InLCBlcnJvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3luYyBzaWduQWxsVHJhbnNhY3Rpb25zKHRyYW5zYWN0aW9ucykge1xuICAgICAgICBmb3IgKGNvbnN0IHRyYW5zYWN0aW9uIG9mIHRyYW5zYWN0aW9ucykge1xuICAgICAgICAgICAgaWYgKGlzVmVyc2lvbmVkVHJhbnNhY3Rpb24odHJhbnNhY3Rpb24pKSB7XG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLnN1cHBvcnRlZFRyYW5zYWN0aW9uVmVyc2lvbnMpXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBXYWxsZXRTaWduVHJhbnNhY3Rpb25FcnJvcihgU2lnbmluZyB2ZXJzaW9uZWQgdHJhbnNhY3Rpb25zIGlzbid0IHN1cHBvcnRlZCBieSB0aGlzIHdhbGxldGApO1xuICAgICAgICAgICAgICAgIGlmICghdGhpcy5zdXBwb3J0ZWRUcmFuc2FjdGlvblZlcnNpb25zLmhhcyh0cmFuc2FjdGlvbi52ZXJzaW9uKSlcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFdhbGxldFNpZ25UcmFuc2FjdGlvbkVycm9yKGBTaWduaW5nIHRyYW5zYWN0aW9uIHZlcnNpb24gJHt0cmFuc2FjdGlvbi52ZXJzaW9ufSBpc24ndCBzdXBwb3J0ZWQgYnkgdGhpcyB3YWxsZXRgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzaWduZWRUcmFuc2FjdGlvbnMgPSBbXTtcbiAgICAgICAgZm9yIChjb25zdCB0cmFuc2FjdGlvbiBvZiB0cmFuc2FjdGlvbnMpIHtcbiAgICAgICAgICAgIHNpZ25lZFRyYW5zYWN0aW9ucy5wdXNoKGF3YWl0IHRoaXMuc2lnblRyYW5zYWN0aW9uKHRyYW5zYWN0aW9uKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHNpZ25lZFRyYW5zYWN0aW9ucztcbiAgICB9XG59XG5leHBvcnQgY2xhc3MgQmFzZU1lc3NhZ2VTaWduZXJXYWxsZXRBZGFwdGVyIGV4dGVuZHMgQmFzZVNpZ25lcldhbGxldEFkYXB0ZXIge1xufVxuZXhwb3J0IGNsYXNzIEJhc2VTaWduSW5NZXNzYWdlU2lnbmVyV2FsbGV0QWRhcHRlciBleHRlbmRzIEJhc2VNZXNzYWdlU2lnbmVyV2FsbGV0QWRhcHRlciB7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zaWduZXIuanMubWFwIl0sIm5hbWVzIjpbIkJhc2VXYWxsZXRBZGFwdGVyIiwiV2FsbGV0U2VuZFRyYW5zYWN0aW9uRXJyb3IiLCJXYWxsZXRTaWduVHJhbnNhY3Rpb25FcnJvciIsImlzVmVyc2lvbmVkVHJhbnNhY3Rpb24iLCJCYXNlU2lnbmVyV2FsbGV0QWRhcHRlciIsInNlbmRUcmFuc2FjdGlvbiIsInRyYW5zYWN0aW9uIiwiY29ubmVjdGlvbiIsIm9wdGlvbnMiLCJlbWl0Iiwic3VwcG9ydGVkVHJhbnNhY3Rpb25WZXJzaW9ucyIsImhhcyIsInZlcnNpb24iLCJzaWduVHJhbnNhY3Rpb24iLCJyYXdUcmFuc2FjdGlvbiIsInNlcmlhbGl6ZSIsInNlbmRSYXdUcmFuc2FjdGlvbiIsImVycm9yIiwibWVzc2FnZSIsInNpZ25lcnMiLCJzZW5kT3B0aW9ucyIsInByZXBhcmVUcmFuc2FjdGlvbiIsImxlbmd0aCIsInBhcnRpYWxTaWduIiwic2lnbkFsbFRyYW5zYWN0aW9ucyIsInRyYW5zYWN0aW9ucyIsInNpZ25lZFRyYW5zYWN0aW9ucyIsInB1c2giLCJCYXNlTWVzc2FnZVNpZ25lcldhbGxldEFkYXB0ZXIiLCJCYXNlU2lnbkluTWVzc2FnZVNpZ25lcldhbGxldEFkYXB0ZXIiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/@solana/wallet-adapter-base/lib/esm/signer.js\n");

/***/ }),

/***/ "(ssr)/../node_modules/@solana/wallet-adapter-base/lib/esm/standard.js":
/*!***********************************************************************!*\
  !*** ../node_modules/@solana/wallet-adapter-base/lib/esm/standard.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   isWalletAdapterCompatibleStandardWallet: () => (/* binding */ isWalletAdapterCompatibleStandardWallet)\n/* harmony export */ });\n/* harmony import */ var _solana_wallet_standard_features__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @solana/wallet-standard-features */ \"(ssr)/../node_modules/@solana/wallet-standard-features/lib/esm/signAndSendTransaction.js\");\n/* harmony import */ var _solana_wallet_standard_features__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @solana/wallet-standard-features */ \"(ssr)/../node_modules/@solana/wallet-standard-features/lib/esm/signTransaction.js\");\n/* harmony import */ var _wallet_standard_features__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @wallet-standard/features */ \"(ssr)/../node_modules/@wallet-standard/features/lib/esm/connect.js\");\n/* harmony import */ var _wallet_standard_features__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @wallet-standard/features */ \"(ssr)/../node_modules/@wallet-standard/features/lib/esm/events.js\");\n\n\nfunction isWalletAdapterCompatibleStandardWallet(wallet) {\n    return _wallet_standard_features__WEBPACK_IMPORTED_MODULE_0__.StandardConnect in wallet.features && _wallet_standard_features__WEBPACK_IMPORTED_MODULE_1__.StandardEvents in wallet.features && (_solana_wallet_standard_features__WEBPACK_IMPORTED_MODULE_2__.SolanaSignAndSendTransaction in wallet.features || _solana_wallet_standard_features__WEBPACK_IMPORTED_MODULE_3__.SolanaSignTransaction in wallet.features);\n} //# sourceMappingURL=standard.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL0Bzb2xhbmEvd2FsbGV0LWFkYXB0ZXItYmFzZS9saWIvZXNtL3N0YW5kYXJkLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBQXdHO0FBQzNCO0FBQ3RFLFNBQVNJLHdDQUF3Q0MsTUFBTTtJQUMxRCxPQUFRSCxzRUFBZUEsSUFBSUcsT0FBT0MsUUFBUSxJQUN0Q0gscUVBQWNBLElBQUlFLE9BQU9DLFFBQVEsSUFDaENOLENBQUFBLDBGQUE0QkEsSUFBSUssT0FBT0MsUUFBUSxJQUFJTCxtRkFBcUJBLElBQUlJLE9BQU9DLFFBQVE7QUFDcEcsRUFDQSxvQ0FBb0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL0Bzb2xhbmEvd2FsbGV0LWFkYXB0ZXItYmFzZS9saWIvZXNtL3N0YW5kYXJkLmpzPzM5ZjYiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgU29sYW5hU2lnbkFuZFNlbmRUcmFuc2FjdGlvbiwgU29sYW5hU2lnblRyYW5zYWN0aW9uLCB9IGZyb20gJ0Bzb2xhbmEvd2FsbGV0LXN0YW5kYXJkLWZlYXR1cmVzJztcbmltcG9ydCB7IFN0YW5kYXJkQ29ubmVjdCwgU3RhbmRhcmRFdmVudHMsIH0gZnJvbSAnQHdhbGxldC1zdGFuZGFyZC9mZWF0dXJlcyc7XG5leHBvcnQgZnVuY3Rpb24gaXNXYWxsZXRBZGFwdGVyQ29tcGF0aWJsZVN0YW5kYXJkV2FsbGV0KHdhbGxldCkge1xuICAgIHJldHVybiAoU3RhbmRhcmRDb25uZWN0IGluIHdhbGxldC5mZWF0dXJlcyAmJlxuICAgICAgICBTdGFuZGFyZEV2ZW50cyBpbiB3YWxsZXQuZmVhdHVyZXMgJiZcbiAgICAgICAgKFNvbGFuYVNpZ25BbmRTZW5kVHJhbnNhY3Rpb24gaW4gd2FsbGV0LmZlYXR1cmVzIHx8IFNvbGFuYVNpZ25UcmFuc2FjdGlvbiBpbiB3YWxsZXQuZmVhdHVyZXMpKTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXN0YW5kYXJkLmpzLm1hcCJdLCJuYW1lcyI6WyJTb2xhbmFTaWduQW5kU2VuZFRyYW5zYWN0aW9uIiwiU29sYW5hU2lnblRyYW5zYWN0aW9uIiwiU3RhbmRhcmRDb25uZWN0IiwiU3RhbmRhcmRFdmVudHMiLCJpc1dhbGxldEFkYXB0ZXJDb21wYXRpYmxlU3RhbmRhcmRXYWxsZXQiLCJ3YWxsZXQiLCJmZWF0dXJlcyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/@solana/wallet-adapter-base/lib/esm/standard.js\n");

/***/ }),

/***/ "(ssr)/../node_modules/@solana/wallet-adapter-base/lib/esm/transaction.js":
/*!**************************************************************************!*\
  !*** ../node_modules/@solana/wallet-adapter-base/lib/esm/transaction.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   isVersionedTransaction: () => (/* binding */ isVersionedTransaction)\n/* harmony export */ });\nfunction isVersionedTransaction(transaction) {\n    return \"version\" in transaction;\n} //# sourceMappingURL=transaction.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL0Bzb2xhbmEvd2FsbGV0LWFkYXB0ZXItYmFzZS9saWIvZXNtL3RyYW5zYWN0aW9uLmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBTyxTQUFTQSx1QkFBdUJDLFdBQVc7SUFDOUMsT0FBTyxhQUFhQTtBQUN4QixFQUNBLHVDQUF1QyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvQHNvbGFuYS93YWxsZXQtYWRhcHRlci1iYXNlL2xpYi9lc20vdHJhbnNhY3Rpb24uanM/MDUwMCJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgZnVuY3Rpb24gaXNWZXJzaW9uZWRUcmFuc2FjdGlvbih0cmFuc2FjdGlvbikge1xuICAgIHJldHVybiAndmVyc2lvbicgaW4gdHJhbnNhY3Rpb247XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD10cmFuc2FjdGlvbi5qcy5tYXAiXSwibmFtZXMiOlsiaXNWZXJzaW9uZWRUcmFuc2FjdGlvbiIsInRyYW5zYWN0aW9uIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/@solana/wallet-adapter-base/lib/esm/transaction.js\n");

/***/ }),

/***/ "(ssr)/../node_modules/@solana/wallet-adapter-react-ui/lib/esm/Button.js":
/*!*************************************************************************!*\
  !*** ../node_modules/@solana/wallet-adapter-react-ui/lib/esm/Button.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Button: () => (/* binding */ Button)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/../node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n\nconst Button = (props)=>{\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"button\", {\n        className: `wallet-adapter-button ${props.className || \"\"}`,\n        disabled: props.disabled,\n        style: props.style,\n        onClick: props.onClick,\n        tabIndex: props.tabIndex || 0,\n        type: \"button\"\n    }, props.startIcon && /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"i\", {\n        className: \"wallet-adapter-button-start-icon\"\n    }, props.startIcon), props.children, props.endIcon && /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"i\", {\n        className: \"wallet-adapter-button-end-icon\"\n    }, props.endIcon));\n}; //# sourceMappingURL=Button.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL0Bzb2xhbmEvd2FsbGV0LWFkYXB0ZXItcmVhY3QtdWkvbGliL2VzbS9CdXR0b24uanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBMEI7QUFDbkIsTUFBTUMsU0FBUyxDQUFDQztJQUNuQixxQkFBUUYsZ0RBQW1CLENBQUMsVUFBVTtRQUFFSSxXQUFXLENBQUMsc0JBQXNCLEVBQUVGLE1BQU1FLFNBQVMsSUFBSSxHQUFHLENBQUM7UUFBRUMsVUFBVUgsTUFBTUcsUUFBUTtRQUFFQyxPQUFPSixNQUFNSSxLQUFLO1FBQUVDLFNBQVNMLE1BQU1LLE9BQU87UUFBRUMsVUFBVU4sTUFBTU0sUUFBUSxJQUFJO1FBQUdDLE1BQU07SUFBUyxHQUNyTlAsTUFBTVEsU0FBUyxrQkFBSVYsZ0RBQW1CLENBQUMsS0FBSztRQUFFSSxXQUFXO0lBQW1DLEdBQUdGLE1BQU1RLFNBQVMsR0FDOUdSLE1BQU1TLFFBQVEsRUFDZFQsTUFBTVUsT0FBTyxrQkFBSVosZ0RBQW1CLENBQUMsS0FBSztRQUFFSSxXQUFXO0lBQWlDLEdBQUdGLE1BQU1VLE9BQU87QUFDaEgsRUFBRSxDQUNGLGtDQUFrQyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvQHNvbGFuYS93YWxsZXQtYWRhcHRlci1yZWFjdC11aS9saWIvZXNtL0J1dHRvbi5qcz9lMDFjIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG5leHBvcnQgY29uc3QgQnV0dG9uID0gKHByb3BzKSA9PiB7XG4gICAgcmV0dXJuIChSZWFjdC5jcmVhdGVFbGVtZW50KFwiYnV0dG9uXCIsIHsgY2xhc3NOYW1lOiBgd2FsbGV0LWFkYXB0ZXItYnV0dG9uICR7cHJvcHMuY2xhc3NOYW1lIHx8ICcnfWAsIGRpc2FibGVkOiBwcm9wcy5kaXNhYmxlZCwgc3R5bGU6IHByb3BzLnN0eWxlLCBvbkNsaWNrOiBwcm9wcy5vbkNsaWNrLCB0YWJJbmRleDogcHJvcHMudGFiSW5kZXggfHwgMCwgdHlwZTogXCJidXR0b25cIiB9LFxuICAgICAgICBwcm9wcy5zdGFydEljb24gJiYgUmVhY3QuY3JlYXRlRWxlbWVudChcImlcIiwgeyBjbGFzc05hbWU6IFwid2FsbGV0LWFkYXB0ZXItYnV0dG9uLXN0YXJ0LWljb25cIiB9LCBwcm9wcy5zdGFydEljb24pLFxuICAgICAgICBwcm9wcy5jaGlsZHJlbixcbiAgICAgICAgcHJvcHMuZW5kSWNvbiAmJiBSZWFjdC5jcmVhdGVFbGVtZW50KFwiaVwiLCB7IGNsYXNzTmFtZTogXCJ3YWxsZXQtYWRhcHRlci1idXR0b24tZW5kLWljb25cIiB9LCBwcm9wcy5lbmRJY29uKSkpO1xufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUJ1dHRvbi5qcy5tYXAiXSwibmFtZXMiOlsiUmVhY3QiLCJCdXR0b24iLCJwcm9wcyIsImNyZWF0ZUVsZW1lbnQiLCJjbGFzc05hbWUiLCJkaXNhYmxlZCIsInN0eWxlIiwib25DbGljayIsInRhYkluZGV4IiwidHlwZSIsInN0YXJ0SWNvbiIsImNoaWxkcmVuIiwiZW5kSWNvbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/@solana/wallet-adapter-react-ui/lib/esm/Button.js\n");

/***/ }),

/***/ "(ssr)/../node_modules/@solana/wallet-adapter-react-ui/lib/esm/Collapse.js":
/*!***************************************************************************!*\
  !*** ../node_modules/@solana/wallet-adapter-react-ui/lib/esm/Collapse.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Collapse: () => (/* binding */ Collapse)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/../node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n\nconst Collapse = ({ id, children, expanded = false })=>{\n    const ref = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    const instant = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(true);\n    const transition = \"height 250ms ease-out\";\n    const openCollapse = ()=>{\n        const node = ref.current;\n        if (!node) return;\n        requestAnimationFrame(()=>{\n            node.style.height = node.scrollHeight + \"px\";\n        });\n    };\n    const closeCollapse = ()=>{\n        const node = ref.current;\n        if (!node) return;\n        requestAnimationFrame(()=>{\n            node.style.height = node.offsetHeight + \"px\";\n            node.style.overflow = \"hidden\";\n            requestAnimationFrame(()=>{\n                node.style.height = \"0\";\n            });\n        });\n    };\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect)(()=>{\n        if (expanded) {\n            openCollapse();\n        } else {\n            closeCollapse();\n        }\n    }, [\n        expanded\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect)(()=>{\n        const node = ref.current;\n        if (!node) return;\n        function handleComplete() {\n            if (!node) return;\n            node.style.overflow = expanded ? \"initial\" : \"hidden\";\n            if (expanded) {\n                node.style.height = \"auto\";\n            }\n        }\n        function handleTransitionEnd(event) {\n            if (node && event.target === node && event.propertyName === \"height\") {\n                handleComplete();\n            }\n        }\n        if (instant.current) {\n            handleComplete();\n            instant.current = false;\n        }\n        node.addEventListener(\"transitionend\", handleTransitionEnd);\n        return ()=>node.removeEventListener(\"transitionend\", handleTransitionEnd);\n    }, [\n        expanded\n    ]);\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", {\n        className: \"wallet-adapter-collapse\",\n        id: id,\n        ref: ref,\n        role: \"region\",\n        style: {\n            height: 0,\n            transition: instant.current ? undefined : transition\n        }\n    }, children);\n}; //# sourceMappingURL=Collapse.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL0Bzb2xhbmEvd2FsbGV0LWFkYXB0ZXItcmVhY3QtdWkvbGliL2VzbS9Db2xsYXBzZS5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUF1RDtBQUNoRCxNQUFNRyxXQUFXLENBQUMsRUFBRUMsRUFBRSxFQUFFQyxRQUFRLEVBQUVDLFdBQVcsS0FBSyxFQUFFO0lBQ3ZELE1BQU1DLE1BQU1MLDZDQUFNQSxDQUFDO0lBQ25CLE1BQU1NLFVBQVVOLDZDQUFNQSxDQUFDO0lBQ3ZCLE1BQU1PLGFBQWE7SUFDbkIsTUFBTUMsZUFBZTtRQUNqQixNQUFNQyxPQUFPSixJQUFJSyxPQUFPO1FBQ3hCLElBQUksQ0FBQ0QsTUFDRDtRQUNKRSxzQkFBc0I7WUFDbEJGLEtBQUtHLEtBQUssQ0FBQ0MsTUFBTSxHQUFHSixLQUFLSyxZQUFZLEdBQUc7UUFDNUM7SUFDSjtJQUNBLE1BQU1DLGdCQUFnQjtRQUNsQixNQUFNTixPQUFPSixJQUFJSyxPQUFPO1FBQ3hCLElBQUksQ0FBQ0QsTUFDRDtRQUNKRSxzQkFBc0I7WUFDbEJGLEtBQUtHLEtBQUssQ0FBQ0MsTUFBTSxHQUFHSixLQUFLTyxZQUFZLEdBQUc7WUFDeENQLEtBQUtHLEtBQUssQ0FBQ0ssUUFBUSxHQUFHO1lBQ3RCTixzQkFBc0I7Z0JBQ2xCRixLQUFLRyxLQUFLLENBQUNDLE1BQU0sR0FBRztZQUN4QjtRQUNKO0lBQ0o7SUFDQWQsc0RBQWVBLENBQUM7UUFDWixJQUFJSyxVQUFVO1lBQ1ZJO1FBQ0osT0FDSztZQUNETztRQUNKO0lBQ0osR0FBRztRQUFDWDtLQUFTO0lBQ2JMLHNEQUFlQSxDQUFDO1FBQ1osTUFBTVUsT0FBT0osSUFBSUssT0FBTztRQUN4QixJQUFJLENBQUNELE1BQ0Q7UUFDSixTQUFTUztZQUNMLElBQUksQ0FBQ1QsTUFDRDtZQUNKQSxLQUFLRyxLQUFLLENBQUNLLFFBQVEsR0FBR2IsV0FBVyxZQUFZO1lBQzdDLElBQUlBLFVBQVU7Z0JBQ1ZLLEtBQUtHLEtBQUssQ0FBQ0MsTUFBTSxHQUFHO1lBQ3hCO1FBQ0o7UUFDQSxTQUFTTSxvQkFBb0JDLEtBQUs7WUFDOUIsSUFBSVgsUUFBUVcsTUFBTUMsTUFBTSxLQUFLWixRQUFRVyxNQUFNRSxZQUFZLEtBQUssVUFBVTtnQkFDbEVKO1lBQ0o7UUFDSjtRQUNBLElBQUlaLFFBQVFJLE9BQU8sRUFBRTtZQUNqQlE7WUFDQVosUUFBUUksT0FBTyxHQUFHO1FBQ3RCO1FBQ0FELEtBQUtjLGdCQUFnQixDQUFDLGlCQUFpQko7UUFDdkMsT0FBTyxJQUFNVixLQUFLZSxtQkFBbUIsQ0FBQyxpQkFBaUJMO0lBQzNELEdBQUc7UUFBQ2Y7S0FBUztJQUNiLHFCQUFRTixnREFBbUIsQ0FBQyxPQUFPO1FBQUU0QixXQUFXO1FBQTJCeEIsSUFBSUE7UUFBSUcsS0FBS0E7UUFBS3NCLE1BQU07UUFBVWYsT0FBTztZQUFFQyxRQUFRO1lBQUdOLFlBQVlELFFBQVFJLE9BQU8sR0FBR2tCLFlBQVlyQjtRQUFXO0lBQUUsR0FBR0o7QUFDL0wsRUFBRSxDQUNGLG9DQUFvQyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvQHNvbGFuYS93YWxsZXQtYWRhcHRlci1yZWFjdC11aS9saWIvZXNtL0NvbGxhcHNlLmpzPzlhNGMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IFJlYWN0LCB7IHVzZUxheW91dEVmZmVjdCwgdXNlUmVmIH0gZnJvbSAncmVhY3QnO1xuZXhwb3J0IGNvbnN0IENvbGxhcHNlID0gKHsgaWQsIGNoaWxkcmVuLCBleHBhbmRlZCA9IGZhbHNlIH0pID0+IHtcbiAgICBjb25zdCByZWYgPSB1c2VSZWYobnVsbCk7XG4gICAgY29uc3QgaW5zdGFudCA9IHVzZVJlZih0cnVlKTtcbiAgICBjb25zdCB0cmFuc2l0aW9uID0gJ2hlaWdodCAyNTBtcyBlYXNlLW91dCc7XG4gICAgY29uc3Qgb3BlbkNvbGxhcHNlID0gKCkgPT4ge1xuICAgICAgICBjb25zdCBub2RlID0gcmVmLmN1cnJlbnQ7XG4gICAgICAgIGlmICghbm9kZSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHtcbiAgICAgICAgICAgIG5vZGUuc3R5bGUuaGVpZ2h0ID0gbm9kZS5zY3JvbGxIZWlnaHQgKyAncHgnO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIGNvbnN0IGNsb3NlQ29sbGFwc2UgPSAoKSA9PiB7XG4gICAgICAgIGNvbnN0IG5vZGUgPSByZWYuY3VycmVudDtcbiAgICAgICAgaWYgKCFub2RlKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4ge1xuICAgICAgICAgICAgbm9kZS5zdHlsZS5oZWlnaHQgPSBub2RlLm9mZnNldEhlaWdodCArICdweCc7XG4gICAgICAgICAgICBub2RlLnN0eWxlLm92ZXJmbG93ID0gJ2hpZGRlbic7XG4gICAgICAgICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4ge1xuICAgICAgICAgICAgICAgIG5vZGUuc3R5bGUuaGVpZ2h0ID0gJzAnO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgdXNlTGF5b3V0RWZmZWN0KCgpID0+IHtcbiAgICAgICAgaWYgKGV4cGFuZGVkKSB7XG4gICAgICAgICAgICBvcGVuQ29sbGFwc2UoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNsb3NlQ29sbGFwc2UoKTtcbiAgICAgICAgfVxuICAgIH0sIFtleHBhbmRlZF0pO1xuICAgIHVzZUxheW91dEVmZmVjdCgoKSA9PiB7XG4gICAgICAgIGNvbnN0IG5vZGUgPSByZWYuY3VycmVudDtcbiAgICAgICAgaWYgKCFub2RlKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBmdW5jdGlvbiBoYW5kbGVDb21wbGV0ZSgpIHtcbiAgICAgICAgICAgIGlmICghbm9kZSlcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBub2RlLnN0eWxlLm92ZXJmbG93ID0gZXhwYW5kZWQgPyAnaW5pdGlhbCcgOiAnaGlkZGVuJztcbiAgICAgICAgICAgIGlmIChleHBhbmRlZCkge1xuICAgICAgICAgICAgICAgIG5vZGUuc3R5bGUuaGVpZ2h0ID0gJ2F1dG8nO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGhhbmRsZVRyYW5zaXRpb25FbmQoZXZlbnQpIHtcbiAgICAgICAgICAgIGlmIChub2RlICYmIGV2ZW50LnRhcmdldCA9PT0gbm9kZSAmJiBldmVudC5wcm9wZXJ0eU5hbWUgPT09ICdoZWlnaHQnKSB7XG4gICAgICAgICAgICAgICAgaGFuZGxlQ29tcGxldGUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoaW5zdGFudC5jdXJyZW50KSB7XG4gICAgICAgICAgICBoYW5kbGVDb21wbGV0ZSgpO1xuICAgICAgICAgICAgaW5zdGFudC5jdXJyZW50ID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgbm9kZS5hZGRFdmVudExpc3RlbmVyKCd0cmFuc2l0aW9uZW5kJywgaGFuZGxlVHJhbnNpdGlvbkVuZCk7XG4gICAgICAgIHJldHVybiAoKSA9PiBub2RlLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3RyYW5zaXRpb25lbmQnLCBoYW5kbGVUcmFuc2l0aW9uRW5kKTtcbiAgICB9LCBbZXhwYW5kZWRdKTtcbiAgICByZXR1cm4gKFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgeyBjbGFzc05hbWU6IFwid2FsbGV0LWFkYXB0ZXItY29sbGFwc2VcIiwgaWQ6IGlkLCByZWY6IHJlZiwgcm9sZTogXCJyZWdpb25cIiwgc3R5bGU6IHsgaGVpZ2h0OiAwLCB0cmFuc2l0aW9uOiBpbnN0YW50LmN1cnJlbnQgPyB1bmRlZmluZWQgOiB0cmFuc2l0aW9uIH0gfSwgY2hpbGRyZW4pKTtcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1Db2xsYXBzZS5qcy5tYXAiXSwibmFtZXMiOlsiUmVhY3QiLCJ1c2VMYXlvdXRFZmZlY3QiLCJ1c2VSZWYiLCJDb2xsYXBzZSIsImlkIiwiY2hpbGRyZW4iLCJleHBhbmRlZCIsInJlZiIsImluc3RhbnQiLCJ0cmFuc2l0aW9uIiwib3BlbkNvbGxhcHNlIiwibm9kZSIsImN1cnJlbnQiLCJyZXF1ZXN0QW5pbWF0aW9uRnJhbWUiLCJzdHlsZSIsImhlaWdodCIsInNjcm9sbEhlaWdodCIsImNsb3NlQ29sbGFwc2UiLCJvZmZzZXRIZWlnaHQiLCJvdmVyZmxvdyIsImhhbmRsZUNvbXBsZXRlIiwiaGFuZGxlVHJhbnNpdGlvbkVuZCIsImV2ZW50IiwidGFyZ2V0IiwicHJvcGVydHlOYW1lIiwiYWRkRXZlbnRMaXN0ZW5lciIsInJlbW92ZUV2ZW50TGlzdGVuZXIiLCJjcmVhdGVFbGVtZW50IiwiY2xhc3NOYW1lIiwicm9sZSIsInVuZGVmaW5lZCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/@solana/wallet-adapter-react-ui/lib/esm/Collapse.js\n");

/***/ }),

/***/ "(ssr)/../node_modules/@solana/wallet-adapter-react-ui/lib/esm/WalletIcon.js":
/*!*****************************************************************************!*\
  !*** ../node_modules/@solana/wallet-adapter-react-ui/lib/esm/WalletIcon.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   WalletIcon: () => (/* binding */ WalletIcon)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/../node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n\nconst WalletIcon = ({ wallet, ...props })=>{\n    return wallet && /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"img\", {\n        src: wallet.adapter.icon,\n        alt: `${wallet.adapter.name} icon`,\n        ...props\n    });\n}; //# sourceMappingURL=WalletIcon.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL0Bzb2xhbmEvd2FsbGV0LWFkYXB0ZXItcmVhY3QtdWkvbGliL2VzbS9XYWxsZXRJY29uLmpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQTBCO0FBQ25CLE1BQU1DLGFBQWEsQ0FBQyxFQUFFQyxNQUFNLEVBQUUsR0FBR0MsT0FBTztJQUMzQyxPQUFPRCx3QkFBVUYsZ0RBQW1CLENBQUMsT0FBTztRQUFFSyxLQUFLSCxPQUFPSSxPQUFPLENBQUNDLElBQUk7UUFBRUMsS0FBSyxDQUFDLEVBQUVOLE9BQU9JLE9BQU8sQ0FBQ0csSUFBSSxDQUFDLEtBQUssQ0FBQztRQUFFLEdBQUdOLEtBQUs7SUFBQztBQUN6SCxFQUFFLENBQ0Ysc0NBQXNDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9Ac29sYW5hL3dhbGxldC1hZGFwdGVyLXJlYWN0LXVpL2xpYi9lc20vV2FsbGV0SWNvbi5qcz9kNzMwIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG5leHBvcnQgY29uc3QgV2FsbGV0SWNvbiA9ICh7IHdhbGxldCwgLi4ucHJvcHMgfSkgPT4ge1xuICAgIHJldHVybiB3YWxsZXQgJiYgUmVhY3QuY3JlYXRlRWxlbWVudChcImltZ1wiLCB7IHNyYzogd2FsbGV0LmFkYXB0ZXIuaWNvbiwgYWx0OiBgJHt3YWxsZXQuYWRhcHRlci5uYW1lfSBpY29uYCwgLi4ucHJvcHMgfSk7XG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9V2FsbGV0SWNvbi5qcy5tYXAiXSwibmFtZXMiOlsiUmVhY3QiLCJXYWxsZXRJY29uIiwid2FsbGV0IiwicHJvcHMiLCJjcmVhdGVFbGVtZW50Iiwic3JjIiwiYWRhcHRlciIsImljb24iLCJhbHQiLCJuYW1lIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/@solana/wallet-adapter-react-ui/lib/esm/WalletIcon.js\n");

/***/ }),

/***/ "(ssr)/../node_modules/@solana/wallet-adapter-react-ui/lib/esm/WalletListItem.js":
/*!*********************************************************************************!*\
  !*** ../node_modules/@solana/wallet-adapter-react-ui/lib/esm/WalletListItem.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   WalletListItem: () => (/* binding */ WalletListItem)\n/* harmony export */ });\n/* harmony import */ var _solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @solana/wallet-adapter-base */ \"(ssr)/../node_modules/@solana/wallet-adapter-base/lib/esm/adapter.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/../node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var _Button_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Button.js */ \"(ssr)/../node_modules/@solana/wallet-adapter-react-ui/lib/esm/Button.js\");\n/* harmony import */ var _WalletIcon_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./WalletIcon.js */ \"(ssr)/../node_modules/@solana/wallet-adapter-react-ui/lib/esm/WalletIcon.js\");\n\n\n\n\nconst WalletListItem = ({ handleClick, tabIndex, wallet })=>{\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"li\", null, /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(_Button_js__WEBPACK_IMPORTED_MODULE_1__.Button, {\n        onClick: handleClick,\n        startIcon: /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(_WalletIcon_js__WEBPACK_IMPORTED_MODULE_2__.WalletIcon, {\n            wallet: wallet\n        }),\n        tabIndex: tabIndex\n    }, wallet.adapter.name, wallet.readyState === _solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_3__.WalletReadyState.Installed && /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"span\", null, \"Detected\")));\n}; //# sourceMappingURL=WalletListItem.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL0Bzb2xhbmEvd2FsbGV0LWFkYXB0ZXItcmVhY3QtdWkvbGliL2VzbS9XYWxsZXRMaXN0SXRlbS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUErRDtBQUNyQztBQUNXO0FBQ1E7QUFDdEMsTUFBTUksaUJBQWlCLENBQUMsRUFBRUMsV0FBVyxFQUFFQyxRQUFRLEVBQUVDLE1BQU0sRUFBRTtJQUM1RCxxQkFBUU4sZ0RBQW1CLENBQUMsTUFBTSxvQkFDOUJBLGdEQUFtQixDQUFDQyw4Q0FBTUEsRUFBRTtRQUFFTyxTQUFTSjtRQUFhSyx5QkFBV1QsZ0RBQW1CLENBQUNFLHNEQUFVQSxFQUFFO1lBQUVJLFFBQVFBO1FBQU87UUFBSUQsVUFBVUE7SUFBUyxHQUNuSUMsT0FBT0ksT0FBTyxDQUFDQyxJQUFJLEVBQ25CTCxPQUFPTSxVQUFVLEtBQUtiLHlFQUFnQkEsQ0FBQ2MsU0FBUyxrQkFBSWIsZ0RBQW1CLENBQUMsUUFBUSxNQUFNO0FBQ2xHLEVBQUUsQ0FDRiwwQ0FBMEMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL0Bzb2xhbmEvd2FsbGV0LWFkYXB0ZXItcmVhY3QtdWkvbGliL2VzbS9XYWxsZXRMaXN0SXRlbS5qcz9iOWM0Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IFdhbGxldFJlYWR5U3RhdGUgfSBmcm9tICdAc29sYW5hL3dhbGxldC1hZGFwdGVyLWJhc2UnO1xuaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IEJ1dHRvbiB9IGZyb20gJy4vQnV0dG9uLmpzJztcbmltcG9ydCB7IFdhbGxldEljb24gfSBmcm9tICcuL1dhbGxldEljb24uanMnO1xuZXhwb3J0IGNvbnN0IFdhbGxldExpc3RJdGVtID0gKHsgaGFuZGxlQ2xpY2ssIHRhYkluZGV4LCB3YWxsZXQgfSkgPT4ge1xuICAgIHJldHVybiAoUmVhY3QuY3JlYXRlRWxlbWVudChcImxpXCIsIG51bGwsXG4gICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoQnV0dG9uLCB7IG9uQ2xpY2s6IGhhbmRsZUNsaWNrLCBzdGFydEljb246IFJlYWN0LmNyZWF0ZUVsZW1lbnQoV2FsbGV0SWNvbiwgeyB3YWxsZXQ6IHdhbGxldCB9KSwgdGFiSW5kZXg6IHRhYkluZGV4IH0sXG4gICAgICAgICAgICB3YWxsZXQuYWRhcHRlci5uYW1lLFxuICAgICAgICAgICAgd2FsbGV0LnJlYWR5U3RhdGUgPT09IFdhbGxldFJlYWR5U3RhdGUuSW5zdGFsbGVkICYmIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIsIG51bGwsIFwiRGV0ZWN0ZWRcIikpKSk7XG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9V2FsbGV0TGlzdEl0ZW0uanMubWFwIl0sIm5hbWVzIjpbIldhbGxldFJlYWR5U3RhdGUiLCJSZWFjdCIsIkJ1dHRvbiIsIldhbGxldEljb24iLCJXYWxsZXRMaXN0SXRlbSIsImhhbmRsZUNsaWNrIiwidGFiSW5kZXgiLCJ3YWxsZXQiLCJjcmVhdGVFbGVtZW50Iiwib25DbGljayIsInN0YXJ0SWNvbiIsImFkYXB0ZXIiLCJuYW1lIiwicmVhZHlTdGF0ZSIsIkluc3RhbGxlZCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/@solana/wallet-adapter-react-ui/lib/esm/WalletListItem.js\n");

/***/ }),

/***/ "(ssr)/../node_modules/@solana/wallet-adapter-react-ui/lib/esm/WalletModal.js":
/*!******************************************************************************!*\
  !*** ../node_modules/@solana/wallet-adapter-react-ui/lib/esm/WalletModal.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   WalletModal: () => (/* binding */ WalletModal)\n/* harmony export */ });\n/* harmony import */ var _solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @solana/wallet-adapter-base */ \"(ssr)/../node_modules/@solana/wallet-adapter-base/lib/esm/adapter.js\");\n/* harmony import */ var _solana_wallet_adapter_react__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @solana/wallet-adapter-react */ \"(ssr)/../node_modules/@solana/wallet-adapter-react/lib/esm/useWallet.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/../node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var react_dom__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react-dom */ \"(ssr)/../node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react-dom.js\");\n/* harmony import */ var _Collapse_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./Collapse.js */ \"(ssr)/../node_modules/@solana/wallet-adapter-react-ui/lib/esm/Collapse.js\");\n/* harmony import */ var _WalletListItem_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./WalletListItem.js */ \"(ssr)/../node_modules/@solana/wallet-adapter-react-ui/lib/esm/WalletListItem.js\");\n/* harmony import */ var _WalletSVG_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./WalletSVG.js */ \"(ssr)/../node_modules/@solana/wallet-adapter-react-ui/lib/esm/WalletSVG.js\");\n/* harmony import */ var _useWalletModal_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./useWalletModal.js */ \"(ssr)/../node_modules/@solana/wallet-adapter-react-ui/lib/esm/useWalletModal.js\");\n\n\n\n\n\n\n\n\nconst WalletModal = ({ className = \"\", container = \"body\" })=>{\n    const ref = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    const { wallets, select } = (0,_solana_wallet_adapter_react__WEBPACK_IMPORTED_MODULE_2__.useWallet)();\n    const { setVisible } = (0,_useWalletModal_js__WEBPACK_IMPORTED_MODULE_3__.useWalletModal)();\n    const [expanded, setExpanded] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(false);\n    const [fadeIn, setFadeIn] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(false);\n    const [portal, setPortal] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    const [listedWallets, collapsedWallets] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>{\n        const installed = [];\n        const notInstalled = [];\n        for (const wallet of wallets){\n            if (wallet.readyState === _solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_4__.WalletReadyState.Installed) {\n                installed.push(wallet);\n            } else {\n                notInstalled.push(wallet);\n            }\n        }\n        return installed.length ? [\n            installed,\n            notInstalled\n        ] : [\n            notInstalled,\n            []\n        ];\n    }, [\n        wallets\n    ]);\n    const hideModal = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(()=>{\n        setFadeIn(false);\n        setTimeout(()=>setVisible(false), 150);\n    }, [\n        setVisible\n    ]);\n    const handleClose = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((event)=>{\n        event.preventDefault();\n        hideModal();\n    }, [\n        hideModal\n    ]);\n    const handleWalletClick = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((event, walletName)=>{\n        select(walletName);\n        handleClose(event);\n    }, [\n        select,\n        handleClose\n    ]);\n    const handleCollapseClick = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(()=>setExpanded(!expanded), [\n        expanded\n    ]);\n    const handleTabKey = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((event)=>{\n        const node = ref.current;\n        if (!node) return;\n        // here we query all focusable elements\n        const focusableElements = node.querySelectorAll(\"button\");\n        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n        const firstElement = focusableElements[0];\n        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n        const lastElement = focusableElements[focusableElements.length - 1];\n        if (event.shiftKey) {\n            // if going backward by pressing tab and firstElement is active, shift focus to last focusable element\n            if (document.activeElement === firstElement) {\n                lastElement.focus();\n                event.preventDefault();\n            }\n        } else {\n            // if going forward by pressing tab and lastElement is active, shift focus to first focusable element\n            if (document.activeElement === lastElement) {\n                firstElement.focus();\n                event.preventDefault();\n            }\n        }\n    }, [\n        ref\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect)(()=>{\n        const handleKeyDown = (event)=>{\n            if (event.key === \"Escape\") {\n                hideModal();\n            } else if (event.key === \"Tab\") {\n                handleTabKey(event);\n            }\n        };\n        // Get original overflow\n        const { overflow } = window.getComputedStyle(document.body);\n        // Hack to enable fade in animation after mount\n        setTimeout(()=>setFadeIn(true), 0);\n        // Prevent scrolling on mount\n        document.body.style.overflow = \"hidden\";\n        // Listen for keydown events\n        window.addEventListener(\"keydown\", handleKeyDown, false);\n        return ()=>{\n            // Re-enable scrolling when component unmounts\n            document.body.style.overflow = overflow;\n            window.removeEventListener(\"keydown\", handleKeyDown, false);\n        };\n    }, [\n        hideModal,\n        handleTabKey\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect)(()=>setPortal(document.querySelector(container)), [\n        container\n    ]);\n    return portal && /*#__PURE__*/ (0,react_dom__WEBPACK_IMPORTED_MODULE_1__.createPortal)(/*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", {\n        \"aria-labelledby\": \"wallet-adapter-modal-title\",\n        \"aria-modal\": \"true\",\n        className: `wallet-adapter-modal ${fadeIn && \"wallet-adapter-modal-fade-in\"} ${className}`,\n        ref: ref,\n        role: \"dialog\"\n    }, /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", {\n        className: \"wallet-adapter-modal-container\"\n    }, /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", {\n        className: \"wallet-adapter-modal-wrapper\"\n    }, /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"button\", {\n        onClick: handleClose,\n        className: \"wallet-adapter-modal-button-close\"\n    }, /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"svg\", {\n        width: \"14\",\n        height: \"14\"\n    }, /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"path\", {\n        d: \"M14 12.461 8.3 6.772l5.234-5.233L12.006 0 6.772 5.234 1.54 0 0 1.539l5.234 5.233L0 12.006l1.539 1.528L6.772 8.3l5.69 5.7L14 12.461z\"\n    }))), listedWallets.length ? /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null, /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"h1\", {\n        className: \"wallet-adapter-modal-title\"\n    }, \"Connect a wallet on Solana to continue\"), /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"ul\", {\n        className: \"wallet-adapter-modal-list\"\n    }, listedWallets.map((wallet)=>/*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(_WalletListItem_js__WEBPACK_IMPORTED_MODULE_5__.WalletListItem, {\n            key: wallet.adapter.name,\n            handleClick: (event)=>handleWalletClick(event, wallet.adapter.name),\n            wallet: wallet\n        })), collapsedWallets.length ? /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(_Collapse_js__WEBPACK_IMPORTED_MODULE_6__.Collapse, {\n        expanded: expanded,\n        id: \"wallet-adapter-modal-collapse\"\n    }, collapsedWallets.map((wallet)=>/*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(_WalletListItem_js__WEBPACK_IMPORTED_MODULE_5__.WalletListItem, {\n            key: wallet.adapter.name,\n            handleClick: (event)=>handleWalletClick(event, wallet.adapter.name),\n            tabIndex: expanded ? 0 : -1,\n            wallet: wallet\n        }))) : null), collapsedWallets.length ? /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"button\", {\n        className: \"wallet-adapter-modal-list-more\",\n        onClick: handleCollapseClick,\n        tabIndex: 0\n    }, /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"span\", null, expanded ? \"Less \" : \"More \", \"options\"), /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"svg\", {\n        width: \"13\",\n        height: \"7\",\n        viewBox: \"0 0 13 7\",\n        xmlns: \"http://www.w3.org/2000/svg\",\n        className: `${expanded ? \"wallet-adapter-modal-list-more-icon-rotate\" : \"\"}`\n    }, /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"path\", {\n        d: \"M0.71418 1.626L5.83323 6.26188C5.91574 6.33657 6.0181 6.39652 6.13327 6.43762C6.24844 6.47872 6.37371 6.5 6.50048 6.5C6.62725 6.5 6.75252 6.47872 6.8677 6.43762C6.98287 6.39652 7.08523 6.33657 7.16774 6.26188L12.2868 1.626C12.7753 1.1835 12.3703 0.5 11.6195 0.5H1.37997C0.629216 0.5 0.224175 1.1835 0.71418 1.626Z\"\n    }))) : null) : /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null, /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"h1\", {\n        className: \"wallet-adapter-modal-title\"\n    }, \"You'll need a wallet on Solana to continue\"), /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", {\n        className: \"wallet-adapter-modal-middle\"\n    }, /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(_WalletSVG_js__WEBPACK_IMPORTED_MODULE_7__.WalletSVG, null)), collapsedWallets.length ? /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null, /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"button\", {\n        className: \"wallet-adapter-modal-list-more\",\n        onClick: handleCollapseClick,\n        tabIndex: 0\n    }, /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"span\", null, expanded ? \"Hide \" : \"Already have a wallet? View \", \"options\"), /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"svg\", {\n        width: \"13\",\n        height: \"7\",\n        viewBox: \"0 0 13 7\",\n        xmlns: \"http://www.w3.org/2000/svg\",\n        className: `${expanded ? \"wallet-adapter-modal-list-more-icon-rotate\" : \"\"}`\n    }, /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"path\", {\n        d: \"M0.71418 1.626L5.83323 6.26188C5.91574 6.33657 6.0181 6.39652 6.13327 6.43762C6.24844 6.47872 6.37371 6.5 6.50048 6.5C6.62725 6.5 6.75252 6.47872 6.8677 6.43762C6.98287 6.39652 7.08523 6.33657 7.16774 6.26188L12.2868 1.626C12.7753 1.1835 12.3703 0.5 11.6195 0.5H1.37997C0.629216 0.5 0.224175 1.1835 0.71418 1.626Z\"\n    }))), /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(_Collapse_js__WEBPACK_IMPORTED_MODULE_6__.Collapse, {\n        expanded: expanded,\n        id: \"wallet-adapter-modal-collapse\"\n    }, /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"ul\", {\n        className: \"wallet-adapter-modal-list\"\n    }, collapsedWallets.map((wallet)=>/*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(_WalletListItem_js__WEBPACK_IMPORTED_MODULE_5__.WalletListItem, {\n            key: wallet.adapter.name,\n            handleClick: (event)=>handleWalletClick(event, wallet.adapter.name),\n            tabIndex: expanded ? 0 : -1,\n            wallet: wallet\n        }))))) : null))), /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", {\n        className: \"wallet-adapter-modal-overlay\",\n        onMouseDown: handleClose\n    })), portal);\n}; //# sourceMappingURL=WalletModal.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL0Bzb2xhbmEvd2FsbGV0LWFkYXB0ZXItcmVhY3QtdWkvbGliL2VzbS9XYWxsZXRNb2RhbC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7QUFBK0Q7QUFDTjtBQUM4QjtBQUM5QztBQUNBO0FBQ1k7QUFDVjtBQUNVO0FBQzlDLE1BQU1hLGNBQWMsQ0FBQyxFQUFFQyxZQUFZLEVBQUUsRUFBRUMsWUFBWSxNQUFNLEVBQUU7SUFDOUQsTUFBTUMsTUFBTVYsNkNBQU1BLENBQUM7SUFDbkIsTUFBTSxFQUFFVyxPQUFPLEVBQUVDLE1BQU0sRUFBRSxHQUFHakIsdUVBQVNBO0lBQ3JDLE1BQU0sRUFBRWtCLFVBQVUsRUFBRSxHQUFHUCxrRUFBY0E7SUFDckMsTUFBTSxDQUFDUSxVQUFVQyxZQUFZLEdBQUdkLCtDQUFRQSxDQUFDO0lBQ3pDLE1BQU0sQ0FBQ2UsUUFBUUMsVUFBVSxHQUFHaEIsK0NBQVFBLENBQUM7SUFDckMsTUFBTSxDQUFDaUIsUUFBUUMsVUFBVSxHQUFHbEIsK0NBQVFBLENBQUM7SUFDckMsTUFBTSxDQUFDbUIsZUFBZUMsaUJBQWlCLEdBQUd0Qiw4Q0FBT0EsQ0FBQztRQUM5QyxNQUFNdUIsWUFBWSxFQUFFO1FBQ3BCLE1BQU1DLGVBQWUsRUFBRTtRQUN2QixLQUFLLE1BQU1DLFVBQVViLFFBQVM7WUFDMUIsSUFBSWEsT0FBT0MsVUFBVSxLQUFLL0IseUVBQWdCQSxDQUFDZ0MsU0FBUyxFQUFFO2dCQUNsREosVUFBVUssSUFBSSxDQUFDSDtZQUNuQixPQUNLO2dCQUNERCxhQUFhSSxJQUFJLENBQUNIO1lBQ3RCO1FBQ0o7UUFDQSxPQUFPRixVQUFVTSxNQUFNLEdBQUc7WUFBQ047WUFBV0M7U0FBYSxHQUFHO1lBQUNBO1lBQWMsRUFBRTtTQUFDO0lBQzVFLEdBQUc7UUFBQ1o7S0FBUTtJQUNaLE1BQU1rQixZQUFZaEMsa0RBQVdBLENBQUM7UUFDMUJvQixVQUFVO1FBQ1ZhLFdBQVcsSUFBTWpCLFdBQVcsUUFB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Olsid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvQHNvbGFuYS93YWxsZXQtYWRhcHRlci1yZWFjdC11aS9saWIvZXNtL1dhbGxldE1vZGFsLmpzPzNjMzUiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgV2FsbGV0UmVhZHlTdGF0ZSB9IGZyb20gJ0Bzb2xhbmEvd2FsbGV0LWFkYXB0ZXItYmFzZSc7XG5pbXBvcnQgeyB1c2VXYWxsZXQgfSBmcm9tICdAc29sYW5hL3dhbGxldC1hZGFwdGVyLXJlYWN0JztcbmltcG9ydCBSZWFjdCwgeyB1c2VDYWxsYmFjaywgdXNlTGF5b3V0RWZmZWN0LCB1c2VNZW1vLCB1c2VSZWYsIHVzZVN0YXRlIH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgY3JlYXRlUG9ydGFsIH0gZnJvbSAncmVhY3QtZG9tJztcbmltcG9ydCB7IENvbGxhcHNlIH0gZnJvbSAnLi9Db2xsYXBzZS5qcyc7XG5pbXBvcnQgeyBXYWxsZXRMaXN0SXRlbSB9IGZyb20gJy4vV2FsbGV0TGlzdEl0ZW0uanMnO1xuaW1wb3J0IHsgV2FsbGV0U1ZHIH0gZnJvbSAnLi9XYWxsZXRTVkcuanMnO1xuaW1wb3J0IHsgdXNlV2FsbGV0TW9kYWwgfSBmcm9tICcuL3VzZVdhbGxldE1vZGFsLmpzJztcbmV4cG9ydCBjb25zdCBXYWxsZXRNb2RhbCA9ICh7IGNsYXNzTmFtZSA9ICcnLCBjb250YWluZXIgPSAnYm9keScgfSkgPT4ge1xuICAgIGNvbnN0IHJlZiA9IHVzZVJlZihudWxsKTtcbiAgICBjb25zdCB7IHdhbGxldHMsIHNlbGVjdCB9ID0gdXNlV2FsbGV0KCk7XG4gICAgY29uc3QgeyBzZXRWaXNpYmxlIH0gPSB1c2VXYWxsZXRNb2RhbCgpO1xuICAgIGNvbnN0IFtleHBhbmRlZCwgc2V0RXhwYW5kZWRdID0gdXNlU3RhdGUoZmFsc2UpO1xuICAgIGNvbnN0IFtmYWRlSW4sIHNldEZhZGVJbl0gPSB1c2VTdGF0ZShmYWxzZSk7XG4gICAgY29uc3QgW3BvcnRhbCwgc2V0UG9ydGFsXSA9IHVzZVN0YXRlKG51bGwpO1xuICAgIGNvbnN0IFtsaXN0ZWRXYWxsZXRzLCBjb2xsYXBzZWRXYWxsZXRzXSA9IHVzZU1lbW8oKCkgPT4ge1xuICAgICAgICBjb25zdCBpbnN0YWxsZWQgPSBbXTtcbiAgICAgICAgY29uc3Qgbm90SW5zdGFsbGVkID0gW107XG4gICAgICAgIGZvciAoY29uc3Qgd2FsbGV0IG9mIHdhbGxldHMpIHtcbiAgICAgICAgICAgIGlmICh3YWxsZXQucmVhZHlTdGF0ZSA9PT0gV2FsbGV0UmVhZHlTdGF0ZS5JbnN0YWxsZWQpIHtcbiAgICAgICAgICAgICAgICBpbnN0YWxsZWQucHVzaCh3YWxsZXQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbm90SW5zdGFsbGVkLnB1c2god2FsbGV0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaW5zdGFsbGVkLmxlbmd0aCA/IFtpbnN0YWxsZWQsIG5vdEluc3RhbGxlZF0gOiBbbm90SW5zdGFsbGVkLCBbXV07XG4gICAgfSwgW3dhbGxldHNdKTtcbiAgICBjb25zdCBoaWRlTW9kYWwgPSB1c2VDYWxsYmFjaygoKSA9PiB7XG4gICAgICAgIHNldEZhZGVJbihmYWxzZSk7XG4gICAgICAgIHNldFRpbWVvdXQoKCkgPT4gc2V0VmlzaWJsZShmYWxzZSksIDE1MCk7XG4gICAgfSwgW3NldFZpc2libGVdKTtcbiAgICBjb25zdCBoYW5kbGVDbG9zZSA9IHVzZUNhbGxiYWNrKChldmVudCkgPT4ge1xuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICBoaWRlTW9kYWwoKTtcbiAgICB9LCBbaGlkZU1vZGFsXSk7XG4gICAgY29uc3QgaGFuZGxlV2FsbGV0Q2xpY2sgPSB1c2VDYWxsYmFjaygoZXZlbnQsIHdhbGxldE5hbWUpID0+IHtcbiAgICAgICAgc2VsZWN0KHdhbGxldE5hbWUpO1xuICAgICAgICBoYW5kbGVDbG9zZShldmVudCk7XG4gICAgfSwgW3NlbGVjdCwgaGFuZGxlQ2xvc2VdKTtcbiAgICBjb25zdCBoYW5kbGVDb2xsYXBzZUNsaWNrID0gdXNlQ2FsbGJhY2soKCkgPT4gc2V0RXhwYW5kZWQoIWV4cGFuZGVkKSwgW2V4cGFuZGVkXSk7XG4gICAgY29uc3QgaGFuZGxlVGFiS2V5ID0gdXNlQ2FsbGJhY2soKGV2ZW50KSA9PiB7XG4gICAgICAgIGNvbnN0IG5vZGUgPSByZWYuY3VycmVudDtcbiAgICAgICAgaWYgKCFub2RlKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAvLyBoZXJlIHdlIHF1ZXJ5IGFsbCBmb2N1c2FibGUgZWxlbWVudHNcbiAgICAgICAgY29uc3QgZm9jdXNhYmxlRWxlbWVudHMgPSBub2RlLnF1ZXJ5U2VsZWN0b3JBbGwoJ2J1dHRvbicpO1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLW5vbi1udWxsLWFzc2VydGlvblxuICAgICAgICBjb25zdCBmaXJzdEVsZW1lbnQgPSBmb2N1c2FibGVFbGVtZW50c1swXTtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1ub24tbnVsbC1hc3NlcnRpb25cbiAgICAgICAgY29uc3QgbGFzdEVsZW1lbnQgPSBmb2N1c2FibGVFbGVtZW50c1tmb2N1c2FibGVFbGVtZW50cy5sZW5ndGggLSAxXTtcbiAgICAgICAgaWYgKGV2ZW50LnNoaWZ0S2V5KSB7XG4gICAgICAgICAgICAvLyBpZiBnb2luZyBiYWNrd2FyZCBieSBwcmVzc2luZyB0YWIgYW5kIGZpcnN0RWxlbWVudCBpcyBhY3RpdmUsIHNoaWZ0IGZvY3VzIHRvIGxhc3QgZm9jdXNhYmxlIGVsZW1lbnRcbiAgICAgICAgICAgIGlmIChkb2N1bWVudC5hY3RpdmVFbGVtZW50ID09PSBmaXJzdEVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICBsYXN0RWxlbWVudC5mb2N1cygpO1xuICAgICAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBpZiBnb2luZyBmb3J3YXJkIGJ5IHByZXNzaW5nIHRhYiBhbmQgbGFzdEVsZW1lbnQgaXMgYWN0aXZlLCBzaGlmdCBmb2N1cyB0byBmaXJzdCBmb2N1c2FibGUgZWxlbWVudFxuICAgICAgICAgICAgaWYgKGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQgPT09IGxhc3RFbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgZmlyc3RFbGVtZW50LmZvY3VzKCk7XG4gICAgICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sIFtyZWZdKTtcbiAgICB1c2VMYXlvdXRFZmZlY3QoKCkgPT4ge1xuICAgICAgICBjb25zdCBoYW5kbGVLZXlEb3duID0gKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICBpZiAoZXZlbnQua2V5ID09PSAnRXNjYXBlJykge1xuICAgICAgICAgICAgICAgIGhpZGVNb2RhbCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoZXZlbnQua2V5ID09PSAnVGFiJykge1xuICAgICAgICAgICAgICAgIGhhbmRsZVRhYktleShldmVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIC8vIEdldCBvcmlnaW5hbCBvdmVyZmxvd1xuICAgICAgICBjb25zdCB7IG92ZXJmbG93IH0gPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShkb2N1bWVudC5ib2R5KTtcbiAgICAgICAgLy8gSGFjayB0byBlbmFibGUgZmFkZSBpbiBhbmltYXRpb24gYWZ0ZXIgbW91bnRcbiAgICAgICAgc2V0VGltZW91dCgoKSA9PiBzZXRGYWRlSW4odHJ1ZSksIDApO1xuICAgICAgICAvLyBQcmV2ZW50IHNjcm9sbGluZyBvbiBtb3VudFxuICAgICAgICBkb2N1bWVudC5ib2R5LnN0eWxlLm92ZXJmbG93ID0gJ2hpZGRlbic7XG4gICAgICAgIC8vIExpc3RlbiBmb3Iga2V5ZG93biBldmVudHNcbiAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ2tleWRvd24nLCBoYW5kbGVLZXlEb3duLCBmYWxzZSk7XG4gICAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgICAgICAvLyBSZS1lbmFibGUgc2Nyb2xsaW5nIHdoZW4gY29tcG9uZW50IHVubW91bnRzXG4gICAgICAgICAgICBkb2N1bWVudC5ib2R5LnN0eWxlLm92ZXJmbG93ID0gb3ZlcmZsb3c7XG4gICAgICAgICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcigna2V5ZG93bicsIGhhbmRsZUtleURvd24sIGZhbHNlKTtcbiAgICAgICAgfTtcbiAgICB9LCBbaGlkZU1vZGFsLCBoYW5kbGVUYWJLZXldKTtcbiAgICB1c2VMYXlvdXRFZmZlY3QoKCkgPT4gc2V0UG9ydGFsKGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoY29udGFpbmVyKSksIFtjb250YWluZXJdKTtcbiAgICByZXR1cm4gKHBvcnRhbCAmJlxuICAgICAgICBjcmVhdGVQb3J0YWwoUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7IFwiYXJpYS1sYWJlbGxlZGJ5XCI6IFwid2FsbGV0LWFkYXB0ZXItbW9kYWwtdGl0bGVcIiwgXCJhcmlhLW1vZGFsXCI6IFwidHJ1ZVwiLCBjbGFzc05hbWU6IGB3YWxsZXQtYWRhcHRlci1tb2RhbCAke2ZhZGVJbiAmJiAnd2FsbGV0LWFkYXB0ZXItbW9kYWwtZmFkZS1pbid9ICR7Y2xhc3NOYW1lfWAsIHJlZjogcmVmLCByb2xlOiBcImRpYWxvZ1wiIH0sXG4gICAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHsgY2xhc3NOYW1lOiBcIndhbGxldC1hZGFwdGVyLW1vZGFsLWNvbnRhaW5lclwiIH0sXG4gICAgICAgICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7IGNsYXNzTmFtZTogXCJ3YWxsZXQtYWRhcHRlci1tb2RhbC13cmFwcGVyXCIgfSxcbiAgICAgICAgICAgICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcImJ1dHRvblwiLCB7IG9uQ2xpY2s6IGhhbmRsZUNsb3NlLCBjbGFzc05hbWU6IFwid2FsbGV0LWFkYXB0ZXItbW9kYWwtYnV0dG9uLWNsb3NlXCIgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJzdmdcIiwgeyB3aWR0aDogXCIxNFwiLCBoZWlnaHQ6IFwiMTRcIiB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJwYXRoXCIsIHsgZDogXCJNMTQgMTIuNDYxIDguMyA2Ljc3Mmw1LjIzNC01LjIzM0wxMi4wMDYgMCA2Ljc3MiA1LjIzNCAxLjU0IDAgMCAxLjUzOWw1LjIzNCA1LjIzM0wwIDEyLjAwNmwxLjUzOSAxLjUyOEw2Ljc3MiA4LjNsNS42OSA1LjdMMTQgMTIuNDYxelwiIH0pKSksXG4gICAgICAgICAgICAgICAgICAgIGxpc3RlZFdhbGxldHMubGVuZ3RoID8gKFJlYWN0LmNyZWF0ZUVsZW1lbnQoUmVhY3QuRnJhZ21lbnQsIG51bGwsXG4gICAgICAgICAgICAgICAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFwiaDFcIiwgeyBjbGFzc05hbWU6IFwid2FsbGV0LWFkYXB0ZXItbW9kYWwtdGl0bGVcIiB9LCBcIkNvbm5lY3QgYSB3YWxsZXQgb24gU29sYW5hIHRvIGNvbnRpbnVlXCIpLFxuICAgICAgICAgICAgICAgICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcInVsXCIsIHsgY2xhc3NOYW1lOiBcIndhbGxldC1hZGFwdGVyLW1vZGFsLWxpc3RcIiB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxpc3RlZFdhbGxldHMubWFwKCh3YWxsZXQpID0+IChSZWFjdC5jcmVhdGVFbGVtZW50KFdhbGxldExpc3RJdGVtLCB7IGtleTogd2FsbGV0LmFkYXB0ZXIubmFtZSwgaGFuZGxlQ2xpY2s6IChldmVudCkgPT4gaGFuZGxlV2FsbGV0Q2xpY2soZXZlbnQsIHdhbGxldC5hZGFwdGVyLm5hbWUpLCB3YWxsZXQ6IHdhbGxldCB9KSkpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbGxhcHNlZFdhbGxldHMubGVuZ3RoID8gKFJlYWN0LmNyZWF0ZUVsZW1lbnQoQ29sbGFwc2UsIHsgZXhwYW5kZWQ6IGV4cGFuZGVkLCBpZDogXCJ3YWxsZXQtYWRhcHRlci1tb2RhbC1jb2xsYXBzZVwiIH0sIGNvbGxhcHNlZFdhbGxldHMubWFwKCh3YWxsZXQpID0+IChSZWFjdC5jcmVhdGVFbGVtZW50KFdhbGxldExpc3RJdGVtLCB7IGtleTogd2FsbGV0LmFkYXB0ZXIubmFtZSwgaGFuZGxlQ2xpY2s6IChldmVudCkgPT4gaGFuZGxlV2FsbGV0Q2xpY2soZXZlbnQsIHdhbGxldC5hZGFwdGVyLm5hbWUpLCB0YWJJbmRleDogZXhwYW5kZWQgPyAwIDogLTEsIHdhbGxldDogd2FsbGV0IH0pKSkpKSA6IG51bGwpLFxuICAgICAgICAgICAgICAgICAgICAgICAgY29sbGFwc2VkV2FsbGV0cy5sZW5ndGggPyAoUmVhY3QuY3JlYXRlRWxlbWVudChcImJ1dHRvblwiLCB7IGNsYXNzTmFtZTogXCJ3YWxsZXQtYWRhcHRlci1tb2RhbC1saXN0LW1vcmVcIiwgb25DbGljazogaGFuZGxlQ29sbGFwc2VDbGljaywgdGFiSW5kZXg6IDAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFwic3BhblwiLCBudWxsLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBleHBhbmRlZCA/ICdMZXNzICcgOiAnTW9yZSAnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIm9wdGlvbnNcIiksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcInN2Z1wiLCB7IHdpZHRoOiBcIjEzXCIsIGhlaWdodDogXCI3XCIsIHZpZXdCb3g6IFwiMCAwIDEzIDdcIiwgeG1sbnM6IFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIiwgY2xhc3NOYW1lOiBgJHtleHBhbmRlZCA/ICd3YWxsZXQtYWRhcHRlci1tb2RhbC1saXN0LW1vcmUtaWNvbi1yb3RhdGUnIDogJyd9YCB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFwicGF0aFwiLCB7IGQ6IFwiTTAuNzE0MTggMS42MjZMNS44MzMyMyA2LjI2MTg4QzUuOTE1NzQgNi4zMzY1NyA2LjAxODEgNi4zOTY1MiA2LjEzMzI3IDYuNDM3NjJDNi4yNDg0NCA2LjQ3ODcyIDYuMzczNzEgNi41IDYuNTAwNDggNi41QzYuNjI3MjUgNi41IDYuNzUyNTIgNi40Nzg3MiA2Ljg2NzcgNi40Mzc2MkM2Ljk4Mjg3IDYuMzk2NTIgNy4wODUyMyA2LjMzNjU3IDcuMTY3NzQgNi4yNjE4OEwxMi4yODY4IDEuNjI2QzEyLjc3NTMgMS4xODM1IDEyLjM3MDMgMC41IDExLjYxOTUgMC41SDEuMzc5OTdDMC42MjkyMTYgMC41IDAuMjI0MTc1IDEuMTgzNSAwLjcxNDE4IDEuNjI2WlwiIH0pKSkpIDogbnVsbCkpIDogKFJlYWN0LmNyZWF0ZUVsZW1lbnQoUmVhY3QuRnJhZ21lbnQsIG51bGwsXG4gICAgICAgICAgICAgICAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFwiaDFcIiwgeyBjbGFzc05hbWU6IFwid2FsbGV0LWFkYXB0ZXItbW9kYWwtdGl0bGVcIiB9LCBcIllvdSdsbCBuZWVkIGEgd2FsbGV0IG9uIFNvbGFuYSB0byBjb250aW51ZVwiKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgeyBjbGFzc05hbWU6IFwid2FsbGV0LWFkYXB0ZXItbW9kYWwtbWlkZGxlXCIgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFdhbGxldFNWRywgbnVsbCkpLFxuICAgICAgICAgICAgICAgICAgICAgICAgY29sbGFwc2VkV2FsbGV0cy5sZW5ndGggPyAoUmVhY3QuY3JlYXRlRWxlbWVudChSZWFjdC5GcmFnbWVudCwgbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFwiYnV0dG9uXCIsIHsgY2xhc3NOYW1lOiBcIndhbGxldC1hZGFwdGVyLW1vZGFsLWxpc3QtbW9yZVwiLCBvbkNsaWNrOiBoYW5kbGVDb2xsYXBzZUNsaWNrLCB0YWJJbmRleDogMCB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFwic3BhblwiLCBudWxsLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXhwYW5kZWQgPyAnSGlkZSAnIDogJ0FscmVhZHkgaGF2ZSBhIHdhbGxldD8gVmlldyAnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJvcHRpb25zXCIpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFwic3ZnXCIsIHsgd2lkdGg6IFwiMTNcIiwgaGVpZ2h0OiBcIjdcIiwgdmlld0JveDogXCIwIDAgMTMgN1wiLCB4bWxuczogXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiLCBjbGFzc05hbWU6IGAke2V4cGFuZGVkID8gJ3dhbGxldC1hZGFwdGVyLW1vZGFsLWxpc3QtbW9yZS1pY29uLXJvdGF0ZScgOiAnJ31gIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFwicGF0aFwiLCB7IGQ6IFwiTTAuNzE0MTggMS42MjZMNS44MzMyMyA2LjI2MTg4QzUuOTE1NzQgNi4zMzY1NyA2LjAxODEgNi4zOTY1MiA2LjEzMzI3IDYuNDM3NjJDNi4yNDg0NCA2LjQ3ODcyIDYuMzczNzEgNi41IDYuNTAwNDggNi41QzYuNjI3MjUgNi41IDYuNzUyNTIgNi40Nzg3MiA2Ljg2NzcgNi40Mzc2MkM2Ljk4Mjg3IDYuMzk2NTIgNy4wODUyMyA2LjMzNjU3IDcuMTY3NzQgNi4yNjE4OEwxMi4yODY4IDEuNjI2QzEyLjc3NTMgMS4xODM1IDEyLjM3MDMgMC41IDExLjYxOTUgMC41SDEuMzc5OTdDMC42MjkyMTYgMC41IDAuMjI0MTc1IDEuMTgzNSAwLjcxNDE4IDEuNjI2WlwiIH0pKSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChDb2xsYXBzZSwgeyBleHBhbmRlZDogZXhwYW5kZWQsIGlkOiBcIndhbGxldC1hZGFwdGVyLW1vZGFsLWNvbGxhcHNlXCIgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcInVsXCIsIHsgY2xhc3NOYW1lOiBcIndhbGxldC1hZGFwdGVyLW1vZGFsLWxpc3RcIiB9LCBjb2xsYXBzZWRXYWxsZXRzLm1hcCgod2FsbGV0KSA9PiAoUmVhY3QuY3JlYXRlRWxlbWVudChXYWxsZXRMaXN0SXRlbSwgeyBrZXk6IHdhbGxldC5hZGFwdGVyLm5hbWUsIGhhbmRsZUNsaWNrOiAoZXZlbnQpID0+IGhhbmRsZVdhbGxldENsaWNrKGV2ZW50LCB3YWxsZXQuYWRhcHRlci5uYW1lKSwgdGFiSW5kZXg6IGV4cGFuZGVkID8gMCA6IC0xLCB3YWxsZXQ6IHdhbGxldCB9KSkpKSkpKSA6IG51bGwpKSkpLFxuICAgICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7IGNsYXNzTmFtZTogXCJ3YWxsZXQtYWRhcHRlci1tb2RhbC1vdmVybGF5XCIsIG9uTW91c2VEb3duOiBoYW5kbGVDbG9zZSB9KSksIHBvcnRhbCkpO1xufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVdhbGxldE1vZGFsLmpzLm1hcCJdLCJuYW1lcyI6WyJXYWxsZXRSZWFkeVN0YXRlIiwidXNlV2FsbGV0IiwiUmVhY3QiLCJ1c2VDYWxsYmFjayIsInVzZUxheW91dEVmZmVjdCIsInVzZU1lbW8iLCJ1c2VSZWYiLCJ1c2VTdGF0ZSIsImNyZWF0ZVBvcnRhbCIsIkNvbGxhcHNlIiwiV2FsbGV0TGlzdEl0ZW0iLCJXYWxsZXRTVkciLCJ1c2VXYWxsZXRNb2RhbCIsIldhbGxldE1vZGFsIiwiY2xhc3NOYW1lIiwiY29udGFpbmVyIiwicmVmIiwid2FsbGV0cyIsInNlbGVjdCIsInNldFZpc2libGUiLCJleHBhbmRlZCIsInNldEV4cGFuZGVkIiwiZmFkZUluIiwic2V0RmFkZUluIiwicG9ydGFsIiwic2V0UG9ydGFsIiwibGlzdGVkV2FsbGV0cyIsImNvbGxhcHNlZFdhbGxldHMiLCJpbnN0YWxsZWQiLCJub3RJbnN0YWxsZWQiLCJ3YWxsZXQiLCJyZWFkeVN0YXRlIiwiSW5zdGFsbGVkIiwicHVzaCIsImxlbmd0aCIsImhpZGVNb2RhbCIsInNldFRpbWVvdXQiLCJoYW5kbGVDbG9zZSIsImV2ZW50IiwicHJldmVudERlZmF1bHQiLCJoYW5kbGVXYWxsZXRDbGljayIsIndhbGxldE5hbWUiLCJoYW5kbGVDb2xsYXBzZUNsaWNrIiwiaGFuZGxlVGFiS2V5Iiwibm9kZSIsImN1cnJlbnQiLCJmb2N1c2FibGVFbGVtZW50cyIsInF1ZXJ5U2VsZWN0b3JBbGwiLCJmaXJzdEVsZW1lbnQiLCJsYXN0RWxlbWVudCIsInNoaWZ0S2V5IiwiZG9jdW1lbnQiLCJhY3RpdmVFbGVtZW50IiwiZm9jdXMiLCJoYW5kbGVLZXlEb3duIiwia2V5Iiwib3ZlcmZsb3ciLCJ3aW5kb3ciLCJnZXRDb21wdXRlZFN0eWxlIiwiYm9keSIsInN0eWxlIiwiYWRkRXZlbnRMaXN0ZW5lciIsInJlbW92ZUV2ZW50TGlzdGVuZXIiLCJxdWVyeVNlbGVjdG9yIiwiY3JlYXRlRWxlbWVudCIsInJvbGUiLCJvbkNsaWNrIiwid2lkdGgiLCJoZWlnaHQiLCJkIiwiRnJhZ21lbnQiLCJtYXAiLCJhZGFwdGVyIiwibmFtZSIsImhhbmRsZUNsaWNrIiwiaWQiLCJ0YWJJbmRleCIsInZpZXdCb3giLCJ4bWxucyIsIm9uTW91c2VEb3duIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/@solana/wallet-adapter-react-ui/lib/esm/WalletModal.js\n");

/***/ }),

/***/ "(ssr)/../node_modules/@solana/wallet-adapter-react-ui/lib/esm/WalletModalProvider.js":
/*!**************************************************************************************!*\
  !*** ../node_modules/@solana/wallet-adapter-react-ui/lib/esm/WalletModalProvider.js ***!
  \**************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   WalletModalProvider: () => (/* binding */ WalletModalProvider)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/../node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var _useWalletModal_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./useWalletModal.js */ \"(ssr)/../node_modules/@solana/wallet-adapter-react-ui/lib/esm/useWalletModal.js\");\n/* harmony import */ var _WalletModal_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./WalletModal.js */ \"(ssr)/../node_modules/@solana/wallet-adapter-react-ui/lib/esm/WalletModal.js\");\n\n\n\nconst WalletModalProvider = ({ children, ...props })=>{\n    const [visible, setVisible] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(false);\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(_useWalletModal_js__WEBPACK_IMPORTED_MODULE_1__.WalletModalContext.Provider, {\n        value: {\n            visible,\n            setVisible\n        }\n    }, children, visible && /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(_WalletModal_js__WEBPACK_IMPORTED_MODULE_2__.WalletModal, {\n        ...props\n    }));\n}; //# sourceMappingURL=WalletModalProvider.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL0Bzb2xhbmEvd2FsbGV0LWFkYXB0ZXItcmVhY3QtdWkvbGliL2VzbS9XYWxsZXRNb2RhbFByb3ZpZGVyLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBd0M7QUFDaUI7QUFDVjtBQUN4QyxNQUFNSSxzQkFBc0IsQ0FBQyxFQUFFQyxRQUFRLEVBQUUsR0FBR0MsT0FBTztJQUN0RCxNQUFNLENBQUNDLFNBQVNDLFdBQVcsR0FBR1AsK0NBQVFBLENBQUM7SUFDdkMscUJBQVFELGdEQUFtQixDQUFDRSxrRUFBa0JBLENBQUNRLFFBQVEsRUFBRTtRQUFFQyxPQUFPO1lBQzFESjtZQUNBQztRQUNKO0lBQUUsR0FDRkgsVUFDQUUseUJBQVdQLGdEQUFtQixDQUFDRyx3REFBV0EsRUFBRTtRQUFFLEdBQUdHLEtBQUs7SUFBQztBQUMvRCxFQUFFLENBQ0YsK0NBQStDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9Ac29sYW5hL3dhbGxldC1hZGFwdGVyLXJlYWN0LXVpL2xpYi9lc20vV2FsbGV0TW9kYWxQcm92aWRlci5qcz9hNjNlIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBSZWFjdCwgeyB1c2VTdGF0ZSB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IFdhbGxldE1vZGFsQ29udGV4dCB9IGZyb20gJy4vdXNlV2FsbGV0TW9kYWwuanMnO1xuaW1wb3J0IHsgV2FsbGV0TW9kYWwgfSBmcm9tICcuL1dhbGxldE1vZGFsLmpzJztcbmV4cG9ydCBjb25zdCBXYWxsZXRNb2RhbFByb3ZpZGVyID0gKHsgY2hpbGRyZW4sIC4uLnByb3BzIH0pID0+IHtcbiAgICBjb25zdCBbdmlzaWJsZSwgc2V0VmlzaWJsZV0gPSB1c2VTdGF0ZShmYWxzZSk7XG4gICAgcmV0dXJuIChSZWFjdC5jcmVhdGVFbGVtZW50KFdhbGxldE1vZGFsQ29udGV4dC5Qcm92aWRlciwgeyB2YWx1ZToge1xuICAgICAgICAgICAgdmlzaWJsZSxcbiAgICAgICAgICAgIHNldFZpc2libGUsXG4gICAgICAgIH0gfSxcbiAgICAgICAgY2hpbGRyZW4sXG4gICAgICAgIHZpc2libGUgJiYgUmVhY3QuY3JlYXRlRWxlbWVudChXYWxsZXRNb2RhbCwgeyAuLi5wcm9wcyB9KSkpO1xufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVdhbGxldE1vZGFsUHJvdmlkZXIuanMubWFwIl0sIm5hbWVzIjpbIlJlYWN0IiwidXNlU3RhdGUiLCJXYWxsZXRNb2RhbENvbnRleHQiLCJXYWxsZXRNb2RhbCIsIldhbGxldE1vZGFsUHJvdmlkZXIiLCJjaGlsZHJlbiIsInByb3BzIiwidmlzaWJsZSIsInNldFZpc2libGUiLCJjcmVhdGVFbGVtZW50IiwiUHJvdmlkZXIiLCJ2YWx1ZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/@solana/wallet-adapter-react-ui/lib/esm/WalletModalProvider.js\n");

/***/ }),

/***/ "(ssr)/../node_modules/@solana/wallet-adapter-react-ui/lib/esm/WalletSVG.js":
/*!****************************************************************************!*\
  !*** ../node_modules/@solana/wallet-adapter-react-ui/lib/esm/WalletSVG.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   WalletSVG: () => (/* binding */ WalletSVG)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/../node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n\nconst WalletSVG = ()=>{\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"svg\", {\n        width: \"97\",\n        height: \"96\",\n        viewBox: \"0 0 97 96\",\n        fill: \"none\",\n        xmlns: \"http://www.w3.org/2000/svg\"\n    }, /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"circle\", {\n        cx: \"48.5\",\n        cy: \"48\",\n        r: \"48\",\n        fill: \"url(#paint0_linear_880_5115)\",\n        fillOpacity: \"0.1\"\n    }), /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"circle\", {\n        cx: \"48.5\",\n        cy: \"48\",\n        r: \"47\",\n        stroke: \"url(#paint1_linear_880_5115)\",\n        strokeOpacity: \"0.4\",\n        strokeWidth: \"2\"\n    }), /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"g\", {\n        clipPath: \"url(#clip0_880_5115)\"\n    }, /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"path\", {\n        d: \"M65.5769 28.1523H31.4231C27.6057 28.1523 24.5 31.258 24.5 35.0754V60.9215C24.5 64.7389 27.6057 67.8446 31.4231 67.8446H65.5769C69.3943 67.8446 72.5 64.7389 72.5 60.9215V35.0754C72.5 31.258 69.3943 28.1523 65.5769 28.1523ZM69.7308 52.1523H59.5769C57.2865 52.1523 55.4231 50.289 55.4231 47.9985C55.4231 45.708 57.2864 43.8446 59.5769 43.8446H69.7308V52.1523ZM69.7308 41.0754H59.5769C55.7595 41.0754 52.6539 44.1811 52.6539 47.9985C52.6539 51.8159 55.7595 54.9215 59.5769 54.9215H69.7308V60.9215C69.7308 63.2119 67.8674 65.0754 65.5769 65.0754H31.4231C29.1327 65.0754 27.2692 63.212 27.2692 60.9215V35.0754C27.2692 32.785 29.1326 30.9215 31.4231 30.9215H65.5769C67.8673 30.9215 69.7308 32.7849 69.7308 35.0754V41.0754Z\",\n        fill: \"url(#paint2_linear_880_5115)\"\n    }), /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"path\", {\n        d: \"M61.4231 46.6172H59.577C58.8123 46.6172 58.1924 47.2371 58.1924 48.0018C58.1924 48.7665 58.8123 49.3863 59.577 49.3863H61.4231C62.1878 49.3863 62.8077 48.7664 62.8077 48.0018C62.8077 47.2371 62.1878 46.6172 61.4231 46.6172Z\",\n        fill: \"url(#paint3_linear_880_5115)\"\n    })), /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"defs\", null, /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"linearGradient\", {\n        id: \"paint0_linear_880_5115\",\n        x1: \"3.41664\",\n        y1: \"98.0933\",\n        x2: \"103.05\",\n        y2: \"8.42498\",\n        gradientUnits: \"userSpaceOnUse\"\n    }, /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"stop\", {\n        stopColor: \"#9945FF\"\n    }), /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"stop\", {\n        offset: \"0.14\",\n        stopColor: \"#8A53F4\"\n    }), /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"stop\", {\n        offset: \"0.42\",\n        stopColor: \"#6377D6\"\n    }), /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"stop\", {\n        offset: \"0.79\",\n        stopColor: \"#24B0A7\"\n    }), /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"stop\", {\n        offset: \"0.99\",\n        stopColor: \"#00D18C\"\n    }), /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"stop\", {\n        offset: \"1\",\n        stopColor: \"#00D18C\"\n    })), /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"linearGradient\", {\n        id: \"paint1_linear_880_5115\",\n        x1: \"3.41664\",\n        y1: \"98.0933\",\n        x2: \"103.05\",\n        y2: \"8.42498\",\n        gradientUnits: \"userSpaceOnUse\"\n    }, /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"stop\", {\n        stopColor: \"#9945FF\"\n    }), /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"stop\", {\n        offset: \"0.14\",\n        stopColor: \"#8A53F4\"\n    }), /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"stop\", {\n        offset: \"0.42\",\n        stopColor: \"#6377D6\"\n    }), /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"stop\", {\n        offset: \"0.79\",\n        stopColor: \"#24B0A7\"\n    }), /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"stop\", {\n        offset: \"0.99\",\n        stopColor: \"#00D18C\"\n    }), /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"stop\", {\n        offset: \"1\",\n        stopColor: \"#00D18C\"\n    })), /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"linearGradient\", {\n        id: \"paint2_linear_880_5115\",\n        x1: \"25.9583\",\n        y1: \"68.7101\",\n        x2: \"67.2337\",\n        y2: \"23.7879\",\n        gradientUnits: \"userSpaceOnUse\"\n    }, /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"stop\", {\n        stopColor: \"#9945FF\"\n    }), /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"stop\", {\n        offset: \"0.14\",\n        stopColor: \"#8A53F4\"\n    }), /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"stop\", {\n        offset: \"0.42\",\n        stopColor: \"#6377D6\"\n    }), /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"stop\", {\n        offset: \"0.79\",\n        stopColor: \"#24B0A7\"\n    }), /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"stop\", {\n        offset: \"0.99\",\n        stopColor: \"#00D18C\"\n    }), /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"stop\", {\n        offset: \"1\",\n        stopColor: \"#00D18C\"\n    })), /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"linearGradient\", {\n        id: \"paint3_linear_880_5115\",\n        x1: \"58.3326\",\n        y1: \"49.4467\",\n        x2: \"61.0002\",\n        y2: \"45.4453\",\n        gradientUnits: \"userSpaceOnUse\"\n    }, /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"stop\", {\n        stopColor: \"#9945FF\"\n    }), /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"stop\", {\n        offset: \"0.14\",\n        stopColor: \"#8A53F4\"\n    }), /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"stop\", {\n        offset: \"0.42\",\n        stopColor: \"#6377D6\"\n    }), /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"stop\", {\n        offset: \"0.79\",\n        stopColor: \"#24B0A7\"\n    }), /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"stop\", {\n        offset: \"0.99\",\n        stopColor: \"#00D18C\"\n    }), /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"stop\", {\n        offset: \"1\",\n        stopColor: \"#00D18C\"\n    })), /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"clipPath\", {\n        id: \"clip0_880_5115\"\n    }, /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"rect\", {\n        width: \"48\",\n        height: \"48\",\n        fill: \"white\",\n        transform: \"translate(24.5 24)\"\n    }))));\n}; //# sourceMappingURL=WalletSVG.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL0Bzb2xhbmEvd2FsbGV0LWFkYXB0ZXItcmVhY3QtdWkvbGliL2VzbS9XYWxsZXRTVkcuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBMEI7QUFDbkIsTUFBTUMsWUFBWTtJQUNyQixxQkFBUUQsZ0RBQW1CLENBQUMsT0FBTztRQUFFRyxPQUFPO1FBQU1DLFFBQVE7UUFBTUMsU0FBUztRQUFhQyxNQUFNO1FBQVFDLE9BQU87SUFBNkIsaUJBQ3BJUCxnREFBbUIsQ0FBQyxVQUFVO1FBQUVRLElBQUk7UUFBUUMsSUFBSTtRQUFNQyxHQUFHO1FBQU1KLE1BQU07UUFBZ0NLLGFBQWE7SUFBTSxrQkFDeEhYLGdEQUFtQixDQUFDLFVBQVU7UUFBRVEsSUFBSTtRQUFRQyxJQUFJO1FBQU1DLEdBQUc7UUFBTUUsUUFBUTtRQUFnQ0MsZUFBZTtRQUFPQyxhQUFhO0lBQUksa0JBQzlJZCxnREFBbUIsQ0FBQyxLQUFLO1FBQUVlLFVBQVU7SUFBdUIsaUJBQ3hEZixnREFBbUIsQ0FBQyxRQUFRO1FBQUVnQixHQUFHO1FBQStzQlYsTUFBTTtJQUErQixrQkFDcnhCTixnREFBbUIsQ0FBQyxRQUFRO1FBQUVnQixHQUFHO1FBQW1PVixNQUFNO0lBQStCLG1CQUM3U04sZ0RBQW1CLENBQUMsUUFBUSxvQkFDeEJBLGdEQUFtQixDQUFDLGtCQUFrQjtRQUFFaUIsSUFBSTtRQUEwQkMsSUFBSTtRQUFXQyxJQUFJO1FBQVdDLElBQUk7UUFBVUMsSUFBSTtRQUFXQyxlQUFlO0lBQWlCLGlCQUM3SnRCLGdEQUFtQixDQUFDLFFBQVE7UUFBRXVCLFdBQVc7SUFBVSxrQkFDbkR2QixnREFBbUIsQ0FBQyxRQUFRO1FBQUV3QixRQUFRO1FBQVFELFdBQVc7SUFBVSxrQkFDbkV2QixnREFBbUIsQ0FBQyxRQUFRO1FBQUV3QixRQUFRO1FBQVFELFdBQVc7SUFBVSxrQkFDbkV2QixnREFBbUIsQ0FBQyxRQUFRO1FBQUV3QixRQUFRO1FBQVFELFdBQVc7SUFBVSxrQkFDbkV2QixnREFBbUIsQ0FBQyxRQUFRO1FBQUV3QixRQUFRO1FBQVFELFdBQVc7SUFBVSxrQkFDbkV2QixnREFBbUIsQ0FBQyxRQUFRO1FBQUV3QixRQUFRO1FBQUtELFdBQVc7SUFBVSxtQkFDcEV2QixnREFBbUIsQ0FBQyxrQkFBa0I7UUFBRWlCLElBQUk7UUFBMEJDLElBQUk7UUFBV0MsSUFBSTtRQUFXQyxJQUFJO1FBQVVDLElBQUk7UUFBV0MsZUFBZTtJQUFpQixpQkFDN0p0QixnREFBbUIsQ0FBQyxRQUFRO1FBQUV1QixXQUFXO0lBQVUsa0JBQ25EdkIsZ0RBQW1CLENBQUMsUUFBUTtRQUFFd0IsUUFBUTtRQUFRRCxXQUFXO0lBQVUsa0JBQ25FdkIsZ0RBQW1CLENBQUMsUUFBUTtRQUFFd0IsUUFBUTtRQUFRRCxXQUFXO0lBQVUsa0JBQ25FdkIsZ0RBQW1CLENBQUMsUUFBUTtRQUFFd0IsUUFBUTtRQUFRRCxXQUFXO0lBQVUsa0JBQ25FdkIsZ0RBQW1CLENBQUMsUUFBUTtRQUFFd0IsUUFBUTtRQUFRRCxXQUFXO0lBQVUsa0JBQ25FdkIsZ0RBQW1CLENBQUMsUUFBUTtRQUFFd0IsUUFBUTtRQUFLRCxXQUFXO0lBQVUsbUJBQ3BFdkIsZ0RBQW1CLENBQUMsa0JBQWtCO1FBQUVpQixJQUFJO1FBQTBCQyxJQUFJO1FBQVdDLElBQUk7UUFBV0MsSUFBSTtRQUFXQyxJQUFJO1FBQVdDLGVBQWU7SUFBaUIsaUJBQzlKdEIsZ0RBQW1CLENBQUMsUUFBUTtRQUFFdUIsV0FBVztJQUFVLGtCQUNuRHZCLGdEQUFtQixDQUFDLFFBQVE7UUFBRXdCLFFBQVE7UUFBUUQsV0FBVztJQUFVLGtCQUNuRXZCLGdEQUFtQixDQUFDLFFBQVE7UUFBRXdCLFFBQVE7UUFBUUQsV0FBVztJQUFVLGtCQUNuRXZCLGdEQUFtQixDQUFDLFFBQVE7UUFBRXdCLFFBQVE7UUFBUUQsV0FBVztJQUFVLGtCQUNuRXZCLGdEQUFtQixDQUFDLFFBQVE7UUFBRXdCLFFBQVE7UUFBUUQsV0FBVztJQUFVLGtCQUNuRXZCLGdEQUFtQixDQUFDLFFBQVE7UUFBRXdCLFFBQVE7UUFBS0QsV0FBVztJQUFVLG1CQUNwRXZCLGdEQUFtQixDQUFDLGtCQUFrQjtRQUFFaUIsSUFBSTtRQUEwQkMsSUFBSTtRQUFXQyxJQUFJO1FBQVdDLElBQUk7UUFBV0MsSUFBSTtRQUFXQyxlQUFlO0lBQWlCLGlCQUM5SnRCLGdEQUFtQixDQUFDLFFBQVE7UUFBRXVCLFdBQVc7SUFBVSxrQkFDbkR2QixnREFBbUIsQ0FBQyxRQUFRO1FBQUV3QixRQUFRO1FBQVFELFdBQVc7SUFBVSxrQkFDbkV2QixnREFBbUIsQ0FBQyxRQUFRO1FBQUV3QixRQUFRO1FBQVFELFdBQVc7SUFBVSxrQkFDbkV2QixnREFBbUIsQ0FBQyxRQUFRO1FBQUV3QixRQUFRO1FBQVFELFdBQVc7SUFBVSxrQkFDbkV2QixnREFBbUIsQ0FBQyxRQUFRO1FBQUV3QixRQUFRO1FBQVFELFdBQVc7SUFBVSxrQkFDbkV2QixnREFBbUIsQ0FBQyxRQUFRO1FBQUV3QixRQUFRO1FBQUtELFdBQVc7SUFBVSxtQkFDcEV2QixnREFBbUIsQ0FBQyxZQUFZO1FBQUVpQixJQUFJO0lBQWlCLGlCQUNuRGpCLGdEQUFtQixDQUFDLFFBQVE7UUFBRUcsT0FBTztRQUFNQyxRQUFRO1FBQU1FLE1BQU07UUFBU21CLFdBQVc7SUFBcUI7QUFDeEgsRUFBRSxDQUNGLHFDQUFxQyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvQHNvbGFuYS93YWxsZXQtYWRhcHRlci1yZWFjdC11aS9saWIvZXNtL1dhbGxldFNWRy5qcz9kZGUwIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG5leHBvcnQgY29uc3QgV2FsbGV0U1ZHID0gKCkgPT4ge1xuICAgIHJldHVybiAoUmVhY3QuY3JlYXRlRWxlbWVudChcInN2Z1wiLCB7IHdpZHRoOiBcIjk3XCIsIGhlaWdodDogXCI5NlwiLCB2aWV3Qm94OiBcIjAgMCA5NyA5NlwiLCBmaWxsOiBcIm5vbmVcIiwgeG1sbnM6IFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIiB9LFxuICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFwiY2lyY2xlXCIsIHsgY3g6IFwiNDguNVwiLCBjeTogXCI0OFwiLCByOiBcIjQ4XCIsIGZpbGw6IFwidXJsKCNwYWludDBfbGluZWFyXzg4MF81MTE1KVwiLCBmaWxsT3BhY2l0eTogXCIwLjFcIiB9KSxcbiAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcImNpcmNsZVwiLCB7IGN4OiBcIjQ4LjVcIiwgY3k6IFwiNDhcIiwgcjogXCI0N1wiLCBzdHJva2U6IFwidXJsKCNwYWludDFfbGluZWFyXzg4MF81MTE1KVwiLCBzdHJva2VPcGFjaXR5OiBcIjAuNFwiLCBzdHJva2VXaWR0aDogXCIyXCIgfSksXG4gICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJnXCIsIHsgY2xpcFBhdGg6IFwidXJsKCNjbGlwMF84ODBfNTExNSlcIiB9LFxuICAgICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcInBhdGhcIiwgeyBkOiBcIk02NS41NzY5IDI4LjE1MjNIMzEuNDIzMUMyNy42MDU3IDI4LjE1MjMgMjQuNSAzMS4yNTggMjQuNSAzNS4wNzU0VjYwLjkyMTVDMjQuNSA2NC43Mzg5IDI3LjYwNTcgNjcuODQ0NiAzMS40MjMxIDY3Ljg0NDZINjUuNTc2OUM2OS4zOTQzIDY3Ljg0NDYgNzIuNSA2NC43Mzg5IDcyLjUgNjAuOTIxNVYzNS4wNzU0QzcyLjUgMzEuMjU4IDY5LjM5NDMgMjguMTUyMyA2NS41NzY5IDI4LjE1MjNaTTY5LjczMDggNTIuMTUyM0g1OS41NzY5QzU3LjI4NjUgNTIuMTUyMyA1NS40MjMxIDUwLjI4OSA1NS40MjMxIDQ3Ljk5ODVDNTUuNDIzMSA0NS43MDggNTcuMjg2NCA0My44NDQ2IDU5LjU3NjkgNDMuODQ0Nkg2OS43MzA4VjUyLjE1MjNaTTY5LjczMDggNDEuMDc1NEg1OS41NzY5QzU1Ljc1OTUgNDEuMDc1NCA1Mi42NTM5IDQ0LjE4MTEgNTIuNjUzOSA0Ny45OTg1QzUyLjY1MzkgNTEuODE1OSA1NS43NTk1IDU0LjkyMTUgNTkuNTc2OSA1NC45MjE1SDY5LjczMDhWNjAuOTIxNUM2OS43MzA4IDYzLjIxMTkgNjcuODY3NCA2NS4wNzU0IDY1LjU3NjkgNjUuMDc1NEgzMS40MjMxQzI5LjEzMjcgNjUuMDc1NCAyNy4yNjkyIDYzLjIxMiAyNy4yNjkyIDYwLjkyMTVWMzUuMDc1NEMyNy4yNjkyIDMyLjc4NSAyOS4xMzI2IDMwLjkyMTUgMzEuNDIzMSAzMC45MjE1SDY1LjU3NjlDNjcuODY3MyAzMC45MjE1IDY5LjczMDggMzIuNzg0OSA2OS43MzA4IDM1LjA3NTRWNDEuMDc1NFpcIiwgZmlsbDogXCJ1cmwoI3BhaW50Ml9saW5lYXJfODgwXzUxMTUpXCIgfSksXG4gICAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFwicGF0aFwiLCB7IGQ6IFwiTTYxLjQyMzEgNDYuNjE3Mkg1OS41NzdDNTguODEyMyA0Ni42MTcyIDU4LjE5MjQgNDcuMjM3MSA1OC4xOTI0IDQ4LjAwMThDNTguMTkyNCA0OC43NjY1IDU4LjgxMjMgNDkuMzg2MyA1OS41NzcgNDkuMzg2M0g2MS40MjMxQzYyLjE4NzggNDkuMzg2MyA2Mi44MDc3IDQ4Ljc2NjQgNjIuODA3NyA0OC4wMDE4QzYyLjgwNzcgNDcuMjM3MSA2Mi4xODc4IDQ2LjYxNzIgNjEuNDIzMSA0Ni42MTcyWlwiLCBmaWxsOiBcInVybCgjcGFpbnQzX2xpbmVhcl84ODBfNTExNSlcIiB9KSksXG4gICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJkZWZzXCIsIG51bGwsXG4gICAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFwibGluZWFyR3JhZGllbnRcIiwgeyBpZDogXCJwYWludDBfbGluZWFyXzg4MF81MTE1XCIsIHgxOiBcIjMuNDE2NjRcIiwgeTE6IFwiOTguMDkzM1wiLCB4MjogXCIxMDMuMDVcIiwgeTI6IFwiOC40MjQ5OFwiLCBncmFkaWVudFVuaXRzOiBcInVzZXJTcGFjZU9uVXNlXCIgfSxcbiAgICAgICAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFwic3RvcFwiLCB7IHN0b3BDb2xvcjogXCIjOTk0NUZGXCIgfSksXG4gICAgICAgICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcInN0b3BcIiwgeyBvZmZzZXQ6IFwiMC4xNFwiLCBzdG9wQ29sb3I6IFwiIzhBNTNGNFwiIH0pLFxuICAgICAgICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJzdG9wXCIsIHsgb2Zmc2V0OiBcIjAuNDJcIiwgc3RvcENvbG9yOiBcIiM2Mzc3RDZcIiB9KSxcbiAgICAgICAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFwic3RvcFwiLCB7IG9mZnNldDogXCIwLjc5XCIsIHN0b3BDb2xvcjogXCIjMjRCMEE3XCIgfSksXG4gICAgICAgICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcInN0b3BcIiwgeyBvZmZzZXQ6IFwiMC45OVwiLCBzdG9wQ29sb3I6IFwiIzAwRDE4Q1wiIH0pLFxuICAgICAgICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJzdG9wXCIsIHsgb2Zmc2V0OiBcIjFcIiwgc3RvcENvbG9yOiBcIiMwMEQxOENcIiB9KSksXG4gICAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFwibGluZWFyR3JhZGllbnRcIiwgeyBpZDogXCJwYWludDFfbGluZWFyXzg4MF81MTE1XCIsIHgxOiBcIjMuNDE2NjRcIiwgeTE6IFwiOTguMDkzM1wiLCB4MjogXCIxMDMuMDVcIiwgeTI6IFwiOC40MjQ5OFwiLCBncmFkaWVudFVuaXRzOiBcInVzZXJTcGFjZU9uVXNlXCIgfSxcbiAgICAgICAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFwic3RvcFwiLCB7IHN0b3BDb2xvcjogXCIjOTk0NUZGXCIgfSksXG4gICAgICAgICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcInN0b3BcIiwgeyBvZmZzZXQ6IFwiMC4xNFwiLCBzdG9wQ29sb3I6IFwiIzhBNTNGNFwiIH0pLFxuICAgICAgICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJzdG9wXCIsIHsgb2Zmc2V0OiBcIjAuNDJcIiwgc3RvcENvbG9yOiBcIiM2Mzc3RDZcIiB9KSxcbiAgICAgICAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFwic3RvcFwiLCB7IG9mZnNldDogXCIwLjc5XCIsIHN0b3BDb2xvcjogXCIjMjRCMEE3XCIgfSksXG4gICAgICAgICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcInN0b3BcIiwgeyBvZmZzZXQ6IFwiMC45OVwiLCBzdG9wQ29sb3I6IFwiIzAwRDE4Q1wiIH0pLFxuICAgICAgICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJzdG9wXCIsIHsgb2Zmc2V0OiBcIjFcIiwgc3RvcENvbG9yOiBcIiMwMEQxOENcIiB9KSksXG4gICAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFwibGluZWFyR3JhZGllbnRcIiwgeyBpZDogXCJwYWludDJfbGluZWFyXzg4MF81MTE1XCIsIHgxOiBcIjI1Ljk1ODNcIiwgeTE6IFwiNjguNzEwMVwiLCB4MjogXCI2Ny4yMzM3XCIsIHkyOiBcIjIzLjc4NzlcIiwgZ3JhZGllbnRVbml0czogXCJ1c2VyU3BhY2VPblVzZVwiIH0sXG4gICAgICAgICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcInN0b3BcIiwgeyBzdG9wQ29sb3I6IFwiIzk5NDVGRlwiIH0pLFxuICAgICAgICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJzdG9wXCIsIHsgb2Zmc2V0OiBcIjAuMTRcIiwgc3RvcENvbG9yOiBcIiM4QTUzRjRcIiB9KSxcbiAgICAgICAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFwic3RvcFwiLCB7IG9mZnNldDogXCIwLjQyXCIsIHN0b3BDb2xvcjogXCIjNjM3N0Q2XCIgfSksXG4gICAgICAgICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcInN0b3BcIiwgeyBvZmZzZXQ6IFwiMC43OVwiLCBzdG9wQ29sb3I6IFwiIzI0QjBBN1wiIH0pLFxuICAgICAgICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJzdG9wXCIsIHsgb2Zmc2V0OiBcIjAuOTlcIiwgc3RvcENvbG9yOiBcIiMwMEQxOENcIiB9KSxcbiAgICAgICAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFwic3RvcFwiLCB7IG9mZnNldDogXCIxXCIsIHN0b3BDb2xvcjogXCIjMDBEMThDXCIgfSkpLFxuICAgICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcImxpbmVhckdyYWRpZW50XCIsIHsgaWQ6IFwicGFpbnQzX2xpbmVhcl84ODBfNTExNVwiLCB4MTogXCI1OC4zMzI2XCIsIHkxOiBcIjQ5LjQ0NjdcIiwgeDI6IFwiNjEuMDAwMlwiLCB5MjogXCI0NS40NDUzXCIsIGdyYWRpZW50VW5pdHM6IFwidXNlclNwYWNlT25Vc2VcIiB9LFxuICAgICAgICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJzdG9wXCIsIHsgc3RvcENvbG9yOiBcIiM5OTQ1RkZcIiB9KSxcbiAgICAgICAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFwic3RvcFwiLCB7IG9mZnNldDogXCIwLjE0XCIsIHN0b3BDb2xvcjogXCIjOEE1M0Y0XCIgfSksXG4gICAgICAgICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcInN0b3BcIiwgeyBvZmZzZXQ6IFwiMC40MlwiLCBzdG9wQ29sb3I6IFwiIzYzNzdENlwiIH0pLFxuICAgICAgICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJzdG9wXCIsIHsgb2Zmc2V0OiBcIjAuNzlcIiwgc3RvcENvbG9yOiBcIiMyNEIwQTdcIiB9KSxcbiAgICAgICAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFwic3RvcFwiLCB7IG9mZnNldDogXCIwLjk5XCIsIHN0b3BDb2xvcjogXCIjMDBEMThDXCIgfSksXG4gICAgICAgICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcInN0b3BcIiwgeyBvZmZzZXQ6IFwiMVwiLCBzdG9wQ29sb3I6IFwiIzAwRDE4Q1wiIH0pKSxcbiAgICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJjbGlwUGF0aFwiLCB7IGlkOiBcImNsaXAwXzg4MF81MTE1XCIgfSxcbiAgICAgICAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFwicmVjdFwiLCB7IHdpZHRoOiBcIjQ4XCIsIGhlaWdodDogXCI0OFwiLCBmaWxsOiBcIndoaXRlXCIsIHRyYW5zZm9ybTogXCJ0cmFuc2xhdGUoMjQuNSAyNClcIiB9KSkpKSk7XG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9V2FsbGV0U1ZHLmpzLm1hcCJdLCJuYW1lcyI6WyJSZWFjdCIsIldhbGxldFNWRyIsImNyZWF0ZUVsZW1lbnQiLCJ3aWR0aCIsImhlaWdodCIsInZpZXdCb3giLCJmaWxsIiwieG1sbnMiLCJjeCIsImN5IiwiciIsImZpbGxPcGFjaXR5Iiwic3Ryb2tlIiwic3Ryb2tlT3BhY2l0eSIsInN0cm9rZVdpZHRoIiwiY2xpcFBhdGgiLCJkIiwiaWQiLCJ4MSIsInkxIiwieDIiLCJ5MiIsImdyYWRpZW50VW5pdHMiLCJzdG9wQ29sb3IiLCJvZmZzZXQiLCJ0cmFuc2Zvcm0iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/@solana/wallet-adapter-react-ui/lib/esm/WalletSVG.js\n");

/***/ }),

/***/ "(ssr)/../node_modules/@solana/wallet-adapter-react-ui/lib/esm/useWalletModal.js":
/*!*********************************************************************************!*\
  !*** ../node_modules/@solana/wallet-adapter-react-ui/lib/esm/useWalletModal.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   WalletModalContext: () => (/* binding */ WalletModalContext),\n/* harmony export */   useWalletModal: () => (/* binding */ useWalletModal)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/../node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n\nconst DEFAULT_CONTEXT = {\n    setVisible (_open) {\n        console.error(constructMissingProviderErrorMessage(\"call\", \"setVisible\"));\n    },\n    visible: false\n};\nObject.defineProperty(DEFAULT_CONTEXT, \"visible\", {\n    get () {\n        console.error(constructMissingProviderErrorMessage(\"read\", \"visible\"));\n        return false;\n    }\n});\nfunction constructMissingProviderErrorMessage(action, valueName) {\n    return \"You have tried to \" + ` ${action} \"${valueName}\"` + \" on a WalletModalContext without providing one.\" + \" Make sure to render a WalletModalProvider\" + \" as an ancestor of the component that uses \" + \"WalletModalContext\";\n}\nconst WalletModalContext = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.createContext)(DEFAULT_CONTEXT);\nfunction useWalletModal() {\n    return (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(WalletModalContext);\n} //# sourceMappingURL=useWalletModal.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL0Bzb2xhbmEvd2FsbGV0LWFkYXB0ZXItcmVhY3QtdWkvbGliL2VzbS91c2VXYWxsZXRNb2RhbC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBa0Q7QUFDbEQsTUFBTUUsa0JBQWtCO0lBQ3BCQyxZQUFXQyxLQUFLO1FBQ1pDLFFBQVFDLEtBQUssQ0FBQ0MscUNBQXFDLFFBQVE7SUFDL0Q7SUFDQUMsU0FBUztBQUNiO0FBQ0FDLE9BQU9DLGNBQWMsQ0FBQ1IsaUJBQWlCLFdBQVc7SUFDOUNTO1FBQ0lOLFFBQVFDLEtBQUssQ0FBQ0MscUNBQXFDLFFBQVE7UUFDM0QsT0FBTztJQUNYO0FBQ0o7QUFDQSxTQUFTQSxxQ0FBcUNLLE1BQU0sRUFBRUMsU0FBUztJQUMzRCxPQUFRLHVCQUNKLENBQUMsQ0FBQyxFQUFFRCxPQUFPLEVBQUUsRUFBRUMsVUFBVSxDQUFDLENBQUMsR0FDM0Isb0RBQ0EsK0NBQ0EsZ0RBQ0E7QUFDUjtBQUNPLE1BQU1DLG1DQUFxQmQsb0RBQWFBLENBQUNFLGlCQUFpQjtBQUMxRCxTQUFTYTtJQUNaLE9BQU9kLGlEQUFVQSxDQUFDYTtBQUN0QixFQUNBLDBDQUEwQyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvQHNvbGFuYS93YWxsZXQtYWRhcHRlci1yZWFjdC11aS9saWIvZXNtL3VzZVdhbGxldE1vZGFsLmpzPzY5MzQiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgY3JlYXRlQ29udGV4dCwgdXNlQ29udGV4dCB9IGZyb20gJ3JlYWN0JztcbmNvbnN0IERFRkFVTFRfQ09OVEVYVCA9IHtcbiAgICBzZXRWaXNpYmxlKF9vcGVuKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoY29uc3RydWN0TWlzc2luZ1Byb3ZpZGVyRXJyb3JNZXNzYWdlKCdjYWxsJywgJ3NldFZpc2libGUnKSk7XG4gICAgfSxcbiAgICB2aXNpYmxlOiBmYWxzZSxcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoREVGQVVMVF9DT05URVhULCAndmlzaWJsZScsIHtcbiAgICBnZXQoKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoY29uc3RydWN0TWlzc2luZ1Byb3ZpZGVyRXJyb3JNZXNzYWdlKCdyZWFkJywgJ3Zpc2libGUnKSk7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9LFxufSk7XG5mdW5jdGlvbiBjb25zdHJ1Y3RNaXNzaW5nUHJvdmlkZXJFcnJvck1lc3NhZ2UoYWN0aW9uLCB2YWx1ZU5hbWUpIHtcbiAgICByZXR1cm4gKCdZb3UgaGF2ZSB0cmllZCB0byAnICtcbiAgICAgICAgYCAke2FjdGlvbn0gXCIke3ZhbHVlTmFtZX1cImAgK1xuICAgICAgICAnIG9uIGEgV2FsbGV0TW9kYWxDb250ZXh0IHdpdGhvdXQgcHJvdmlkaW5nIG9uZS4nICtcbiAgICAgICAgJyBNYWtlIHN1cmUgdG8gcmVuZGVyIGEgV2FsbGV0TW9kYWxQcm92aWRlcicgK1xuICAgICAgICAnIGFzIGFuIGFuY2VzdG9yIG9mIHRoZSBjb21wb25lbnQgdGhhdCB1c2VzICcgK1xuICAgICAgICAnV2FsbGV0TW9kYWxDb250ZXh0Jyk7XG59XG5leHBvcnQgY29uc3QgV2FsbGV0TW9kYWxDb250ZXh0ID0gY3JlYXRlQ29udGV4dChERUZBVUxUX0NPTlRFWFQpO1xuZXhwb3J0IGZ1bmN0aW9uIHVzZVdhbGxldE1vZGFsKCkge1xuICAgIHJldHVybiB1c2VDb250ZXh0KFdhbGxldE1vZGFsQ29udGV4dCk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD11c2VXYWxsZXRNb2RhbC5qcy5tYXAiXSwibmFtZXMiOlsiY3JlYXRlQ29udGV4dCIsInVzZUNvbnRleHQiLCJERUZBVUxUX0NPTlRFWFQiLCJzZXRWaXNpYmxlIiwiX29wZW4iLCJjb25zb2xlIiwiZXJyb3IiLCJjb25zdHJ1Y3RNaXNzaW5nUHJvdmlkZXJFcnJvck1lc3NhZ2UiLCJ2aXNpYmxlIiwiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJnZXQiLCJhY3Rpb24iLCJ2YWx1ZU5hbWUiLCJXYWxsZXRNb2RhbENvbnRleHQiLCJ1c2VXYWxsZXRNb2RhbCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/@solana/wallet-adapter-react-ui/lib/esm/useWalletModal.js\n");

/***/ }),

/***/ "(ssr)/../node_modules/@solana/wallet-adapter-react/lib/esm/ConnectionProvider.js":
/*!**********************************************************************************!*\
  !*** ../node_modules/@solana/wallet-adapter-react/lib/esm/ConnectionProvider.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ConnectionProvider: () => (/* binding */ ConnectionProvider)\n/* harmony export */ });\n/* harmony import */ var _solana_web3_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @solana/web3.js */ \"(ssr)/../node_modules/@solana/web3.js/lib/index.esm.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(ssr)/../node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var _useConnection_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./useConnection.js */ \"(ssr)/../node_modules/@solana/wallet-adapter-react/lib/esm/useConnection.js\");\n\n\n\nconst ConnectionProvider = ({ children, endpoint, config = {\n    commitment: \"confirmed\"\n} })=>{\n    const connection = (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)(()=>new _solana_web3_js__WEBPACK_IMPORTED_MODULE_0__.Connection(endpoint, config), [\n        endpoint,\n        config\n    ]);\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1__.createElement(_useConnection_js__WEBPACK_IMPORTED_MODULE_2__.ConnectionContext.Provider, {\n        value: {\n            connection\n        }\n    }, children);\n}; //# sourceMappingURL=ConnectionProvider.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL0Bzb2xhbmEvd2FsbGV0LWFkYXB0ZXItcmVhY3QvbGliL2VzbS9Db25uZWN0aW9uUHJvdmlkZXIuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUE2QztBQUNOO0FBQ2dCO0FBQ2hELE1BQU1JLHFCQUFxQixDQUFDLEVBQUVDLFFBQVEsRUFBRUMsUUFBUSxFQUFFQyxTQUFTO0lBQUVDLFlBQVk7QUFBWSxDQUFDLEVBQUc7SUFDNUYsTUFBTUMsYUFBYVAsOENBQU9BLENBQUMsSUFBTSxJQUFJRix1REFBVUEsQ0FBQ00sVUFBVUMsU0FBUztRQUFDRDtRQUFVQztLQUFPO0lBQ3JGLHFCQUFPTixnREFBbUIsQ0FBQ0UsZ0VBQWlCQSxDQUFDUSxRQUFRLEVBQUU7UUFBRUMsT0FBTztZQUFFSDtRQUFXO0lBQUUsR0FBR0o7QUFDdEYsRUFBRSxDQUNGLDhDQUE4QyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvQHNvbGFuYS93YWxsZXQtYWRhcHRlci1yZWFjdC9saWIvZXNtL0Nvbm5lY3Rpb25Qcm92aWRlci5qcz9jZWJjIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IENvbm5lY3Rpb24gfSBmcm9tICdAc29sYW5hL3dlYjMuanMnO1xuaW1wb3J0IFJlYWN0LCB7IHVzZU1lbW8gfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyBDb25uZWN0aW9uQ29udGV4dCB9IGZyb20gJy4vdXNlQ29ubmVjdGlvbi5qcyc7XG5leHBvcnQgY29uc3QgQ29ubmVjdGlvblByb3ZpZGVyID0gKHsgY2hpbGRyZW4sIGVuZHBvaW50LCBjb25maWcgPSB7IGNvbW1pdG1lbnQ6ICdjb25maXJtZWQnIH0sIH0pID0+IHtcbiAgICBjb25zdCBjb25uZWN0aW9uID0gdXNlTWVtbygoKSA9PiBuZXcgQ29ubmVjdGlvbihlbmRwb2ludCwgY29uZmlnKSwgW2VuZHBvaW50LCBjb25maWddKTtcbiAgICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChDb25uZWN0aW9uQ29udGV4dC5Qcm92aWRlciwgeyB2YWx1ZTogeyBjb25uZWN0aW9uIH0gfSwgY2hpbGRyZW4pO1xufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUNvbm5lY3Rpb25Qcm92aWRlci5qcy5tYXAiXSwibmFtZXMiOlsiQ29ubmVjdGlvbiIsIlJlYWN0IiwidXNlTWVtbyIsIkNvbm5lY3Rpb25Db250ZXh0IiwiQ29ubmVjdGlvblByb3ZpZGVyIiwiY2hpbGRyZW4iLCJlbmRwb2ludCIsImNvbmZpZyIsImNvbW1pdG1lbnQiLCJjb25uZWN0aW9uIiwiY3JlYXRlRWxlbWVudCIsIlByb3ZpZGVyIiwidmFsdWUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/@solana/wallet-adapter-react/lib/esm/ConnectionProvider.js\n");

/***/ }),

/***/ "(ssr)/../node_modules/@solana/wallet-adapter-react/lib/esm/WalletProvider.js":
/*!******************************************************************************!*\
  !*** ../node_modules/@solana/wallet-adapter-react/lib/esm/WalletProvider.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   WalletProvider: () => (/* binding */ WalletProvider)\n/* harmony export */ });\n/* harmony import */ var _solana_mobile_wallet_adapter_mobile__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @solana-mobile/wallet-adapter-mobile */ \"(ssr)/../node_modules/@solana-mobile/wallet-adapter-mobile/lib/esm/index.js\");\n/* harmony import */ var _solana_wallet_standard_wallet_adapter_react__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @solana/wallet-standard-wallet-adapter-react */ \"(ssr)/../node_modules/@solana/wallet-standard-wallet-adapter-react/lib/esm/useStandardWalletAdapters.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(ssr)/../node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var _getEnvironment_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./getEnvironment.js */ \"(ssr)/../node_modules/@solana/wallet-adapter-react/lib/esm/getEnvironment.js\");\n/* harmony import */ var _getInferredClusterFromEndpoint_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./getInferredClusterFromEndpoint.js */ \"(ssr)/../node_modules/@solana/wallet-adapter-react/lib/esm/getInferredClusterFromEndpoint.js\");\n/* harmony import */ var _useConnection_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./useConnection.js */ \"(ssr)/../node_modules/@solana/wallet-adapter-react/lib/esm/useConnection.js\");\n/* harmony import */ var _useLocalStorage_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./useLocalStorage.js */ \"(ssr)/../node_modules/@solana/wallet-adapter-react/lib/esm/useLocalStorage.js\");\n/* harmony import */ var _WalletProviderBase_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./WalletProviderBase.js */ \"(ssr)/../node_modules/@solana/wallet-adapter-react/lib/esm/WalletProviderBase.js\");\n\n\n\n\n\n\n\n\nlet _userAgent;\nfunction getUserAgent() {\n    if (_userAgent === undefined) {\n        _userAgent = globalThis.navigator?.userAgent ?? null;\n    }\n    return _userAgent;\n}\nfunction getIsMobile(adapters) {\n    const userAgentString = getUserAgent();\n    return (0,_getEnvironment_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"])({\n        adapters,\n        userAgentString\n    }) === _getEnvironment_js__WEBPACK_IMPORTED_MODULE_2__.Environment.MOBILE_WEB;\n}\nfunction getUriForAppIdentity() {\n    const location = globalThis.location;\n    if (!location) return;\n    return `${location.protocol}//${location.host}`;\n}\nfunction WalletProvider({ children, wallets: adapters, autoConnect, localStorageKey = \"walletName\", onError }) {\n    const { connection } = (0,_useConnection_js__WEBPACK_IMPORTED_MODULE_3__.useConnection)();\n    const adaptersWithStandardAdapters = (0,_solana_wallet_standard_wallet_adapter_react__WEBPACK_IMPORTED_MODULE_4__.useStandardWalletAdapters)(adapters);\n    const mobileWalletAdapter = (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)(()=>{\n        if (!getIsMobile(adaptersWithStandardAdapters)) {\n            return null;\n        }\n        const existingMobileWalletAdapter = adaptersWithStandardAdapters.find((adapter)=>adapter.name === _solana_mobile_wallet_adapter_mobile__WEBPACK_IMPORTED_MODULE_0__.SolanaMobileWalletAdapterWalletName);\n        if (existingMobileWalletAdapter) {\n            return existingMobileWalletAdapter;\n        }\n        return new _solana_mobile_wallet_adapter_mobile__WEBPACK_IMPORTED_MODULE_0__.SolanaMobileWalletAdapter({\n            addressSelector: (0,_solana_mobile_wallet_adapter_mobile__WEBPACK_IMPORTED_MODULE_0__.createDefaultAddressSelector)(),\n            appIdentity: {\n                uri: getUriForAppIdentity()\n            },\n            authorizationResultCache: (0,_solana_mobile_wallet_adapter_mobile__WEBPACK_IMPORTED_MODULE_0__.createDefaultAuthorizationResultCache)(),\n            cluster: (0,_getInferredClusterFromEndpoint_js__WEBPACK_IMPORTED_MODULE_5__[\"default\"])(connection?.rpcEndpoint),\n            onWalletNotFound: (0,_solana_mobile_wallet_adapter_mobile__WEBPACK_IMPORTED_MODULE_0__.createDefaultWalletNotFoundHandler)()\n        });\n    }, [\n        adaptersWithStandardAdapters,\n        connection?.rpcEndpoint\n    ]);\n    const adaptersWithMobileWalletAdapter = (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)(()=>{\n        if (mobileWalletAdapter == null || adaptersWithStandardAdapters.indexOf(mobileWalletAdapter) !== -1) {\n            return adaptersWithStandardAdapters;\n        }\n        return [\n            mobileWalletAdapter,\n            ...adaptersWithStandardAdapters\n        ];\n    }, [\n        adaptersWithStandardAdapters,\n        mobileWalletAdapter\n    ]);\n    const [walletName, setWalletName] = (0,_useLocalStorage_js__WEBPACK_IMPORTED_MODULE_6__.useLocalStorage)(localStorageKey, getIsMobile(adaptersWithStandardAdapters) ? _solana_mobile_wallet_adapter_mobile__WEBPACK_IMPORTED_MODULE_0__.SolanaMobileWalletAdapterWalletName : null);\n    const adapter = (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)(()=>adaptersWithMobileWalletAdapter.find((a)=>a.name === walletName) ?? null, [\n        adaptersWithMobileWalletAdapter,\n        walletName\n    ]);\n    const changeWallet = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)((nextWalletName)=>{\n        if (walletName === nextWalletName) return;\n        if (adapter && // Selecting a wallet other than the mobile wallet adapter is not\n        // sufficient reason to call `disconnect` on the mobile wallet adapter.\n        // Calling `disconnect` on the mobile wallet adapter causes the entire\n        // authorization store to be wiped.\n        adapter.name !== _solana_mobile_wallet_adapter_mobile__WEBPACK_IMPORTED_MODULE_0__.SolanaMobileWalletAdapterWalletName) {\n            adapter.disconnect();\n        }\n        setWalletName(nextWalletName);\n    }, [\n        adapter,\n        setWalletName,\n        walletName\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        if (!adapter) return;\n        function handleDisconnect() {\n            if (isUnloadingRef.current) return;\n            // Leave the adapter selected in the event of a disconnection.\n            if (walletName === _solana_mobile_wallet_adapter_mobile__WEBPACK_IMPORTED_MODULE_0__.SolanaMobileWalletAdapterWalletName && getIsMobile(adaptersWithStandardAdapters)) return;\n            setWalletName(null);\n        }\n        adapter.on(\"disconnect\", handleDisconnect);\n        return ()=>{\n            adapter.off(\"disconnect\", handleDisconnect);\n        };\n    }, [\n        adapter,\n        adaptersWithStandardAdapters,\n        setWalletName,\n        walletName\n    ]);\n    const hasUserSelectedAWallet = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(false);\n    const handleAutoConnectRequest = (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)(()=>{\n        if (!autoConnect || !adapter) return;\n        return async ()=>{\n            // If autoConnect is true or returns true, use the default autoConnect behavior.\n            if (autoConnect === true || await autoConnect(adapter)) {\n                if (hasUserSelectedAWallet.current) {\n                    await adapter.connect();\n                } else {\n                    await adapter.autoConnect();\n                }\n            }\n        };\n    }, [\n        autoConnect,\n        adapter\n    ]);\n    const isUnloadingRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(false);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        if (walletName === _solana_mobile_wallet_adapter_mobile__WEBPACK_IMPORTED_MODULE_0__.SolanaMobileWalletAdapterWalletName && getIsMobile(adaptersWithStandardAdapters)) {\n            isUnloadingRef.current = false;\n            return;\n        }\n        function handleBeforeUnload() {\n            isUnloadingRef.current = true;\n        }\n        /**\n         * Some wallets fire disconnection events when the window unloads. Since there's no way to\n         * distinguish between a disconnection event received because a user initiated it, and one\n         * that was received because they've closed the window, we have to track window unload\n         * events themselves. Downstream components use this information to decide whether to act\n         * upon or drop wallet events and errors.\n         */ window.addEventListener(\"beforeunload\", handleBeforeUnload);\n        return ()=>{\n            window.removeEventListener(\"beforeunload\", handleBeforeUnload);\n        };\n    }, [\n        adaptersWithStandardAdapters,\n        walletName\n    ]);\n    const handleConnectError = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)(()=>{\n        if (adapter && adapter.name !== _solana_mobile_wallet_adapter_mobile__WEBPACK_IMPORTED_MODULE_0__.SolanaMobileWalletAdapterWalletName) {\n            // If any error happens while connecting, unset the adapter.\n            changeWallet(null);\n        }\n    }, [\n        adapter,\n        changeWallet\n    ]);\n    const selectWallet = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)((walletName)=>{\n        hasUserSelectedAWallet.current = true;\n        changeWallet(walletName);\n    }, [\n        changeWallet\n    ]);\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1__.createElement(_WalletProviderBase_js__WEBPACK_IMPORTED_MODULE_7__.WalletProviderBase, {\n        wallets: adaptersWithMobileWalletAdapter,\n        adapter: adapter,\n        isUnloadingRef: isUnloadingRef,\n        onAutoConnectRequest: handleAutoConnectRequest,\n        onConnectError: handleConnectError,\n        onError: onError,\n        onSelectWallet: selectWallet\n    }, children);\n} //# sourceMappingURL=WalletProvider.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL0Bzb2xhbmEvd2FsbGV0LWFkYXB0ZXItcmVhY3QvbGliL2VzbS9XYWxsZXRQcm92aWRlci5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7QUFBZ087QUFDdkk7QUFDbEI7QUFDTDtBQUNlO0FBQzlCO0FBQ0k7QUFDTTtBQUM3RCxJQUFJaUI7QUFDSixTQUFTQztJQUNMLElBQUlELGVBQWVFLFdBQVc7UUFDMUJGLGFBQWFHLFdBQVdDLFNBQVMsRUFBRUMsYUFBYTtJQUNwRDtJQUNBLE9BQU9MO0FBQ1g7QUFDQSxTQUFTTSxZQUFZQyxRQUFRO0lBQ3pCLE1BQU1DLGtCQUFrQlA7SUFDeEIsT0FBT1AsOERBQWNBLENBQUM7UUFBRWE7UUFBVUM7SUFBZ0IsT0FBT2IsMkRBQVdBLENBQUNjLFVBQVU7QUFDbkY7QUFDQSxTQUFTQztJQUNMLE1BQU1DLFdBQVdSLFdBQVdRLFFBQVE7SUFDcEMsSUFBSSxDQUFDQSxVQUNEO0lBQ0osT0FBTyxDQUFDLEVBQUVBLFNBQVNDLFFBQVEsQ0FBQyxFQUFFLEVBQUVELFNBQVNFLElBQUksQ0FBQyxDQUFDO0FBQ25EO0FBQ08sU0FBU0MsZUFBZSxFQUFFQyxRQUFRLEVBQUVDLFNBQVNULFFBQVEsRUFBRVUsV0FBVyxFQUFFQyxrQkFBa0IsWUFBWSxFQUFFQyxPQUFPLEVBQUc7SUFDakgsTUFBTSxFQUFFQyxVQUFVLEVBQUUsR0FBR3ZCLGdFQUFhQTtJQUNwQyxNQUFNd0IsK0JBQStCakMsdUdBQXlCQSxDQUFDbUI7SUFDL0QsTUFBTWUsc0JBQXNCOUIsOENBQU9BLENBQUM7UUFDaEMsSUFBSSxDQUFDYyxZQUFZZSwrQkFBK0I7WUFDNUMsT0FBTztRQUNYO1FBQ0EsTUFBTUUsOEJBQThCRiw2QkFBNkJHLElBQUksQ0FBQyxDQUFDQyxVQUFZQSxRQUFRQyxJQUFJLEtBQUt2QyxxR0FBbUNBO1FBQ3ZJLElBQUlvQyw2QkFBNkI7WUFDN0IsT0FBT0E7UUFDWDtRQUNBLE9BQU8sSUFBSXJDLDJGQUF5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QUFDZDtRQUFTYztLQUFhO0lBQzFCLE1BQU1nQixlQUFlakUsa0RBQVdBLENBQUMsQ0FBQzhDO1FBQzlCVyx1QkFBdUJILE9BQU8sR0FBRztRQUNqQ0wsYUFBYUg7SUFDakIsR0FBRztRQUFDRztLQUFhO0lBQ2pCLHFCQUFRbEQsZ0RBQW1CLENBQUNVLHNFQUFrQkEsRUFBRTtRQUFFaUIsU0FBU2tCO1FBQWlDVCxTQUFTQTtRQUFTa0IsZ0JBQWdCQTtRQUFnQmMsc0JBQXNCVDtRQUEwQlUsZ0JBQWdCSjtRQUFvQm5DLFNBQVNBO1FBQVN3QyxnQkFBZ0JKO0lBQWEsR0FBR3hDO0FBQ3hSLEVBQ0EsMENBQTBDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9Ac29sYW5hL3dhbGxldC1hZGFwdGVyLXJlYWN0L2xpYi9lc20vV2FsbGV0UHJvdmlkZXIuanM/NjMyMiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBjcmVhdGVEZWZhdWx0QWRkcmVzc1NlbGVjdG9yLCBjcmVhdGVEZWZhdWx0QXV0aG9yaXphdGlvblJlc3VsdENhY2hlLCBjcmVhdGVEZWZhdWx0V2FsbGV0Tm90Rm91bmRIYW5kbGVyLCBTb2xhbmFNb2JpbGVXYWxsZXRBZGFwdGVyLCBTb2xhbmFNb2JpbGVXYWxsZXRBZGFwdGVyV2FsbGV0TmFtZSwgfSBmcm9tICdAc29sYW5hLW1vYmlsZS93YWxsZXQtYWRhcHRlci1tb2JpbGUnO1xuaW1wb3J0IHsgdXNlU3RhbmRhcmRXYWxsZXRBZGFwdGVycyB9IGZyb20gJ0Bzb2xhbmEvd2FsbGV0LXN0YW5kYXJkLXdhbGxldC1hZGFwdGVyLXJlYWN0JztcbmltcG9ydCBSZWFjdCwgeyB1c2VDYWxsYmFjaywgdXNlRWZmZWN0LCB1c2VNZW1vLCB1c2VSZWYgfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgZ2V0RW52aXJvbm1lbnQsIHsgRW52aXJvbm1lbnQgfSBmcm9tICcuL2dldEVudmlyb25tZW50LmpzJztcbmltcG9ydCBnZXRJbmZlcnJlZENsdXN0ZXJGcm9tRW5kcG9pbnQgZnJvbSAnLi9nZXRJbmZlcnJlZENsdXN0ZXJGcm9tRW5kcG9pbnQuanMnO1xuaW1wb3J0IHsgdXNlQ29ubmVjdGlvbiB9IGZyb20gJy4vdXNlQ29ubmVjdGlvbi5qcyc7XG5pbXBvcnQgeyB1c2VMb2NhbFN0b3JhZ2UgfSBmcm9tICcuL3VzZUxvY2FsU3RvcmFnZS5qcyc7XG5pbXBvcnQgeyBXYWxsZXRQcm92aWRlckJhc2UgfSBmcm9tICcuL1dhbGxldFByb3ZpZGVyQmFzZS5qcyc7XG5sZXQgX3VzZXJBZ2VudDtcbmZ1bmN0aW9uIGdldFVzZXJBZ2VudCgpIHtcbiAgICBpZiAoX3VzZXJBZ2VudCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIF91c2VyQWdlbnQgPSBnbG9iYWxUaGlzLm5hdmlnYXRvcj8udXNlckFnZW50ID8/IG51bGw7XG4gICAgfVxuICAgIHJldHVybiBfdXNlckFnZW50O1xufVxuZnVuY3Rpb24gZ2V0SXNNb2JpbGUoYWRhcHRlcnMpIHtcbiAgICBjb25zdCB1c2VyQWdlbnRTdHJpbmcgPSBnZXRVc2VyQWdlbnQoKTtcbiAgICByZXR1cm4gZ2V0RW52aXJvbm1lbnQoeyBhZGFwdGVycywgdXNlckFnZW50U3RyaW5nIH0pID09PSBFbnZpcm9ubWVudC5NT0JJTEVfV0VCO1xufVxuZnVuY3Rpb24gZ2V0VXJpRm9yQXBwSWRlbnRpdHkoKSB7XG4gICAgY29uc3QgbG9jYXRpb24gPSBnbG9iYWxUaGlzLmxvY2F0aW9uO1xuICAgIGlmICghbG9jYXRpb24pXG4gICAgICAgIHJldHVybjtcbiAgICByZXR1cm4gYCR7bG9jYXRpb24ucHJvdG9jb2x9Ly8ke2xvY2F0aW9uLmhvc3R9YDtcbn1cbmV4cG9ydCBmdW5jdGlvbiBXYWxsZXRQcm92aWRlcih7IGNoaWxkcmVuLCB3YWxsZXRzOiBhZGFwdGVycywgYXV0b0Nvbm5lY3QsIGxvY2FsU3RvcmFnZUtleSA9ICd3YWxsZXROYW1lJywgb25FcnJvciwgfSkge1xuICAgIGNvbnN0IHsgY29ubmVjdGlvbiB9ID0gdXNlQ29ubmVjdGlvbigpO1xuICAgIGNvbnN0IGFkYXB0ZXJzV2l0aFN0YW5kYXJkQWRhcHRlcnMgPSB1c2VTdGFuZGFyZFdhbGxldEFkYXB0ZXJzKGFkYXB0ZXJzKTtcbiAgICBjb25zdCBtb2JpbGVXYWxsZXRBZGFwdGVyID0gdXNlTWVtbygoKSA9PiB7XG4gICAgICAgIGlmICghZ2V0SXNNb2JpbGUoYWRhcHRlcnNXaXRoU3RhbmRhcmRBZGFwdGVycykpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGV4aXN0aW5nTW9iaWxlV2FsbGV0QWRhcHRlciA9IGFkYXB0ZXJzV2l0aFN0YW5kYXJkQWRhcHRlcnMuZmluZCgoYWRhcHRlcikgPT4gYWRhcHRlci5uYW1lID09PSBTb2xhbmFNb2JpbGVXYWxsZXRBZGFwdGVyV2FsbGV0TmFtZSk7XG4gICAgICAgIGlmIChleGlzdGluZ01vYmlsZVdhbGxldEFkYXB0ZXIpIHtcbiAgICAgICAgICAgIHJldHVybiBleGlzdGluZ01vYmlsZVdhbGxldEFkYXB0ZXI7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBTb2xhbmFNb2JpbGVXYWxsZXRBZGFwdGVyKHtcbiAgICAgICAgICAgIGFkZHJlc3NTZWxlY3RvcjogY3JlYXRlRGVmYXVsdEFkZHJlc3NTZWxlY3RvcigpLFxuICAgICAgICAgICAgYXBwSWRlbnRpdHk6IHtcbiAgICAgICAgICAgICAgICB1cmk6IGdldFVyaUZvckFwcElkZW50aXR5KCksXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgYXV0aG9yaXphdGlvblJlc3VsdENhY2hlOiBjcmVhdGVEZWZhdWx0QXV0aG9yaXphdGlvblJlc3VsdENhY2hlKCksXG4gICAgICAgICAgICBjbHVzdGVyOiBnZXRJbmZlcnJlZENsdXN0ZXJGcm9tRW5kcG9pbnQoY29ubmVjdGlvbj8ucnBjRW5kcG9pbnQpLFxuICAgICAgICAgICAgb25XYWxsZXROb3RGb3VuZDogY3JlYXRlRGVmYXVsdFdhbGxldE5vdEZvdW5kSGFuZGxlcigpLFxuICAgICAgICB9KTtcbiAgICB9LCBbYWRhcHRlcnNXaXRoU3RhbmRhcmRBZGFwdGVycywgY29ubmVjdGlvbj8ucnBjRW5kcG9pbnRdKTtcbiAgICBjb25zdCBhZGFwdGVyc1dpdGhNb2JpbGVXYWxsZXRBZGFwdGVyID0gdXNlTWVtbygoKSA9PiB7XG4gICAgICAgIGlmIChtb2JpbGVXYWxsZXRBZGFwdGVyID09IG51bGwgfHwgYWRhcHRlcnNXaXRoU3RhbmRhcmRBZGFwdGVycy5pbmRleE9mKG1vYmlsZVdhbGxldEFkYXB0ZXIpICE9PSAtMSkge1xuICAgICAgICAgICAgcmV0dXJuIGFkYXB0ZXJzV2l0aFN0YW5kYXJkQWRhcHRlcnM7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFttb2JpbGVXYWxsZXRBZGFwdGVyLCAuLi5hZGFwdGVyc1dpdGhTdGFuZGFyZEFkYXB0ZXJzXTtcbiAgICB9LCBbYWRhcHRlcnNXaXRoU3RhbmRhcmRBZGFwdGVycywgbW9iaWxlV2FsbGV0QWRhcHRlcl0pO1xuICAgIGNvbnN0IFt3YWxsZXROYW1lLCBzZXRXYWxsZXROYW1lXSA9IHVzZUxvY2FsU3RvcmFnZShsb2NhbFN0b3JhZ2VLZXksIGdldElzTW9iaWxlKGFkYXB0ZXJzV2l0aFN0YW5kYXJkQWRhcHRlcnMpID8gU29sYW5hTW9iaWxlV2FsbGV0QWRhcHRlcldhbGxldE5hbWUgOiBudWxsKTtcbiAgICBjb25zdCBhZGFwdGVyID0gdXNlTWVtbygoKSA9PiBhZGFwdGVyc1dpdGhNb2JpbGVXYWxsZXRBZGFwdGVyLmZpbmQoKGEpID0+IGEubmFtZSA9PT0gd2FsbGV0TmFtZSkgPz8gbnVsbCwgW2FkYXB0ZXJzV2l0aE1vYmlsZVdhbGxldEFkYXB0ZXIsIHdhbGxldE5hbWVdKTtcbiAgICBjb25zdCBjaGFuZ2VXYWxsZXQgPSB1c2VDYWxsYmFjaygobmV4dFdhbGxldE5hbWUpID0+IHtcbiAgICAgICAgaWYgKHdhbGxldE5hbWUgPT09IG5leHRXYWxsZXROYW1lKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBpZiAoYWRhcHRlciAmJlxuICAgICAgICAgICAgLy8gU2VsZWN0aW5nIGEgd2FsbGV0IG90aGVyIHRoYW4gdGhlIG1vYmlsZSB3YWxsZXQgYWRhcHRlciBpcyBub3RcbiAgICAgICAgICAgIC8vIHN1ZmZpY2llbnQgcmVhc29uIHRvIGNhbGwgYGRpc2Nvbm5lY3RgIG9uIHRoZSBtb2JpbGUgd2FsbGV0IGFkYXB0ZXIuXG4gICAgICAgICAgICAvLyBDYWxsaW5nIGBkaXNjb25uZWN0YCBvbiB0aGUgbW9iaWxlIHdhbGxldCBhZGFwdGVyIGNhdXNlcyB0aGUgZW50aXJlXG4gICAgICAgICAgICAvLyBhdXRob3JpemF0aW9uIHN0b3JlIHRvIGJlIHdpcGVkLlxuICAgICAgICAgICAgYWRhcHRlci5uYW1lICE9PSBTb2xhbmFNb2JpbGVXYWxsZXRBZGFwdGVyV2FsbGV0TmFtZSkge1xuICAgICAgICAgICAgYWRhcHRlci5kaXNjb25uZWN0KCk7XG4gICAgICAgIH1cbiAgICAgICAgc2V0V2FsbGV0TmFtZShuZXh0V2FsbGV0TmFtZSk7XG4gICAgfSwgW2FkYXB0ZXIsIHNldFdhbGxldE5hbWUsIHdhbGxldE5hbWVdKTtcbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgICBpZiAoIWFkYXB0ZXIpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGZ1bmN0aW9uIGhhbmRsZURpc2Nvbm5lY3QoKSB7XG4gICAgICAgICAgICBpZiAoaXNVbmxvYWRpbmdSZWYuY3VycmVudClcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAvLyBMZWF2ZSB0aGUgYWRhcHRlciBzZWxlY3RlZCBpbiB0aGUgZXZlbnQgb2YgYSBkaXNjb25uZWN0aW9uLlxuICAgICAgICAgICAgaWYgKHdhbGxldE5hbWUgPT09IFNvbGFuYU1vYmlsZVdhbGxldEFkYXB0ZXJXYWxsZXROYW1lICYmIGdldElzTW9iaWxlKGFkYXB0ZXJzV2l0aFN0YW5kYXJkQWRhcHRlcnMpKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIHNldFdhbGxldE5hbWUobnVsbCk7XG4gICAgICAgIH1cbiAgICAgICAgYWRhcHRlci5vbignZGlzY29ubmVjdCcsIGhhbmRsZURpc2Nvbm5lY3QpO1xuICAgICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICAgICAgYWRhcHRlci5vZmYoJ2Rpc2Nvbm5lY3QnLCBoYW5kbGVEaXNjb25uZWN0KTtcbiAgICAgICAgfTtcbiAgICB9LCBbYWRhcHRlciwgYWRhcHRlcnNXaXRoU3RhbmRhcmRBZGFwdGVycywgc2V0V2FsbGV0TmFtZSwgd2FsbGV0TmFtZV0pO1xuICAgIGNvbnN0IGhhc1VzZXJTZWxlY3RlZEFXYWxsZXQgPSB1c2VSZWYoZmFsc2UpO1xuICAgIGNvbnN0IGhhbmRsZUF1dG9Db25uZWN0UmVxdWVzdCA9IHVzZU1lbW8oKCkgPT4ge1xuICAgICAgICBpZiAoIWF1dG9Db25uZWN0IHx8ICFhZGFwdGVyKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICByZXR1cm4gYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgLy8gSWYgYXV0b0Nvbm5lY3QgaXMgdHJ1ZSBvciByZXR1cm5zIHRydWUsIHVzZSB0aGUgZGVmYXVsdCBhdXRvQ29ubmVjdCBiZWhhdmlvci5cbiAgICAgICAgICAgIGlmIChhdXRvQ29ubmVjdCA9PT0gdHJ1ZSB8fCAoYXdhaXQgYXV0b0Nvbm5lY3QoYWRhcHRlcikpKSB7XG4gICAgICAgICAgICAgICAgaWYgKGhhc1VzZXJTZWxlY3RlZEFXYWxsZXQuY3VycmVudCkge1xuICAgICAgICAgICAgICAgICAgICBhd2FpdCBhZGFwdGVyLmNvbm5lY3QoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGF3YWl0IGFkYXB0ZXIuYXV0b0Nvbm5lY3QoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfSwgW2F1dG9Db25uZWN0LCBhZGFwdGVyXSk7XG4gICAgY29uc3QgaXNVbmxvYWRpbmdSZWYgPSB1c2VSZWYoZmFsc2UpO1xuICAgIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICAgIGlmICh3YWxsZXROYW1lID09PSBTb2xhbmFNb2JpbGVXYWxsZXRBZGFwdGVyV2FsbGV0TmFtZSAmJiBnZXRJc01vYmlsZShhZGFwdGVyc1dpdGhTdGFuZGFyZEFkYXB0ZXJzKSkge1xuICAgICAgICAgICAgaXNVbmxvYWRpbmdSZWYuY3VycmVudCA9IGZhbHNlO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGhhbmRsZUJlZm9yZVVubG9hZCgpIHtcbiAgICAgICAgICAgIGlzVW5sb2FkaW5nUmVmLmN1cnJlbnQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTb21lIHdhbGxldHMgZmlyZSBkaXNjb25uZWN0aW9uIGV2ZW50cyB3aGVuIHRoZSB3aW5kb3cgdW5sb2Fkcy4gU2luY2UgdGhlcmUncyBubyB3YXkgdG9cbiAgICAgICAgICogZGlzdGluZ3Vpc2ggYmV0d2VlbiBhIGRpc2Nvbm5lY3Rpb24gZXZlbnQgcmVjZWl2ZWQgYmVjYXVzZSBhIHVzZXIgaW5pdGlhdGVkIGl0LCBhbmQgb25lXG4gICAgICAgICAqIHRoYXQgd2FzIHJlY2VpdmVkIGJlY2F1c2UgdGhleSd2ZSBjbG9zZWQgdGhlIHdpbmRvdywgd2UgaGF2ZSB0byB0cmFjayB3aW5kb3cgdW5sb2FkXG4gICAgICAgICAqIGV2ZW50cyB0aGVtc2VsdmVzLiBEb3duc3RyZWFtIGNvbXBvbmVudHMgdXNlIHRoaXMgaW5mb3JtYXRpb24gdG8gZGVjaWRlIHdoZXRoZXIgdG8gYWN0XG4gICAgICAgICAqIHVwb24gb3IgZHJvcCB3YWxsZXQgZXZlbnRzIGFuZCBlcnJvcnMuXG4gICAgICAgICAqL1xuICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignYmVmb3JldW5sb2FkJywgaGFuZGxlQmVmb3JlVW5sb2FkKTtcbiAgICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdiZWZvcmV1bmxvYWQnLCBoYW5kbGVCZWZvcmVVbmxvYWQpO1xuICAgICAgICB9O1xuICAgIH0sIFthZGFwdGVyc1dpdGhTdGFuZGFyZEFkYXB0ZXJzLCB3YWxsZXROYW1lXSk7XG4gICAgY29uc3QgaGFuZGxlQ29ubmVjdEVycm9yID0gdXNlQ2FsbGJhY2soKCkgPT4ge1xuICAgICAgICBpZiAoYWRhcHRlciAmJiBhZGFwdGVyLm5hbWUgIT09IFNvbGFuYU1vYmlsZVdhbGxldEFkYXB0ZXJXYWxsZXROYW1lKSB7XG4gICAgICAgICAgICAvLyBJZiBhbnkgZXJyb3IgaGFwcGVucyB3aGlsZSBjb25uZWN0aW5nLCB1bnNldCB0aGUgYWRhcHRlci5cbiAgICAgICAgICAgIGNoYW5nZVdhbGxldChudWxsKTtcbiAgICAgICAgfVxuICAgIH0sIFthZGFwdGVyLCBjaGFuZ2VXYWxsZXRdKTtcbiAgICBjb25zdCBzZWxlY3RXYWxsZXQgPSB1c2VDYWxsYmFjaygod2FsbGV0TmFtZSkgPT4ge1xuICAgICAgICBoYXNVc2VyU2VsZWN0ZWRBV2FsbGV0LmN1cnJlbnQgPSB0cnVlO1xuICAgICAgICBjaGFuZ2VXYWxsZXQod2FsbGV0TmFtZSk7XG4gICAgfSwgW2NoYW5nZVdhbGxldF0pO1xuICAgIHJldHVybiAoUmVhY3QuY3JlYXRlRWxlbWVudChXYWxsZXRQcm92aWRlckJhc2UsIHsgd2FsbGV0czogYWRhcHRlcnNXaXRoTW9iaWxlV2FsbGV0QWRhcHRlciwgYWRhcHRlcjogYWRhcHRlciwgaXNVbmxvYWRpbmdSZWY6IGlzVW5sb2FkaW5nUmVmLCBvbkF1dG9Db25uZWN0UmVxdWVzdDogaGFuZGxlQXV0b0Nvbm5lY3RSZXF1ZXN0LCBvbkNvbm5lY3RFcnJvcjogaGFuZGxlQ29ubmVjdEVycm9yLCBvbkVycm9yOiBvbkVycm9yLCBvblNlbGVjdFdhbGxldDogc2VsZWN0V2FsbGV0IH0sIGNoaWxkcmVuKSk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1XYWxsZXRQcm92aWRlci5qcy5tYXAiXSwibmFtZXMiOlsiY3JlYXRlRGVmYXVsdEFkZHJlc3NTZWxlY3RvciIsImNyZWF0ZURlZmF1bHRBdXRob3JpemF0aW9uUmVzdWx0Q2FjaGUiLCJjcmVhdGVEZWZhdWx0V2FsbGV0Tm90Rm91bmRIYW5kbGVyIiwiU29sYW5hTW9iaWxlV2FsbGV0QWRhcHRlciIsIlNvbGFuYU1vYmlsZVdhbGxldEFkYXB0ZXJXYWxsZXROYW1lIiwidXNlU3RhbmRhcmRXYWxsZXRBZGFwdGVycyIsIlJlYWN0IiwidXNlQ2FsbGJhY2siLCJ1c2VFZmZlY3QiLCJ1c2VNZW1vIiwidXNlUmVmIiwiZ2V0RW52aXJvbm1lbnQiLCJFbnZpcm9ubWVudCIsImdldEluZmVycmVkQ2x1c3RlckZyb21FbmRwb2ludCIsInVzZUNvbm5lY3Rpb24iLCJ1c2VMb2NhbFN0b3JhZ2UiLCJXYWxsZXRQcm92aWRlckJhc2UiLCJfdXNlckFnZW50IiwiZ2V0VXNlckFnZW50IiwidW5kZWZpbmVkIiwiZ2xvYmFsVGhpcyIsIm5hdmlnYXRvciIsInVzZXJBZ2VudCIsImdldElzTW9iaWxlIiwiYWRhcHRlcnMiLCJ1c2VyQWdlbnRTdHJpbmciLCJNT0JJTEVfV0VCIiwiZ2V0VXJpRm9yQXBwSWRlbnRpdHkiLCJsb2NhdGlvbiIsInByb3RvY29sIiwiaG9zdCIsIldhbGxldFByb3ZpZGVyIiwiY2hpbGRyZW4iLCJ3YWxsZXRzIiwiYXV0b0Nvbm5lY3QiLCJsb2NhbFN0b3JhZ2VLZXkiLCJvbkVycm9yIiwiY29ubmVjdGlvbiIsImFkYXB0ZXJzV2l0aFN0YW5kYXJkQWRhcHRlcnMiLCJtb2JpbGVXYWxsZXRBZGFwdGVyIiwiZXhpc3RpbmdNb2JpbGVXYWxsZXRBZGFwdGVyIiwiZmluZCIsImFkYXB0ZXIiLCJuYW1lIiwiYWRkcmVzc1NlbGVjdG9yIiwiYXBwSWRlbnRpdHkiLCJ1cmkiLCJhdXRob3JpemF0aW9uUmVzdWx0Q2FjaGUiLCJjbHVzdGVyIiwicnBjRW5kcG9pbnQiLCJvbldhbGxldE5vdEZvdW5kIiwiYWRhcHRlcnNXaXRoTW9iaWxlV2FsbGV0QWRhcHRlciIsImluZGV4T2YiLCJ3YWxsZXROYW1lIiwic2V0V2FsbGV0TmFtZSIsImEiLCJjaGFuZ2VXYWxsZXQiLCJuZXh0V2FsbGV0TmFtZSIsImRpc2Nvbm5lY3QiLCJoYW5kbGVEaXNjb25uZWN0IiwiaXNVbmxvYWRpbmdSZWYiLCJjdXJyZW50Iiwib24iLCJvZmYiLCJoYXNVc2VyU2VsZWN0ZWRBV2FsbGV0IiwiaGFuZGxlQXV0b0Nvbm5lY3RSZXF1ZXN0IiwiY29ubmVjdCIsImhhbmRsZUJlZm9yZVVubG9hZCIsIndpbmRvdyIsImFkZEV2ZW50TGlzdGVuZXIiLCJyZW1vdmVFdmVudExpc3RlbmVyIiwiaGFuZGxlQ29ubmVjdEVycm9yIiwic2VsZWN0V2FsbGV0IiwiY3JlYXRlRWxlbWVudCIsIm9uQXV0b0Nvbm5lY3RSZXF1ZXN0Iiwib25Db25uZWN0RXJyb3IiLCJvblNlbGVjdFdhbGxldCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/@solana/wallet-adapter-react/lib/esm/WalletProvider.js\n");

/***/ }),

/***/ "(ssr)/../node_modules/@solana/wallet-adapter-react/lib/esm/WalletProviderBase.js":
/*!**********************************************************************************!*\
  !*** ../node_modules/@solana/wallet-adapter-react/lib/esm/WalletProviderBase.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   WalletProviderBase: () => (/* binding */ WalletProviderBase)\n/* harmony export */ });\n/* harmony import */ var _solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @solana/wallet-adapter-base */ \"(ssr)/../node_modules/@solana/wallet-adapter-base/lib/esm/errors.js\");\n/* harmony import */ var _solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @solana/wallet-adapter-base */ \"(ssr)/../node_modules/@solana/wallet-adapter-base/lib/esm/adapter.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/../node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var _errors_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./errors.js */ \"(ssr)/../node_modules/@solana/wallet-adapter-react/lib/esm/errors.js\");\n/* harmony import */ var _useWallet_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./useWallet.js */ \"(ssr)/../node_modules/@solana/wallet-adapter-react/lib/esm/useWallet.js\");\n\n\n\n\nfunction WalletProviderBase({ children, wallets: adapters, adapter, isUnloadingRef, onAutoConnectRequest, onConnectError, onError, onSelectWallet }) {\n    const isConnectingRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(false);\n    const [connecting, setConnecting] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(false);\n    const isDisconnectingRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(false);\n    const [disconnecting, setDisconnecting] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(false);\n    const [publicKey, setPublicKey] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(()=>adapter?.publicKey ?? null);\n    const [connected, setConnected] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(()=>adapter?.connected ?? false);\n    /**\n     * Store the error handlers as refs so that a change in the\n     * custom error handler does not recompute other dependencies.\n     */ const onErrorRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(onError);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        onErrorRef.current = onError;\n        return ()=>{\n            onErrorRef.current = undefined;\n        };\n    }, [\n        onError\n    ]);\n    const handleErrorRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)((error, adapter)=>{\n        if (!isUnloadingRef.current) {\n            if (onErrorRef.current) {\n                onErrorRef.current(error, adapter);\n            } else {\n                console.error(error, adapter);\n                if (error instanceof _solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_1__.WalletNotReadyError && \"undefined\" !== \"undefined\" && 0) {}\n            }\n        }\n        return error;\n    });\n    // Wrap adapters to conform to the `Wallet` interface\n    const [wallets, setWallets] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(()=>adapters.map((adapter)=>({\n                adapter,\n                readyState: adapter.readyState\n            })).filter(({ readyState })=>readyState !== _solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_2__.WalletReadyState.Unsupported));\n    // When the adapters change, start to listen for changes to their `readyState`\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        // When the adapters change, wrap them to conform to the `Wallet` interface\n        setWallets((wallets)=>adapters.map((adapter, index)=>{\n                const wallet = wallets[index];\n                // If the wallet hasn't changed, return the same instance\n                return wallet && wallet.adapter === adapter && wallet.readyState === adapter.readyState ? wallet : {\n                    adapter: adapter,\n                    readyState: adapter.readyState\n                };\n            }).filter(({ readyState })=>readyState !== _solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_2__.WalletReadyState.Unsupported));\n        function handleReadyStateChange(readyState) {\n            setWallets((prevWallets)=>{\n                const index = prevWallets.findIndex(({ adapter })=>adapter === this);\n                if (index === -1) return prevWallets;\n                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n                const { adapter } = prevWallets[index];\n                return [\n                    ...prevWallets.slice(0, index),\n                    {\n                        adapter,\n                        readyState\n                    },\n                    ...prevWallets.slice(index + 1)\n                ].filter(({ readyState })=>readyState !== _solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_2__.WalletReadyState.Unsupported);\n            });\n        }\n        adapters.forEach((adapter)=>adapter.on(\"readyStateChange\", handleReadyStateChange, adapter));\n        return ()=>{\n            adapters.forEach((adapter)=>adapter.off(\"readyStateChange\", handleReadyStateChange, adapter));\n        };\n    }, [\n        adapter,\n        adapters\n    ]);\n    const wallet = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>wallets.find((wallet)=>wallet.adapter === adapter) ?? null, [\n        adapter,\n        wallets\n    ]);\n    // Setup and teardown event listeners when the adapter changes\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        if (!adapter) return;\n        const handleConnect = (publicKey)=>{\n            setPublicKey(publicKey);\n            isConnectingRef.current = false;\n            setConnecting(false);\n            setConnected(true);\n            isDisconnectingRef.current = false;\n            setDisconnecting(false);\n        };\n        const handleDisconnect = ()=>{\n            if (isUnloadingRef.current) return;\n            setPublicKey(null);\n            isConnectingRef.current = false;\n            setConnecting(false);\n            setConnected(false);\n            isDisconnectingRef.current = false;\n            setDisconnecting(false);\n        };\n        const handleError = (error)=>{\n            handleErrorRef.current(error, adapter);\n        };\n        adapter.on(\"connect\", handleConnect);\n        adapter.on(\"disconnect\", handleDisconnect);\n        adapter.on(\"error\", handleError);\n        return ()=>{\n            adapter.off(\"connect\", handleConnect);\n            adapter.off(\"disconnect\", handleDisconnect);\n            adapter.off(\"error\", handleError);\n            handleDisconnect();\n        };\n    }, [\n        adapter,\n        isUnloadingRef\n    ]);\n    // When the adapter changes, clear the `autoConnect` tracking flag\n    const didAttemptAutoConnectRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(false);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        return ()=>{\n            didAttemptAutoConnectRef.current = false;\n        };\n    }, [\n        adapter\n    ]);\n    // If auto-connect is enabled, request to connect when the adapter changes and is ready\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        if (didAttemptAutoConnectRef.current || isConnectingRef.current || connected || !onAutoConnectRequest || !(wallet?.readyState === _solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_2__.WalletReadyState.Installed || wallet?.readyState === _solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_2__.WalletReadyState.Loadable)) return;\n        isConnectingRef.current = true;\n        setConnecting(true);\n        didAttemptAutoConnectRef.current = true;\n        (async function() {\n            try {\n                await onAutoConnectRequest();\n            } catch  {\n                onConnectError();\n            // Drop the error. It will be caught by `handleError` anyway.\n            } finally{\n                setConnecting(false);\n                isConnectingRef.current = false;\n            }\n        })();\n    }, [\n        connected,\n        onAutoConnectRequest,\n        onConnectError,\n        wallet\n    ]);\n    // Send a transaction using the provided connection\n    const sendTransaction = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(async (transaction, connection, options)=>{\n        if (!adapter) throw handleErrorRef.current(new _errors_js__WEBPACK_IMPORTED_MODULE_3__.WalletNotSelectedError());\n        if (!connected) throw handleErrorRef.current(new _solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_1__.WalletNotConnectedError(), adapter);\n        return await adapter.sendTransaction(transaction, connection, options);\n    }, [\n        adapter,\n        connected\n    ]);\n    // Sign a transaction if the wallet supports it\n    const signTransaction = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>adapter && \"signTransaction\" in adapter ? async (transaction)=>{\n            if (!connected) throw handleErrorRef.current(new _solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_1__.WalletNotConnectedError(), adapter);\n            return await adapter.signTransaction(transaction);\n        } : undefined, [\n        adapter,\n        connected\n    ]);\n    // Sign multiple transactions if the wallet supports it\n    const signAllTransactions = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>adapter && \"signAllTransactions\" in adapter ? async (transactions)=>{\n            if (!connected) throw handleErrorRef.current(new _solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_1__.WalletNotConnectedError(), adapter);\n            return await adapter.signAllTransactions(transactions);\n        } : undefined, [\n        adapter,\n        connected\n    ]);\n    // Sign an arbitrary message if the wallet supports it\n    const signMessage = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>adapter && \"signMessage\" in adapter ? async (message)=>{\n            if (!connected) throw handleErrorRef.current(new _solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_1__.WalletNotConnectedError(), adapter);\n            return await adapter.signMessage(message);\n        } : undefined, [\n        adapter,\n        connected\n    ]);\n    // Sign in if the wallet supports it\n    const signIn = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>adapter && \"signIn\" in adapter ? async (input)=>{\n            return await adapter.signIn(input);\n        } : undefined, [\n        adapter\n    ]);\n    const handleConnect = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(async ()=>{\n        if (isConnectingRef.current || isDisconnectingRef.current || wallet?.adapter.connected) return;\n        if (!wallet) throw handleErrorRef.current(new _errors_js__WEBPACK_IMPORTED_MODULE_3__.WalletNotSelectedError());\n        const { adapter, readyState } = wallet;\n        if (!(readyState === _solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_2__.WalletReadyState.Installed || readyState === _solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_2__.WalletReadyState.Loadable)) throw handleErrorRef.current(new _solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_1__.WalletNotReadyError(), adapter);\n        isConnectingRef.current = true;\n        setConnecting(true);\n        try {\n            await adapter.connect();\n        } catch (e) {\n            onConnectError();\n            throw e;\n        } finally{\n            setConnecting(false);\n            isConnectingRef.current = false;\n        }\n    }, [\n        onConnectError,\n        wallet\n    ]);\n    const handleDisconnect = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(async ()=>{\n        if (isDisconnectingRef.current) return;\n        if (!adapter) return;\n        isDisconnectingRef.current = true;\n        setDisconnecting(true);\n        try {\n            await adapter.disconnect();\n        } finally{\n            setDisconnecting(false);\n            isDisconnectingRef.current = false;\n        }\n    }, [\n        adapter\n    ]);\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(_useWallet_js__WEBPACK_IMPORTED_MODULE_4__.WalletContext.Provider, {\n        value: {\n            autoConnect: !!onAutoConnectRequest,\n            wallets,\n            wallet,\n            publicKey,\n            connected,\n            connecting,\n            disconnecting,\n            select: onSelectWallet,\n            connect: handleConnect,\n            disconnect: handleDisconnect,\n            sendTransaction,\n            signTransaction,\n            signAllTransactions,\n            signMessage,\n            signIn\n        }\n    }, children);\n} //# sourceMappingURL=WalletProviderBase.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL0Bzb2xhbmEvd2FsbGV0LWFkYXB0ZXItcmVhY3QvbGliL2VzbS9XYWxsZXRQcm92aWRlckJhc2UuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBQThHO0FBQzdCO0FBQzVCO0FBQ047QUFDeEMsU0FBU1csbUJBQW1CLEVBQUVDLFFBQVEsRUFBRUMsU0FBU0MsUUFBUSxFQUFFQyxPQUFPLEVBQUVDLGNBQWMsRUFBRUMsb0JBQW9CLEVBQUVDLGNBQWMsRUFBRUMsT0FBTyxFQUFFQyxjQUFjLEVBQUc7SUFDdkosTUFBTUMsa0JBQWtCZCw2Q0FBTUEsQ0FBQztJQUMvQixNQUFNLENBQUNlLFlBQVlDLGNBQWMsR0FBR2YsK0NBQVFBLENBQUM7SUFDN0MsTUFBTWdCLHFCQUFxQmpCLDZDQUFNQSxDQUFDO0lBQ2xDLE1BQU0sQ0FBQ2tCLGVBQWVDLGlCQUFpQixHQUFHbEIsK0NBQVFBLENBQUM7SUFDbkQsTUFBTSxDQUFDbUIsV0FBV0MsYUFBYSxHQUFHcEIsK0NBQVFBLENBQUMsSUFBTU8sU0FBU1ksYUFBYTtJQUN2RSxNQUFNLENBQUNFLFdBQVdDLGFBQWEsR0FBR3RCLCtDQUFRQSxDQUFDLElBQU1PLFNBQVNjLGFBQWE7SUFDdkU7OztLQUdDLEdBQ0QsTUFBTUUsYUFBYXhCLDZDQUFNQSxDQUFDWTtJQUMxQmQsZ0RBQVNBLENBQUM7UUFDTjBCLFdBQVdDLE9BQU8sR0FBR2I7UUFDckIsT0FBTztZQUNIWSxXQUFXQyxPQUFPLEdBQUdDO1FBQ3pCO0lBQ0osR0FBRztRQUFDZDtLQUFRO0lBQ1osTUFBTWUsaUJBQWlCM0IsNkNBQU1BLENBQUMsQ0FBQzRCLE9BQU9wQjtRQUNsQyxJQUFJLENBQUNDLGVBQWVnQixPQUFPLEVBQUU7WUFDekIsSUFBSUQsV0FBV0MsT0FBTyxFQUFFO2dCQUNwQkQsV0FBV0MsT0FBTyxDQUFDRyxPQUFPcEI7WUFDOUIsT0FDSztnQkFDRHFCLFFBQVFELEtBQUssQ0FBQ0EsT0FBT3BCO2dCQUNyQixJQUFJ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U2pCO1lBQ1RtQixZQUFZbEI7WUFDWks7WUFDQUk7WUFDQUM7WUFDQUU7WUFDQUU7UUFDSjtJQUFFLEdBQUcxRDtBQUNiLEVBQ0EsOENBQThDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9Ac29sYW5hL3dhbGxldC1hZGFwdGVyLXJlYWN0L2xpYi9lc20vV2FsbGV0UHJvdmlkZXJCYXNlLmpzPzIzM2QiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgV2FsbGV0Tm90Q29ubmVjdGVkRXJyb3IsIFdhbGxldE5vdFJlYWR5RXJyb3IsIFdhbGxldFJlYWR5U3RhdGUsIH0gZnJvbSAnQHNvbGFuYS93YWxsZXQtYWRhcHRlci1iYXNlJztcbmltcG9ydCBSZWFjdCwgeyB1c2VDYWxsYmFjaywgdXNlRWZmZWN0LCB1c2VNZW1vLCB1c2VSZWYsIHVzZVN0YXRlIH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgV2FsbGV0Tm90U2VsZWN0ZWRFcnJvciB9IGZyb20gJy4vZXJyb3JzLmpzJztcbmltcG9ydCB7IFdhbGxldENvbnRleHQgfSBmcm9tICcuL3VzZVdhbGxldC5qcyc7XG5leHBvcnQgZnVuY3Rpb24gV2FsbGV0UHJvdmlkZXJCYXNlKHsgY2hpbGRyZW4sIHdhbGxldHM6IGFkYXB0ZXJzLCBhZGFwdGVyLCBpc1VubG9hZGluZ1JlZiwgb25BdXRvQ29ubmVjdFJlcXVlc3QsIG9uQ29ubmVjdEVycm9yLCBvbkVycm9yLCBvblNlbGVjdFdhbGxldCwgfSkge1xuICAgIGNvbnN0IGlzQ29ubmVjdGluZ1JlZiA9IHVzZVJlZihmYWxzZSk7XG4gICAgY29uc3QgW2Nvbm5lY3RpbmcsIHNldENvbm5lY3RpbmddID0gdXNlU3RhdGUoZmFsc2UpO1xuICAgIGNvbnN0IGlzRGlzY29ubmVjdGluZ1JlZiA9IHVzZVJlZihmYWxzZSk7XG4gICAgY29uc3QgW2Rpc2Nvbm5lY3RpbmcsIHNldERpc2Nvbm5lY3RpbmddID0gdXNlU3RhdGUoZmFsc2UpO1xuICAgIGNvbnN0IFtwdWJsaWNLZXksIHNldFB1YmxpY0tleV0gPSB1c2VTdGF0ZSgoKSA9PiBhZGFwdGVyPy5wdWJsaWNLZXkgPz8gbnVsbCk7XG4gICAgY29uc3QgW2Nvbm5lY3RlZCwgc2V0Q29ubmVjdGVkXSA9IHVzZVN0YXRlKCgpID0+IGFkYXB0ZXI/LmNvbm5lY3RlZCA/PyBmYWxzZSk7XG4gICAgLyoqXG4gICAgICogU3RvcmUgdGhlIGVycm9yIGhhbmRsZXJzIGFzIHJlZnMgc28gdGhhdCBhIGNoYW5nZSBpbiB0aGVcbiAgICAgKiBjdXN0b20gZXJyb3IgaGFuZGxlciBkb2VzIG5vdCByZWNvbXB1dGUgb3RoZXIgZGVwZW5kZW5jaWVzLlxuICAgICAqL1xuICAgIGNvbnN0IG9uRXJyb3JSZWYgPSB1c2VSZWYob25FcnJvcik7XG4gICAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgb25FcnJvclJlZi5jdXJyZW50ID0gb25FcnJvcjtcbiAgICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgICAgIG9uRXJyb3JSZWYuY3VycmVudCA9IHVuZGVmaW5lZDtcbiAgICAgICAgfTtcbiAgICB9LCBbb25FcnJvcl0pO1xuICAgIGNvbnN0IGhhbmRsZUVycm9yUmVmID0gdXNlUmVmKChlcnJvciwgYWRhcHRlcikgPT4ge1xuICAgICAgICBpZiAoIWlzVW5sb2FkaW5nUmVmLmN1cnJlbnQpIHtcbiAgICAgICAgICAgIGlmIChvbkVycm9yUmVmLmN1cnJlbnQpIHtcbiAgICAgICAgICAgICAgICBvbkVycm9yUmVmLmN1cnJlbnQoZXJyb3IsIGFkYXB0ZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihlcnJvciwgYWRhcHRlcik7XG4gICAgICAgICAgICAgICAgaWYgKGVycm9yIGluc3RhbmNlb2YgV2FsbGV0Tm90UmVhZHlFcnJvciAmJiB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiBhZGFwdGVyKSB7XG4gICAgICAgICAgICAgICAgICAgIHdpbmRvdy5vcGVuKGFkYXB0ZXIudXJsLCAnX2JsYW5rJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBlcnJvcjtcbiAgICB9KTtcbiAgICAvLyBXcmFwIGFkYXB0ZXJzIHRvIGNvbmZvcm0gdG8gdGhlIGBXYWxsZXRgIGludGVyZmFjZVxuICAgIGNvbnN0IFt3YWxsZXRzLCBzZXRXYWxsZXRzXSA9IHVzZVN0YXRlKCgpID0+IGFkYXB0ZXJzXG4gICAgICAgIC5tYXAoKGFkYXB0ZXIpID0+ICh7XG4gICAgICAgIGFkYXB0ZXIsXG4gICAgICAgIHJlYWR5U3RhdGU6IGFkYXB0ZXIucmVhZHlTdGF0ZSxcbiAgICB9KSlcbiAgICAgICAgLmZpbHRlcigoeyByZWFkeVN0YXRlIH0pID0+IHJlYWR5U3RhdGUgIT09IFdhbGxldFJlYWR5U3RhdGUuVW5zdXBwb3J0ZWQpKTtcbiAgICAvLyBXaGVuIHRoZSBhZGFwdGVycyBjaGFuZ2UsIHN0YXJ0IHRvIGxpc3RlbiBmb3IgY2hhbmdlcyB0byB0aGVpciBgcmVhZHlTdGF0ZWBcbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgICAvLyBXaGVuIHRoZSBhZGFwdGVycyBjaGFuZ2UsIHdyYXAgdGhlbSB0byBjb25mb3JtIHRvIHRoZSBgV2FsbGV0YCBpbnRlcmZhY2VcbiAgICAgICAgc2V0V2FsbGV0cygod2FsbGV0cykgPT4gYWRhcHRlcnNcbiAgICAgICAgICAgIC5tYXAoKGFkYXB0ZXIsIGluZGV4KSA9PiB7XG4gICAgICAgICAgICBjb25zdCB3YWxsZXQgPSB3YWxsZXRzW2luZGV4XTtcbiAgICAgICAgICAgIC8vIElmIHRoZSB3YWxsZXQgaGFzbid0IGNoYW5nZWQsIHJldHVybiB0aGUgc2FtZSBpbnN0YW5jZVxuICAgICAgICAgICAgcmV0dXJuIHdhbGxldCAmJiB3YWxsZXQuYWRhcHRlciA9PT0gYWRhcHRlciAmJiB3YWxsZXQucmVhZHlTdGF0ZSA9PT0gYWRhcHRlci5yZWFkeVN0YXRlXG4gICAgICAgICAgICAgICAgPyB3YWxsZXRcbiAgICAgICAgICAgICAgICA6IHtcbiAgICAgICAgICAgICAgICAgICAgYWRhcHRlcjogYWRhcHRlcixcbiAgICAgICAgICAgICAgICAgICAgcmVhZHlTdGF0ZTogYWRhcHRlci5yZWFkeVN0YXRlLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgIH0pXG4gICAgICAgICAgICAuZmlsdGVyKCh7IHJlYWR5U3RhdGUgfSkgPT4gcmVhZHlTdGF0ZSAhPT0gV2FsbGV0UmVhZHlTdGF0ZS5VbnN1cHBvcnRlZCkpO1xuICAgICAgICBmdW5jdGlvbiBoYW5kbGVSZWFkeVN0YXRlQ2hhbmdlKHJlYWR5U3RhdGUpIHtcbiAgICAgICAgICAgIHNldFdhbGxldHMoKHByZXZXYWxsZXRzKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgaW5kZXggPSBwcmV2V2FsbGV0cy5maW5kSW5kZXgoKHsgYWRhcHRlciB9KSA9PiBhZGFwdGVyID09PSB0aGlzKTtcbiAgICAgICAgICAgICAgICBpZiAoaW5kZXggPT09IC0xKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcHJldldhbGxldHM7XG4gICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1ub24tbnVsbC1hc3NlcnRpb25cbiAgICAgICAgICAgICAgICBjb25zdCB7IGFkYXB0ZXIgfSA9IHByZXZXYWxsZXRzW2luZGV4XTtcbiAgICAgICAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgICAgICAgICAuLi5wcmV2V2FsbGV0cy5zbGljZSgwLCBpbmRleCksXG4gICAgICAgICAgICAgICAgICAgIHsgYWRhcHRlciwgcmVhZHlTdGF0ZSB9LFxuICAgICAgICAgICAgICAgICAgICAuLi5wcmV2V2FsbGV0cy5zbGljZShpbmRleCArIDEpLFxuICAgICAgICAgICAgICAgIF0uZmlsdGVyKCh7IHJlYWR5U3RhdGUgfSkgPT4gcmVhZHlTdGF0ZSAhPT0gV2FsbGV0UmVhZHlTdGF0ZS5VbnN1cHBvcnRlZCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBhZGFwdGVycy5mb3JFYWNoKChhZGFwdGVyKSA9PiBhZGFwdGVyLm9uKCdyZWFkeVN0YXRlQ2hhbmdlJywgaGFuZGxlUmVhZHlTdGF0ZUNoYW5nZSwgYWRhcHRlcikpO1xuICAgICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICAgICAgYWRhcHRlcnMuZm9yRWFjaCgoYWRhcHRlcikgPT4gYWRhcHRlci5vZmYoJ3JlYWR5U3RhdGVDaGFuZ2UnLCBoYW5kbGVSZWFkeVN0YXRlQ2hhbmdlLCBhZGFwdGVyKSk7XG4gICAgICAgIH07XG4gICAgfSwgW2FkYXB0ZXIsIGFkYXB0ZXJzXSk7XG4gICAgY29uc3Qgd2FsbGV0ID0gdXNlTWVtbygoKSA9PiB3YWxsZXRzLmZpbmQoKHdhbGxldCkgPT4gd2FsbGV0LmFkYXB0ZXIgPT09IGFkYXB0ZXIpID8/IG51bGwsIFthZGFwdGVyLCB3YWxsZXRzXSk7XG4gICAgLy8gU2V0dXAgYW5kIHRlYXJkb3duIGV2ZW50IGxpc3RlbmVycyB3aGVuIHRoZSBhZGFwdGVyIGNoYW5nZXNcbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgICBpZiAoIWFkYXB0ZXIpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGNvbnN0IGhhbmRsZUNvbm5lY3QgPSAocHVibGljS2V5KSA9PiB7XG4gICAgICAgICAgICBzZXRQdWJsaWNLZXkocHVibGljS2V5KTtcbiAgICAgICAgICAgIGlzQ29ubmVjdGluZ1JlZi5jdXJyZW50ID0gZmFsc2U7XG4gICAgICAgICAgICBzZXRDb25uZWN0aW5nKGZhbHNlKTtcbiAgICAgICAgICAgIHNldENvbm5lY3RlZCh0cnVlKTtcbiAgICAgICAgICAgIGlzRGlzY29ubmVjdGluZ1JlZi5jdXJyZW50ID0gZmFsc2U7XG4gICAgICAgICAgICBzZXREaXNjb25uZWN0aW5nKGZhbHNlKTtcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgaGFuZGxlRGlzY29ubmVjdCA9ICgpID0+IHtcbiAgICAgICAgICAgIGlmIChpc1VubG9hZGluZ1JlZi5jdXJyZW50KVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIHNldFB1YmxpY0tleShudWxsKTtcbiAgICAgICAgICAgIGlzQ29ubmVjdGluZ1JlZi5jdXJyZW50ID0gZmFsc2U7XG4gICAgICAgICAgICBzZXRDb25uZWN0aW5nKGZhbHNlKTtcbiAgICAgICAgICAgIHNldENvbm5lY3RlZChmYWxzZSk7XG4gICAgICAgICAgICBpc0Rpc2Nvbm5lY3RpbmdSZWYuY3VycmVudCA9IGZhbHNlO1xuICAgICAgICAgICAgc2V0RGlzY29ubmVjdGluZyhmYWxzZSk7XG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IGhhbmRsZUVycm9yID0gKGVycm9yKSA9PiB7XG4gICAgICAgICAgICBoYW5kbGVFcnJvclJlZi5jdXJyZW50KGVycm9yLCBhZGFwdGVyKTtcbiAgICAgICAgfTtcbiAgICAgICAgYWRhcHRlci5vbignY29ubmVjdCcsIGhhbmRsZUNvbm5lY3QpO1xuICAgICAgICBhZGFwdGVyLm9uKCdkaXNjb25uZWN0JywgaGFuZGxlRGlzY29ubmVjdCk7XG4gICAgICAgIGFkYXB0ZXIub24oJ2Vycm9yJywgaGFuZGxlRXJyb3IpO1xuICAgICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICAgICAgYWRhcHRlci5vZmYoJ2Nvbm5lY3QnLCBoYW5kbGVDb25uZWN0KTtcbiAgICAgICAgICAgIGFkYXB0ZXIub2ZmKCdkaXNjb25uZWN0JywgaGFuZGxlRGlzY29ubmVjdCk7XG4gICAgICAgICAgICBhZGFwdGVyLm9mZignZXJyb3InLCBoYW5kbGVFcnJvcik7XG4gICAgICAgICAgICBoYW5kbGVEaXNjb25uZWN0KCk7XG4gICAgICAgIH07XG4gICAgfSwgW2FkYXB0ZXIsIGlzVW5sb2FkaW5nUmVmXSk7XG4gICAgLy8gV2hlbiB0aGUgYWRhcHRlciBjaGFuZ2VzLCBjbGVhciB0aGUgYGF1dG9Db25uZWN0YCB0cmFja2luZyBmbGFnXG4gICAgY29uc3QgZGlkQXR0ZW1wdEF1dG9Db25uZWN0UmVmID0gdXNlUmVmKGZhbHNlKTtcbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICAgICAgZGlkQXR0ZW1wdEF1dG9Db25uZWN0UmVmLmN1cnJlbnQgPSBmYWxzZTtcbiAgICAgICAgfTtcbiAgICB9LCBbYWRhcHRlcl0pO1xuICAgIC8vIElmIGF1dG8tY29ubmVjdCBpcyBlbmFibGVkLCByZXF1ZXN0IHRvIGNvbm5lY3Qgd2hlbiB0aGUgYWRhcHRlciBjaGFuZ2VzIGFuZCBpcyByZWFkeVxuICAgIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICAgIGlmIChkaWRBdHRlbXB0QXV0b0Nvbm5lY3RSZWYuY3VycmVudCB8fFxuICAgICAgICAgICAgaXNDb25uZWN0aW5nUmVmLmN1cnJlbnQgfHxcbiAgICAgICAgICAgIGNvbm5lY3RlZCB8fFxuICAgICAgICAgICAgIW9uQXV0b0Nvbm5lY3RSZXF1ZXN0IHx8XG4gICAgICAgICAgICAhKHdhbGxldD8ucmVhZHlTdGF0ZSA9PT0gV2FsbGV0UmVhZHlTdGF0ZS5JbnN0YWxsZWQgfHwgd2FsbGV0Py5yZWFkeVN0YXRlID09PSBXYWxsZXRSZWFkeVN0YXRlLkxvYWRhYmxlKSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgaXNDb25uZWN0aW5nUmVmLmN1cnJlbnQgPSB0cnVlO1xuICAgICAgICBzZXRDb25uZWN0aW5nKHRydWUpO1xuICAgICAgICBkaWRBdHRlbXB0QXV0b0Nvbm5lY3RSZWYuY3VycmVudCA9IHRydWU7XG4gICAgICAgIChhc3luYyBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGF3YWl0IG9uQXV0b0Nvbm5lY3RSZXF1ZXN0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCB7XG4gICAgICAgICAgICAgICAgb25Db25uZWN0RXJyb3IoKTtcbiAgICAgICAgICAgICAgICAvLyBEcm9wIHRoZSBlcnJvci4gSXQgd2lsbCBiZSBjYXVnaHQgYnkgYGhhbmRsZUVycm9yYCBhbnl3YXkuXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgICBzZXRDb25uZWN0aW5nKGZhbHNlKTtcbiAgICAgICAgICAgICAgICBpc0Nvbm5lY3RpbmdSZWYuY3VycmVudCA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KSgpO1xuICAgIH0sIFtjb25uZWN0ZWQsIG9uQXV0b0Nvbm5lY3RSZXF1ZXN0LCBvbkNvbm5lY3RFcnJvciwgd2FsbGV0XSk7XG4gICAgLy8gU2VuZCBhIHRyYW5zYWN0aW9uIHVzaW5nIHRoZSBwcm92aWRlZCBjb25uZWN0aW9uXG4gICAgY29uc3Qgc2VuZFRyYW5zYWN0aW9uID0gdXNlQ2FsbGJhY2soYXN5bmMgKHRyYW5zYWN0aW9uLCBjb25uZWN0aW9uLCBvcHRpb25zKSA9PiB7XG4gICAgICAgIGlmICghYWRhcHRlcilcbiAgICAgICAgICAgIHRocm93IGhhbmRsZUVycm9yUmVmLmN1cnJlbnQobmV3IFdhbGxldE5vdFNlbGVjdGVkRXJyb3IoKSk7XG4gICAgICAgIGlmICghY29ubmVjdGVkKVxuICAgICAgICAgICAgdGhyb3cgaGFuZGxlRXJyb3JSZWYuY3VycmVudChuZXcgV2FsbGV0Tm90Q29ubmVjdGVkRXJyb3IoKSwgYWRhcHRlcik7XG4gICAgICAgIHJldHVybiBhd2FpdCBhZGFwdGVyLnNlbmRUcmFuc2FjdGlvbih0cmFuc2FjdGlvbiwgY29ubmVjdGlvbiwgb3B0aW9ucyk7XG4gICAgfSwgW2FkYXB0ZXIsIGNvbm5lY3RlZF0pO1xuICAgIC8vIFNpZ24gYSB0cmFuc2FjdGlvbiBpZiB0aGUgd2FsbGV0IHN1cHBvcnRzIGl0XG4gICAgY29uc3Qgc2lnblRyYW5zYWN0aW9uID0gdXNlTWVtbygoKSA9PiBhZGFwdGVyICYmICdzaWduVHJhbnNhY3Rpb24nIGluIGFkYXB0ZXJcbiAgICAgICAgPyBhc3luYyAodHJhbnNhY3Rpb24pID0+IHtcbiAgICAgICAgICAgIGlmICghY29ubmVjdGVkKVxuICAgICAgICAgICAgICAgIHRocm93IGhhbmRsZUVycm9yUmVmLmN1cnJlbnQobmV3IFdhbGxldE5vdENvbm5lY3RlZEVycm9yKCksIGFkYXB0ZXIpO1xuICAgICAgICAgICAgcmV0dXJuIGF3YWl0IGFkYXB0ZXIuc2lnblRyYW5zYWN0aW9uKHRyYW5zYWN0aW9uKTtcbiAgICAgICAgfVxuICAgICAgICA6IHVuZGVmaW5lZCwgW2FkYXB0ZXIsIGNvbm5lY3RlZF0pO1xuICAgIC8vIFNpZ24gbXVsdGlwbGUgdHJhbnNhY3Rpb25zIGlmIHRoZSB3YWxsZXQgc3VwcG9ydHMgaXRcbiAgICBjb25zdCBzaWduQWxsVHJhbnNhY3Rpb25zID0gdXNlTWVtbygoKSA9PiBhZGFwdGVyICYmICdzaWduQWxsVHJhbnNhY3Rpb25zJyBpbiBhZGFwdGVyXG4gICAgICAgID8gYXN5bmMgKHRyYW5zYWN0aW9ucykgPT4ge1xuICAgICAgICAgICAgaWYgKCFjb25uZWN0ZWQpXG4gICAgICAgICAgICAgICAgdGhyb3cgaGFuZGxlRXJyb3JSZWYuY3VycmVudChuZXcgV2FsbGV0Tm90Q29ubmVjdGVkRXJyb3IoKSwgYWRhcHRlcik7XG4gICAgICAgICAgICByZXR1cm4gYXdhaXQgYWRhcHRlci5zaWduQWxsVHJhbnNhY3Rpb25zKHRyYW5zYWN0aW9ucyk7XG4gICAgICAgIH1cbiAgICAgICAgOiB1bmRlZmluZWQsIFthZGFwdGVyLCBjb25uZWN0ZWRdKTtcbiAgICAvLyBTaWduIGFuIGFyYml0cmFyeSBtZXNzYWdlIGlmIHRoZSB3YWxsZXQgc3VwcG9ydHMgaXRcbiAgICBjb25zdCBzaWduTWVzc2FnZSA9IHVzZU1lbW8oKCkgPT4gYWRhcHRlciAmJiAnc2lnbk1lc3NhZ2UnIGluIGFkYXB0ZXJcbiAgICAgICAgPyBhc3luYyAobWVzc2FnZSkgPT4ge1xuICAgICAgICAgICAgaWYgKCFjb25uZWN0ZWQpXG4gICAgICAgICAgICAgICAgdGhyb3cgaGFuZGxlRXJyb3JSZWYuY3VycmVudChuZXcgV2FsbGV0Tm90Q29ubmVjdGVkRXJyb3IoKSwgYWRhcHRlcik7XG4gICAgICAgICAgICByZXR1cm4gYXdhaXQgYWRhcHRlci5zaWduTWVzc2FnZShtZXNzYWdlKTtcbiAgICAgICAgfVxuICAgICAgICA6IHVuZGVmaW5lZCwgW2FkYXB0ZXIsIGNvbm5lY3RlZF0pO1xuICAgIC8vIFNpZ24gaW4gaWYgdGhlIHdhbGxldCBzdXBwb3J0cyBpdFxuICAgIGNvbnN0IHNpZ25JbiA9IHVzZU1lbW8oKCkgPT4gYWRhcHRlciAmJiAnc2lnbkluJyBpbiBhZGFwdGVyXG4gICAgICAgID8gYXN5bmMgKGlucHV0KSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gYXdhaXQgYWRhcHRlci5zaWduSW4oaW5wdXQpO1xuICAgICAgICB9XG4gICAgICAgIDogdW5kZWZpbmVkLCBbYWRhcHRlcl0pO1xuICAgIGNvbnN0IGhhbmRsZUNvbm5lY3QgPSB1c2VDYWxsYmFjayhhc3luYyAoKSA9PiB7XG4gICAgICAgIGlmIChpc0Nvbm5lY3RpbmdSZWYuY3VycmVudCB8fCBpc0Rpc2Nvbm5lY3RpbmdSZWYuY3VycmVudCB8fCB3YWxsZXQ/LmFkYXB0ZXIuY29ubmVjdGVkKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBpZiAoIXdhbGxldClcbiAgICAgICAgICAgIHRocm93IGhhbmRsZUVycm9yUmVmLmN1cnJlbnQobmV3IFdhbGxldE5vdFNlbGVjdGVkRXJyb3IoKSk7XG4gICAgICAgIGNvbnN0IHsgYWRhcHRlciwgcmVhZHlTdGF0ZSB9ID0gd2FsbGV0O1xuICAgICAgICBpZiAoIShyZWFkeVN0YXRlID09PSBXYWxsZXRSZWFkeVN0YXRlLkluc3RhbGxlZCB8fCByZWFkeVN0YXRlID09PSBXYWxsZXRSZWFkeVN0YXRlLkxvYWRhYmxlKSlcbiAgICAgICAgICAgIHRocm93IGhhbmRsZUVycm9yUmVmLmN1cnJlbnQobmV3IFdhbGxldE5vdFJlYWR5RXJyb3IoKSwgYWRhcHRlcik7XG4gICAgICAgIGlzQ29ubmVjdGluZ1JlZi5jdXJyZW50ID0gdHJ1ZTtcbiAgICAgICAgc2V0Q29ubmVjdGluZyh0cnVlKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGF3YWl0IGFkYXB0ZXIuY29ubmVjdCgpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICBvbkNvbm5lY3RFcnJvcigpO1xuICAgICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgfVxuICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgIHNldENvbm5lY3RpbmcoZmFsc2UpO1xuICAgICAgICAgICAgaXNDb25uZWN0aW5nUmVmLmN1cnJlbnQgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgIH0sIFtvbkNvbm5lY3RFcnJvciwgd2FsbGV0XSk7XG4gICAgY29uc3QgaGFuZGxlRGlzY29ubmVjdCA9IHVzZUNhbGxiYWNrKGFzeW5jICgpID0+IHtcbiAgICAgICAgaWYgKGlzRGlzY29ubmVjdGluZ1JlZi5jdXJyZW50KVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBpZiAoIWFkYXB0ZXIpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGlzRGlzY29ubmVjdGluZ1JlZi5jdXJyZW50ID0gdHJ1ZTtcbiAgICAgICAgc2V0RGlzY29ubmVjdGluZyh0cnVlKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGF3YWl0IGFkYXB0ZXIuZGlzY29ubmVjdCgpO1xuICAgICAgICB9XG4gICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgc2V0RGlzY29ubmVjdGluZyhmYWxzZSk7XG4gICAgICAgICAgICBpc0Rpc2Nvbm5lY3RpbmdSZWYuY3VycmVudCA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgfSwgW2FkYXB0ZXJdKTtcbiAgICByZXR1cm4gKFJlYWN0LmNyZWF0ZUVsZW1lbnQoV2FsbGV0Q29udGV4dC5Qcm92aWRlciwgeyB2YWx1ZToge1xuICAgICAgICAgICAgYXV0b0Nvbm5lY3Q6ICEhb25BdXRvQ29ubmVjdFJlcXVlc3QsXG4gICAgICAgICAgICB3YWxsZXRzLFxuICAgICAgICAgICAgd2FsbGV0LFxuICAgICAgICAgICAgcHVibGljS2V5LFxuICAgICAgICAgICAgY29ubmVjdGVkLFxuICAgICAgICAgICAgY29ubmVjdGluZyxcbiAgICAgICAgICAgIGRpc2Nvbm5lY3RpbmcsXG4gICAgICAgICAgICBzZWxlY3Q6IG9uU2VsZWN0V2FsbGV0LFxuICAgICAgICAgICAgY29ubmVjdDogaGFuZGxlQ29ubmVjdCxcbiAgICAgICAgICAgIGRpc2Nvbm5lY3Q6IGhhbmRsZURpc2Nvbm5lY3QsXG4gICAgICAgICAgICBzZW5kVHJhbnNhY3Rpb24sXG4gICAgICAgICAgICBzaWduVHJhbnNhY3Rpb24sXG4gICAgICAgICAgICBzaWduQWxsVHJhbnNhY3Rpb25zLFxuICAgICAgICAgICAgc2lnbk1lc3NhZ2UsXG4gICAgICAgICAgICBzaWduSW4sXG4gICAgICAgIH0gfSwgY2hpbGRyZW4pKTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVdhbGxldFByb3ZpZGVyQmFzZS5qcy5tYXAiXSwibmFtZXMiOlsiV2FsbGV0Tm90Q29ubmVjdGVkRXJyb3IiLCJXYWxsZXROb3RSZWFkeUVycm9yIiwiV2FsbGV0UmVhZHlTdGF0ZSIsIlJlYWN0IiwidXNlQ2FsbGJhY2siLCJ1c2VFZmZlY3QiLCJ1c2VNZW1vIiwidXNlUmVmIiwidXNlU3RhdGUiLCJXYWxsZXROb3RTZWxlY3RlZEVycm9yIiwiV2FsbGV0Q29udGV4dCIsIldhbGxldFByb3ZpZGVyQmFzZSIsImNoaWxkcmVuIiwid2FsbGV0cyIsImFkYXB0ZXJzIiwiYWRhcHRlciIsImlzVW5sb2FkaW5nUmVmIiwib25BdXRvQ29ubmVjdFJlcXVlc3QiLCJvbkNvbm5lY3RFcnJvciIsIm9uRXJyb3IiLCJvblNlbGVjdFdhbGxldCIsImlzQ29ubmVjdGluZ1JlZiIsImNvbm5lY3RpbmciLCJzZXRDb25uZWN0aW5nIiwiaXNEaXNjb25uZWN0aW5nUmVmIiwiZGlzY29ubmVjdGluZyIsInNldERpc2Nvbm5lY3RpbmciLCJwdWJsaWNLZXkiLCJzZXRQdWJsaWNLZXkiLCJjb25uZWN0ZWQiLCJzZXRDb25uZWN0ZWQiLCJvbkVycm9yUmVmIiwiY3VycmVudCIsInVuZGVmaW5lZCIsImhhbmRsZUVycm9yUmVmIiwiZXJyb3IiLCJjb25zb2xlIiwid2luZG93Iiwib3BlbiIsInVybCIsInNldFdhbGxldHMiLCJtYXAiLCJyZWFkeVN0YXRlIiwiZmlsdGVyIiwiVW5zdXBwb3J0ZWQiLCJpbmRleCIsIndhbGxldCIsImhhbmRsZVJlYWR5U3RhdGVDaGFuZ2UiLCJwcmV2V2FsbGV0cyIsImZpbmRJbmRleCIsInNsaWNlIiwiZm9yRWFjaCIsIm9uIiwib2ZmIiwiZmluZCIsImhhbmRsZUNvbm5lY3QiLCJoYW5kbGVEaXNjb25uZWN0IiwiaGFuZGxlRXJyb3IiLCJkaWRBdHRlbXB0QXV0b0Nvbm5lY3RSZWYiLCJJbnN0YWxsZWQiLCJMb2FkYWJsZSIsInNlbmRUcmFuc2FjdGlvbiIsInRyYW5zYWN0aW9uIiwiY29ubmVjdGlvbiIsIm9wdGlvbnMiLCJzaWduVHJhbnNhY3Rpb24iLCJzaWduQWxsVHJhbnNhY3Rpb25zIiwidHJhbnNhY3Rpb25zIiwic2lnbk1lc3NhZ2UiLCJtZXNzYWdlIiwic2lnbkluIiwiaW5wdXQiLCJjb25uZWN0IiwiZSIsImRpc2Nvbm5lY3QiLCJjcmVhdGVFbGVtZW50IiwiUHJvdmlkZXIiLCJ2YWx1ZSIsImF1dG9Db25uZWN0Iiwic2VsZWN0Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/@solana/wallet-adapter-react/lib/esm/WalletProviderBase.js\n");

/***/ }),

/***/ "(ssr)/../node_modules/@solana/wallet-adapter-react/lib/esm/errors.js":
/*!**********************************************************************!*\
  !*** ../node_modules/@solana/wallet-adapter-react/lib/esm/errors.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   WalletNotSelectedError: () => (/* binding */ WalletNotSelectedError)\n/* harmony export */ });\n/* harmony import */ var _solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @solana/wallet-adapter-base */ \"(ssr)/../node_modules/@solana/wallet-adapter-base/lib/esm/errors.js\");\n\nclass WalletNotSelectedError extends _solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_0__.WalletError {\n    constructor(){\n        super(...arguments);\n        this.name = \"WalletNotSelectedError\";\n    }\n} //# sourceMappingURL=errors.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL0Bzb2xhbmEvd2FsbGV0LWFkYXB0ZXItcmVhY3QvbGliL2VzbS9lcnJvcnMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBMEQ7QUFDbkQsTUFBTUMsK0JBQStCRCxvRUFBV0E7SUFDbkRFLGFBQWM7UUFDVixLQUFLLElBQUlDO1FBQ1QsSUFBSSxDQUFDQyxJQUFJLEdBQUc7SUFDaEI7QUFDSixFQUNBLGtDQUFrQyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvQHNvbGFuYS93YWxsZXQtYWRhcHRlci1yZWFjdC9saWIvZXNtL2Vycm9ycy5qcz9lNWRiIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IFdhbGxldEVycm9yIH0gZnJvbSAnQHNvbGFuYS93YWxsZXQtYWRhcHRlci1iYXNlJztcbmV4cG9ydCBjbGFzcyBXYWxsZXROb3RTZWxlY3RlZEVycm9yIGV4dGVuZHMgV2FsbGV0RXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgICAgICB0aGlzLm5hbWUgPSAnV2FsbGV0Tm90U2VsZWN0ZWRFcnJvcic7XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZXJyb3JzLmpzLm1hcCJdLCJuYW1lcyI6WyJXYWxsZXRFcnJvciIsIldhbGxldE5vdFNlbGVjdGVkRXJyb3IiLCJjb25zdHJ1Y3RvciIsImFyZ3VtZW50cyIsIm5hbWUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/@solana/wallet-adapter-react/lib/esm/errors.js\n");

/***/ }),

/***/ "(ssr)/../node_modules/@solana/wallet-adapter-react/lib/esm/getEnvironment.js":
/*!******************************************************************************!*\
  !*** ../node_modules/@solana/wallet-adapter-react/lib/esm/getEnvironment.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Environment: () => (/* binding */ Environment),\n/* harmony export */   \"default\": () => (/* binding */ getEnvironment)\n/* harmony export */ });\n/* harmony import */ var _solana_mobile_wallet_adapter_mobile__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @solana-mobile/wallet-adapter-mobile */ \"(ssr)/../node_modules/@solana-mobile/wallet-adapter-mobile/lib/esm/index.js\");\n/* harmony import */ var _solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @solana/wallet-adapter-base */ \"(ssr)/../node_modules/@solana/wallet-adapter-base/lib/esm/adapter.js\");\n\n\nvar Environment;\n(function(Environment) {\n    Environment[Environment[\"DESKTOP_WEB\"] = 0] = \"DESKTOP_WEB\";\n    Environment[Environment[\"MOBILE_WEB\"] = 1] = \"MOBILE_WEB\";\n})(Environment || (Environment = {}));\nfunction isWebView(userAgentString) {\n    return /(WebView|Version\\/.+(Chrome)\\/(\\d+)\\.(\\d+)\\.(\\d+)\\.(\\d+)|; wv\\).+(Chrome)\\/(\\d+)\\.(\\d+)\\.(\\d+)\\.(\\d+))/i.test(userAgentString);\n}\nfunction getEnvironment({ adapters, userAgentString }) {\n    if (adapters.some((adapter)=>adapter.name !== _solana_mobile_wallet_adapter_mobile__WEBPACK_IMPORTED_MODULE_0__.SolanaMobileWalletAdapterWalletName && adapter.readyState === _solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_1__.WalletReadyState.Installed)) {\n        /**\n         * There are only two ways a browser extension adapter should be able to reach `Installed` status:\n         *\n         *     1. Its browser extension is installed.\n         *     2. The app is running on a mobile wallet's in-app browser.\n         *\n         * In either case, we consider the environment to be desktop-like.\n         */ return Environment.DESKTOP_WEB;\n    }\n    if (userAgentString && // Step 1: Check whether we're on a platform that supports MWA at all.\n    /android/i.test(userAgentString) && // Step 2: Determine that we are *not* running in a WebView.\n    !isWebView(userAgentString)) {\n        return Environment.MOBILE_WEB;\n    } else {\n        return Environment.DESKTOP_WEB;\n    }\n} //# sourceMappingURL=getEnvironment.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL0Bzb2xhbmEvd2FsbGV0LWFkYXB0ZXItcmVhY3QvbGliL2VzbS9nZXRFbnZpcm9ubWVudC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQTJGO0FBQzVCO0FBQ3hELElBQUlFLFlBQVk7QUFDdEIsVUFBVUEsV0FBVztJQUNsQkEsV0FBVyxDQUFDQSxXQUFXLENBQUMsY0FBYyxHQUFHLEVBQUUsR0FBRztJQUM5Q0EsV0FBVyxDQUFDQSxXQUFXLENBQUMsYUFBYSxHQUFHLEVBQUUsR0FBRztBQUNqRCxHQUFHQSxlQUFnQkEsQ0FBQUEsY0FBYyxDQUFDO0FBQ2xDLFNBQVNDLFVBQVVDLGVBQWU7SUFDOUIsT0FBTywwR0FBMEdDLElBQUksQ0FBQ0Q7QUFDMUg7QUFDZSxTQUFTRSxlQUFlLEVBQUVDLFFBQVEsRUFBRUgsZUFBZSxFQUFFO0lBQ2hFLElBQUlHLFNBQVNDLElBQUksQ0FBQyxDQUFDQyxVQUFZQSxRQUFRQyxJQUFJLEtBQUtWLHFHQUFtQ0EsSUFDL0VTLFFBQVFFLFVBQVUsS0FBS1YseUVBQWdCQSxDQUFDVyxTQUFTLEdBQUc7UUFDcEQ7Ozs7Ozs7U0FPQyxHQUNELE9BQU9WLFlBQVlXLFdBQVc7SUFDbEM7SUFDQSxJQUFJVCxtQkFDQSxzRUFBc0U7SUFDdEUsV0FBV0MsSUFBSSxDQUFDRCxvQkFDaEIsNERBQTREO0lBQzVELENBQUNELFVBQVVDLGtCQUFrQjtRQUM3QixPQUFPRixZQUFZWSxVQUFVO0lBQ2pDLE9BQ0s7UUFDRCxPQUFPWixZQUFZVyxXQUFXO0lBQ2xDO0FBQ0osRUFDQSwwQ0FBMEMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL0Bzb2xhbmEvd2FsbGV0LWFkYXB0ZXItcmVhY3QvbGliL2VzbS9nZXRFbnZpcm9ubWVudC5qcz83Zjk2Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IFNvbGFuYU1vYmlsZVdhbGxldEFkYXB0ZXJXYWxsZXROYW1lIH0gZnJvbSAnQHNvbGFuYS1tb2JpbGUvd2FsbGV0LWFkYXB0ZXItbW9iaWxlJztcbmltcG9ydCB7IFdhbGxldFJlYWR5U3RhdGUgfSBmcm9tICdAc29sYW5hL3dhbGxldC1hZGFwdGVyLWJhc2UnO1xuZXhwb3J0IHZhciBFbnZpcm9ubWVudDtcbihmdW5jdGlvbiAoRW52aXJvbm1lbnQpIHtcbiAgICBFbnZpcm9ubWVudFtFbnZpcm9ubWVudFtcIkRFU0tUT1BfV0VCXCJdID0gMF0gPSBcIkRFU0tUT1BfV0VCXCI7XG4gICAgRW52aXJvbm1lbnRbRW52aXJvbm1lbnRbXCJNT0JJTEVfV0VCXCJdID0gMV0gPSBcIk1PQklMRV9XRUJcIjtcbn0pKEVudmlyb25tZW50IHx8IChFbnZpcm9ubWVudCA9IHt9KSk7XG5mdW5jdGlvbiBpc1dlYlZpZXcodXNlckFnZW50U3RyaW5nKSB7XG4gICAgcmV0dXJuIC8oV2ViVmlld3xWZXJzaW9uXFwvLisoQ2hyb21lKVxcLyhcXGQrKVxcLihcXGQrKVxcLihcXGQrKVxcLihcXGQrKXw7IHd2XFwpLisoQ2hyb21lKVxcLyhcXGQrKVxcLihcXGQrKVxcLihcXGQrKVxcLihcXGQrKSkvaS50ZXN0KHVzZXJBZ2VudFN0cmluZyk7XG59XG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBnZXRFbnZpcm9ubWVudCh7IGFkYXB0ZXJzLCB1c2VyQWdlbnRTdHJpbmcgfSkge1xuICAgIGlmIChhZGFwdGVycy5zb21lKChhZGFwdGVyKSA9PiBhZGFwdGVyLm5hbWUgIT09IFNvbGFuYU1vYmlsZVdhbGxldEFkYXB0ZXJXYWxsZXROYW1lICYmXG4gICAgICAgIGFkYXB0ZXIucmVhZHlTdGF0ZSA9PT0gV2FsbGV0UmVhZHlTdGF0ZS5JbnN0YWxsZWQpKSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGVyZSBhcmUgb25seSB0d28gd2F5cyBhIGJyb3dzZXIgZXh0ZW5zaW9uIGFkYXB0ZXIgc2hvdWxkIGJlIGFibGUgdG8gcmVhY2ggYEluc3RhbGxlZGAgc3RhdHVzOlxuICAgICAgICAgKlxuICAgICAgICAgKiAgICAgMS4gSXRzIGJyb3dzZXIgZXh0ZW5zaW9uIGlzIGluc3RhbGxlZC5cbiAgICAgICAgICogICAgIDIuIFRoZSBhcHAgaXMgcnVubmluZyBvbiBhIG1vYmlsZSB3YWxsZXQncyBpbi1hcHAgYnJvd3Nlci5cbiAgICAgICAgICpcbiAgICAgICAgICogSW4gZWl0aGVyIGNhc2UsIHdlIGNvbnNpZGVyIHRoZSBlbnZpcm9ubWVudCB0byBiZSBkZXNrdG9wLWxpa2UuXG4gICAgICAgICAqL1xuICAgICAgICByZXR1cm4gRW52aXJvbm1lbnQuREVTS1RPUF9XRUI7XG4gICAgfVxuICAgIGlmICh1c2VyQWdlbnRTdHJpbmcgJiZcbiAgICAgICAgLy8gU3RlcCAxOiBDaGVjayB3aGV0aGVyIHdlJ3JlIG9uIGEgcGxhdGZvcm0gdGhhdCBzdXBwb3J0cyBNV0EgYXQgYWxsLlxuICAgICAgICAvYW5kcm9pZC9pLnRlc3QodXNlckFnZW50U3RyaW5nKSAmJlxuICAgICAgICAvLyBTdGVwIDI6IERldGVybWluZSB0aGF0IHdlIGFyZSAqbm90KiBydW5uaW5nIGluIGEgV2ViVmlldy5cbiAgICAgICAgIWlzV2ViVmlldyh1c2VyQWdlbnRTdHJpbmcpKSB7XG4gICAgICAgIHJldHVybiBFbnZpcm9ubWVudC5NT0JJTEVfV0VCO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIEVudmlyb25tZW50LkRFU0tUT1BfV0VCO1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWdldEVudmlyb25tZW50LmpzLm1hcCJdLCJuYW1lcyI6WyJTb2xhbmFNb2JpbGVXYWxsZXRBZGFwdGVyV2FsbGV0TmFtZSIsIldhbGxldFJlYWR5U3RhdGUiLCJFbnZpcm9ubWVudCIsImlzV2ViVmlldyIsInVzZXJBZ2VudFN0cmluZyIsInRlc3QiLCJnZXRFbnZpcm9ubWVudCIsImFkYXB0ZXJzIiwic29tZSIsImFkYXB0ZXIiLCJuYW1lIiwicmVhZHlTdGF0ZSIsIkluc3RhbGxlZCIsIkRFU0tUT1BfV0VCIiwiTU9CSUxFX1dFQiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/@solana/wallet-adapter-react/lib/esm/getEnvironment.js\n");

/***/ }),

/***/ "(ssr)/../node_modules/@solana/wallet-adapter-react/lib/esm/getInferredClusterFromEndpoint.js":
/*!**********************************************************************************************!*\
  !*** ../node_modules/@solana/wallet-adapter-react/lib/esm/getInferredClusterFromEndpoint.js ***!
  \**********************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ getInferredClusterFromEndpoint)\n/* harmony export */ });\nfunction getInferredClusterFromEndpoint(endpoint) {\n    if (!endpoint) {\n        return \"mainnet-beta\";\n    }\n    if (/devnet/i.test(endpoint)) {\n        return \"devnet\";\n    } else if (/testnet/i.test(endpoint)) {\n        return \"testnet\";\n    } else {\n        return \"mainnet-beta\";\n    }\n} //# sourceMappingURL=getInferredClusterFromEndpoint.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL0Bzb2xhbmEvd2FsbGV0LWFkYXB0ZXItcmVhY3QvbGliL2VzbS9nZXRJbmZlcnJlZENsdXN0ZXJGcm9tRW5kcG9pbnQuanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFlLFNBQVNBLCtCQUErQkMsUUFBUTtJQUMzRCxJQUFJLENBQUNBLFVBQVU7UUFDWCxPQUFPO0lBQ1g7SUFDQSxJQUFJLFVBQVVDLElBQUksQ0FBQ0QsV0FBVztRQUMxQixPQUFPO0lBQ1gsT0FDSyxJQUFJLFdBQVdDLElBQUksQ0FBQ0QsV0FBVztRQUNoQyxPQUFPO0lBQ1gsT0FDSztRQUNELE9BQU87SUFDWDtBQUNKLEVBQ0EsMERBQTBEIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9Ac29sYW5hL3dhbGxldC1hZGFwdGVyLXJlYWN0L2xpYi9lc20vZ2V0SW5mZXJyZWRDbHVzdGVyRnJvbUVuZHBvaW50LmpzPzIzY2QiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZ2V0SW5mZXJyZWRDbHVzdGVyRnJvbUVuZHBvaW50KGVuZHBvaW50KSB7XG4gICAgaWYgKCFlbmRwb2ludCkge1xuICAgICAgICByZXR1cm4gJ21haW5uZXQtYmV0YSc7XG4gICAgfVxuICAgIGlmICgvZGV2bmV0L2kudGVzdChlbmRwb2ludCkpIHtcbiAgICAgICAgcmV0dXJuICdkZXZuZXQnO1xuICAgIH1cbiAgICBlbHNlIGlmICgvdGVzdG5ldC9pLnRlc3QoZW5kcG9pbnQpKSB7XG4gICAgICAgIHJldHVybiAndGVzdG5ldCc7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gJ21haW5uZXQtYmV0YSc7XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Z2V0SW5mZXJyZWRDbHVzdGVyRnJvbUVuZHBvaW50LmpzLm1hcCJdLCJuYW1lcyI6WyJnZXRJbmZlcnJlZENsdXN0ZXJGcm9tRW5kcG9pbnQiLCJlbmRwb2ludCIsInRlc3QiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/@solana/wallet-adapter-react/lib/esm/getInferredClusterFromEndpoint.js\n");

/***/ }),

/***/ "(ssr)/../node_modules/@solana/wallet-adapter-react/lib/esm/useConnection.js":
/*!*****************************************************************************!*\
  !*** ../node_modules/@solana/wallet-adapter-react/lib/esm/useConnection.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ConnectionContext: () => (/* binding */ ConnectionContext),\n/* harmony export */   useConnection: () => (/* binding */ useConnection)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/../node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n\nconst ConnectionContext = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.createContext)({});\nfunction useConnection() {\n    return (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(ConnectionContext);\n} //# sourceMappingURL=useConnection.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL0Bzb2xhbmEvd2FsbGV0LWFkYXB0ZXItcmVhY3QvbGliL2VzbS91c2VDb25uZWN0aW9uLmpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUFrRDtBQUMzQyxNQUFNRSxrQ0FBb0JGLG9EQUFhQSxDQUFDLENBQUMsR0FBRztBQUM1QyxTQUFTRztJQUNaLE9BQU9GLGlEQUFVQSxDQUFDQztBQUN0QixFQUNBLHlDQUF5QyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvQHNvbGFuYS93YWxsZXQtYWRhcHRlci1yZWFjdC9saWIvZXNtL3VzZUNvbm5lY3Rpb24uanM/MTk2ZSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBjcmVhdGVDb250ZXh0LCB1c2VDb250ZXh0IH0gZnJvbSAncmVhY3QnO1xuZXhwb3J0IGNvbnN0IENvbm5lY3Rpb25Db250ZXh0ID0gY3JlYXRlQ29udGV4dCh7fSk7XG5leHBvcnQgZnVuY3Rpb24gdXNlQ29ubmVjdGlvbigpIHtcbiAgICByZXR1cm4gdXNlQ29udGV4dChDb25uZWN0aW9uQ29udGV4dCk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD11c2VDb25uZWN0aW9uLmpzLm1hcCJdLCJuYW1lcyI6WyJjcmVhdGVDb250ZXh0IiwidXNlQ29udGV4dCIsIkNvbm5lY3Rpb25Db250ZXh0IiwidXNlQ29ubmVjdGlvbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/@solana/wallet-adapter-react/lib/esm/useConnection.js\n");

/***/ }),

/***/ "(ssr)/../node_modules/@solana/wallet-adapter-react/lib/esm/useLocalStorage.js":
/*!*******************************************************************************!*\
  !*** ../node_modules/@solana/wallet-adapter-react/lib/esm/useLocalStorage.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   useLocalStorage: () => (/* binding */ useLocalStorage)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/../node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n\nfunction useLocalStorage(key, defaultState) {\n    const state = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(()=>{\n        try {\n            const value = localStorage.getItem(key);\n            if (value) return JSON.parse(value);\n        } catch (error) {\n            if (false) {}\n        }\n        return defaultState;\n    });\n    const value = state[0];\n    const isFirstRenderRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(true);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        if (isFirstRenderRef.current) {\n            isFirstRenderRef.current = false;\n            return;\n        }\n        try {\n            if (value === null) {\n                localStorage.removeItem(key);\n            } else {\n                localStorage.setItem(key, JSON.stringify(value));\n            }\n        } catch (error) {\n            if (false) {}\n        }\n    }, [\n        value,\n        key\n    ]);\n    return state;\n} //# sourceMappingURL=useLocalStorage.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL0Bzb2xhbmEvd2FsbGV0LWFkYXB0ZXItcmVhY3QvbGliL2VzbS91c2VMb2NhbFN0b3JhZ2UuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBb0Q7QUFDN0MsU0FBU0csZ0JBQWdCQyxHQUFHLEVBQUVDLFlBQVk7SUFDN0MsTUFBTUMsUUFBUUosK0NBQVFBLENBQUM7UUFDbkIsSUFBSTtZQUNBLE1BQU1LLFFBQVFDLGFBQWFDLE9BQU8sQ0FBQ0w7WUFDbkMsSUFBSUcsT0FDQSxPQUFPRyxLQUFLQyxLQUFLLENBQUNKO1FBQzFCLEVBQ0EsT0FBT0ssT0FBTztZQUNWLElBQUksS0FBa0IsRUFBYSxFQUVsQztRQUNMO1FBQ0EsT0FBT1A7SUFDWDtJQUNBLE1BQU1FLFFBQVFELEtBQUssQ0FBQyxFQUFFO0lBQ3RCLE1BQU1RLG1CQUFtQmIsNkNBQU1BLENBQUM7SUFDaENELGdEQUFTQSxDQUFDO1FBQ04sSUFBSWMsaUJBQWlCQyxPQUFPLEVBQUU7WUFDMUJELGlCQUFpQkMsT0FBTyxHQUFHO1lBQzNCO1FBQ0o7UUFDQSxJQUFJO1lBQ0EsSUFBSVIsVUFBVSxNQUFNO2dCQUNoQkMsYUFBYVEsVUFBVSxDQUFDWjtZQUM1QixPQUNLO2dCQUNESSxhQUFhUyxPQUFPLENBQUNiLEtBQUtNLEtBQUtRLFNBQVMsQ0FBQ1g7WUFDN0M7UUFDSixFQUNBLE9BQU9LLE9BQU87WUFDVixJQUFJLEtBQWtCLEVBQWEsRUFFbEM7UUFDTDtJQUNKLEdBQUc7UUFBQ0w7UUFBT0g7S0FBSTtJQUNmLE9BQU9FO0FBQ1gsRUFDQSwyQ0FBMkMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL0Bzb2xhbmEvd2FsbGV0LWFkYXB0ZXItcmVhY3QvbGliL2VzbS91c2VMb2NhbFN0b3JhZ2UuanM/MmZhOSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyB1c2VFZmZlY3QsIHVzZVJlZiwgdXNlU3RhdGUgfSBmcm9tICdyZWFjdCc7XG5leHBvcnQgZnVuY3Rpb24gdXNlTG9jYWxTdG9yYWdlKGtleSwgZGVmYXVsdFN0YXRlKSB7XG4gICAgY29uc3Qgc3RhdGUgPSB1c2VTdGF0ZSgoKSA9PiB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCB2YWx1ZSA9IGxvY2FsU3RvcmFnZS5nZXRJdGVtKGtleSk7XG4gICAgICAgICAgICBpZiAodmFsdWUpXG4gICAgICAgICAgICAgICAgcmV0dXJuIEpTT04ucGFyc2UodmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihlcnJvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGRlZmF1bHRTdGF0ZTtcbiAgICB9KTtcbiAgICBjb25zdCB2YWx1ZSA9IHN0YXRlWzBdO1xuICAgIGNvbnN0IGlzRmlyc3RSZW5kZXJSZWYgPSB1c2VSZWYodHJ1ZSk7XG4gICAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgaWYgKGlzRmlyc3RSZW5kZXJSZWYuY3VycmVudCkge1xuICAgICAgICAgICAgaXNGaXJzdFJlbmRlclJlZi5jdXJyZW50ID0gZmFsc2U7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGlmICh2YWx1ZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGxvY2FsU3RvcmFnZS5yZW1vdmVJdGVtKGtleSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBsb2NhbFN0b3JhZ2Uuc2V0SXRlbShrZXksIEpTT04uc3RyaW5naWZ5KHZhbHVlKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKGVycm9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sIFt2YWx1ZSwga2V5XSk7XG4gICAgcmV0dXJuIHN0YXRlO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dXNlTG9jYWxTdG9yYWdlLmpzLm1hcCJdLCJuYW1lcyI6WyJ1c2VFZmZlY3QiLCJ1c2VSZWYiLCJ1c2VTdGF0ZSIsInVzZUxvY2FsU3RvcmFnZSIsImtleSIsImRlZmF1bHRTdGF0ZSIsInN0YXRlIiwidmFsdWUiLCJsb2NhbFN0b3JhZ2UiLCJnZXRJdGVtIiwiSlNPTiIsInBhcnNlIiwiZXJyb3IiLCJjb25zb2xlIiwiaXNGaXJzdFJlbmRlclJlZiIsImN1cnJlbnQiLCJyZW1vdmVJdGVtIiwic2V0SXRlbSIsInN0cmluZ2lmeSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/@solana/wallet-adapter-react/lib/esm/useLocalStorage.js\n");

/***/ }),

/***/ "(ssr)/../node_modules/@solana/wallet-adapter-react/lib/esm/useWallet.js":
/*!*************************************************************************!*\
  !*** ../node_modules/@solana/wallet-adapter-react/lib/esm/useWallet.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   WalletContext: () => (/* binding */ WalletContext),\n/* harmony export */   useWallet: () => (/* binding */ useWallet)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/../node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n\nconst EMPTY_ARRAY = [];\nconst DEFAULT_CONTEXT = {\n    autoConnect: false,\n    connecting: false,\n    connected: false,\n    disconnecting: false,\n    select () {\n        logMissingProviderError(\"call\", \"select\");\n    },\n    connect () {\n        return Promise.reject(logMissingProviderError(\"call\", \"connect\"));\n    },\n    disconnect () {\n        return Promise.reject(logMissingProviderError(\"call\", \"disconnect\"));\n    },\n    sendTransaction () {\n        return Promise.reject(logMissingProviderError(\"call\", \"sendTransaction\"));\n    },\n    signTransaction () {\n        return Promise.reject(logMissingProviderError(\"call\", \"signTransaction\"));\n    },\n    signAllTransactions () {\n        return Promise.reject(logMissingProviderError(\"call\", \"signAllTransactions\"));\n    },\n    signMessage () {\n        return Promise.reject(logMissingProviderError(\"call\", \"signMessage\"));\n    },\n    signIn () {\n        return Promise.reject(logMissingProviderError(\"call\", \"signIn\"));\n    }\n};\nObject.defineProperty(DEFAULT_CONTEXT, \"wallets\", {\n    get () {\n        logMissingProviderError(\"read\", \"wallets\");\n        return EMPTY_ARRAY;\n    }\n});\nObject.defineProperty(DEFAULT_CONTEXT, \"wallet\", {\n    get () {\n        logMissingProviderError(\"read\", \"wallet\");\n        return null;\n    }\n});\nObject.defineProperty(DEFAULT_CONTEXT, \"publicKey\", {\n    get () {\n        logMissingProviderError(\"read\", \"publicKey\");\n        return null;\n    }\n});\nfunction logMissingProviderError(action, property) {\n    const error = new Error(`You have tried to ${action} \"${property}\" on a WalletContext without providing one. ` + \"Make sure to render a WalletProvider as an ancestor of the component that uses WalletContext.\");\n    console.error(error);\n    return error;\n}\nconst WalletContext = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.createContext)(DEFAULT_CONTEXT);\nfunction useWallet() {\n    return (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(WalletContext);\n} //# sourceMappingURL=useWallet.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL0Bzb2xhbmEvd2FsbGV0LWFkYXB0ZXItcmVhY3QvbGliL2VzbS91c2VXYWxsZXQuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQWtEO0FBQ2xELE1BQU1FLGNBQWMsRUFBRTtBQUN0QixNQUFNQyxrQkFBa0I7SUFDcEJDLGFBQWE7SUFDYkMsWUFBWTtJQUNaQyxXQUFXO0lBQ1hDLGVBQWU7SUFDZkM7UUFDSUMsd0JBQXdCLFFBQVE7SUFDcEM7SUFDQUM7UUFDSSxPQUFPQyxRQUFRQyxNQUFNLENBQUNILHdCQUF3QixRQUFRO0lBQzFEO0lBQ0FJO1FBQ0ksT0FBT0YsUUFBUUMsTUFBTSxDQUFDSCx3QkFBd0IsUUFBUTtJQUMxRDtJQUNBSztRQUNJLE9BQU9ILFFBQVFDLE1BQU0sQ0FBQ0gsd0JBQXdCLFFBQVE7SUFDMUQ7SUFDQU07UUFDSSxPQUFPSixRQUFRQyxNQUFNLENBQUNILHdCQUF3QixRQUFRO0lBQzFEO0lBQ0FPO1FBQ0ksT0FBT0wsUUFBUUMsTUFBTSxDQUFDSCx3QkFBd0IsUUFBUTtJQUMxRDtJQUNBUTtRQUNJLE9BQU9OLFFBQVFDLE1BQU0sQ0FBQ0gsd0JBQXdCLFFBQVE7SUFDMUQ7SUFDQVM7UUFDSSxPQUFPUCxRQUFRQyxNQUFNLENBQUNILHdCQUF3QixRQUFRO0lBQzFEO0FBQ0o7QUFDQVUsT0FBT0MsY0FBYyxDQUFDakIsaUJBQWlCLFdBQVc7SUFDOUNrQjtRQUNJWix3QkFBd0IsUUFBUTtRQUNoQyxPQUFPUDtJQUNYO0FBQ0o7QUFDQWlCLE9BQU9DLGNBQWMsQ0FBQ2pCLGlCQUFpQixVQUFVO0lBQzdDa0I7UUFDSVosd0JBQXdCLFFBQVE7UUFDaEMsT0FBTztJQUNYO0FBQ0o7QUFDQVUsT0FBT0MsY0FBYyxDQUFDakIsaUJBQWlCLGFBQWE7SUFDaERrQjtRQUNJWix3QkFBd0IsUUFBUTtRQUNoQyxPQUFPO0lBQ1g7QUFDSjtBQUNBLFNBQVNBLHdCQUF3QmEsTUFBTSxFQUFFQyxRQUFRO0lBQzdDLE1BQU1DLFFBQVEsSUFBSUMsTUFBTSxDQUFDLGtCQUFrQixFQUFFSCxPQUFPLEVBQUUsRUFBRUMsU0FBUyw0Q0FBNEMsQ0FBQyxHQUMxRztJQUNKRyxRQUFRRixLQUFLLENBQUNBO0lBQ2QsT0FBT0E7QUFDWDtBQUNPLE1BQU1HLDhCQUFnQjNCLG9EQUFhQSxDQUFDRyxpQkFBaUI7QUFDckQsU0FBU3lCO0lBQ1osT0FBTzNCLGlEQUFVQSxDQUFDMEI7QUFDdEIsRUFDQSxxQ0FBcUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL0Bzb2xhbmEvd2FsbGV0LWFkYXB0ZXItcmVhY3QvbGliL2VzbS91c2VXYWxsZXQuanM/MzBhMCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBjcmVhdGVDb250ZXh0LCB1c2VDb250ZXh0IH0gZnJvbSAncmVhY3QnO1xuY29uc3QgRU1QVFlfQVJSQVkgPSBbXTtcbmNvbnN0IERFRkFVTFRfQ09OVEVYVCA9IHtcbiAgICBhdXRvQ29ubmVjdDogZmFsc2UsXG4gICAgY29ubmVjdGluZzogZmFsc2UsXG4gICAgY29ubmVjdGVkOiBmYWxzZSxcbiAgICBkaXNjb25uZWN0aW5nOiBmYWxzZSxcbiAgICBzZWxlY3QoKSB7XG4gICAgICAgIGxvZ01pc3NpbmdQcm92aWRlckVycm9yKCdjYWxsJywgJ3NlbGVjdCcpO1xuICAgIH0sXG4gICAgY29ubmVjdCgpIHtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KGxvZ01pc3NpbmdQcm92aWRlckVycm9yKCdjYWxsJywgJ2Nvbm5lY3QnKSk7XG4gICAgfSxcbiAgICBkaXNjb25uZWN0KCkge1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QobG9nTWlzc2luZ1Byb3ZpZGVyRXJyb3IoJ2NhbGwnLCAnZGlzY29ubmVjdCcpKTtcbiAgICB9LFxuICAgIHNlbmRUcmFuc2FjdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KGxvZ01pc3NpbmdQcm92aWRlckVycm9yKCdjYWxsJywgJ3NlbmRUcmFuc2FjdGlvbicpKTtcbiAgICB9LFxuICAgIHNpZ25UcmFuc2FjdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KGxvZ01pc3NpbmdQcm92aWRlckVycm9yKCdjYWxsJywgJ3NpZ25UcmFuc2FjdGlvbicpKTtcbiAgICB9LFxuICAgIHNpZ25BbGxUcmFuc2FjdGlvbnMoKSB7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChsb2dNaXNzaW5nUHJvdmlkZXJFcnJvcignY2FsbCcsICdzaWduQWxsVHJhbnNhY3Rpb25zJykpO1xuICAgIH0sXG4gICAgc2lnbk1lc3NhZ2UoKSB7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChsb2dNaXNzaW5nUHJvdmlkZXJFcnJvcignY2FsbCcsICdzaWduTWVzc2FnZScpKTtcbiAgICB9LFxuICAgIHNpZ25JbigpIHtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KGxvZ01pc3NpbmdQcm92aWRlckVycm9yKCdjYWxsJywgJ3NpZ25JbicpKTtcbiAgICB9LFxufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShERUZBVUxUX0NPTlRFWFQsICd3YWxsZXRzJywge1xuICAgIGdldCgpIHtcbiAgICAgICAgbG9nTWlzc2luZ1Byb3ZpZGVyRXJyb3IoJ3JlYWQnLCAnd2FsbGV0cycpO1xuICAgICAgICByZXR1cm4gRU1QVFlfQVJSQVk7XG4gICAgfSxcbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KERFRkFVTFRfQ09OVEVYVCwgJ3dhbGxldCcsIHtcbiAgICBnZXQoKSB7XG4gICAgICAgIGxvZ01pc3NpbmdQcm92aWRlckVycm9yKCdyZWFkJywgJ3dhbGxldCcpO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9LFxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoREVGQVVMVF9DT05URVhULCAncHVibGljS2V5Jywge1xuICAgIGdldCgpIHtcbiAgICAgICAgbG9nTWlzc2luZ1Byb3ZpZGVyRXJyb3IoJ3JlYWQnLCAncHVibGljS2V5Jyk7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH0sXG59KTtcbmZ1bmN0aW9uIGxvZ01pc3NpbmdQcm92aWRlckVycm9yKGFjdGlvbiwgcHJvcGVydHkpIHtcbiAgICBjb25zdCBlcnJvciA9IG5ldyBFcnJvcihgWW91IGhhdmUgdHJpZWQgdG8gJHthY3Rpb259IFwiJHtwcm9wZXJ0eX1cIiBvbiBhIFdhbGxldENvbnRleHQgd2l0aG91dCBwcm92aWRpbmcgb25lLiBgICtcbiAgICAgICAgJ01ha2Ugc3VyZSB0byByZW5kZXIgYSBXYWxsZXRQcm92aWRlciBhcyBhbiBhbmNlc3RvciBvZiB0aGUgY29tcG9uZW50IHRoYXQgdXNlcyBXYWxsZXRDb250ZXh0LicpO1xuICAgIGNvbnNvbGUuZXJyb3IoZXJyb3IpO1xuICAgIHJldHVybiBlcnJvcjtcbn1cbmV4cG9ydCBjb25zdCBXYWxsZXRDb250ZXh0ID0gY3JlYXRlQ29udGV4dChERUZBVUxUX0NPTlRFWFQpO1xuZXhwb3J0IGZ1bmN0aW9uIHVzZVdhbGxldCgpIHtcbiAgICByZXR1cm4gdXNlQ29udGV4dChXYWxsZXRDb250ZXh0KTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXVzZVdhbGxldC5qcy5tYXAiXSwibmFtZXMiOlsiY3JlYXRlQ29udGV4dCIsInVzZUNvbnRleHQiLCJFTVBUWV9BUlJBWSIsIkRFRkFVTFRfQ09OVEVYVCIsImF1dG9Db25uZWN0IiwiY29ubmVjdGluZyIsImNvbm5lY3RlZCIsImRpc2Nvbm5lY3RpbmciLCJzZWxlY3QiLCJsb2dNaXNzaW5nUHJvdmlkZXJFcnJvciIsImNvbm5lY3QiLCJQcm9taXNlIiwicmVqZWN0IiwiZGlzY29ubmVjdCIsInNlbmRUcmFuc2FjdGlvbiIsInNpZ25UcmFuc2FjdGlvbiIsInNpZ25BbGxUcmFuc2FjdGlvbnMiLCJzaWduTWVzc2FnZSIsInNpZ25JbiIsIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZ2V0IiwiYWN0aW9uIiwicHJvcGVydHkiLCJlcnJvciIsIkVycm9yIiwiY29uc29sZSIsIldhbGxldENvbnRleHQiLCJ1c2VXYWxsZXQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/@solana/wallet-adapter-react/lib/esm/useWallet.js\n");

/***/ }),

/***/ "(ssr)/../node_modules/@solana/wallet-standard-chains/lib/esm/index.js":
/*!***********************************************************************!*\
  !*** ../node_modules/@solana/wallet-standard-chains/lib/esm/index.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   SOLANA_CHAINS: () => (/* binding */ SOLANA_CHAINS),\n/* harmony export */   SOLANA_DEVNET_CHAIN: () => (/* binding */ SOLANA_DEVNET_CHAIN),\n/* harmony export */   SOLANA_LOCALNET_CHAIN: () => (/* binding */ SOLANA_LOCALNET_CHAIN),\n/* harmony export */   SOLANA_MAINNET_CHAIN: () => (/* binding */ SOLANA_MAINNET_CHAIN),\n/* harmony export */   SOLANA_TESTNET_CHAIN: () => (/* binding */ SOLANA_TESTNET_CHAIN),\n/* harmony export */   isSolanaChain: () => (/* binding */ isSolanaChain)\n/* harmony export */ });\n/** Solana Mainnet (beta) cluster, e.g. https://api.mainnet-beta.solana.com */ const SOLANA_MAINNET_CHAIN = \"solana:mainnet\";\n/** Solana Devnet cluster, e.g. https://api.devnet.solana.com */ const SOLANA_DEVNET_CHAIN = \"solana:devnet\";\n/** Solana Testnet cluster, e.g. https://api.testnet.solana.com */ const SOLANA_TESTNET_CHAIN = \"solana:testnet\";\n/** Solana Localnet cluster, e.g. http://localhost:8899 */ const SOLANA_LOCALNET_CHAIN = \"solana:localnet\";\n/** Array of all Solana clusters */ const SOLANA_CHAINS = [\n    SOLANA_MAINNET_CHAIN,\n    SOLANA_DEVNET_CHAIN,\n    SOLANA_TESTNET_CHAIN,\n    SOLANA_LOCALNET_CHAIN\n];\n/**\n * Check if a chain corresponds with one of the Solana clusters.\n */ function isSolanaChain(chain) {\n    return SOLANA_CHAINS.includes(chain);\n} //# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL0Bzb2xhbmEvd2FsbGV0LXN0YW5kYXJkLWNoYWlucy9saWIvZXNtL2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7OztBQUFBLDRFQUE0RSxHQUNyRSxNQUFNQSx1QkFBdUIsaUJBQWlCO0FBQ3JELDhEQUE4RCxHQUN2RCxNQUFNQyxzQkFBc0IsZ0JBQWdCO0FBQ25ELGdFQUFnRSxHQUN6RCxNQUFNQyx1QkFBdUIsaUJBQWlCO0FBQ3JELHdEQUF3RCxHQUNqRCxNQUFNQyx3QkFBd0Isa0JBQWtCO0FBQ3ZELGlDQUFpQyxHQUMxQixNQUFNQyxnQkFBZ0I7SUFDekJKO0lBQ0FDO0lBQ0FDO0lBQ0FDO0NBQ0gsQ0FBQztBQUNGOztDQUVDLEdBQ00sU0FBU0UsY0FBY0MsS0FBSztJQUMvQixPQUFPRixjQUFjRyxRQUFRLENBQUNEO0FBQ2xDLEVBQ0EsaUNBQWlDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9Ac29sYW5hL3dhbGxldC1zdGFuZGFyZC1jaGFpbnMvbGliL2VzbS9pbmRleC5qcz9jMDhhIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKiBTb2xhbmEgTWFpbm5ldCAoYmV0YSkgY2x1c3RlciwgZS5nLiBodHRwczovL2FwaS5tYWlubmV0LWJldGEuc29sYW5hLmNvbSAqL1xuZXhwb3J0IGNvbnN0IFNPTEFOQV9NQUlOTkVUX0NIQUlOID0gJ3NvbGFuYTptYWlubmV0Jztcbi8qKiBTb2xhbmEgRGV2bmV0IGNsdXN0ZXIsIGUuZy4gaHR0cHM6Ly9hcGkuZGV2bmV0LnNvbGFuYS5jb20gKi9cbmV4cG9ydCBjb25zdCBTT0xBTkFfREVWTkVUX0NIQUlOID0gJ3NvbGFuYTpkZXZuZXQnO1xuLyoqIFNvbGFuYSBUZXN0bmV0IGNsdXN0ZXIsIGUuZy4gaHR0cHM6Ly9hcGkudGVzdG5ldC5zb2xhbmEuY29tICovXG5leHBvcnQgY29uc3QgU09MQU5BX1RFU1RORVRfQ0hBSU4gPSAnc29sYW5hOnRlc3RuZXQnO1xuLyoqIFNvbGFuYSBMb2NhbG5ldCBjbHVzdGVyLCBlLmcuIGh0dHA6Ly9sb2NhbGhvc3Q6ODg5OSAqL1xuZXhwb3J0IGNvbnN0IFNPTEFOQV9MT0NBTE5FVF9DSEFJTiA9ICdzb2xhbmE6bG9jYWxuZXQnO1xuLyoqIEFycmF5IG9mIGFsbCBTb2xhbmEgY2x1c3RlcnMgKi9cbmV4cG9ydCBjb25zdCBTT0xBTkFfQ0hBSU5TID0gW1xuICAgIFNPTEFOQV9NQUlOTkVUX0NIQUlOLFxuICAgIFNPTEFOQV9ERVZORVRfQ0hBSU4sXG4gICAgU09MQU5BX1RFU1RORVRfQ0hBSU4sXG4gICAgU09MQU5BX0xPQ0FMTkVUX0NIQUlOLFxuXTtcbi8qKlxuICogQ2hlY2sgaWYgYSBjaGFpbiBjb3JyZXNwb25kcyB3aXRoIG9uZSBvZiB0aGUgU29sYW5hIGNsdXN0ZXJzLlxuICovXG5leHBvcnQgZnVuY3Rpb24gaXNTb2xhbmFDaGFpbihjaGFpbikge1xuICAgIHJldHVybiBTT0xBTkFfQ0hBSU5TLmluY2x1ZGVzKGNoYWluKTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCJdLCJuYW1lcyI6WyJTT0xBTkFfTUFJTk5FVF9DSEFJTiIsIlNPTEFOQV9ERVZORVRfQ0hBSU4iLCJTT0xBTkFfVEVTVE5FVF9DSEFJTiIsIlNPTEFOQV9MT0NBTE5FVF9DSEFJTiIsIlNPTEFOQV9DSEFJTlMiLCJpc1NvbGFuYUNoYWluIiwiY2hhaW4iLCJpbmNsdWRlcyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/@solana/wallet-standard-chains/lib/esm/index.js\n");

/***/ }),

/***/ "(ssr)/../node_modules/@solana/wallet-standard-features/lib/esm/signAndSendTransaction.js":
/*!******************************************************************************************!*\
  !*** ../node_modules/@solana/wallet-standard-features/lib/esm/signAndSendTransaction.js ***!
  \******************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   SolanaSignAndSendTransaction: () => (/* binding */ SolanaSignAndSendTransaction)\n/* harmony export */ });\n/** Name of the feature. */ const SolanaSignAndSendTransaction = \"solana:signAndSendTransaction\"; //# sourceMappingURL=signAndSendTransaction.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL0Bzb2xhbmEvd2FsbGV0LXN0YW5kYXJkLWZlYXR1cmVzL2xpYi9lc20vc2lnbkFuZFNlbmRUcmFuc2FjdGlvbi5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQUEseUJBQXlCLEdBQ2xCLE1BQU1BLCtCQUErQixnQ0FBZ0MsQ0FDNUUsa0RBQWtEIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9Ac29sYW5hL3dhbGxldC1zdGFuZGFyZC1mZWF0dXJlcy9saWIvZXNtL3NpZ25BbmRTZW5kVHJhbnNhY3Rpb24uanM/MTYwNSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiogTmFtZSBvZiB0aGUgZmVhdHVyZS4gKi9cbmV4cG9ydCBjb25zdCBTb2xhbmFTaWduQW5kU2VuZFRyYW5zYWN0aW9uID0gJ3NvbGFuYTpzaWduQW5kU2VuZFRyYW5zYWN0aW9uJztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXNpZ25BbmRTZW5kVHJhbnNhY3Rpb24uanMubWFwIl0sIm5hbWVzIjpbIlNvbGFuYVNpZ25BbmRTZW5kVHJhbnNhY3Rpb24iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/@solana/wallet-standard-features/lib/esm/signAndSendTransaction.js\n");

/***/ }),

/***/ "(ssr)/../node_modules/@solana/wallet-standard-features/lib/esm/signIn.js":
/*!**************************************************************************!*\
  !*** ../node_modules/@solana/wallet-standard-features/lib/esm/signIn.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   SolanaSignIn: () => (/* binding */ SolanaSignIn)\n/* harmony export */ });\n/** Name of the feature. */ const SolanaSignIn = \"solana:signIn\"; //# sourceMappingURL=signIn.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL0Bzb2xhbmEvd2FsbGV0LXN0YW5kYXJkLWZlYXR1cmVzL2xpYi9lc20vc2lnbkluLmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQSx5QkFBeUIsR0FDbEIsTUFBTUEsZUFBZSxnQkFBZ0IsQ0FDNUMsa0NBQWtDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9Ac29sYW5hL3dhbGxldC1zdGFuZGFyZC1mZWF0dXJlcy9saWIvZXNtL3NpZ25Jbi5qcz8wZmQ1Il0sInNvdXJjZXNDb250ZW50IjpbIi8qKiBOYW1lIG9mIHRoZSBmZWF0dXJlLiAqL1xuZXhwb3J0IGNvbnN0IFNvbGFuYVNpZ25JbiA9ICdzb2xhbmE6c2lnbkluJztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXNpZ25Jbi5qcy5tYXAiXSwibmFtZXMiOlsiU29sYW5hU2lnbkluIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/@solana/wallet-standard-features/lib/esm/signIn.js\n");

/***/ }),

/***/ "(ssr)/../node_modules/@solana/wallet-standard-features/lib/esm/signMessage.js":
/*!*******************************************************************************!*\
  !*** ../node_modules/@solana/wallet-standard-features/lib/esm/signMessage.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   SolanaSignMessage: () => (/* binding */ SolanaSignMessage)\n/* harmony export */ });\n/** Name of the feature. */ const SolanaSignMessage = \"solana:signMessage\"; //# sourceMappingURL=signMessage.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL0Bzb2xhbmEvd2FsbGV0LXN0YW5kYXJkLWZlYXR1cmVzL2xpYi9lc20vc2lnbk1lc3NhZ2UuanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFBLHlCQUF5QixHQUNsQixNQUFNQSxvQkFBb0IscUJBQXFCLENBQ3RELHVDQUF1QyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvQHNvbGFuYS93YWxsZXQtc3RhbmRhcmQtZmVhdHVyZXMvbGliL2VzbS9zaWduTWVzc2FnZS5qcz9mMTYzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKiBOYW1lIG9mIHRoZSBmZWF0dXJlLiAqL1xuZXhwb3J0IGNvbnN0IFNvbGFuYVNpZ25NZXNzYWdlID0gJ3NvbGFuYTpzaWduTWVzc2FnZSc7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zaWduTWVzc2FnZS5qcy5tYXAiXSwibmFtZXMiOlsiU29sYW5hU2lnbk1lc3NhZ2UiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/@solana/wallet-standard-features/lib/esm/signMessage.js\n");

/***/ }),

/***/ "(ssr)/../node_modules/@solana/wallet-standard-features/lib/esm/signTransaction.js":
/*!***********************************************************************************!*\
  !*** ../node_modules/@solana/wallet-standard-features/lib/esm/signTransaction.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   SolanaSignTransaction: () => (/* binding */ SolanaSignTransaction)\n/* harmony export */ });\n/** Name of the feature. */ const SolanaSignTransaction = \"solana:signTransaction\"; //# sourceMappingURL=signTransaction.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL0Bzb2xhbmEvd2FsbGV0LXN0YW5kYXJkLWZlYXR1cmVzL2xpYi9lc20vc2lnblRyYW5zYWN0aW9uLmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQSx5QkFBeUIsR0FDbEIsTUFBTUEsd0JBQXdCLHlCQUF5QixDQUM5RCwyQ0FBMkMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL0Bzb2xhbmEvd2FsbGV0LXN0YW5kYXJkLWZlYXR1cmVzL2xpYi9lc20vc2lnblRyYW5zYWN0aW9uLmpzPzZlNjIiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqIE5hbWUgb2YgdGhlIGZlYXR1cmUuICovXG5leHBvcnQgY29uc3QgU29sYW5hU2lnblRyYW5zYWN0aW9uID0gJ3NvbGFuYTpzaWduVHJhbnNhY3Rpb24nO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c2lnblRyYW5zYWN0aW9uLmpzLm1hcCJdLCJuYW1lcyI6WyJTb2xhbmFTaWduVHJhbnNhY3Rpb24iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/@solana/wallet-standard-features/lib/esm/signTransaction.js\n");

/***/ }),

/***/ "(ssr)/../node_modules/@solana/wallet-standard-util/lib/esm/commitment.js":
/*!**************************************************************************!*\
  !*** ../node_modules/@solana/wallet-standard-util/lib/esm/commitment.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getCommitment: () => (/* binding */ getCommitment)\n/* harmony export */ });\n/**\n * TODO: docs\n */ function getCommitment(commitment) {\n    switch(commitment){\n        case \"processed\":\n        case \"confirmed\":\n        case \"finalized\":\n        case undefined:\n            return commitment;\n        case \"recent\":\n            return \"processed\";\n        case \"single\":\n        case \"singleGossip\":\n            return \"confirmed\";\n        case \"max\":\n        case \"root\":\n            return \"finalized\";\n        default:\n            return undefined;\n    }\n} //# sourceMappingURL=commitment.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL0Bzb2xhbmEvd2FsbGV0LXN0YW5kYXJkLXV0aWwvbGliL2VzbS9jb21taXRtZW50LmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQTs7Q0FFQyxHQUNNLFNBQVNBLGNBQWNDLFVBQVU7SUFDcEMsT0FBUUE7UUFDSixLQUFLO1FBQ0wsS0FBSztRQUNMLEtBQUs7UUFDTCxLQUFLQztZQUNELE9BQU9EO1FBQ1gsS0FBSztZQUNELE9BQU87UUFDWCxLQUFLO1FBQ0wsS0FBSztZQUNELE9BQU87UUFDWCxLQUFLO1FBQ0wsS0FBSztZQUNELE9BQU87UUFDWDtZQUNJLE9BQU9DO0lBQ2Y7QUFDSixFQUNBLHNDQUFzQyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvQHNvbGFuYS93YWxsZXQtc3RhbmRhcmQtdXRpbC9saWIvZXNtL2NvbW1pdG1lbnQuanM/MzEwZiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIFRPRE86IGRvY3NcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldENvbW1pdG1lbnQoY29tbWl0bWVudCkge1xuICAgIHN3aXRjaCAoY29tbWl0bWVudCkge1xuICAgICAgICBjYXNlICdwcm9jZXNzZWQnOlxuICAgICAgICBjYXNlICdjb25maXJtZWQnOlxuICAgICAgICBjYXNlICdmaW5hbGl6ZWQnOlxuICAgICAgICBjYXNlIHVuZGVmaW5lZDpcbiAgICAgICAgICAgIHJldHVybiBjb21taXRtZW50O1xuICAgICAgICBjYXNlICdyZWNlbnQnOlxuICAgICAgICAgICAgcmV0dXJuICdwcm9jZXNzZWQnO1xuICAgICAgICBjYXNlICdzaW5nbGUnOlxuICAgICAgICBjYXNlICdzaW5nbGVHb3NzaXAnOlxuICAgICAgICAgICAgcmV0dXJuICdjb25maXJtZWQnO1xuICAgICAgICBjYXNlICdtYXgnOlxuICAgICAgICBjYXNlICdyb290JzpcbiAgICAgICAgICAgIHJldHVybiAnZmluYWxpemVkJztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y29tbWl0bWVudC5qcy5tYXAiXSwibmFtZXMiOlsiZ2V0Q29tbWl0bWVudCIsImNvbW1pdG1lbnQiLCJ1bmRlZmluZWQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/@solana/wallet-standard-util/lib/esm/commitment.js\n");

/***/ }),

/***/ "(ssr)/../node_modules/@solana/wallet-standard-util/lib/esm/endpoint.js":
/*!************************************************************************!*\
  !*** ../node_modules/@solana/wallet-standard-util/lib/esm/endpoint.js ***!
  \************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DEVNET_ENDPOINT: () => (/* binding */ DEVNET_ENDPOINT),\n/* harmony export */   LOCALNET_ENDPOINT: () => (/* binding */ LOCALNET_ENDPOINT),\n/* harmony export */   MAINNET_ENDPOINT: () => (/* binding */ MAINNET_ENDPOINT),\n/* harmony export */   TESTNET_ENDPOINT: () => (/* binding */ TESTNET_ENDPOINT),\n/* harmony export */   getChainForEndpoint: () => (/* binding */ getChainForEndpoint),\n/* harmony export */   getEndpointForChain: () => (/* binding */ getEndpointForChain)\n/* harmony export */ });\n/* harmony import */ var _solana_wallet_standard_chains__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @solana/wallet-standard-chains */ \"(ssr)/../node_modules/@solana/wallet-standard-chains/lib/esm/index.js\");\n\n/** TODO: docs */ const MAINNET_ENDPOINT = \"https://api.mainnet-beta.solana.com\";\n/** TODO: docs */ const DEVNET_ENDPOINT = \"https://api.devnet.solana.com\";\n/** TODO: docs */ const TESTNET_ENDPOINT = \"https://api.testnet.solana.com\";\n/** TODO: docs */ const LOCALNET_ENDPOINT = \"http://localhost:8899\";\n/**\n * TODO: docs\n */ function getChainForEndpoint(endpoint) {\n    if (endpoint.includes(MAINNET_ENDPOINT)) return _solana_wallet_standard_chains__WEBPACK_IMPORTED_MODULE_0__.SOLANA_MAINNET_CHAIN;\n    if (/\\bdevnet\\b/i.test(endpoint)) return _solana_wallet_standard_chains__WEBPACK_IMPORTED_MODULE_0__.SOLANA_DEVNET_CHAIN;\n    if (/\\btestnet\\b/i.test(endpoint)) return _solana_wallet_standard_chains__WEBPACK_IMPORTED_MODULE_0__.SOLANA_TESTNET_CHAIN;\n    if (/\\blocalhost\\b/i.test(endpoint) || /\\b127\\.0\\.0\\.1\\b/.test(endpoint)) return _solana_wallet_standard_chains__WEBPACK_IMPORTED_MODULE_0__.SOLANA_LOCALNET_CHAIN;\n    return _solana_wallet_standard_chains__WEBPACK_IMPORTED_MODULE_0__.SOLANA_MAINNET_CHAIN;\n}\n/**\n * TODO: docs\n */ function getEndpointForChain(chain, endpoint) {\n    if (endpoint) return endpoint;\n    if (chain === _solana_wallet_standard_chains__WEBPACK_IMPORTED_MODULE_0__.SOLANA_MAINNET_CHAIN) return MAINNET_ENDPOINT;\n    if (chain === _solana_wallet_standard_chains__WEBPACK_IMPORTED_MODULE_0__.SOLANA_DEVNET_CHAIN) return DEVNET_ENDPOINT;\n    if (chain === _solana_wallet_standard_chains__WEBPACK_IMPORTED_MODULE_0__.SOLANA_TESTNET_CHAIN) return TESTNET_ENDPOINT;\n    if (chain === _solana_wallet_standard_chains__WEBPACK_IMPORTED_MODULE_0__.SOLANA_LOCALNET_CHAIN) return LOCALNET_ENDPOINT;\n    return MAINNET_ENDPOINT;\n} //# sourceMappingURL=endpoint.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL0Bzb2xhbmEvd2FsbGV0LXN0YW5kYXJkLXV0aWwvbGliL2VzbS9lbmRwb2ludC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7O0FBQXlJO0FBQ3pJLGVBQWUsR0FDUixNQUFNSSxtQkFBbUIsc0NBQXNDO0FBQ3RFLGVBQWUsR0FDUixNQUFNQyxrQkFBa0IsZ0NBQWdDO0FBQy9ELGVBQWUsR0FDUixNQUFNQyxtQkFBbUIsaUNBQWlDO0FBQ2pFLGVBQWUsR0FDUixNQUFNQyxvQkFBb0Isd0JBQXdCO0FBQ3pEOztDQUVDLEdBQ00sU0FBU0Msb0JBQW9CQyxRQUFRO0lBQ3hDLElBQUlBLFNBQVNDLFFBQVEsQ0FBQ04sbUJBQ2xCLE9BQU9GLGdGQUFvQkE7SUFDL0IsSUFBSSxjQUFjUyxJQUFJLENBQUNGLFdBQ25CLE9BQU9ULCtFQUFtQkE7SUFDOUIsSUFBSSxlQUFlVyxJQUFJLENBQUNGLFdBQ3BCLE9BQU9OLGdGQUFvQkE7SUFDL0IsSUFBSSxpQkFBaUJRLElBQUksQ0FBQ0YsYUFBYSxtQkFBbUJFLElBQUksQ0FBQ0YsV0FDM0QsT0FBT1IsaUZBQXFCQTtJQUNoQyxPQUFPQyxnRkFBb0JBO0FBQy9CO0FBQ0E7O0NBRUMsR0FDTSxTQUFTVSxvQkFBb0JDLEtBQUssRUFBRUosUUFBUTtJQUMvQyxJQUFJQSxVQUNBLE9BQU9BO0lBQ1gsSUFBSUksVUFBVVgsZ0ZBQW9CQSxFQUM5QixPQUFPRTtJQUNYLElBQUlTLFVBQVViLCtFQUFtQkEsRUFDN0IsT0FBT0s7SUFDWCxJQUFJUSxVQUFVVixnRkFBb0JBLEVBQzlCLE9BQU9HO0lBQ1gsSUFBSU8sVUFBVVosaUZBQXFCQSxFQUMvQixPQUFPTTtJQUNYLE9BQU9IO0FBQ1gsRUFDQSxvQ0FBb0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL0Bzb2xhbmEvd2FsbGV0LXN0YW5kYXJkLXV0aWwvbGliL2VzbS9lbmRwb2ludC5qcz9hNDhlIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IFNPTEFOQV9ERVZORVRfQ0hBSU4sIFNPTEFOQV9MT0NBTE5FVF9DSEFJTiwgU09MQU5BX01BSU5ORVRfQ0hBSU4sIFNPTEFOQV9URVNUTkVUX0NIQUlOLCB9IGZyb20gJ0Bzb2xhbmEvd2FsbGV0LXN0YW5kYXJkLWNoYWlucyc7XG4vKiogVE9ETzogZG9jcyAqL1xuZXhwb3J0IGNvbnN0IE1BSU5ORVRfRU5EUE9JTlQgPSAnaHR0cHM6Ly9hcGkubWFpbm5ldC1iZXRhLnNvbGFuYS5jb20nO1xuLyoqIFRPRE86IGRvY3MgKi9cbmV4cG9ydCBjb25zdCBERVZORVRfRU5EUE9JTlQgPSAnaHR0cHM6Ly9hcGkuZGV2bmV0LnNvbGFuYS5jb20nO1xuLyoqIFRPRE86IGRvY3MgKi9cbmV4cG9ydCBjb25zdCBURVNUTkVUX0VORFBPSU5UID0gJ2h0dHBzOi8vYXBpLnRlc3RuZXQuc29sYW5hLmNvbSc7XG4vKiogVE9ETzogZG9jcyAqL1xuZXhwb3J0IGNvbnN0IExPQ0FMTkVUX0VORFBPSU5UID0gJ2h0dHA6Ly9sb2NhbGhvc3Q6ODg5OSc7XG4vKipcbiAqIFRPRE86IGRvY3NcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldENoYWluRm9yRW5kcG9pbnQoZW5kcG9pbnQpIHtcbiAgICBpZiAoZW5kcG9pbnQuaW5jbHVkZXMoTUFJTk5FVF9FTkRQT0lOVCkpXG4gICAgICAgIHJldHVybiBTT0xBTkFfTUFJTk5FVF9DSEFJTjtcbiAgICBpZiAoL1xcYmRldm5ldFxcYi9pLnRlc3QoZW5kcG9pbnQpKVxuICAgICAgICByZXR1cm4gU09MQU5BX0RFVk5FVF9DSEFJTjtcbiAgICBpZiAoL1xcYnRlc3RuZXRcXGIvaS50ZXN0KGVuZHBvaW50KSlcbiAgICAgICAgcmV0dXJuIFNPTEFOQV9URVNUTkVUX0NIQUlOO1xuICAgIGlmICgvXFxibG9jYWxob3N0XFxiL2kudGVzdChlbmRwb2ludCkgfHwgL1xcYjEyN1xcLjBcXC4wXFwuMVxcYi8udGVzdChlbmRwb2ludCkpXG4gICAgICAgIHJldHVybiBTT0xBTkFfTE9DQUxORVRfQ0hBSU47XG4gICAgcmV0dXJuIFNPTEFOQV9NQUlOTkVUX0NIQUlOO1xufVxuLyoqXG4gKiBUT0RPOiBkb2NzXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRFbmRwb2ludEZvckNoYWluKGNoYWluLCBlbmRwb2ludCkge1xuICAgIGlmIChlbmRwb2ludClcbiAgICAgICAgcmV0dXJuIGVuZHBvaW50O1xuICAgIGlmIChjaGFpbiA9PT0gU09MQU5BX01BSU5ORVRfQ0hBSU4pXG4gICAgICAgIHJldHVybiBNQUlOTkVUX0VORFBPSU5UO1xuICAgIGlmIChjaGFpbiA9PT0gU09MQU5BX0RFVk5FVF9DSEFJTilcbiAgICAgICAgcmV0dXJuIERFVk5FVF9FTkRQT0lOVDtcbiAgICBpZiAoY2hhaW4gPT09IFNPTEFOQV9URVNUTkVUX0NIQUlOKVxuICAgICAgICByZXR1cm4gVEVTVE5FVF9FTkRQT0lOVDtcbiAgICBpZiAoY2hhaW4gPT09IFNPTEFOQV9MT0NBTE5FVF9DSEFJTilcbiAgICAgICAgcmV0dXJuIExPQ0FMTkVUX0VORFBPSU5UO1xuICAgIHJldHVybiBNQUlOTkVUX0VORFBPSU5UO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZW5kcG9pbnQuanMubWFwIl0sIm5hbWVzIjpbIlNPTEFOQV9ERVZORVRfQ0hBSU4iLCJTT0xBTkFfTE9DQUxORVRfQ0hBSU4iLCJTT0xBTkFfTUFJTk5FVF9DSEFJTiIsIlNPTEFOQV9URVNUTkVUX0NIQUlOIiwiTUFJTk5FVF9FTkRQT0lOVCIsIkRFVk5FVF9FTkRQT0lOVCIsIlRFU1RORVRfRU5EUE9JTlQiLCJMT0NBTE5FVF9FTkRQT0lOVCIsImdldENoYWluRm9yRW5kcG9pbnQiLCJlbmRwb2ludCIsImluY2x1ZGVzIiwidGVzdCIsImdldEVuZHBvaW50Rm9yQ2hhaW4iLCJjaGFpbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/@solana/wallet-standard-util/lib/esm/endpoint.js\n");

/***/ }),

/***/ "(ssr)/../node_modules/@solana/wallet-standard-util/lib/esm/signIn.js":
/*!**********************************************************************!*\
  !*** ../node_modules/@solana/wallet-standard-util/lib/esm/signIn.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createSignInMessage: () => (/* binding */ createSignInMessage),\n/* harmony export */   createSignInMessageText: () => (/* binding */ createSignInMessageText),\n/* harmony export */   deriveSignInMessage: () => (/* binding */ deriveSignInMessage),\n/* harmony export */   deriveSignInMessageText: () => (/* binding */ deriveSignInMessageText),\n/* harmony export */   parseSignInMessage: () => (/* binding */ parseSignInMessage),\n/* harmony export */   parseSignInMessageText: () => (/* binding */ parseSignInMessageText),\n/* harmony export */   verifySignIn: () => (/* binding */ verifySignIn)\n/* harmony export */ });\n/* harmony import */ var _signMessage_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./signMessage.js */ \"(ssr)/../node_modules/@solana/wallet-standard-util/lib/esm/signMessage.js\");\n/* harmony import */ var _util_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./util.js */ \"(ssr)/../node_modules/@solana/wallet-standard-util/lib/esm/util.js\");\n\n\n/**\n * TODO: docs\n */ function verifySignIn(input, output) {\n    const { signedMessage, signature, account: { publicKey } } = output;\n    const message = deriveSignInMessage(input, output);\n    return !!message && (0,_signMessage_js__WEBPACK_IMPORTED_MODULE_0__.verifyMessageSignature)({\n        message,\n        signedMessage,\n        signature,\n        publicKey\n    });\n}\n/**\n * TODO: docs\n */ function deriveSignInMessage(input, output) {\n    const text = deriveSignInMessageText(input, output);\n    if (!text) return null;\n    return new TextEncoder().encode(text);\n}\n/**\n * TODO: docs\n */ function deriveSignInMessageText(input, output) {\n    const parsed = parseSignInMessage(output.signedMessage);\n    if (!parsed) return null;\n    if (input.domain && input.domain !== parsed.domain) return null;\n    if (input.address && input.address !== parsed.address) return null;\n    if (input.statement !== parsed.statement) return null;\n    if (input.uri !== parsed.uri) return null;\n    if (input.version !== parsed.version) return null;\n    if (input.chainId !== parsed.chainId) return null;\n    if (input.nonce !== parsed.nonce) return null;\n    if (input.issuedAt !== parsed.issuedAt) return null;\n    if (input.expirationTime !== parsed.expirationTime) return null;\n    if (input.notBefore !== parsed.notBefore) return null;\n    if (input.requestId !== parsed.requestId) return null;\n    if (input.resources) {\n        if (!parsed.resources) return null;\n        if (!(0,_util_js__WEBPACK_IMPORTED_MODULE_1__.arraysEqual)(input.resources, parsed.resources)) return null;\n    } else if (parsed.resources) return null;\n    return createSignInMessageText(parsed);\n}\n/**\n * TODO: docs\n */ function parseSignInMessage(message) {\n    const text = new TextDecoder().decode(message);\n    return parseSignInMessageText(text);\n}\n// TODO: implement https://github.com/solana-labs/solana/blob/master/docs/src/proposals/off-chain-message-signing.md\nconst DOMAIN = \"(?<domain>[^\\\\n]+?) wants you to sign in with your Solana account:\\\\n\";\nconst ADDRESS = \"(?<address>[^\\\\n]+)(?:\\\\n|$)\";\nconst STATEMENT = \"(?:\\\\n(?<statement>[\\\\S\\\\s]*?)(?:\\\\n|$))??\";\nconst URI = \"(?:\\\\nURI: (?<uri>[^\\\\n]+))?\";\nconst VERSION = \"(?:\\\\nVersion: (?<version>[^\\\\n]+))?\";\nconst CHAIN_ID = \"(?:\\\\nChain ID: (?<chainId>[^\\\\n]+))?\";\nconst NONCE = \"(?:\\\\nNonce: (?<nonce>[^\\\\n]+))?\";\nconst ISSUED_AT = \"(?:\\\\nIssued At: (?<issuedAt>[^\\\\n]+))?\";\nconst EXPIRATION_TIME = \"(?:\\\\nExpiration Time: (?<expirationTime>[^\\\\n]+))?\";\nconst NOT_BEFORE = \"(?:\\\\nNot Before: (?<notBefore>[^\\\\n]+))?\";\nconst REQUEST_ID = \"(?:\\\\nRequest ID: (?<requestId>[^\\\\n]+))?\";\nconst RESOURCES = \"(?:\\\\nResources:(?<resources>(?:\\\\n- [^\\\\n]+)*))?\";\nconst FIELDS = `${URI}${VERSION}${CHAIN_ID}${NONCE}${ISSUED_AT}${EXPIRATION_TIME}${NOT_BEFORE}${REQUEST_ID}${RESOURCES}`;\nconst MESSAGE = new RegExp(`^${DOMAIN}${ADDRESS}${STATEMENT}${FIELDS}\\\\n*$`);\n/**\n * TODO: docs\n */ function parseSignInMessageText(text) {\n    const match = MESSAGE.exec(text);\n    if (!match) return null;\n    const groups = match.groups;\n    if (!groups) return null;\n    return {\n        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n        domain: groups.domain,\n        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n        address: groups.address,\n        statement: groups.statement,\n        uri: groups.uri,\n        version: groups.version,\n        nonce: groups.nonce,\n        chainId: groups.chainId,\n        issuedAt: groups.issuedAt,\n        expirationTime: groups.expirationTime,\n        notBefore: groups.notBefore,\n        requestId: groups.requestId,\n        resources: groups.resources?.split(\"\\n- \").slice(1)\n    };\n}\n/**\n * TODO: docs\n */ function createSignInMessage(input) {\n    const text = createSignInMessageText(input);\n    return new TextEncoder().encode(text);\n}\n/**\n * TODO: docs\n */ function createSignInMessageText(input) {\n    // ${domain} wants you to sign in with your Solana account:\n    // ${address}\n    //\n    // ${statement}\n    //\n    // URI: ${uri}\n    // Version: ${version}\n    // Chain ID: ${chain}\n    // Nonce: ${nonce}\n    // Issued At: ${issued-at}\n    // Expiration Time: ${expiration-time}\n    // Not Before: ${not-before}\n    // Request ID: ${request-id}\n    // Resources:\n    // - ${resources[0]}\n    // - ${resources[1]}\n    // ...\n    // - ${resources[n]}\n    let message = `${input.domain} wants you to sign in with your Solana account:\\n`;\n    message += `${input.address}`;\n    if (input.statement) {\n        message += `\\n\\n${input.statement}`;\n    }\n    const fields = [];\n    if (input.uri) {\n        fields.push(`URI: ${input.uri}`);\n    }\n    if (input.version) {\n        fields.push(`Version: ${input.version}`);\n    }\n    if (input.chainId) {\n        fields.push(`Chain ID: ${input.chainId}`);\n    }\n    if (input.nonce) {\n        fields.push(`Nonce: ${input.nonce}`);\n    }\n    if (input.issuedAt) {\n        fields.push(`Issued At: ${input.issuedAt}`);\n    }\n    if (input.expirationTime) {\n        fields.push(`Expiration Time: ${input.expirationTime}`);\n    }\n    if (input.notBefore) {\n        fields.push(`Not Before: ${input.notBefore}`);\n    }\n    if (input.requestId) {\n        fields.push(`Request ID: ${input.requestId}`);\n    }\n    if (input.resources) {\n        fields.push(`Resources:`);\n        for (const resource of input.resources){\n            fields.push(`- ${resource}`);\n        }\n    }\n    if (fields.length) {\n        message += `\\n\\n${fields.join(\"\\n\")}`;\n    }\n    return message;\n} //# sourceMappingURL=signIn.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL0Bzb2xhbmEvd2FsbGV0LXN0YW5kYXJkLXV0aWwvbGliL2VzbS9zaWduSW4uanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7O0FBQTBEO0FBQ2xCO0FBQ3hDOztDQUVDLEdBQ00sU0FBU0UsYUFBYUMsS0FBSyxFQUFFQyxNQUFNO0lBQ3RDLE1BQU0sRUFBRUMsYUFBYSxFQUFFQyxTQUFTLEVBQUVDLFNBQVMsRUFBRUMsU0FBUyxFQUFFLEVBQUcsR0FBR0o7SUFDOUQsTUFBTUssVUFBVUMsb0JBQW9CUCxPQUFPQztJQUMzQyxPQUFPLENBQUMsQ0FBQ0ssV0FBV1QsdUVBQXNCQSxDQUFDO1FBQUVTO1FBQVNKO1FBQWVDO1FBQVdFO0lBQVU7QUFDOUY7QUFDQTs7Q0FFQyxHQUNNLFNBQVNFLG9CQUFvQlAsS0FBSyxFQUFFQyxNQUFNO0lBQzdDLE1BQU1PLE9BQU9DLHdCQUF3QlQsT0FBT0M7SUFDNUMsSUFBSSxDQUFDTyxNQUNELE9BQU87SUFDWCxPQUFPLElBQUlFLGNBQWNDLE1BQU0sQ0FBQ0g7QUFDcEM7QUFDQTs7Q0FFQyxHQUNNLFNBQVNDLHdCQUF3QlQsS0FBSyxFQUFFQyxNQUFNO0lBQ2pELE1BQU1XLFNBQVNDLG1CQUFtQlosT0FBT0MsYUFBYTtJQUN0RCxJQUFJLENBQUNVLFFBQ0QsT0FBTztJQUNYLElBQUlaLE1BQU1jLE1BQU0sSUFBSWQsTUFBTWMsTUFBTSxLQUFLRixPQUFPRSxNQUFNLEVBQzlDLE9BQU87SUFDWCxJQUFJZCxNQUFNZSxPQUFPLElBQUlmLE1BQU1lLE9BQU8sS0FBS0gsT0FBT0csT0FBTyxFQUNqRCxPQUFPO0lBQ1gsSUFBSWYsTUFBTWdCLFNBQVMsS0FBS0osT0FBT0ksU0FBUyxFQUNwQyxPQUFPO0lBQ1gsSUFBSWhCLE1BQU1pQixHQUFHLEtBQUtMLE9BQU9LLEdBQUcsRUFDeEIsT0FBTztJQUNYLElBQUlqQixNQUFNa0IsT0FBTyxLQUFLTixPQUFPTSxPQUFPLEVBQ2hDLE9BQU87SUFDWCxJ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LEVBQUVwRCxNQUFNc0IsY0FBYyxDQUFDLENBQUM7SUFDMUQ7SUFDQSxJQUFJdEIsTUFBTXVCLFNBQVMsRUFBRTtRQUNqQjRCLE9BQU9DLElBQUksQ0FBQyxDQUFDLFlBQVksRUFBRXBELE1BQU11QixTQUFTLENBQUMsQ0FBQztJQUNoRDtJQUNBLElBQUl2QixNQUFNd0IsU0FBUyxFQUFFO1FBQ2pCMkIsT0FBT0MsSUFBSSxDQUFDLENBQUMsWUFBWSxFQUFFcEQsTUFBTXdCLFNBQVMsQ0FBQyxDQUFDO0lBQ2hEO0lBQ0EsSUFBSXhCLE1BQU15QixTQUFTLEVBQUU7UUFDakIwQixPQUFPQyxJQUFJLENBQUMsQ0FBQyxVQUFVLENBQUM7UUFDeEIsS0FBSyxNQUFNQyxZQUFZckQsTUFBTXlCLFNBQVMsQ0FBRTtZQUNwQzBCLE9BQU9DLElBQUksQ0FBQyxDQUFDLEVBQUUsRUFBRUMsU0FBUyxDQUFDO1FBQy9CO0lBQ0o7SUFDQSxJQUFJRixPQUFPRyxNQUFNLEVBQUU7UUFDZmhELFdBQVcsQ0FBQyxJQUFJLEVBQUU2QyxPQUFPSSxJQUFJLENBQUMsTUFBTSxDQUFDO0lBQ3pDO0lBQ0EsT0FBT2pEO0FBQ1gsRUFDQSxrQ0FBa0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL0Bzb2xhbmEvd2FsbGV0LXN0YW5kYXJkLXV0aWwvbGliL2VzbS9zaWduSW4uanM/NWQ4MCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyB2ZXJpZnlNZXNzYWdlU2lnbmF0dXJlIH0gZnJvbSAnLi9zaWduTWVzc2FnZS5qcyc7XG5pbXBvcnQgeyBhcnJheXNFcXVhbCB9IGZyb20gJy4vdXRpbC5qcyc7XG4vKipcbiAqIFRPRE86IGRvY3NcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHZlcmlmeVNpZ25JbihpbnB1dCwgb3V0cHV0KSB7XG4gICAgY29uc3QgeyBzaWduZWRNZXNzYWdlLCBzaWduYXR1cmUsIGFjY291bnQ6IHsgcHVibGljS2V5IH0sIH0gPSBvdXRwdXQ7XG4gICAgY29uc3QgbWVzc2FnZSA9IGRlcml2ZVNpZ25Jbk1lc3NhZ2UoaW5wdXQsIG91dHB1dCk7XG4gICAgcmV0dXJuICEhbWVzc2FnZSAmJiB2ZXJpZnlNZXNzYWdlU2lnbmF0dXJlKHsgbWVzc2FnZSwgc2lnbmVkTWVzc2FnZSwgc2lnbmF0dXJlLCBwdWJsaWNLZXkgfSk7XG59XG4vKipcbiAqIFRPRE86IGRvY3NcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGRlcml2ZVNpZ25Jbk1lc3NhZ2UoaW5wdXQsIG91dHB1dCkge1xuICAgIGNvbnN0IHRleHQgPSBkZXJpdmVTaWduSW5NZXNzYWdlVGV4dChpbnB1dCwgb3V0cHV0KTtcbiAgICBpZiAoIXRleHQpXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIHJldHVybiBuZXcgVGV4dEVuY29kZXIoKS5lbmNvZGUodGV4dCk7XG59XG4vKipcbiAqIFRPRE86IGRvY3NcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGRlcml2ZVNpZ25Jbk1lc3NhZ2VUZXh0KGlucHV0LCBvdXRwdXQpIHtcbiAgICBjb25zdCBwYXJzZWQgPSBwYXJzZVNpZ25Jbk1lc3NhZ2Uob3V0cHV0LnNpZ25lZE1lc3NhZ2UpO1xuICAgIGlmICghcGFyc2VkKVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICBpZiAoaW5wdXQuZG9tYWluICYmIGlucHV0LmRvbWFpbiAhPT0gcGFyc2VkLmRvbWFpbilcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgaWYgKGlucHV0LmFkZHJlc3MgJiYgaW5wdXQuYWRkcmVzcyAhPT0gcGFyc2VkLmFkZHJlc3MpXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIGlmIChpbnB1dC5zdGF0ZW1lbnQgIT09IHBhcnNlZC5zdGF0ZW1lbnQpXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIGlmIChpbnB1dC51cmkgIT09IHBhcnNlZC51cmkpXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIGlmIChpbnB1dC52ZXJzaW9uICE9PSBwYXJzZWQudmVyc2lvbilcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgaWYgKGlucHV0LmNoYWluSWQgIT09IHBhcnNlZC5jaGFpbklkKVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICBpZiAoaW5wdXQubm9uY2UgIT09IHBhcnNlZC5ub25jZSlcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgaWYgKGlucHV0Lmlzc3VlZEF0ICE9PSBwYXJzZWQuaXNzdWVkQXQpXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIGlmIChpbnB1dC5leHBpcmF0aW9uVGltZSAhPT0gcGFyc2VkLmV4cGlyYXRpb25UaW1lKVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICBpZiAoaW5wdXQubm90QmVmb3JlICE9PSBwYXJzZWQubm90QmVmb3JlKVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICBpZiAoaW5wdXQucmVxdWVzdElkICE9PSBwYXJzZWQucmVxdWVzdElkKVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICBpZiAoaW5wdXQucmVzb3VyY2VzKSB7XG4gICAgICAgIGlmICghcGFyc2VkLnJlc291cmNlcylcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICBpZiAoIWFycmF5c0VxdWFsKGlucHV0LnJlc291cmNlcywgcGFyc2VkLnJlc291cmNlcykpXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgZWxzZSBpZiAocGFyc2VkLnJlc291cmNlcylcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgcmV0dXJuIGNyZWF0ZVNpZ25Jbk1lc3NhZ2VUZXh0KHBhcnNlZCk7XG59XG4vKipcbiAqIFRPRE86IGRvY3NcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHBhcnNlU2lnbkluTWVzc2FnZShtZXNzYWdlKSB7XG4gICAgY29uc3QgdGV4dCA9IG5ldyBUZXh0RGVjb2RlcigpLmRlY29kZShtZXNzYWdlKTtcbiAgICByZXR1cm4gcGFyc2VTaWduSW5NZXNzYWdlVGV4dCh0ZXh0KTtcbn1cbi8vIFRPRE86IGltcGxlbWVudCBodHRwczovL2dpdGh1Yi5jb20vc29sYW5hLWxhYnMvc29sYW5hL2Jsb2IvbWFzdGVyL2RvY3Mvc3JjL3Byb3Bvc2Fscy9vZmYtY2hhaW4tbWVzc2FnZS1zaWduaW5nLm1kXG5jb25zdCBET01BSU4gPSAnKD88ZG9tYWluPlteXFxcXG5dKz8pIHdhbnRzIHlvdSB0byBzaWduIGluIHdpdGggeW91ciBTb2xhbmEgYWNjb3VudDpcXFxcbic7XG5jb25zdCBBRERSRVNTID0gJyg/PGFkZHJlc3M+W15cXFxcbl0rKSg/OlxcXFxufCQpJztcbmNvbnN0IFNUQVRFTUVOVCA9ICcoPzpcXFxcbig/PHN0YXRlbWVudD5bXFxcXFNcXFxcc10qPykoPzpcXFxcbnwkKSk/Pyc7XG5jb25zdCBVUkkgPSAnKD86XFxcXG5VUkk6ICg/PHVyaT5bXlxcXFxuXSspKT8nO1xuY29uc3QgVkVSU0lPTiA9ICcoPzpcXFxcblZlcnNpb246ICg/PHZlcnNpb24+W15cXFxcbl0rKSk/JztcbmNvbnN0IENIQUlOX0lEID0gJyg/OlxcXFxuQ2hhaW4gSUQ6ICg/PGNoYWluSWQ+W15cXFxcbl0rKSk/JztcbmNvbnN0IE5PTkNFID0gJyg/OlxcXFxuTm9uY2U6ICg/PG5vbmNlPlteXFxcXG5dKykpPyc7XG5jb25zdCBJU1NVRURfQVQgPSAnKD86XFxcXG5Jc3N1ZWQgQXQ6ICg/PGlzc3VlZEF0PlteXFxcXG5dKykpPyc7XG5jb25zdCBFWFBJUkFUSU9OX1RJTUUgPSAnKD86XFxcXG5FeHBpcmF0aW9uIFRpbWU6ICg/PGV4cGlyYXRpb25UaW1lPlteXFxcXG5dKykpPyc7XG5jb25zdCBOT1RfQkVGT1JFID0gJyg/OlxcXFxuTm90IEJlZm9yZTogKD88bm90QmVmb3JlPlteXFxcXG5dKykpPyc7XG5jb25zdCBSRVFVRVNUX0lEID0gJyg/OlxcXFxuUmVxdWVzdCBJRDogKD88cmVxdWVzdElkPlteXFxcXG5dKykpPyc7XG5jb25zdCBSRVNPVVJDRVMgPSAnKD86XFxcXG5SZXNvdXJjZXM6KD88cmVzb3VyY2VzPig/OlxcXFxuLSBbXlxcXFxuXSspKikpPyc7XG5jb25zdCBGSUVMRFMgPSBgJHtVUkl9JHtWRVJTSU9OfSR7Q0hBSU5fSUR9JHtOT05DRX0ke0lTU1VFRF9BVH0ke0VYUElSQVRJT05fVElNRX0ke05PVF9CRUZPUkV9JHtSRVFVRVNUX0lEfSR7UkVTT1VSQ0VTfWA7XG5jb25zdCBNRVNTQUdFID0gbmV3IFJlZ0V4cChgXiR7RE9NQUlOfSR7QUREUkVTU30ke1NUQVRFTUVOVH0ke0ZJRUxEU31cXFxcbiokYCk7XG4vKipcbiAqIFRPRE86IGRvY3NcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHBhcnNlU2lnbkluTWVzc2FnZVRleHQodGV4dCkge1xuICAgIGNvbnN0IG1hdGNoID0gTUVTU0FHRS5leGVjKHRleHQpO1xuICAgIGlmICghbWF0Y2gpXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIGNvbnN0IGdyb3VwcyA9IG1hdGNoLmdyb3VwcztcbiAgICBpZiAoIWdyb3VwcylcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1ub24tbnVsbC1hc3NlcnRpb25cbiAgICAgICAgZG9tYWluOiBncm91cHMuZG9tYWluLFxuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLW5vbi1udWxsLWFzc2VydGlvblxuICAgICAgICBhZGRyZXNzOiBncm91cHMuYWRkcmVzcyxcbiAgICAgICAgc3RhdGVtZW50OiBncm91cHMuc3RhdGVtZW50LFxuICAgICAgICB1cmk6IGdyb3Vwcy51cmksXG4gICAgICAgIHZlcnNpb246IGdyb3Vwcy52ZXJzaW9uLFxuICAgICAgICBub25jZTogZ3JvdXBzLm5vbmNlLFxuICAgICAgICBjaGFpbklkOiBncm91cHMuY2hhaW5JZCxcbiAgICAgICAgaXNzdWVkQXQ6IGdyb3Vwcy5pc3N1ZWRBdCxcbiAgICAgICAgZXhwaXJhdGlvblRpbWU6IGdyb3Vwcy5leHBpcmF0aW9uVGltZSxcbiAgICAgICAgbm90QmVmb3JlOiBncm91cHMubm90QmVmb3JlLFxuICAgICAgICByZXF1ZXN0SWQ6IGdyb3Vwcy5yZXF1ZXN0SWQsXG4gICAgICAgIHJlc291cmNlczogZ3JvdXBzLnJlc291cmNlcz8uc3BsaXQoJ1xcbi0gJykuc2xpY2UoMSksXG4gICAgfTtcbn1cbi8qKlxuICogVE9ETzogZG9jc1xuICovXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlU2lnbkluTWVzc2FnZShpbnB1dCkge1xuICAgIGNvbnN0IHRleHQgPSBjcmVhdGVTaWduSW5NZXNzYWdlVGV4dChpbnB1dCk7XG4gICAgcmV0dXJuIG5ldyBUZXh0RW5jb2RlcigpLmVuY29kZSh0ZXh0KTtcbn1cbi8qKlxuICogVE9ETzogZG9jc1xuICovXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlU2lnbkluTWVzc2FnZVRleHQoaW5wdXQpIHtcbiAgICAvLyAke2RvbWFpbn0gd2FudHMgeW91IHRvIHNpZ24gaW4gd2l0aCB5b3VyIFNvbGFuYSBhY2NvdW50OlxuICAgIC8vICR7YWRkcmVzc31cbiAgICAvL1xuICAgIC8vICR7c3RhdGVtZW50fVxuICAgIC8vXG4gICAgLy8gVVJJOiAke3VyaX1cbiAgICAvLyBWZXJzaW9uOiAke3ZlcnNpb259XG4gICAgLy8gQ2hhaW4gSUQ6ICR7Y2hhaW59XG4gICAgLy8gTm9uY2U6ICR7bm9uY2V9XG4gICAgLy8gSXNzdWVkIEF0OiAke2lzc3VlZC1hdH1cbiAgICAvLyBFeHBpcmF0aW9uIFRpbWU6ICR7ZXhwaXJhdGlvbi10aW1lfVxuICAgIC8vIE5vdCBCZWZvcmU6ICR7bm90LWJlZm9yZX1cbiAgICAvLyBSZXF1ZXN0IElEOiAke3JlcXVlc3QtaWR9XG4gICAgLy8gUmVzb3VyY2VzOlxuICAgIC8vIC0gJHtyZXNvdXJjZXNbMF19XG4gICAgLy8gLSAke3Jlc291cmNlc1sxXX1cbiAgICAvLyAuLi5cbiAgICAvLyAtICR7cmVzb3VyY2VzW25dfVxuICAgIGxldCBtZXNzYWdlID0gYCR7aW5wdXQuZG9tYWlufSB3YW50cyB5b3UgdG8gc2lnbiBpbiB3aXRoIHlvdXIgU29sYW5hIGFjY291bnQ6XFxuYDtcbiAgICBtZXNzYWdlICs9IGAke2lucHV0LmFkZHJlc3N9YDtcbiAgICBpZiAoaW5wdXQuc3RhdGVtZW50KSB7XG4gICAgICAgIG1lc3NhZ2UgKz0gYFxcblxcbiR7aW5wdXQuc3RhdGVtZW50fWA7XG4gICAgfVxuICAgIGNvbnN0IGZpZWxkcyA9IFtdO1xuICAgIGlmIChpbnB1dC51cmkpIHtcbiAgICAgICAgZmllbGRzLnB1c2goYFVSSTogJHtpbnB1dC51cml9YCk7XG4gICAgfVxuICAgIGlmIChpbnB1dC52ZXJzaW9uKSB7XG4gICAgICAgIGZpZWxkcy5wdXNoKGBWZXJzaW9uOiAke2lucHV0LnZlcnNpb259YCk7XG4gICAgfVxuICAgIGlmIChpbnB1dC5jaGFpbklkKSB7XG4gICAgICAgIGZpZWxkcy5wdXNoKGBDaGFpbiBJRDogJHtpbnB1dC5jaGFpbklkfWApO1xuICAgIH1cbiAgICBpZiAoaW5wdXQubm9uY2UpIHtcbiAgICAgICAgZmllbGRzLnB1c2goYE5vbmNlOiAke2lucHV0Lm5vbmNlfWApO1xuICAgIH1cbiAgICBpZiAoaW5wdXQuaXNzdWVkQXQpIHtcbiAgICAgICAgZmllbGRzLnB1c2goYElzc3VlZCBBdDogJHtpbnB1dC5pc3N1ZWRBdH1gKTtcbiAgICB9XG4gICAgaWYgKGlucHV0LmV4cGlyYXRpb25UaW1lKSB7XG4gICAgICAgIGZpZWxkcy5wdXNoKGBFeHBpcmF0aW9uIFRpbWU6ICR7aW5wdXQuZXhwaXJhdGlvblRpbWV9YCk7XG4gICAgfVxuICAgIGlmIChpbnB1dC5ub3RCZWZvcmUpIHtcbiAgICAgICAgZmllbGRzLnB1c2goYE5vdCBCZWZvcmU6ICR7aW5wdXQubm90QmVmb3JlfWApO1xuICAgIH1cbiAgICBpZiAoaW5wdXQucmVxdWVzdElkKSB7XG4gICAgICAgIGZpZWxkcy5wdXNoKGBSZXF1ZXN0IElEOiAke2lucHV0LnJlcXVlc3RJZH1gKTtcbiAgICB9XG4gICAgaWYgKGlucHV0LnJlc291cmNlcykge1xuICAgICAgICBmaWVsZHMucHVzaChgUmVzb3VyY2VzOmApO1xuICAgICAgICBmb3IgKGNvbnN0IHJlc291cmNlIG9mIGlucHV0LnJlc291cmNlcykge1xuICAgICAgICAgICAgZmllbGRzLnB1c2goYC0gJHtyZXNvdXJjZX1gKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoZmllbGRzLmxlbmd0aCkge1xuICAgICAgICBtZXNzYWdlICs9IGBcXG5cXG4ke2ZpZWxkcy5qb2luKCdcXG4nKX1gO1xuICAgIH1cbiAgICByZXR1cm4gbWVzc2FnZTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXNpZ25Jbi5qcy5tYXAiXSwibmFtZXMiOlsidmVyaWZ5TWVzc2FnZVNpZ25hdHVyZSIsImFycmF5c0VxdWFsIiwidmVyaWZ5U2lnbkluIiwiaW5wdXQiLCJvdXRwdXQiLCJzaWduZWRNZXNzYWdlIiwic2lnbmF0dXJlIiwiYWNjb3VudCIsInB1YmxpY0tleSIsIm1lc3NhZ2UiLCJkZXJpdmVTaWduSW5NZXNzYWdlIiwidGV4dCIsImRlcml2ZVNpZ25Jbk1lc3NhZ2VUZXh0IiwiVGV4dEVuY29kZXIiLCJlbmNvZGUiLCJwYXJzZWQiLCJwYXJzZVNpZ25Jbk1lc3NhZ2UiLCJkb21haW4iLCJhZGRyZXNzIiwic3RhdGVtZW50IiwidXJpIiwidmVyc2lvbiIsImNoYWluSWQiLCJub25jZSIsImlzc3VlZEF0IiwiZXhwaXJhdGlvblRpbWUiLCJub3RCZWZvcmUiLCJyZXF1ZXN0SWQiLCJyZXNvdXJjZXMiLCJjcmVhdGVTaWduSW5NZXNzYWdlVGV4dCIsIlRleHREZWNvZGVyIiwiZGVjb2RlIiwicGFyc2VTaWduSW5NZXNzYWdlVGV4dCIsIkRPTUFJTiIsIkFERFJFU1MiLCJTVEFURU1FTlQiLCJVUkkiLCJWRVJTSU9OIiwiQ0hBSU5fSUQiLCJOT05DRSIsIklTU1VFRF9BVCIsIkVYUElSQVRJT05fVElNRSIsIk5PVF9CRUZPUkUiLCJSRVFVRVNUX0lEIiwiUkVTT1VSQ0VTIiwiRklFTERTIiwiTUVTU0FHRSIsIlJlZ0V4cCIsIm1hdGNoIiwiZXhlYyIsImdyb3VwcyIsInNwbGl0Iiwic2xpY2UiLCJjcmVhdGVTaWduSW5NZXNzYWdlIiwiZmllbGRzIiwicHVzaCIsInJlc291cmNlIiwibGVuZ3RoIiwiam9pbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/@solana/wallet-standard-util/lib/esm/signIn.js\n");

/***/ }),

/***/ "(ssr)/../node_modules/@solana/wallet-standard-util/lib/esm/signMessage.js":
/*!***************************************************************************!*\
  !*** ../node_modules/@solana/wallet-standard-util/lib/esm/signMessage.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   verifyMessageSignature: () => (/* binding */ verifyMessageSignature),\n/* harmony export */   verifySignMessage: () => (/* binding */ verifySignMessage)\n/* harmony export */ });\n/* harmony import */ var _noble_curves_ed25519__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @noble/curves/ed25519 */ \"(ssr)/../node_modules/@noble/curves/esm/ed25519.js\");\n/* harmony import */ var _util_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./util.js */ \"(ssr)/../node_modules/@solana/wallet-standard-util/lib/esm/util.js\");\n\n\n/**\n * TODO: docs\n */ function verifyMessageSignature({ message, signedMessage, signature, publicKey }) {\n    // TODO: implement https://github.com/solana-labs/solana/blob/master/docs/src/proposals/off-chain-message-signing.md\n    return (0,_util_js__WEBPACK_IMPORTED_MODULE_0__.bytesEqual)(message, signedMessage) && _noble_curves_ed25519__WEBPACK_IMPORTED_MODULE_1__.ed25519.verify(signature, signedMessage, publicKey);\n}\n/**\n * TODO: docs\n */ function verifySignMessage(input, output) {\n    const { message, account: { publicKey } } = input;\n    const { signedMessage, signature } = output;\n    return verifyMessageSignature({\n        message,\n        signedMessage,\n        signature,\n        publicKey\n    });\n} //# sourceMappingURL=signMessage.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL0Bzb2xhbmEvd2FsbGV0LXN0YW5kYXJkLXV0aWwvbGliL2VzbS9zaWduTWVzc2FnZS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQWdEO0FBQ1Q7QUFDdkM7O0NBRUMsR0FDTSxTQUFTRSx1QkFBdUIsRUFBRUMsT0FBTyxFQUFFQyxhQUFhLEVBQUVDLFNBQVMsRUFBRUMsU0FBUyxFQUFHO0lBQ3BGLG9IQUFvSDtJQUNwSCxPQUFPTCxvREFBVUEsQ0FBQ0UsU0FBU0Msa0JBQWtCSiwwREFBT0EsQ0FBQ08sTUFBTSxDQUFDRixXQUFXRCxlQUFlRTtBQUMxRjtBQUNBOztDQUVDLEdBQ00sU0FBU0Usa0JBQWtCQyxLQUFLLEVBQUVDLE1BQU07SUFDM0MsTUFBTSxFQUFFUCxPQUFPLEVBQUVRLFNBQVMsRUFBRUwsU0FBUyxFQUFFLEVBQUcsR0FBR0c7SUFDN0MsTUFBTSxFQUFFTCxhQUFhLEVBQUVDLFNBQVMsRUFBRSxHQUFHSztJQUNyQyxPQUFPUix1QkFBdUI7UUFBRUM7UUFBU0M7UUFBZUM7UUFBV0M7SUFBVTtBQUNqRixFQUNBLHVDQUF1QyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvQHNvbGFuYS93YWxsZXQtc3RhbmRhcmQtdXRpbC9saWIvZXNtL3NpZ25NZXNzYWdlLmpzP2FhMjciXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgZWQyNTUxOSB9IGZyb20gJ0Bub2JsZS9jdXJ2ZXMvZWQyNTUxOSc7XG5pbXBvcnQgeyBieXRlc0VxdWFsIH0gZnJvbSAnLi91dGlsLmpzJztcbi8qKlxuICogVE9ETzogZG9jc1xuICovXG5leHBvcnQgZnVuY3Rpb24gdmVyaWZ5TWVzc2FnZVNpZ25hdHVyZSh7IG1lc3NhZ2UsIHNpZ25lZE1lc3NhZ2UsIHNpZ25hdHVyZSwgcHVibGljS2V5LCB9KSB7XG4gICAgLy8gVE9ETzogaW1wbGVtZW50IGh0dHBzOi8vZ2l0aHViLmNvbS9zb2xhbmEtbGFicy9zb2xhbmEvYmxvYi9tYXN0ZXIvZG9jcy9zcmMvcHJvcG9zYWxzL29mZi1jaGFpbi1tZXNzYWdlLXNpZ25pbmcubWRcbiAgICByZXR1cm4gYnl0ZXNFcXVhbChtZXNzYWdlLCBzaWduZWRNZXNzYWdlKSAmJiBlZDI1NTE5LnZlcmlmeShzaWduYXR1cmUsIHNpZ25lZE1lc3NhZ2UsIHB1YmxpY0tleSk7XG59XG4vKipcbiAqIFRPRE86IGRvY3NcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHZlcmlmeVNpZ25NZXNzYWdlKGlucHV0LCBvdXRwdXQpIHtcbiAgICBjb25zdCB7IG1lc3NhZ2UsIGFjY291bnQ6IHsgcHVibGljS2V5IH0sIH0gPSBpbnB1dDtcbiAgICBjb25zdCB7IHNpZ25lZE1lc3NhZ2UsIHNpZ25hdHVyZSB9ID0gb3V0cHV0O1xuICAgIHJldHVybiB2ZXJpZnlNZXNzYWdlU2lnbmF0dXJlKHsgbWVzc2FnZSwgc2lnbmVkTWVzc2FnZSwgc2lnbmF0dXJlLCBwdWJsaWNLZXkgfSk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zaWduTWVzc2FnZS5qcy5tYXAiXSwibmFtZXMiOlsiZWQyNTUxOSIsImJ5dGVzRXF1YWwiLCJ2ZXJpZnlNZXNzYWdlU2lnbmF0dXJlIiwibWVzc2FnZSIsInNpZ25lZE1lc3NhZ2UiLCJzaWduYXR1cmUiLCJwdWJsaWNLZXkiLCJ2ZXJpZnkiLCJ2ZXJpZnlTaWduTWVzc2FnZSIsImlucHV0Iiwib3V0cHV0IiwiYWNjb3VudCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/@solana/wallet-standard-util/lib/esm/signMessage.js\n");

/***/ }),

/***/ "(ssr)/../node_modules/@solana/wallet-standard-util/lib/esm/util.js":
/*!********************************************************************!*\
  !*** ../node_modules/@solana/wallet-standard-util/lib/esm/util.js ***!
  \********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   arraysEqual: () => (/* binding */ arraysEqual),\n/* harmony export */   bytesEqual: () => (/* binding */ bytesEqual)\n/* harmony export */ });\n/**\n * @internal\n *\n * Efficiently compare {@link Indexed} arrays (e.g. `Array` and `Uint8Array`).\n *\n * @param a An array.\n * @param b Another array.\n *\n * @return `true` if the arrays have the same length and elements, `false` otherwise.\n *\n * @group Internal\n */ function arraysEqual(a, b) {\n    if (a === b) return true;\n    const length = a.length;\n    if (length !== b.length) return false;\n    for(let i = 0; i < length; i++){\n        if (a[i] !== b[i]) return false;\n    }\n    return true;\n}\n/**\n * @internal\n *\n * Efficiently compare byte arrays, using {@link arraysEqual}.\n *\n * @param a A byte array.\n * @param b Another byte array.\n *\n * @return `true` if the byte arrays have the same length and bytes, `false` otherwise.\n *\n * @group Internal\n */ function bytesEqual(a, b) {\n    return arraysEqual(a, b);\n} //# sourceMappingURL=util.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL0Bzb2xhbmEvd2FsbGV0LXN0YW5kYXJkLXV0aWwvbGliL2VzbS91dGlsLmpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQUE7Ozs7Ozs7Ozs7O0NBV0MsR0FDTSxTQUFTQSxZQUFZQyxDQUFDLEVBQUVDLENBQUM7SUFDNUIsSUFBSUQsTUFBTUMsR0FDTixPQUFPO0lBQ1gsTUFBTUMsU0FBU0YsRUFBRUUsTUFBTTtJQUN2QixJQUFJQSxXQUFXRCxFQUFFQyxNQUFNLEVBQ25CLE9BQU87SUFDWCxJQUFLLElBQUlDLElBQUksR0FBR0EsSUFBSUQsUUFBUUMsSUFBSztRQUM3QixJQUFJSCxDQUFDLENBQUNHLEVBQUUsS0FBS0YsQ0FBQyxDQUFDRSxFQUFFLEVBQ2IsT0FBTztJQUNmO0lBQ0EsT0FBTztBQUNYO0FBQ0E7Ozs7Ozs7Ozs7O0NBV0MsR0FDTSxTQUFTQyxXQUFXSixDQUFDLEVBQUVDLENBQUM7SUFDM0IsT0FBT0YsWUFBWUMsR0FBR0M7QUFDMUIsRUFDQSxnQ0FBZ0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL0Bzb2xhbmEvd2FsbGV0LXN0YW5kYXJkLXV0aWwvbGliL2VzbS91dGlsLmpzPzA1MDQiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAaW50ZXJuYWxcbiAqXG4gKiBFZmZpY2llbnRseSBjb21wYXJlIHtAbGluayBJbmRleGVkfSBhcnJheXMgKGUuZy4gYEFycmF5YCBhbmQgYFVpbnQ4QXJyYXlgKS5cbiAqXG4gKiBAcGFyYW0gYSBBbiBhcnJheS5cbiAqIEBwYXJhbSBiIEFub3RoZXIgYXJyYXkuXG4gKlxuICogQHJldHVybiBgdHJ1ZWAgaWYgdGhlIGFycmF5cyBoYXZlIHRoZSBzYW1lIGxlbmd0aCBhbmQgZWxlbWVudHMsIGBmYWxzZWAgb3RoZXJ3aXNlLlxuICpcbiAqIEBncm91cCBJbnRlcm5hbFxuICovXG5leHBvcnQgZnVuY3Rpb24gYXJyYXlzRXF1YWwoYSwgYikge1xuICAgIGlmIChhID09PSBiKVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICBjb25zdCBsZW5ndGggPSBhLmxlbmd0aDtcbiAgICBpZiAobGVuZ3RoICE9PSBiLmxlbmd0aClcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKGFbaV0gIT09IGJbaV0pXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xufVxuLyoqXG4gKiBAaW50ZXJuYWxcbiAqXG4gKiBFZmZpY2llbnRseSBjb21wYXJlIGJ5dGUgYXJyYXlzLCB1c2luZyB7QGxpbmsgYXJyYXlzRXF1YWx9LlxuICpcbiAqIEBwYXJhbSBhIEEgYnl0ZSBhcnJheS5cbiAqIEBwYXJhbSBiIEFub3RoZXIgYnl0ZSBhcnJheS5cbiAqXG4gKiBAcmV0dXJuIGB0cnVlYCBpZiB0aGUgYnl0ZSBhcnJheXMgaGF2ZSB0aGUgc2FtZSBsZW5ndGggYW5kIGJ5dGVzLCBgZmFsc2VgIG90aGVyd2lzZS5cbiAqXG4gKiBAZ3JvdXAgSW50ZXJuYWxcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGJ5dGVzRXF1YWwoYSwgYikge1xuICAgIHJldHVybiBhcnJheXNFcXVhbChhLCBiKTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXV0aWwuanMubWFwIl0sIm5hbWVzIjpbImFycmF5c0VxdWFsIiwiYSIsImIiLCJsZW5ndGgiLCJpIiwiYnl0ZXNFcXVhbCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/@solana/wallet-standard-util/lib/esm/util.js\n");

/***/ }),

/***/ "(ssr)/../node_modules/@solana/wallet-standard-wallet-adapter-base/lib/esm/adapter.js":
/*!**************************************************************************************!*\
  !*** ../node_modules/@solana/wallet-standard-wallet-adapter-base/lib/esm/adapter.js ***!
  \**************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   StandardWalletAdapter: () => (/* binding */ StandardWalletAdapter)\n/* harmony export */ });\n/* harmony import */ var _solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @solana/wallet-adapter-base */ \"(ssr)/../node_modules/@solana/wallet-adapter-base/lib/esm/adapter.js\");\n/* harmony import */ var _solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @solana/wallet-adapter-base */ \"(ssr)/../node_modules/@solana/wallet-adapter-base/lib/esm/errors.js\");\n/* harmony import */ var _solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! @solana/wallet-adapter-base */ \"(ssr)/../node_modules/@solana/wallet-adapter-base/lib/esm/transaction.js\");\n/* harmony import */ var _solana_wallet_standard_features__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @solana/wallet-standard-features */ \"(ssr)/../node_modules/@solana/wallet-standard-features/lib/esm/signAndSendTransaction.js\");\n/* harmony import */ var _solana_wallet_standard_features__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @solana/wallet-standard-features */ \"(ssr)/../node_modules/@solana/wallet-standard-features/lib/esm/signTransaction.js\");\n/* harmony import */ var _solana_wallet_standard_features__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! @solana/wallet-standard-features */ \"(ssr)/../node_modules/@solana/wallet-standard-features/lib/esm/signMessage.js\");\n/* harmony import */ var _solana_wallet_standard_features__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! @solana/wallet-standard-features */ \"(ssr)/../node_modules/@solana/wallet-standard-features/lib/esm/signIn.js\");\n/* harmony import */ var _solana_wallet_standard_util__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! @solana/wallet-standard-util */ \"(ssr)/../node_modules/@solana/wallet-standard-util/lib/esm/endpoint.js\");\n/* harmony import */ var _solana_wallet_standard_util__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! @solana/wallet-standard-util */ \"(ssr)/../node_modules/@solana/wallet-standard-util/lib/esm/commitment.js\");\n/* harmony import */ var _solana_web3_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @solana/web3.js */ \"(ssr)/../node_modules/@solana/web3.js/lib/index.esm.js\");\n/* harmony import */ var _wallet_standard_features__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @wallet-standard/features */ \"(ssr)/../node_modules/@wallet-standard/features/lib/esm/events.js\");\n/* harmony import */ var _wallet_standard_features__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @wallet-standard/features */ \"(ssr)/../node_modules/@wallet-standard/features/lib/esm/disconnect.js\");\n/* harmony import */ var _wallet_standard_features__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! @wallet-standard/features */ \"(ssr)/../node_modules/@wallet-standard/features/lib/esm/connect.js\");\n/* harmony import */ var _wallet_standard_wallet__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! @wallet-standard/wallet */ \"(ssr)/../node_modules/@wallet-standard/wallet/lib/esm/util.js\");\n/* harmony import */ var bs58__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! bs58 */ \"(ssr)/../node_modules/bs58/index.js\");\nvar __classPrivateFieldSet = undefined && undefined.__classPrivateFieldSet || function(receiver, state, value, kind, f) {\n    if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a setter\");\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\n    return kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;\n};\nvar __classPrivateFieldGet = undefined && undefined.__classPrivateFieldGet || function(receiver, state, kind, f) {\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\n    return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\n};\nvar _StandardWalletAdapter_instances, _StandardWalletAdapter_account, _StandardWalletAdapter_publicKey, _StandardWalletAdapter_connecting, _StandardWalletAdapter_disconnecting, _StandardWalletAdapter_off, _StandardWalletAdapter_supportedTransactionVersions, _StandardWalletAdapter_wallet, _StandardWalletAdapter_readyState, _StandardWalletAdapter_connect, _StandardWalletAdapter_connected, _StandardWalletAdapter_disconnected, _StandardWalletAdapter_reset, _StandardWalletAdapter_changed, _StandardWalletAdapter_signTransaction, _StandardWalletAdapter_signAllTransactions, _StandardWalletAdapter_signMessage, _StandardWalletAdapter_signIn;\n\n\n\n\n\n\n\n/** TODO: docs */ class StandardWalletAdapter extends _solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_2__.BaseWalletAdapter {\n    constructor({ wallet }){\n        super();\n        _StandardWalletAdapter_instances.add(this);\n        _StandardWalletAdapter_account.set(this, void 0);\n        _StandardWalletAdapter_publicKey.set(this, void 0);\n        _StandardWalletAdapter_connecting.set(this, void 0);\n        _StandardWalletAdapter_disconnecting.set(this, void 0);\n        _StandardWalletAdapter_off.set(this, void 0);\n        _StandardWalletAdapter_supportedTransactionVersions.set(this, void 0);\n        _StandardWalletAdapter_wallet.set(this, void 0);\n        _StandardWalletAdapter_readyState.set(this,  true ? _solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_2__.WalletReadyState.Unsupported : 0);\n        _StandardWalletAdapter_changed.set(this, (properties)=>{\n            // If accounts have changed on the wallet, reflect this on the adapter.\n            if (\"accounts\" in properties) {\n                const account = __classPrivateFieldGet(this, _StandardWalletAdapter_wallet, \"f\").accounts[0];\n                // If the adapter isn't connected, or is disconnecting, or the first account hasn't changed, do nothing.\n                if (__classPrivateFieldGet(this, _StandardWalletAdapter_account, \"f\") && !__classPrivateFieldGet(this, _StandardWalletAdapter_disconnecting, \"f\") && account !== __classPrivateFieldGet(this, _StandardWalletAdapter_account, \"f\")) {\n                    // If there's a connected account, connect the adapter. Otherwise, disconnect it.\n                    if (account) {\n                        // Connect the adapter.\n                        __classPrivateFieldGet(this, _StandardWalletAdapter_instances, \"m\", _StandardWalletAdapter_connected).call(this, account);\n                    } else {\n                        // Emit an error because the wallet spontaneously disconnected.\n                        this.emit(\"error\", new _solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_3__.WalletDisconnectedError());\n                        // Disconnect the adapter.\n                        __classPrivateFieldGet(this, _StandardWalletAdapter_instances, \"m\", _StandardWalletAdapter_disconnected).call(this);\n                    }\n                }\n            }\n            // After reflecting account changes, if features have changed on the wallet, reflect this on the adapter.\n            if (\"features\" in properties) {\n                __classPrivateFieldGet(this, _StandardWalletAdapter_instances, \"m\", _StandardWalletAdapter_reset).call(this);\n            }\n        });\n        __classPrivateFieldSet(this, _StandardWalletAdapter_wallet, wallet, \"f\");\n        __classPrivateFieldSet(this, _StandardWalletAdapter_account, null, \"f\");\n        __classPrivateFieldSet(this, _StandardWalletAdapter_publicKey, null, \"f\");\n        __classPrivateFieldSet(this, _StandardWalletAdapter_connecting, false, \"f\");\n        __classPrivateFieldSet(this, _StandardWalletAdapter_disconnecting, false, \"f\");\n        __classPrivateFieldSet(this, _StandardWalletAdapter_off, __classPrivateFieldGet(this, _StandardWalletAdapter_wallet, \"f\").features[_wallet_standard_features__WEBPACK_IMPORTED_MODULE_4__.StandardEvents].on(\"change\", __classPrivateFieldGet(this, _StandardWalletAdapter_changed, \"f\")), \"f\");\n        __classPrivateFieldGet(this, _StandardWalletAdapter_instances, \"m\", _StandardWalletAdapter_reset).call(this);\n    }\n    get name() {\n        return __classPrivateFieldGet(this, _StandardWalletAdapter_wallet, \"f\").name;\n    }\n    get url() {\n        return \"https://github.com/solana-labs/wallet-standard\";\n    }\n    get icon() {\n        return __classPrivateFieldGet(this, _StandardWalletAdapter_wallet, \"f\").icon;\n    }\n    get readyState() {\n        return __classPrivateFieldGet(this, _StandardWalletAdapter_readyState, \"f\");\n    }\n    get publicKey() {\n        return __classPrivateFieldGet(this, _StandardWalletAdapter_publicKey, \"f\");\n    }\n    get connecting() {\n        return __classPrivateFieldGet(this, _StandardWalletAdapter_connecting, \"f\");\n    }\n    get supportedTransactionVersions() {\n        return __classPrivateFieldGet(this, _StandardWalletAdapter_supportedTransactionVersions, \"f\");\n    }\n    get wallet() {\n        return __classPrivateFieldGet(this, _StandardWalletAdapter_wallet, \"f\");\n    }\n    get standard() {\n        return true;\n    }\n    destroy() {\n        __classPrivateFieldSet(this, _StandardWalletAdapter_account, null, \"f\");\n        __classPrivateFieldSet(this, _StandardWalletAdapter_publicKey, null, \"f\");\n        __classPrivateFieldSet(this, _StandardWalletAdapter_connecting, false, \"f\");\n        __classPrivateFieldSet(this, _StandardWalletAdapter_disconnecting, false, \"f\");\n        const off = __classPrivateFieldGet(this, _StandardWalletAdapter_off, \"f\");\n        if (off) {\n            __classPrivateFieldSet(this, _StandardWalletAdapter_off, null, \"f\");\n            off();\n        }\n    }\n    async autoConnect() {\n        return __classPrivateFieldGet(this, _StandardWalletAdapter_instances, \"m\", _StandardWalletAdapter_connect).call(this, {\n            silent: true\n        });\n    }\n    async connect() {\n        return __classPrivateFieldGet(this, _StandardWalletAdapter_instances, \"m\", _StandardWalletAdapter_connect).call(this);\n    }\n    async disconnect() {\n        if (_wallet_standard_features__WEBPACK_IMPORTED_MODULE_5__.StandardDisconnect in __classPrivateFieldGet(this, _StandardWalletAdapter_wallet, \"f\").features) {\n            try {\n                __classPrivateFieldSet(this, _StandardWalletAdapter_disconnecting, true, \"f\");\n                await __classPrivateFieldGet(this, _StandardWalletAdapter_wallet, \"f\").features[_wallet_standard_features__WEBPACK_IMPORTED_MODULE_5__.StandardDisconnect].disconnect();\n            } catch (error) {\n                this.emit(\"error\", new _solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_3__.WalletDisconnectionError(error?.message, error));\n            } finally{\n                __classPrivateFieldSet(this, _StandardWalletAdapter_disconnecting, false, \"f\");\n            }\n        }\n        __classPrivateFieldGet(this, _StandardWalletAdapter_instances, \"m\", _StandardWalletAdapter_disconnected).call(this);\n    }\n    async sendTransaction(transaction, connection, options = {}) {\n        try {\n            const account = __classPrivateFieldGet(this, _StandardWalletAdapter_account, \"f\");\n            if (!account) throw new _solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_3__.WalletNotConnectedError();\n            let feature;\n            if (_solana_wallet_standard_features__WEBPACK_IMPORTED_MODULE_6__.SolanaSignAndSendTransaction in __classPrivateFieldGet(this, _StandardWalletAdapter_wallet, \"f\").features) {\n                if (account.features.includes(_solana_wallet_standard_features__WEBPACK_IMPORTED_MODULE_6__.SolanaSignAndSendTransaction)) {\n                    feature = _solana_wallet_standard_features__WEBPACK_IMPORTED_MODULE_6__.SolanaSignAndSendTransaction;\n                } else if (_solana_wallet_standard_features__WEBPACK_IMPORTED_MODULE_7__.SolanaSignTransaction in __classPrivateFieldGet(this, _StandardWalletAdapter_wallet, \"f\").features && account.features.includes(_solana_wallet_standard_features__WEBPACK_IMPORTED_MODULE_7__.SolanaSignTransaction)) {\n                    feature = _solana_wallet_standard_features__WEBPACK_IMPORTED_MODULE_7__.SolanaSignTransaction;\n                } else {\n                    throw new _solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_3__.WalletAccountError();\n                }\n            } else if (_solana_wallet_standard_features__WEBPACK_IMPORTED_MODULE_7__.SolanaSignTransaction in __classPrivateFieldGet(this, _StandardWalletAdapter_wallet, \"f\").features) {\n                if (!account.features.includes(_solana_wallet_standard_features__WEBPACK_IMPORTED_MODULE_7__.SolanaSignTransaction)) throw new _solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_3__.WalletAccountError();\n                feature = _solana_wallet_standard_features__WEBPACK_IMPORTED_MODULE_7__.SolanaSignTransaction;\n            } else {\n                throw new _solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_3__.WalletConfigError();\n            }\n            const chain = (0,_solana_wallet_standard_util__WEBPACK_IMPORTED_MODULE_8__.getChainForEndpoint)(connection.rpcEndpoint);\n            if (!account.chains.includes(chain)) throw new _solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_3__.WalletSendTransactionError();\n            try {\n                const { signers, ...sendOptions } = options;\n                let serializedTransaction;\n                if ((0,_solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_9__.isVersionedTransaction)(transaction)) {\n                    signers?.length && transaction.sign(signers);\n                    serializedTransaction = transaction.serialize();\n                } else {\n                    transaction = await this.prepareTransaction(transaction, connection, sendOptions);\n                    signers?.length && transaction.partialSign(...signers);\n                    serializedTransaction = new Uint8Array(transaction.serialize({\n                        requireAllSignatures: false,\n                        verifySignatures: false\n                    }));\n                }\n                if (feature === _solana_wallet_standard_features__WEBPACK_IMPORTED_MODULE_6__.SolanaSignAndSendTransaction) {\n                    const [output] = await __classPrivateFieldGet(this, _StandardWalletAdapter_wallet, \"f\").features[_solana_wallet_standard_features__WEBPACK_IMPORTED_MODULE_6__.SolanaSignAndSendTransaction].signAndSendTransaction({\n                        account,\n                        chain,\n                        transaction: serializedTransaction,\n                        options: {\n                            preflightCommitment: (0,_solana_wallet_standard_util__WEBPACK_IMPORTED_MODULE_10__.getCommitment)(sendOptions.preflightCommitment || connection.commitment),\n                            skipPreflight: sendOptions.skipPreflight,\n                            maxRetries: sendOptions.maxRetries,\n                            minContextSlot: sendOptions.minContextSlot\n                        }\n                    });\n                    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n                    return bs58__WEBPACK_IMPORTED_MODULE_1__.encode(output.signature);\n                } else {\n                    const [output] = await __classPrivateFieldGet(this, _StandardWalletAdapter_wallet, \"f\").features[_solana_wallet_standard_features__WEBPACK_IMPORTED_MODULE_7__.SolanaSignTransaction].signTransaction({\n                        account,\n                        chain,\n                        transaction: serializedTransaction,\n                        options: {\n                            preflightCommitment: (0,_solana_wallet_standard_util__WEBPACK_IMPORTED_MODULE_10__.getCommitment)(sendOptions.preflightCommitment || connection.commitment),\n                            minContextSlot: sendOptions.minContextSlot\n                        }\n                    });\n                    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n                    return await connection.sendRawTransaction(output.signedTransaction, {\n                        ...sendOptions,\n                        preflightCommitment: (0,_solana_wallet_standard_util__WEBPACK_IMPORTED_MODULE_10__.getCommitment)(sendOptions.preflightCommitment || connection.commitment)\n                    });\n                }\n            } catch (error) {\n                if (error instanceof _solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_3__.WalletError) throw error;\n                throw new _solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_3__.WalletSendTransactionError(error?.message, error);\n            }\n        } catch (error) {\n            this.emit(\"error\", error);\n            throw error;\n        }\n    }\n}\n_StandardWalletAdapter_account = new WeakMap(), _StandardWalletAdapter_publicKey = new WeakMap(), _StandardWalletAdapter_connecting = new WeakMap(), _StandardWalletAdapter_disconnecting = new WeakMap(), _StandardWalletAdapter_off = new WeakMap(), _StandardWalletAdapter_supportedTransactionVersions = new WeakMap(), _StandardWalletAdapter_wallet = new WeakMap(), _StandardWalletAdapter_readyState = new WeakMap(), _StandardWalletAdapter_changed = new WeakMap(), _StandardWalletAdapter_instances = new WeakSet(), _StandardWalletAdapter_connect = async function _StandardWalletAdapter_connect(input) {\n    try {\n        if (this.connected || this.connecting) return;\n        if (__classPrivateFieldGet(this, _StandardWalletAdapter_readyState, \"f\") !== _solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_2__.WalletReadyState.Installed) throw new _solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_3__.WalletNotReadyError();\n        __classPrivateFieldSet(this, _StandardWalletAdapter_connecting, true, \"f\");\n        if (!__classPrivateFieldGet(this, _StandardWalletAdapter_wallet, \"f\").accounts.length) {\n            try {\n                await __classPrivateFieldGet(this, _StandardWalletAdapter_wallet, \"f\").features[_wallet_standard_features__WEBPACK_IMPORTED_MODULE_11__.StandardConnect].connect(input);\n            } catch (error) {\n                throw new _solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_3__.WalletConnectionError(error?.message, error);\n            }\n        }\n        const account = __classPrivateFieldGet(this, _StandardWalletAdapter_wallet, \"f\").accounts[0];\n        if (!account) throw new _solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_3__.WalletAccountError();\n        __classPrivateFieldGet(this, _StandardWalletAdapter_instances, \"m\", _StandardWalletAdapter_connected).call(this, account);\n    } catch (error) {\n        this.emit(\"error\", error);\n        throw error;\n    } finally{\n        __classPrivateFieldSet(this, _StandardWalletAdapter_connecting, false, \"f\");\n    }\n}, _StandardWalletAdapter_connected = function _StandardWalletAdapter_connected(account) {\n    let publicKey;\n    try {\n        // Use account.address instead of account.publicKey since address could be a PDA\n        publicKey = new _solana_web3_js__WEBPACK_IMPORTED_MODULE_0__.PublicKey(account.address);\n    } catch (error) {\n        throw new _solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_3__.WalletPublicKeyError(error?.message, error);\n    }\n    __classPrivateFieldSet(this, _StandardWalletAdapter_account, account, \"f\");\n    __classPrivateFieldSet(this, _StandardWalletAdapter_publicKey, publicKey, \"f\");\n    __classPrivateFieldGet(this, _StandardWalletAdapter_instances, \"m\", _StandardWalletAdapter_reset).call(this);\n    this.emit(\"connect\", publicKey);\n}, _StandardWalletAdapter_disconnected = function _StandardWalletAdapter_disconnected() {\n    __classPrivateFieldSet(this, _StandardWalletAdapter_account, null, \"f\");\n    __classPrivateFieldSet(this, _StandardWalletAdapter_publicKey, null, \"f\");\n    __classPrivateFieldGet(this, _StandardWalletAdapter_instances, \"m\", _StandardWalletAdapter_reset).call(this);\n    this.emit(\"disconnect\");\n}, _StandardWalletAdapter_reset = function _StandardWalletAdapter_reset() {\n    const supportedTransactionVersions = _solana_wallet_standard_features__WEBPACK_IMPORTED_MODULE_6__.SolanaSignAndSendTransaction in __classPrivateFieldGet(this, _StandardWalletAdapter_wallet, \"f\").features ? __classPrivateFieldGet(this, _StandardWalletAdapter_wallet, \"f\").features[_solana_wallet_standard_features__WEBPACK_IMPORTED_MODULE_6__.SolanaSignAndSendTransaction].supportedTransactionVersions : __classPrivateFieldGet(this, _StandardWalletAdapter_wallet, \"f\").features[_solana_wallet_standard_features__WEBPACK_IMPORTED_MODULE_7__.SolanaSignTransaction].supportedTransactionVersions;\n    __classPrivateFieldSet(this, _StandardWalletAdapter_supportedTransactionVersions, (0,_wallet_standard_wallet__WEBPACK_IMPORTED_MODULE_12__.arraysEqual)(supportedTransactionVersions, [\n        \"legacy\"\n    ]) ? null : new Set(supportedTransactionVersions), \"f\");\n    if (_solana_wallet_standard_features__WEBPACK_IMPORTED_MODULE_7__.SolanaSignTransaction in __classPrivateFieldGet(this, _StandardWalletAdapter_wallet, \"f\").features && __classPrivateFieldGet(this, _StandardWalletAdapter_account, \"f\")?.features.includes(_solana_wallet_standard_features__WEBPACK_IMPORTED_MODULE_7__.SolanaSignTransaction)) {\n        this.signTransaction = __classPrivateFieldGet(this, _StandardWalletAdapter_instances, \"m\", _StandardWalletAdapter_signTransaction);\n        this.signAllTransactions = __classPrivateFieldGet(this, _StandardWalletAdapter_instances, \"m\", _StandardWalletAdapter_signAllTransactions);\n    } else {\n        delete this.signTransaction;\n        delete this.signAllTransactions;\n    }\n    if (_solana_wallet_standard_features__WEBPACK_IMPORTED_MODULE_13__.SolanaSignMessage in __classPrivateFieldGet(this, _StandardWalletAdapter_wallet, \"f\").features && __classPrivateFieldGet(this, _StandardWalletAdapter_account, \"f\")?.features.includes(_solana_wallet_standard_features__WEBPACK_IMPORTED_MODULE_13__.SolanaSignMessage)) {\n        this.signMessage = __classPrivateFieldGet(this, _StandardWalletAdapter_instances, \"m\", _StandardWalletAdapter_signMessage);\n    } else {\n        delete this.signMessage;\n    }\n    if (_solana_wallet_standard_features__WEBPACK_IMPORTED_MODULE_14__.SolanaSignIn in __classPrivateFieldGet(this, _StandardWalletAdapter_wallet, \"f\").features) {\n        this.signIn = __classPrivateFieldGet(this, _StandardWalletAdapter_instances, \"m\", _StandardWalletAdapter_signIn);\n    } else {\n        delete this.signIn;\n    }\n}, _StandardWalletAdapter_signTransaction = async function _StandardWalletAdapter_signTransaction(transaction) {\n    try {\n        const account = __classPrivateFieldGet(this, _StandardWalletAdapter_account, \"f\");\n        if (!account) throw new _solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_3__.WalletNotConnectedError();\n        if (!(_solana_wallet_standard_features__WEBPACK_IMPORTED_MODULE_7__.SolanaSignTransaction in __classPrivateFieldGet(this, _StandardWalletAdapter_wallet, \"f\").features)) throw new _solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_3__.WalletConfigError();\n        if (!account.features.includes(_solana_wallet_standard_features__WEBPACK_IMPORTED_MODULE_7__.SolanaSignTransaction)) throw new _solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_3__.WalletAccountError();\n        try {\n            const signedTransactions = await __classPrivateFieldGet(this, _StandardWalletAdapter_wallet, \"f\").features[_solana_wallet_standard_features__WEBPACK_IMPORTED_MODULE_7__.SolanaSignTransaction].signTransaction({\n                account,\n                transaction: (0,_solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_9__.isVersionedTransaction)(transaction) ? transaction.serialize() : new Uint8Array(transaction.serialize({\n                    requireAllSignatures: false,\n                    verifySignatures: false\n                }))\n            });\n            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n            const serializedTransaction = signedTransactions[0].signedTransaction;\n            return (0,_solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_9__.isVersionedTransaction)(transaction) ? _solana_web3_js__WEBPACK_IMPORTED_MODULE_0__.VersionedTransaction.deserialize(serializedTransaction) : _solana_web3_js__WEBPACK_IMPORTED_MODULE_0__.Transaction.from(serializedTransaction);\n        } catch (error) {\n            if (error instanceof _solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_3__.WalletError) throw error;\n            throw new _solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_3__.WalletSignTransactionError(error?.message, error);\n        }\n    } catch (error) {\n        this.emit(\"error\", error);\n        throw error;\n    }\n}, _StandardWalletAdapter_signAllTransactions = async function _StandardWalletAdapter_signAllTransactions(transactions) {\n    try {\n        const account = __classPrivateFieldGet(this, _StandardWalletAdapter_account, \"f\");\n        if (!account) throw new _solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_3__.WalletNotConnectedError();\n        if (!(_solana_wallet_standard_features__WEBPACK_IMPORTED_MODULE_7__.SolanaSignTransaction in __classPrivateFieldGet(this, _StandardWalletAdapter_wallet, \"f\").features)) throw new _solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_3__.WalletConfigError();\n        if (!account.features.includes(_solana_wallet_standard_features__WEBPACK_IMPORTED_MODULE_7__.SolanaSignTransaction)) throw new _solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_3__.WalletAccountError();\n        try {\n            const signedTransactions = await __classPrivateFieldGet(this, _StandardWalletAdapter_wallet, \"f\").features[_solana_wallet_standard_features__WEBPACK_IMPORTED_MODULE_7__.SolanaSignTransaction].signTransaction(...transactions.map((transaction)=>({\n                    account,\n                    transaction: (0,_solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_9__.isVersionedTransaction)(transaction) ? transaction.serialize() : new Uint8Array(transaction.serialize({\n                        requireAllSignatures: false,\n                        verifySignatures: false\n                    }))\n                })));\n            return transactions.map((transaction, index)=>{\n                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n                const signedTransaction = signedTransactions[index].signedTransaction;\n                return (0,_solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_9__.isVersionedTransaction)(transaction) ? _solana_web3_js__WEBPACK_IMPORTED_MODULE_0__.VersionedTransaction.deserialize(signedTransaction) : _solana_web3_js__WEBPACK_IMPORTED_MODULE_0__.Transaction.from(signedTransaction);\n            });\n        } catch (error) {\n            throw new _solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_3__.WalletSignTransactionError(error?.message, error);\n        }\n    } catch (error) {\n        this.emit(\"error\", error);\n        throw error;\n    }\n}, _StandardWalletAdapter_signMessage = async function _StandardWalletAdapter_signMessage(message) {\n    try {\n        const account = __classPrivateFieldGet(this, _StandardWalletAdapter_account, \"f\");\n        if (!account) throw new _solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_3__.WalletNotConnectedError();\n        if (!(_solana_wallet_standard_features__WEBPACK_IMPORTED_MODULE_13__.SolanaSignMessage in __classPrivateFieldGet(this, _StandardWalletAdapter_wallet, \"f\").features)) throw new _solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_3__.WalletConfigError();\n        if (!account.features.includes(_solana_wallet_standard_features__WEBPACK_IMPORTED_MODULE_13__.SolanaSignMessage)) throw new _solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_3__.WalletAccountError();\n        try {\n            const signedMessages = await __classPrivateFieldGet(this, _StandardWalletAdapter_wallet, \"f\").features[_solana_wallet_standard_features__WEBPACK_IMPORTED_MODULE_13__.SolanaSignMessage].signMessage({\n                account,\n                message\n            });\n            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n            return signedMessages[0].signature;\n        } catch (error) {\n            throw new _solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_3__.WalletSignMessageError(error?.message, error);\n        }\n    } catch (error) {\n        this.emit(\"error\", error);\n        throw error;\n    }\n}, _StandardWalletAdapter_signIn = async function _StandardWalletAdapter_signIn(input = {}) {\n    try {\n        if (!(_solana_wallet_standard_features__WEBPACK_IMPORTED_MODULE_14__.SolanaSignIn in __classPrivateFieldGet(this, _StandardWalletAdapter_wallet, \"f\").features)) throw new _solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_3__.WalletConfigError();\n        let output;\n        try {\n            [output] = await __classPrivateFieldGet(this, _StandardWalletAdapter_wallet, \"f\").features[_solana_wallet_standard_features__WEBPACK_IMPORTED_MODULE_14__.SolanaSignIn].signIn(input);\n        } catch (error) {\n            throw new _solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_3__.WalletSignInError(error?.message, error);\n        }\n        if (!output) throw new _solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_3__.WalletSignInError();\n        __classPrivateFieldGet(this, _StandardWalletAdapter_instances, \"m\", _StandardWalletAdapter_connected).call(this, output.account);\n        return output;\n    } catch (error) {\n        this.emit(\"error\", error);\n        throw error;\n    }\n}; //# sourceMappingURL=adapter.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL0Bzb2xhbmEvd2FsbGV0LXN0YW5kYXJkLXdhbGxldC1hZGFwdGVyLWJhc2UvbGliL2VzbS9hZGFwdGVyLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQSxJQUFJQSx5QkFBeUIsU0FBSyxJQUFJLFNBQUksQ0FBQ0Esc0JBQXNCLElBQUssU0FBVUMsUUFBUSxFQUFFQyxLQUFLLEVBQUVDLEtBQUssRUFBRUMsSUFBSSxFQUFFQyxDQUFDO0lBQzNHLElBQUlELFNBQVMsS0FBSyxNQUFNLElBQUlFLFVBQVU7SUFDdEMsSUFBSUYsU0FBUyxPQUFPLENBQUNDLEdBQUcsTUFBTSxJQUFJQyxVQUFVO0lBQzVDLElBQUksT0FBT0osVUFBVSxhQUFhRCxhQUFhQyxTQUFTLENBQUNHLElBQUksQ0FBQ0gsTUFBTUssR0FBRyxDQUFDTixXQUFXLE1BQU0sSUFBSUssVUFBVTtJQUN2RyxPQUFPLFNBQVUsTUFBTUQsRUFBRUcsSUFBSSxDQUFDUCxVQUFVRSxTQUFTRSxJQUFJQSxFQUFFRixLQUFLLEdBQUdBLFFBQVFELE1BQU1PLEdBQUcsQ0FBQ1IsVUFBVUUsUUFBU0E7QUFDeEc7QUFDQSxJQUFJTyx5QkFBeUIsU0FBSyxJQUFJLFNBQUksQ0FBQ0Esc0JBQXNCLElBQUssU0FBVVQsUUFBUSxFQUFFQyxLQUFLLEVBQUVFLElBQUksRUFBRUMsQ0FBQztJQUNwRyxJQUFJRCxTQUFTLE9BQU8sQ0FBQ0MsR0FBRyxNQUFNLElBQUlDLFVBQVU7SUFDNUMsSUFBSSxPQUFPSixVQUFVLGFBQWFELGFBQWFDLFNBQVMsQ0FBQ0csSUFBSSxDQUFDSCxNQUFNSyxHQUFHLENBQUNOLFdBQVcsTUFBTSxJQUFJSyxVQUFVO0lBQ3ZHLE9BQU9GLFNBQVMsTUFBTUMsSUFBSUQsU0FBUyxNQUFNQyxFQUFFRyxJQUFJLENBQUNQLFlBQVlJLElBQUlBLEVBQUVGLEtBQUssR0FBR0QsTUFBTVMsR0FBRyxDQUFDVjtBQUN4RjtBQUNBLElBQUlXLGtD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Q0FBQ047UUFDcEgsRUFDQSxPQUFPcEMsT0FBTztZQUNWLE1BQU0sSUFBSTVDLDBFQUFpQkEsQ0FBQzRDLE9BQU9DLFNBQVNEO1FBQ2hEO1FBQ0EsSUFBSSxDQUFDc0IsUUFDRCxNQUFNLElBQUlsRSwwRUFBaUJBO1FBQy9CakMsdUJBQXVCLElBQUksRUFBRUUsa0NBQWtDLEtBQUtVLGtDQUFrQ2QsSUFBSSxDQUFDLElBQUksRUFBRXFHLE9BQU96QyxPQUFPO1FBQy9ILE9BQU95QztJQUNYLEVBQ0EsT0FBT3RCLE9BQU87UUFDVixJQUFJLENBQUNqQixJQUFJLENBQUMsU0FBU2lCO1FBQ25CLE1BQU1BO0lBQ1Y7QUFDSixHQUNBLG1DQUFtQyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvQHNvbGFuYS93YWxsZXQtc3RhbmRhcmQtd2FsbGV0LWFkYXB0ZXItYmFzZS9saWIvZXNtL2FkYXB0ZXIuanM/YWE4ZSJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgX19jbGFzc1ByaXZhdGVGaWVsZFNldCA9ICh0aGlzICYmIHRoaXMuX19jbGFzc1ByaXZhdGVGaWVsZFNldCkgfHwgZnVuY3Rpb24gKHJlY2VpdmVyLCBzdGF0ZSwgdmFsdWUsIGtpbmQsIGYpIHtcbiAgICBpZiAoa2luZCA9PT0gXCJtXCIpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJQcml2YXRlIG1ldGhvZCBpcyBub3Qgd3JpdGFibGVcIik7XG4gICAgaWYgKGtpbmQgPT09IFwiYVwiICYmICFmKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiUHJpdmF0ZSBhY2Nlc3NvciB3YXMgZGVmaW5lZCB3aXRob3V0IGEgc2V0dGVyXCIpO1xuICAgIGlmICh0eXBlb2Ygc3RhdGUgPT09IFwiZnVuY3Rpb25cIiA/IHJlY2VpdmVyICE9PSBzdGF0ZSB8fCAhZiA6ICFzdGF0ZS5oYXMocmVjZWl2ZXIpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IHdyaXRlIHByaXZhdGUgbWVtYmVyIHRvIGFuIG9iamVjdCB3aG9zZSBjbGFzcyBkaWQgbm90IGRlY2xhcmUgaXRcIik7XG4gICAgcmV0dXJuIChraW5kID09PSBcImFcIiA/IGYuY2FsbChyZWNlaXZlciwgdmFsdWUpIDogZiA/IGYudmFsdWUgPSB2YWx1ZSA6IHN0YXRlLnNldChyZWNlaXZlciwgdmFsdWUpKSwgdmFsdWU7XG59O1xudmFyIF9fY2xhc3NQcml2YXRlRmllbGRHZXQgPSAodGhpcyAmJiB0aGlzLl9fY2xhc3NQcml2YXRlRmllbGRHZXQpIHx8IGZ1bmN0aW9uIChyZWNlaXZlciwgc3RhdGUsIGtpbmQsIGYpIHtcbiAgICBpZiAoa2luZCA9PT0gXCJhXCIgJiYgIWYpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJQcml2YXRlIGFjY2Vzc29yIHdhcyBkZWZpbmVkIHdpdGhvdXQgYSBnZXR0ZXJcIik7XG4gICAgaWYgKHR5cGVvZiBzdGF0ZSA9PT0gXCJmdW5jdGlvblwiID8gcmVjZWl2ZXIgIT09IHN0YXRlIHx8ICFmIDogIXN0YXRlLmhhcyhyZWNlaXZlcikpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgcmVhZCBwcml2YXRlIG1lbWJlciBmcm9tIGFuIG9iamVjdCB3aG9zZSBjbGFzcyBkaWQgbm90IGRlY2xhcmUgaXRcIik7XG4gICAgcmV0dXJuIGtpbmQgPT09IFwibVwiID8gZiA6IGtpbmQgPT09IFwiYVwiID8gZi5jYWxsKHJlY2VpdmVyKSA6IGYgPyBmLnZhbHVlIDogc3RhdGUuZ2V0KHJlY2VpdmVyKTtcbn07XG52YXIgX1N0YW5kYXJkV2FsbGV0QWRhcHRlcl9pbnN0YW5jZXMsIF9TdGFuZGFyZFdhbGxldEFkYXB0ZXJfYWNjb3VudCwgX1N0YW5kYXJkV2FsbGV0QWRhcHRlcl9wdWJsaWNLZXksIF9TdGFuZGFyZFdhbGxldEFkYXB0ZXJfY29ubmVjdGluZywgX1N0YW5kYXJkV2FsbGV0QWRhcHRlcl9kaXNjb25uZWN0aW5nLCBfU3RhbmRhcmRXYWxsZXRBZGFwdGVyX29mZiwgX1N0YW5kYXJkV2FsbGV0QWRhcHRlcl9zdXBwb3J0ZWRUcmFuc2FjdGlvblZlcnNpb25zLCBfU3RhbmRhcmRXYWxsZXRBZGFwdGVyX3dhbGxldCwgX1N0YW5kYXJkV2FsbGV0QWRhcHRlcl9yZWFkeVN0YXRlLCBfU3RhbmRhcmRXYWxsZXRBZGFwdGVyX2Nvbm5lY3QsIF9TdGFuZGFyZFdhbGxldEFkYXB0ZXJfY29ubmVjdGVkLCBfU3RhbmRhcmRXYWxsZXRBZGFwdGVyX2Rpc2Nvbm5lY3RlZCwgX1N0YW5kYXJkV2FsbGV0QWRhcHRlcl9yZXNldCwgX1N0YW5kYXJkV2FsbGV0QWRhcHRlcl9jaGFuZ2VkLCBfU3RhbmRhcmRXYWxsZXRBZGFwdGVyX3NpZ25UcmFuc2FjdGlvbiwgX1N0YW5kYXJkV2FsbGV0QWRhcHRlcl9zaWduQWxsVHJhbnNhY3Rpb25zLCBfU3RhbmRhcmRXYWxsZXRBZGFwdGVyX3NpZ25NZXNzYWdlLCBfU3RhbmRhcmRXYWxsZXRBZGFwdGVyX3NpZ25JbjtcbmltcG9ydCB7IEJhc2VXYWxsZXRBZGFwdGVyLCBpc1ZlcnNpb25lZFRyYW5zYWN0aW9uLCBXYWxsZXRBY2NvdW50RXJyb3IsIFdhbGxldENvbmZpZ0Vycm9yLCBXYWxsZXRDb25uZWN0aW9uRXJyb3IsIFdhbGxldERpc2Nvbm5lY3RlZEVycm9yLCBXYWxsZXREaXNjb25uZWN0aW9uRXJyb3IsIFdhbGxldEVycm9yLCBXYWxsZXROb3RDb25uZWN0ZWRFcnJvciwgV2FsbGV0Tm90UmVhZHlFcnJvciwgV2FsbGV0UHVibGljS2V5RXJyb3IsIFdhbGxldFJlYWR5U3RhdGUsIFdhbGxldFNlbmRUcmFuc2FjdGlvbkVycm9yLCBXYWxsZXRTaWduSW5FcnJvciwgV2FsbGV0U2lnbk1lc3NhZ2VFcnJvciwgV2FsbGV0U2lnblRyYW5zYWN0aW9uRXJyb3IsIH0gZnJvbSAnQHNvbGFuYS93YWxsZXQtYWRhcHRlci1iYXNlJztcbmltcG9ydCB7IFNvbGFuYVNpZ25BbmRTZW5kVHJhbnNhY3Rpb24sIFNvbGFuYVNpZ25JbiwgU29sYW5hU2lnbk1lc3NhZ2UsIFNvbGFuYVNpZ25UcmFuc2FjdGlvbiwgfSBmcm9tICdAc29sYW5hL3dhbGxldC1zdGFuZGFyZC1mZWF0dXJlcyc7XG5pbXBvcnQgeyBnZXRDaGFpbkZvckVuZHBvaW50LCBnZXRDb21taXRtZW50IH0gZnJvbSAnQHNvbGFuYS93YWxsZXQtc3RhbmRhcmQtdXRpbCc7XG5pbXBvcnQgeyBQdWJsaWNLZXksIFRyYW5zYWN0aW9uLCBWZXJzaW9uZWRUcmFuc2FjdGlvbiB9IGZyb20gJ0Bzb2xhbmEvd2ViMy5qcyc7XG5pbXBvcnQgeyBTdGFuZGFyZENvbm5lY3QsIFN0YW5kYXJkRGlzY29ubmVjdCwgU3RhbmRhcmRFdmVudHMsIH0gZnJvbSAnQHdhbGxldC1zdGFuZGFyZC9mZWF0dXJlcyc7XG5pbXBvcnQgeyBhcnJheXNFcXVhbCB9IGZyb20gJ0B3YWxsZXQtc3RhbmRhcmQvd2FsbGV0JztcbmltcG9ydCBiczU4IGZyb20gJ2JzNTgnO1xuLyoqIFRPRE86IGRvY3MgKi9cbmV4cG9ydCBjbGFzcyBTdGFuZGFyZFdhbGxldEFkYXB0ZXIgZXh0ZW5kcyBCYXNlV2FsbGV0QWRhcHRlciB7XG4gICAgY29uc3RydWN0b3IoeyB3YWxsZXQgfSkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICBfU3RhbmRhcmRXYWxsZXRBZGFwdGVyX2luc3RhbmNlcy5hZGQodGhpcyk7XG4gICAgICAgIF9TdGFuZGFyZFdhbGxldEFkYXB0ZXJfYWNjb3VudC5zZXQodGhpcywgdm9pZCAwKTtcbiAgICAgICAgX1N0YW5kYXJkV2FsbGV0QWRhcHRlcl9wdWJsaWNLZXkuc2V0KHRoaXMsIHZvaWQgMCk7XG4gICAgICAgIF9TdGFuZGFyZFdhbGxldEFkYXB0ZXJfY29ubmVjdGluZy5zZXQodGhpcywgdm9pZCAwKTtcbiAgICAgICAgX1N0YW5kYXJkV2FsbGV0QWRhcHRlcl9kaXNjb25uZWN0aW5nLnNldCh0aGlzLCB2b2lkIDApO1xuICAgICAgICBfU3RhbmRhcmRXYWxsZXRBZGFwdGVyX29mZi5zZXQodGhpcywgdm9pZCAwKTtcbiAgICAgICAgX1N0YW5kYXJkV2FsbGV0QWRhcHRlcl9zdXBwb3J0ZWRUcmFuc2FjdGlvblZlcnNpb25zLnNldCh0aGlzLCB2b2lkIDApO1xuICAgICAgICBfU3RhbmRhcmRXYWxsZXRBZGFwdGVyX3dhbGxldC5zZXQodGhpcywgdm9pZCAwKTtcbiAgICAgICAgX1N0YW5kYXJkV2FsbGV0QWRhcHRlcl9yZWFkeVN0YXRlLnNldCh0aGlzLCB0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJyB8fCB0eXBlb2YgZG9jdW1lbnQgPT09ICd1bmRlZmluZWQnXG4gICAgICAgICAgICA/IFdhbGxldFJlYWR5U3RhdGUuVW5zdXBwb3J0ZWRcbiAgICAgICAgICAgIDogV2FsbGV0UmVhZHlTdGF0ZS5JbnN0YWxsZWQpO1xuICAgICAgICBfU3RhbmRhcmRXYWxsZXRBZGFwdGVyX2NoYW5nZWQuc2V0KHRoaXMsIChwcm9wZXJ0aWVzKSA9PiB7XG4gICAgICAgICAgICAvLyBJZiBhY2NvdW50cyBoYXZlIGNoYW5nZWQgb24gdGhlIHdhbGxldCwgcmVmbGVjdCB0aGlzIG9uIHRoZSBhZGFwdGVyLlxuICAgICAgICAgICAgaWYgKCdhY2NvdW50cycgaW4gcHJvcGVydGllcykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGFjY291bnQgPSBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9TdGFuZGFyZFdhbGxldEFkYXB0ZXJfd2FsbGV0LCBcImZcIikuYWNjb3VudHNbMF07XG4gICAgICAgICAgICAgICAgLy8gSWYgdGhlIGFkYXB0ZXIgaXNuJ3QgY29ubmVjdGVkLCBvciBpcyBkaXNjb25uZWN0aW5nLCBvciB0aGUgZmlyc3QgYWNjb3VudCBoYXNuJ3QgY2hhbmdlZCwgZG8gbm90aGluZy5cbiAgICAgICAgICAgICAgICBpZiAoX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfU3RhbmRhcmRXYWxsZXRBZGFwdGVyX2FjY291bnQsIFwiZlwiKSAmJiAhX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfU3RhbmRhcmRXYWxsZXRBZGFwdGVyX2Rpc2Nvbm5lY3RpbmcsIFwiZlwiKSAmJiBhY2NvdW50ICE9PSBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9TdGFuZGFyZFdhbGxldEFkYXB0ZXJfYWNjb3VudCwgXCJmXCIpKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIElmIHRoZXJlJ3MgYSBjb25uZWN0ZWQgYWNjb3VudCwgY29ubmVjdCB0aGUgYWRhcHRlci4gT3RoZXJ3aXNlLCBkaXNjb25uZWN0IGl0LlxuICAgICAgICAgICAgICAgICAgICBpZiAoYWNjb3VudCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQ29ubmVjdCB0aGUgYWRhcHRlci5cbiAgICAgICAgICAgICAgICAgICAgICAgIF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX1N0YW5kYXJkV2FsbGV0QWRhcHRlcl9pbnN0YW5jZXMsIFwibVwiLCBfU3RhbmRhcmRXYWxsZXRBZGFwdGVyX2Nvbm5lY3RlZCkuY2FsbCh0aGlzLCBhY2NvdW50KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEVtaXQgYW4gZXJyb3IgYmVjYXVzZSB0aGUgd2FsbGV0IHNwb250YW5lb3VzbHkgZGlzY29ubmVjdGVkLlxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5lbWl0KCdlcnJvcicsIG5ldyBXYWxsZXREaXNjb25uZWN0ZWRFcnJvcigpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIERpc2Nvbm5lY3QgdGhlIGFkYXB0ZXIuXG4gICAgICAgICAgICAgICAgICAgICAgICBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9TdGFuZGFyZFdhbGxldEFkYXB0ZXJfaW5zdGFuY2VzLCBcIm1cIiwgX1N0YW5kYXJkV2FsbGV0QWRhcHRlcl9kaXNjb25uZWN0ZWQpLmNhbGwodGhpcyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBBZnRlciByZWZsZWN0aW5nIGFjY291bnQgY2hhbmdlcywgaWYgZmVhdHVyZXMgaGF2ZSBjaGFuZ2VkIG9uIHRoZSB3YWxsZXQsIHJlZmxlY3QgdGhpcyBvbiB0aGUgYWRhcHRlci5cbiAgICAgICAgICAgIGlmICgnZmVhdHVyZXMnIGluIHByb3BlcnRpZXMpIHtcbiAgICAgICAgICAgICAgICBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9TdGFuZGFyZFdhbGxldEFkYXB0ZXJfaW5zdGFuY2VzLCBcIm1cIiwgX1N0YW5kYXJkV2FsbGV0QWRhcHRlcl9yZXNldCkuY2FsbCh0aGlzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIF9fY2xhc3NQcml2YXRlRmllbGRTZXQodGhpcywgX1N0YW5kYXJkV2FsbGV0QWRhcHRlcl93YWxsZXQsIHdhbGxldCwgXCJmXCIpO1xuICAgICAgICBfX2NsYXNzUHJpdmF0ZUZpZWxkU2V0KHRoaXMsIF9TdGFuZGFyZFdhbGxldEFkYXB0ZXJfYWNjb3VudCwgbnVsbCwgXCJmXCIpO1xuICAgICAgICBfX2NsYXNzUHJpdmF0ZUZpZWxkU2V0KHRoaXMsIF9TdGFuZGFyZFdhbGxldEFkYXB0ZXJfcHVibGljS2V5LCBudWxsLCBcImZcIik7XG4gICAgICAgIF9fY2xhc3NQcml2YXRlRmllbGRTZXQodGhpcywgX1N0YW5kYXJkV2FsbGV0QWRhcHRlcl9jb25uZWN0aW5nLCBmYWxzZSwgXCJmXCIpO1xuICAgICAgICBfX2NsYXNzUHJpdmF0ZUZpZWxkU2V0KHRoaXMsIF9TdGFuZGFyZFdhbGxldEFkYXB0ZXJfZGlzY29ubmVjdGluZywgZmFsc2UsIFwiZlwiKTtcbiAgICAgICAgX19jbGFzc1ByaXZhdGVGaWVsZFNldCh0aGlzLCBfU3RhbmRhcmRXYWxsZXRBZGFwdGVyX29mZiwgX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfU3RhbmRhcmRXYWxsZXRBZGFwdGVyX3dhbGxldCwgXCJmXCIpLmZlYXR1cmVzW1N0YW5kYXJkRXZlbnRzXS5vbignY2hhbmdlJywgX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfU3RhbmRhcmRXYWxsZXRBZGFwdGVyX2NoYW5nZWQsIFwiZlwiKSksIFwiZlwiKTtcbiAgICAgICAgX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfU3RhbmRhcmRXYWxsZXRBZGFwdGVyX2luc3RhbmNlcywgXCJtXCIsIF9TdGFuZGFyZFdhbGxldEFkYXB0ZXJfcmVzZXQpLmNhbGwodGhpcyk7XG4gICAgfVxuICAgIGdldCBuYW1lKCkge1xuICAgICAgICByZXR1cm4gX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfU3RhbmRhcmRXYWxsZXRBZGFwdGVyX3dhbGxldCwgXCJmXCIpLm5hbWU7XG4gICAgfVxuICAgIGdldCB1cmwoKSB7XG4gICAgICAgIHJldHVybiAnaHR0cHM6Ly9naXRodWIuY29tL3NvbGFuYS1sYWJzL3dhbGxldC1zdGFuZGFyZCc7XG4gICAgfVxuICAgIGdldCBpY29uKCkge1xuICAgICAgICByZXR1cm4gX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfU3RhbmRhcmRXYWxsZXRBZGFwdGVyX3dhbGxldCwgXCJmXCIpLmljb247XG4gICAgfVxuICAgIGdldCByZWFkeVN0YXRlKCkge1xuICAgICAgICByZXR1cm4gX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfU3RhbmRhcmRXYWxsZXRBZGFwdGVyX3JlYWR5U3RhdGUsIFwiZlwiKTtcbiAgICB9XG4gICAgZ2V0IHB1YmxpY0tleSgpIHtcbiAgICAgICAgcmV0dXJuIF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX1N0YW5kYXJkV2FsbGV0QWRhcHRlcl9wdWJsaWNLZXksIFwiZlwiKTtcbiAgICB9XG4gICAgZ2V0IGNvbm5lY3RpbmcoKSB7XG4gICAgICAgIHJldHVybiBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9TdGFuZGFyZFdhbGxldEFkYXB0ZXJfY29ubmVjdGluZywgXCJmXCIpO1xuICAgIH1cbiAgICBnZXQgc3VwcG9ydGVkVHJhbnNhY3Rpb25WZXJzaW9ucygpIHtcbiAgICAgICAgcmV0dXJuIF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX1N0YW5kYXJkV2FsbGV0QWRhcHRlcl9zdXBwb3J0ZWRUcmFuc2FjdGlvblZlcnNpb25zLCBcImZcIik7XG4gICAgfVxuICAgIGdldCB3YWxsZXQoKSB7XG4gICAgICAgIHJldHVybiBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9TdGFuZGFyZFdhbGxldEFkYXB0ZXJfd2FsbGV0LCBcImZcIik7XG4gICAgfVxuICAgIGdldCBzdGFuZGFyZCgpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGRlc3Ryb3koKSB7XG4gICAgICAgIF9fY2xhc3NQcml2YXRlRmllbGRTZXQodGhpcywgX1N0YW5kYXJkV2FsbGV0QWRhcHRlcl9hY2NvdW50LCBudWxsLCBcImZcIik7XG4gICAgICAgIF9fY2xhc3NQcml2YXRlRmllbGRTZXQodGhpcywgX1N0YW5kYXJkV2FsbGV0QWRhcHRlcl9wdWJsaWNLZXksIG51bGwsIFwiZlwiKTtcbiAgICAgICAgX19jbGFzc1ByaXZhdGVGaWVsZFNldCh0aGlzLCBfU3RhbmRhcmRXYWxsZXRBZGFwdGVyX2Nvbm5lY3RpbmcsIGZhbHNlLCBcImZcIik7XG4gICAgICAgIF9fY2xhc3NQcml2YXRlRmllbGRTZXQodGhpcywgX1N0YW5kYXJkV2FsbGV0QWRhcHRlcl9kaXNjb25uZWN0aW5nLCBmYWxzZSwgXCJmXCIpO1xuICAgICAgICBjb25zdCBvZmYgPSBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9TdGFuZGFyZFdhbGxldEFkYXB0ZXJfb2ZmLCBcImZcIik7XG4gICAgICAgIGlmIChvZmYpIHtcbiAgICAgICAgICAgIF9fY2xhc3NQcml2YXRlRmllbGRTZXQodGhpcywgX1N0YW5kYXJkV2FsbGV0QWRhcHRlcl9vZmYsIG51bGwsIFwiZlwiKTtcbiAgICAgICAgICAgIG9mZigpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFzeW5jIGF1dG9Db25uZWN0KCkge1xuICAgICAgICByZXR1cm4gX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfU3RhbmRhcmRXYWxsZXRBZGFwdGVyX2luc3RhbmNlcywgXCJtXCIsIF9TdGFuZGFyZFdhbGxldEFkYXB0ZXJfY29ubmVjdCkuY2FsbCh0aGlzLCB7IHNpbGVudDogdHJ1ZSB9KTtcbiAgICB9XG4gICAgYXN5bmMgY29ubmVjdCgpIHtcbiAgICAgICAgcmV0dXJuIF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX1N0YW5kYXJkV2FsbGV0QWRhcHRlcl9pbnN0YW5jZXMsIFwibVwiLCBfU3RhbmRhcmRXYWxsZXRBZGFwdGVyX2Nvbm5lY3QpLmNhbGwodGhpcyk7XG4gICAgfVxuICAgIGFzeW5jIGRpc2Nvbm5lY3QoKSB7XG4gICAgICAgIGlmIChTdGFuZGFyZERpc2Nvbm5lY3QgaW4gX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfU3RhbmRhcmRXYWxsZXRBZGFwdGVyX3dhbGxldCwgXCJmXCIpLmZlYXR1cmVzKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIF9fY2xhc3NQcml2YXRlRmllbGRTZXQodGhpcywgX1N0YW5kYXJkV2FsbGV0QWRhcHRlcl9kaXNjb25uZWN0aW5nLCB0cnVlLCBcImZcIik7XG4gICAgICAgICAgICAgICAgYXdhaXQgX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfU3RhbmRhcmRXYWxsZXRBZGFwdGVyX3dhbGxldCwgXCJmXCIpLmZlYXR1cmVzW1N0YW5kYXJkRGlzY29ubmVjdF0uZGlzY29ubmVjdCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5lbWl0KCdlcnJvcicsIG5ldyBXYWxsZXREaXNjb25uZWN0aW9uRXJyb3IoZXJyb3I/Lm1lc3NhZ2UsIGVycm9yKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgICBfX2NsYXNzUHJpdmF0ZUZpZWxkU2V0KHRoaXMsIF9TdGFuZGFyZFdhbGxldEFkYXB0ZXJfZGlzY29ubmVjdGluZywgZmFsc2UsIFwiZlwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9TdGFuZGFyZFdhbGxldEFkYXB0ZXJfaW5zdGFuY2VzLCBcIm1cIiwgX1N0YW5kYXJkV2FsbGV0QWRhcHRlcl9kaXNjb25uZWN0ZWQpLmNhbGwodGhpcyk7XG4gICAgfVxuICAgIGFzeW5jIHNlbmRUcmFuc2FjdGlvbih0cmFuc2FjdGlvbiwgY29ubmVjdGlvbiwgb3B0aW9ucyA9IHt9KSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCBhY2NvdW50ID0gX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfU3RhbmRhcmRXYWxsZXRBZGFwdGVyX2FjY291bnQsIFwiZlwiKTtcbiAgICAgICAgICAgIGlmICghYWNjb3VudClcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgV2FsbGV0Tm90Q29ubmVjdGVkRXJyb3IoKTtcbiAgICAgICAgICAgIGxldCBmZWF0dXJlO1xuICAgICAgICAgICAgaWYgKFNvbGFuYVNpZ25BbmRTZW5kVHJhbnNhY3Rpb24gaW4gX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfU3RhbmRhcmRXYWxsZXRBZGFwdGVyX3dhbGxldCwgXCJmXCIpLmZlYXR1cmVzKSB7XG4gICAgICAgICAgICAgICAgaWYgKGFjY291bnQuZmVhdHVyZXMuaW5jbHVkZXMoU29sYW5hU2lnbkFuZFNlbmRUcmFuc2FjdGlvbikpIHtcbiAgICAgICAgICAgICAgICAgICAgZmVhdHVyZSA9IFNvbGFuYVNpZ25BbmRTZW5kVHJhbnNhY3Rpb247XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKFNvbGFuYVNpZ25UcmFuc2FjdGlvbiBpbiBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9TdGFuZGFyZFdhbGxldEFkYXB0ZXJfd2FsbGV0LCBcImZcIikuZmVhdHVyZXMgJiZcbiAgICAgICAgICAgICAgICAgICAgYWNjb3VudC5mZWF0dXJlcy5pbmNsdWRlcyhTb2xhbmFTaWduVHJhbnNhY3Rpb24pKSB7XG4gICAgICAgICAgICAgICAgICAgIGZlYXR1cmUgPSBTb2xhbmFTaWduVHJhbnNhY3Rpb247XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgV2FsbGV0QWNjb3VudEVycm9yKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoU29sYW5hU2lnblRyYW5zYWN0aW9uIGluIF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX1N0YW5kYXJkV2FsbGV0QWRhcHRlcl93YWxsZXQsIFwiZlwiKS5mZWF0dXJlcykge1xuICAgICAgICAgICAgICAgIGlmICghYWNjb3VudC5mZWF0dXJlcy5pbmNsdWRlcyhTb2xhbmFTaWduVHJhbnNhY3Rpb24pKVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgV2FsbGV0QWNjb3VudEVycm9yKCk7XG4gICAgICAgICAgICAgICAgZmVhdHVyZSA9IFNvbGFuYVNpZ25UcmFuc2FjdGlvbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBXYWxsZXRDb25maWdFcnJvcigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgY2hhaW4gPSBnZXRDaGFpbkZvckVuZHBvaW50KGNvbm5lY3Rpb24ucnBjRW5kcG9pbnQpO1xuICAgICAgICAgICAgaWYgKCFhY2NvdW50LmNoYWlucy5pbmNsdWRlcyhjaGFpbikpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFdhbGxldFNlbmRUcmFuc2FjdGlvbkVycm9yKCk7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgc2lnbmVycywgLi4uc2VuZE9wdGlvbnMgfSA9IG9wdGlvbnM7XG4gICAgICAgICAgICAgICAgbGV0IHNlcmlhbGl6ZWRUcmFuc2FjdGlvbjtcbiAgICAgICAgICAgICAgICBpZiAoaXNWZXJzaW9uZWRUcmFuc2FjdGlvbih0cmFuc2FjdGlvbikpIHtcbiAgICAgICAgICAgICAgICAgICAgc2lnbmVycz8ubGVuZ3RoICYmIHRyYW5zYWN0aW9uLnNpZ24oc2lnbmVycyk7XG4gICAgICAgICAgICAgICAgICAgIHNlcmlhbGl6ZWRUcmFuc2FjdGlvbiA9IHRyYW5zYWN0aW9uLnNlcmlhbGl6ZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdHJhbnNhY3Rpb24gPSAoYXdhaXQgdGhpcy5wcmVwYXJlVHJhbnNhY3Rpb24odHJhbnNhY3Rpb24sIGNvbm5lY3Rpb24sIHNlbmRPcHRpb25zKSk7XG4gICAgICAgICAgICAgICAgICAgIHNpZ25lcnM/Lmxlbmd0aCAmJiB0cmFuc2FjdGlvbi5wYXJ0aWFsU2lnbiguLi5zaWduZXJzKTtcbiAgICAgICAgICAgICAgICAgICAgc2VyaWFsaXplZFRyYW5zYWN0aW9uID0gbmV3IFVpbnQ4QXJyYXkodHJhbnNhY3Rpb24uc2VyaWFsaXplKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlcXVpcmVBbGxTaWduYXR1cmVzOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHZlcmlmeVNpZ25hdHVyZXM6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChmZWF0dXJlID09PSBTb2xhbmFTaWduQW5kU2VuZFRyYW5zYWN0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IFtvdXRwdXRdID0gYXdhaXQgX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfU3RhbmRhcmRXYWxsZXRBZGFwdGVyX3dhbGxldCwgXCJmXCIpLmZlYXR1cmVzW1NvbGFuYVNpZ25BbmRTZW5kVHJhbnNhY3Rpb25dLnNpZ25BbmRTZW5kVHJhbnNhY3Rpb24oe1xuICAgICAgICAgICAgICAgICAgICAgICAgYWNjb3VudCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoYWluLFxuICAgICAgICAgICAgICAgICAgICAgICAgdHJhbnNhY3Rpb246IHNlcmlhbGl6ZWRUcmFuc2FjdGlvbixcbiAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnM6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcmVmbGlnaHRDb21taXRtZW50OiBnZXRDb21taXRtZW50KHNlbmRPcHRpb25zLnByZWZsaWdodENvbW1pdG1lbnQgfHwgY29ubmVjdGlvbi5jb21taXRtZW50KSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBza2lwUHJlZmxpZ2h0OiBzZW5kT3B0aW9ucy5za2lwUHJlZmxpZ2h0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1heFJldHJpZXM6IHNlbmRPcHRpb25zLm1heFJldHJpZXMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWluQ29udGV4dFNsb3Q6IHNlbmRPcHRpb25zLm1pbkNvbnRleHRTbG90LFxuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tbm9uLW51bGwtYXNzZXJ0aW9uXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBiczU4LmVuY29kZShvdXRwdXQuc2lnbmF0dXJlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IFtvdXRwdXRdID0gYXdhaXQgX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfU3RhbmRhcmRXYWxsZXRBZGFwdGVyX3dhbGxldCwgXCJmXCIpLmZlYXR1cmVzW1NvbGFuYVNpZ25UcmFuc2FjdGlvbl0uc2lnblRyYW5zYWN0aW9uKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFjY291bnQsXG4gICAgICAgICAgICAgICAgICAgICAgICBjaGFpbixcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyYW5zYWN0aW9uOiBzZXJpYWxpemVkVHJhbnNhY3Rpb24sXG4gICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJlZmxpZ2h0Q29tbWl0bWVudDogZ2V0Q29tbWl0bWVudChzZW5kT3B0aW9ucy5wcmVmbGlnaHRDb21taXRtZW50IHx8IGNvbm5lY3Rpb24uY29tbWl0bWVudCksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWluQ29udGV4dFNsb3Q6IHNlbmRPcHRpb25zLm1pbkNvbnRleHRTbG90LFxuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tbm9uLW51bGwtYXNzZXJ0aW9uXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBhd2FpdCBjb25uZWN0aW9uLnNlbmRSYXdUcmFuc2FjdGlvbihvdXRwdXQuc2lnbmVkVHJhbnNhY3Rpb24sIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC4uLnNlbmRPcHRpb25zLFxuICAgICAgICAgICAgICAgICAgICAgICAgcHJlZmxpZ2h0Q29tbWl0bWVudDogZ2V0Q29tbWl0bWVudChzZW5kT3B0aW9ucy5wcmVmbGlnaHRDb21taXRtZW50IHx8IGNvbm5lY3Rpb24uY29tbWl0bWVudCksXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIFdhbGxldEVycm9yKVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgV2FsbGV0U2VuZFRyYW5zYWN0aW9uRXJyb3IoZXJyb3I/Lm1lc3NhZ2UsIGVycm9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIHRoaXMuZW1pdCgnZXJyb3InLCBlcnJvcik7XG4gICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgfVxuICAgIH1cbn1cbl9TdGFuZGFyZFdhbGxldEFkYXB0ZXJfYWNjb3VudCA9IG5ldyBXZWFrTWFwKCksIF9TdGFuZGFyZFdhbGxldEFkYXB0ZXJfcHVibGljS2V5ID0gbmV3IFdlYWtNYXAoKSwgX1N0YW5kYXJkV2FsbGV0QWRhcHRlcl9jb25uZWN0aW5nID0gbmV3IFdlYWtNYXAoKSwgX1N0YW5kYXJkV2FsbGV0QWRhcHRlcl9kaXNjb25uZWN0aW5nID0gbmV3IFdlYWtNYXAoKSwgX1N0YW5kYXJkV2FsbGV0QWRhcHRlcl9vZmYgPSBuZXcgV2Vha01hcCgpLCBfU3RhbmRhcmRXYWxsZXRBZGFwdGVyX3N1cHBvcnRlZFRyYW5zYWN0aW9uVmVyc2lvbnMgPSBuZXcgV2Vha01hcCgpLCBfU3RhbmRhcmRXYWxsZXRBZGFwdGVyX3dhbGxldCA9IG5ldyBXZWFrTWFwKCksIF9TdGFuZGFyZFdhbGxldEFkYXB0ZXJfcmVhZHlTdGF0ZSA9IG5ldyBXZWFrTWFwKCksIF9TdGFuZGFyZFdhbGxldEFkYXB0ZXJfY2hhbmdlZCA9IG5ldyBXZWFrTWFwKCksIF9TdGFuZGFyZFdhbGxldEFkYXB0ZXJfaW5zdGFuY2VzID0gbmV3IFdlYWtTZXQoKSwgX1N0YW5kYXJkV2FsbGV0QWRhcHRlcl9jb25uZWN0ID0gYXN5bmMgZnVuY3Rpb24gX1N0YW5kYXJkV2FsbGV0QWRhcHRlcl9jb25uZWN0KGlucHV0KSB7XG4gICAgdHJ5IHtcbiAgICAgICAgaWYgKHRoaXMuY29ubmVjdGVkIHx8IHRoaXMuY29ubmVjdGluZylcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgaWYgKF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX1N0YW5kYXJkV2FsbGV0QWRhcHRlcl9yZWFkeVN0YXRlLCBcImZcIikgIT09IFdhbGxldFJlYWR5U3RhdGUuSW5zdGFsbGVkKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFdhbGxldE5vdFJlYWR5RXJyb3IoKTtcbiAgICAgICAgX19jbGFzc1ByaXZhdGVGaWVsZFNldCh0aGlzLCBfU3RhbmRhcmRXYWxsZXRBZGFwdGVyX2Nvbm5lY3RpbmcsIHRydWUsIFwiZlwiKTtcbiAgICAgICAgaWYgKCFfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9TdGFuZGFyZFdhbGxldEFkYXB0ZXJfd2FsbGV0LCBcImZcIikuYWNjb3VudHMubGVuZ3RoKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGF3YWl0IF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX1N0YW5kYXJkV2FsbGV0QWRhcHRlcl93YWxsZXQsIFwiZlwiKS5mZWF0dXJlc1tTdGFuZGFyZENvbm5lY3RdLmNvbm5lY3QoaW5wdXQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFdhbGxldENvbm5lY3Rpb25FcnJvcihlcnJvcj8ubWVzc2FnZSwgZXJyb3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGFjY291bnQgPSBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9TdGFuZGFyZFdhbGxldEFkYXB0ZXJfd2FsbGV0LCBcImZcIikuYWNjb3VudHNbMF07XG4gICAgICAgIGlmICghYWNjb3VudClcbiAgICAgICAgICAgIHRocm93IG5ldyBXYWxsZXRBY2NvdW50RXJyb3IoKTtcbiAgICAgICAgX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfU3RhbmRhcmRXYWxsZXRBZGFwdGVyX2luc3RhbmNlcywgXCJtXCIsIF9TdGFuZGFyZFdhbGxldEFkYXB0ZXJfY29ubmVjdGVkKS5jYWxsKHRoaXMsIGFjY291bnQpO1xuICAgIH1cbiAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgdGhpcy5lbWl0KCdlcnJvcicsIGVycm9yKTtcbiAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxuICAgIGZpbmFsbHkge1xuICAgICAgICBfX2NsYXNzUHJpdmF0ZUZpZWxkU2V0KHRoaXMsIF9TdGFuZGFyZFdhbGxldEFkYXB0ZXJfY29ubmVjdGluZywgZmFsc2UsIFwiZlwiKTtcbiAgICB9XG59LCBfU3RhbmRhcmRXYWxsZXRBZGFwdGVyX2Nvbm5lY3RlZCA9IGZ1bmN0aW9uIF9TdGFuZGFyZFdhbGxldEFkYXB0ZXJfY29ubmVjdGVkKGFjY291bnQpIHtcbiAgICBsZXQgcHVibGljS2V5O1xuICAgIHRyeSB7XG4gICAgICAgIC8vIFVzZSBhY2NvdW50LmFkZHJlc3MgaW5zdGVhZCBvZiBhY2NvdW50LnB1YmxpY0tleSBzaW5jZSBhZGRyZXNzIGNvdWxkIGJlIGEgUERBXG4gICAgICAgIHB1YmxpY0tleSA9IG5ldyBQdWJsaWNLZXkoYWNjb3VudC5hZGRyZXNzKTtcbiAgICB9XG4gICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIHRocm93IG5ldyBXYWxsZXRQdWJsaWNLZXlFcnJvcihlcnJvcj8ubWVzc2FnZSwgZXJyb3IpO1xuICAgIH1cbiAgICBfX2NsYXNzUHJpdmF0ZUZpZWxkU2V0KHRoaXMsIF9TdGFuZGFyZFdhbGxldEFkYXB0ZXJfYWNjb3VudCwgYWNjb3VudCwgXCJmXCIpO1xuICAgIF9fY2xhc3NQcml2YXRlRmllbGRTZXQodGhpcywgX1N0YW5kYXJkV2FsbGV0QWRhcHRlcl9wdWJsaWNLZXksIHB1YmxpY0tleSwgXCJmXCIpO1xuICAgIF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX1N0YW5kYXJkV2FsbGV0QWRhcHRlcl9pbnN0YW5jZXMsIFwibVwiLCBfU3RhbmRhcmRXYWxsZXRBZGFwdGVyX3Jlc2V0KS5jYWxsKHRoaXMpO1xuICAgIHRoaXMuZW1pdCgnY29ubmVjdCcsIHB1YmxpY0tleSk7XG59LCBfU3RhbmRhcmRXYWxsZXRBZGFwdGVyX2Rpc2Nvbm5lY3RlZCA9IGZ1bmN0aW9uIF9TdGFuZGFyZFdhbGxldEFkYXB0ZXJfZGlzY29ubmVjdGVkKCkge1xuICAgIF9fY2xhc3NQcml2YXRlRmllbGRTZXQodGhpcywgX1N0YW5kYXJkV2FsbGV0QWRhcHRlcl9hY2NvdW50LCBudWxsLCBcImZcIik7XG4gICAgX19jbGFzc1ByaXZhdGVGaWVsZFNldCh0aGlzLCBfU3RhbmRhcmRXYWxsZXRBZGFwdGVyX3B1YmxpY0tleSwgbnVsbCwgXCJmXCIpO1xuICAgIF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX1N0YW5kYXJkV2FsbGV0QWRhcHRlcl9pbnN0YW5jZXMsIFwibVwiLCBfU3RhbmRhcmRXYWxsZXRBZGFwdGVyX3Jlc2V0KS5jYWxsKHRoaXMpO1xuICAgIHRoaXMuZW1pdCgnZGlzY29ubmVjdCcpO1xufSwgX1N0YW5kYXJkV2FsbGV0QWRhcHRlcl9yZXNldCA9IGZ1bmN0aW9uIF9TdGFuZGFyZFdhbGxldEFkYXB0ZXJfcmVzZXQoKSB7XG4gICAgY29uc3Qgc3VwcG9ydGVkVHJhbnNhY3Rpb25WZXJzaW9ucyA9IFNvbGFuYVNpZ25BbmRTZW5kVHJhbnNhY3Rpb24gaW4gX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfU3RhbmRhcmRXYWxsZXRBZGFwdGVyX3dhbGxldCwgXCJmXCIpLmZlYXR1cmVzXG4gICAgICAgID8gX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfU3RhbmRhcmRXYWxsZXRBZGFwdGVyX3dhbGxldCwgXCJmXCIpLmZlYXR1cmVzW1NvbGFuYVNpZ25BbmRTZW5kVHJhbnNhY3Rpb25dLnN1cHBvcnRlZFRyYW5zYWN0aW9uVmVyc2lvbnNcbiAgICAgICAgOiBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9TdGFuZGFyZFdhbGxldEFkYXB0ZXJfd2FsbGV0LCBcImZcIikuZmVhdHVyZXNbU29sYW5hU2lnblRyYW5zYWN0aW9uXS5zdXBwb3J0ZWRUcmFuc2FjdGlvblZlcnNpb25zO1xuICAgIF9fY2xhc3NQcml2YXRlRmllbGRTZXQodGhpcywgX1N0YW5kYXJkV2FsbGV0QWRhcHRlcl9zdXBwb3J0ZWRUcmFuc2FjdGlvblZlcnNpb25zLCBhcnJheXNFcXVhbChzdXBwb3J0ZWRUcmFuc2FjdGlvblZlcnNpb25zLCBbJ2xlZ2FjeSddKVxuICAgICAgICA/IG51bGxcbiAgICAgICAgOiBuZXcgU2V0KHN1cHBvcnRlZFRyYW5zYWN0aW9uVmVyc2lvbnMpLCBcImZcIik7XG4gICAgaWYgKFNvbGFuYVNpZ25UcmFuc2FjdGlvbiBpbiBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9TdGFuZGFyZFdhbGxldEFkYXB0ZXJfd2FsbGV0LCBcImZcIikuZmVhdHVyZXMgJiYgX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfU3RhbmRhcmRXYWxsZXRBZGFwdGVyX2FjY291bnQsIFwiZlwiKT8uZmVhdHVyZXMuaW5jbHVkZXMoU29sYW5hU2lnblRyYW5zYWN0aW9uKSkge1xuICAgICAgICB0aGlzLnNpZ25UcmFuc2FjdGlvbiA9IF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX1N0YW5kYXJkV2FsbGV0QWRhcHRlcl9pbnN0YW5jZXMsIFwibVwiLCBfU3RhbmRhcmRXYWxsZXRBZGFwdGVyX3NpZ25UcmFuc2FjdGlvbik7XG4gICAgICAgIHRoaXMuc2lnbkFsbFRyYW5zYWN0aW9ucyA9IF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX1N0YW5kYXJkV2FsbGV0QWRhcHRlcl9pbnN0YW5jZXMsIFwibVwiLCBfU3RhbmRhcmRXYWxsZXRBZGFwdGVyX3NpZ25BbGxUcmFuc2FjdGlvbnMpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgZGVsZXRlIHRoaXMuc2lnblRyYW5zYWN0aW9uO1xuICAgICAgICBkZWxldGUgdGhpcy5zaWduQWxsVHJhbnNhY3Rpb25zO1xuICAgIH1cbiAgICBpZiAoU29sYW5hU2lnbk1lc3NhZ2UgaW4gX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfU3RhbmRhcmRXYWxsZXRBZGFwdGVyX3dhbGxldCwgXCJmXCIpLmZlYXR1cmVzICYmIF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX1N0YW5kYXJkV2FsbGV0QWRhcHRlcl9hY2NvdW50LCBcImZcIik/LmZlYXR1cmVzLmluY2x1ZGVzKFNvbGFuYVNpZ25NZXNzYWdlKSkge1xuICAgICAgICB0aGlzLnNpZ25NZXNzYWdlID0gX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfU3RhbmRhcmRXYWxsZXRBZGFwdGVyX2luc3RhbmNlcywgXCJtXCIsIF9TdGFuZGFyZFdhbGxldEFkYXB0ZXJfc2lnbk1lc3NhZ2UpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgZGVsZXRlIHRoaXMuc2lnbk1lc3NhZ2U7XG4gICAgfVxuICAgIGlmIChTb2xhbmFTaWduSW4gaW4gX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfU3RhbmRhcmRXYWxsZXRBZGFwdGVyX3dhbGxldCwgXCJmXCIpLmZlYXR1cmVzKSB7XG4gICAgICAgIHRoaXMuc2lnbkluID0gX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfU3RhbmRhcmRXYWxsZXRBZGFwdGVyX2luc3RhbmNlcywgXCJtXCIsIF9TdGFuZGFyZFdhbGxldEFkYXB0ZXJfc2lnbkluKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGRlbGV0ZSB0aGlzLnNpZ25JbjtcbiAgICB9XG59LCBfU3RhbmRhcmRXYWxsZXRBZGFwdGVyX3NpZ25UcmFuc2FjdGlvbiA9IGFzeW5jIGZ1bmN0aW9uIF9TdGFuZGFyZFdhbGxldEFkYXB0ZXJfc2lnblRyYW5zYWN0aW9uKHRyYW5zYWN0aW9uKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgY29uc3QgYWNjb3VudCA9IF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX1N0YW5kYXJkV2FsbGV0QWRhcHRlcl9hY2NvdW50LCBcImZcIik7XG4gICAgICAgIGlmICghYWNjb3VudClcbiAgICAgICAgICAgIHRocm93IG5ldyBXYWxsZXROb3RDb25uZWN0ZWRFcnJvcigpO1xuICAgICAgICBpZiAoIShTb2xhbmFTaWduVHJhbnNhY3Rpb24gaW4gX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfU3RhbmRhcmRXYWxsZXRBZGFwdGVyX3dhbGxldCwgXCJmXCIpLmZlYXR1cmVzKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBXYWxsZXRDb25maWdFcnJvcigpO1xuICAgICAgICBpZiAoIWFjY291bnQuZmVhdHVyZXMuaW5jbHVkZXMoU29sYW5hU2lnblRyYW5zYWN0aW9uKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBXYWxsZXRBY2NvdW50RXJyb3IoKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHNpZ25lZFRyYW5zYWN0aW9ucyA9IGF3YWl0IF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX1N0YW5kYXJkV2FsbGV0QWRhcHRlcl93YWxsZXQsIFwiZlwiKS5mZWF0dXJlc1tTb2xhbmFTaWduVHJhbnNhY3Rpb25dLnNpZ25UcmFuc2FjdGlvbih7XG4gICAgICAgICAgICAgICAgYWNjb3VudCxcbiAgICAgICAgICAgICAgICB0cmFuc2FjdGlvbjogaXNWZXJzaW9uZWRUcmFuc2FjdGlvbih0cmFuc2FjdGlvbilcbiAgICAgICAgICAgICAgICAgICAgPyB0cmFuc2FjdGlvbi5zZXJpYWxpemUoKVxuICAgICAgICAgICAgICAgICAgICA6IG5ldyBVaW50OEFycmF5KHRyYW5zYWN0aW9uLnNlcmlhbGl6ZSh7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXF1aXJlQWxsU2lnbmF0dXJlczogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgICAgICB2ZXJpZnlTaWduYXR1cmVzOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgfSkpLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLW5vbi1udWxsLWFzc2VydGlvblxuICAgICAgICAgICAgY29uc3Qgc2VyaWFsaXplZFRyYW5zYWN0aW9uID0gc2lnbmVkVHJhbnNhY3Rpb25zWzBdLnNpZ25lZFRyYW5zYWN0aW9uO1xuICAgICAgICAgICAgcmV0dXJuIChpc1ZlcnNpb25lZFRyYW5zYWN0aW9uKHRyYW5zYWN0aW9uKVxuICAgICAgICAgICAgICAgID8gVmVyc2lvbmVkVHJhbnNhY3Rpb24uZGVzZXJpYWxpemUoc2VyaWFsaXplZFRyYW5zYWN0aW9uKVxuICAgICAgICAgICAgICAgIDogVHJhbnNhY3Rpb24uZnJvbShzZXJpYWxpemVkVHJhbnNhY3Rpb24pKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIFdhbGxldEVycm9yKVxuICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgICAgdGhyb3cgbmV3IFdhbGxldFNpZ25UcmFuc2FjdGlvbkVycm9yKGVycm9yPy5tZXNzYWdlLCBlcnJvcik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIHRoaXMuZW1pdCgnZXJyb3InLCBlcnJvcik7XG4gICAgICAgIHRocm93IGVycm9yO1xuICAgIH1cbn0sIF9TdGFuZGFyZFdhbGxldEFkYXB0ZXJfc2lnbkFsbFRyYW5zYWN0aW9ucyA9IGFzeW5jIGZ1bmN0aW9uIF9TdGFuZGFyZFdhbGxldEFkYXB0ZXJfc2lnbkFsbFRyYW5zYWN0aW9ucyh0cmFuc2FjdGlvbnMpIHtcbiAgICB0cnkge1xuICAgICAgICBjb25zdCBhY2NvdW50ID0gX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfU3RhbmRhcmRXYWxsZXRBZGFwdGVyX2FjY291bnQsIFwiZlwiKTtcbiAgICAgICAgaWYgKCFhY2NvdW50KVxuICAgICAgICAgICAgdGhyb3cgbmV3IFdhbGxldE5vdENvbm5lY3RlZEVycm9yKCk7XG4gICAgICAgIGlmICghKFNvbGFuYVNpZ25UcmFuc2FjdGlvbiBpbiBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9TdGFuZGFyZFdhbGxldEFkYXB0ZXJfd2FsbGV0LCBcImZcIikuZmVhdHVyZXMpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFdhbGxldENvbmZpZ0Vycm9yKCk7XG4gICAgICAgIGlmICghYWNjb3VudC5mZWF0dXJlcy5pbmNsdWRlcyhTb2xhbmFTaWduVHJhbnNhY3Rpb24pKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFdhbGxldEFjY291bnRFcnJvcigpO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3Qgc2lnbmVkVHJhbnNhY3Rpb25zID0gYXdhaXQgX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfU3RhbmRhcmRXYWxsZXRBZGFwdGVyX3dhbGxldCwgXCJmXCIpLmZlYXR1cmVzW1NvbGFuYVNpZ25UcmFuc2FjdGlvbl0uc2lnblRyYW5zYWN0aW9uKC4uLnRyYW5zYWN0aW9ucy5tYXAoKHRyYW5zYWN0aW9uKSA9PiAoe1xuICAgICAgICAgICAgICAgIGFjY291bnQsXG4gICAgICAgICAgICAgICAgdHJhbnNhY3Rpb246IGlzVmVyc2lvbmVkVHJhbnNhY3Rpb24odHJhbnNhY3Rpb24pXG4gICAgICAgICAgICAgICAgICAgID8gdHJhbnNhY3Rpb24uc2VyaWFsaXplKClcbiAgICAgICAgICAgICAgICAgICAgOiBuZXcgVWludDhBcnJheSh0cmFuc2FjdGlvbi5zZXJpYWxpemUoe1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVxdWlyZUFsbFNpZ25hdHVyZXM6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgdmVyaWZ5U2lnbmF0dXJlczogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgIH0pKSxcbiAgICAgICAgICAgIH0pKSk7XG4gICAgICAgICAgICByZXR1cm4gdHJhbnNhY3Rpb25zLm1hcCgodHJhbnNhY3Rpb24sIGluZGV4KSA9PiB7XG4gICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1ub24tbnVsbC1hc3NlcnRpb25cbiAgICAgICAgICAgICAgICBjb25zdCBzaWduZWRUcmFuc2FjdGlvbiA9IHNpZ25lZFRyYW5zYWN0aW9uc1tpbmRleF0uc2lnbmVkVHJhbnNhY3Rpb247XG4gICAgICAgICAgICAgICAgcmV0dXJuIChpc1ZlcnNpb25lZFRyYW5zYWN0aW9uKHRyYW5zYWN0aW9uKVxuICAgICAgICAgICAgICAgICAgICA/IFZlcnNpb25lZFRyYW5zYWN0aW9uLmRlc2VyaWFsaXplKHNpZ25lZFRyYW5zYWN0aW9uKVxuICAgICAgICAgICAgICAgICAgICA6IFRyYW5zYWN0aW9uLmZyb20oc2lnbmVkVHJhbnNhY3Rpb24pKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFdhbGxldFNpZ25UcmFuc2FjdGlvbkVycm9yKGVycm9yPy5tZXNzYWdlLCBlcnJvcik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIHRoaXMuZW1pdCgnZXJyb3InLCBlcnJvcik7XG4gICAgICAgIHRocm93IGVycm9yO1xuICAgIH1cbn0sIF9TdGFuZGFyZFdhbGxldEFkYXB0ZXJfc2lnbk1lc3NhZ2UgPSBhc3luYyBmdW5jdGlvbiBfU3RhbmRhcmRXYWxsZXRBZGFwdGVyX3NpZ25NZXNzYWdlKG1lc3NhZ2UpIHtcbiAgICB0cnkge1xuICAgICAgICBjb25zdCBhY2NvdW50ID0gX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfU3RhbmRhcmRXYWxsZXRBZGFwdGVyX2FjY291bnQsIFwiZlwiKTtcbiAgICAgICAgaWYgKCFhY2NvdW50KVxuICAgICAgICAgICAgdGhyb3cgbmV3IFdhbGxldE5vdENvbm5lY3RlZEVycm9yKCk7XG4gICAgICAgIGlmICghKFNvbGFuYVNpZ25NZXNzYWdlIGluIF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX1N0YW5kYXJkV2FsbGV0QWRhcHRlcl93YWxsZXQsIFwiZlwiKS5mZWF0dXJlcykpXG4gICAgICAgICAgICB0aHJvdyBuZXcgV2FsbGV0Q29uZmlnRXJyb3IoKTtcbiAgICAgICAgaWYgKCFhY2NvdW50LmZlYXR1cmVzLmluY2x1ZGVzKFNvbGFuYVNpZ25NZXNzYWdlKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBXYWxsZXRBY2NvdW50RXJyb3IoKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHNpZ25lZE1lc3NhZ2VzID0gYXdhaXQgX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfU3RhbmRhcmRXYWxsZXRBZGFwdGVyX3dhbGxldCwgXCJmXCIpLmZlYXR1cmVzW1NvbGFuYVNpZ25NZXNzYWdlXS5zaWduTWVzc2FnZSh7XG4gICAgICAgICAgICAgICAgYWNjb3VudCxcbiAgICAgICAgICAgICAgICBtZXNzYWdlLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLW5vbi1udWxsLWFzc2VydGlvblxuICAgICAgICAgICAgcmV0dXJuIHNpZ25lZE1lc3NhZ2VzWzBdLnNpZ25hdHVyZTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBXYWxsZXRTaWduTWVzc2FnZUVycm9yKGVycm9yPy5tZXNzYWdlLCBlcnJvcik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIHRoaXMuZW1pdCgnZXJyb3InLCBlcnJvcik7XG4gICAgICAgIHRocm93IGVycm9yO1xuICAgIH1cbn0sIF9TdGFuZGFyZFdhbGxldEFkYXB0ZXJfc2lnbkluID0gYXN5bmMgZnVuY3Rpb24gX1N0YW5kYXJkV2FsbGV0QWRhcHRlcl9zaWduSW4oaW5wdXQgPSB7fSkge1xuICAgIHRyeSB7XG4gICAgICAgIGlmICghKFNvbGFuYVNpZ25JbiBpbiBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9TdGFuZGFyZFdhbGxldEFkYXB0ZXJfd2FsbGV0LCBcImZcIikuZmVhdHVyZXMpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFdhbGxldENvbmZpZ0Vycm9yKCk7XG4gICAgICAgIGxldCBvdXRwdXQ7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBbb3V0cHV0XSA9IGF3YWl0IF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX1N0YW5kYXJkV2FsbGV0QWRhcHRlcl93YWxsZXQsIFwiZlwiKS5mZWF0dXJlc1tTb2xhbmFTaWduSW5dLnNpZ25JbihpbnB1dCk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgV2FsbGV0U2lnbkluRXJyb3IoZXJyb3I/Lm1lc3NhZ2UsIGVycm9yKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIW91dHB1dClcbiAgICAgICAgICAgIHRocm93IG5ldyBXYWxsZXRTaWduSW5FcnJvcigpO1xuICAgICAgICBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9TdGFuZGFyZFdhbGxldEFkYXB0ZXJfaW5zdGFuY2VzLCBcIm1cIiwgX1N0YW5kYXJkV2FsbGV0QWRhcHRlcl9jb25uZWN0ZWQpLmNhbGwodGhpcywgb3V0cHV0LmFjY291bnQpO1xuICAgICAgICByZXR1cm4gb3V0cHV0O1xuICAgIH1cbiAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgdGhpcy5lbWl0KCdlcnJvcicsIGVycm9yKTtcbiAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWFkYXB0ZXIuanMubWFwIl0sIm5hbWVzIjpbIl9fY2xhc3NQcml2YXRlRmllbGRTZXQiLCJyZWNlaXZlciIsInN0YXRlIiwidmFsdWUiLCJraW5kIiwiZiIsIlR5cGVFcnJvciIsImhhcyIsImNhbGwiLCJzZXQiLCJfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0IiwiZ2V0IiwiX1N0YW5kYXJkV2FsbGV0QWRhcHRlcl9pbnN0YW5jZXMiLCJfU3RhbmRhcmRXYWxsZXRBZGFwdGVyX2FjY291bnQiLCJfU3RhbmRhcmRXYWxsZXRBZGFwdGVyX3B1YmxpY0tleSIsIl9TdGFuZGFyZFdhbGxldEFkYXB0ZXJfY29ubmVjdGluZyIsIl9TdGFuZGFyZFdhbGxldEFkYXB0ZXJfZGlzY29ubmVjdGluZyIsIl9TdGFuZGFyZFdhbGxldEFkYXB0ZXJfb2ZmIiwiX1N0YW5kYXJkV2FsbGV0QWRhcHRlcl9zdXBwb3J0ZWRUcmFuc2FjdGlvblZlcnNpb25zIiwiX1N0YW5kYXJkV2FsbGV0QWRhcHRlcl93YWxsZXQiLCJfU3RhbmRhcmRXYWxsZXRBZGFwdGVyX3JlYWR5U3RhdGUiLCJfU3RhbmRhcmRXYWxsZXRBZGFwdGVyX2Nvbm5lY3QiLCJfU3RhbmRhcmRXYWxsZXRBZGFwdGVyX2Nvbm5lY3RlZCIsIl9TdGFuZGFyZFdhbGxldEFkYXB0ZXJfZGlzY29ubmVjdGVkIiwiX1N0YW5kYXJkV2FsbGV0QWRhcHRlcl9yZXNldCIsIl9TdGFuZGFyZFdhbGxldEFkYXB0ZXJfY2hhbmdlZCIsIl9TdGFuZGFyZFdhbGxldEFkYXB0ZXJfc2lnblRyYW5zYWN0aW9uIiwiX1N0YW5kYXJkV2FsbGV0QWRhcHRlcl9zaWduQWxsVHJhbnNhY3Rpb25zIiwiX1N0YW5kYXJkV2FsbGV0QWRhcHRlcl9zaWduTWVzc2FnZSIsIl9TdGFuZGFyZFdhbGxldEFkYXB0ZXJfc2lnbkluIiwiQmFzZVdhbGxldEFkYXB0ZXIiLCJpc1ZlcnNpb25lZFRyYW5zYWN0aW9uIiwiV2FsbGV0QWNjb3VudEVycm9yIiwiV2FsbGV0Q29uZmlnRXJyb3IiLCJXYWxsZXRDb25uZWN0aW9uRXJyb3IiLCJXYWxsZXREaXNjb25uZWN0ZWRFcnJvciIsIldhbGxldERpc2Nvbm5lY3Rpb25FcnJvciIsIldhbGxldEVycm9yIiwiV2FsbGV0Tm90Q29ubmVjdGVkRXJyb3IiLCJXYWxsZXROb3RSZWFkeUVycm9yIiwiV2FsbGV0UHVibGljS2V5RXJyb3IiLCJXYWxsZXRSZWFkeVN0YXRlIiwiV2FsbGV0U2VuZFRyYW5zYWN0aW9uRXJyb3IiLCJXYWxsZXRTaWduSW5FcnJvciIsIldhbGxldFNpZ25NZXNzYWdlRXJyb3IiLCJXYWxsZXRTaWduVHJhbnNhY3Rpb25FcnJvciIsIlNvbGFuYVNpZ25BbmRTZW5kVHJhbnNhY3Rpb24iLCJTb2xhbmFTaWduSW4iLCJTb2xhbmFTaWduTWVzc2FnZSIsIlNvbGFuYVNpZ25UcmFuc2FjdGlvbiIsImdldENoYWluRm9yRW5kcG9pbnQiLCJnZXRDb21taXRtZW50IiwiUHVibGljS2V5IiwiVHJhbnNhY3Rpb24iLCJWZXJzaW9uZWRUcmFuc2FjdGlvbiIsIlN0YW5kYXJkQ29ubmVjdCIsIlN0YW5kYXJkRGlzY29ubmVjdCIsIlN0YW5kYXJkRXZlbnRzIiwiYXJyYXlzRXF1YWwiLCJiczU4IiwiU3RhbmRhcmRXYWxsZXRBZGFwdGVyIiwiY29uc3RydWN0b3IiLCJ3YWxsZXQiLCJhZGQiLCJkb2N1bWVudCIsIlVuc3VwcG9ydGVkIiwiSW5zdGFsbGVkIiwicHJvcGVydGllcyIsImFjY291bnQiLCJhY2NvdW50cyIsImVtaXQiLCJmZWF0dXJlcyIsIm9uIiwibmFtZSIsInVybCIsImljb24iLCJyZWFkeVN0YXRlIiwicHVibGljS2V5IiwiY29ubmVjdGluZyIsInN1cHBvcnRlZFRyYW5zYWN0aW9uVmVyc2lvbnMiLCJzdGFuZGFyZCIsImRlc3Ryb3kiLCJvZmYiLCJhdXRvQ29ubmVjdCIsInNpbGVudCIsImNvbm5lY3QiLCJkaXNjb25uZWN0IiwiZXJyb3IiLCJtZXNzYWdlIiwic2VuZFRyYW5zYWN0aW9uIiwidHJhbnNhY3Rpb24iLCJjb25uZWN0aW9uIiwib3B0aW9ucyIsImZlYXR1cmUiLCJpbmNsdWRlcyIsImNoYWluIiwicnBjRW5kcG9pbnQiLCJjaGFpbnMiLCJzaWduZXJzIiwic2VuZE9wdGlvbnMiLCJzZXJpYWxpemVkVHJhbnNhY3Rpb24iLCJsZW5ndGgiLCJzaWduIiwic2VyaWFsaXplIiwicHJlcGFyZVRyYW5zYWN0aW9uIiwicGFydGlhbFNpZ24iLCJVaW50OEFycmF5IiwicmVxdWlyZUFsbFNpZ25hdHVyZXMiLCJ2ZXJpZnlTaWduYXR1cmVzIiwib3V0cHV0Iiwic2lnbkFuZFNlbmRUcmFuc2FjdGlvbiIsInByZWZsaWdodENvbW1pdG1lbnQiLCJjb21taXRtZW50Iiwic2tpcFByZWZsaWdodCIsIm1heFJldHJpZXMiLCJtaW5Db250ZXh0U2xvdCIsImVuY29kZSIsInNpZ25hdHVyZSIsInNpZ25UcmFuc2FjdGlvbiIsInNlbmRSYXdUcmFuc2FjdGlvbiIsInNpZ25lZFRyYW5zYWN0aW9uIiwiV2Vha01hcCIsIldlYWtTZXQiLCJpbnB1dCIsImNvbm5lY3RlZCIsImFkZHJlc3MiLCJTZXQiLCJzaWduQWxsVHJhbnNhY3Rpb25zIiwic2lnbk1lc3NhZ2UiLCJzaWduSW4iLCJzaWduZWRUcmFuc2FjdGlvbnMiLCJkZXNlcmlhbGl6ZSIsImZyb20iLCJ0cmFuc2FjdGlvbnMiLCJtYXAiLCJpbmRleCIsInNpZ25lZE1lc3NhZ2VzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/@solana/wallet-standard-wallet-adapter-base/lib/esm/adapter.js\n");

/***/ }),

/***/ "(ssr)/../node_modules/@solana/wallet-standard-wallet-adapter-base/lib/esm/types.js":
/*!************************************************************************************!*\
  !*** ../node_modules/@solana/wallet-standard-wallet-adapter-base/lib/esm/types.js ***!
  \************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   isWalletAdapterCompatibleWallet: () => (/* binding */ isWalletAdapterCompatibleWallet)\n/* harmony export */ });\n/* harmony import */ var _solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @solana/wallet-adapter-base */ \"(ssr)/../node_modules/@solana/wallet-adapter-base/lib/esm/standard.js\");\n\n/**\n * @deprecated Use `isWalletAdapterCompatibleStandardWallet` from `@solana/wallet-adapter-base` instead.\n *\n * @group Deprecated\n */ const isWalletAdapterCompatibleWallet = _solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_0__.isWalletAdapterCompatibleStandardWallet; //# sourceMappingURL=types.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL0Bzb2xhbmEvd2FsbGV0LXN0YW5kYXJkLXdhbGxldC1hZGFwdGVyLWJhc2UvbGliL2VzbS90eXBlcy5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUF1RjtBQUN2Rjs7OztDQUlDLEdBQ00sTUFBTUMsa0NBQWtDRCxnR0FBdUNBLENBQUMsQ0FDdkYsaUNBQWlDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9Ac29sYW5hL3dhbGxldC1zdGFuZGFyZC13YWxsZXQtYWRhcHRlci1iYXNlL2xpYi9lc20vdHlwZXMuanM/OGQxOSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBpc1dhbGxldEFkYXB0ZXJDb21wYXRpYmxlU3RhbmRhcmRXYWxsZXQsIH0gZnJvbSAnQHNvbGFuYS93YWxsZXQtYWRhcHRlci1iYXNlJztcbi8qKlxuICogQGRlcHJlY2F0ZWQgVXNlIGBpc1dhbGxldEFkYXB0ZXJDb21wYXRpYmxlU3RhbmRhcmRXYWxsZXRgIGZyb20gYEBzb2xhbmEvd2FsbGV0LWFkYXB0ZXItYmFzZWAgaW5zdGVhZC5cbiAqXG4gKiBAZ3JvdXAgRGVwcmVjYXRlZFxuICovXG5leHBvcnQgY29uc3QgaXNXYWxsZXRBZGFwdGVyQ29tcGF0aWJsZVdhbGxldCA9IGlzV2FsbGV0QWRhcHRlckNvbXBhdGlibGVTdGFuZGFyZFdhbGxldDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXR5cGVzLmpzLm1hcCJdLCJuYW1lcyI6WyJpc1dhbGxldEFkYXB0ZXJDb21wYXRpYmxlU3RhbmRhcmRXYWxsZXQiLCJpc1dhbGxldEFkYXB0ZXJDb21wYXRpYmxlV2FsbGV0Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/@solana/wallet-standard-wallet-adapter-base/lib/esm/types.js\n");

/***/ }),

/***/ "(ssr)/../node_modules/@solana/wallet-standard-wallet-adapter-react/lib/esm/useStandardWalletAdapters.js":
/*!*********************************************************************************************************!*\
  !*** ../node_modules/@solana/wallet-standard-wallet-adapter-react/lib/esm/useStandardWalletAdapters.js ***!
  \*********************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   useStandardWalletAdapters: () => (/* binding */ useStandardWalletAdapters)\n/* harmony export */ });\n/* harmony import */ var _solana_wallet_standard_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @solana/wallet-standard-wallet-adapter-base */ \"(ssr)/../node_modules/@solana/wallet-standard-wallet-adapter-base/lib/esm/types.js\");\n/* harmony import */ var _solana_wallet_standard_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @solana/wallet-standard-wallet-adapter-base */ \"(ssr)/../node_modules/@solana/wallet-standard-wallet-adapter-base/lib/esm/adapter.js\");\n/* harmony import */ var _wallet_standard_app__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @wallet-standard/app */ \"(ssr)/../node_modules/@wallet-standard/app/lib/esm/wallets.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/../node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n\n\n\nfunction useStandardWalletAdapters(adapters) {\n    const warnings = useConstant(()=>new Set());\n    const { get, on } = useConstant(()=>(0,_wallet_standard_app__WEBPACK_IMPORTED_MODULE_1__.DEPRECATED_getWallets)());\n    const [standardAdapters, setStandardAdapters] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(()=>wrapWalletsWithAdapters(get()));\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        const listeners = [\n            on(\"register\", (...wallets)=>setStandardAdapters((standardAdapters)=>[\n                        ...standardAdapters,\n                        ...wrapWalletsWithAdapters(wallets)\n                    ])),\n            on(\"unregister\", (...wallets)=>setStandardAdapters((standardAdapters)=>standardAdapters.filter((standardAdapter)=>wallets.some((wallet)=>wallet === standardAdapter.wallet))))\n        ];\n        return ()=>listeners.forEach((off)=>off());\n    }, [\n        on\n    ]);\n    const prevStandardAdapters = usePrevious(standardAdapters);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        if (!prevStandardAdapters) return;\n        const currentAdapters = new Set(standardAdapters);\n        const removedAdapters = new Set(prevStandardAdapters.filter((previousAdapter)=>!currentAdapters.has(previousAdapter)));\n        removedAdapters.forEach((adapter)=>adapter.destroy());\n    }, [\n        prevStandardAdapters,\n        standardAdapters\n    ]);\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>()=>standardAdapters.forEach((adapter)=>adapter.destroy()), []);\n    return (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>[\n            ...standardAdapters,\n            ...adapters.filter(({ name })=>{\n                if (standardAdapters.some((standardAdapter)=>standardAdapter.name === name)) {\n                    if (!warnings.has(name)) {\n                        warnings.add(name);\n                        console.warn(`${name} was registered as a Standard Wallet. The Wallet Adapter for ${name} can be removed from your app.`);\n                    }\n                    return false;\n                }\n                return true;\n            })\n        ], [\n        standardAdapters,\n        adapters,\n        warnings\n    ]);\n}\nfunction useConstant(fn) {\n    const ref = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)();\n    if (!ref.current) {\n        ref.current = {\n            value: fn()\n        };\n    }\n    return ref.current.value;\n}\nfunction usePrevious(state) {\n    const ref = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)();\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        ref.current = state;\n    });\n    return ref.current;\n}\nfunction wrapWalletsWithAdapters(wallets) {\n    return wallets.filter(_solana_wallet_standard_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_2__.isWalletAdapterCompatibleWallet).map((wallet)=>new _solana_wallet_standard_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_3__.StandardWalletAdapter({\n            wallet\n        }));\n} //# sourceMappingURL=useStandardWalletAdapters.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL0Bzb2xhbmEvd2FsbGV0LXN0YW5kYXJkLXdhbGxldC1hZGFwdGVyLXJlYWN0L2xpYi9lc20vdXNlU3RhbmRhcmRXYWxsZXRBZGFwdGVycy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUFxSDtBQUN4RDtBQUNBO0FBQ3RELFNBQVNPLDBCQUEwQkMsUUFBUTtJQUM5QyxNQUFNQyxXQUFXQyxZQUFZLElBQU0sSUFBSUM7SUFDdkMsTUFBTSxFQUFFQyxHQUFHLEVBQUVDLEVBQUUsRUFBRSxHQUFHSCxZQUFZLElBQU1SLDJFQUFxQkE7SUFDM0QsTUFBTSxDQUFDWSxrQkFBa0JDLG9CQUFvQixHQUFHVCwrQ0FBUUEsQ0FBQyxJQUFNVSx3QkFBd0JKO0lBQ3ZGVCxnREFBU0EsQ0FBQztRQUNOLE1BQU1jLFlBQVk7WUFDZEosR0FBRyxZQUFZLENBQUMsR0FBR0ssVUFBWUgsb0JBQW9CLENBQUNELG1CQUFxQjsyQkFBSUE7MkJBQXFCRSx3QkFBd0JFO3FCQUFTO1lBQ25JTCxHQUFHLGNBQWMsQ0FBQyxHQUFHSyxVQUFZSCxvQkFBb0IsQ0FBQ0QsbUJBQXFCQSxpQkFBaUJLLE1BQU0sQ0FBQyxDQUFDQyxrQkFBb0JGLFFBQVFHLElBQUksQ0FBQyxDQUFDQyxTQUFXQSxXQUFXRixnQkFBZ0JFLE1BQU07U0FDckw7UUFDRCxPQUFPLElBQU1MLFVBQVVNLE9BQU8sQ0FBQyxDQUFDQyxNQUFRQTtJQUM1QyxHQUFHO1FBQUNYO0tBQUc7SUFDUCxNQUFNWSx1QkFBdUJDLFlBQVlaO0lBQ3pDWCxnREFBU0EsQ0FBQztRQUNOLElBQUksQ0FBQ3NCLHNCQUNEO1FBQ0osTUFBTUUsa0JBQWtCLElBQUloQixJQUFJRztRQUNoQyxNQUFNYyxrQkFBa0IsSUFBSWpCLElBQUljLHFCQUFxQk4sTUFBTSxDQUFDLENBQUNVLGtCQUFvQixDQUFDRixnQkFBZ0JHLEdBQUcsQ0FBQ0Q7UUFDdEdELGdCQUFnQkwsT0FBTyxDQUFDLENBQUNRLFVBQVlBLFFBQVFDLE9BQU87SUFDeEQsR0FBRztRQUFDUDtRQUFzQlg7S0FBaUI7SUFDM0MsdURBQXVEO0lBQ3ZEWCxnREFBU0EsQ0FBQyxJQUFNLElBQU1XLGlCQUFpQlMsT0FBTyxDQUFDLENBQUNRLFVBQVlBLFFBQVFDLE9BQU8sS0FBSyxFQUFFO0lBQ2xGLE9BQU81Qiw4Q0FBT0EsQ0FBQyxJQUFNO2VBQ2RVO2VBQ0FOLFNBQVNXLE1BQU0sQ0FBQyxDQUFDLEVBQUVjLElBQUksRUFBRTtnQkFDeEIsSUFBSW5CLGlCQUFpQk8sSUFBSSxDQUFDLENBQUNELGtCQUFvQkEsZ0JBQWdCYSxJQUFJLEtBQUtBLE9BQU87b0JBQzNFLElBQUksQ0FBQ3hCLFNBQVNxQixHQUFHLENBQUNHLE9BQU87d0JBQ3JCeEIsU0FBU3lCLEdBQUcsQ0FBQ0Q7d0JBQ2JFLFFBQVFDLElBQUksQ0FBQyxDQUFDLEVBQUVILEtBQUssNkRBQTZELEVBQUVBLEtBQUssOEJBQThCLENBQUM7b0JBQzVIO29CQUNBLE9BQU87Z0JBQ1g7Z0JBQ0EsT0FBTztZQUNYO1NBQ0gsRUFBRTtRQUFDbkI7UUFBa0JOO1FBQVVDO0tBQVM7QUFDN0M7QUFDQSxTQUFTQyxZQUFZMkIsRUFBRTtJQUNuQixNQUFNQyxNQUFNakMsNkNBQU1BO0lBQ2xCLElBQUksQ0FBQ2lDLElBQUlDLE9BQU8sRUFBRTtRQUNkRCxJQUFJQyxPQUFPLEdBQUc7WUFBRUMsT0FBT0g7UUFBSztJQUNoQztJQUNBLE9BQU9DLElBQUlDLE9BQU8sQ0FBQ0MsS0FBSztBQUM1QjtBQUNBLFNBQVNkLFlBQVllLEtBQUs7SUFDdEIsTUFBTUgsTUFBTWpDLDZDQUFNQTtJQUNsQkYsZ0RBQVNBLENBQUM7UUFDTm1DLElBQUlDLE9BQU8sR0FBR0U7SUFDbEI7SUFDQSxPQUFPSCxJQUFJQyxPQUFPO0FBQ3RCO0FBQ0EsU0FBU3ZCLHdCQUF3QkUsT0FBTztJQUNwQyxPQUFPQSxRQUFRQyxNQUFNLENBQUNuQix3R0FBK0JBLEVBQUUwQyxHQUFHLENBQUMsQ0FBQ3BCLFNBQVcsSUFBSXJCLDhGQUFxQkEsQ0FBQztZQUFFcUI7UUFBTztBQUM5RyxFQUNBLHFEQUFxRCIsInNvdXJjZXMiOlsid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvQHNvbGFuYS93YWxsZXQtc3RhbmRhcmQtd2FsbGV0LWFkYXB0ZXItcmVhY3QvbGliL2VzbS91c2VTdGFuZGFyZFdhbGxldEFkYXB0ZXJzLmpzPzI1MmYiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgaXNXYWxsZXRBZGFwdGVyQ29tcGF0aWJsZVdhbGxldCwgU3RhbmRhcmRXYWxsZXRBZGFwdGVyIH0gZnJvbSAnQHNvbGFuYS93YWxsZXQtc3RhbmRhcmQtd2FsbGV0LWFkYXB0ZXItYmFzZSc7XG5pbXBvcnQgeyBERVBSRUNBVEVEX2dldFdhbGxldHMgfSBmcm9tICdAd2FsbGV0LXN0YW5kYXJkL2FwcCc7XG5pbXBvcnQgeyB1c2VFZmZlY3QsIHVzZU1lbW8sIHVzZVJlZiwgdXNlU3RhdGUgfSBmcm9tICdyZWFjdCc7XG5leHBvcnQgZnVuY3Rpb24gdXNlU3RhbmRhcmRXYWxsZXRBZGFwdGVycyhhZGFwdGVycykge1xuICAgIGNvbnN0IHdhcm5pbmdzID0gdXNlQ29uc3RhbnQoKCkgPT4gbmV3IFNldCgpKTtcbiAgICBjb25zdCB7IGdldCwgb24gfSA9IHVzZUNvbnN0YW50KCgpID0+IERFUFJFQ0FURURfZ2V0V2FsbGV0cygpKTtcbiAgICBjb25zdCBbc3RhbmRhcmRBZGFwdGVycywgc2V0U3RhbmRhcmRBZGFwdGVyc10gPSB1c2VTdGF0ZSgoKSA9PiB3cmFwV2FsbGV0c1dpdGhBZGFwdGVycyhnZXQoKSkpO1xuICAgIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICAgIGNvbnN0IGxpc3RlbmVycyA9IFtcbiAgICAgICAgICAgIG9uKCdyZWdpc3RlcicsICguLi53YWxsZXRzKSA9PiBzZXRTdGFuZGFyZEFkYXB0ZXJzKChzdGFuZGFyZEFkYXB0ZXJzKSA9PiBbLi4uc3RhbmRhcmRBZGFwdGVycywgLi4ud3JhcFdhbGxldHNXaXRoQWRhcHRlcnMod2FsbGV0cyldKSksXG4gICAgICAgICAgICBvbigndW5yZWdpc3RlcicsICguLi53YWxsZXRzKSA9PiBzZXRTdGFuZGFyZEFkYXB0ZXJzKChzdGFuZGFyZEFkYXB0ZXJzKSA9PiBzdGFuZGFyZEFkYXB0ZXJzLmZpbHRlcigoc3RhbmRhcmRBZGFwdGVyKSA9PiB3YWxsZXRzLnNvbWUoKHdhbGxldCkgPT4gd2FsbGV0ID09PSBzdGFuZGFyZEFkYXB0ZXIud2FsbGV0KSkpKSxcbiAgICAgICAgXTtcbiAgICAgICAgcmV0dXJuICgpID0+IGxpc3RlbmVycy5mb3JFYWNoKChvZmYpID0+IG9mZigpKTtcbiAgICB9LCBbb25dKTtcbiAgICBjb25zdCBwcmV2U3RhbmRhcmRBZGFwdGVycyA9IHVzZVByZXZpb3VzKHN0YW5kYXJkQWRhcHRlcnMpO1xuICAgIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICAgIGlmICghcHJldlN0YW5kYXJkQWRhcHRlcnMpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGNvbnN0IGN1cnJlbnRBZGFwdGVycyA9IG5ldyBTZXQoc3RhbmRhcmRBZGFwdGVycyk7XG4gICAgICAgIGNvbnN0IHJlbW92ZWRBZGFwdGVycyA9IG5ldyBTZXQocHJldlN0YW5kYXJkQWRhcHRlcnMuZmlsdGVyKChwcmV2aW91c0FkYXB0ZXIpID0+ICFjdXJyZW50QWRhcHRlcnMuaGFzKHByZXZpb3VzQWRhcHRlcikpKTtcbiAgICAgICAgcmVtb3ZlZEFkYXB0ZXJzLmZvckVhY2goKGFkYXB0ZXIpID0+IGFkYXB0ZXIuZGVzdHJveSgpKTtcbiAgICB9LCBbcHJldlN0YW5kYXJkQWRhcHRlcnMsIHN0YW5kYXJkQWRhcHRlcnNdKTtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaG9va3MvZXhoYXVzdGl2ZS1kZXBzXG4gICAgdXNlRWZmZWN0KCgpID0+ICgpID0+IHN0YW5kYXJkQWRhcHRlcnMuZm9yRWFjaCgoYWRhcHRlcikgPT4gYWRhcHRlci5kZXN0cm95KCkpLCBbXSk7XG4gICAgcmV0dXJuIHVzZU1lbW8oKCkgPT4gW1xuICAgICAgICAuLi5zdGFuZGFyZEFkYXB0ZXJzLFxuICAgICAgICAuLi5hZGFwdGVycy5maWx0ZXIoKHsgbmFtZSB9KSA9PiB7XG4gICAgICAgICAgICBpZiAoc3RhbmRhcmRBZGFwdGVycy5zb21lKChzdGFuZGFyZEFkYXB0ZXIpID0+IHN0YW5kYXJkQWRhcHRlci5uYW1lID09PSBuYW1lKSkge1xuICAgICAgICAgICAgICAgIGlmICghd2FybmluZ3MuaGFzKG5hbWUpKSB7XG4gICAgICAgICAgICAgICAgICAgIHdhcm5pbmdzLmFkZChuYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS53YXJuKGAke25hbWV9IHdhcyByZWdpc3RlcmVkIGFzIGEgU3RhbmRhcmQgV2FsbGV0LiBUaGUgV2FsbGV0IEFkYXB0ZXIgZm9yICR7bmFtZX0gY2FuIGJlIHJlbW92ZWQgZnJvbSB5b3VyIGFwcC5gKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH0pLFxuICAgIF0sIFtzdGFuZGFyZEFkYXB0ZXJzLCBhZGFwdGVycywgd2FybmluZ3NdKTtcbn1cbmZ1bmN0aW9uIHVzZUNvbnN0YW50KGZuKSB7XG4gICAgY29uc3QgcmVmID0gdXNlUmVmKCk7XG4gICAgaWYgKCFyZWYuY3VycmVudCkge1xuICAgICAgICByZWYuY3VycmVudCA9IHsgdmFsdWU6IGZuKCkgfTtcbiAgICB9XG4gICAgcmV0dXJuIHJlZi5jdXJyZW50LnZhbHVlO1xufVxuZnVuY3Rpb24gdXNlUHJldmlvdXMoc3RhdGUpIHtcbiAgICBjb25zdCByZWYgPSB1c2VSZWYoKTtcbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgICByZWYuY3VycmVudCA9IHN0YXRlO1xuICAgIH0pO1xuICAgIHJldHVybiByZWYuY3VycmVudDtcbn1cbmZ1bmN0aW9uIHdyYXBXYWxsZXRzV2l0aEFkYXB0ZXJzKHdhbGxldHMpIHtcbiAgICByZXR1cm4gd2FsbGV0cy5maWx0ZXIoaXNXYWxsZXRBZGFwdGVyQ29tcGF0aWJsZVdhbGxldCkubWFwKCh3YWxsZXQpID0+IG5ldyBTdGFuZGFyZFdhbGxldEFkYXB0ZXIoeyB3YWxsZXQgfSkpO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dXNlU3RhbmRhcmRXYWxsZXRBZGFwdGVycy5qcy5tYXAiXSwibmFtZXMiOlsiaXNXYWxsZXRBZGFwdGVyQ29tcGF0aWJsZVdhbGxldCIsIlN0YW5kYXJkV2FsbGV0QWRhcHRlciIsIkRFUFJFQ0FURURfZ2V0V2FsbGV0cyIsInVzZUVmZmVjdCIsInVzZU1lbW8iLCJ1c2VSZWYiLCJ1c2VTdGF0ZSIsInVzZVN0YW5kYXJkV2FsbGV0QWRhcHRlcnMiLCJhZGFwdGVycyIsIndhcm5pbmdzIiwidXNlQ29uc3RhbnQiLCJTZXQiLCJnZXQiLCJvbiIsInN0YW5kYXJkQWRhcHRlcnMiLCJzZXRTdGFuZGFyZEFkYXB0ZXJzIiwid3JhcFdhbGxldHNXaXRoQWRhcHRlcnMiLCJsaXN0ZW5lcnMiLCJ3YWxsZXRzIiwiZmlsdGVyIiwic3RhbmRhcmRBZGFwdGVyIiwic29tZSIsIndhbGxldCIsImZvckVhY2giLCJvZmYiLCJwcmV2U3RhbmRhcmRBZGFwdGVycyIsInVzZVByZXZpb3VzIiwiY3VycmVudEFkYXB0ZXJzIiwicmVtb3ZlZEFkYXB0ZXJzIiwicHJldmlvdXNBZGFwdGVyIiwiaGFzIiwiYWRhcHRlciIsImRlc3Ryb3kiLCJuYW1lIiwiYWRkIiwiY29uc29sZSIsIndhcm4iLCJmbiIsInJlZiIsImN1cnJlbnQiLCJ2YWx1ZSIsInN0YXRlIiwibWFwIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/@solana/wallet-standard-wallet-adapter-react/lib/esm/useStandardWalletAdapters.js\n");

/***/ })

};
;