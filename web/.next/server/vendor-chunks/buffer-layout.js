"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/buffer-layout";
exports.ids = ["vendor-chunks/buffer-layout"];
exports.modules = {

/***/ "(ssr)/../anchor/node_modules/buffer-layout/lib/Layout.js":
/*!**********************************************************!*\
  !*** ../anchor/node_modules/buffer-layout/lib/Layout.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("/* The MIT License (MIT)\n *\n * Copyright 2015-2018 Peter A. Bigot\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n */ /**\n * Support for translating between Buffer instances and JavaScript\n * native types.\n *\n * {@link module:Layout~Layout|Layout} is the basis of a class\n * hierarchy that associates property names with sequences of encoded\n * bytes.\n *\n * Layouts are supported for these scalar (numeric) types:\n * * {@link module:Layout~UInt|Unsigned integers in little-endian\n *   format} with {@link module:Layout.u8|8-bit}, {@link\n *   module:Layout.u16|16-bit}, {@link module:Layout.u24|24-bit},\n *   {@link module:Layout.u32|32-bit}, {@link\n *   module:Layout.u40|40-bit}, and {@link module:Layout.u48|48-bit}\n *   representation ranges;\n * * {@link module:Layout~UIntBE|Unsigned integers in big-endian\n *   format} with {@link module:Layout.u16be|16-bit}, {@link\n *   module:Layout.u24be|24-bit}, {@link module:Layout.u32be|32-bit},\n *   {@link module:Layout.u40be|40-bit}, and {@link\n *   module:Layout.u48be|48-bit} representation ranges;\n * * {@link module:Layout~Int|Signed integers in little-endian\n *   format} with {@link module:Layout.s8|8-bit}, {@link\n *   module:Layout.s16|16-bit}, {@link module:Layout.s24|24-bit},\n *   {@link module:Layout.s32|32-bit}, {@link\n *   module:Layout.s40|40-bit}, and {@link module:Layout.s48|48-bit}\n *   representation ranges;\n * * {@link module:Layout~IntBE|Signed integers in big-endian format}\n *   with {@link module:Layout.s16be|16-bit}, {@link\n *   module:Layout.s24be|24-bit}, {@link module:Layout.s32be|32-bit},\n *   {@link module:Layout.s40be|40-bit}, and {@link\n *   module:Layout.s48be|48-bit} representation ranges;\n * * 64-bit integral values that decode to an exact (if magnitude is\n *   less than 2^53) or nearby integral Number in {@link\n *   module:Layout.nu64|unsigned little-endian}, {@link\n *   module:Layout.nu64be|unsigned big-endian}, {@link\n *   module:Layout.ns64|signed little-endian}, and {@link\n *   module:Layout.ns64be|unsigned big-endian} encodings;\n * * 32-bit floating point values with {@link\n *   module:Layout.f32|little-endian} and {@link\n *   module:Layout.f32be|big-endian} representations;\n * * 64-bit floating point values with {@link\n *   module:Layout.f64|little-endian} and {@link\n *   module:Layout.f64be|big-endian} representations;\n * * {@link module:Layout.const|Constants} that take no space in the\n *   encoded expression.\n *\n * and for these aggregate types:\n * * {@link module:Layout.seq|Sequence}s of instances of a {@link\n *   module:Layout~Layout|Layout}, with JavaScript representation as\n *   an Array and constant or data-dependent {@link\n *   module:Layout~Sequence#count|length};\n * * {@link module:Layout.struct|Structure}s that aggregate a\n *   heterogeneous sequence of {@link module:Layout~Layout|Layout}\n *   instances, with JavaScript representation as an Object;\n * * {@link module:Layout.union|Union}s that support multiple {@link\n *   module:Layout~VariantLayout|variant layouts} over a fixed\n *   (padded) or variable (not padded) span of bytes, using an\n *   unsigned integer at the start of the data or a separate {@link\n *   module:Layout.unionLayoutDiscriminator|layout element} to\n *   determine which layout to use when interpreting the buffer\n *   contents;\n * * {@link module:Layout.bits|BitStructure}s that contain a sequence\n *   of individual {@link\n *   module:Layout~BitStructure#addField|BitField}s packed into an 8,\n *   16, 24, or 32-bit unsigned integer starting at the least- or\n *   most-significant bit;\n * * {@link module:Layout.cstr|C strings} of varying length;\n * * {@link module:Layout.blob|Blobs} of fixed- or variable-{@link\n *   module:Layout~Blob#length|length} raw data.\n *\n * All {@link module:Layout~Layout|Layout} instances are immutable\n * after construction, to prevent internal state from becoming\n * inconsistent.\n *\n * @local Layout\n * @local ExternalLayout\n * @local GreedyCount\n * @local OffsetLayout\n * @local UInt\n * @local UIntBE\n * @local Int\n * @local IntBE\n * @local NearUInt64\n * @local NearUInt64BE\n * @local NearInt64\n * @local NearInt64BE\n * @local Float\n * @local FloatBE\n * @local Double\n * @local DoubleBE\n * @local Sequence\n * @local Structure\n * @local UnionDiscriminator\n * @local UnionLayoutDiscriminator\n * @local Union\n * @local VariantLayout\n * @local BitStructure\n * @local BitField\n * @local Boolean\n * @local Blob\n * @local CString\n * @local Constant\n * @local bindConstructorLayout\n * @module Layout\n * @license MIT\n * @author Peter A. Bigot\n * @see {@link https://github.com/pabigot/buffer-layout|buffer-layout on GitHub}\n */ \n/**\n * Base class for layout objects.\n *\n * **NOTE** This is an abstract base class; you can create instances\n * if it amuses you, but they won't support the {@link\n * Layout#encode|encode} or {@link Layout#decode|decode} functions.\n *\n * @param {Number} span - Initializer for {@link Layout#span|span}.  The\n * parameter must be an integer; a negative value signifies that the\n * span is {@link Layout#getSpan|value-specific}.\n *\n * @param {string} [property] - Initializer for {@link\n * Layout#property|property}.\n *\n * @abstract\n */ class Layout {\n    constructor(span, property){\n        if (!Number.isInteger(span)) {\n            throw new TypeError(\"span must be an integer\");\n        }\n        /** The span of the layout in bytes.\n     *\n     * Positive values are generally expected.\n     *\n     * Zero will only appear in {@link Constant}s and in {@link\n     * Sequence}s where the {@link Sequence#count|count} is zero.\n     *\n     * A negative value indicates that the span is value-specific, and\n     * must be obtained using {@link Layout#getSpan|getSpan}. */ this.span = span;\n        /** The property name used when this layout is represented in an\n     * Object.\n     *\n     * Used only for layouts that {@link Layout#decode|decode} to Object\n     * instances.  If left undefined the span of the unnamed layout will\n     * be treated as padding: it will not be mutated by {@link\n     * Layout#encode|encode} nor represented as a property in the\n     * decoded Object. */ this.property = property;\n    }\n    /** Function to create an Object into which decoded properties will\n   * be written.\n   *\n   * Used only for layouts that {@link Layout#decode|decode} to Object\n   * instances, which means:\n   * * {@link Structure}\n   * * {@link Union}\n   * * {@link VariantLayout}\n   * * {@link BitStructure}\n   *\n   * If left undefined the JavaScript representation of these layouts\n   * will be Object instances.\n   *\n   * See {@link bindConstructorLayout}.\n   */ makeDestinationObject() {\n        return {};\n    }\n    /**\n   * Decode from a Buffer into an JavaScript value.\n   *\n   * @param {Buffer} b - the buffer from which encoded data is read.\n   *\n   * @param {Number} [offset] - the offset at which the encoded data\n   * starts.  If absent a zero offset is inferred.\n   *\n   * @returns {(Number|Array|Object)} - the value of the decoded data.\n   *\n   * @abstract\n   */ decode(b, offset) {\n        throw new Error(\"Layout is abstract\");\n    }\n    /**\n   * Encode a JavaScript value into a Buffer.\n   *\n   * @param {(Number|Array|Object)} src - the value to be encoded into\n   * the buffer.  The type accepted depends on the (sub-)type of {@link\n   * Layout}.\n   *\n   * @param {Buffer} b - the buffer into which encoded data will be\n   * written.\n   *\n   * @param {Number} [offset] - the offset at which the encoded data\n   * starts.  If absent a zero offset is inferred.\n   *\n   * @returns {Number} - the number of bytes encoded, including the\n   * space skipped for internal padding, but excluding data such as\n   * {@link Sequence#count|lengths} when stored {@link\n   * ExternalLayout|externally}.  This is the adjustment to `offset`\n   * producing the offset where data for the next layout would be\n   * written.\n   *\n   * @abstract\n   */ encode(src, b, offset) {\n        throw new Error(\"Layout is abstract\");\n    }\n    /**\n   * Calculate the span of a specific instance of a layout.\n   *\n   * @param {Buffer} b - the buffer that contains an encoded instance.\n   *\n   * @param {Number} [offset] - the offset at which the encoded instance\n   * starts.  If absent a zero offset is inferred.\n   *\n   * @return {Number} - the number of bytes covered by the layout\n   * instance.  If this method is not overridden in a subclass the\n   * definition-time constant {@link Layout#span|span} will be\n   * returned.\n   *\n   * @throws {RangeError} - if the length of the value cannot be\n   * determined.\n   */ getSpan(b, offset) {\n        if (0 > this.span) {\n            throw new RangeError(\"indeterminate span\");\n        }\n        return this.span;\n    }\n    /**\n   * Replicate the layout using a new property.\n   *\n   * This function must be used to get a structurally-equivalent layout\n   * with a different name since all {@link Layout} instances are\n   * immutable.\n   *\n   * **NOTE** This is a shallow copy.  All fields except {@link\n   * Layout#property|property} are strictly equal to the origin layout.\n   *\n   * @param {String} property - the value for {@link\n   * Layout#property|property} in the replica.\n   *\n   * @returns {Layout} - the copy with {@link Layout#property|property}\n   * set to `property`.\n   */ replicate(property) {\n        const rv = Object.create(this.constructor.prototype);\n        Object.assign(rv, this);\n        rv.property = property;\n        return rv;\n    }\n    /**\n   * Create an object from layout properties and an array of values.\n   *\n   * **NOTE** This function returns `undefined` if invoked on a layout\n   * that does not return its value as an Object.  Objects are\n   * returned for things that are a {@link Structure}, which includes\n   * {@link VariantLayout|variant layouts} if they are structures, and\n   * excludes {@link Union}s.  If you want this feature for a union\n   * you must use {@link Union.getVariant|getVariant} to select the\n   * desired layout.\n   *\n   * @param {Array} values - an array of values that correspond to the\n   * default order for properties.  As with {@link Layout#decode|decode}\n   * layout elements that have no property name are skipped when\n   * iterating over the array values.  Only the top-level properties are\n   * assigned; arguments are not assigned to properties of contained\n   * layouts.  Any unused values are ignored.\n   *\n   * @return {(Object|undefined)}\n   */ fromArray(values) {\n        return undefined;\n    }\n}\nexports.Layout = Layout;\n/* Provide text that carries a name (such as for a function that will\n * be throwing an error) annotated with the property of a given layout\n * (such as one for which the value was unacceptable).\n *\n * @ignore */ function nameWithProperty(name, lo) {\n    if (lo.property) {\n        return name + \"[\" + lo.property + \"]\";\n    }\n    return name;\n}\nexports.nameWithProperty = nameWithProperty;\n/**\n * Augment a class so that instances can be encoded/decoded using a\n * given layout.\n *\n * Calling this function couples `Class` with `layout` in several ways:\n *\n * * `Class.layout_` becomes a static member property equal to `layout`;\n * * `layout.boundConstructor_` becomes a static member property equal\n *    to `Class`;\n * * The {@link Layout#makeDestinationObject|makeDestinationObject()}\n *   property of `layout` is set to a function that returns a `new\n *   Class()`;\n * * `Class.decode(b, offset)` becomes a static member function that\n *   delegates to {@link Layout#decode|layout.decode}.  The\n *   synthesized function may be captured and extended.\n * * `Class.prototype.encode(b, offset)` provides an instance member\n *   function that delegates to {@link Layout#encode|layout.encode}\n *   with `src` set to `this`.  The synthesized function may be\n *   captured and extended, but when the extension is invoked `this`\n *   must be explicitly bound to the instance.\n *\n * @param {class} Class - a JavaScript class with a nullary\n * constructor.\n *\n * @param {Layout} layout - the {@link Layout} instance used to encode\n * instances of `Class`.\n */ function bindConstructorLayout(Class, layout) {\n    if (\"function\" !== typeof Class) {\n        throw new TypeError(\"Class must be constructor\");\n    }\n    if (Class.hasOwnProperty(\"layout_\")) {\n        throw new Error(\"Class is already bound to a layout\");\n    }\n    if (!(layout && layout instanceof Layout)) {\n        throw new TypeError(\"layout must be a Layout\");\n    }\n    if (layout.hasOwnProperty(\"boundConstructor_\")) {\n        throw new Error(\"layout is already bound to a constructor\");\n    }\n    Class.layout_ = layout;\n    layout.boundConstructor_ = Class;\n    layout.makeDestinationObject = ()=>new Class();\n    Object.defineProperty(Class.prototype, \"encode\", {\n        value: function(b, offset) {\n            return layout.encode(this, b, offset);\n        },\n        writable: true\n    });\n    Object.defineProperty(Class, \"decode\", {\n        value: function(b, offset) {\n            return layout.decode(b, offset);\n        },\n        writable: true\n    });\n}\nexports.bindConstructorLayout = bindConstructorLayout;\n/**\n * An object that behaves like a layout but does not consume space\n * within its containing layout.\n *\n * This is primarily used to obtain metadata about a member, such as a\n * {@link OffsetLayout} that can provide data about a {@link\n * Layout#getSpan|value-specific span}.\n *\n * **NOTE** This is an abstract base class; you can create instances\n * if it amuses you, but they won't support {@link\n * ExternalLayout#isCount|isCount} or other {@link Layout} functions.\n *\n * @param {Number} span - initializer for {@link Layout#span|span}.\n * The parameter can range from 1 through 6.\n *\n * @param {string} [property] - initializer for {@link\n * Layout#property|property}.\n *\n * @abstract\n * @augments {Layout}\n */ class ExternalLayout extends Layout {\n    /**\n   * Return `true` iff the external layout decodes to an unsigned\n   * integer layout.\n   *\n   * In that case it can be used as the source of {@link\n   * Sequence#count|Sequence counts}, {@link Blob#length|Blob lengths},\n   * or as {@link UnionLayoutDiscriminator#layout|external union\n   * discriminators}.\n   *\n   * @abstract\n   */ isCount() {\n        throw new Error(\"ExternalLayout is abstract\");\n    }\n}\n/**\n * An {@link ExternalLayout} that determines its {@link\n * Layout#decode|value} based on offset into and length of the buffer\n * on which it is invoked.\n *\n * *Factory*: {@link module:Layout.greedy|greedy}\n *\n * @param {Number} [elementSpan] - initializer for {@link\n * GreedyCount#elementSpan|elementSpan}.\n *\n * @param {string} [property] - initializer for {@link\n * Layout#property|property}.\n *\n * @augments {ExternalLayout}\n */ class GreedyCount extends ExternalLayout {\n    constructor(elementSpan, property){\n        if (undefined === elementSpan) {\n            elementSpan = 1;\n        }\n        if (!Number.isInteger(elementSpan) || 0 >= elementSpan) {\n            throw new TypeError(\"elementSpan must be a (positive) integer\");\n        }\n        super(-1, property);\n        /** The layout for individual elements of the sequence.  The value\n     * must be a positive integer.  If not provided, the value will be\n     * 1. */ this.elementSpan = elementSpan;\n    }\n    /** @override */ isCount() {\n        return true;\n    }\n    /** @override */ decode(b, offset) {\n        if (undefined === offset) {\n            offset = 0;\n        }\n        const rem = b.length - offset;\n        return Math.floor(rem / this.elementSpan);\n    }\n    /** @override */ encode(src, b, offset) {\n        return 0;\n    }\n}\n/**\n * An {@link ExternalLayout} that supports accessing a {@link Layout}\n * at a fixed offset from the start of another Layout.  The offset may\n * be before, within, or after the base layout.\n *\n * *Factory*: {@link module:Layout.offset|offset}\n *\n * @param {Layout} layout - initializer for {@link\n * OffsetLayout#layout|layout}, modulo `property`.\n *\n * @param {Number} [offset] - Initializes {@link\n * OffsetLayout#offset|offset}.  Defaults to zero.\n *\n * @param {string} [property] - Optional new property name for a\n * {@link Layout#replicate| replica} of `layout` to be used as {@link\n * OffsetLayout#layout|layout}.  If not provided the `layout` is used\n * unchanged.\n *\n * @augments {Layout}\n */ class OffsetLayout extends ExternalLayout {\n    constructor(layout, offset, property){\n        if (!(layout instanceof Layout)) {\n            throw new TypeError(\"layout must be a Layout\");\n        }\n        if (undefined === offset) {\n            offset = 0;\n        } else if (!Number.isInteger(offset)) {\n            throw new TypeError(\"offset must be integer or undefined\");\n        }\n        super(layout.span, property || layout.property);\n        /** The subordinated layout. */ this.layout = layout;\n        /** The location of {@link OffsetLayout#layout} relative to the\n     * start of another layout.\n     *\n     * The value may be positive or negative, but an error will thrown\n     * if at the point of use it goes outside the span of the Buffer\n     * being accessed.  */ this.offset = offset;\n    }\n    /** @override */ isCount() {\n        return this.layout instanceof UInt || this.layout instanceof UIntBE;\n    }\n    /** @override */ decode(b, offset) {\n        if (undefined === offset) {\n            offset = 0;\n        }\n        return this.layout.decode(b, offset + this.offset);\n    }\n    /** @override */ encode(src, b, offset) {\n        if (undefined === offset) {\n            offset = 0;\n        }\n        return this.layout.encode(src, b, offset + this.offset);\n    }\n}\n/**\n * Represent an unsigned integer in little-endian format.\n *\n * *Factory*: {@link module:Layout.u8|u8}, {@link\n *  module:Layout.u16|u16}, {@link module:Layout.u24|u24}, {@link\n *  module:Layout.u32|u32}, {@link module:Layout.u40|u40}, {@link\n *  module:Layout.u48|u48}\n *\n * @param {Number} span - initializer for {@link Layout#span|span}.\n * The parameter can range from 1 through 6.\n *\n * @param {string} [property] - initializer for {@link\n * Layout#property|property}.\n *\n * @augments {Layout}\n */ class UInt extends Layout {\n    constructor(span, property){\n        super(span, property);\n        if (6 < this.span) {\n            throw new RangeError(\"span must not exceed 6 bytes\");\n        }\n    }\n    /** @override */ decode(b, offset) {\n        if (undefined === offset) {\n            offset = 0;\n        }\n        return b.readUIntLE(offset, this.span);\n    }\n    /** @override */ encode(src, b, offset) {\n        if (undefined === offset) {\n            offset = 0;\n        }\n        b.writeUIntLE(src, offset, this.span);\n        return this.span;\n    }\n}\n/**\n * Represent an unsigned integer in big-endian format.\n *\n * *Factory*: {@link module:Layout.u8be|u8be}, {@link\n * module:Layout.u16be|u16be}, {@link module:Layout.u24be|u24be},\n * {@link module:Layout.u32be|u32be}, {@link\n * module:Layout.u40be|u40be}, {@link module:Layout.u48be|u48be}\n *\n * @param {Number} span - initializer for {@link Layout#span|span}.\n * The parameter can range from 1 through 6.\n *\n * @param {string} [property] - initializer for {@link\n * Layout#property|property}.\n *\n * @augments {Layout}\n */ class UIntBE extends Layout {\n    constructor(span, property){\n        super(span, property);\n        if (6 < this.span) {\n            throw new RangeError(\"span must not exceed 6 bytes\");\n        }\n    }\n    /** @override */ decode(b, offset) {\n        if (undefined === offset) {\n            offset = 0;\n        }\n        return b.readUIntBE(offset, this.span);\n    }\n    /** @override */ encode(src, b, offset) {\n        if (undefined === offset) {\n            offset = 0;\n        }\n        b.writeUIntBE(src, offset, this.span);\n        return this.span;\n    }\n}\n/**\n * Represent a signed integer in little-endian format.\n *\n * *Factory*: {@link module:Layout.s8|s8}, {@link\n *  module:Layout.s16|s16}, {@link module:Layout.s24|s24}, {@link\n *  module:Layout.s32|s32}, {@link module:Layout.s40|s40}, {@link\n *  module:Layout.s48|s48}\n *\n * @param {Number} span - initializer for {@link Layout#span|span}.\n * The parameter can range from 1 through 6.\n *\n * @param {string} [property] - initializer for {@link\n * Layout#property|property}.\n *\n * @augments {Layout}\n */ class Int extends Layout {\n    constructor(span, property){\n        super(span, property);\n        if (6 < this.span) {\n            throw new RangeError(\"span must not exceed 6 bytes\");\n        }\n    }\n    /** @override */ decode(b, offset) {\n        if (undefined === offset) {\n            offset = 0;\n        }\n        return b.readIntLE(offset, this.span);\n    }\n    /** @override */ encode(src, b, offset) {\n        if (undefined === offset) {\n            offset = 0;\n        }\n        b.writeIntLE(src, offset, this.span);\n        return this.span;\n    }\n}\n/**\n * Represent a signed integer in big-endian format.\n *\n * *Factory*: {@link module:Layout.s8be|s8be}, {@link\n * module:Layout.s16be|s16be}, {@link module:Layout.s24be|s24be},\n * {@link module:Layout.s32be|s32be}, {@link\n * module:Layout.s40be|s40be}, {@link module:Layout.s48be|s48be}\n *\n * @param {Number} span - initializer for {@link Layout#span|span}.\n * The parameter can range from 1 through 6.\n *\n * @param {string} [property] - initializer for {@link\n * Layout#property|property}.\n *\n * @augments {Layout}\n */ class IntBE extends Layout {\n    constructor(span, property){\n        super(span, property);\n        if (6 < this.span) {\n            throw new RangeError(\"span must not exceed 6 bytes\");\n        }\n    }\n    /** @override */ decode(b, offset) {\n        if (undefined === offset) {\n            offset = 0;\n        }\n        return b.readIntBE(offset, this.span);\n    }\n    /** @override */ encode(src, b, offset) {\n        if (undefined === offset) {\n            offset = 0;\n        }\n        b.writeIntBE(src, offset, this.span);\n        return this.span;\n    }\n}\nconst V2E32 = Math.pow(2, 32);\n/* True modulus high and low 32-bit words, where low word is always\n * non-negative. */ function divmodInt64(src) {\n    const hi32 = Math.floor(src / V2E32);\n    const lo32 = src - hi32 * V2E32;\n    return {\n        hi32,\n        lo32\n    };\n}\n/* Reconstruct Number from quotient and non-negative remainder */ function roundedInt64(hi32, lo32) {\n    return hi32 * V2E32 + lo32;\n}\n/**\n * Represent an unsigned 64-bit integer in little-endian format when\n * encoded and as a near integral JavaScript Number when decoded.\n *\n * *Factory*: {@link module:Layout.nu64|nu64}\n *\n * **NOTE** Values with magnitude greater than 2^52 may not decode to\n * the exact value of the encoded representation.\n *\n * @augments {Layout}\n */ class NearUInt64 extends Layout {\n    constructor(property){\n        super(8, property);\n    }\n    /** @override */ decode(b, offset) {\n        if (undefined === offset) {\n            offset = 0;\n        }\n        const lo32 = b.readUInt32LE(offset);\n        const hi32 = b.readUInt32LE(offset + 4);\n        return roundedInt64(hi32, lo32);\n    }\n    /** @override */ encode(src, b, offset) {\n        if (undefined === offset) {\n            offset = 0;\n        }\n        const split = divmodInt64(src);\n        b.writeUInt32LE(split.lo32, offset);\n        b.writeUInt32LE(split.hi32, offset + 4);\n        return 8;\n    }\n}\n/**\n * Represent an unsigned 64-bit integer in big-endian format when\n * encoded and as a near integral JavaScript Number when decoded.\n *\n * *Factory*: {@link module:Layout.nu64be|nu64be}\n *\n * **NOTE** Values with magnitude greater than 2^52 may not decode to\n * the exact value of the encoded representation.\n *\n * @augments {Layout}\n */ class NearUInt64BE extends Layout {\n    constructor(property){\n        super(8, property);\n    }\n    /** @override */ decode(b, offset) {\n        if (undefined === offset) {\n            offset = 0;\n        }\n        const hi32 = b.readUInt32BE(offset);\n        const lo32 = b.readUInt32BE(offset + 4);\n        return roundedInt64(hi32, lo32);\n    }\n    /** @override */ encode(src, b, offset) {\n        if (undefined === offset) {\n            offset = 0;\n        }\n        const split = divmodInt64(src);\n        b.writeUInt32BE(split.hi32, offset);\n        b.writeUInt32BE(split.lo32, offset + 4);\n        return 8;\n    }\n}\n/**\n * Represent a signed 64-bit integer in little-endian format when\n * encoded and as a near integral JavaScript Number when decoded.\n *\n * *Factory*: {@link module:Layout.ns64|ns64}\n *\n * **NOTE** Values with magnitude greater than 2^52 may not decode to\n * the exact value of the encoded representation.\n *\n * @augments {Layout}\n */ class NearInt64 extends Layout {\n    constructor(property){\n        super(8, property);\n    }\n    /** @override */ decode(b, offset) {\n        if (undefined === offset) {\n            offset = 0;\n        }\n        const lo32 = b.readUInt32LE(offset);\n        const hi32 = b.readInt32LE(offset + 4);\n        return roundedInt64(hi32, lo32);\n    }\n    /** @override */ encode(src, b, offset) {\n        if (undefined === offset) {\n            offset = 0;\n        }\n        const split = divmodInt64(src);\n        b.writeUInt32LE(split.lo32, offset);\n        b.writeInt32LE(split.hi32, offset + 4);\n        return 8;\n    }\n}\n/**\n * Represent a signed 64-bit integer in big-endian format when\n * encoded and as a near integral JavaScript Number when decoded.\n *\n * *Factory*: {@link module:Layout.ns64be|ns64be}\n *\n * **NOTE** Values with magnitude greater than 2^52 may not decode to\n * the exact value of the encoded representation.\n *\n * @augments {Layout}\n */ class NearInt64BE extends Layout {\n    constructor(property){\n        super(8, property);\n    }\n    /** @override */ decode(b, offset) {\n        if (undefined === offset) {\n            offset = 0;\n        }\n        const hi32 = b.readInt32BE(offset);\n        const lo32 = b.readUInt32BE(offset + 4);\n        return roundedInt64(hi32, lo32);\n    }\n    /** @override */ encode(src, b, offset) {\n        if (undefined === offset) {\n            offset = 0;\n        }\n        const split = divmodInt64(src);\n        b.writeInt32BE(split.hi32, offset);\n        b.writeUInt32BE(split.lo32, offset + 4);\n        return 8;\n    }\n}\n/**\n * Represent a 32-bit floating point number in little-endian format.\n *\n * *Factory*: {@link module:Layout.f32|f32}\n *\n * @param {string} [property] - initializer for {@link\n * Layout#property|property}.\n *\n * @augments {Layout}\n */ class Float extends Layout {\n    constructor(property){\n        super(4, property);\n    }\n    /** @override */ decode(b, offset) {\n        if (undefined === offset) {\n            offset = 0;\n        }\n        return b.readFloatLE(offset);\n    }\n    /** @override */ encode(src, b, offset) {\n        if (undefined === offset) {\n            offset = 0;\n        }\n        b.writeFloatLE(src, offset);\n        return 4;\n    }\n}\n/**\n * Represent a 32-bit floating point number in big-endian format.\n *\n * *Factory*: {@link module:Layout.f32be|f32be}\n *\n * @param {string} [property] - initializer for {@link\n * Layout#property|property}.\n *\n * @augments {Layout}\n */ class FloatBE extends Layout {\n    constructor(property){\n        super(4, property);\n    }\n    /** @override */ decode(b, offset) {\n        if (undefined === offset) {\n            offset = 0;\n        }\n        return b.readFloatBE(offset);\n    }\n    /** @override */ encode(src, b, offset) {\n        if (undefined === offset) {\n            offset = 0;\n        }\n        b.writeFloatBE(src, offset);\n        return 4;\n    }\n}\n/**\n * Represent a 64-bit floating point number in little-endian format.\n *\n * *Factory*: {@link module:Layout.f64|f64}\n *\n * @param {string} [property] - initializer for {@link\n * Layout#property|property}.\n *\n * @augments {Layout}\n */ class Double extends Layout {\n    constructor(property){\n        super(8, property);\n    }\n    /** @override */ decode(b, offset) {\n        if (undefined === offset) {\n            offset = 0;\n        }\n        return b.readDoubleLE(offset);\n    }\n    /** @override */ encode(src, b, offset) {\n        if (undefined === offset) {\n            offset = 0;\n        }\n        b.writeDoubleLE(src, offset);\n        return 8;\n    }\n}\n/**\n * Represent a 64-bit floating point number in big-endian format.\n *\n * *Factory*: {@link module:Layout.f64be|f64be}\n *\n * @param {string} [property] - initializer for {@link\n * Layout#property|property}.\n *\n * @augments {Layout}\n */ class DoubleBE extends Layout {\n    constructor(property){\n        super(8, property);\n    }\n    /** @override */ decode(b, offset) {\n        if (undefined === offset) {\n            offset = 0;\n        }\n        return b.readDoubleBE(offset);\n    }\n    /** @override */ encode(src, b, offset) {\n        if (undefined === offset) {\n            offset = 0;\n        }\n        b.writeDoubleBE(src, offset);\n        return 8;\n    }\n}\n/**\n * Represent a contiguous sequence of a specific layout as an Array.\n *\n * *Factory*: {@link module:Layout.seq|seq}\n *\n * @param {Layout} elementLayout - initializer for {@link\n * Sequence#elementLayout|elementLayout}.\n *\n * @param {(Number|ExternalLayout)} count - initializer for {@link\n * Sequence#count|count}.  The parameter must be either a positive\n * integer or an instance of {@link ExternalLayout}.\n *\n * @param {string} [property] - initializer for {@link\n * Layout#property|property}.\n *\n * @augments {Layout}\n */ class Sequence extends Layout {\n    constructor(elementLayout, count, property){\n        if (!(elementLayout instanceof Layout)) {\n            throw new TypeError(\"elementLayout must be a Layout\");\n        }\n        if (!(count instanceof ExternalLayout && count.isCount() || Number.isInteger(count) && 0 <= count)) {\n            throw new TypeError(\"count must be non-negative integer \" + \"or an unsigned integer ExternalLayout\");\n        }\n        let span = -1;\n        if (!(count instanceof ExternalLayout) && 0 < elementLayout.span) {\n            span = count * elementLayout.span;\n        }\n        super(span, property);\n        /** The layout for individual elements of the sequence. */ this.elementLayout = elementLayout;\n        /** The number of elements in the sequence.\n     *\n     * This will be either a non-negative integer or an instance of\n     * {@link ExternalLayout} for which {@link\n     * ExternalLayout#isCount|isCount()} is `true`. */ this.count = count;\n    }\n    /** @override */ getSpan(b, offset) {\n        if (0 <= this.span) {\n            return this.span;\n        }\n        if (undefined === offset) {\n            offset = 0;\n        }\n        let span = 0;\n        let count = this.count;\n        if (count instanceof ExternalLayout) {\n            count = count.decode(b, offset);\n        }\n        if (0 < this.elementLayout.span) {\n            span = count * this.elementLayout.span;\n        } else {\n            let idx = 0;\n            while(idx < count){\n                span += this.elementLayout.getSpan(b, offset + span);\n                ++idx;\n            }\n        }\n        return span;\n    }\n    /** @override */ decode(b, offset) {\n        if (undefined === offset) {\n            offset = 0;\n        }\n        const rv = [];\n        let i = 0;\n        let count = this.count;\n        if (count instanceof ExternalLayout) {\n            count = count.decode(b, offset);\n        }\n        while(i < count){\n            rv.push(this.elementLayout.decode(b, offset));\n            offset += this.elementLayout.getSpan(b, offset);\n            i += 1;\n        }\n        return rv;\n    }\n    /** Implement {@link Layout#encode|encode} for {@link Sequence}.\n   *\n   * **NOTE** If `src` is shorter than {@link Sequence#count|count} then\n   * the unused space in the buffer is left unchanged.  If `src` is\n   * longer than {@link Sequence#count|count} the unneeded elements are\n   * ignored.\n   *\n   * **NOTE** If {@link Layout#count|count} is an instance of {@link\n   * ExternalLayout} then the length of `src` will be encoded as the\n   * count after `src` is encoded. */ encode(src, b, offset) {\n        if (undefined === offset) {\n            offset = 0;\n        }\n        const elo = this.elementLayout;\n        const span = src.reduce((span, v)=>{\n            return span + elo.encode(v, b, offset + span);\n        }, 0);\n        if (this.count instanceof ExternalLayout) {\n            this.count.encode(src.length, b, offset);\n        }\n        return span;\n    }\n}\n/**\n * Represent a contiguous sequence of arbitrary layout elements as an\n * Object.\n *\n * *Factory*: {@link module:Layout.struct|struct}\n *\n * **NOTE** The {@link Layout#span|span} of the structure is variable\n * if any layout in {@link Structure#fields|fields} has a variable\n * span.  When {@link Layout#encode|encoding} we must have a value for\n * all variable-length fields, or we wouldn't be able to figure out\n * how much space to use for storage.  We can only identify the value\n * for a field when it has a {@link Layout#property|property}.  As\n * such, although a structure may contain both unnamed fields and\n * variable-length fields, it cannot contain an unnamed\n * variable-length field.\n *\n * @param {Layout[]} fields - initializer for {@link\n * Structure#fields|fields}.  An error is raised if this contains a\n * variable-length field for which a {@link Layout#property|property}\n * is not defined.\n *\n * @param {string} [property] - initializer for {@link\n * Layout#property|property}.\n *\n * @param {Boolean} [decodePrefixes] - initializer for {@link\n * Structure#decodePrefixes|property}.\n *\n * @throws {Error} - if `fields` contains an unnamed variable-length\n * layout.\n *\n * @augments {Layout}\n */ class Structure extends Layout {\n    constructor(fields, property, decodePrefixes){\n        if (!(Array.isArray(fields) && fields.reduce((acc, v)=>acc && v instanceof Layout, true))) {\n            throw new TypeError(\"fields must be array of Layout instances\");\n        }\n        if (\"boolean\" === typeof property && undefined === decodePrefixes) {\n            decodePrefixes = property;\n            property = undefined;\n        }\n        /* Verify absence of unnamed variable-length fields. */ for (const fd of fields){\n            if (0 > fd.span && undefined === fd.property) {\n                throw new Error(\"fields cannot contain unnamed variable-length layout\");\n            }\n        }\n        let span = -1;\n        try {\n            span = fields.reduce((span, fd)=>span + fd.getSpan(), 0);\n        } catch (e) {}\n        super(span, property);\n        /** The sequence of {@link Layout} values that comprise the\n     * structure.\n     *\n     * The individual elements need not be the same type, and may be\n     * either scalar or aggregate layouts.  If a member layout leaves\n     * its {@link Layout#property|property} undefined the\n     * corresponding region of the buffer associated with the element\n     * will not be mutated.\n     *\n     * @type {Layout[]} */ this.fields = fields;\n        /** Control behavior of {@link Layout#decode|decode()} given short\n     * buffers.\n     *\n     * In some situations a structure many be extended with additional\n     * fields over time, with older installations providing only a\n     * prefix of the full structure.  If this property is `true`\n     * decoding will accept those buffers and leave subsequent fields\n     * undefined, as long as the buffer ends at a field boundary.\n     * Defaults to `false`. */ this.decodePrefixes = !!decodePrefixes;\n    }\n    /** @override */ getSpan(b, offset) {\n        if (0 <= this.span) {\n            return this.span;\n        }\n        if (undefined === offset) {\n            offset = 0;\n        }\n        let span = 0;\n        try {\n            span = this.fields.reduce((span, fd)=>{\n                const fsp = fd.getSpan(b, offset);\n                offset += fsp;\n                return span + fsp;\n            }, 0);\n        } catch (e) {\n            throw new RangeError(\"indeterminate span\");\n        }\n        return span;\n    }\n    /** @override */ decode(b, offset) {\n        if (undefined === offset) {\n            offset = 0;\n        }\n        const dest = this.makeDestinationObject();\n        for (const fd of this.fields){\n            if (undefined !== fd.property) {\n                dest[fd.property] = fd.decode(b, offset);\n            }\n            offset += fd.getSpan(b, offset);\n            if (this.decodePrefixes && b.length === offset) {\n                break;\n            }\n        }\n        return dest;\n    }\n    /** Implement {@link Layout#encode|encode} for {@link Structure}.\n   *\n   * If `src` is missing a property for a member with a defined {@link\n   * Layout#property|property} the corresponding region of the buffer is\n   * left unmodified. */ encode(src, b, offset) {\n        if (undefined === offset) {\n            offset = 0;\n        }\n        const firstOffset = offset;\n        let lastOffset = 0;\n        let lastWrote = 0;\n        for (const fd of this.fields){\n            let span = fd.span;\n            lastWrote = 0 < span ? span : 0;\n            if (undefined !== fd.property) {\n                const fv = src[fd.property];\n                if (undefined !== fv) {\n                    lastWrote = fd.encode(fv, b, offset);\n                    if (0 > span) {\n                        /* Read the as-encoded span, which is not necessarily the\n             * same as what we wrote. */ span = fd.getSpan(b, offset);\n                    }\n                }\n            }\n            lastOffset = offset;\n            offset += span;\n        }\n        /* Use (lastOffset + lastWrote) instead of offset because the last\n     * item may have had a dynamic length and we don't want to include\n     * the padding between it and the end of the space reserved for\n     * it. */ return lastOffset + lastWrote - firstOffset;\n    }\n    /** @override */ fromArray(values) {\n        const dest = this.makeDestinationObject();\n        for (const fd of this.fields){\n            if (undefined !== fd.property && 0 < values.length) {\n                dest[fd.property] = values.shift();\n            }\n        }\n        return dest;\n    }\n    /**\n   * Get access to the layout of a given property.\n   *\n   * @param {String} property - the structure member of interest.\n   *\n   * @return {Layout} - the layout associated with `property`, or\n   * undefined if there is no such property.\n   */ layoutFor(property) {\n        if (\"string\" !== typeof property) {\n            throw new TypeError(\"property must be string\");\n        }\n        for (const fd of this.fields){\n            if (fd.property === property) {\n                return fd;\n            }\n        }\n    }\n    /**\n   * Get the offset of a structure member.\n   *\n   * @param {String} property - the structure member of interest.\n   *\n   * @return {Number} - the offset in bytes to the start of `property`\n   * within the structure, or undefined if `property` is not a field\n   * within the structure.  If the property is a member but follows a\n   * variable-length structure member a negative number will be\n   * returned.\n   */ offsetOf(property) {\n        if (\"string\" !== typeof property) {\n            throw new TypeError(\"property must be string\");\n        }\n        let offset = 0;\n        for (const fd of this.fields){\n            if (fd.property === property) {\n                return offset;\n            }\n            if (0 > fd.span) {\n                offset = -1;\n            } else if (0 <= offset) {\n                offset += fd.span;\n            }\n        }\n    }\n}\n/**\n * An object that can provide a {@link\n * Union#discriminator|discriminator} API for {@link Union}.\n *\n * **NOTE** This is an abstract base class; you can create instances\n * if it amuses you, but they won't support the {@link\n * UnionDiscriminator#encode|encode} or {@link\n * UnionDiscriminator#decode|decode} functions.\n *\n * @param {string} [property] - Default for {@link\n * UnionDiscriminator#property|property}.\n *\n * @abstract\n */ class UnionDiscriminator {\n    constructor(property){\n        /** The {@link Layout#property|property} to be used when the\n     * discriminator is referenced in isolation (generally when {@link\n     * Union#decode|Union decode} cannot delegate to a specific\n     * variant). */ this.property = property;\n    }\n    /** Analog to {@link Layout#decode|Layout decode} for union discriminators.\n   *\n   * The implementation of this method need not reference the buffer if\n   * variant information is available through other means. */ decode() {\n        throw new Error(\"UnionDiscriminator is abstract\");\n    }\n    /** Analog to {@link Layout#decode|Layout encode} for union discriminators.\n   *\n   * The implementation of this method need not store the value if\n   * variant information is maintained through other means. */ encode() {\n        throw new Error(\"UnionDiscriminator is abstract\");\n    }\n}\n/**\n * An object that can provide a {@link\n * UnionDiscriminator|discriminator API} for {@link Union} using an\n * unsigned integral {@link Layout} instance located either inside or\n * outside the union.\n *\n * @param {ExternalLayout} layout - initializes {@link\n * UnionLayoutDiscriminator#layout|layout}.  Must satisfy {@link\n * ExternalLayout#isCount|isCount()}.\n *\n * @param {string} [property] - Default for {@link\n * UnionDiscriminator#property|property}, superseding the property\n * from `layout`, but defaulting to `variant` if neither `property`\n * nor layout provide a property name.\n *\n * @augments {UnionDiscriminator}\n */ class UnionLayoutDiscriminator extends UnionDiscriminator {\n    constructor(layout, property){\n        if (!(layout instanceof ExternalLayout && layout.isCount())) {\n            throw new TypeError(\"layout must be an unsigned integer ExternalLayout\");\n        }\n        super(property || layout.property || \"variant\");\n        /** The {@link ExternalLayout} used to access the discriminator\n     * value. */ this.layout = layout;\n    }\n    /** Delegate decoding to {@link UnionLayoutDiscriminator#layout|layout}. */ decode(b, offset) {\n        return this.layout.decode(b, offset);\n    }\n    /** Delegate encoding to {@link UnionLayoutDiscriminator#layout|layout}. */ encode(src, b, offset) {\n        return this.layout.encode(src, b, offset);\n    }\n}\n/**\n * Represent any number of span-compatible layouts.\n *\n * *Factory*: {@link module:Layout.union|union}\n *\n * If the union has a {@link Union#defaultLayout|default layout} that\n * layout must have a non-negative {@link Layout#span|span}.  The span\n * of a fixed-span union includes its {@link\n * Union#discriminator|discriminator} if the variant is a {@link\n * Union#usesPrefixDiscriminator|prefix of the union}, plus the span\n * of its {@link Union#defaultLayout|default layout}.\n *\n * If the union does not have a default layout then the encoded span\n * of the union depends on the encoded span of its variant (which may\n * be fixed or variable).\n *\n * {@link VariantLayout#layout|Variant layout}s are added through\n * {@link Union#addVariant|addVariant}.  If the union has a default\n * layout, the span of the {@link VariantLayout#layout|layout\n * contained by the variant} must not exceed the span of the {@link\n * Union#defaultLayout|default layout} (minus the span of a {@link\n * Union#usesPrefixDiscriminator|prefix disriminator}, if used).  The\n * span of the variant will equal the span of the union itself.\n *\n * The variant for a buffer can only be identified from the {@link\n * Union#discriminator|discriminator} {@link\n * UnionDiscriminator#property|property} (in the case of the {@link\n * Union#defaultLayout|default layout}), or by using {@link\n * Union#getVariant|getVariant} and examining the resulting {@link\n * VariantLayout} instance.\n *\n * A variant compatible with a JavaScript object can be identified\n * using {@link Union#getSourceVariant|getSourceVariant}.\n *\n * @param {(UnionDiscriminator|ExternalLayout|Layout)} discr - How to\n * identify the layout used to interpret the union contents.  The\n * parameter must be an instance of {@link UnionDiscriminator}, an\n * {@link ExternalLayout} that satisfies {@link\n * ExternalLayout#isCount|isCount()}, or {@link UInt} (or {@link\n * UIntBE}).  When a non-external layout element is passed the layout\n * appears at the start of the union.  In all cases the (synthesized)\n * {@link UnionDiscriminator} instance is recorded as {@link\n * Union#discriminator|discriminator}.\n *\n * @param {(Layout|null)} defaultLayout - initializer for {@link\n * Union#defaultLayout|defaultLayout}.  If absent defaults to `null`.\n * If `null` there is no default layout: the union has data-dependent\n * length and attempts to decode or encode unrecognized variants will\n * throw an exception.  A {@link Layout} instance must have a\n * non-negative {@link Layout#span|span}, and if it lacks a {@link\n * Layout#property|property} the {@link\n * Union#defaultLayout|defaultLayout} will be a {@link\n * Layout#replicate|replica} with property `content`.\n *\n * @param {string} [property] - initializer for {@link\n * Layout#property|property}.\n *\n * @augments {Layout}\n */ class Union extends Layout {\n    constructor(discr, defaultLayout, property){\n        const upv = discr instanceof UInt || discr instanceof UIntBE;\n        if (upv) {\n            discr = new UnionLayoutDiscriminator(new OffsetLayout(discr));\n        } else if (discr instanceof ExternalLayout && discr.isCount()) {\n            discr = new UnionLayoutDiscriminator(discr);\n        } else if (!(discr instanceof UnionDiscriminator)) {\n            throw new TypeError(\"discr must be a UnionDiscriminator \" + \"or an unsigned integer layout\");\n        }\n        if (undefined === defaultLayout) {\n            defaultLayout = null;\n        }\n        if (!(null === defaultLayout || defaultLayout instanceof Layout)) {\n            throw new TypeError(\"defaultLayout must be null or a Layout\");\n        }\n        if (null !== defaultLayout) {\n            if (0 > defaultLayout.span) {\n                throw new Error(\"defaultLayout must have constant span\");\n            }\n            if (undefined === defaultLayout.property) {\n                defaultLayout = defaultLayout.replicate(\"content\");\n            }\n        }\n        /* The union span can be estimated only if there's a default\n     * layout.  The union spans its default layout, plus any prefix\n     * variant layout.  By construction both layouts, if present, have\n     * non-negative span. */ let span = -1;\n        if (defaultLayout) {\n            span = defaultLayout.span;\n            if (0 <= span && upv) {\n                span += discr.layout.span;\n            }\n        }\n        super(span, property);\n        /** The interface for the discriminator value in isolation.\n     *\n     * This a {@link UnionDiscriminator} either passed to the\n     * constructor or synthesized from the `discr` constructor\n     * argument.  {@link\n     * Union#usesPrefixDiscriminator|usesPrefixDiscriminator} will be\n     * `true` iff the `discr` parameter was a non-offset {@link\n     * Layout} instance. */ this.discriminator = discr;\n        /** `true` if the {@link Union#discriminator|discriminator} is the\n     * first field in the union.\n     *\n     * If `false` the discriminator is obtained from somewhere\n     * else. */ this.usesPrefixDiscriminator = upv;\n        /** The layout for non-discriminator content when the value of the\n     * discriminator is not recognized.\n     *\n     * This is the value passed to the constructor.  It is\n     * structurally equivalent to the second component of {@link\n     * Union#layout|layout} but may have a different property\n     * name. */ this.defaultLayout = defaultLayout;\n        /** A registry of allowed variants.\n     *\n     * The keys are unsigned integers which should be compatible with\n     * {@link Union.discriminator|discriminator}.  The property value\n     * is the corresponding {@link VariantLayout} instances assigned\n     * to this union by {@link Union#addVariant|addVariant}.\n     *\n     * **NOTE** The registry remains mutable so that variants can be\n     * {@link Union#addVariant|added} at any time.  Users should not\n     * manipulate the content of this property. */ this.registry = {};\n        /* Private variable used when invoking getSourceVariant */ let boundGetSourceVariant = this.defaultGetSourceVariant.bind(this);\n        /** Function to infer the variant selected by a source object.\n     *\n     * Defaults to {@link\n     * Union#defaultGetSourceVariant|defaultGetSourceVariant} but may\n     * be overridden using {@link\n     * Union#configGetSourceVariant|configGetSourceVariant}.\n     *\n     * @param {Object} src - as with {@link\n     * Union#defaultGetSourceVariant|defaultGetSourceVariant}.\n     *\n     * @returns {(undefined|VariantLayout)} The default variant\n     * (`undefined`) or first registered variant that uses a property\n     * available in `src`. */ this.getSourceVariant = function(src) {\n            return boundGetSourceVariant(src);\n        };\n        /** Function to override the implementation of {@link\n     * Union#getSourceVariant|getSourceVariant}.\n     *\n     * Use this if the desired variant cannot be identified using the\n     * algorithm of {@link\n     * Union#defaultGetSourceVariant|defaultGetSourceVariant}.\n     *\n     * **NOTE** The provided function will be invoked bound to this\n     * Union instance, providing local access to {@link\n     * Union#registry|registry}.\n     *\n     * @param {Function} gsv - a function that follows the API of\n     * {@link Union#defaultGetSourceVariant|defaultGetSourceVariant}. */ this.configGetSourceVariant = function(gsv) {\n            boundGetSourceVariant = gsv.bind(this);\n        };\n    }\n    /** @override */ getSpan(b, offset) {\n        if (0 <= this.span) {\n            return this.span;\n        }\n        if (undefined === offset) {\n            offset = 0;\n        }\n        /* Default layouts always have non-negative span, so we don't have\n     * one and we have to recognize the variant which will in turn\n     * determine the span. */ const vlo = this.getVariant(b, offset);\n        if (!vlo) {\n            throw new Error(\"unable to determine span for unrecognized variant\");\n        }\n        return vlo.getSpan(b, offset);\n    }\n    /**\n   * Method to infer a registered Union variant compatible with `src`.\n   *\n   * The first satisified rule in the following sequence defines the\n   * return value:\n   * * If `src` has properties matching the Union discriminator and\n   *   the default layout, `undefined` is returned regardless of the\n   *   value of the discriminator property (this ensures the default\n   *   layout will be used);\n   * * If `src` has a property matching the Union discriminator, the\n   *   value of the discriminator identifies a registered variant, and\n   *   either (a) the variant has no layout, or (b) `src` has the\n   *   variant's property, then the variant is returned (because the\n   *   source satisfies the constraints of the variant it identifies);\n   * * If `src` does not have a property matching the Union\n   *   discriminator, but does have a property matching a registered\n   *   variant, then the variant is returned (because the source\n   *   matches a variant without an explicit conflict);\n   * * An error is thrown (because we either can't identify a variant,\n   *   or we were explicitly told the variant but can't satisfy it).\n   *\n   * @param {Object} src - an object presumed to be compatible with\n   * the content of the Union.\n   *\n   * @return {(undefined|VariantLayout)} - as described above.\n   *\n   * @throws {Error} - if `src` cannot be associated with a default or\n   * registered variant.\n   */ defaultGetSourceVariant(src) {\n        if (src.hasOwnProperty(this.discriminator.property)) {\n            if (this.defaultLayout && src.hasOwnProperty(this.defaultLayout.property)) {\n                return undefined;\n            }\n            const vlo = this.registry[src[this.discriminator.property]];\n            if (vlo && (!vlo.layout || src.hasOwnProperty(vlo.property))) {\n                return vlo;\n            }\n        } else {\n            for(const tag in this.registry){\n                const vlo = this.registry[tag];\n                if (src.hasOwnProperty(vlo.property)) {\n                    return vlo;\n                }\n            }\n        }\n        throw new Error(\"unable to infer src variant\");\n    }\n    /** Implement {@link Layout#decode|decode} for {@link Union}.\n   *\n   * If the variant is {@link Union#addVariant|registered} the return\n   * value is an instance of that variant, with no explicit\n   * discriminator.  Otherwise the {@link Union#defaultLayout|default\n   * layout} is used to decode the content. */ decode(b, offset) {\n        if (undefined === offset) {\n            offset = 0;\n        }\n        let dest;\n        const dlo = this.discriminator;\n        const discr = dlo.decode(b, offset);\n        let clo = this.registry[discr];\n        if (undefined === clo) {\n            let contentOffset = 0;\n            clo = this.defaultLayout;\n            if (this.usesPrefixDiscriminator) {\n                contentOffset = dlo.layout.span;\n            }\n            dest = this.makeDestinationObject();\n            dest[dlo.property] = discr;\n            dest[clo.property] = this.defaultLayout.decode(b, offset + contentOffset);\n        } else {\n            dest = clo.decode(b, offset);\n        }\n        return dest;\n    }\n    /** Implement {@link Layout#encode|encode} for {@link Union}.\n   *\n   * This API assumes the `src` object is consistent with the union's\n   * {@link Union#defaultLayout|default layout}.  To encode variants\n   * use the appropriate variant-specific {@link VariantLayout#encode}\n   * method. */ encode(src, b, offset) {\n        if (undefined === offset) {\n            offset = 0;\n        }\n        const vlo = this.getSourceVariant(src);\n        if (undefined === vlo) {\n            const dlo = this.discriminator;\n            const clo = this.defaultLayout;\n            let contentOffset = 0;\n            if (this.usesPrefixDiscriminator) {\n                contentOffset = dlo.layout.span;\n            }\n            dlo.encode(src[dlo.property], b, offset);\n            return contentOffset + clo.encode(src[clo.property], b, offset + contentOffset);\n        }\n        return vlo.encode(src, b, offset);\n    }\n    /** Register a new variant structure within a union.  The newly\n   * created variant is returned.\n   *\n   * @param {Number} variant - initializer for {@link\n   * VariantLayout#variant|variant}.\n   *\n   * @param {Layout} layout - initializer for {@link\n   * VariantLayout#layout|layout}.\n   *\n   * @param {String} property - initializer for {@link\n   * Layout#property|property}.\n   *\n   * @return {VariantLayout} */ addVariant(variant, layout, property) {\n        const rv = new VariantLayout(this, variant, layout, property);\n        this.registry[variant] = rv;\n        return rv;\n    }\n    /**\n   * Get the layout associated with a registered variant.\n   *\n   * If `vb` does not produce a registered variant the function returns\n   * `undefined`.\n   *\n   * @param {(Number|Buffer)} vb - either the variant number, or a\n   * buffer from which the discriminator is to be read.\n   *\n   * @param {Number} offset - offset into `vb` for the start of the\n   * union.  Used only when `vb` is an instance of {Buffer}.\n   *\n   * @return {({VariantLayout}|undefined)}\n   */ getVariant(vb, offset) {\n        let variant = vb;\n        if (Buffer.isBuffer(vb)) {\n            if (undefined === offset) {\n                offset = 0;\n            }\n            variant = this.discriminator.decode(vb, offset);\n        }\n        return this.registry[variant];\n    }\n}\n/**\n * Represent a specific variant within a containing union.\n *\n * **NOTE** The {@link Layout#span|span} of the variant may include\n * the span of the {@link Union#discriminator|discriminator} used to\n * identify it, but values read and written using the variant strictly\n * conform to the content of {@link VariantLayout#layout|layout}.\n *\n * **NOTE** User code should not invoke this constructor directly.  Use\n * the union {@link Union#addVariant|addVariant} helper method.\n *\n * @param {Union} union - initializer for {@link\n * VariantLayout#union|union}.\n *\n * @param {Number} variant - initializer for {@link\n * VariantLayout#variant|variant}.\n *\n * @param {Layout} [layout] - initializer for {@link\n * VariantLayout#layout|layout}.  If absent the variant carries no\n * data.\n *\n * @param {String} [property] - initializer for {@link\n * Layout#property|property}.  Unlike many other layouts, variant\n * layouts normally include a property name so they can be identified\n * within their containing {@link Union}.  The property identifier may\n * be absent only if `layout` is is absent.\n *\n * @augments {Layout}\n */ class VariantLayout extends Layout {\n    constructor(union, variant, layout, property){\n        if (!(union instanceof Union)) {\n            throw new TypeError(\"union must be a Union\");\n        }\n        if (!Number.isInteger(variant) || 0 > variant) {\n            throw new TypeError(\"variant must be a (non-negative) integer\");\n        }\n        if (\"string\" === typeof layout && undefined === property) {\n            property = layout;\n            layout = null;\n        }\n        if (layout) {\n            if (!(layout instanceof Layout)) {\n                throw new TypeError(\"layout must be a Layout\");\n            }\n            if (null !== union.defaultLayout && 0 <= layout.span && layout.span > union.defaultLayout.span) {\n                throw new Error(\"variant span exceeds span of containing union\");\n            }\n            if (\"string\" !== typeof property) {\n                throw new TypeError(\"variant must have a String property\");\n            }\n        }\n        let span = union.span;\n        if (0 > union.span) {\n            span = layout ? layout.span : 0;\n            if (0 <= span && union.usesPrefixDiscriminator) {\n                span += union.discriminator.layout.span;\n            }\n        }\n        super(span, property);\n        /** The {@link Union} to which this variant belongs. */ this.union = union;\n        /** The unsigned integral value identifying this variant within\n     * the {@link Union#discriminator|discriminator} of the containing\n     * union. */ this.variant = variant;\n        /** The {@link Layout} to be used when reading/writing the\n     * non-discriminator part of the {@link\n     * VariantLayout#union|union}.  If `null` the variant carries no\n     * data. */ this.layout = layout || null;\n    }\n    /** @override */ getSpan(b, offset) {\n        if (0 <= this.span) {\n            /* Will be equal to the containing union span if that is not\n       * variable. */ return this.span;\n        }\n        if (undefined === offset) {\n            offset = 0;\n        }\n        let contentOffset = 0;\n        if (this.union.usesPrefixDiscriminator) {\n            contentOffset = this.union.discriminator.layout.span;\n        }\n        /* Span is defined solely by the variant (and prefix discriminator) */ return contentOffset + this.layout.getSpan(b, offset + contentOffset);\n    }\n    /** @override */ decode(b, offset) {\n        const dest = this.makeDestinationObject();\n        if (undefined === offset) {\n            offset = 0;\n        }\n        if (this !== this.union.getVariant(b, offset)) {\n            throw new Error(\"variant mismatch\");\n        }\n        let contentOffset = 0;\n        if (this.union.usesPrefixDiscriminator) {\n            contentOffset = this.union.discriminator.layout.span;\n        }\n        if (this.layout) {\n            dest[this.property] = this.layout.decode(b, offset + contentOffset);\n        } else if (this.property) {\n            dest[this.property] = true;\n        } else if (this.union.usesPrefixDiscriminator) {\n            dest[this.union.discriminator.property] = this.variant;\n        }\n        return dest;\n    }\n    /** @override */ encode(src, b, offset) {\n        if (undefined === offset) {\n            offset = 0;\n        }\n        let contentOffset = 0;\n        if (this.union.usesPrefixDiscriminator) {\n            contentOffset = this.union.discriminator.layout.span;\n        }\n        if (this.layout && !src.hasOwnProperty(this.property)) {\n            throw new TypeError(\"variant lacks property \" + this.property);\n        }\n        this.union.discriminator.encode(this.variant, b, offset);\n        let span = contentOffset;\n        if (this.layout) {\n            this.layout.encode(src[this.property], b, offset + contentOffset);\n            span += this.layout.getSpan(b, offset + contentOffset);\n            if (0 <= this.union.span && span > this.union.span) {\n                throw new Error(\"encoded variant overruns containing union\");\n            }\n        }\n        return span;\n    }\n    /** Delegate {@link Layout#fromArray|fromArray} to {@link\n   * VariantLayout#layout|layout}. */ fromArray(values) {\n        if (this.layout) {\n            return this.layout.fromArray(values);\n        }\n    }\n}\n/** JavaScript chose to define bitwise operations as operating on\n * signed 32-bit values in 2's complement form, meaning any integer\n * with bit 31 set is going to look negative.  For right shifts that's\n * not a problem, because `>>>` is a logical shift, but for every\n * other bitwise operator we have to compensate for possible negative\n * results. */ function fixBitwiseResult(v) {\n    if (0 > v) {\n        v += 0x100000000;\n    }\n    return v;\n}\n/**\n * Contain a sequence of bit fields as an unsigned integer.\n *\n * *Factory*: {@link module:Layout.bits|bits}\n *\n * This is a container element; within it there are {@link BitField}\n * instances that provide the extracted properties.  The container\n * simply defines the aggregate representation and its bit ordering.\n * The representation is an object containing properties with numeric\n * or {@link Boolean} values.\n *\n * {@link BitField}s are added with the {@link\n * BitStructure#addField|addField} and {@link\n * BitStructure#addBoolean|addBoolean} methods.\n\n * @param {Layout} word - initializer for {@link\n * BitStructure#word|word}.  The parameter must be an instance of\n * {@link UInt} (or {@link UIntBE}) that is no more than 4 bytes wide.\n *\n * @param {bool} [msb] - `true` if the bit numbering starts at the\n * most significant bit of the containing word; `false` (default) if\n * it starts at the least significant bit of the containing word.  If\n * the parameter at this position is a string and `property` is\n * `undefined` the value of this argument will instead be used as the\n * value of `property`.\n *\n * @param {string} [property] - initializer for {@link\n * Layout#property|property}.\n *\n * @augments {Layout}\n */ class BitStructure extends Layout {\n    constructor(word, msb, property){\n        if (!(word instanceof UInt || word instanceof UIntBE)) {\n            throw new TypeError(\"word must be a UInt or UIntBE layout\");\n        }\n        if (\"string\" === typeof msb && undefined === property) {\n            property = msb;\n            msb = undefined;\n        }\n        if (4 < word.span) {\n            throw new RangeError(\"word cannot exceed 32 bits\");\n        }\n        super(word.span, property);\n        /** The layout used for the packed value.  {@link BitField}\n     * instances are packed sequentially depending on {@link\n     * BitStructure#msb|msb}. */ this.word = word;\n        /** Whether the bit sequences are packed starting at the most\n     * significant bit growing down (`true`), or the least significant\n     * bit growing up (`false`).\n     *\n     * **NOTE** Regardless of this value, the least significant bit of\n     * any {@link BitField} value is the least significant bit of the\n     * corresponding section of the packed value. */ this.msb = !!msb;\n        /** The sequence of {@link BitField} layouts that comprise the\n     * packed structure.\n     *\n     * **NOTE** The array remains mutable to allow fields to be {@link\n     * BitStructure#addField|added} after construction.  Users should\n     * not manipulate the content of this property.*/ this.fields = [];\n        /* Storage for the value.  Capture a variable instead of using an\n     * instance property because we don't want anything to change the\n     * value without going through the mutator. */ let value = 0;\n        this._packedSetValue = function(v) {\n            value = fixBitwiseResult(v);\n            return this;\n        };\n        this._packedGetValue = function() {\n            return value;\n        };\n    }\n    /** @override */ decode(b, offset) {\n        const dest = this.makeDestinationObject();\n        if (undefined === offset) {\n            offset = 0;\n        }\n        const value = this.word.decode(b, offset);\n        this._packedSetValue(value);\n        for (const fd of this.fields){\n            if (undefined !== fd.property) {\n                dest[fd.property] = fd.decode(value);\n            }\n        }\n        return dest;\n    }\n    /** Implement {@link Layout#encode|encode} for {@link BitStructure}.\n   *\n   * If `src` is missing a property for a member with a defined {@link\n   * Layout#property|property} the corresponding region of the packed\n   * value is left unmodified.  Unused bits are also left unmodified. */ encode(src, b, offset) {\n        if (undefined === offset) {\n            offset = 0;\n        }\n        const value = this.word.decode(b, offset);\n        this._packedSetValue(value);\n        for (const fd of this.fields){\n            if (undefined !== fd.property) {\n                const fv = src[fd.property];\n                if (undefined !== fv) {\n                    fd.encode(fv);\n                }\n            }\n        }\n        return this.word.encode(this._packedGetValue(), b, offset);\n    }\n    /** Register a new bitfield with a containing bit structure.  The\n   * resulting bitfield is returned.\n   *\n   * @param {Number} bits - initializer for {@link BitField#bits|bits}.\n   *\n   * @param {string} property - initializer for {@link\n   * Layout#property|property}.\n   *\n   * @return {BitField} */ addField(bits, property) {\n        const bf = new BitField(this, bits, property);\n        this.fields.push(bf);\n        return bf;\n    }\n    /** As with {@link BitStructure#addField|addField} for single-bit\n   * fields with `boolean` value representation.\n   *\n   * @param {string} property - initializer for {@link\n   * Layout#property|property}.\n   *\n   * @return {Boolean} */ addBoolean(property) {\n        // This is my Boolean, not the Javascript one.\n        // eslint-disable-next-line no-new-wrappers\n        const bf = new Boolean(this, property);\n        this.fields.push(bf);\n        return bf;\n    }\n    /**\n   * Get access to the bit field for a given property.\n   *\n   * @param {String} property - the bit field of interest.\n   *\n   * @return {BitField} - the field associated with `property`, or\n   * undefined if there is no such property.\n   */ fieldFor(property) {\n        if (\"string\" !== typeof property) {\n            throw new TypeError(\"property must be string\");\n        }\n        for (const fd of this.fields){\n            if (fd.property === property) {\n                return fd;\n            }\n        }\n    }\n}\n/**\n * Represent a sequence of bits within a {@link BitStructure}.\n *\n * All bit field values are represented as unsigned integers.\n *\n * **NOTE** User code should not invoke this constructor directly.\n * Use the container {@link BitStructure#addField|addField} helper\n * method.\n *\n * **NOTE** BitField instances are not instances of {@link Layout}\n * since {@link Layout#span|span} measures 8-bit units.\n *\n * @param {BitStructure} container - initializer for {@link\n * BitField#container|container}.\n *\n * @param {Number} bits - initializer for {@link BitField#bits|bits}.\n *\n * @param {string} [property] - initializer for {@link\n * Layout#property|property}.\n */ class BitField {\n    constructor(container, bits, property){\n        if (!(container instanceof BitStructure)) {\n            throw new TypeError(\"container must be a BitStructure\");\n        }\n        if (!Number.isInteger(bits) || 0 >= bits) {\n            throw new TypeError(\"bits must be positive integer\");\n        }\n        const totalBits = 8 * container.span;\n        const usedBits = container.fields.reduce((sum, fd)=>sum + fd.bits, 0);\n        if (bits + usedBits > totalBits) {\n            throw new Error(\"bits too long for span remainder (\" + (totalBits - usedBits) + \" of \" + totalBits + \" remain)\");\n        }\n        /** The {@link BitStructure} instance to which this bit field\n     * belongs. */ this.container = container;\n        /** The span of this value in bits. */ this.bits = bits;\n        /** A mask of {@link BitField#bits|bits} bits isolating value bits\n     * that fit within the field.\n     *\n     * That is, it masks a value that has not yet been shifted into\n     * position within its containing packed integer. */ this.valueMask = (1 << bits) - 1;\n        if (32 === bits) {\n            this.valueMask = 0xFFFFFFFF;\n        }\n        /** The offset of the value within the containing packed unsigned\n     * integer.  The least significant bit of the packed value is at\n     * offset zero, regardless of bit ordering used. */ this.start = usedBits;\n        if (this.container.msb) {\n            this.start = totalBits - usedBits - bits;\n        }\n        /** A mask of {@link BitField#bits|bits} isolating the field value\n     * within the containing packed unsigned integer. */ this.wordMask = fixBitwiseResult(this.valueMask << this.start);\n        /** The property name used when this bitfield is represented in an\n     * Object.\n     *\n     * Intended to be functionally equivalent to {@link\n     * Layout#property}.\n     *\n     * If left undefined the corresponding span of bits will be\n     * treated as padding: it will not be mutated by {@link\n     * Layout#encode|encode} nor represented as a property in the\n     * decoded Object. */ this.property = property;\n    }\n    /** Store a value into the corresponding subsequence of the containing\n   * bit field. */ decode() {\n        const word = this.container._packedGetValue();\n        const wordValue = fixBitwiseResult(word & this.wordMask);\n        const value = wordValue >>> this.start;\n        return value;\n    }\n    /** Store a value into the corresponding subsequence of the containing\n   * bit field.\n   *\n   * **NOTE** This is not a specialization of {@link\n   * Layout#encode|Layout.encode} and there is no return value. */ encode(value) {\n        if (!Number.isInteger(value) || value !== fixBitwiseResult(value & this.valueMask)) {\n            throw new TypeError(nameWithProperty(\"BitField.encode\", this) + \" value must be integer not exceeding \" + this.valueMask);\n        }\n        const word = this.container._packedGetValue();\n        const wordValue = fixBitwiseResult(value << this.start);\n        this.container._packedSetValue(fixBitwiseResult(word & ~this.wordMask) | wordValue);\n    }\n}\n/**\n * Represent a single bit within a {@link BitStructure} as a\n * JavaScript boolean.\n *\n * **NOTE** User code should not invoke this constructor directly.\n * Use the container {@link BitStructure#addBoolean|addBoolean} helper\n * method.\n *\n * @param {BitStructure} container - initializer for {@link\n * BitField#container|container}.\n *\n * @param {string} [property] - initializer for {@link\n * Layout#property|property}.\n *\n * @augments {BitField}\n */ /* eslint-disable no-extend-native */ class Boolean extends BitField {\n    constructor(container, property){\n        super(container, 1, property);\n    }\n    /** Override {@link BitField#decode|decode} for {@link Boolean|Boolean}.\n   *\n   * @returns {boolean} */ decode(b, offset) {\n        return !!BitField.prototype.decode.call(this, b, offset);\n    }\n    /** @override */ encode(value) {\n        if (\"boolean\" === typeof value) {\n            // BitField requires integer values\n            value = +value;\n        }\n        return BitField.prototype.encode.call(this, value);\n    }\n}\n/* eslint-enable no-extend-native */ /**\n * Contain a fixed-length block of arbitrary data, represented as a\n * Buffer.\n *\n * *Factory*: {@link module:Layout.blob|blob}\n *\n * @param {(Number|ExternalLayout)} length - initializes {@link\n * Blob#length|length}.\n *\n * @param {String} [property] - initializer for {@link\n * Layout#property|property}.\n *\n * @augments {Layout}\n */ class Blob extends Layout {\n    constructor(length, property){\n        if (!(length instanceof ExternalLayout && length.isCount() || Number.isInteger(length) && 0 <= length)) {\n            throw new TypeError(\"length must be positive integer \" + \"or an unsigned integer ExternalLayout\");\n        }\n        let span = -1;\n        if (!(length instanceof ExternalLayout)) {\n            span = length;\n        }\n        super(span, property);\n        /** The number of bytes in the blob.\n     *\n     * This may be a non-negative integer, or an instance of {@link\n     * ExternalLayout} that satisfies {@link\n     * ExternalLayout#isCount|isCount()}. */ this.length = length;\n    }\n    /** @override */ getSpan(b, offset) {\n        let span = this.span;\n        if (0 > span) {\n            span = this.length.decode(b, offset);\n        }\n        return span;\n    }\n    /** @override */ decode(b, offset) {\n        if (undefined === offset) {\n            offset = 0;\n        }\n        let span = this.span;\n        if (0 > span) {\n            span = this.length.decode(b, offset);\n        }\n        return b.slice(offset, offset + span);\n    }\n    /** Implement {@link Layout#encode|encode} for {@link Blob}.\n   *\n   * **NOTE** If {@link Layout#count|count} is an instance of {@link\n   * ExternalLayout} then the length of `src` will be encoded as the\n   * count after `src` is encoded. */ encode(src, b, offset) {\n        let span = this.length;\n        if (this.length instanceof ExternalLayout) {\n            span = src.length;\n        }\n        if (!(Buffer.isBuffer(src) && span === src.length)) {\n            throw new TypeError(nameWithProperty(\"Blob.encode\", this) + \" requires (length \" + span + \") Buffer as src\");\n        }\n        if (offset + span > b.length) {\n            throw new RangeError(\"encoding overruns Buffer\");\n        }\n        b.write(src.toString(\"hex\"), offset, span, \"hex\");\n        if (this.length instanceof ExternalLayout) {\n            this.length.encode(span, b, offset);\n        }\n        return span;\n    }\n}\n/**\n * Contain a `NUL`-terminated UTF8 string.\n *\n * *Factory*: {@link module:Layout.cstr|cstr}\n *\n * **NOTE** Any UTF8 string that incorporates a zero-valued byte will\n * not be correctly decoded by this layout.\n *\n * @param {String} [property] - initializer for {@link\n * Layout#property|property}.\n *\n * @augments {Layout}\n */ class CString extends Layout {\n    constructor(property){\n        super(-1, property);\n    }\n    /** @override */ getSpan(b, offset) {\n        if (!Buffer.isBuffer(b)) {\n            throw new TypeError(\"b must be a Buffer\");\n        }\n        if (undefined === offset) {\n            offset = 0;\n        }\n        let idx = offset;\n        while(idx < b.length && 0 !== b[idx]){\n            idx += 1;\n        }\n        return 1 + idx - offset;\n    }\n    /** @override */ decode(b, offset, dest) {\n        if (undefined === offset) {\n            offset = 0;\n        }\n        let span = this.getSpan(b, offset);\n        return b.slice(offset, offset + span - 1).toString(\"utf-8\");\n    }\n    /** @override */ encode(src, b, offset) {\n        if (undefined === offset) {\n            offset = 0;\n        }\n        /* Must force this to a string, lest it be a number and the\n     * \"utf8-encoding\" below actually allocate a buffer of length\n     * src */ if (\"string\" !== typeof src) {\n            src = src.toString();\n        }\n        const srcb = new Buffer(src, \"utf8\");\n        const span = srcb.length;\n        if (offset + span > b.length) {\n            throw new RangeError(\"encoding overruns Buffer\");\n        }\n        srcb.copy(b, offset);\n        b[offset + span] = 0;\n        return span + 1;\n    }\n}\n/**\n * Contain a UTF8 string with implicit length.\n *\n * *Factory*: {@link module:Layout.utf8|utf8}\n *\n * **NOTE** Because the length is implicit in the size of the buffer\n * this layout should be used only in isolation, or in a situation\n * where the length can be expressed by operating on a slice of the\n * containing buffer.\n *\n * @param {Number} [maxSpan] - the maximum length allowed for encoded\n * string content.  If not provided there is no bound on the allowed\n * content.\n *\n * @param {String} [property] - initializer for {@link\n * Layout#property|property}.\n *\n * @augments {Layout}\n */ class UTF8 extends Layout {\n    constructor(maxSpan, property){\n        if (\"string\" === typeof maxSpan && undefined === property) {\n            property = maxSpan;\n            maxSpan = undefined;\n        }\n        if (undefined === maxSpan) {\n            maxSpan = -1;\n        } else if (!Number.isInteger(maxSpan)) {\n            throw new TypeError(\"maxSpan must be an integer\");\n        }\n        super(-1, property);\n        /** The maximum span of the layout in bytes.\n     *\n     * Positive values are generally expected.  Zero is abnormal.\n     * Attempts to encode or decode a value that exceeds this length\n     * will throw a `RangeError`.\n     *\n     * A negative value indicates that there is no bound on the length\n     * of the content. */ this.maxSpan = maxSpan;\n    }\n    /** @override */ getSpan(b, offset) {\n        if (!Buffer.isBuffer(b)) {\n            throw new TypeError(\"b must be a Buffer\");\n        }\n        if (undefined === offset) {\n            offset = 0;\n        }\n        return b.length - offset;\n    }\n    /** @override */ decode(b, offset, dest) {\n        if (undefined === offset) {\n            offset = 0;\n        }\n        let span = this.getSpan(b, offset);\n        if (0 <= this.maxSpan && this.maxSpan < span) {\n            throw new RangeError(\"text length exceeds maxSpan\");\n        }\n        return b.slice(offset, offset + span).toString(\"utf-8\");\n    }\n    /** @override */ encode(src, b, offset) {\n        if (undefined === offset) {\n            offset = 0;\n        }\n        /* Must force this to a string, lest it be a number and the\n     * \"utf8-encoding\" below actually allocate a buffer of length\n     * src */ if (\"string\" !== typeof src) {\n            src = src.toString();\n        }\n        const srcb = new Buffer(src, \"utf8\");\n        const span = srcb.length;\n        if (0 <= this.maxSpan && this.maxSpan < span) {\n            throw new RangeError(\"text length exceeds maxSpan\");\n        }\n        if (offset + span > b.length) {\n            throw new RangeError(\"encoding overruns Buffer\");\n        }\n        srcb.copy(b, offset);\n        return span;\n    }\n}\n/**\n * Contain a constant value.\n *\n * This layout may be used in cases where a JavaScript value can be\n * inferred without an expression in the binary encoding.  An example\n * would be a {@link VariantLayout|variant layout} where the content\n * is implied by the union {@link Union#discriminator|discriminator}.\n *\n * @param {Object|Number|String} value - initializer for {@link\n * Constant#value|value}.  If the value is an object (or array) and\n * the application intends the object to remain unchanged regardless\n * of what is done to values decoded by this layout, the value should\n * be frozen prior passing it to this constructor.\n *\n * @param {String} [property] - initializer for {@link\n * Layout#property|property}.\n *\n * @augments {Layout}\n */ class Constant extends Layout {\n    constructor(value, property){\n        super(0, property);\n        /** The value produced by this constant when the layout is {@link\n     * Constant#decode|decoded}.\n     *\n     * Any JavaScript value including `null` and `undefined` is\n     * permitted.\n     *\n     * **WARNING** If `value` passed in the constructor was not\n     * frozen, it is possible for users of decoded values to change\n     * the content of the value. */ this.value = value;\n    }\n    /** @override */ decode(b, offset, dest) {\n        return this.value;\n    }\n    /** @override */ encode(src, b, offset) {\n        /* Constants take no space */ return 0;\n    }\n}\nexports.ExternalLayout = ExternalLayout;\nexports.GreedyCount = GreedyCount;\nexports.OffsetLayout = OffsetLayout;\nexports.UInt = UInt;\nexports.UIntBE = UIntBE;\nexports.Int = Int;\nexports.IntBE = IntBE;\nexports.Float = Float;\nexports.FloatBE = FloatBE;\nexports.Double = Double;\nexports.DoubleBE = DoubleBE;\nexports.Sequence = Sequence;\nexports.Structure = Structure;\nexports.UnionDiscriminator = UnionDiscriminator;\nexports.UnionLayoutDiscriminator = UnionLayoutDiscriminator;\nexports.Union = Union;\nexports.VariantLayout = VariantLayout;\nexports.BitStructure = BitStructure;\nexports.BitField = BitField;\nexports.Boolean = Boolean;\nexports.Blob = Blob;\nexports.CString = CString;\nexports.UTF8 = UTF8;\nexports.Constant = Constant;\n/** Factory for {@link GreedyCount}. */ exports.greedy = (elementSpan, property)=>new GreedyCount(elementSpan, property);\n/** Factory for {@link OffsetLayout}. */ exports.offset = (layout, offset, property)=>new OffsetLayout(layout, offset, property);\n/** Factory for {@link UInt|unsigned int layouts} spanning one\n * byte. */ exports.u8 = (property)=>new UInt(1, property);\n/** Factory for {@link UInt|little-endian unsigned int layouts}\n * spanning two bytes. */ exports.u16 = (property)=>new UInt(2, property);\n/** Factory for {@link UInt|little-endian unsigned int layouts}\n * spanning three bytes. */ exports.u24 = (property)=>new UInt(3, property);\n/** Factory for {@link UInt|little-endian unsigned int layouts}\n * spanning four bytes. */ exports.u32 = (property)=>new UInt(4, property);\n/** Factory for {@link UInt|little-endian unsigned int layouts}\n * spanning five bytes. */ exports.u40 = (property)=>new UInt(5, property);\n/** Factory for {@link UInt|little-endian unsigned int layouts}\n * spanning six bytes. */ exports.u48 = (property)=>new UInt(6, property);\n/** Factory for {@link NearUInt64|little-endian unsigned int\n * layouts} interpreted as Numbers. */ exports.nu64 = (property)=>new NearUInt64(property);\n/** Factory for {@link UInt|big-endian unsigned int layouts}\n * spanning two bytes. */ exports.u16be = (property)=>new UIntBE(2, property);\n/** Factory for {@link UInt|big-endian unsigned int layouts}\n * spanning three bytes. */ exports.u24be = (property)=>new UIntBE(3, property);\n/** Factory for {@link UInt|big-endian unsigned int layouts}\n * spanning four bytes. */ exports.u32be = (property)=>new UIntBE(4, property);\n/** Factory for {@link UInt|big-endian unsigned int layouts}\n * spanning five bytes. */ exports.u40be = (property)=>new UIntBE(5, property);\n/** Factory for {@link UInt|big-endian unsigned int layouts}\n * spanning six bytes. */ exports.u48be = (property)=>new UIntBE(6, property);\n/** Factory for {@link NearUInt64BE|big-endian unsigned int\n * layouts} interpreted as Numbers. */ exports.nu64be = (property)=>new NearUInt64BE(property);\n/** Factory for {@link Int|signed int layouts} spanning one\n * byte. */ exports.s8 = (property)=>new Int(1, property);\n/** Factory for {@link Int|little-endian signed int layouts}\n * spanning two bytes. */ exports.s16 = (property)=>new Int(2, property);\n/** Factory for {@link Int|little-endian signed int layouts}\n * spanning three bytes. */ exports.s24 = (property)=>new Int(3, property);\n/** Factory for {@link Int|little-endian signed int layouts}\n * spanning four bytes. */ exports.s32 = (property)=>new Int(4, property);\n/** Factory for {@link Int|little-endian signed int layouts}\n * spanning five bytes. */ exports.s40 = (property)=>new Int(5, property);\n/** Factory for {@link Int|little-endian signed int layouts}\n * spanning six bytes. */ exports.s48 = (property)=>new Int(6, property);\n/** Factory for {@link NearInt64|little-endian signed int layouts}\n * interpreted as Numbers. */ exports.ns64 = (property)=>new NearInt64(property);\n/** Factory for {@link Int|big-endian signed int layouts}\n * spanning two bytes. */ exports.s16be = (property)=>new IntBE(2, property);\n/** Factory for {@link Int|big-endian signed int layouts}\n * spanning three bytes. */ exports.s24be = (property)=>new IntBE(3, property);\n/** Factory for {@link Int|big-endian signed int layouts}\n * spanning four bytes. */ exports.s32be = (property)=>new IntBE(4, property);\n/** Factory for {@link Int|big-endian signed int layouts}\n * spanning five bytes. */ exports.s40be = (property)=>new IntBE(5, property);\n/** Factory for {@link Int|big-endian signed int layouts}\n * spanning six bytes. */ exports.s48be = (property)=>new IntBE(6, property);\n/** Factory for {@link NearInt64BE|big-endian signed int layouts}\n * interpreted as Numbers. */ exports.ns64be = (property)=>new NearInt64BE(property);\n/** Factory for {@link Float|little-endian 32-bit floating point} values. */ exports.f32 = (property)=>new Float(property);\n/** Factory for {@link FloatBE|big-endian 32-bit floating point} values. */ exports.f32be = (property)=>new FloatBE(property);\n/** Factory for {@link Double|little-endian 64-bit floating point} values. */ exports.f64 = (property)=>new Double(property);\n/** Factory for {@link DoubleBE|big-endian 64-bit floating point} values. */ exports.f64be = (property)=>new DoubleBE(property);\n/** Factory for {@link Structure} values. */ exports.struct = (fields, property, decodePrefixes)=>new Structure(fields, property, decodePrefixes);\n/** Factory for {@link BitStructure} values. */ exports.bits = (word, msb, property)=>new BitStructure(word, msb, property);\n/** Factory for {@link Sequence} values. */ exports.seq = (elementLayout, count, property)=>new Sequence(elementLayout, count, property);\n/** Factory for {@link Union} values. */ exports.union = (discr, defaultLayout, property)=>new Union(discr, defaultLayout, property);\n/** Factory for {@link UnionLayoutDiscriminator} values. */ exports.unionLayoutDiscriminator = (layout, property)=>new UnionLayoutDiscriminator(layout, property);\n/** Factory for {@link Blob} values. */ exports.blob = (length, property)=>new Blob(length, property);\n/** Factory for {@link CString} values. */ exports.cstr = (property)=>new CString(property);\n/** Factory for {@link UTF8} values. */ exports.utf8 = (maxSpan, property)=>new UTF8(maxSpan, property);\n/** Factory for {@link Constant} values. */ exports[\"const\"] = (value, property)=>new Constant(value, property);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vYW5jaG9yL25vZGVfbW9kdWxlcy9idWZmZXItbGF5b3V0L2xpYi9MYXlvdXQuanMiLCJtYXBwaW5ncyI6IkFBQUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztDQXFCQyxHQUVEOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztDQTJHQyxHQUVEO0FBRUE7Ozs7Ozs7Ozs7Ozs7OztDQWVDLEdBQ0QsTUFBTUE7SUFDSkMsWUFBWUMsSUFBSSxFQUFFQyxRQUFRLENBQUU7UUFDMUIsSUFBSSxDQUFDQyxPQUFPQyxTQUFTLENBQUNILE9BQU87WUFDM0IsTUFBTSxJQUFJSSxVQUFVO1FBQ3RCO1FBRUE7Ozs7Ozs7OzhEQVEwRCxHQUMxRCxJQUFJLENBQUNKLElBQUksR0FBR0E7UUFFWjs7Ozs7Ozt1QkFPbUIsR0FDbkIsSUFBSSxDQUFDQyxRQUFRLEdBQUdBO0lBQ2xCO0lBRUE7Ozs7Ozs7Ozs7Ozs7O0dBY0MsR0FDREksd0JBQXdCO1FBQ3RCLE9BQU8sQ0FBQztJQUNWO0lBRUE7Ozs7Ozs7Ozs7O0dBV0MsR0FDREMsT0FBT0MsQ0FBQyxFQUFFQyxNQUFNLEVBQUU7UUFDaEIsTUFBTSxJQUFJQyxNQUFNO0lBQ2xCO0lBRUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztHQXFCQyxHQUNEQyxPQUFPQyxHQUFHLEVBQUVKLENBQUMsRUFBRUMsTUFBTSxFQUFFO1FBQ3JCLE1BQU0sSUFBSUMsTUFBTTtJQUNsQjtJQUVBOzs7Ozs7Ozs7Ozs7Ozs7R0FlQyxHQUNERyxRQUFRTCxDQUFDLEVBQUVDLE1BQU0sRUFBRTtRQUNqQixJQUFJLElBQUksSUFBSSxDQUFDUixJQUFJLEVBQUU7WUFDakIsTUFBTSxJQUFJYSxXQUFXO1FBQ3ZCO1FBQ0EsT0FBTyxJQUFJLENBQUNiLElBQUk7SUFDbEI7SUFFQTs7Ozs7Ozs7Ozs7Ozs7O0dBZUMsR0FD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QU9DLGVBQWVySDtBQUVyRix5REFBeUQsR0FDekRzQixnQ0FBZ0MsR0FBSSxDQUFDTSxRQUFRNUIsV0FBYSxJQUFJa0gseUJBQXlCdEYsUUFBUTVCO0FBRS9GLHFDQUFxQyxHQUNyQ3NCLFlBQVksR0FBSSxDQUFDa0IsUUFBUXhDLFdBQWEsSUFBSW1LLEtBQUszSCxRQUFReEM7QUFFdkQsd0NBQXdDLEdBQ3hDc0IsWUFBWSxHQUFJdEIsQ0FBQUEsV0FBWSxJQUFJdUssUUFBUXZLO0FBRXhDLHFDQUFxQyxHQUNyQ3NCLFlBQVksR0FBSSxDQUFDcUosU0FBUzNLLFdBQWEsSUFBSTBLLEtBQUtDLFNBQVMzSztBQUV6RCx5Q0FBeUMsR0FDekNzQixnQkFBYSxHQUFJLENBQUNXLE9BQU9qQyxXQUFhLElBQUk0SyxTQUFTM0ksT0FBT2pDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4uL2FuY2hvci9ub2RlX21vZHVsZXMvYnVmZmVyLWxheW91dC9saWIvTGF5b3V0LmpzPzlhMDciXSwic291cmNlc0NvbnRlbnQiOlsiLyogVGhlIE1JVCBMaWNlbnNlIChNSVQpXG4gKlxuICogQ29weXJpZ2h0IDIwMTUtMjAxOCBQZXRlciBBLiBCaWdvdFxuICpcbiAqIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcbiAqIG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWxcbiAqIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHNcbiAqIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcbiAqIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xuICogZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbiAqXG4gKiBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpblxuICogYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4gKlxuICogVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuICogSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG4gKiBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbiAqIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbiAqIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG4gKiBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOXG4gKiBUSEUgU09GVFdBUkUuXG4gKi9cblxuLyoqXG4gKiBTdXBwb3J0IGZvciB0cmFuc2xhdGluZyBiZXR3ZWVuIEJ1ZmZlciBpbnN0YW5jZXMgYW5kIEphdmFTY3JpcHRcbiAqIG5hdGl2ZSB0eXBlcy5cbiAqXG4gKiB7QGxpbmsgbW9kdWxlOkxheW91dH5MYXlvdXR8TGF5b3V0fSBpcyB0aGUgYmFzaXMgb2YgYSBjbGFzc1xuICogaGllcmFyY2h5IHRoYXQgYXNzb2NpYXRlcyBwcm9wZXJ0eSBuYW1lcyB3aXRoIHNlcXVlbmNlcyBvZiBlbmNvZGVkXG4gKiBieXRlcy5cbiAqXG4gKiBMYXlvdXRzIGFyZSBzdXBwb3J0ZWQgZm9yIHRoZXNlIHNjYWxhciAobnVtZXJpYykgdHlwZXM6XG4gKiAqIHtAbGluayBtb2R1bGU6TGF5b3V0flVJbnR8VW5zaWduZWQgaW50ZWdlcnMgaW4gbGl0dGxlLWVuZGlhblxuICogICBmb3JtYXR9IHdpdGgge0BsaW5rIG1vZHVsZTpMYXlvdXQudTh8OC1iaXR9LCB7QGxpbmtcbiAqICAgbW9kdWxlOkxheW91dC51MTZ8MTYtYml0fSwge0BsaW5rIG1vZHVsZTpMYXlvdXQudTI0fDI0LWJpdH0sXG4gKiAgIHtAbGluayBtb2R1bGU6TGF5b3V0LnUzMnwzMi1iaXR9LCB7QGxpbmtcbiAqICAgbW9kdWxlOkxheW91dC51NDB8NDAtYml0fSwgYW5kIHtAbGluayBtb2R1bGU6TGF5b3V0LnU0OHw0OC1iaXR9XG4gKiAgIHJlcHJlc2VudGF0aW9uIHJhbmdlcztcbiAqICoge0BsaW5rIG1vZHVsZTpMYXlvdXR+VUludEJFfFVuc2lnbmVkIGludGVnZXJzIGluIGJpZy1lbmRpYW5cbiAqICAgZm9ybWF0fSB3aXRoIHtAbGluayBtb2R1bGU6TGF5b3V0LnUxNmJlfDE2LWJpdH0sIHtAbGlua1xuICogICBtb2R1bGU6TGF5b3V0LnUyNGJlfDI0LWJpdH0sIHtAbGluayBtb2R1bGU6TGF5b3V0LnUzMmJlfDMyLWJpdH0sXG4gKiAgIHtAbGluayBtb2R1bGU6TGF5b3V0LnU0MGJlfDQwLWJpdH0sIGFuZCB7QGxpbmtcbiAqICAgbW9kdWxlOkxheW91dC51NDhiZXw0OC1iaXR9IHJlcHJlc2VudGF0aW9uIHJhbmdlcztcbiAqICoge0BsaW5rIG1vZHVsZTpMYXlvdXR+SW50fFNpZ25lZCBpbnRlZ2VycyBpbiBsaXR0bGUtZW5kaWFuXG4gKiAgIGZvcm1hdH0gd2l0aCB7QGxpbmsgbW9kdWxlOkxheW91dC5zOHw4LWJpdH0sIHtAbGlua1xuICogICBtb2R1bGU6TGF5b3V0LnMxNnwxNi1iaXR9LCB7QGxpbmsgbW9kdWxlOkxheW91dC5zMjR8MjQtYml0fSxcbiAqICAge0BsaW5rIG1vZHVsZTpMYXlvdXQuczMyfDMyLWJpdH0sIHtAbGlua1xuICogICBtb2R1bGU6TGF5b3V0LnM0MHw0MC1iaXR9LCBhbmQge0BsaW5rIG1vZHVsZTpMYXlvdXQuczQ4fDQ4LWJpdH1cbiAqICAgcmVwcmVzZW50YXRpb24gcmFuZ2VzO1xuICogKiB7QGxpbmsgbW9kdWxlOkxheW91dH5JbnRCRXxTaWduZWQgaW50ZWdlcnMgaW4gYmlnLWVuZGlhbiBmb3JtYXR9XG4gKiAgIHdpdGgge0BsaW5rIG1vZHVsZTpMYXlvdXQuczE2YmV8MTYtYml0fSwge0BsaW5rXG4gKiAgIG1vZHVsZTpMYXlvdXQuczI0YmV8MjQtYml0fSwge0BsaW5rIG1vZHVsZTpMYXlvdXQuczMyYmV8MzItYml0fSxcbiAqICAge0BsaW5rIG1vZHVsZTpMYXlvdXQuczQwYmV8NDAtYml0fSwgYW5kIHtAbGlua1xuICogICBtb2R1bGU6TGF5b3V0LnM0OGJlfDQ4LWJpdH0gcmVwcmVzZW50YXRpb24gcmFuZ2VzO1xuICogKiA2NC1iaXQgaW50ZWdyYWwgdmFsdWVzIHRoYXQgZGVjb2RlIHRvIGFuIGV4YWN0IChpZiBtYWduaXR1ZGUgaXNcbiAqICAgbGVzcyB0aGFuIDJeNTMpIG9yIG5lYXJieSBpbnRlZ3JhbCBOdW1iZXIgaW4ge0BsaW5rXG4gKiAgIG1vZHVsZTpMYXlvdXQubnU2NHx1bnNpZ25lZCBsaXR0bGUtZW5kaWFufSwge0BsaW5rXG4gKiAgIG1vZHVsZTpMYXlvdXQubnU2NGJlfHVuc2lnbmVkIGJpZy1lbmRpYW59LCB7QGxpbmtcbiAqICAgbW9kdWxlOkxheW91dC5uczY0fHNpZ25lZCBsaXR0bGUtZW5kaWFufSwgYW5kIHtAbGlua1xuICogICBtb2R1bGU6TGF5b3V0Lm5zNjRiZXx1bnNpZ25lZCBiaWctZW5kaWFufSBlbmNvZGluZ3M7XG4gKiAqIDMyLWJpdCBmbG9hdGluZyBwb2ludCB2YWx1ZXMgd2l0aCB7QGxpbmtcbiAqICAgbW9kdWxlOkxheW91dC5mMzJ8bGl0dGxlLWVuZGlhbn0gYW5kIHtAbGlua1xuICogICBtb2R1bGU6TGF5b3V0LmYzMmJlfGJpZy1lbmRpYW59IHJlcHJlc2VudGF0aW9ucztcbiAqICogNjQtYml0IGZsb2F0aW5nIHBvaW50IHZhbHVlcyB3aXRoIHtAbGlua1xuICogICBtb2R1bGU6TGF5b3V0LmY2NHxsaXR0bGUtZW5kaWFufSBhbmQge0BsaW5rXG4gKiAgIG1vZHVsZTpMYXlvdXQuZjY0YmV8YmlnLWVuZGlhbn0gcmVwcmVzZW50YXRpb25zO1xuICogKiB7QGxpbmsgbW9kdWxlOkxheW91dC5jb25zdHxDb25zdGFudHN9IHRoYXQgdGFrZSBubyBzcGFjZSBpbiB0aGVcbiAqICAgZW5jb2RlZCBleHByZXNzaW9uLlxuICpcbiAqIGFuZCBmb3IgdGhlc2UgYWdncmVnYXRlIHR5cGVzOlxuICogKiB7QGxpbmsgbW9kdWxlOkxheW91dC5zZXF8U2VxdWVuY2V9cyBvZiBpbnN0YW5jZXMgb2YgYSB7QGxpbmtcbiAqICAgbW9kdWxlOkxheW91dH5MYXlvdXR8TGF5b3V0fSwgd2l0aCBKYXZhU2NyaXB0IHJlcHJlc2VudGF0aW9uIGFzXG4gKiAgIGFuIEFycmF5IGFuZCBjb25zdGFudCBvciBkYXRhLWRlcGVuZGVudCB7QGxpbmtcbiAqICAgbW9kdWxlOkxheW91dH5TZXF1ZW5jZSNjb3VudHxsZW5ndGh9O1xuICogKiB7QGxpbmsgbW9kdWxlOkxheW91dC5zdHJ1Y3R8U3RydWN0dXJlfXMgdGhhdCBhZ2dyZWdhdGUgYVxuICogICBoZXRlcm9nZW5lb3VzIHNlcXVlbmNlIG9mIHtAbGluayBtb2R1bGU6TGF5b3V0fkxheW91dHxMYXlvdXR9XG4gKiAgIGluc3RhbmNlcywgd2l0aCBKYXZhU2NyaXB0IHJlcHJlc2VudGF0aW9uIGFzIGFuIE9iamVjdDtcbiAqICoge0BsaW5rIG1vZHVsZTpMYXlvdXQudW5pb258VW5pb259cyB0aGF0IHN1cHBvcnQgbXVsdGlwbGUge0BsaW5rXG4gKiAgIG1vZHVsZTpMYXlvdXR+VmFyaWFudExheW91dHx2YXJpYW50IGxheW91dHN9IG92ZXIgYSBmaXhlZFxuICogICAocGFkZGVkKSBvciB2YXJpYWJsZSAobm90IHBhZGRlZCkgc3BhbiBvZiBieXRlcywgdXNpbmcgYW5cbiAqICAgdW5zaWduZWQgaW50ZWdlciBhdCB0aGUgc3RhcnQgb2YgdGhlIGRhdGEgb3IgYSBzZXBhcmF0ZSB7QGxpbmtcbiAqICAgbW9kdWxlOkxheW91dC51bmlvbkxheW91dERpc2NyaW1pbmF0b3J8bGF5b3V0IGVsZW1lbnR9IHRvXG4gKiAgIGRldGVybWluZSB3aGljaCBsYXlvdXQgdG8gdXNlIHdoZW4gaW50ZXJwcmV0aW5nIHRoZSBidWZmZXJcbiAqICAgY29udGVudHM7XG4gKiAqIHtAbGluayBtb2R1bGU6TGF5b3V0LmJpdHN8Qml0U3RydWN0dXJlfXMgdGhhdCBjb250YWluIGEgc2VxdWVuY2VcbiAqICAgb2YgaW5kaXZpZHVhbCB7QGxpbmtcbiAqICAgbW9kdWxlOkxheW91dH5CaXRTdHJ1Y3R1cmUjYWRkRmllbGR8Qml0RmllbGR9cyBwYWNrZWQgaW50byBhbiA4LFxuICogICAxNiwgMjQsIG9yIDMyLWJpdCB1bnNpZ25lZCBpbnRlZ2VyIHN0YXJ0aW5nIGF0IHRoZSBsZWFzdC0gb3JcbiAqICAgbW9zdC1zaWduaWZpY2FudCBiaXQ7XG4gKiAqIHtAbGluayBtb2R1bGU6TGF5b3V0LmNzdHJ8QyBzdHJpbmdzfSBvZiB2YXJ5aW5nIGxlbmd0aDtcbiAqICoge0BsaW5rIG1vZHVsZTpMYXlvdXQuYmxvYnxCbG9ic30gb2YgZml4ZWQtIG9yIHZhcmlhYmxlLXtAbGlua1xuICogICBtb2R1bGU6TGF5b3V0fkJsb2IjbGVuZ3RofGxlbmd0aH0gcmF3IGRhdGEuXG4gKlxuICogQWxsIHtAbGluayBtb2R1bGU6TGF5b3V0fkxheW91dHxMYXlvdXR9IGluc3RhbmNlcyBhcmUgaW1tdXRhYmxlXG4gKiBhZnRlciBjb25zdHJ1Y3Rpb24sIHRvIHByZXZlbnQgaW50ZXJuYWwgc3RhdGUgZnJvbSBiZWNvbWluZ1xuICogaW5jb25zaXN0ZW50LlxuICpcbiAqIEBsb2NhbCBMYXlvdXRcbiAqIEBsb2NhbCBFeHRlcm5hbExheW91dFxuICogQGxvY2FsIEdyZWVkeUNvdW50XG4gKiBAbG9jYWwgT2Zmc2V0TGF5b3V0XG4gKiBAbG9jYWwgVUludFxuICogQGxvY2FsIFVJbnRCRVxuICogQGxvY2FsIEludFxuICogQGxvY2FsIEludEJFXG4gKiBAbG9jYWwgTmVhclVJbnQ2NFxuICogQGxvY2FsIE5lYXJVSW50NjRCRVxuICogQGxvY2FsIE5lYXJJbnQ2NFxuICogQGxvY2FsIE5lYXJJbnQ2NEJFXG4gKiBAbG9jYWwgRmxvYXRcbiAqIEBsb2NhbCBGbG9hdEJFXG4gKiBAbG9jYWwgRG91YmxlXG4gKiBAbG9jYWwgRG91YmxlQkVcbiAqIEBsb2NhbCBTZXF1ZW5jZVxuICogQGxvY2FsIFN0cnVjdHVyZVxuICogQGxvY2FsIFVuaW9uRGlzY3JpbWluYXRvclxuICogQGxvY2FsIFVuaW9uTGF5b3V0RGlzY3JpbWluYXRvclxuICogQGxvY2FsIFVuaW9uXG4gKiBAbG9jYWwgVmFyaWFudExheW91dFxuICogQGxvY2FsIEJpdFN0cnVjdHVyZVxuICogQGxvY2FsIEJpdEZpZWxkXG4gKiBAbG9jYWwgQm9vbGVhblxuICogQGxvY2FsIEJsb2JcbiAqIEBsb2NhbCBDU3RyaW5nXG4gKiBAbG9jYWwgQ29uc3RhbnRcbiAqIEBsb2NhbCBiaW5kQ29uc3RydWN0b3JMYXlvdXRcbiAqIEBtb2R1bGUgTGF5b3V0XG4gKiBAbGljZW5zZSBNSVRcbiAqIEBhdXRob3IgUGV0ZXIgQS4gQmlnb3RcbiAqIEBzZWUge0BsaW5rIGh0dHBzOi8vZ2l0aHViLmNvbS9wYWJpZ290L2J1ZmZlci1sYXlvdXR8YnVmZmVyLWxheW91dCBvbiBHaXRIdWJ9XG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIEJhc2UgY2xhc3MgZm9yIGxheW91dCBvYmplY3RzLlxuICpcbiAqICoqTk9URSoqIFRoaXMgaXMgYW4gYWJzdHJhY3QgYmFzZSBjbGFzczsgeW91IGNhbiBjcmVhdGUgaW5zdGFuY2VzXG4gKiBpZiBpdCBhbXVzZXMgeW91LCBidXQgdGhleSB3b24ndCBzdXBwb3J0IHRoZSB7QGxpbmtcbiAqIExheW91dCNlbmNvZGV8ZW5jb2RlfSBvciB7QGxpbmsgTGF5b3V0I2RlY29kZXxkZWNvZGV9IGZ1bmN0aW9ucy5cbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gc3BhbiAtIEluaXRpYWxpemVyIGZvciB7QGxpbmsgTGF5b3V0I3NwYW58c3Bhbn0uICBUaGVcbiAqIHBhcmFtZXRlciBtdXN0IGJlIGFuIGludGVnZXI7IGEgbmVnYXRpdmUgdmFsdWUgc2lnbmlmaWVzIHRoYXQgdGhlXG4gKiBzcGFuIGlzIHtAbGluayBMYXlvdXQjZ2V0U3Bhbnx2YWx1ZS1zcGVjaWZpY30uXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IFtwcm9wZXJ0eV0gLSBJbml0aWFsaXplciBmb3Ige0BsaW5rXG4gKiBMYXlvdXQjcHJvcGVydHl8cHJvcGVydHl9LlxuICpcbiAqIEBhYnN0cmFjdFxuICovXG5jbGFzcyBMYXlvdXQge1xuICBjb25zdHJ1Y3RvcihzcGFuLCBwcm9wZXJ0eSkge1xuICAgIGlmICghTnVtYmVyLmlzSW50ZWdlcihzcGFuKSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignc3BhbiBtdXN0IGJlIGFuIGludGVnZXInKTtcbiAgICB9XG5cbiAgICAvKiogVGhlIHNwYW4gb2YgdGhlIGxheW91dCBpbiBieXRlcy5cbiAgICAgKlxuICAgICAqIFBvc2l0aXZlIHZhbHVlcyBhcmUgZ2VuZXJhbGx5IGV4cGVjdGVkLlxuICAgICAqXG4gICAgICogWmVybyB3aWxsIG9ubHkgYXBwZWFyIGluIHtAbGluayBDb25zdGFudH1zIGFuZCBpbiB7QGxpbmtcbiAgICAgKiBTZXF1ZW5jZX1zIHdoZXJlIHRoZSB7QGxpbmsgU2VxdWVuY2UjY291bnR8Y291bnR9IGlzIHplcm8uXG4gICAgICpcbiAgICAgKiBBIG5lZ2F0aXZlIHZhbHVlIGluZGljYXRlcyB0aGF0IHRoZSBzcGFuIGlzIHZhbHVlLXNwZWNpZmljLCBhbmRcbiAgICAgKiBtdXN0IGJlIG9idGFpbmVkIHVzaW5nIHtAbGluayBMYXlvdXQjZ2V0U3BhbnxnZXRTcGFufS4gKi9cbiAgICB0aGlzLnNwYW4gPSBzcGFuO1xuXG4gICAgLyoqIFRoZSBwcm9wZXJ0eSBuYW1lIHVzZWQgd2hlbiB0aGlzIGxheW91dCBpcyByZXByZXNlbnRlZCBpbiBhblxuICAgICAqIE9iamVjdC5cbiAgICAgKlxuICAgICAqIFVzZWQgb25seSBmb3IgbGF5b3V0cyB0aGF0IHtAbGluayBMYXlvdXQjZGVjb2RlfGRlY29kZX0gdG8gT2JqZWN0XG4gICAgICogaW5zdGFuY2VzLiAgSWYgbGVmdCB1bmRlZmluZWQgdGhlIHNwYW4gb2YgdGhlIHVubmFtZWQgbGF5b3V0IHdpbGxcbiAgICAgKiBiZSB0cmVhdGVkIGFzIHBhZGRpbmc6IGl0IHdpbGwgbm90IGJlIG11dGF0ZWQgYnkge0BsaW5rXG4gICAgICogTGF5b3V0I2VuY29kZXxlbmNvZGV9IG5vciByZXByZXNlbnRlZCBhcyBhIHByb3BlcnR5IGluIHRoZVxuICAgICAqIGRlY29kZWQgT2JqZWN0LiAqL1xuICAgIHRoaXMucHJvcGVydHkgPSBwcm9wZXJ0eTtcbiAgfVxuXG4gIC8qKiBGdW5jdGlvbiB0byBjcmVhdGUgYW4gT2JqZWN0IGludG8gd2hpY2ggZGVjb2RlZCBwcm9wZXJ0aWVzIHdpbGxcbiAgICogYmUgd3JpdHRlbi5cbiAgICpcbiAgICogVXNlZCBvbmx5IGZvciBsYXlvdXRzIHRoYXQge0BsaW5rIExheW91dCNkZWNvZGV8ZGVjb2RlfSB0byBPYmplY3RcbiAgICogaW5zdGFuY2VzLCB3aGljaCBtZWFuczpcbiAgICogKiB7QGxpbmsgU3RydWN0dXJlfVxuICAgKiAqIHtAbGluayBVbmlvbn1cbiAgICogKiB7QGxpbmsgVmFyaWFudExheW91dH1cbiAgICogKiB7QGxpbmsgQml0U3RydWN0dXJlfVxuICAgKlxuICAgKiBJZiBsZWZ0IHVuZGVmaW5lZCB0aGUgSmF2YVNjcmlwdCByZXByZXNlbnRhdGlvbiBvZiB0aGVzZSBsYXlvdXRzXG4gICAqIHdpbGwgYmUgT2JqZWN0IGluc3RhbmNlcy5cbiAgICpcbiAgICogU2VlIHtAbGluayBiaW5kQ29uc3RydWN0b3JMYXlvdXR9LlxuICAgKi9cbiAgbWFrZURlc3RpbmF0aW9uT2JqZWN0KCkge1xuICAgIHJldHVybiB7fTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZWNvZGUgZnJvbSBhIEJ1ZmZlciBpbnRvIGFuIEphdmFTY3JpcHQgdmFsdWUuXG4gICAqXG4gICAqIEBwYXJhbSB7QnVmZmVyfSBiIC0gdGhlIGJ1ZmZlciBmcm9tIHdoaWNoIGVuY29kZWQgZGF0YSBpcyByZWFkLlxuICAgKlxuICAgKiBAcGFyYW0ge051bWJlcn0gW29mZnNldF0gLSB0aGUgb2Zmc2V0IGF0IHdoaWNoIHRoZSBlbmNvZGVkIGRhdGFcbiAgICogc3RhcnRzLiAgSWYgYWJzZW50IGEgemVybyBvZmZzZXQgaXMgaW5mZXJyZWQuXG4gICAqXG4gICAqIEByZXR1cm5zIHsoTnVtYmVyfEFycmF5fE9iamVjdCl9IC0gdGhlIHZhbHVlIG9mIHRoZSBkZWNvZGVkIGRhdGEuXG4gICAqXG4gICAqIEBhYnN0cmFjdFxuICAgKi9cbiAgZGVjb2RlKGIsIG9mZnNldCkge1xuICAgIHRocm93IG5ldyBFcnJvcignTGF5b3V0IGlzIGFic3RyYWN0Jyk7XG4gIH1cblxuICAvKipcbiAgICogRW5jb2RlIGEgSmF2YVNjcmlwdCB2YWx1ZSBpbnRvIGEgQnVmZmVyLlxuICAgKlxuICAgKiBAcGFyYW0geyhOdW1iZXJ8QXJyYXl8T2JqZWN0KX0gc3JjIC0gdGhlIHZhbHVlIHRvIGJlIGVuY29kZWQgaW50b1xuICAgKiB0aGUgYnVmZmVyLiAgVGhlIHR5cGUgYWNjZXB0ZWQgZGVwZW5kcyBvbiB0aGUgKHN1Yi0pdHlwZSBvZiB7QGxpbmtcbiAgICogTGF5b3V0fS5cbiAgICpcbiAgICogQHBhcmFtIHtCdWZmZXJ9IGIgLSB0aGUgYnVmZmVyIGludG8gd2hpY2ggZW5jb2RlZCBkYXRhIHdpbGwgYmVcbiAgICogd3JpdHRlbi5cbiAgICpcbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtvZmZzZXRdIC0gdGhlIG9mZnNldCBhdCB3aGljaCB0aGUgZW5jb2RlZCBkYXRhXG4gICAqIHN0YXJ0cy4gIElmIGFic2VudCBhIHplcm8gb2Zmc2V0IGlzIGluZmVycmVkLlxuICAgKlxuICAgKiBAcmV0dXJucyB7TnVtYmVyfSAtIHRoZSBudW1iZXIgb2YgYnl0ZXMgZW5jb2RlZCwgaW5jbHVkaW5nIHRoZVxuICAgKiBzcGFjZSBza2lwcGVkIGZvciBpbnRlcm5hbCBwYWRkaW5nLCBidXQgZXhjbHVkaW5nIGRhdGEgc3VjaCBhc1xuICAgKiB7QGxpbmsgU2VxdWVuY2UjY291bnR8bGVuZ3Roc30gd2hlbiBzdG9yZWQge0BsaW5rXG4gICAqIEV4dGVybmFsTGF5b3V0fGV4dGVybmFsbHl9LiAgVGhpcyBpcyB0aGUgYWRqdXN0bWVudCB0byBgb2Zmc2V0YFxuICAgKiBwcm9kdWNpbmcgdGhlIG9mZnNldCB3aGVyZSBkYXRhIGZvciB0aGUgbmV4dCBsYXlvdXQgd291bGQgYmVcbiAgICogd3JpdHRlbi5cbiAgICpcbiAgICogQGFic3RyYWN0XG4gICAqL1xuICBlbmNvZGUoc3JjLCBiLCBvZmZzZXQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0xheW91dCBpcyBhYnN0cmFjdCcpO1xuICB9XG5cbiAgLyoqXG4gICAqIENhbGN1bGF0ZSB0aGUgc3BhbiBvZiBhIHNwZWNpZmljIGluc3RhbmNlIG9mIGEgbGF5b3V0LlxuICAgKlxuICAgKiBAcGFyYW0ge0J1ZmZlcn0gYiAtIHRoZSBidWZmZXIgdGhhdCBjb250YWlucyBhbiBlbmNvZGVkIGluc3RhbmNlLlxuICAgKlxuICAgKiBAcGFyYW0ge051bWJlcn0gW29mZnNldF0gLSB0aGUgb2Zmc2V0IGF0IHdoaWNoIHRoZSBlbmNvZGVkIGluc3RhbmNlXG4gICAqIHN0YXJ0cy4gIElmIGFic2VudCBhIHplcm8gb2Zmc2V0IGlzIGluZmVycmVkLlxuICAgKlxuICAgKiBAcmV0dXJuIHtOdW1iZXJ9IC0gdGhlIG51bWJlciBvZiBieXRlcyBjb3ZlcmVkIGJ5IHRoZSBsYXlvdXRcbiAgICogaW5zdGFuY2UuICBJZiB0aGlzIG1ldGhvZCBpcyBub3Qgb3ZlcnJpZGRlbiBpbiBhIHN1YmNsYXNzIHRoZVxuICAgKiBkZWZpbml0aW9uLXRpbWUgY29uc3RhbnQge0BsaW5rIExheW91dCNzcGFufHNwYW59IHdpbGwgYmVcbiAgICogcmV0dXJuZWQuXG4gICAqXG4gICAqIEB0aHJvd3Mge1JhbmdlRXJyb3J9IC0gaWYgdGhlIGxlbmd0aCBvZiB0aGUgdmFsdWUgY2Fubm90IGJlXG4gICAqIGRldGVybWluZWQuXG4gICAqL1xuICBnZXRTcGFuKGIsIG9mZnNldCkge1xuICAgIGlmICgwID4gdGhpcy5zcGFuKSB7XG4gICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignaW5kZXRlcm1pbmF0ZSBzcGFuJyk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLnNwYW47XG4gIH1cblxuICAvKipcbiAgICogUmVwbGljYXRlIHRoZSBsYXlvdXQgdXNpbmcgYSBuZXcgcHJvcGVydHkuXG4gICAqXG4gICAqIFRoaXMgZnVuY3Rpb24gbXVzdCBiZSB1c2VkIHRvIGdldCBhIHN0cnVjdHVyYWxseS1lcXVpdmFsZW50IGxheW91dFxuICAgKiB3aXRoIGEgZGlmZmVyZW50IG5hbWUgc2luY2UgYWxsIHtAbGluayBMYXlvdXR9IGluc3RhbmNlcyBhcmVcbiAgICogaW1tdXRhYmxlLlxuICAgKlxuICAgKiAqKk5PVEUqKiBUaGlzIGlzIGEgc2hhbGxvdyBjb3B5LiAgQWxsIGZpZWxkcyBleGNlcHQge0BsaW5rXG4gICAqIExheW91dCNwcm9wZXJ0eXxwcm9wZXJ0eX0gYXJlIHN0cmljdGx5IGVxdWFsIHRvIHRoZSBvcmlnaW4gbGF5b3V0LlxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gcHJvcGVydHkgLSB0aGUgdmFsdWUgZm9yIHtAbGlua1xuICAgKiBMYXlvdXQjcHJvcGVydHl8cHJvcGVydHl9IGluIHRoZSByZXBsaWNhLlxuICAgKlxuICAgKiBAcmV0dXJucyB7TGF5b3V0fSAtIHRoZSBjb3B5IHdpdGgge0BsaW5rIExheW91dCNwcm9wZXJ0eXxwcm9wZXJ0eX1cbiAgICogc2V0IHRvIGBwcm9wZXJ0eWAuXG4gICAqL1xuICByZXBsaWNhdGUocHJvcGVydHkpIHtcbiAgICBjb25zdCBydiA9IE9iamVjdC5jcmVhdGUodGhpcy5jb25zdHJ1Y3Rvci5wcm90b3R5cGUpO1xuICAgIE9iamVjdC5hc3NpZ24ocnYsIHRoaXMpO1xuICAgIHJ2LnByb3BlcnR5ID0gcHJvcGVydHk7XG4gICAgcmV0dXJuIHJ2O1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhbiBvYmplY3QgZnJvbSBsYXlvdXQgcHJvcGVydGllcyBhbmQgYW4gYXJyYXkgb2YgdmFsdWVzLlxuICAgKlxuICAgKiAqKk5PVEUqKiBUaGlzIGZ1bmN0aW9uIHJldHVybnMgYHVuZGVmaW5lZGAgaWYgaW52b2tlZCBvbiBhIGxheW91dFxuICAgKiB0aGF0IGRvZXMgbm90IHJldHVybiBpdHMgdmFsdWUgYXMgYW4gT2JqZWN0LiAgT2JqZWN0cyBhcmVcbiAgICogcmV0dXJuZWQgZm9yIHRoaW5ncyB0aGF0IGFyZSBhIHtAbGluayBTdHJ1Y3R1cmV9LCB3aGljaCBpbmNsdWRlc1xuICAgKiB7QGxpbmsgVmFyaWFudExheW91dHx2YXJpYW50IGxheW91dHN9IGlmIHRoZXkgYXJlIHN0cnVjdHVyZXMsIGFuZFxuICAgKiBleGNsdWRlcyB7QGxpbmsgVW5pb259cy4gIElmIHlvdSB3YW50IHRoaXMgZmVhdHVyZSBmb3IgYSB1bmlvblxuICAgKiB5b3UgbXVzdCB1c2Uge0BsaW5rIFVuaW9uLmdldFZhcmlhbnR8Z2V0VmFyaWFudH0gdG8gc2VsZWN0IHRoZVxuICAgKiBkZXNpcmVkIGxheW91dC5cbiAgICpcbiAgICogQHBhcmFtIHtBcnJheX0gdmFsdWVzIC0gYW4gYXJyYXkgb2YgdmFsdWVzIHRoYXQgY29ycmVzcG9uZCB0byB0aGVcbiAgICogZGVmYXVsdCBvcmRlciBmb3IgcHJvcGVydGllcy4gIEFzIHdpdGgge0BsaW5rIExheW91dCNkZWNvZGV8ZGVjb2RlfVxuICAgKiBsYXlvdXQgZWxlbWVudHMgdGhhdCBoYXZlIG5vIHByb3BlcnR5IG5hbWUgYXJlIHNraXBwZWQgd2hlblxuICAgKiBpdGVyYXRpbmcgb3ZlciB0aGUgYXJyYXkgdmFsdWVzLiAgT25seSB0aGUgdG9wLWxldmVsIHByb3BlcnRpZXMgYXJlXG4gICAqIGFzc2lnbmVkOyBhcmd1bWVudHMgYXJlIG5vdCBhc3NpZ25lZCB0byBwcm9wZXJ0aWVzIG9mIGNvbnRhaW5lZFxuICAgKiBsYXlvdXRzLiAgQW55IHVudXNlZCB2YWx1ZXMgYXJlIGlnbm9yZWQuXG4gICAqXG4gICAqIEByZXR1cm4geyhPYmplY3R8dW5kZWZpbmVkKX1cbiAgICovXG4gIGZyb21BcnJheSh2YWx1ZXMpIHtcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG59XG5leHBvcnRzLkxheW91dCA9IExheW91dDtcblxuLyogUHJvdmlkZSB0ZXh0IHRoYXQgY2FycmllcyBhIG5hbWUgKHN1Y2ggYXMgZm9yIGEgZnVuY3Rpb24gdGhhdCB3aWxsXG4gKiBiZSB0aHJvd2luZyBhbiBlcnJvcikgYW5ub3RhdGVkIHdpdGggdGhlIHByb3BlcnR5IG9mIGEgZ2l2ZW4gbGF5b3V0XG4gKiAoc3VjaCBhcyBvbmUgZm9yIHdoaWNoIHRoZSB2YWx1ZSB3YXMgdW5hY2NlcHRhYmxlKS5cbiAqXG4gKiBAaWdub3JlICovXG5mdW5jdGlvbiBuYW1lV2l0aFByb3BlcnR5KG5hbWUsIGxvKSB7XG4gIGlmIChsby5wcm9wZXJ0eSkge1xuICAgIHJldHVybiBuYW1lICsgJ1snICsgbG8ucHJvcGVydHkgKyAnXSc7XG4gIH1cbiAgcmV0dXJuIG5hbWU7XG59XG5leHBvcnRzLm5hbWVXaXRoUHJvcGVydHkgPSBuYW1lV2l0aFByb3BlcnR5O1xuXG4vKipcbiAqIEF1Z21lbnQgYSBjbGFzcyBzbyB0aGF0IGluc3RhbmNlcyBjYW4gYmUgZW5jb2RlZC9kZWNvZGVkIHVzaW5nIGFcbiAqIGdpdmVuIGxheW91dC5cbiAqXG4gKiBDYWxsaW5nIHRoaXMgZnVuY3Rpb24gY291cGxlcyBgQ2xhc3NgIHdpdGggYGxheW91dGAgaW4gc2V2ZXJhbCB3YXlzOlxuICpcbiAqICogYENsYXNzLmxheW91dF9gIGJlY29tZXMgYSBzdGF0aWMgbWVtYmVyIHByb3BlcnR5IGVxdWFsIHRvIGBsYXlvdXRgO1xuICogKiBgbGF5b3V0LmJvdW5kQ29uc3RydWN0b3JfYCBiZWNvbWVzIGEgc3RhdGljIG1lbWJlciBwcm9wZXJ0eSBlcXVhbFxuICogICAgdG8gYENsYXNzYDtcbiAqICogVGhlIHtAbGluayBMYXlvdXQjbWFrZURlc3RpbmF0aW9uT2JqZWN0fG1ha2VEZXN0aW5hdGlvbk9iamVjdCgpfVxuICogICBwcm9wZXJ0eSBvZiBgbGF5b3V0YCBpcyBzZXQgdG8gYSBmdW5jdGlvbiB0aGF0IHJldHVybnMgYSBgbmV3XG4gKiAgIENsYXNzKClgO1xuICogKiBgQ2xhc3MuZGVjb2RlKGIsIG9mZnNldClgIGJlY29tZXMgYSBzdGF0aWMgbWVtYmVyIGZ1bmN0aW9uIHRoYXRcbiAqICAgZGVsZWdhdGVzIHRvIHtAbGluayBMYXlvdXQjZGVjb2RlfGxheW91dC5kZWNvZGV9LiAgVGhlXG4gKiAgIHN5bnRoZXNpemVkIGZ1bmN0aW9uIG1heSBiZSBjYXB0dXJlZCBhbmQgZXh0ZW5kZWQuXG4gKiAqIGBDbGFzcy5wcm90b3R5cGUuZW5jb2RlKGIsIG9mZnNldClgIHByb3ZpZGVzIGFuIGluc3RhbmNlIG1lbWJlclxuICogICBmdW5jdGlvbiB0aGF0IGRlbGVnYXRlcyB0byB7QGxpbmsgTGF5b3V0I2VuY29kZXxsYXlvdXQuZW5jb2RlfVxuICogICB3aXRoIGBzcmNgIHNldCB0byBgdGhpc2AuICBUaGUgc3ludGhlc2l6ZWQgZnVuY3Rpb24gbWF5IGJlXG4gKiAgIGNhcHR1cmVkIGFuZCBleHRlbmRlZCwgYnV0IHdoZW4gdGhlIGV4dGVuc2lvbiBpcyBpbnZva2VkIGB0aGlzYFxuICogICBtdXN0IGJlIGV4cGxpY2l0bHkgYm91bmQgdG8gdGhlIGluc3RhbmNlLlxuICpcbiAqIEBwYXJhbSB7Y2xhc3N9IENsYXNzIC0gYSBKYXZhU2NyaXB0IGNsYXNzIHdpdGggYSBudWxsYXJ5XG4gKiBjb25zdHJ1Y3Rvci5cbiAqXG4gKiBAcGFyYW0ge0xheW91dH0gbGF5b3V0IC0gdGhlIHtAbGluayBMYXlvdXR9IGluc3RhbmNlIHVzZWQgdG8gZW5jb2RlXG4gKiBpbnN0YW5jZXMgb2YgYENsYXNzYC5cbiAqL1xuZnVuY3Rpb24gYmluZENvbnN0cnVjdG9yTGF5b3V0KENsYXNzLCBsYXlvdXQpIHtcbiAgaWYgKCdmdW5jdGlvbicgIT09IHR5cGVvZiBDbGFzcykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0NsYXNzIG11c3QgYmUgY29uc3RydWN0b3InKTtcbiAgfVxuICBpZiAoQ2xhc3MuaGFzT3duUHJvcGVydHkoJ2xheW91dF8nKSkge1xuICAgIHRocm93IG5ldyBFcnJvcignQ2xhc3MgaXMgYWxyZWFkeSBib3VuZCB0byBhIGxheW91dCcpO1xuICB9XG4gIGlmICghKGxheW91dCAmJiAobGF5b3V0IGluc3RhbmNlb2YgTGF5b3V0KSkpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdsYXlvdXQgbXVzdCBiZSBhIExheW91dCcpO1xuICB9XG4gIGlmIChsYXlvdXQuaGFzT3duUHJvcGVydHkoJ2JvdW5kQ29uc3RydWN0b3JfJykpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2xheW91dCBpcyBhbHJlYWR5IGJvdW5kIHRvIGEgY29uc3RydWN0b3InKTtcbiAgfVxuICBDbGFzcy5sYXlvdXRfID0gbGF5b3V0O1xuICBsYXlvdXQuYm91bmRDb25zdHJ1Y3Rvcl8gPSBDbGFzcztcbiAgbGF5b3V0Lm1ha2VEZXN0aW5hdGlvbk9iamVjdCA9ICgoKSA9PiBuZXcgQ2xhc3MoKSk7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShDbGFzcy5wcm90b3R5cGUsICdlbmNvZGUnLCB7XG4gICAgdmFsdWU6IGZ1bmN0aW9uKGIsIG9mZnNldCkge1xuICAgICAgcmV0dXJuIGxheW91dC5lbmNvZGUodGhpcywgYiwgb2Zmc2V0KTtcbiAgICB9LFxuICAgIHdyaXRhYmxlOiB0cnVlLFxuICB9KTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KENsYXNzLCAnZGVjb2RlJywge1xuICAgIHZhbHVlOiBmdW5jdGlvbihiLCBvZmZzZXQpIHtcbiAgICAgIHJldHVybiBsYXlvdXQuZGVjb2RlKGIsIG9mZnNldCk7XG4gICAgfSxcbiAgICB3cml0YWJsZTogdHJ1ZSxcbiAgfSk7XG59XG5leHBvcnRzLmJpbmRDb25zdHJ1Y3RvckxheW91dCA9IGJpbmRDb25zdHJ1Y3RvckxheW91dDtcblxuLyoqXG4gKiBBbiBvYmplY3QgdGhhdCBiZWhhdmVzIGxpa2UgYSBsYXlvdXQgYnV0IGRvZXMgbm90IGNvbnN1bWUgc3BhY2VcbiAqIHdpdGhpbiBpdHMgY29udGFpbmluZyBsYXlvdXQuXG4gKlxuICogVGhpcyBpcyBwcmltYXJpbHkgdXNlZCB0byBvYnRhaW4gbWV0YWRhdGEgYWJvdXQgYSBtZW1iZXIsIHN1Y2ggYXMgYVxuICoge0BsaW5rIE9mZnNldExheW91dH0gdGhhdCBjYW4gcHJvdmlkZSBkYXRhIGFib3V0IGEge0BsaW5rXG4gKiBMYXlvdXQjZ2V0U3Bhbnx2YWx1ZS1zcGVjaWZpYyBzcGFufS5cbiAqXG4gKiAqKk5PVEUqKiBUaGlzIGlzIGFuIGFic3RyYWN0IGJhc2UgY2xhc3M7IHlvdSBjYW4gY3JlYXRlIGluc3RhbmNlc1xuICogaWYgaXQgYW11c2VzIHlvdSwgYnV0IHRoZXkgd29uJ3Qgc3VwcG9ydCB7QGxpbmtcbiAqIEV4dGVybmFsTGF5b3V0I2lzQ291bnR8aXNDb3VudH0gb3Igb3RoZXIge0BsaW5rIExheW91dH0gZnVuY3Rpb25zLlxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSBzcGFuIC0gaW5pdGlhbGl6ZXIgZm9yIHtAbGluayBMYXlvdXQjc3BhbnxzcGFufS5cbiAqIFRoZSBwYXJhbWV0ZXIgY2FuIHJhbmdlIGZyb20gMSB0aHJvdWdoIDYuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IFtwcm9wZXJ0eV0gLSBpbml0aWFsaXplciBmb3Ige0BsaW5rXG4gKiBMYXlvdXQjcHJvcGVydHl8cHJvcGVydHl9LlxuICpcbiAqIEBhYnN0cmFjdFxuICogQGF1Z21lbnRzIHtMYXlvdXR9XG4gKi9cbmNsYXNzIEV4dGVybmFsTGF5b3V0IGV4dGVuZHMgTGF5b3V0IHtcbiAgLyoqXG4gICAqIFJldHVybiBgdHJ1ZWAgaWZmIHRoZSBleHRlcm5hbCBsYXlvdXQgZGVjb2RlcyB0byBhbiB1bnNpZ25lZFxuICAgKiBpbnRlZ2VyIGxheW91dC5cbiAgICpcbiAgICogSW4gdGhhdCBjYXNlIGl0IGNhbiBiZSB1c2VkIGFzIHRoZSBzb3VyY2Ugb2Yge0BsaW5rXG4gICAqIFNlcXVlbmNlI2NvdW50fFNlcXVlbmNlIGNvdW50c30sIHtAbGluayBCbG9iI2xlbmd0aHxCbG9iIGxlbmd0aHN9LFxuICAgKiBvciBhcyB7QGxpbmsgVW5pb25MYXlvdXREaXNjcmltaW5hdG9yI2xheW91dHxleHRlcm5hbCB1bmlvblxuICAgKiBkaXNjcmltaW5hdG9yc30uXG4gICAqXG4gICAqIEBhYnN0cmFjdFxuICAgKi9cbiAgaXNDb3VudCgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0V4dGVybmFsTGF5b3V0IGlzIGFic3RyYWN0Jyk7XG4gIH1cbn1cblxuLyoqXG4gKiBBbiB7QGxpbmsgRXh0ZXJuYWxMYXlvdXR9IHRoYXQgZGV0ZXJtaW5lcyBpdHMge0BsaW5rXG4gKiBMYXlvdXQjZGVjb2RlfHZhbHVlfSBiYXNlZCBvbiBvZmZzZXQgaW50byBhbmQgbGVuZ3RoIG9mIHRoZSBidWZmZXJcbiAqIG9uIHdoaWNoIGl0IGlzIGludm9rZWQuXG4gKlxuICogKkZhY3RvcnkqOiB7QGxpbmsgbW9kdWxlOkxheW91dC5ncmVlZHl8Z3JlZWR5fVxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSBbZWxlbWVudFNwYW5dIC0gaW5pdGlhbGl6ZXIgZm9yIHtAbGlua1xuICogR3JlZWR5Q291bnQjZWxlbWVudFNwYW58ZWxlbWVudFNwYW59LlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBbcHJvcGVydHldIC0gaW5pdGlhbGl6ZXIgZm9yIHtAbGlua1xuICogTGF5b3V0I3Byb3BlcnR5fHByb3BlcnR5fS5cbiAqXG4gKiBAYXVnbWVudHMge0V4dGVybmFsTGF5b3V0fVxuICovXG5jbGFzcyBHcmVlZHlDb3VudCBleHRlbmRzIEV4dGVybmFsTGF5b3V0IHtcbiAgY29uc3RydWN0b3IoZWxlbWVudFNwYW4sIHByb3BlcnR5KSB7XG4gICAgaWYgKHVuZGVmaW5lZCA9PT0gZWxlbWVudFNwYW4pIHtcbiAgICAgIGVsZW1lbnRTcGFuID0gMTtcbiAgICB9XG4gICAgaWYgKCghTnVtYmVyLmlzSW50ZWdlcihlbGVtZW50U3BhbikpIHx8ICgwID49IGVsZW1lbnRTcGFuKSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignZWxlbWVudFNwYW4gbXVzdCBiZSBhIChwb3NpdGl2ZSkgaW50ZWdlcicpO1xuICAgIH1cbiAgICBzdXBlcigtMSwgcHJvcGVydHkpO1xuXG4gICAgLyoqIFRoZSBsYXlvdXQgZm9yIGluZGl2aWR1YWwgZWxlbWVudHMgb2YgdGhlIHNlcXVlbmNlLiAgVGhlIHZhbHVlXG4gICAgICogbXVzdCBiZSBhIHBvc2l0aXZlIGludGVnZXIuICBJZiBub3QgcHJvdmlkZWQsIHRoZSB2YWx1ZSB3aWxsIGJlXG4gICAgICogMS4gKi9cbiAgICB0aGlzLmVsZW1lbnRTcGFuID0gZWxlbWVudFNwYW47XG4gIH1cblxuICAvKiogQG92ZXJyaWRlICovXG4gIGlzQ291bnQoKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICAvKiogQG92ZXJyaWRlICovXG4gIGRlY29kZShiLCBvZmZzZXQpIHtcbiAgICBpZiAodW5kZWZpbmVkID09PSBvZmZzZXQpIHtcbiAgICAgIG9mZnNldCA9IDA7XG4gICAgfVxuICAgIGNvbnN0IHJlbSA9IGIubGVuZ3RoIC0gb2Zmc2V0O1xuICAgIHJldHVybiBNYXRoLmZsb29yKHJlbSAvIHRoaXMuZWxlbWVudFNwYW4pO1xuICB9XG5cbiAgLyoqIEBvdmVycmlkZSAqL1xuICBlbmNvZGUoc3JjLCBiLCBvZmZzZXQpIHtcbiAgICByZXR1cm4gMDtcbiAgfVxufVxuXG4vKipcbiAqIEFuIHtAbGluayBFeHRlcm5hbExheW91dH0gdGhhdCBzdXBwb3J0cyBhY2Nlc3NpbmcgYSB7QGxpbmsgTGF5b3V0fVxuICogYXQgYSBmaXhlZCBvZmZzZXQgZnJvbSB0aGUgc3RhcnQgb2YgYW5vdGhlciBMYXlvdXQuICBUaGUgb2Zmc2V0IG1heVxuICogYmUgYmVmb3JlLCB3aXRoaW4sIG9yIGFmdGVyIHRoZSBiYXNlIGxheW91dC5cbiAqXG4gKiAqRmFjdG9yeSo6IHtAbGluayBtb2R1bGU6TGF5b3V0Lm9mZnNldHxvZmZzZXR9XG4gKlxuICogQHBhcmFtIHtMYXlvdXR9IGxheW91dCAtIGluaXRpYWxpemVyIGZvciB7QGxpbmtcbiAqIE9mZnNldExheW91dCNsYXlvdXR8bGF5b3V0fSwgbW9kdWxvIGBwcm9wZXJ0eWAuXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IFtvZmZzZXRdIC0gSW5pdGlhbGl6ZXMge0BsaW5rXG4gKiBPZmZzZXRMYXlvdXQjb2Zmc2V0fG9mZnNldH0uICBEZWZhdWx0cyB0byB6ZXJvLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBbcHJvcGVydHldIC0gT3B0aW9uYWwgbmV3IHByb3BlcnR5IG5hbWUgZm9yIGFcbiAqIHtAbGluayBMYXlvdXQjcmVwbGljYXRlfCByZXBsaWNhfSBvZiBgbGF5b3V0YCB0byBiZSB1c2VkIGFzIHtAbGlua1xuICogT2Zmc2V0TGF5b3V0I2xheW91dHxsYXlvdXR9LiAgSWYgbm90IHByb3ZpZGVkIHRoZSBgbGF5b3V0YCBpcyB1c2VkXG4gKiB1bmNoYW5nZWQuXG4gKlxuICogQGF1Z21lbnRzIHtMYXlvdXR9XG4gKi9cbmNsYXNzIE9mZnNldExheW91dCBleHRlbmRzIEV4dGVybmFsTGF5b3V0IHtcbiAgY29uc3RydWN0b3IobGF5b3V0LCBvZmZzZXQsIHByb3BlcnR5KSB7XG4gICAgaWYgKCEobGF5b3V0IGluc3RhbmNlb2YgTGF5b3V0KSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignbGF5b3V0IG11c3QgYmUgYSBMYXlvdXQnKTtcbiAgICB9XG5cbiAgICBpZiAodW5kZWZpbmVkID09PSBvZmZzZXQpIHtcbiAgICAgIG9mZnNldCA9IDA7XG4gICAgfSBlbHNlIGlmICghTnVtYmVyLmlzSW50ZWdlcihvZmZzZXQpKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdvZmZzZXQgbXVzdCBiZSBpbnRlZ2VyIG9yIHVuZGVmaW5lZCcpO1xuICAgIH1cblxuICAgIHN1cGVyKGxheW91dC5zcGFuLCBwcm9wZXJ0eSB8fCBsYXlvdXQucHJvcGVydHkpO1xuXG4gICAgLyoqIFRoZSBzdWJvcmRpbmF0ZWQgbGF5b3V0LiAqL1xuICAgIHRoaXMubGF5b3V0ID0gbGF5b3V0O1xuXG4gICAgLyoqIFRoZSBsb2NhdGlvbiBvZiB7QGxpbmsgT2Zmc2V0TGF5b3V0I2xheW91dH0gcmVsYXRpdmUgdG8gdGhlXG4gICAgICogc3RhcnQgb2YgYW5vdGhlciBsYXlvdXQuXG4gICAgICpcbiAgICAgKiBUaGUgdmFsdWUgbWF5IGJlIHBvc2l0aXZlIG9yIG5lZ2F0aXZlLCBidXQgYW4gZXJyb3Igd2lsbCB0aHJvd25cbiAgICAgKiBpZiBhdCB0aGUgcG9pbnQgb2YgdXNlIGl0IGdvZXMgb3V0c2lkZSB0aGUgc3BhbiBvZiB0aGUgQnVmZmVyXG4gICAgICogYmVpbmcgYWNjZXNzZWQuICAqL1xuICAgIHRoaXMub2Zmc2V0ID0gb2Zmc2V0O1xuICB9XG5cbiAgLyoqIEBvdmVycmlkZSAqL1xuICBpc0NvdW50KCkge1xuICAgIHJldHVybiAoKHRoaXMubGF5b3V0IGluc3RhbmNlb2YgVUludClcbiAgICAgICAgICAgIHx8ICh0aGlzLmxheW91dCBpbnN0YW5jZW9mIFVJbnRCRSkpO1xuICB9XG5cbiAgLyoqIEBvdmVycmlkZSAqL1xuICBkZWNvZGUoYiwgb2Zmc2V0KSB7XG4gICAgaWYgKHVuZGVmaW5lZCA9PT0gb2Zmc2V0KSB7XG4gICAgICBvZmZzZXQgPSAwO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5sYXlvdXQuZGVjb2RlKGIsIG9mZnNldCArIHRoaXMub2Zmc2V0KTtcbiAgfVxuXG4gIC8qKiBAb3ZlcnJpZGUgKi9cbiAgZW5jb2RlKHNyYywgYiwgb2Zmc2V0KSB7XG4gICAgaWYgKHVuZGVmaW5lZCA9PT0gb2Zmc2V0KSB7XG4gICAgICBvZmZzZXQgPSAwO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5sYXlvdXQuZW5jb2RlKHNyYywgYiwgb2Zmc2V0ICsgdGhpcy5vZmZzZXQpO1xuICB9XG59XG5cbi8qKlxuICogUmVwcmVzZW50IGFuIHVuc2lnbmVkIGludGVnZXIgaW4gbGl0dGxlLWVuZGlhbiBmb3JtYXQuXG4gKlxuICogKkZhY3RvcnkqOiB7QGxpbmsgbW9kdWxlOkxheW91dC51OHx1OH0sIHtAbGlua1xuICogIG1vZHVsZTpMYXlvdXQudTE2fHUxNn0sIHtAbGluayBtb2R1bGU6TGF5b3V0LnUyNHx1MjR9LCB7QGxpbmtcbiAqICBtb2R1bGU6TGF5b3V0LnUzMnx1MzJ9LCB7QGxpbmsgbW9kdWxlOkxheW91dC51NDB8dTQwfSwge0BsaW5rXG4gKiAgbW9kdWxlOkxheW91dC51NDh8dTQ4fVxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSBzcGFuIC0gaW5pdGlhbGl6ZXIgZm9yIHtAbGluayBMYXlvdXQjc3BhbnxzcGFufS5cbiAqIFRoZSBwYXJhbWV0ZXIgY2FuIHJhbmdlIGZyb20gMSB0aHJvdWdoIDYuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IFtwcm9wZXJ0eV0gLSBpbml0aWFsaXplciBmb3Ige0BsaW5rXG4gKiBMYXlvdXQjcHJvcGVydHl8cHJvcGVydHl9LlxuICpcbiAqIEBhdWdtZW50cyB7TGF5b3V0fVxuICovXG5jbGFzcyBVSW50IGV4dGVuZHMgTGF5b3V0IHtcbiAgY29uc3RydWN0b3Ioc3BhbiwgcHJvcGVydHkpIHtcbiAgICBzdXBlcihzcGFuLCBwcm9wZXJ0eSk7XG4gICAgaWYgKDYgPCB0aGlzLnNwYW4pIHtcbiAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdzcGFuIG11c3Qgbm90IGV4Y2VlZCA2IGJ5dGVzJyk7XG4gICAgfVxuICB9XG5cbiAgLyoqIEBvdmVycmlkZSAqL1xuICBkZWNvZGUoYiwgb2Zmc2V0KSB7XG4gICAgaWYgKHVuZGVmaW5lZCA9PT0gb2Zmc2V0KSB7XG4gICAgICBvZmZzZXQgPSAwO1xuICAgIH1cbiAgICByZXR1cm4gYi5yZWFkVUludExFKG9mZnNldCwgdGhpcy5zcGFuKTtcbiAgfVxuXG4gIC8qKiBAb3ZlcnJpZGUgKi9cbiAgZW5jb2RlKHNyYywgYiwgb2Zmc2V0KSB7XG4gICAgaWYgKHVuZGVmaW5lZCA9PT0gb2Zmc2V0KSB7XG4gICAgICBvZmZzZXQgPSAwO1xuICAgIH1cbiAgICBiLndyaXRlVUludExFKHNyYywgb2Zmc2V0LCB0aGlzLnNwYW4pO1xuICAgIHJldHVybiB0aGlzLnNwYW47XG4gIH1cbn1cblxuLyoqXG4gKiBSZXByZXNlbnQgYW4gdW5zaWduZWQgaW50ZWdlciBpbiBiaWctZW5kaWFuIGZvcm1hdC5cbiAqXG4gKiAqRmFjdG9yeSo6IHtAbGluayBtb2R1bGU6TGF5b3V0LnU4YmV8dThiZX0sIHtAbGlua1xuICogbW9kdWxlOkxheW91dC51MTZiZXx1MTZiZX0sIHtAbGluayBtb2R1bGU6TGF5b3V0LnUyNGJlfHUyNGJlfSxcbiAqIHtAbGluayBtb2R1bGU6TGF5b3V0LnUzMmJlfHUzMmJlfSwge0BsaW5rXG4gKiBtb2R1bGU6TGF5b3V0LnU0MGJlfHU0MGJlfSwge0BsaW5rIG1vZHVsZTpMYXlvdXQudTQ4YmV8dTQ4YmV9XG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IHNwYW4gLSBpbml0aWFsaXplciBmb3Ige0BsaW5rIExheW91dCNzcGFufHNwYW59LlxuICogVGhlIHBhcmFtZXRlciBjYW4gcmFuZ2UgZnJvbSAxIHRocm91Z2ggNi5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gW3Byb3BlcnR5XSAtIGluaXRpYWxpemVyIGZvciB7QGxpbmtcbiAqIExheW91dCNwcm9wZXJ0eXxwcm9wZXJ0eX0uXG4gKlxuICogQGF1Z21lbnRzIHtMYXlvdXR9XG4gKi9cbmNsYXNzIFVJbnRCRSBleHRlbmRzIExheW91dCB7XG4gIGNvbnN0cnVjdG9yKHNwYW4sIHByb3BlcnR5KSB7XG4gICAgc3VwZXIoIHNwYW4sIHByb3BlcnR5KTtcbiAgICBpZiAoNiA8IHRoaXMuc3Bhbikge1xuICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ3NwYW4gbXVzdCBub3QgZXhjZWVkIDYgYnl0ZXMnKTtcbiAgICB9XG4gIH1cblxuICAvKiogQG92ZXJyaWRlICovXG4gIGRlY29kZShiLCBvZmZzZXQpIHtcbiAgICBpZiAodW5kZWZpbmVkID09PSBvZmZzZXQpIHtcbiAgICAgIG9mZnNldCA9IDA7XG4gICAgfVxuICAgIHJldHVybiBiLnJlYWRVSW50QkUob2Zmc2V0LCB0aGlzLnNwYW4pO1xuICB9XG5cbiAgLyoqIEBvdmVycmlkZSAqL1xuICBlbmNvZGUoc3JjLCBiLCBvZmZzZXQpIHtcbiAgICBpZiAodW5kZWZpbmVkID09PSBvZmZzZXQpIHtcbiAgICAgIG9mZnNldCA9IDA7XG4gICAgfVxuICAgIGIud3JpdGVVSW50QkUoc3JjLCBvZmZzZXQsIHRoaXMuc3Bhbik7XG4gICAgcmV0dXJuIHRoaXMuc3BhbjtcbiAgfVxufVxuXG4vKipcbiAqIFJlcHJlc2VudCBhIHNpZ25lZCBpbnRlZ2VyIGluIGxpdHRsZS1lbmRpYW4gZm9ybWF0LlxuICpcbiAqICpGYWN0b3J5Kjoge0BsaW5rIG1vZHVsZTpMYXlvdXQuczh8czh9LCB7QGxpbmtcbiAqICBtb2R1bGU6TGF5b3V0LnMxNnxzMTZ9LCB7QGxpbmsgbW9kdWxlOkxheW91dC5zMjR8czI0fSwge0BsaW5rXG4gKiAgbW9kdWxlOkxheW91dC5zMzJ8czMyfSwge0BsaW5rIG1vZHVsZTpMYXlvdXQuczQwfHM0MH0sIHtAbGlua1xuICogIG1vZHVsZTpMYXlvdXQuczQ4fHM0OH1cbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gc3BhbiAtIGluaXRpYWxpemVyIGZvciB7QGxpbmsgTGF5b3V0I3NwYW58c3Bhbn0uXG4gKiBUaGUgcGFyYW1ldGVyIGNhbiByYW5nZSBmcm9tIDEgdGhyb3VnaCA2LlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBbcHJvcGVydHldIC0gaW5pdGlhbGl6ZXIgZm9yIHtAbGlua1xuICogTGF5b3V0I3Byb3BlcnR5fHByb3BlcnR5fS5cbiAqXG4gKiBAYXVnbWVudHMge0xheW91dH1cbiAqL1xuY2xhc3MgSW50IGV4dGVuZHMgTGF5b3V0IHtcbiAgY29uc3RydWN0b3Ioc3BhbiwgcHJvcGVydHkpIHtcbiAgICBzdXBlcihzcGFuLCBwcm9wZXJ0eSk7XG4gICAgaWYgKDYgPCB0aGlzLnNwYW4pIHtcbiAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdzcGFuIG11c3Qgbm90IGV4Y2VlZCA2IGJ5dGVzJyk7XG4gICAgfVxuICB9XG5cbiAgLyoqIEBvdmVycmlkZSAqL1xuICBkZWNvZGUoYiwgb2Zmc2V0KSB7XG4gICAgaWYgKHVuZGVmaW5lZCA9PT0gb2Zmc2V0KSB7XG4gICAgICBvZmZzZXQgPSAwO1xuICAgIH1cbiAgICByZXR1cm4gYi5yZWFkSW50TEUob2Zmc2V0LCB0aGlzLnNwYW4pO1xuICB9XG5cbiAgLyoqIEBvdmVycmlkZSAqL1xuICBlbmNvZGUoc3JjLCBiLCBvZmZzZXQpIHtcbiAgICBpZiAodW5kZWZpbmVkID09PSBvZmZzZXQpIHtcbiAgICAgIG9mZnNldCA9IDA7XG4gICAgfVxuICAgIGIud3JpdGVJbnRMRShzcmMsIG9mZnNldCwgdGhpcy5zcGFuKTtcbiAgICByZXR1cm4gdGhpcy5zcGFuO1xuICB9XG59XG5cbi8qKlxuICogUmVwcmVzZW50IGEgc2lnbmVkIGludGVnZXIgaW4gYmlnLWVuZGlhbiBmb3JtYXQuXG4gKlxuICogKkZhY3RvcnkqOiB7QGxpbmsgbW9kdWxlOkxheW91dC5zOGJlfHM4YmV9LCB7QGxpbmtcbiAqIG1vZHVsZTpMYXlvdXQuczE2YmV8czE2YmV9LCB7QGxpbmsgbW9kdWxlOkxheW91dC5zMjRiZXxzMjRiZX0sXG4gKiB7QGxpbmsgbW9kdWxlOkxheW91dC5zMzJiZXxzMzJiZX0sIHtAbGlua1xuICogbW9kdWxlOkxheW91dC5zNDBiZXxzNDBiZX0sIHtAbGluayBtb2R1bGU6TGF5b3V0LnM0OGJlfHM0OGJlfVxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSBzcGFuIC0gaW5pdGlhbGl6ZXIgZm9yIHtAbGluayBMYXlvdXQjc3BhbnxzcGFufS5cbiAqIFRoZSBwYXJhbWV0ZXIgY2FuIHJhbmdlIGZyb20gMSB0aHJvdWdoIDYuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IFtwcm9wZXJ0eV0gLSBpbml0aWFsaXplciBmb3Ige0BsaW5rXG4gKiBMYXlvdXQjcHJvcGVydHl8cHJvcGVydHl9LlxuICpcbiAqIEBhdWdtZW50cyB7TGF5b3V0fVxuICovXG5jbGFzcyBJbnRCRSBleHRlbmRzIExheW91dCB7XG4gIGNvbnN0cnVjdG9yKHNwYW4sIHByb3BlcnR5KSB7XG4gICAgc3VwZXIoc3BhbiwgcHJvcGVydHkpO1xuICAgIGlmICg2IDwgdGhpcy5zcGFuKSB7XG4gICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignc3BhbiBtdXN0IG5vdCBleGNlZWQgNiBieXRlcycpO1xuICAgIH1cbiAgfVxuXG4gIC8qKiBAb3ZlcnJpZGUgKi9cbiAgZGVjb2RlKGIsIG9mZnNldCkge1xuICAgIGlmICh1bmRlZmluZWQgPT09IG9mZnNldCkge1xuICAgICAgb2Zmc2V0ID0gMDtcbiAgICB9XG4gICAgcmV0dXJuIGIucmVhZEludEJFKG9mZnNldCwgdGhpcy5zcGFuKTtcbiAgfVxuXG4gIC8qKiBAb3ZlcnJpZGUgKi9cbiAgZW5jb2RlKHNyYywgYiwgb2Zmc2V0KSB7XG4gICAgaWYgKHVuZGVmaW5lZCA9PT0gb2Zmc2V0KSB7XG4gICAgICBvZmZzZXQgPSAwO1xuICAgIH1cbiAgICBiLndyaXRlSW50QkUoc3JjLCBvZmZzZXQsIHRoaXMuc3Bhbik7XG4gICAgcmV0dXJuIHRoaXMuc3BhbjtcbiAgfVxufVxuXG5jb25zdCBWMkUzMiA9IE1hdGgucG93KDIsIDMyKTtcblxuLyogVHJ1ZSBtb2R1bHVzIGhpZ2ggYW5kIGxvdyAzMi1iaXQgd29yZHMsIHdoZXJlIGxvdyB3b3JkIGlzIGFsd2F5c1xuICogbm9uLW5lZ2F0aXZlLiAqL1xuZnVuY3Rpb24gZGl2bW9kSW50NjQoc3JjKSB7XG4gIGNvbnN0IGhpMzIgPSBNYXRoLmZsb29yKHNyYyAvIFYyRTMyKTtcbiAgY29uc3QgbG8zMiA9IHNyYyAtIChoaTMyICogVjJFMzIpO1xuICByZXR1cm4ge2hpMzIsIGxvMzJ9O1xufVxuLyogUmVjb25zdHJ1Y3QgTnVtYmVyIGZyb20gcXVvdGllbnQgYW5kIG5vbi1uZWdhdGl2ZSByZW1haW5kZXIgKi9cbmZ1bmN0aW9uIHJvdW5kZWRJbnQ2NChoaTMyLCBsbzMyKSB7XG4gIHJldHVybiBoaTMyICogVjJFMzIgKyBsbzMyO1xufVxuXG4vKipcbiAqIFJlcHJlc2VudCBhbiB1bnNpZ25lZCA2NC1iaXQgaW50ZWdlciBpbiBsaXR0bGUtZW5kaWFuIGZvcm1hdCB3aGVuXG4gKiBlbmNvZGVkIGFuZCBhcyBhIG5lYXIgaW50ZWdyYWwgSmF2YVNjcmlwdCBOdW1iZXIgd2hlbiBkZWNvZGVkLlxuICpcbiAqICpGYWN0b3J5Kjoge0BsaW5rIG1vZHVsZTpMYXlvdXQubnU2NHxudTY0fVxuICpcbiAqICoqTk9URSoqIFZhbHVlcyB3aXRoIG1hZ25pdHVkZSBncmVhdGVyIHRoYW4gMl41MiBtYXkgbm90IGRlY29kZSB0b1xuICogdGhlIGV4YWN0IHZhbHVlIG9mIHRoZSBlbmNvZGVkIHJlcHJlc2VudGF0aW9uLlxuICpcbiAqIEBhdWdtZW50cyB7TGF5b3V0fVxuICovXG5jbGFzcyBOZWFyVUludDY0IGV4dGVuZHMgTGF5b3V0IHtcbiAgY29uc3RydWN0b3IocHJvcGVydHkpIHtcbiAgICBzdXBlcig4LCBwcm9wZXJ0eSk7XG4gIH1cblxuICAvKiogQG92ZXJyaWRlICovXG4gIGRlY29kZShiLCBvZmZzZXQpIHtcbiAgICBpZiAodW5kZWZpbmVkID09PSBvZmZzZXQpIHtcbiAgICAgIG9mZnNldCA9IDA7XG4gICAgfVxuICAgIGNvbnN0IGxvMzIgPSBiLnJlYWRVSW50MzJMRShvZmZzZXQpO1xuICAgIGNvbnN0IGhpMzIgPSBiLnJlYWRVSW50MzJMRShvZmZzZXQgKyA0KTtcbiAgICByZXR1cm4gcm91bmRlZEludDY0KGhpMzIsIGxvMzIpO1xuICB9XG5cbiAgLyoqIEBvdmVycmlkZSAqL1xuICBlbmNvZGUoc3JjLCBiLCBvZmZzZXQpIHtcbiAgICBpZiAodW5kZWZpbmVkID09PSBvZmZzZXQpIHtcbiAgICAgIG9mZnNldCA9IDA7XG4gICAgfVxuICAgIGNvbnN0IHNwbGl0ID0gZGl2bW9kSW50NjQoc3JjKTtcbiAgICBiLndyaXRlVUludDMyTEUoc3BsaXQubG8zMiwgb2Zmc2V0KTtcbiAgICBiLndyaXRlVUludDMyTEUoc3BsaXQuaGkzMiwgb2Zmc2V0ICsgNCk7XG4gICAgcmV0dXJuIDg7XG4gIH1cbn1cblxuLyoqXG4gKiBSZXByZXNlbnQgYW4gdW5zaWduZWQgNjQtYml0IGludGVnZXIgaW4gYmlnLWVuZGlhbiBmb3JtYXQgd2hlblxuICogZW5jb2RlZCBhbmQgYXMgYSBuZWFyIGludGVncmFsIEphdmFTY3JpcHQgTnVtYmVyIHdoZW4gZGVjb2RlZC5cbiAqXG4gKiAqRmFjdG9yeSo6IHtAbGluayBtb2R1bGU6TGF5b3V0Lm51NjRiZXxudTY0YmV9XG4gKlxuICogKipOT1RFKiogVmFsdWVzIHdpdGggbWFnbml0dWRlIGdyZWF0ZXIgdGhhbiAyXjUyIG1heSBub3QgZGVjb2RlIHRvXG4gKiB0aGUgZXhhY3QgdmFsdWUgb2YgdGhlIGVuY29kZWQgcmVwcmVzZW50YXRpb24uXG4gKlxuICogQGF1Z21lbnRzIHtMYXlvdXR9XG4gKi9cbmNsYXNzIE5lYXJVSW50NjRCRSBleHRlbmRzIExheW91dCB7XG4gIGNvbnN0cnVjdG9yKHByb3BlcnR5KSB7XG4gICAgc3VwZXIoOCwgcHJvcGVydHkpO1xuICB9XG5cbiAgLyoqIEBvdmVycmlkZSAqL1xuICBkZWNvZGUoYiwgb2Zmc2V0KSB7XG4gICAgaWYgKHVuZGVmaW5lZCA9PT0gb2Zmc2V0KSB7XG4gICAgICBvZmZzZXQgPSAwO1xuICAgIH1cbiAgICBjb25zdCBoaTMyID0gYi5yZWFkVUludDMyQkUob2Zmc2V0KTtcbiAgICBjb25zdCBsbzMyID0gYi5yZWFkVUludDMyQkUob2Zmc2V0ICsgNCk7XG4gICAgcmV0dXJuIHJvdW5kZWRJbnQ2NChoaTMyLCBsbzMyKTtcbiAgfVxuXG4gIC8qKiBAb3ZlcnJpZGUgKi9cbiAgZW5jb2RlKHNyYywgYiwgb2Zmc2V0KSB7XG4gICAgaWYgKHVuZGVmaW5lZCA9PT0gb2Zmc2V0KSB7XG4gICAgICBvZmZzZXQgPSAwO1xuICAgIH1cbiAgICBjb25zdCBzcGxpdCA9IGRpdm1vZEludDY0KHNyYyk7XG4gICAgYi53cml0ZVVJbnQzMkJFKHNwbGl0LmhpMzIsIG9mZnNldCk7XG4gICAgYi53cml0ZVVJbnQzMkJFKHNwbGl0LmxvMzIsIG9mZnNldCArIDQpO1xuICAgIHJldHVybiA4O1xuICB9XG59XG5cbi8qKlxuICogUmVwcmVzZW50IGEgc2lnbmVkIDY0LWJpdCBpbnRlZ2VyIGluIGxpdHRsZS1lbmRpYW4gZm9ybWF0IHdoZW5cbiAqIGVuY29kZWQgYW5kIGFzIGEgbmVhciBpbnRlZ3JhbCBKYXZhU2NyaXB0IE51bWJlciB3aGVuIGRlY29kZWQuXG4gKlxuICogKkZhY3RvcnkqOiB7QGxpbmsgbW9kdWxlOkxheW91dC5uczY0fG5zNjR9XG4gKlxuICogKipOT1RFKiogVmFsdWVzIHdpdGggbWFnbml0dWRlIGdyZWF0ZXIgdGhhbiAyXjUyIG1heSBub3QgZGVjb2RlIHRvXG4gKiB0aGUgZXhhY3QgdmFsdWUgb2YgdGhlIGVuY29kZWQgcmVwcmVzZW50YXRpb24uXG4gKlxuICogQGF1Z21lbnRzIHtMYXlvdXR9XG4gKi9cbmNsYXNzIE5lYXJJbnQ2NCBleHRlbmRzIExheW91dCB7XG4gIGNvbnN0cnVjdG9yKHByb3BlcnR5KSB7XG4gICAgc3VwZXIoOCwgcHJvcGVydHkpO1xuICB9XG5cbiAgLyoqIEBvdmVycmlkZSAqL1xuICBkZWNvZGUoYiwgb2Zmc2V0KSB7XG4gICAgaWYgKHVuZGVmaW5lZCA9PT0gb2Zmc2V0KSB7XG4gICAgICBvZmZzZXQgPSAwO1xuICAgIH1cbiAgICBjb25zdCBsbzMyID0gYi5yZWFkVUludDMyTEUob2Zmc2V0KTtcbiAgICBjb25zdCBoaTMyID0gYi5yZWFkSW50MzJMRShvZmZzZXQgKyA0KTtcbiAgICByZXR1cm4gcm91bmRlZEludDY0KGhpMzIsIGxvMzIpO1xuICB9XG5cbiAgLyoqIEBvdmVycmlkZSAqL1xuICBlbmNvZGUoc3JjLCBiLCBvZmZzZXQpIHtcbiAgICBpZiAodW5kZWZpbmVkID09PSBvZmZzZXQpIHtcbiAgICAgIG9mZnNldCA9IDA7XG4gICAgfVxuICAgIGNvbnN0IHNwbGl0ID0gZGl2bW9kSW50NjQoc3JjKTtcbiAgICBiLndyaXRlVUludDMyTEUoc3BsaXQubG8zMiwgb2Zmc2V0KTtcbiAgICBiLndyaXRlSW50MzJMRShzcGxpdC5oaTMyLCBvZmZzZXQgKyA0KTtcbiAgICByZXR1cm4gODtcbiAgfVxufVxuXG4vKipcbiAqIFJlcHJlc2VudCBhIHNpZ25lZCA2NC1iaXQgaW50ZWdlciBpbiBiaWctZW5kaWFuIGZvcm1hdCB3aGVuXG4gKiBlbmNvZGVkIGFuZCBhcyBhIG5lYXIgaW50ZWdyYWwgSmF2YVNjcmlwdCBOdW1iZXIgd2hlbiBkZWNvZGVkLlxuICpcbiAqICpGYWN0b3J5Kjoge0BsaW5rIG1vZHVsZTpMYXlvdXQubnM2NGJlfG5zNjRiZX1cbiAqXG4gKiAqKk5PVEUqKiBWYWx1ZXMgd2l0aCBtYWduaXR1ZGUgZ3JlYXRlciB0aGFuIDJeNTIgbWF5IG5vdCBkZWNvZGUgdG9cbiAqIHRoZSBleGFjdCB2YWx1ZSBvZiB0aGUgZW5jb2RlZCByZXByZXNlbnRhdGlvbi5cbiAqXG4gKiBAYXVnbWVudHMge0xheW91dH1cbiAqL1xuY2xhc3MgTmVhckludDY0QkUgZXh0ZW5kcyBMYXlvdXQge1xuICBjb25zdHJ1Y3Rvcihwcm9wZXJ0eSkge1xuICAgIHN1cGVyKDgsIHByb3BlcnR5KTtcbiAgfVxuXG4gIC8qKiBAb3ZlcnJpZGUgKi9cbiAgZGVjb2RlKGIsIG9mZnNldCkge1xuICAgIGlmICh1bmRlZmluZWQgPT09IG9mZnNldCkge1xuICAgICAgb2Zmc2V0ID0gMDtcbiAgICB9XG4gICAgY29uc3QgaGkzMiA9IGIucmVhZEludDMyQkUob2Zmc2V0KTtcbiAgICBjb25zdCBsbzMyID0gYi5yZWFkVUludDMyQkUob2Zmc2V0ICsgNCk7XG4gICAgcmV0dXJuIHJvdW5kZWRJbnQ2NChoaTMyLCBsbzMyKTtcbiAgfVxuXG4gIC8qKiBAb3ZlcnJpZGUgKi9cbiAgZW5jb2RlKHNyYywgYiwgb2Zmc2V0KSB7XG4gICAgaWYgKHVuZGVmaW5lZCA9PT0gb2Zmc2V0KSB7XG4gICAgICBvZmZzZXQgPSAwO1xuICAgIH1cbiAgICBjb25zdCBzcGxpdCA9IGRpdm1vZEludDY0KHNyYyk7XG4gICAgYi53cml0ZUludDMyQkUoc3BsaXQuaGkzMiwgb2Zmc2V0KTtcbiAgICBiLndyaXRlVUludDMyQkUoc3BsaXQubG8zMiwgb2Zmc2V0ICsgNCk7XG4gICAgcmV0dXJuIDg7XG4gIH1cbn1cblxuLyoqXG4gKiBSZXByZXNlbnQgYSAzMi1iaXQgZmxvYXRpbmcgcG9pbnQgbnVtYmVyIGluIGxpdHRsZS1lbmRpYW4gZm9ybWF0LlxuICpcbiAqICpGYWN0b3J5Kjoge0BsaW5rIG1vZHVsZTpMYXlvdXQuZjMyfGYzMn1cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gW3Byb3BlcnR5XSAtIGluaXRpYWxpemVyIGZvciB7QGxpbmtcbiAqIExheW91dCNwcm9wZXJ0eXxwcm9wZXJ0eX0uXG4gKlxuICogQGF1Z21lbnRzIHtMYXlvdXR9XG4gKi9cbmNsYXNzIEZsb2F0IGV4dGVuZHMgTGF5b3V0IHtcbiAgY29uc3RydWN0b3IocHJvcGVydHkpIHtcbiAgICBzdXBlcig0LCBwcm9wZXJ0eSk7XG4gIH1cblxuICAvKiogQG92ZXJyaWRlICovXG4gIGRlY29kZShiLCBvZmZzZXQpIHtcbiAgICBpZiAodW5kZWZpbmVkID09PSBvZmZzZXQpIHtcbiAgICAgIG9mZnNldCA9IDA7XG4gICAgfVxuICAgIHJldHVybiBiLnJlYWRGbG9hdExFKG9mZnNldCk7XG4gIH1cblxuICAvKiogQG92ZXJyaWRlICovXG4gIGVuY29kZShzcmMsIGIsIG9mZnNldCkge1xuICAgIGlmICh1bmRlZmluZWQgPT09IG9mZnNldCkge1xuICAgICAgb2Zmc2V0ID0gMDtcbiAgICB9XG4gICAgYi53cml0ZUZsb2F0TEUoc3JjLCBvZmZzZXQpO1xuICAgIHJldHVybiA0O1xuICB9XG59XG5cbi8qKlxuICogUmVwcmVzZW50IGEgMzItYml0IGZsb2F0aW5nIHBvaW50IG51bWJlciBpbiBiaWctZW5kaWFuIGZvcm1hdC5cbiAqXG4gKiAqRmFjdG9yeSo6IHtAbGluayBtb2R1bGU6TGF5b3V0LmYzMmJlfGYzMmJlfVxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBbcHJvcGVydHldIC0gaW5pdGlhbGl6ZXIgZm9yIHtAbGlua1xuICogTGF5b3V0I3Byb3BlcnR5fHByb3BlcnR5fS5cbiAqXG4gKiBAYXVnbWVudHMge0xheW91dH1cbiAqL1xuY2xhc3MgRmxvYXRCRSBleHRlbmRzIExheW91dCB7XG4gIGNvbnN0cnVjdG9yKHByb3BlcnR5KSB7XG4gICAgc3VwZXIoNCwgcHJvcGVydHkpO1xuICB9XG5cbiAgLyoqIEBvdmVycmlkZSAqL1xuICBkZWNvZGUoYiwgb2Zmc2V0KSB7XG4gICAgaWYgKHVuZGVmaW5lZCA9PT0gb2Zmc2V0KSB7XG4gICAgICBvZmZzZXQgPSAwO1xuICAgIH1cbiAgICByZXR1cm4gYi5yZWFkRmxvYXRCRShvZmZzZXQpO1xuICB9XG5cbiAgLyoqIEBvdmVycmlkZSAqL1xuICBlbmNvZGUoc3JjLCBiLCBvZmZzZXQpIHtcbiAgICBpZiAodW5kZWZpbmVkID09PSBvZmZzZXQpIHtcbiAgICAgIG9mZnNldCA9IDA7XG4gICAgfVxuICAgIGIud3JpdGVGbG9hdEJFKHNyYywgb2Zmc2V0KTtcbiAgICByZXR1cm4gNDtcbiAgfVxufVxuXG4vKipcbiAqIFJlcHJlc2VudCBhIDY0LWJpdCBmbG9hdGluZyBwb2ludCBudW1iZXIgaW4gbGl0dGxlLWVuZGlhbiBmb3JtYXQuXG4gKlxuICogKkZhY3RvcnkqOiB7QGxpbmsgbW9kdWxlOkxheW91dC5mNjR8ZjY0fVxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBbcHJvcGVydHldIC0gaW5pdGlhbGl6ZXIgZm9yIHtAbGlua1xuICogTGF5b3V0I3Byb3BlcnR5fHByb3BlcnR5fS5cbiAqXG4gKiBAYXVnbWVudHMge0xheW91dH1cbiAqL1xuY2xhc3MgRG91YmxlIGV4dGVuZHMgTGF5b3V0IHtcbiAgY29uc3RydWN0b3IocHJvcGVydHkpIHtcbiAgICBzdXBlcig4LCBwcm9wZXJ0eSk7XG4gIH1cblxuICAvKiogQG92ZXJyaWRlICovXG4gIGRlY29kZShiLCBvZmZzZXQpIHtcbiAgICBpZiAodW5kZWZpbmVkID09PSBvZmZzZXQpIHtcbiAgICAgIG9mZnNldCA9IDA7XG4gICAgfVxuICAgIHJldHVybiBiLnJlYWREb3VibGVMRShvZmZzZXQpO1xuICB9XG5cbiAgLyoqIEBvdmVycmlkZSAqL1xuICBlbmNvZGUoc3JjLCBiLCBvZmZzZXQpIHtcbiAgICBpZiAodW5kZWZpbmVkID09PSBvZmZzZXQpIHtcbiAgICAgIG9mZnNldCA9IDA7XG4gICAgfVxuICAgIGIud3JpdGVEb3VibGVMRShzcmMsIG9mZnNldCk7XG4gICAgcmV0dXJuIDg7XG4gIH1cbn1cblxuLyoqXG4gKiBSZXByZXNlbnQgYSA2NC1iaXQgZmxvYXRpbmcgcG9pbnQgbnVtYmVyIGluIGJpZy1lbmRpYW4gZm9ybWF0LlxuICpcbiAqICpGYWN0b3J5Kjoge0BsaW5rIG1vZHVsZTpMYXlvdXQuZjY0YmV8ZjY0YmV9XG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IFtwcm9wZXJ0eV0gLSBpbml0aWFsaXplciBmb3Ige0BsaW5rXG4gKiBMYXlvdXQjcHJvcGVydHl8cHJvcGVydHl9LlxuICpcbiAqIEBhdWdtZW50cyB7TGF5b3V0fVxuICovXG5jbGFzcyBEb3VibGVCRSBleHRlbmRzIExheW91dCB7XG4gIGNvbnN0cnVjdG9yKHByb3BlcnR5KSB7XG4gICAgc3VwZXIoOCwgcHJvcGVydHkpO1xuICB9XG5cbiAgLyoqIEBvdmVycmlkZSAqL1xuICBkZWNvZGUoYiwgb2Zmc2V0KSB7XG4gICAgaWYgKHVuZGVmaW5lZCA9PT0gb2Zmc2V0KSB7XG4gICAgICBvZmZzZXQgPSAwO1xuICAgIH1cbiAgICByZXR1cm4gYi5yZWFkRG91YmxlQkUob2Zmc2V0KTtcbiAgfVxuXG4gIC8qKiBAb3ZlcnJpZGUgKi9cbiAgZW5jb2RlKHNyYywgYiwgb2Zmc2V0KSB7XG4gICAgaWYgKHVuZGVmaW5lZCA9PT0gb2Zmc2V0KSB7XG4gICAgICBvZmZzZXQgPSAwO1xuICAgIH1cbiAgICBiLndyaXRlRG91YmxlQkUoc3JjLCBvZmZzZXQpO1xuICAgIHJldHVybiA4O1xuICB9XG59XG5cbi8qKlxuICogUmVwcmVzZW50IGEgY29udGlndW91cyBzZXF1ZW5jZSBvZiBhIHNwZWNpZmljIGxheW91dCBhcyBhbiBBcnJheS5cbiAqXG4gKiAqRmFjdG9yeSo6IHtAbGluayBtb2R1bGU6TGF5b3V0LnNlcXxzZXF9XG4gKlxuICogQHBhcmFtIHtMYXlvdXR9IGVsZW1lbnRMYXlvdXQgLSBpbml0aWFsaXplciBmb3Ige0BsaW5rXG4gKiBTZXF1ZW5jZSNlbGVtZW50TGF5b3V0fGVsZW1lbnRMYXlvdXR9LlxuICpcbiAqIEBwYXJhbSB7KE51bWJlcnxFeHRlcm5hbExheW91dCl9IGNvdW50IC0gaW5pdGlhbGl6ZXIgZm9yIHtAbGlua1xuICogU2VxdWVuY2UjY291bnR8Y291bnR9LiAgVGhlIHBhcmFtZXRlciBtdXN0IGJlIGVpdGhlciBhIHBvc2l0aXZlXG4gKiBpbnRlZ2VyIG9yIGFuIGluc3RhbmNlIG9mIHtAbGluayBFeHRlcm5hbExheW91dH0uXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IFtwcm9wZXJ0eV0gLSBpbml0aWFsaXplciBmb3Ige0BsaW5rXG4gKiBMYXlvdXQjcHJvcGVydHl8cHJvcGVydHl9LlxuICpcbiAqIEBhdWdtZW50cyB7TGF5b3V0fVxuICovXG5jbGFzcyBTZXF1ZW5jZSBleHRlbmRzIExheW91dCB7XG4gIGNvbnN0cnVjdG9yKGVsZW1lbnRMYXlvdXQsIGNvdW50LCBwcm9wZXJ0eSkge1xuICAgIGlmICghKGVsZW1lbnRMYXlvdXQgaW5zdGFuY2VvZiBMYXlvdXQpKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdlbGVtZW50TGF5b3V0IG11c3QgYmUgYSBMYXlvdXQnKTtcbiAgICB9XG4gICAgaWYgKCEoKChjb3VudCBpbnN0YW5jZW9mIEV4dGVybmFsTGF5b3V0KSAmJiBjb3VudC5pc0NvdW50KCkpXG4gICAgICAgICAgfHwgKE51bWJlci5pc0ludGVnZXIoY291bnQpICYmICgwIDw9IGNvdW50KSkpKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdjb3VudCBtdXN0IGJlIG5vbi1uZWdhdGl2ZSBpbnRlZ2VyICdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgKyAnb3IgYW4gdW5zaWduZWQgaW50ZWdlciBFeHRlcm5hbExheW91dCcpO1xuICAgIH1cbiAgICBsZXQgc3BhbiA9IC0xO1xuICAgIGlmICgoIShjb3VudCBpbnN0YW5jZW9mIEV4dGVybmFsTGF5b3V0KSlcbiAgICAgICAgJiYgKDAgPCBlbGVtZW50TGF5b3V0LnNwYW4pKSB7XG4gICAgICBzcGFuID0gY291bnQgKiBlbGVtZW50TGF5b3V0LnNwYW47XG4gICAgfVxuXG4gICAgc3VwZXIoc3BhbiwgcHJvcGVydHkpO1xuXG4gICAgLyoqIFRoZSBsYXlvdXQgZm9yIGluZGl2aWR1YWwgZWxlbWVudHMgb2YgdGhlIHNlcXVlbmNlLiAqL1xuICAgIHRoaXMuZWxlbWVudExheW91dCA9IGVsZW1lbnRMYXlvdXQ7XG5cbiAgICAvKiogVGhlIG51bWJlciBvZiBlbGVtZW50cyBpbiB0aGUgc2VxdWVuY2UuXG4gICAgICpcbiAgICAgKiBUaGlzIHdpbGwgYmUgZWl0aGVyIGEgbm9uLW5lZ2F0aXZlIGludGVnZXIgb3IgYW4gaW5zdGFuY2Ugb2ZcbiAgICAgKiB7QGxpbmsgRXh0ZXJuYWxMYXlvdXR9IGZvciB3aGljaCB7QGxpbmtcbiAgICAgKiBFeHRlcm5hbExheW91dCNpc0NvdW50fGlzQ291bnQoKX0gaXMgYHRydWVgLiAqL1xuICAgIHRoaXMuY291bnQgPSBjb3VudDtcbiAgfVxuXG4gIC8qKiBAb3ZlcnJpZGUgKi9cbiAgZ2V0U3BhbihiLCBvZmZzZXQpIHtcbiAgICBpZiAoMCA8PSB0aGlzLnNwYW4pIHtcbiAgICAgIHJldHVybiB0aGlzLnNwYW47XG4gICAgfVxuICAgIGlmICh1bmRlZmluZWQgPT09IG9mZnNldCkge1xuICAgICAgb2Zmc2V0ID0gMDtcbiAgICB9XG4gICAgbGV0IHNwYW4gPSAwO1xuICAgIGxldCBjb3VudCA9IHRoaXMuY291bnQ7XG4gICAgaWYgKGNvdW50IGluc3RhbmNlb2YgRXh0ZXJuYWxMYXlvdXQpIHtcbiAgICAgIGNvdW50ID0gY291bnQuZGVjb2RlKGIsIG9mZnNldCk7XG4gICAgfVxuICAgIGlmICgwIDwgdGhpcy5lbGVtZW50TGF5b3V0LnNwYW4pIHtcbiAgICAgIHNwYW4gPSBjb3VudCAqIHRoaXMuZWxlbWVudExheW91dC5zcGFuO1xuICAgIH0gZWxzZSB7XG4gICAgICBsZXQgaWR4ID0gMDtcbiAgICAgIHdoaWxlIChpZHggPCBjb3VudCkge1xuICAgICAgICBzcGFuICs9IHRoaXMuZWxlbWVudExheW91dC5nZXRTcGFuKGIsIG9mZnNldCArIHNwYW4pO1xuICAgICAgICArK2lkeDtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHNwYW47XG4gIH1cblxuICAvKiogQG92ZXJyaWRlICovXG4gIGRlY29kZShiLCBvZmZzZXQpIHtcbiAgICBpZiAodW5kZWZpbmVkID09PSBvZmZzZXQpIHtcbiAgICAgIG9mZnNldCA9IDA7XG4gICAgfVxuICAgIGNvbnN0IHJ2ID0gW107XG4gICAgbGV0IGkgPSAwO1xuICAgIGxldCBjb3VudCA9IHRoaXMuY291bnQ7XG4gICAgaWYgKGNvdW50IGluc3RhbmNlb2YgRXh0ZXJuYWxMYXlvdXQpIHtcbiAgICAgIGNvdW50ID0gY291bnQuZGVjb2RlKGIsIG9mZnNldCk7XG4gICAgfVxuICAgIHdoaWxlIChpIDwgY291bnQpIHtcbiAgICAgIHJ2LnB1c2godGhpcy5lbGVtZW50TGF5b3V0LmRlY29kZShiLCBvZmZzZXQpKTtcbiAgICAgIG9mZnNldCArPSB0aGlzLmVsZW1lbnRMYXlvdXQuZ2V0U3BhbihiLCBvZmZzZXQpO1xuICAgICAgaSArPSAxO1xuICAgIH1cbiAgICByZXR1cm4gcnY7XG4gIH1cblxuICAvKiogSW1wbGVtZW50IHtAbGluayBMYXlvdXQjZW5jb2RlfGVuY29kZX0gZm9yIHtAbGluayBTZXF1ZW5jZX0uXG4gICAqXG4gICAqICoqTk9URSoqIElmIGBzcmNgIGlzIHNob3J0ZXIgdGhhbiB7QGxpbmsgU2VxdWVuY2UjY291bnR8Y291bnR9IHRoZW5cbiAgICogdGhlIHVudXNlZCBzcGFjZSBpbiB0aGUgYnVmZmVyIGlzIGxlZnQgdW5jaGFuZ2VkLiAgSWYgYHNyY2AgaXNcbiAgICogbG9uZ2VyIHRoYW4ge0BsaW5rIFNlcXVlbmNlI2NvdW50fGNvdW50fSB0aGUgdW5uZWVkZWQgZWxlbWVudHMgYXJlXG4gICAqIGlnbm9yZWQuXG4gICAqXG4gICAqICoqTk9URSoqIElmIHtAbGluayBMYXlvdXQjY291bnR8Y291bnR9IGlzIGFuIGluc3RhbmNlIG9mIHtAbGlua1xuICAgKiBFeHRlcm5hbExheW91dH0gdGhlbiB0aGUgbGVuZ3RoIG9mIGBzcmNgIHdpbGwgYmUgZW5jb2RlZCBhcyB0aGVcbiAgICogY291bnQgYWZ0ZXIgYHNyY2AgaXMgZW5jb2RlZC4gKi9cbiAgZW5jb2RlKHNyYywgYiwgb2Zmc2V0KSB7XG4gICAgaWYgKHVuZGVmaW5lZCA9PT0gb2Zmc2V0KSB7XG4gICAgICBvZmZzZXQgPSAwO1xuICAgIH1cbiAgICBjb25zdCBlbG8gPSB0aGlzLmVsZW1lbnRMYXlvdXQ7XG4gICAgY29uc3Qgc3BhbiA9IHNyYy5yZWR1Y2UoKHNwYW4sIHYpID0+IHtcbiAgICAgIHJldHVybiBzcGFuICsgZWxvLmVuY29kZSh2LCBiLCBvZmZzZXQgKyBzcGFuKTtcbiAgICB9LCAwKTtcbiAgICBpZiAodGhpcy5jb3VudCBpbnN0YW5jZW9mIEV4dGVybmFsTGF5b3V0KSB7XG4gICAgICB0aGlzLmNvdW50LmVuY29kZShzcmMubGVuZ3RoLCBiLCBvZmZzZXQpO1xuICAgIH1cbiAgICByZXR1cm4gc3BhbjtcbiAgfVxufVxuXG4vKipcbiAqIFJlcHJlc2VudCBhIGNvbnRpZ3VvdXMgc2VxdWVuY2Ugb2YgYXJiaXRyYXJ5IGxheW91dCBlbGVtZW50cyBhcyBhblxuICogT2JqZWN0LlxuICpcbiAqICpGYWN0b3J5Kjoge0BsaW5rIG1vZHVsZTpMYXlvdXQuc3RydWN0fHN0cnVjdH1cbiAqXG4gKiAqKk5PVEUqKiBUaGUge0BsaW5rIExheW91dCNzcGFufHNwYW59IG9mIHRoZSBzdHJ1Y3R1cmUgaXMgdmFyaWFibGVcbiAqIGlmIGFueSBsYXlvdXQgaW4ge0BsaW5rIFN0cnVjdHVyZSNmaWVsZHN8ZmllbGRzfSBoYXMgYSB2YXJpYWJsZVxuICogc3Bhbi4gIFdoZW4ge0BsaW5rIExheW91dCNlbmNvZGV8ZW5jb2Rpbmd9IHdlIG11c3QgaGF2ZSBhIHZhbHVlIGZvclxuICogYWxsIHZhcmlhYmxlLWxlbmd0aCBmaWVsZHMsIG9yIHdlIHdvdWxkbid0IGJlIGFibGUgdG8gZmlndXJlIG91dFxuICogaG93IG11Y2ggc3BhY2UgdG8gdXNlIGZvciBzdG9yYWdlLiAgV2UgY2FuIG9ubHkgaWRlbnRpZnkgdGhlIHZhbHVlXG4gKiBmb3IgYSBmaWVsZCB3aGVuIGl0IGhhcyBhIHtAbGluayBMYXlvdXQjcHJvcGVydHl8cHJvcGVydHl9LiAgQXNcbiAqIHN1Y2gsIGFsdGhvdWdoIGEgc3RydWN0dXJlIG1heSBjb250YWluIGJvdGggdW5uYW1lZCBmaWVsZHMgYW5kXG4gKiB2YXJpYWJsZS1sZW5ndGggZmllbGRzLCBpdCBjYW5ub3QgY29udGFpbiBhbiB1bm5hbWVkXG4gKiB2YXJpYWJsZS1sZW5ndGggZmllbGQuXG4gKlxuICogQHBhcmFtIHtMYXlvdXRbXX0gZmllbGRzIC0gaW5pdGlhbGl6ZXIgZm9yIHtAbGlua1xuICogU3RydWN0dXJlI2ZpZWxkc3xmaWVsZHN9LiAgQW4gZXJyb3IgaXMgcmFpc2VkIGlmIHRoaXMgY29udGFpbnMgYVxuICogdmFyaWFibGUtbGVuZ3RoIGZpZWxkIGZvciB3aGljaCBhIHtAbGluayBMYXlvdXQjcHJvcGVydHl8cHJvcGVydHl9XG4gKiBpcyBub3QgZGVmaW5lZC5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gW3Byb3BlcnR5XSAtIGluaXRpYWxpemVyIGZvciB7QGxpbmtcbiAqIExheW91dCNwcm9wZXJ0eXxwcm9wZXJ0eX0uXG4gKlxuICogQHBhcmFtIHtCb29sZWFufSBbZGVjb2RlUHJlZml4ZXNdIC0gaW5pdGlhbGl6ZXIgZm9yIHtAbGlua1xuICogU3RydWN0dXJlI2RlY29kZVByZWZpeGVzfHByb3BlcnR5fS5cbiAqXG4gKiBAdGhyb3dzIHtFcnJvcn0gLSBpZiBgZmllbGRzYCBjb250YWlucyBhbiB1bm5hbWVkIHZhcmlhYmxlLWxlbmd0aFxuICogbGF5b3V0LlxuICpcbiAqIEBhdWdtZW50cyB7TGF5b3V0fVxuICovXG5jbGFzcyBTdHJ1Y3R1cmUgZXh0ZW5kcyBMYXlvdXQge1xuICBjb25zdHJ1Y3RvcihmaWVsZHMsIHByb3BlcnR5LCBkZWNvZGVQcmVmaXhlcykge1xuICAgIGlmICghKEFycmF5LmlzQXJyYXkoZmllbGRzKVxuICAgICAgICAgICYmIGZpZWxkcy5yZWR1Y2UoKGFjYywgdikgPT4gYWNjICYmICh2IGluc3RhbmNlb2YgTGF5b3V0KSwgdHJ1ZSkpKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdmaWVsZHMgbXVzdCBiZSBhcnJheSBvZiBMYXlvdXQgaW5zdGFuY2VzJyk7XG4gICAgfVxuICAgIGlmICgoJ2Jvb2xlYW4nID09PSB0eXBlb2YgcHJvcGVydHkpXG4gICAgICAgICYmICh1bmRlZmluZWQgPT09IGRlY29kZVByZWZpeGVzKSkge1xuICAgICAgZGVjb2RlUHJlZml4ZXMgPSBwcm9wZXJ0eTtcbiAgICAgIHByb3BlcnR5ID0gdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIC8qIFZlcmlmeSBhYnNlbmNlIG9mIHVubmFtZWQgdmFyaWFibGUtbGVuZ3RoIGZpZWxkcy4gKi9cbiAgICBmb3IgKGNvbnN0IGZkIG9mIGZpZWxkcykge1xuICAgICAgaWYgKCgwID4gZmQuc3BhbilcbiAgICAgICAgICAmJiAodW5kZWZpbmVkID09PSBmZC5wcm9wZXJ0eSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdmaWVsZHMgY2Fubm90IGNvbnRhaW4gdW5uYW1lZCB2YXJpYWJsZS1sZW5ndGggbGF5b3V0Jyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgbGV0IHNwYW4gPSAtMTtcbiAgICB0cnkge1xuICAgICAgc3BhbiA9IGZpZWxkcy5yZWR1Y2UoKHNwYW4sIGZkKSA9PiBzcGFuICsgZmQuZ2V0U3BhbigpLCAwKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgfVxuICAgIHN1cGVyKHNwYW4sIHByb3BlcnR5KTtcblxuICAgIC8qKiBUaGUgc2VxdWVuY2Ugb2Yge0BsaW5rIExheW91dH0gdmFsdWVzIHRoYXQgY29tcHJpc2UgdGhlXG4gICAgICogc3RydWN0dXJlLlxuICAgICAqXG4gICAgICogVGhlIGluZGl2aWR1YWwgZWxlbWVudHMgbmVlZCBub3QgYmUgdGhlIHNhbWUgdHlwZSwgYW5kIG1heSBiZVxuICAgICAqIGVpdGhlciBzY2FsYXIgb3IgYWdncmVnYXRlIGxheW91dHMuICBJZiBhIG1lbWJlciBsYXlvdXQgbGVhdmVzXG4gICAgICogaXRzIHtAbGluayBMYXlvdXQjcHJvcGVydHl8cHJvcGVydHl9IHVuZGVmaW5lZCB0aGVcbiAgICAgKiBjb3JyZXNwb25kaW5nIHJlZ2lvbiBvZiB0aGUgYnVmZmVyIGFzc29jaWF0ZWQgd2l0aCB0aGUgZWxlbWVudFxuICAgICAqIHdpbGwgbm90IGJlIG11dGF0ZWQuXG4gICAgICpcbiAgICAgKiBAdHlwZSB7TGF5b3V0W119ICovXG4gICAgdGhpcy5maWVsZHMgPSBmaWVsZHM7XG5cbiAgICAvKiogQ29udHJvbCBiZWhhdmlvciBvZiB7QGxpbmsgTGF5b3V0I2RlY29kZXxkZWNvZGUoKX0gZ2l2ZW4gc2hvcnRcbiAgICAgKiBidWZmZXJzLlxuICAgICAqXG4gICAgICogSW4gc29tZSBzaXR1YXRpb25zIGEgc3RydWN0dXJlIG1hbnkgYmUgZXh0ZW5kZWQgd2l0aCBhZGRpdGlvbmFsXG4gICAgICogZmllbGRzIG92ZXIgdGltZSwgd2l0aCBvbGRlciBpbnN0YWxsYXRpb25zIHByb3ZpZGluZyBvbmx5IGFcbiAgICAgKiBwcmVmaXggb2YgdGhlIGZ1bGwgc3RydWN0dXJlLiAgSWYgdGhpcyBwcm9wZXJ0eSBpcyBgdHJ1ZWBcbiAgICAgKiBkZWNvZGluZyB3aWxsIGFjY2VwdCB0aG9zZSBidWZmZXJzIGFuZCBsZWF2ZSBzdWJzZXF1ZW50IGZpZWxkc1xuICAgICAqIHVuZGVmaW5lZCwgYXMgbG9uZyBhcyB0aGUgYnVmZmVyIGVuZHMgYXQgYSBmaWVsZCBib3VuZGFyeS5cbiAgICAgKiBEZWZhdWx0cyB0byBgZmFsc2VgLiAqL1xuICAgIHRoaXMuZGVjb2RlUHJlZml4ZXMgPSAhIWRlY29kZVByZWZpeGVzO1xuICB9XG5cbiAgLyoqIEBvdmVycmlkZSAqL1xuICBnZXRTcGFuKGIsIG9mZnNldCkge1xuICAgIGlmICgwIDw9IHRoaXMuc3Bhbikge1xuICAgICAgcmV0dXJuIHRoaXMuc3BhbjtcbiAgICB9XG4gICAgaWYgKHVuZGVmaW5lZCA9PT0gb2Zmc2V0KSB7XG4gICAgICBvZmZzZXQgPSAwO1xuICAgIH1cbiAgICBsZXQgc3BhbiA9IDA7XG4gICAgdHJ5IHtcbiAgICAgIHNwYW4gPSB0aGlzLmZpZWxkcy5yZWR1Y2UoKHNwYW4sIGZkKSA9PiB7XG4gICAgICAgIGNvbnN0IGZzcCA9IGZkLmdldFNwYW4oYiwgb2Zmc2V0KTtcbiAgICAgICAgb2Zmc2V0ICs9IGZzcDtcbiAgICAgICAgcmV0dXJuIHNwYW4gKyBmc3A7XG4gICAgICB9LCAwKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignaW5kZXRlcm1pbmF0ZSBzcGFuJyk7XG4gICAgfVxuICAgIHJldHVybiBzcGFuO1xuICB9XG5cbiAgLyoqIEBvdmVycmlkZSAqL1xuICBkZWNvZGUoYiwgb2Zmc2V0KSB7XG4gICAgaWYgKHVuZGVmaW5lZCA9PT0gb2Zmc2V0KSB7XG4gICAgICBvZmZzZXQgPSAwO1xuICAgIH1cbiAgICBjb25zdCBkZXN0ID0gdGhpcy5tYWtlRGVzdGluYXRpb25PYmplY3QoKTtcbiAgICBmb3IgKGNvbnN0IGZkIG9mIHRoaXMuZmllbGRzKSB7XG4gICAgICBpZiAodW5kZWZpbmVkICE9PSBmZC5wcm9wZXJ0eSkge1xuICAgICAgICBkZXN0W2ZkLnByb3BlcnR5XSA9IGZkLmRlY29kZShiLCBvZmZzZXQpO1xuICAgICAgfVxuICAgICAgb2Zmc2V0ICs9IGZkLmdldFNwYW4oYiwgb2Zmc2V0KTtcbiAgICAgIGlmICh0aGlzLmRlY29kZVByZWZpeGVzXG4gICAgICAgICAgJiYgKGIubGVuZ3RoID09PSBvZmZzZXQpKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZGVzdDtcbiAgfVxuXG4gIC8qKiBJbXBsZW1lbnQge0BsaW5rIExheW91dCNlbmNvZGV8ZW5jb2RlfSBmb3Ige0BsaW5rIFN0cnVjdHVyZX0uXG4gICAqXG4gICAqIElmIGBzcmNgIGlzIG1pc3NpbmcgYSBwcm9wZXJ0eSBmb3IgYSBtZW1iZXIgd2l0aCBhIGRlZmluZWQge0BsaW5rXG4gICAqIExheW91dCNwcm9wZXJ0eXxwcm9wZXJ0eX0gdGhlIGNvcnJlc3BvbmRpbmcgcmVnaW9uIG9mIHRoZSBidWZmZXIgaXNcbiAgICogbGVmdCB1bm1vZGlmaWVkLiAqL1xuICBlbmNvZGUoc3JjLCBiLCBvZmZzZXQpIHtcbiAgICBpZiAodW5kZWZpbmVkID09PSBvZmZzZXQpIHtcbiAgICAgIG9mZnNldCA9IDA7XG4gICAgfVxuICAgIGNvbnN0IGZpcnN0T2Zmc2V0ID0gb2Zmc2V0O1xuICAgIGxldCBsYXN0T2Zmc2V0ID0gMDtcbiAgICBsZXQgbGFzdFdyb3RlID0gMDtcbiAgICBmb3IgKGNvbnN0IGZkIG9mIHRoaXMuZmllbGRzKSB7XG4gICAgICBsZXQgc3BhbiA9IGZkLnNwYW47XG4gICAgICBsYXN0V3JvdGUgPSAoMCA8IHNwYW4pID8gc3BhbiA6IDA7XG4gICAgICBpZiAodW5kZWZpbmVkICE9PSBmZC5wcm9wZXJ0eSkge1xuICAgICAgICBjb25zdCBmdiA9IHNyY1tmZC5wcm9wZXJ0eV07XG4gICAgICAgIGlmICh1bmRlZmluZWQgIT09IGZ2KSB7XG4gICAgICAgICAgbGFzdFdyb3RlID0gZmQuZW5jb2RlKGZ2LCBiLCBvZmZzZXQpO1xuICAgICAgICAgIGlmICgwID4gc3Bhbikge1xuICAgICAgICAgICAgLyogUmVhZCB0aGUgYXMtZW5jb2RlZCBzcGFuLCB3aGljaCBpcyBub3QgbmVjZXNzYXJpbHkgdGhlXG4gICAgICAgICAgICAgKiBzYW1lIGFzIHdoYXQgd2Ugd3JvdGUuICovXG4gICAgICAgICAgICBzcGFuID0gZmQuZ2V0U3BhbihiLCBvZmZzZXQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgbGFzdE9mZnNldCA9IG9mZnNldDtcbiAgICAgIG9mZnNldCArPSBzcGFuO1xuICAgIH1cbiAgICAvKiBVc2UgKGxhc3RPZmZzZXQgKyBsYXN0V3JvdGUpIGluc3RlYWQgb2Ygb2Zmc2V0IGJlY2F1c2UgdGhlIGxhc3RcbiAgICAgKiBpdGVtIG1heSBoYXZlIGhhZCBhIGR5bmFtaWMgbGVuZ3RoIGFuZCB3ZSBkb24ndCB3YW50IHRvIGluY2x1ZGVcbiAgICAgKiB0aGUgcGFkZGluZyBiZXR3ZWVuIGl0IGFuZCB0aGUgZW5kIG9mIHRoZSBzcGFjZSByZXNlcnZlZCBmb3JcbiAgICAgKiBpdC4gKi9cbiAgICByZXR1cm4gKGxhc3RPZmZzZXQgKyBsYXN0V3JvdGUpIC0gZmlyc3RPZmZzZXQ7XG4gIH1cblxuICAvKiogQG92ZXJyaWRlICovXG4gIGZyb21BcnJheSh2YWx1ZXMpIHtcbiAgICBjb25zdCBkZXN0ID0gdGhpcy5tYWtlRGVzdGluYXRpb25PYmplY3QoKTtcbiAgICBmb3IgKGNvbnN0IGZkIG9mIHRoaXMuZmllbGRzKSB7XG4gICAgICBpZiAoKHVuZGVmaW5lZCAhPT0gZmQucHJvcGVydHkpXG4gICAgICAgICAgJiYgKDAgPCB2YWx1ZXMubGVuZ3RoKSkge1xuICAgICAgICBkZXN0W2ZkLnByb3BlcnR5XSA9IHZhbHVlcy5zaGlmdCgpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZGVzdDtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgYWNjZXNzIHRvIHRoZSBsYXlvdXQgb2YgYSBnaXZlbiBwcm9wZXJ0eS5cbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd9IHByb3BlcnR5IC0gdGhlIHN0cnVjdHVyZSBtZW1iZXIgb2YgaW50ZXJlc3QuXG4gICAqXG4gICAqIEByZXR1cm4ge0xheW91dH0gLSB0aGUgbGF5b3V0IGFzc29jaWF0ZWQgd2l0aCBgcHJvcGVydHlgLCBvclxuICAgKiB1bmRlZmluZWQgaWYgdGhlcmUgaXMgbm8gc3VjaCBwcm9wZXJ0eS5cbiAgICovXG4gIGxheW91dEZvcihwcm9wZXJ0eSkge1xuICAgIGlmICgnc3RyaW5nJyAhPT0gdHlwZW9mIHByb3BlcnR5KSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdwcm9wZXJ0eSBtdXN0IGJlIHN0cmluZycpO1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IGZkIG9mIHRoaXMuZmllbGRzKSB7XG4gICAgICBpZiAoZmQucHJvcGVydHkgPT09IHByb3BlcnR5KSB7XG4gICAgICAgIHJldHVybiBmZDtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBvZmZzZXQgb2YgYSBzdHJ1Y3R1cmUgbWVtYmVyLlxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gcHJvcGVydHkgLSB0aGUgc3RydWN0dXJlIG1lbWJlciBvZiBpbnRlcmVzdC5cbiAgICpcbiAgICogQHJldHVybiB7TnVtYmVyfSAtIHRoZSBvZmZzZXQgaW4gYnl0ZXMgdG8gdGhlIHN0YXJ0IG9mIGBwcm9wZXJ0eWBcbiAgICogd2l0aGluIHRoZSBzdHJ1Y3R1cmUsIG9yIHVuZGVmaW5lZCBpZiBgcHJvcGVydHlgIGlzIG5vdCBhIGZpZWxkXG4gICAqIHdpdGhpbiB0aGUgc3RydWN0dXJlLiAgSWYgdGhlIHByb3BlcnR5IGlzIGEgbWVtYmVyIGJ1dCBmb2xsb3dzIGFcbiAgICogdmFyaWFibGUtbGVuZ3RoIHN0cnVjdHVyZSBtZW1iZXIgYSBuZWdhdGl2ZSBudW1iZXIgd2lsbCBiZVxuICAgKiByZXR1cm5lZC5cbiAgICovXG4gIG9mZnNldE9mKHByb3BlcnR5KSB7XG4gICAgaWYgKCdzdHJpbmcnICE9PSB0eXBlb2YgcHJvcGVydHkpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ3Byb3BlcnR5IG11c3QgYmUgc3RyaW5nJyk7XG4gICAgfVxuICAgIGxldCBvZmZzZXQgPSAwO1xuICAgIGZvciAoY29uc3QgZmQgb2YgdGhpcy5maWVsZHMpIHtcbiAgICAgIGlmIChmZC5wcm9wZXJ0eSA9PT0gcHJvcGVydHkpIHtcbiAgICAgICAgcmV0dXJuIG9mZnNldDtcbiAgICAgIH1cbiAgICAgIGlmICgwID4gZmQuc3Bhbikge1xuICAgICAgICBvZmZzZXQgPSAtMTtcbiAgICAgIH0gZWxzZSBpZiAoMCA8PSBvZmZzZXQpIHtcbiAgICAgICAgb2Zmc2V0ICs9IGZkLnNwYW47XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogQW4gb2JqZWN0IHRoYXQgY2FuIHByb3ZpZGUgYSB7QGxpbmtcbiAqIFVuaW9uI2Rpc2NyaW1pbmF0b3J8ZGlzY3JpbWluYXRvcn0gQVBJIGZvciB7QGxpbmsgVW5pb259LlxuICpcbiAqICoqTk9URSoqIFRoaXMgaXMgYW4gYWJzdHJhY3QgYmFzZSBjbGFzczsgeW91IGNhbiBjcmVhdGUgaW5zdGFuY2VzXG4gKiBpZiBpdCBhbXVzZXMgeW91LCBidXQgdGhleSB3b24ndCBzdXBwb3J0IHRoZSB7QGxpbmtcbiAqIFVuaW9uRGlzY3JpbWluYXRvciNlbmNvZGV8ZW5jb2RlfSBvciB7QGxpbmtcbiAqIFVuaW9uRGlzY3JpbWluYXRvciNkZWNvZGV8ZGVjb2RlfSBmdW5jdGlvbnMuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IFtwcm9wZXJ0eV0gLSBEZWZhdWx0IGZvciB7QGxpbmtcbiAqIFVuaW9uRGlzY3JpbWluYXRvciNwcm9wZXJ0eXxwcm9wZXJ0eX0uXG4gKlxuICogQGFic3RyYWN0XG4gKi9cbmNsYXNzIFVuaW9uRGlzY3JpbWluYXRvciB7XG4gIGNvbnN0cnVjdG9yKHByb3BlcnR5KSB7XG4gICAgLyoqIFRoZSB7QGxpbmsgTGF5b3V0I3Byb3BlcnR5fHByb3BlcnR5fSB0byBiZSB1c2VkIHdoZW4gdGhlXG4gICAgICogZGlzY3JpbWluYXRvciBpcyByZWZlcmVuY2VkIGluIGlzb2xhdGlvbiAoZ2VuZXJhbGx5IHdoZW4ge0BsaW5rXG4gICAgICogVW5pb24jZGVjb2RlfFVuaW9uIGRlY29kZX0gY2Fubm90IGRlbGVnYXRlIHRvIGEgc3BlY2lmaWNcbiAgICAgKiB2YXJpYW50KS4gKi9cbiAgICB0aGlzLnByb3BlcnR5ID0gcHJvcGVydHk7XG4gIH1cblxuICAvKiogQW5hbG9nIHRvIHtAbGluayBMYXlvdXQjZGVjb2RlfExheW91dCBkZWNvZGV9IGZvciB1bmlvbiBkaXNjcmltaW5hdG9ycy5cbiAgICpcbiAgICogVGhlIGltcGxlbWVudGF0aW9uIG9mIHRoaXMgbWV0aG9kIG5lZWQgbm90IHJlZmVyZW5jZSB0aGUgYnVmZmVyIGlmXG4gICAqIHZhcmlhbnQgaW5mb3JtYXRpb24gaXMgYXZhaWxhYmxlIHRocm91Z2ggb3RoZXIgbWVhbnMuICovXG4gIGRlY29kZSgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1VuaW9uRGlzY3JpbWluYXRvciBpcyBhYnN0cmFjdCcpO1xuICB9XG5cbiAgLyoqIEFuYWxvZyB0byB7QGxpbmsgTGF5b3V0I2RlY29kZXxMYXlvdXQgZW5jb2RlfSBmb3IgdW5pb24gZGlzY3JpbWluYXRvcnMuXG4gICAqXG4gICAqIFRoZSBpbXBsZW1lbnRhdGlvbiBvZiB0aGlzIG1ldGhvZCBuZWVkIG5vdCBzdG9yZSB0aGUgdmFsdWUgaWZcbiAgICogdmFyaWFudCBpbmZvcm1hdGlvbiBpcyBtYWludGFpbmVkIHRocm91Z2ggb3RoZXIgbWVhbnMuICovXG4gIGVuY29kZSgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1VuaW9uRGlzY3JpbWluYXRvciBpcyBhYnN0cmFjdCcpO1xuICB9XG59XG5cbi8qKlxuICogQW4gb2JqZWN0IHRoYXQgY2FuIHByb3ZpZGUgYSB7QGxpbmtcbiAqIFVuaW9uRGlzY3JpbWluYXRvcnxkaXNjcmltaW5hdG9yIEFQSX0gZm9yIHtAbGluayBVbmlvbn0gdXNpbmcgYW5cbiAqIHVuc2lnbmVkIGludGVncmFsIHtAbGluayBMYXlvdXR9IGluc3RhbmNlIGxvY2F0ZWQgZWl0aGVyIGluc2lkZSBvclxuICogb3V0c2lkZSB0aGUgdW5pb24uXG4gKlxuICogQHBhcmFtIHtFeHRlcm5hbExheW91dH0gbGF5b3V0IC0gaW5pdGlhbGl6ZXMge0BsaW5rXG4gKiBVbmlvbkxheW91dERpc2NyaW1pbmF0b3IjbGF5b3V0fGxheW91dH0uICBNdXN0IHNhdGlzZnkge0BsaW5rXG4gKiBFeHRlcm5hbExheW91dCNpc0NvdW50fGlzQ291bnQoKX0uXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IFtwcm9wZXJ0eV0gLSBEZWZhdWx0IGZvciB7QGxpbmtcbiAqIFVuaW9uRGlzY3JpbWluYXRvciNwcm9wZXJ0eXxwcm9wZXJ0eX0sIHN1cGVyc2VkaW5nIHRoZSBwcm9wZXJ0eVxuICogZnJvbSBgbGF5b3V0YCwgYnV0IGRlZmF1bHRpbmcgdG8gYHZhcmlhbnRgIGlmIG5laXRoZXIgYHByb3BlcnR5YFxuICogbm9yIGxheW91dCBwcm92aWRlIGEgcHJvcGVydHkgbmFtZS5cbiAqXG4gKiBAYXVnbWVudHMge1VuaW9uRGlzY3JpbWluYXRvcn1cbiAqL1xuY2xhc3MgVW5pb25MYXlvdXREaXNjcmltaW5hdG9yIGV4dGVuZHMgVW5pb25EaXNjcmltaW5hdG9yIHtcbiAgY29uc3RydWN0b3IobGF5b3V0LCBwcm9wZXJ0eSkge1xuICAgIGlmICghKChsYXlvdXQgaW5zdGFuY2VvZiBFeHRlcm5hbExheW91dClcbiAgICAgICAgICAmJiBsYXlvdXQuaXNDb3VudCgpKSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignbGF5b3V0IG11c3QgYmUgYW4gdW5zaWduZWQgaW50ZWdlciBFeHRlcm5hbExheW91dCcpO1xuICAgIH1cblxuICAgIHN1cGVyKHByb3BlcnR5IHx8IGxheW91dC5wcm9wZXJ0eSB8fCAndmFyaWFudCcpO1xuXG4gICAgLyoqIFRoZSB7QGxpbmsgRXh0ZXJuYWxMYXlvdXR9IHVzZWQgdG8gYWNjZXNzIHRoZSBkaXNjcmltaW5hdG9yXG4gICAgICogdmFsdWUuICovXG4gICAgdGhpcy5sYXlvdXQgPSBsYXlvdXQ7XG4gIH1cblxuICAvKiogRGVsZWdhdGUgZGVjb2RpbmcgdG8ge0BsaW5rIFVuaW9uTGF5b3V0RGlzY3JpbWluYXRvciNsYXlvdXR8bGF5b3V0fS4gKi9cbiAgZGVjb2RlKGIsIG9mZnNldCkge1xuICAgIHJldHVybiB0aGlzLmxheW91dC5kZWNvZGUoYiwgb2Zmc2V0KTtcbiAgfVxuXG4gIC8qKiBEZWxlZ2F0ZSBlbmNvZGluZyB0byB7QGxpbmsgVW5pb25MYXlvdXREaXNjcmltaW5hdG9yI2xheW91dHxsYXlvdXR9LiAqL1xuICBlbmNvZGUoc3JjLCBiLCBvZmZzZXQpIHtcbiAgICByZXR1cm4gdGhpcy5sYXlvdXQuZW5jb2RlKHNyYywgYiwgb2Zmc2V0KTtcbiAgfVxufVxuXG4vKipcbiAqIFJlcHJlc2VudCBhbnkgbnVtYmVyIG9mIHNwYW4tY29tcGF0aWJsZSBsYXlvdXRzLlxuICpcbiAqICpGYWN0b3J5Kjoge0BsaW5rIG1vZHVsZTpMYXlvdXQudW5pb258dW5pb259XG4gKlxuICogSWYgdGhlIHVuaW9uIGhhcyBhIHtAbGluayBVbmlvbiNkZWZhdWx0TGF5b3V0fGRlZmF1bHQgbGF5b3V0fSB0aGF0XG4gKiBsYXlvdXQgbXVzdCBoYXZlIGEgbm9uLW5lZ2F0aXZlIHtAbGluayBMYXlvdXQjc3BhbnxzcGFufS4gIFRoZSBzcGFuXG4gKiBvZiBhIGZpeGVkLXNwYW4gdW5pb24gaW5jbHVkZXMgaXRzIHtAbGlua1xuICogVW5pb24jZGlzY3JpbWluYXRvcnxkaXNjcmltaW5hdG9yfSBpZiB0aGUgdmFyaWFudCBpcyBhIHtAbGlua1xuICogVW5pb24jdXNlc1ByZWZpeERpc2NyaW1pbmF0b3J8cHJlZml4IG9mIHRoZSB1bmlvbn0sIHBsdXMgdGhlIHNwYW5cbiAqIG9mIGl0cyB7QGxpbmsgVW5pb24jZGVmYXVsdExheW91dHxkZWZhdWx0IGxheW91dH0uXG4gKlxuICogSWYgdGhlIHVuaW9uIGRvZXMgbm90IGhhdmUgYSBkZWZhdWx0IGxheW91dCB0aGVuIHRoZSBlbmNvZGVkIHNwYW5cbiAqIG9mIHRoZSB1bmlvbiBkZXBlbmRzIG9uIHRoZSBlbmNvZGVkIHNwYW4gb2YgaXRzIHZhcmlhbnQgKHdoaWNoIG1heVxuICogYmUgZml4ZWQgb3IgdmFyaWFibGUpLlxuICpcbiAqIHtAbGluayBWYXJpYW50TGF5b3V0I2xheW91dHxWYXJpYW50IGxheW91dH1zIGFyZSBhZGRlZCB0aHJvdWdoXG4gKiB7QGxpbmsgVW5pb24jYWRkVmFyaWFudHxhZGRWYXJpYW50fS4gIElmIHRoZSB1bmlvbiBoYXMgYSBkZWZhdWx0XG4gKiBsYXlvdXQsIHRoZSBzcGFuIG9mIHRoZSB7QGxpbmsgVmFyaWFudExheW91dCNsYXlvdXR8bGF5b3V0XG4gKiBjb250YWluZWQgYnkgdGhlIHZhcmlhbnR9IG11c3Qgbm90IGV4Y2VlZCB0aGUgc3BhbiBvZiB0aGUge0BsaW5rXG4gKiBVbmlvbiNkZWZhdWx0TGF5b3V0fGRlZmF1bHQgbGF5b3V0fSAobWludXMgdGhlIHNwYW4gb2YgYSB7QGxpbmtcbiAqIFVuaW9uI3VzZXNQcmVmaXhEaXNjcmltaW5hdG9yfHByZWZpeCBkaXNyaW1pbmF0b3J9LCBpZiB1c2VkKS4gIFRoZVxuICogc3BhbiBvZiB0aGUgdmFyaWFudCB3aWxsIGVxdWFsIHRoZSBzcGFuIG9mIHRoZSB1bmlvbiBpdHNlbGYuXG4gKlxuICogVGhlIHZhcmlhbnQgZm9yIGEgYnVmZmVyIGNhbiBvbmx5IGJlIGlkZW50aWZpZWQgZnJvbSB0aGUge0BsaW5rXG4gKiBVbmlvbiNkaXNjcmltaW5hdG9yfGRpc2NyaW1pbmF0b3J9IHtAbGlua1xuICogVW5pb25EaXNjcmltaW5hdG9yI3Byb3BlcnR5fHByb3BlcnR5fSAoaW4gdGhlIGNhc2Ugb2YgdGhlIHtAbGlua1xuICogVW5pb24jZGVmYXVsdExheW91dHxkZWZhdWx0IGxheW91dH0pLCBvciBieSB1c2luZyB7QGxpbmtcbiAqIFVuaW9uI2dldFZhcmlhbnR8Z2V0VmFyaWFudH0gYW5kIGV4YW1pbmluZyB0aGUgcmVzdWx0aW5nIHtAbGlua1xuICogVmFyaWFudExheW91dH0gaW5zdGFuY2UuXG4gKlxuICogQSB2YXJpYW50IGNvbXBhdGlibGUgd2l0aCBhIEphdmFTY3JpcHQgb2JqZWN0IGNhbiBiZSBpZGVudGlmaWVkXG4gKiB1c2luZyB7QGxpbmsgVW5pb24jZ2V0U291cmNlVmFyaWFudHxnZXRTb3VyY2VWYXJpYW50fS5cbiAqXG4gKiBAcGFyYW0geyhVbmlvbkRpc2NyaW1pbmF0b3J8RXh0ZXJuYWxMYXlvdXR8TGF5b3V0KX0gZGlzY3IgLSBIb3cgdG9cbiAqIGlkZW50aWZ5IHRoZSBsYXlvdXQgdXNlZCB0byBpbnRlcnByZXQgdGhlIHVuaW9uIGNvbnRlbnRzLiAgVGhlXG4gKiBwYXJhbWV0ZXIgbXVzdCBiZSBhbiBpbnN0YW5jZSBvZiB7QGxpbmsgVW5pb25EaXNjcmltaW5hdG9yfSwgYW5cbiAqIHtAbGluayBFeHRlcm5hbExheW91dH0gdGhhdCBzYXRpc2ZpZXMge0BsaW5rXG4gKiBFeHRlcm5hbExheW91dCNpc0NvdW50fGlzQ291bnQoKX0sIG9yIHtAbGluayBVSW50fSAob3Ige0BsaW5rXG4gKiBVSW50QkV9KS4gIFdoZW4gYSBub24tZXh0ZXJuYWwgbGF5b3V0IGVsZW1lbnQgaXMgcGFzc2VkIHRoZSBsYXlvdXRcbiAqIGFwcGVhcnMgYXQgdGhlIHN0YXJ0IG9mIHRoZSB1bmlvbi4gIEluIGFsbCBjYXNlcyB0aGUgKHN5bnRoZXNpemVkKVxuICoge0BsaW5rIFVuaW9uRGlzY3JpbWluYXRvcn0gaW5zdGFuY2UgaXMgcmVjb3JkZWQgYXMge0BsaW5rXG4gKiBVbmlvbiNkaXNjcmltaW5hdG9yfGRpc2NyaW1pbmF0b3J9LlxuICpcbiAqIEBwYXJhbSB7KExheW91dHxudWxsKX0gZGVmYXVsdExheW91dCAtIGluaXRpYWxpemVyIGZvciB7QGxpbmtcbiAqIFVuaW9uI2RlZmF1bHRMYXlvdXR8ZGVmYXVsdExheW91dH0uICBJZiBhYnNlbnQgZGVmYXVsdHMgdG8gYG51bGxgLlxuICogSWYgYG51bGxgIHRoZXJlIGlzIG5vIGRlZmF1bHQgbGF5b3V0OiB0aGUgdW5pb24gaGFzIGRhdGEtZGVwZW5kZW50XG4gKiBsZW5ndGggYW5kIGF0dGVtcHRzIHRvIGRlY29kZSBvciBlbmNvZGUgdW5yZWNvZ25pemVkIHZhcmlhbnRzIHdpbGxcbiAqIHRocm93IGFuIGV4Y2VwdGlvbi4gIEEge0BsaW5rIExheW91dH0gaW5zdGFuY2UgbXVzdCBoYXZlIGFcbiAqIG5vbi1uZWdhdGl2ZSB7QGxpbmsgTGF5b3V0I3NwYW58c3Bhbn0sIGFuZCBpZiBpdCBsYWNrcyBhIHtAbGlua1xuICogTGF5b3V0I3Byb3BlcnR5fHByb3BlcnR5fSB0aGUge0BsaW5rXG4gKiBVbmlvbiNkZWZhdWx0TGF5b3V0fGRlZmF1bHRMYXlvdXR9IHdpbGwgYmUgYSB7QGxpbmtcbiAqIExheW91dCNyZXBsaWNhdGV8cmVwbGljYX0gd2l0aCBwcm9wZXJ0eSBgY29udGVudGAuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IFtwcm9wZXJ0eV0gLSBpbml0aWFsaXplciBmb3Ige0BsaW5rXG4gKiBMYXlvdXQjcHJvcGVydHl8cHJvcGVydHl9LlxuICpcbiAqIEBhdWdtZW50cyB7TGF5b3V0fVxuICovXG5jbGFzcyBVbmlvbiBleHRlbmRzIExheW91dCB7XG4gIGNvbnN0cnVjdG9yKGRpc2NyLCBkZWZhdWx0TGF5b3V0LCBwcm9wZXJ0eSkge1xuICAgIGNvbnN0IHVwdiA9ICgoZGlzY3IgaW5zdGFuY2VvZiBVSW50KVxuICAgICAgICAgICAgICAgfHwgKGRpc2NyIGluc3RhbmNlb2YgVUludEJFKSk7XG4gICAgaWYgKHVwdikge1xuICAgICAgZGlzY3IgPSBuZXcgVW5pb25MYXlvdXREaXNjcmltaW5hdG9yKG5ldyBPZmZzZXRMYXlvdXQoZGlzY3IpKTtcbiAgICB9IGVsc2UgaWYgKChkaXNjciBpbnN0YW5jZW9mIEV4dGVybmFsTGF5b3V0KVxuICAgICAgICAgICAgICAgJiYgZGlzY3IuaXNDb3VudCgpKSB7XG4gICAgICBkaXNjciA9IG5ldyBVbmlvbkxheW91dERpc2NyaW1pbmF0b3IoZGlzY3IpO1xuICAgIH0gZWxzZSBpZiAoIShkaXNjciBpbnN0YW5jZW9mIFVuaW9uRGlzY3JpbWluYXRvcikpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2Rpc2NyIG11c3QgYmUgYSBVbmlvbkRpc2NyaW1pbmF0b3IgJ1xuICAgICAgICAgICAgICAgICAgICAgICAgICArICdvciBhbiB1bnNpZ25lZCBpbnRlZ2VyIGxheW91dCcpO1xuICAgIH1cbiAgICBpZiAodW5kZWZpbmVkID09PSBkZWZhdWx0TGF5b3V0KSB7XG4gICAgICBkZWZhdWx0TGF5b3V0ID0gbnVsbDtcbiAgICB9XG4gICAgaWYgKCEoKG51bGwgPT09IGRlZmF1bHRMYXlvdXQpXG4gICAgICAgICAgfHwgKGRlZmF1bHRMYXlvdXQgaW5zdGFuY2VvZiBMYXlvdXQpKSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignZGVmYXVsdExheW91dCBtdXN0IGJlIG51bGwgb3IgYSBMYXlvdXQnKTtcbiAgICB9XG4gICAgaWYgKG51bGwgIT09IGRlZmF1bHRMYXlvdXQpIHtcbiAgICAgIGlmICgwID4gZGVmYXVsdExheW91dC5zcGFuKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignZGVmYXVsdExheW91dCBtdXN0IGhhdmUgY29uc3RhbnQgc3BhbicpO1xuICAgICAgfVxuICAgICAgaWYgKHVuZGVmaW5lZCA9PT0gZGVmYXVsdExheW91dC5wcm9wZXJ0eSkge1xuICAgICAgICBkZWZhdWx0TGF5b3V0ID0gZGVmYXVsdExheW91dC5yZXBsaWNhdGUoJ2NvbnRlbnQnKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKiBUaGUgdW5pb24gc3BhbiBjYW4gYmUgZXN0aW1hdGVkIG9ubHkgaWYgdGhlcmUncyBhIGRlZmF1bHRcbiAgICAgKiBsYXlvdXQuICBUaGUgdW5pb24gc3BhbnMgaXRzIGRlZmF1bHQgbGF5b3V0LCBwbHVzIGFueSBwcmVmaXhcbiAgICAgKiB2YXJpYW50IGxheW91dC4gIEJ5IGNvbnN0cnVjdGlvbiBib3RoIGxheW91dHMsIGlmIHByZXNlbnQsIGhhdmVcbiAgICAgKiBub24tbmVnYXRpdmUgc3Bhbi4gKi9cbiAgICBsZXQgc3BhbiA9IC0xO1xuICAgIGlmIChkZWZhdWx0TGF5b3V0KSB7XG4gICAgICBzcGFuID0gZGVmYXVsdExheW91dC5zcGFuO1xuICAgICAgaWYgKCgwIDw9IHNwYW4pICYmIHVwdikge1xuICAgICAgICBzcGFuICs9IGRpc2NyLmxheW91dC5zcGFuO1xuICAgICAgfVxuICAgIH1cbiAgICBzdXBlcihzcGFuLCBwcm9wZXJ0eSk7XG5cbiAgICAvKiogVGhlIGludGVyZmFjZSBmb3IgdGhlIGRpc2NyaW1pbmF0b3IgdmFsdWUgaW4gaXNvbGF0aW9uLlxuICAgICAqXG4gICAgICogVGhpcyBhIHtAbGluayBVbmlvbkRpc2NyaW1pbmF0b3J9IGVpdGhlciBwYXNzZWQgdG8gdGhlXG4gICAgICogY29uc3RydWN0b3Igb3Igc3ludGhlc2l6ZWQgZnJvbSB0aGUgYGRpc2NyYCBjb25zdHJ1Y3RvclxuICAgICAqIGFyZ3VtZW50LiAge0BsaW5rXG4gICAgICogVW5pb24jdXNlc1ByZWZpeERpc2NyaW1pbmF0b3J8dXNlc1ByZWZpeERpc2NyaW1pbmF0b3J9IHdpbGwgYmVcbiAgICAgKiBgdHJ1ZWAgaWZmIHRoZSBgZGlzY3JgIHBhcmFtZXRlciB3YXMgYSBub24tb2Zmc2V0IHtAbGlua1xuICAgICAqIExheW91dH0gaW5zdGFuY2UuICovXG4gICAgdGhpcy5kaXNjcmltaW5hdG9yID0gZGlzY3I7XG5cbiAgICAvKiogYHRydWVgIGlmIHRoZSB7QGxpbmsgVW5pb24jZGlzY3JpbWluYXRvcnxkaXNjcmltaW5hdG9yfSBpcyB0aGVcbiAgICAgKiBmaXJzdCBmaWVsZCBpbiB0aGUgdW5pb24uXG4gICAgICpcbiAgICAgKiBJZiBgZmFsc2VgIHRoZSBkaXNjcmltaW5hdG9yIGlzIG9idGFpbmVkIGZyb20gc29tZXdoZXJlXG4gICAgICogZWxzZS4gKi9cbiAgICB0aGlzLnVzZXNQcmVmaXhEaXNjcmltaW5hdG9yID0gdXB2O1xuXG4gICAgLyoqIFRoZSBsYXlvdXQgZm9yIG5vbi1kaXNjcmltaW5hdG9yIGNvbnRlbnQgd2hlbiB0aGUgdmFsdWUgb2YgdGhlXG4gICAgICogZGlzY3JpbWluYXRvciBpcyBub3QgcmVjb2duaXplZC5cbiAgICAgKlxuICAgICAqIFRoaXMgaXMgdGhlIHZhbHVlIHBhc3NlZCB0byB0aGUgY29uc3RydWN0b3IuICBJdCBpc1xuICAgICAqIHN0cnVjdHVyYWxseSBlcXVpdmFsZW50IHRvIHRoZSBzZWNvbmQgY29tcG9uZW50IG9mIHtAbGlua1xuICAgICAqIFVuaW9uI2xheW91dHxsYXlvdXR9IGJ1dCBtYXkgaGF2ZSBhIGRpZmZlcmVudCBwcm9wZXJ0eVxuICAgICAqIG5hbWUuICovXG4gICAgdGhpcy5kZWZhdWx0TGF5b3V0ID0gZGVmYXVsdExheW91dDtcblxuICAgIC8qKiBBIHJlZ2lzdHJ5IG9mIGFsbG93ZWQgdmFyaWFudHMuXG4gICAgICpcbiAgICAgKiBUaGUga2V5cyBhcmUgdW5zaWduZWQgaW50ZWdlcnMgd2hpY2ggc2hvdWxkIGJlIGNvbXBhdGlibGUgd2l0aFxuICAgICAqIHtAbGluayBVbmlvbi5kaXNjcmltaW5hdG9yfGRpc2NyaW1pbmF0b3J9LiAgVGhlIHByb3BlcnR5IHZhbHVlXG4gICAgICogaXMgdGhlIGNvcnJlc3BvbmRpbmcge0BsaW5rIFZhcmlhbnRMYXlvdXR9IGluc3RhbmNlcyBhc3NpZ25lZFxuICAgICAqIHRvIHRoaXMgdW5pb24gYnkge0BsaW5rIFVuaW9uI2FkZFZhcmlhbnR8YWRkVmFyaWFudH0uXG4gICAgICpcbiAgICAgKiAqKk5PVEUqKiBUaGUgcmVnaXN0cnkgcmVtYWlucyBtdXRhYmxlIHNvIHRoYXQgdmFyaWFudHMgY2FuIGJlXG4gICAgICoge0BsaW5rIFVuaW9uI2FkZFZhcmlhbnR8YWRkZWR9IGF0IGFueSB0aW1lLiAgVXNlcnMgc2hvdWxkIG5vdFxuICAgICAqIG1hbmlwdWxhdGUgdGhlIGNvbnRlbnQgb2YgdGhpcyBwcm9wZXJ0eS4gKi9cbiAgICB0aGlzLnJlZ2lzdHJ5ID0ge307XG5cbiAgICAvKiBQcml2YXRlIHZhcmlhYmxlIHVzZWQgd2hlbiBpbnZva2luZyBnZXRTb3VyY2VWYXJpYW50ICovXG4gICAgbGV0IGJvdW5kR2V0U291cmNlVmFyaWFudCA9IHRoaXMuZGVmYXVsdEdldFNvdXJjZVZhcmlhbnQuYmluZCh0aGlzKTtcblxuICAgIC8qKiBGdW5jdGlvbiB0byBpbmZlciB0aGUgdmFyaWFudCBzZWxlY3RlZCBieSBhIHNvdXJjZSBvYmplY3QuXG4gICAgICpcbiAgICAgKiBEZWZhdWx0cyB0byB7QGxpbmtcbiAgICAgKiBVbmlvbiNkZWZhdWx0R2V0U291cmNlVmFyaWFudHxkZWZhdWx0R2V0U291cmNlVmFyaWFudH0gYnV0IG1heVxuICAgICAqIGJlIG92ZXJyaWRkZW4gdXNpbmcge0BsaW5rXG4gICAgICogVW5pb24jY29uZmlnR2V0U291cmNlVmFyaWFudHxjb25maWdHZXRTb3VyY2VWYXJpYW50fS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBzcmMgLSBhcyB3aXRoIHtAbGlua1xuICAgICAqIFVuaW9uI2RlZmF1bHRHZXRTb3VyY2VWYXJpYW50fGRlZmF1bHRHZXRTb3VyY2VWYXJpYW50fS5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHsodW5kZWZpbmVkfFZhcmlhbnRMYXlvdXQpfSBUaGUgZGVmYXVsdCB2YXJpYW50XG4gICAgICogKGB1bmRlZmluZWRgKSBvciBmaXJzdCByZWdpc3RlcmVkIHZhcmlhbnQgdGhhdCB1c2VzIGEgcHJvcGVydHlcbiAgICAgKiBhdmFpbGFibGUgaW4gYHNyY2AuICovXG4gICAgdGhpcy5nZXRTb3VyY2VWYXJpYW50ID0gZnVuY3Rpb24oc3JjKSB7XG4gICAgICByZXR1cm4gYm91bmRHZXRTb3VyY2VWYXJpYW50KHNyYyk7XG4gICAgfTtcblxuICAgIC8qKiBGdW5jdGlvbiB0byBvdmVycmlkZSB0aGUgaW1wbGVtZW50YXRpb24gb2Yge0BsaW5rXG4gICAgICogVW5pb24jZ2V0U291cmNlVmFyaWFudHxnZXRTb3VyY2VWYXJpYW50fS5cbiAgICAgKlxuICAgICAqIFVzZSB0aGlzIGlmIHRoZSBkZXNpcmVkIHZhcmlhbnQgY2Fubm90IGJlIGlkZW50aWZpZWQgdXNpbmcgdGhlXG4gICAgICogYWxnb3JpdGhtIG9mIHtAbGlua1xuICAgICAqIFVuaW9uI2RlZmF1bHRHZXRTb3VyY2VWYXJpYW50fGRlZmF1bHRHZXRTb3VyY2VWYXJpYW50fS5cbiAgICAgKlxuICAgICAqICoqTk9URSoqIFRoZSBwcm92aWRlZCBmdW5jdGlvbiB3aWxsIGJlIGludm9rZWQgYm91bmQgdG8gdGhpc1xuICAgICAqIFVuaW9uIGluc3RhbmNlLCBwcm92aWRpbmcgbG9jYWwgYWNjZXNzIHRvIHtAbGlua1xuICAgICAqIFVuaW9uI3JlZ2lzdHJ5fHJlZ2lzdHJ5fS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGdzdiAtIGEgZnVuY3Rpb24gdGhhdCBmb2xsb3dzIHRoZSBBUEkgb2ZcbiAgICAgKiB7QGxpbmsgVW5pb24jZGVmYXVsdEdldFNvdXJjZVZhcmlhbnR8ZGVmYXVsdEdldFNvdXJjZVZhcmlhbnR9LiAqL1xuICAgIHRoaXMuY29uZmlnR2V0U291cmNlVmFyaWFudCA9IGZ1bmN0aW9uKGdzdikge1xuICAgICAgYm91bmRHZXRTb3VyY2VWYXJpYW50ID0gZ3N2LmJpbmQodGhpcyk7XG4gICAgfTtcbiAgfVxuXG4gIC8qKiBAb3ZlcnJpZGUgKi9cbiAgZ2V0U3BhbihiLCBvZmZzZXQpIHtcbiAgICBpZiAoMCA8PSB0aGlzLnNwYW4pIHtcbiAgICAgIHJldHVybiB0aGlzLnNwYW47XG4gICAgfVxuICAgIGlmICh1bmRlZmluZWQgPT09IG9mZnNldCkge1xuICAgICAgb2Zmc2V0ID0gMDtcbiAgICB9XG4gICAgLyogRGVmYXVsdCBsYXlvdXRzIGFsd2F5cyBoYXZlIG5vbi1uZWdhdGl2ZSBzcGFuLCBzbyB3ZSBkb24ndCBoYXZlXG4gICAgICogb25lIGFuZCB3ZSBoYXZlIHRvIHJlY29nbml6ZSB0aGUgdmFyaWFudCB3aGljaCB3aWxsIGluIHR1cm5cbiAgICAgKiBkZXRlcm1pbmUgdGhlIHNwYW4uICovXG4gICAgY29uc3QgdmxvID0gdGhpcy5nZXRWYXJpYW50KGIsIG9mZnNldCk7XG4gICAgaWYgKCF2bG8pIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcigndW5hYmxlIHRvIGRldGVybWluZSBzcGFuIGZvciB1bnJlY29nbml6ZWQgdmFyaWFudCcpO1xuICAgIH1cbiAgICByZXR1cm4gdmxvLmdldFNwYW4oYiwgb2Zmc2V0KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBNZXRob2QgdG8gaW5mZXIgYSByZWdpc3RlcmVkIFVuaW9uIHZhcmlhbnQgY29tcGF0aWJsZSB3aXRoIGBzcmNgLlxuICAgKlxuICAgKiBUaGUgZmlyc3Qgc2F0aXNpZmllZCBydWxlIGluIHRoZSBmb2xsb3dpbmcgc2VxdWVuY2UgZGVmaW5lcyB0aGVcbiAgICogcmV0dXJuIHZhbHVlOlxuICAgKiAqIElmIGBzcmNgIGhhcyBwcm9wZXJ0aWVzIG1hdGNoaW5nIHRoZSBVbmlvbiBkaXNjcmltaW5hdG9yIGFuZFxuICAgKiAgIHRoZSBkZWZhdWx0IGxheW91dCwgYHVuZGVmaW5lZGAgaXMgcmV0dXJuZWQgcmVnYXJkbGVzcyBvZiB0aGVcbiAgICogICB2YWx1ZSBvZiB0aGUgZGlzY3JpbWluYXRvciBwcm9wZXJ0eSAodGhpcyBlbnN1cmVzIHRoZSBkZWZhdWx0XG4gICAqICAgbGF5b3V0IHdpbGwgYmUgdXNlZCk7XG4gICAqICogSWYgYHNyY2AgaGFzIGEgcHJvcGVydHkgbWF0Y2hpbmcgdGhlIFVuaW9uIGRpc2NyaW1pbmF0b3IsIHRoZVxuICAgKiAgIHZhbHVlIG9mIHRoZSBkaXNjcmltaW5hdG9yIGlkZW50aWZpZXMgYSByZWdpc3RlcmVkIHZhcmlhbnQsIGFuZFxuICAgKiAgIGVpdGhlciAoYSkgdGhlIHZhcmlhbnQgaGFzIG5vIGxheW91dCwgb3IgKGIpIGBzcmNgIGhhcyB0aGVcbiAgICogICB2YXJpYW50J3MgcHJvcGVydHksIHRoZW4gdGhlIHZhcmlhbnQgaXMgcmV0dXJuZWQgKGJlY2F1c2UgdGhlXG4gICAqICAgc291cmNlIHNhdGlzZmllcyB0aGUgY29uc3RyYWludHMgb2YgdGhlIHZhcmlhbnQgaXQgaWRlbnRpZmllcyk7XG4gICAqICogSWYgYHNyY2AgZG9lcyBub3QgaGF2ZSBhIHByb3BlcnR5IG1hdGNoaW5nIHRoZSBVbmlvblxuICAgKiAgIGRpc2NyaW1pbmF0b3IsIGJ1dCBkb2VzIGhhdmUgYSBwcm9wZXJ0eSBtYXRjaGluZyBhIHJlZ2lzdGVyZWRcbiAgICogICB2YXJpYW50LCB0aGVuIHRoZSB2YXJpYW50IGlzIHJldHVybmVkIChiZWNhdXNlIHRoZSBzb3VyY2VcbiAgICogICBtYXRjaGVzIGEgdmFyaWFudCB3aXRob3V0IGFuIGV4cGxpY2l0IGNvbmZsaWN0KTtcbiAgICogKiBBbiBlcnJvciBpcyB0aHJvd24gKGJlY2F1c2Ugd2UgZWl0aGVyIGNhbid0IGlkZW50aWZ5IGEgdmFyaWFudCxcbiAgICogICBvciB3ZSB3ZXJlIGV4cGxpY2l0bHkgdG9sZCB0aGUgdmFyaWFudCBidXQgY2FuJ3Qgc2F0aXNmeSBpdCkuXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBzcmMgLSBhbiBvYmplY3QgcHJlc3VtZWQgdG8gYmUgY29tcGF0aWJsZSB3aXRoXG4gICAqIHRoZSBjb250ZW50IG9mIHRoZSBVbmlvbi5cbiAgICpcbiAgICogQHJldHVybiB7KHVuZGVmaW5lZHxWYXJpYW50TGF5b3V0KX0gLSBhcyBkZXNjcmliZWQgYWJvdmUuXG4gICAqXG4gICAqIEB0aHJvd3Mge0Vycm9yfSAtIGlmIGBzcmNgIGNhbm5vdCBiZSBhc3NvY2lhdGVkIHdpdGggYSBkZWZhdWx0IG9yXG4gICAqIHJlZ2lzdGVyZWQgdmFyaWFudC5cbiAgICovXG4gIGRlZmF1bHRHZXRTb3VyY2VWYXJpYW50KHNyYykge1xuICAgIGlmIChzcmMuaGFzT3duUHJvcGVydHkodGhpcy5kaXNjcmltaW5hdG9yLnByb3BlcnR5KSkge1xuICAgICAgaWYgKHRoaXMuZGVmYXVsdExheW91dFxuICAgICAgICAgICYmIHNyYy5oYXNPd25Qcm9wZXJ0eSh0aGlzLmRlZmF1bHRMYXlvdXQucHJvcGVydHkpKSB7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICB9XG4gICAgICBjb25zdCB2bG8gPSB0aGlzLnJlZ2lzdHJ5W3NyY1t0aGlzLmRpc2NyaW1pbmF0b3IucHJvcGVydHldXTtcbiAgICAgIGlmICh2bG9cbiAgICAgICAgICAmJiAoKCF2bG8ubGF5b3V0KVxuICAgICAgICAgICAgICB8fCBzcmMuaGFzT3duUHJvcGVydHkodmxvLnByb3BlcnR5KSkpIHtcbiAgICAgICAgcmV0dXJuIHZsbztcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgZm9yIChjb25zdCB0YWcgaW4gdGhpcy5yZWdpc3RyeSkge1xuICAgICAgICBjb25zdCB2bG8gPSB0aGlzLnJlZ2lzdHJ5W3RhZ107XG4gICAgICAgIGlmIChzcmMuaGFzT3duUHJvcGVydHkodmxvLnByb3BlcnR5KSkge1xuICAgICAgICAgIHJldHVybiB2bG87XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKCd1bmFibGUgdG8gaW5mZXIgc3JjIHZhcmlhbnQnKTtcbiAgfVxuXG4gIC8qKiBJbXBsZW1lbnQge0BsaW5rIExheW91dCNkZWNvZGV8ZGVjb2RlfSBmb3Ige0BsaW5rIFVuaW9ufS5cbiAgICpcbiAgICogSWYgdGhlIHZhcmlhbnQgaXMge0BsaW5rIFVuaW9uI2FkZFZhcmlhbnR8cmVnaXN0ZXJlZH0gdGhlIHJldHVyblxuICAgKiB2YWx1ZSBpcyBhbiBpbnN0YW5jZSBvZiB0aGF0IHZhcmlhbnQsIHdpdGggbm8gZXhwbGljaXRcbiAgICogZGlzY3JpbWluYXRvci4gIE90aGVyd2lzZSB0aGUge0BsaW5rIFVuaW9uI2RlZmF1bHRMYXlvdXR8ZGVmYXVsdFxuICAgKiBsYXlvdXR9IGlzIHVzZWQgdG8gZGVjb2RlIHRoZSBjb250ZW50LiAqL1xuICBkZWNvZGUoYiwgb2Zmc2V0KSB7XG4gICAgaWYgKHVuZGVmaW5lZCA9PT0gb2Zmc2V0KSB7XG4gICAgICBvZmZzZXQgPSAwO1xuICAgIH1cbiAgICBsZXQgZGVzdDtcbiAgICBjb25zdCBkbG8gPSB0aGlzLmRpc2NyaW1pbmF0b3I7XG4gICAgY29uc3QgZGlzY3IgPSBkbG8uZGVjb2RlKGIsIG9mZnNldCk7XG4gICAgbGV0IGNsbyA9IHRoaXMucmVnaXN0cnlbZGlzY3JdO1xuICAgIGlmICh1bmRlZmluZWQgPT09IGNsbykge1xuICAgICAgbGV0IGNvbnRlbnRPZmZzZXQgPSAwO1xuICAgICAgY2xvID0gdGhpcy5kZWZhdWx0TGF5b3V0O1xuICAgICAgaWYgKHRoaXMudXNlc1ByZWZpeERpc2NyaW1pbmF0b3IpIHtcbiAgICAgICAgY29udGVudE9mZnNldCA9IGRsby5sYXlvdXQuc3BhbjtcbiAgICAgIH1cbiAgICAgIGRlc3QgPSB0aGlzLm1ha2VEZXN0aW5hdGlvbk9iamVjdCgpO1xuICAgICAgZGVzdFtkbG8ucHJvcGVydHldID0gZGlzY3I7XG4gICAgICBkZXN0W2Nsby5wcm9wZXJ0eV0gPSB0aGlzLmRlZmF1bHRMYXlvdXQuZGVjb2RlKGIsIG9mZnNldCArIGNvbnRlbnRPZmZzZXQpO1xuICAgIH0gZWxzZSB7XG4gICAgICBkZXN0ID0gY2xvLmRlY29kZShiLCBvZmZzZXQpO1xuICAgIH1cbiAgICByZXR1cm4gZGVzdDtcbiAgfVxuXG4gIC8qKiBJbXBsZW1lbnQge0BsaW5rIExheW91dCNlbmNvZGV8ZW5jb2RlfSBmb3Ige0BsaW5rIFVuaW9ufS5cbiAgICpcbiAgICogVGhpcyBBUEkgYXNzdW1lcyB0aGUgYHNyY2Agb2JqZWN0IGlzIGNvbnNpc3RlbnQgd2l0aCB0aGUgdW5pb24nc1xuICAgKiB7QGxpbmsgVW5pb24jZGVmYXVsdExheW91dHxkZWZhdWx0IGxheW91dH0uICBUbyBlbmNvZGUgdmFyaWFudHNcbiAgICogdXNlIHRoZSBhcHByb3ByaWF0ZSB2YXJpYW50LXNwZWNpZmljIHtAbGluayBWYXJpYW50TGF5b3V0I2VuY29kZX1cbiAgICogbWV0aG9kLiAqL1xuICBlbmNvZGUoc3JjLCBiLCBvZmZzZXQpIHtcbiAgICBpZiAodW5kZWZpbmVkID09PSBvZmZzZXQpIHtcbiAgICAgIG9mZnNldCA9IDA7XG4gICAgfVxuICAgIGNvbnN0IHZsbyA9IHRoaXMuZ2V0U291cmNlVmFyaWFudChzcmMpO1xuICAgIGlmICh1bmRlZmluZWQgPT09IHZsbykge1xuICAgICAgY29uc3QgZGxvID0gdGhpcy5kaXNjcmltaW5hdG9yO1xuICAgICAgY29uc3QgY2xvID0gdGhpcy5kZWZhdWx0TGF5b3V0O1xuICAgICAgbGV0IGNvbnRlbnRPZmZzZXQgPSAwO1xuICAgICAgaWYgKHRoaXMudXNlc1ByZWZpeERpc2NyaW1pbmF0b3IpIHtcbiAgICAgICAgY29udGVudE9mZnNldCA9IGRsby5sYXlvdXQuc3BhbjtcbiAgICAgIH1cbiAgICAgIGRsby5lbmNvZGUoc3JjW2Rsby5wcm9wZXJ0eV0sIGIsIG9mZnNldCk7XG4gICAgICByZXR1cm4gY29udGVudE9mZnNldCArIGNsby5lbmNvZGUoc3JjW2Nsby5wcm9wZXJ0eV0sIGIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb2Zmc2V0ICsgY29udGVudE9mZnNldCk7XG4gICAgfVxuICAgIHJldHVybiB2bG8uZW5jb2RlKHNyYywgYiwgb2Zmc2V0KTtcbiAgfVxuXG4gIC8qKiBSZWdpc3RlciBhIG5ldyB2YXJpYW50IHN0cnVjdHVyZSB3aXRoaW4gYSB1bmlvbi4gIFRoZSBuZXdseVxuICAgKiBjcmVhdGVkIHZhcmlhbnQgaXMgcmV0dXJuZWQuXG4gICAqXG4gICAqIEBwYXJhbSB7TnVtYmVyfSB2YXJpYW50IC0gaW5pdGlhbGl6ZXIgZm9yIHtAbGlua1xuICAgKiBWYXJpYW50TGF5b3V0I3ZhcmlhbnR8dmFyaWFudH0uXG4gICAqXG4gICAqIEBwYXJhbSB7TGF5b3V0fSBsYXlvdXQgLSBpbml0aWFsaXplciBmb3Ige0BsaW5rXG4gICAqIFZhcmlhbnRMYXlvdXQjbGF5b3V0fGxheW91dH0uXG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBwcm9wZXJ0eSAtIGluaXRpYWxpemVyIGZvciB7QGxpbmtcbiAgICogTGF5b3V0I3Byb3BlcnR5fHByb3BlcnR5fS5cbiAgICpcbiAgICogQHJldHVybiB7VmFyaWFudExheW91dH0gKi9cbiAgYWRkVmFyaWFudCh2YXJpYW50LCBsYXlvdXQsIHByb3BlcnR5KSB7XG4gICAgY29uc3QgcnYgPSBuZXcgVmFyaWFudExheW91dCh0aGlzLCB2YXJpYW50LCBsYXlvdXQsIHByb3BlcnR5KTtcbiAgICB0aGlzLnJlZ2lzdHJ5W3ZhcmlhbnRdID0gcnY7XG4gICAgcmV0dXJuIHJ2O1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgbGF5b3V0IGFzc29jaWF0ZWQgd2l0aCBhIHJlZ2lzdGVyZWQgdmFyaWFudC5cbiAgICpcbiAgICogSWYgYHZiYCBkb2VzIG5vdCBwcm9kdWNlIGEgcmVnaXN0ZXJlZCB2YXJpYW50IHRoZSBmdW5jdGlvbiByZXR1cm5zXG4gICAqIGB1bmRlZmluZWRgLlxuICAgKlxuICAgKiBAcGFyYW0geyhOdW1iZXJ8QnVmZmVyKX0gdmIgLSBlaXRoZXIgdGhlIHZhcmlhbnQgbnVtYmVyLCBvciBhXG4gICAqIGJ1ZmZlciBmcm9tIHdoaWNoIHRoZSBkaXNjcmltaW5hdG9yIGlzIHRvIGJlIHJlYWQuXG4gICAqXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBvZmZzZXQgLSBvZmZzZXQgaW50byBgdmJgIGZvciB0aGUgc3RhcnQgb2YgdGhlXG4gICAqIHVuaW9uLiAgVXNlZCBvbmx5IHdoZW4gYHZiYCBpcyBhbiBpbnN0YW5jZSBvZiB7QnVmZmVyfS5cbiAgICpcbiAgICogQHJldHVybiB7KHtWYXJpYW50TGF5b3V0fXx1bmRlZmluZWQpfVxuICAgKi9cbiAgZ2V0VmFyaWFudCh2Yiwgb2Zmc2V0KSB7XG4gICAgbGV0IHZhcmlhbnQgPSB2YjtcbiAgICBpZiAoQnVmZmVyLmlzQnVmZmVyKHZiKSkge1xuICAgICAgaWYgKHVuZGVmaW5lZCA9PT0gb2Zmc2V0KSB7XG4gICAgICAgIG9mZnNldCA9IDA7XG4gICAgICB9XG4gICAgICB2YXJpYW50ID0gdGhpcy5kaXNjcmltaW5hdG9yLmRlY29kZSh2Yiwgb2Zmc2V0KTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMucmVnaXN0cnlbdmFyaWFudF07XG4gIH1cbn1cblxuLyoqXG4gKiBSZXByZXNlbnQgYSBzcGVjaWZpYyB2YXJpYW50IHdpdGhpbiBhIGNvbnRhaW5pbmcgdW5pb24uXG4gKlxuICogKipOT1RFKiogVGhlIHtAbGluayBMYXlvdXQjc3BhbnxzcGFufSBvZiB0aGUgdmFyaWFudCBtYXkgaW5jbHVkZVxuICogdGhlIHNwYW4gb2YgdGhlIHtAbGluayBVbmlvbiNkaXNjcmltaW5hdG9yfGRpc2NyaW1pbmF0b3J9IHVzZWQgdG9cbiAqIGlkZW50aWZ5IGl0LCBidXQgdmFsdWVzIHJlYWQgYW5kIHdyaXR0ZW4gdXNpbmcgdGhlIHZhcmlhbnQgc3RyaWN0bHlcbiAqIGNvbmZvcm0gdG8gdGhlIGNvbnRlbnQgb2Yge0BsaW5rIFZhcmlhbnRMYXlvdXQjbGF5b3V0fGxheW91dH0uXG4gKlxuICogKipOT1RFKiogVXNlciBjb2RlIHNob3VsZCBub3QgaW52b2tlIHRoaXMgY29uc3RydWN0b3IgZGlyZWN0bHkuICBVc2VcbiAqIHRoZSB1bmlvbiB7QGxpbmsgVW5pb24jYWRkVmFyaWFudHxhZGRWYXJpYW50fSBoZWxwZXIgbWV0aG9kLlxuICpcbiAqIEBwYXJhbSB7VW5pb259IHVuaW9uIC0gaW5pdGlhbGl6ZXIgZm9yIHtAbGlua1xuICogVmFyaWFudExheW91dCN1bmlvbnx1bmlvbn0uXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IHZhcmlhbnQgLSBpbml0aWFsaXplciBmb3Ige0BsaW5rXG4gKiBWYXJpYW50TGF5b3V0I3ZhcmlhbnR8dmFyaWFudH0uXG4gKlxuICogQHBhcmFtIHtMYXlvdXR9IFtsYXlvdXRdIC0gaW5pdGlhbGl6ZXIgZm9yIHtAbGlua1xuICogVmFyaWFudExheW91dCNsYXlvdXR8bGF5b3V0fS4gIElmIGFic2VudCB0aGUgdmFyaWFudCBjYXJyaWVzIG5vXG4gKiBkYXRhLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBbcHJvcGVydHldIC0gaW5pdGlhbGl6ZXIgZm9yIHtAbGlua1xuICogTGF5b3V0I3Byb3BlcnR5fHByb3BlcnR5fS4gIFVubGlrZSBtYW55IG90aGVyIGxheW91dHMsIHZhcmlhbnRcbiAqIGxheW91dHMgbm9ybWFsbHkgaW5jbHVkZSBhIHByb3BlcnR5IG5hbWUgc28gdGhleSBjYW4gYmUgaWRlbnRpZmllZFxuICogd2l0aGluIHRoZWlyIGNvbnRhaW5pbmcge0BsaW5rIFVuaW9ufS4gIFRoZSBwcm9wZXJ0eSBpZGVudGlmaWVyIG1heVxuICogYmUgYWJzZW50IG9ubHkgaWYgYGxheW91dGAgaXMgaXMgYWJzZW50LlxuICpcbiAqIEBhdWdtZW50cyB7TGF5b3V0fVxuICovXG5jbGFzcyBWYXJpYW50TGF5b3V0IGV4dGVuZHMgTGF5b3V0IHtcbiAgY29uc3RydWN0b3IodW5pb24sIHZhcmlhbnQsIGxheW91dCwgcHJvcGVydHkpIHtcbiAgICBpZiAoISh1bmlvbiBpbnN0YW5jZW9mIFVuaW9uKSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcigndW5pb24gbXVzdCBiZSBhIFVuaW9uJyk7XG4gICAgfVxuICAgIGlmICgoIU51bWJlci5pc0ludGVnZXIodmFyaWFudCkpIHx8ICgwID4gdmFyaWFudCkpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ3ZhcmlhbnQgbXVzdCBiZSBhIChub24tbmVnYXRpdmUpIGludGVnZXInKTtcbiAgICB9XG4gICAgaWYgKCgnc3RyaW5nJyA9PT0gdHlwZW9mIGxheW91dClcbiAgICAgICAgJiYgKHVuZGVmaW5lZCA9PT0gcHJvcGVydHkpKSB7XG4gICAgICBwcm9wZXJ0eSA9IGxheW91dDtcbiAgICAgIGxheW91dCA9IG51bGw7XG4gICAgfVxuICAgIGlmIChsYXlvdXQpIHtcbiAgICAgIGlmICghKGxheW91dCBpbnN0YW5jZW9mIExheW91dCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignbGF5b3V0IG11c3QgYmUgYSBMYXlvdXQnKTtcbiAgICAgIH1cbiAgICAgIGlmICgobnVsbCAhPT0gdW5pb24uZGVmYXVsdExheW91dClcbiAgICAgICAgICAmJiAoMCA8PSBsYXlvdXQuc3BhbilcbiAgICAgICAgICAmJiAobGF5b3V0LnNwYW4gPiB1bmlvbi5kZWZhdWx0TGF5b3V0LnNwYW4pKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcigndmFyaWFudCBzcGFuIGV4Y2VlZHMgc3BhbiBvZiBjb250YWluaW5nIHVuaW9uJyk7XG4gICAgICB9XG4gICAgICBpZiAoJ3N0cmluZycgIT09IHR5cGVvZiBwcm9wZXJ0eSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCd2YXJpYW50IG11c3QgaGF2ZSBhIFN0cmluZyBwcm9wZXJ0eScpO1xuICAgICAgfVxuICAgIH1cbiAgICBsZXQgc3BhbiA9IHVuaW9uLnNwYW47XG4gICAgaWYgKDAgPiB1bmlvbi5zcGFuKSB7XG4gICAgICBzcGFuID0gbGF5b3V0ID8gbGF5b3V0LnNwYW4gOiAwO1xuICAgICAgaWYgKCgwIDw9IHNwYW4pICYmIHVuaW9uLnVzZXNQcmVmaXhEaXNjcmltaW5hdG9yKSB7XG4gICAgICAgIHNwYW4gKz0gdW5pb24uZGlzY3JpbWluYXRvci5sYXlvdXQuc3BhbjtcbiAgICAgIH1cbiAgICB9XG4gICAgc3VwZXIoc3BhbiwgcHJvcGVydHkpO1xuXG4gICAgLyoqIFRoZSB7QGxpbmsgVW5pb259IHRvIHdoaWNoIHRoaXMgdmFyaWFudCBiZWxvbmdzLiAqL1xuICAgIHRoaXMudW5pb24gPSB1bmlvbjtcblxuICAgIC8qKiBUaGUgdW5zaWduZWQgaW50ZWdyYWwgdmFsdWUgaWRlbnRpZnlpbmcgdGhpcyB2YXJpYW50IHdpdGhpblxuICAgICAqIHRoZSB7QGxpbmsgVW5pb24jZGlzY3JpbWluYXRvcnxkaXNjcmltaW5hdG9yfSBvZiB0aGUgY29udGFpbmluZ1xuICAgICAqIHVuaW9uLiAqL1xuICAgIHRoaXMudmFyaWFudCA9IHZhcmlhbnQ7XG5cbiAgICAvKiogVGhlIHtAbGluayBMYXlvdXR9IHRvIGJlIHVzZWQgd2hlbiByZWFkaW5nL3dyaXRpbmcgdGhlXG4gICAgICogbm9uLWRpc2NyaW1pbmF0b3IgcGFydCBvZiB0aGUge0BsaW5rXG4gICAgICogVmFyaWFudExheW91dCN1bmlvbnx1bmlvbn0uICBJZiBgbnVsbGAgdGhlIHZhcmlhbnQgY2FycmllcyBub1xuICAgICAqIGRhdGEuICovXG4gICAgdGhpcy5sYXlvdXQgPSBsYXlvdXQgfHwgbnVsbDtcbiAgfVxuXG4gIC8qKiBAb3ZlcnJpZGUgKi9cbiAgZ2V0U3BhbihiLCBvZmZzZXQpIHtcbiAgICBpZiAoMCA8PSB0aGlzLnNwYW4pIHtcbiAgICAgIC8qIFdpbGwgYmUgZXF1YWwgdG8gdGhlIGNvbnRhaW5pbmcgdW5pb24gc3BhbiBpZiB0aGF0IGlzIG5vdFxuICAgICAgICogdmFyaWFibGUuICovXG4gICAgICByZXR1cm4gdGhpcy5zcGFuO1xuICAgIH1cbiAgICBpZiAodW5kZWZpbmVkID09PSBvZmZzZXQpIHtcbiAgICAgIG9mZnNldCA9IDA7XG4gICAgfVxuICAgIGxldCBjb250ZW50T2Zmc2V0ID0gMDtcbiAgICBpZiAodGhpcy51bmlvbi51c2VzUHJlZml4RGlzY3JpbWluYXRvcikge1xuICAgICAgY29udGVudE9mZnNldCA9IHRoaXMudW5pb24uZGlzY3JpbWluYXRvci5sYXlvdXQuc3BhbjtcbiAgICB9XG4gICAgLyogU3BhbiBpcyBkZWZpbmVkIHNvbGVseSBieSB0aGUgdmFyaWFudCAoYW5kIHByZWZpeCBkaXNjcmltaW5hdG9yKSAqL1xuICAgIHJldHVybiBjb250ZW50T2Zmc2V0ICsgdGhpcy5sYXlvdXQuZ2V0U3BhbihiLCBvZmZzZXQgKyBjb250ZW50T2Zmc2V0KTtcbiAgfVxuXG4gIC8qKiBAb3ZlcnJpZGUgKi9cbiAgZGVjb2RlKGIsIG9mZnNldCkge1xuICAgIGNvbnN0IGRlc3QgPSB0aGlzLm1ha2VEZXN0aW5hdGlvbk9iamVjdCgpO1xuICAgIGlmICh1bmRlZmluZWQgPT09IG9mZnNldCkge1xuICAgICAgb2Zmc2V0ID0gMDtcbiAgICB9XG4gICAgaWYgKHRoaXMgIT09IHRoaXMudW5pb24uZ2V0VmFyaWFudChiLCBvZmZzZXQpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ3ZhcmlhbnQgbWlzbWF0Y2gnKTtcbiAgICB9XG4gICAgbGV0IGNvbnRlbnRPZmZzZXQgPSAwO1xuICAgIGlmICh0aGlzLnVuaW9uLnVzZXNQcmVmaXhEaXNjcmltaW5hdG9yKSB7XG4gICAgICBjb250ZW50T2Zmc2V0ID0gdGhpcy51bmlvbi5kaXNjcmltaW5hdG9yLmxheW91dC5zcGFuO1xuICAgIH1cbiAgICBpZiAodGhpcy5sYXlvdXQpIHtcbiAgICAgIGRlc3RbdGhpcy5wcm9wZXJ0eV0gPSB0aGlzLmxheW91dC5kZWNvZGUoYiwgb2Zmc2V0ICsgY29udGVudE9mZnNldCk7XG4gICAgfSBlbHNlIGlmICh0aGlzLnByb3BlcnR5KSB7XG4gICAgICBkZXN0W3RoaXMucHJvcGVydHldID0gdHJ1ZTtcbiAgICB9IGVsc2UgaWYgKHRoaXMudW5pb24udXNlc1ByZWZpeERpc2NyaW1pbmF0b3IpIHtcbiAgICAgIGRlc3RbdGhpcy51bmlvbi5kaXNjcmltaW5hdG9yLnByb3BlcnR5XSA9IHRoaXMudmFyaWFudDtcbiAgICB9XG4gICAgcmV0dXJuIGRlc3Q7XG4gIH1cblxuICAvKiogQG92ZXJyaWRlICovXG4gIGVuY29kZShzcmMsIGIsIG9mZnNldCkge1xuICAgIGlmICh1bmRlZmluZWQgPT09IG9mZnNldCkge1xuICAgICAgb2Zmc2V0ID0gMDtcbiAgICB9XG4gICAgbGV0IGNvbnRlbnRPZmZzZXQgPSAwO1xuICAgIGlmICh0aGlzLnVuaW9uLnVzZXNQcmVmaXhEaXNjcmltaW5hdG9yKSB7XG4gICAgICBjb250ZW50T2Zmc2V0ID0gdGhpcy51bmlvbi5kaXNjcmltaW5hdG9yLmxheW91dC5zcGFuO1xuICAgIH1cbiAgICBpZiAodGhpcy5sYXlvdXRcbiAgICAgICAgJiYgKCFzcmMuaGFzT3duUHJvcGVydHkodGhpcy5wcm9wZXJ0eSkpKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCd2YXJpYW50IGxhY2tzIHByb3BlcnR5ICcgKyB0aGlzLnByb3BlcnR5KTtcbiAgICB9XG4gICAgdGhpcy51bmlvbi5kaXNjcmltaW5hdG9yLmVuY29kZSh0aGlzLnZhcmlhbnQsIGIsIG9mZnNldCk7XG4gICAgbGV0IHNwYW4gPSBjb250ZW50T2Zmc2V0O1xuICAgIGlmICh0aGlzLmxheW91dCkge1xuICAgICAgdGhpcy5sYXlvdXQuZW5jb2RlKHNyY1t0aGlzLnByb3BlcnR5XSwgYiwgb2Zmc2V0ICsgY29udGVudE9mZnNldCk7XG4gICAgICBzcGFuICs9IHRoaXMubGF5b3V0LmdldFNwYW4oYiwgb2Zmc2V0ICsgY29udGVudE9mZnNldCk7XG4gICAgICBpZiAoKDAgPD0gdGhpcy51bmlvbi5zcGFuKVxuICAgICAgICAgICYmIChzcGFuID4gdGhpcy51bmlvbi5zcGFuKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2VuY29kZWQgdmFyaWFudCBvdmVycnVucyBjb250YWluaW5nIHVuaW9uJyk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBzcGFuO1xuICB9XG5cbiAgLyoqIERlbGVnYXRlIHtAbGluayBMYXlvdXQjZnJvbUFycmF5fGZyb21BcnJheX0gdG8ge0BsaW5rXG4gICAqIFZhcmlhbnRMYXlvdXQjbGF5b3V0fGxheW91dH0uICovXG4gIGZyb21BcnJheSh2YWx1ZXMpIHtcbiAgICBpZiAodGhpcy5sYXlvdXQpIHtcbiAgICAgIHJldHVybiB0aGlzLmxheW91dC5mcm9tQXJyYXkodmFsdWVzKTtcbiAgICB9XG4gIH1cbn1cblxuLyoqIEphdmFTY3JpcHQgY2hvc2UgdG8gZGVmaW5lIGJpdHdpc2Ugb3BlcmF0aW9ucyBhcyBvcGVyYXRpbmcgb25cbiAqIHNpZ25lZCAzMi1iaXQgdmFsdWVzIGluIDIncyBjb21wbGVtZW50IGZvcm0sIG1lYW5pbmcgYW55IGludGVnZXJcbiAqIHdpdGggYml0IDMxIHNldCBpcyBnb2luZyB0byBsb29rIG5lZ2F0aXZlLiAgRm9yIHJpZ2h0IHNoaWZ0cyB0aGF0J3NcbiAqIG5vdCBhIHByb2JsZW0sIGJlY2F1c2UgYD4+PmAgaXMgYSBsb2dpY2FsIHNoaWZ0LCBidXQgZm9yIGV2ZXJ5XG4gKiBvdGhlciBiaXR3aXNlIG9wZXJhdG9yIHdlIGhhdmUgdG8gY29tcGVuc2F0ZSBmb3IgcG9zc2libGUgbmVnYXRpdmVcbiAqIHJlc3VsdHMuICovXG5mdW5jdGlvbiBmaXhCaXR3aXNlUmVzdWx0KHYpIHtcbiAgaWYgKDAgPiB2KSB7XG4gICAgdiArPSAweDEwMDAwMDAwMDtcbiAgfVxuICByZXR1cm4gdjtcbn1cblxuLyoqXG4gKiBDb250YWluIGEgc2VxdWVuY2Ugb2YgYml0IGZpZWxkcyBhcyBhbiB1bnNpZ25lZCBpbnRlZ2VyLlxuICpcbiAqICpGYWN0b3J5Kjoge0BsaW5rIG1vZHVsZTpMYXlvdXQuYml0c3xiaXRzfVxuICpcbiAqIFRoaXMgaXMgYSBjb250YWluZXIgZWxlbWVudDsgd2l0aGluIGl0IHRoZXJlIGFyZSB7QGxpbmsgQml0RmllbGR9XG4gKiBpbnN0YW5jZXMgdGhhdCBwcm92aWRlIHRoZSBleHRyYWN0ZWQgcHJvcGVydGllcy4gIFRoZSBjb250YWluZXJcbiAqIHNpbXBseSBkZWZpbmVzIHRoZSBhZ2dyZWdhdGUgcmVwcmVzZW50YXRpb24gYW5kIGl0cyBiaXQgb3JkZXJpbmcuXG4gKiBUaGUgcmVwcmVzZW50YXRpb24gaXMgYW4gb2JqZWN0IGNvbnRhaW5pbmcgcHJvcGVydGllcyB3aXRoIG51bWVyaWNcbiAqIG9yIHtAbGluayBCb29sZWFufSB2YWx1ZXMuXG4gKlxuICoge0BsaW5rIEJpdEZpZWxkfXMgYXJlIGFkZGVkIHdpdGggdGhlIHtAbGlua1xuICogQml0U3RydWN0dXJlI2FkZEZpZWxkfGFkZEZpZWxkfSBhbmQge0BsaW5rXG4gKiBCaXRTdHJ1Y3R1cmUjYWRkQm9vbGVhbnxhZGRCb29sZWFufSBtZXRob2RzLlxuXG4gKiBAcGFyYW0ge0xheW91dH0gd29yZCAtIGluaXRpYWxpemVyIGZvciB7QGxpbmtcbiAqIEJpdFN0cnVjdHVyZSN3b3JkfHdvcmR9LiAgVGhlIHBhcmFtZXRlciBtdXN0IGJlIGFuIGluc3RhbmNlIG9mXG4gKiB7QGxpbmsgVUludH0gKG9yIHtAbGluayBVSW50QkV9KSB0aGF0IGlzIG5vIG1vcmUgdGhhbiA0IGJ5dGVzIHdpZGUuXG4gKlxuICogQHBhcmFtIHtib29sfSBbbXNiXSAtIGB0cnVlYCBpZiB0aGUgYml0IG51bWJlcmluZyBzdGFydHMgYXQgdGhlXG4gKiBtb3N0IHNpZ25pZmljYW50IGJpdCBvZiB0aGUgY29udGFpbmluZyB3b3JkOyBgZmFsc2VgIChkZWZhdWx0KSBpZlxuICogaXQgc3RhcnRzIGF0IHRoZSBsZWFzdCBzaWduaWZpY2FudCBiaXQgb2YgdGhlIGNvbnRhaW5pbmcgd29yZC4gIElmXG4gKiB0aGUgcGFyYW1ldGVyIGF0IHRoaXMgcG9zaXRpb24gaXMgYSBzdHJpbmcgYW5kIGBwcm9wZXJ0eWAgaXNcbiAqIGB1bmRlZmluZWRgIHRoZSB2YWx1ZSBvZiB0aGlzIGFyZ3VtZW50IHdpbGwgaW5zdGVhZCBiZSB1c2VkIGFzIHRoZVxuICogdmFsdWUgb2YgYHByb3BlcnR5YC5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gW3Byb3BlcnR5XSAtIGluaXRpYWxpemVyIGZvciB7QGxpbmtcbiAqIExheW91dCNwcm9wZXJ0eXxwcm9wZXJ0eX0uXG4gKlxuICogQGF1Z21lbnRzIHtMYXlvdXR9XG4gKi9cbmNsYXNzIEJpdFN0cnVjdHVyZSBleHRlbmRzIExheW91dCB7XG4gIGNvbnN0cnVjdG9yKHdvcmQsIG1zYiwgcHJvcGVydHkpIHtcbiAgICBpZiAoISgod29yZCBpbnN0YW5jZW9mIFVJbnQpXG4gICAgICAgICAgfHwgKHdvcmQgaW5zdGFuY2VvZiBVSW50QkUpKSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignd29yZCBtdXN0IGJlIGEgVUludCBvciBVSW50QkUgbGF5b3V0Jyk7XG4gICAgfVxuICAgIGlmICgoJ3N0cmluZycgPT09IHR5cGVvZiBtc2IpXG4gICAgICAgICYmICh1bmRlZmluZWQgPT09IHByb3BlcnR5KSkge1xuICAgICAgcHJvcGVydHkgPSBtc2I7XG4gICAgICBtc2IgPSB1bmRlZmluZWQ7XG4gICAgfVxuICAgIGlmICg0IDwgd29yZC5zcGFuKSB7XG4gICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignd29yZCBjYW5ub3QgZXhjZWVkIDMyIGJpdHMnKTtcbiAgICB9XG4gICAgc3VwZXIod29yZC5zcGFuLCBwcm9wZXJ0eSk7XG5cbiAgICAvKiogVGhlIGxheW91dCB1c2VkIGZvciB0aGUgcGFja2VkIHZhbHVlLiAge0BsaW5rIEJpdEZpZWxkfVxuICAgICAqIGluc3RhbmNlcyBhcmUgcGFja2VkIHNlcXVlbnRpYWxseSBkZXBlbmRpbmcgb24ge0BsaW5rXG4gICAgICogQml0U3RydWN0dXJlI21zYnxtc2J9LiAqL1xuICAgIHRoaXMud29yZCA9IHdvcmQ7XG5cbiAgICAvKiogV2hldGhlciB0aGUgYml0IHNlcXVlbmNlcyBhcmUgcGFja2VkIHN0YXJ0aW5nIGF0IHRoZSBtb3N0XG4gICAgICogc2lnbmlmaWNhbnQgYml0IGdyb3dpbmcgZG93biAoYHRydWVgKSwgb3IgdGhlIGxlYXN0IHNpZ25pZmljYW50XG4gICAgICogYml0IGdyb3dpbmcgdXAgKGBmYWxzZWApLlxuICAgICAqXG4gICAgICogKipOT1RFKiogUmVnYXJkbGVzcyBvZiB0aGlzIHZhbHVlLCB0aGUgbGVhc3Qgc2lnbmlmaWNhbnQgYml0IG9mXG4gICAgICogYW55IHtAbGluayBCaXRGaWVsZH0gdmFsdWUgaXMgdGhlIGxlYXN0IHNpZ25pZmljYW50IGJpdCBvZiB0aGVcbiAgICAgKiBjb3JyZXNwb25kaW5nIHNlY3Rpb24gb2YgdGhlIHBhY2tlZCB2YWx1ZS4gKi9cbiAgICB0aGlzLm1zYiA9ICEhbXNiO1xuXG4gICAgLyoqIFRoZSBzZXF1ZW5jZSBvZiB7QGxpbmsgQml0RmllbGR9IGxheW91dHMgdGhhdCBjb21wcmlzZSB0aGVcbiAgICAgKiBwYWNrZWQgc3RydWN0dXJlLlxuICAgICAqXG4gICAgICogKipOT1RFKiogVGhlIGFycmF5IHJlbWFpbnMgbXV0YWJsZSB0byBhbGxvdyBmaWVsZHMgdG8gYmUge0BsaW5rXG4gICAgICogQml0U3RydWN0dXJlI2FkZEZpZWxkfGFkZGVkfSBhZnRlciBjb25zdHJ1Y3Rpb24uICBVc2VycyBzaG91bGRcbiAgICAgKiBub3QgbWFuaXB1bGF0ZSB0aGUgY29udGVudCBvZiB0aGlzIHByb3BlcnR5LiovXG4gICAgdGhpcy5maWVsZHMgPSBbXTtcblxuICAgIC8qIFN0b3JhZ2UgZm9yIHRoZSB2YWx1ZS4gIENhcHR1cmUgYSB2YXJpYWJsZSBpbnN0ZWFkIG9mIHVzaW5nIGFuXG4gICAgICogaW5zdGFuY2UgcHJvcGVydHkgYmVjYXVzZSB3ZSBkb24ndCB3YW50IGFueXRoaW5nIHRvIGNoYW5nZSB0aGVcbiAgICAgKiB2YWx1ZSB3aXRob3V0IGdvaW5nIHRocm91Z2ggdGhlIG11dGF0b3IuICovXG4gICAgbGV0IHZhbHVlID0gMDtcbiAgICB0aGlzLl9wYWNrZWRTZXRWYWx1ZSA9IGZ1bmN0aW9uKHYpIHtcbiAgICAgIHZhbHVlID0gZml4Qml0d2lzZVJlc3VsdCh2KTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgdGhpcy5fcGFja2VkR2V0VmFsdWUgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9O1xuICB9XG5cbiAgLyoqIEBvdmVycmlkZSAqL1xuICBkZWNvZGUoYiwgb2Zmc2V0KSB7XG4gICAgY29uc3QgZGVzdCA9IHRoaXMubWFrZURlc3RpbmF0aW9uT2JqZWN0KCk7XG4gICAgaWYgKHVuZGVmaW5lZCA9PT0gb2Zmc2V0KSB7XG4gICAgICBvZmZzZXQgPSAwO1xuICAgIH1cbiAgICBjb25zdCB2YWx1ZSA9IHRoaXMud29yZC5kZWNvZGUoYiwgb2Zmc2V0KTtcbiAgICB0aGlzLl9wYWNrZWRTZXRWYWx1ZSh2YWx1ZSk7XG4gICAgZm9yIChjb25zdCBmZCBvZiB0aGlzLmZpZWxkcykge1xuICAgICAgaWYgKHVuZGVmaW5lZCAhPT0gZmQucHJvcGVydHkpIHtcbiAgICAgICAgZGVzdFtmZC5wcm9wZXJ0eV0gPSBmZC5kZWNvZGUodmFsdWUpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZGVzdDtcbiAgfVxuXG4gIC8qKiBJbXBsZW1lbnQge0BsaW5rIExheW91dCNlbmNvZGV8ZW5jb2RlfSBmb3Ige0BsaW5rIEJpdFN0cnVjdHVyZX0uXG4gICAqXG4gICAqIElmIGBzcmNgIGlzIG1pc3NpbmcgYSBwcm9wZXJ0eSBmb3IgYSBtZW1iZXIgd2l0aCBhIGRlZmluZWQge0BsaW5rXG4gICAqIExheW91dCNwcm9wZXJ0eXxwcm9wZXJ0eX0gdGhlIGNvcnJlc3BvbmRpbmcgcmVnaW9uIG9mIHRoZSBwYWNrZWRcbiAgICogdmFsdWUgaXMgbGVmdCB1bm1vZGlmaWVkLiAgVW51c2VkIGJpdHMgYXJlIGFsc28gbGVmdCB1bm1vZGlmaWVkLiAqL1xuICBlbmNvZGUoc3JjLCBiLCBvZmZzZXQpIHtcbiAgICBpZiAodW5kZWZpbmVkID09PSBvZmZzZXQpIHtcbiAgICAgIG9mZnNldCA9IDA7XG4gICAgfVxuICAgIGNvbnN0IHZhbHVlID0gdGhpcy53b3JkLmRlY29kZShiLCBvZmZzZXQpO1xuICAgIHRoaXMuX3BhY2tlZFNldFZhbHVlKHZhbHVlKTtcbiAgICBmb3IgKGNvbnN0IGZkIG9mIHRoaXMuZmllbGRzKSB7XG4gICAgICBpZiAodW5kZWZpbmVkICE9PSBmZC5wcm9wZXJ0eSkge1xuICAgICAgICBjb25zdCBmdiA9IHNyY1tmZC5wcm9wZXJ0eV07XG4gICAgICAgIGlmICh1bmRlZmluZWQgIT09IGZ2KSB7XG4gICAgICAgICAgZmQuZW5jb2RlKGZ2KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGhpcy53b3JkLmVuY29kZSh0aGlzLl9wYWNrZWRHZXRWYWx1ZSgpLCBiLCBvZmZzZXQpO1xuICB9XG5cbiAgLyoqIFJlZ2lzdGVyIGEgbmV3IGJpdGZpZWxkIHdpdGggYSBjb250YWluaW5nIGJpdCBzdHJ1Y3R1cmUuICBUaGVcbiAgICogcmVzdWx0aW5nIGJpdGZpZWxkIGlzIHJldHVybmVkLlxuICAgKlxuICAgKiBAcGFyYW0ge051bWJlcn0gYml0cyAtIGluaXRpYWxpemVyIGZvciB7QGxpbmsgQml0RmllbGQjYml0c3xiaXRzfS5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IHByb3BlcnR5IC0gaW5pdGlhbGl6ZXIgZm9yIHtAbGlua1xuICAgKiBMYXlvdXQjcHJvcGVydHl8cHJvcGVydHl9LlxuICAgKlxuICAgKiBAcmV0dXJuIHtCaXRGaWVsZH0gKi9cbiAgYWRkRmllbGQoYml0cywgcHJvcGVydHkpIHtcbiAgICBjb25zdCBiZiA9IG5ldyBCaXRGaWVsZCh0aGlzLCBiaXRzLCBwcm9wZXJ0eSk7XG4gICAgdGhpcy5maWVsZHMucHVzaChiZik7XG4gICAgcmV0dXJuIGJmO1xuICB9XG5cbiAgLyoqIEFzIHdpdGgge0BsaW5rIEJpdFN0cnVjdHVyZSNhZGRGaWVsZHxhZGRGaWVsZH0gZm9yIHNpbmdsZS1iaXRcbiAgICogZmllbGRzIHdpdGggYGJvb2xlYW5gIHZhbHVlIHJlcHJlc2VudGF0aW9uLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gcHJvcGVydHkgLSBpbml0aWFsaXplciBmb3Ige0BsaW5rXG4gICAqIExheW91dCNwcm9wZXJ0eXxwcm9wZXJ0eX0uXG4gICAqXG4gICAqIEByZXR1cm4ge0Jvb2xlYW59ICovXG4gIGFkZEJvb2xlYW4ocHJvcGVydHkpIHtcbiAgICAvLyBUaGlzIGlzIG15IEJvb2xlYW4sIG5vdCB0aGUgSmF2YXNjcmlwdCBvbmUuXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLW5ldy13cmFwcGVyc1xuICAgIGNvbnN0IGJmID0gbmV3IEJvb2xlYW4odGhpcywgcHJvcGVydHkpO1xuICAgIHRoaXMuZmllbGRzLnB1c2goYmYpO1xuICAgIHJldHVybiBiZjtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgYWNjZXNzIHRvIHRoZSBiaXQgZmllbGQgZm9yIGEgZ2l2ZW4gcHJvcGVydHkuXG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBwcm9wZXJ0eSAtIHRoZSBiaXQgZmllbGQgb2YgaW50ZXJlc3QuXG4gICAqXG4gICAqIEByZXR1cm4ge0JpdEZpZWxkfSAtIHRoZSBmaWVsZCBhc3NvY2lhdGVkIHdpdGggYHByb3BlcnR5YCwgb3JcbiAgICogdW5kZWZpbmVkIGlmIHRoZXJlIGlzIG5vIHN1Y2ggcHJvcGVydHkuXG4gICAqL1xuICBmaWVsZEZvcihwcm9wZXJ0eSkge1xuICAgIGlmICgnc3RyaW5nJyAhPT0gdHlwZW9mIHByb3BlcnR5KSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdwcm9wZXJ0eSBtdXN0IGJlIHN0cmluZycpO1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IGZkIG9mIHRoaXMuZmllbGRzKSB7XG4gICAgICBpZiAoZmQucHJvcGVydHkgPT09IHByb3BlcnR5KSB7XG4gICAgICAgIHJldHVybiBmZDtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBSZXByZXNlbnQgYSBzZXF1ZW5jZSBvZiBiaXRzIHdpdGhpbiBhIHtAbGluayBCaXRTdHJ1Y3R1cmV9LlxuICpcbiAqIEFsbCBiaXQgZmllbGQgdmFsdWVzIGFyZSByZXByZXNlbnRlZCBhcyB1bnNpZ25lZCBpbnRlZ2Vycy5cbiAqXG4gKiAqKk5PVEUqKiBVc2VyIGNvZGUgc2hvdWxkIG5vdCBpbnZva2UgdGhpcyBjb25zdHJ1Y3RvciBkaXJlY3RseS5cbiAqIFVzZSB0aGUgY29udGFpbmVyIHtAbGluayBCaXRTdHJ1Y3R1cmUjYWRkRmllbGR8YWRkRmllbGR9IGhlbHBlclxuICogbWV0aG9kLlxuICpcbiAqICoqTk9URSoqIEJpdEZpZWxkIGluc3RhbmNlcyBhcmUgbm90IGluc3RhbmNlcyBvZiB7QGxpbmsgTGF5b3V0fVxuICogc2luY2Uge0BsaW5rIExheW91dCNzcGFufHNwYW59IG1lYXN1cmVzIDgtYml0IHVuaXRzLlxuICpcbiAqIEBwYXJhbSB7Qml0U3RydWN0dXJlfSBjb250YWluZXIgLSBpbml0aWFsaXplciBmb3Ige0BsaW5rXG4gKiBCaXRGaWVsZCNjb250YWluZXJ8Y29udGFpbmVyfS5cbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gYml0cyAtIGluaXRpYWxpemVyIGZvciB7QGxpbmsgQml0RmllbGQjYml0c3xiaXRzfS5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gW3Byb3BlcnR5XSAtIGluaXRpYWxpemVyIGZvciB7QGxpbmtcbiAqIExheW91dCNwcm9wZXJ0eXxwcm9wZXJ0eX0uXG4gKi9cbmNsYXNzIEJpdEZpZWxkIHtcbiAgY29uc3RydWN0b3IoY29udGFpbmVyLCBiaXRzLCBwcm9wZXJ0eSkge1xuICAgIGlmICghKGNvbnRhaW5lciBpbnN0YW5jZW9mIEJpdFN0cnVjdHVyZSkpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2NvbnRhaW5lciBtdXN0IGJlIGEgQml0U3RydWN0dXJlJyk7XG4gICAgfVxuICAgIGlmICgoIU51bWJlci5pc0ludGVnZXIoYml0cykpIHx8ICgwID49IGJpdHMpKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdiaXRzIG11c3QgYmUgcG9zaXRpdmUgaW50ZWdlcicpO1xuICAgIH1cbiAgICBjb25zdCB0b3RhbEJpdHMgPSA4ICogY29udGFpbmVyLnNwYW47XG4gICAgY29uc3QgdXNlZEJpdHMgPSBjb250YWluZXIuZmllbGRzLnJlZHVjZSgoc3VtLCBmZCkgPT4gc3VtICsgZmQuYml0cywgMCk7XG4gICAgaWYgKChiaXRzICsgdXNlZEJpdHMpID4gdG90YWxCaXRzKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2JpdHMgdG9vIGxvbmcgZm9yIHNwYW4gcmVtYWluZGVyICgnXG4gICAgICAgICAgICAgICAgICAgICAgKyAodG90YWxCaXRzIC0gdXNlZEJpdHMpICsgJyBvZiAnXG4gICAgICAgICAgICAgICAgICAgICAgKyB0b3RhbEJpdHMgKyAnIHJlbWFpbiknKTtcbiAgICB9XG5cbiAgICAvKiogVGhlIHtAbGluayBCaXRTdHJ1Y3R1cmV9IGluc3RhbmNlIHRvIHdoaWNoIHRoaXMgYml0IGZpZWxkXG4gICAgICogYmVsb25ncy4gKi9cbiAgICB0aGlzLmNvbnRhaW5lciA9IGNvbnRhaW5lcjtcblxuICAgIC8qKiBUaGUgc3BhbiBvZiB0aGlzIHZhbHVlIGluIGJpdHMuICovXG4gICAgdGhpcy5iaXRzID0gYml0cztcblxuICAgIC8qKiBBIG1hc2sgb2Yge0BsaW5rIEJpdEZpZWxkI2JpdHN8Yml0c30gYml0cyBpc29sYXRpbmcgdmFsdWUgYml0c1xuICAgICAqIHRoYXQgZml0IHdpdGhpbiB0aGUgZmllbGQuXG4gICAgICpcbiAgICAgKiBUaGF0IGlzLCBpdCBtYXNrcyBhIHZhbHVlIHRoYXQgaGFzIG5vdCB5ZXQgYmVlbiBzaGlmdGVkIGludG9cbiAgICAgKiBwb3NpdGlvbiB3aXRoaW4gaXRzIGNvbnRhaW5pbmcgcGFja2VkIGludGVnZXIuICovXG4gICAgdGhpcy52YWx1ZU1hc2sgPSAoMSA8PCBiaXRzKSAtIDE7XG4gICAgaWYgKDMyID09PSBiaXRzKSB7IC8vIHNoaWZ0ZWQgdmFsdWUgb3V0IG9mIHJhbmdlXG4gICAgICB0aGlzLnZhbHVlTWFzayA9IDB4RkZGRkZGRkY7XG4gICAgfVxuXG4gICAgLyoqIFRoZSBvZmZzZXQgb2YgdGhlIHZhbHVlIHdpdGhpbiB0aGUgY29udGFpbmluZyBwYWNrZWQgdW5zaWduZWRcbiAgICAgKiBpbnRlZ2VyLiAgVGhlIGxlYXN0IHNpZ25pZmljYW50IGJpdCBvZiB0aGUgcGFja2VkIHZhbHVlIGlzIGF0XG4gICAgICogb2Zmc2V0IHplcm8sIHJlZ2FyZGxlc3Mgb2YgYml0IG9yZGVyaW5nIHVzZWQuICovXG4gICAgdGhpcy5zdGFydCA9IHVzZWRCaXRzO1xuICAgIGlmICh0aGlzLmNvbnRhaW5lci5tc2IpIHtcbiAgICAgIHRoaXMuc3RhcnQgPSB0b3RhbEJpdHMgLSB1c2VkQml0cyAtIGJpdHM7XG4gICAgfVxuXG4gICAgLyoqIEEgbWFzayBvZiB7QGxpbmsgQml0RmllbGQjYml0c3xiaXRzfSBpc29sYXRpbmcgdGhlIGZpZWxkIHZhbHVlXG4gICAgICogd2l0aGluIHRoZSBjb250YWluaW5nIHBhY2tlZCB1bnNpZ25lZCBpbnRlZ2VyLiAqL1xuICAgIHRoaXMud29yZE1hc2sgPSBmaXhCaXR3aXNlUmVzdWx0KHRoaXMudmFsdWVNYXNrIDw8IHRoaXMuc3RhcnQpO1xuXG4gICAgLyoqIFRoZSBwcm9wZXJ0eSBuYW1lIHVzZWQgd2hlbiB0aGlzIGJpdGZpZWxkIGlzIHJlcHJlc2VudGVkIGluIGFuXG4gICAgICogT2JqZWN0LlxuICAgICAqXG4gICAgICogSW50ZW5kZWQgdG8gYmUgZnVuY3Rpb25hbGx5IGVxdWl2YWxlbnQgdG8ge0BsaW5rXG4gICAgICogTGF5b3V0I3Byb3BlcnR5fS5cbiAgICAgKlxuICAgICAqIElmIGxlZnQgdW5kZWZpbmVkIHRoZSBjb3JyZXNwb25kaW5nIHNwYW4gb2YgYml0cyB3aWxsIGJlXG4gICAgICogdHJlYXRlZCBhcyBwYWRkaW5nOiBpdCB3aWxsIG5vdCBiZSBtdXRhdGVkIGJ5IHtAbGlua1xuICAgICAqIExheW91dCNlbmNvZGV8ZW5jb2RlfSBub3IgcmVwcmVzZW50ZWQgYXMgYSBwcm9wZXJ0eSBpbiB0aGVcbiAgICAgKiBkZWNvZGVkIE9iamVjdC4gKi9cbiAgICB0aGlzLnByb3BlcnR5ID0gcHJvcGVydHk7XG4gIH1cblxuICAvKiogU3RvcmUgYSB2YWx1ZSBpbnRvIHRoZSBjb3JyZXNwb25kaW5nIHN1YnNlcXVlbmNlIG9mIHRoZSBjb250YWluaW5nXG4gICAqIGJpdCBmaWVsZC4gKi9cbiAgZGVjb2RlKCkge1xuICAgIGNvbnN0IHdvcmQgPSB0aGlzLmNvbnRhaW5lci5fcGFja2VkR2V0VmFsdWUoKTtcbiAgICBjb25zdCB3b3JkVmFsdWUgPSBmaXhCaXR3aXNlUmVzdWx0KHdvcmQgJiB0aGlzLndvcmRNYXNrKTtcbiAgICBjb25zdCB2YWx1ZSA9IHdvcmRWYWx1ZSA+Pj4gdGhpcy5zdGFydDtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cblxuICAvKiogU3RvcmUgYSB2YWx1ZSBpbnRvIHRoZSBjb3JyZXNwb25kaW5nIHN1YnNlcXVlbmNlIG9mIHRoZSBjb250YWluaW5nXG4gICAqIGJpdCBmaWVsZC5cbiAgICpcbiAgICogKipOT1RFKiogVGhpcyBpcyBub3QgYSBzcGVjaWFsaXphdGlvbiBvZiB7QGxpbmtcbiAgICogTGF5b3V0I2VuY29kZXxMYXlvdXQuZW5jb2RlfSBhbmQgdGhlcmUgaXMgbm8gcmV0dXJuIHZhbHVlLiAqL1xuICBlbmNvZGUodmFsdWUpIHtcbiAgICBpZiAoKCFOdW1iZXIuaXNJbnRlZ2VyKHZhbHVlKSlcbiAgICAgICAgfHwgKHZhbHVlICE9PSBmaXhCaXR3aXNlUmVzdWx0KHZhbHVlICYgdGhpcy52YWx1ZU1hc2spKSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihuYW1lV2l0aFByb3BlcnR5KCdCaXRGaWVsZC5lbmNvZGUnLCB0aGlzKVxuICAgICAgICAgICAgICAgICAgICAgICAgICArICcgdmFsdWUgbXVzdCBiZSBpbnRlZ2VyIG5vdCBleGNlZWRpbmcgJyArIHRoaXMudmFsdWVNYXNrKTtcbiAgICB9XG4gICAgY29uc3Qgd29yZCA9IHRoaXMuY29udGFpbmVyLl9wYWNrZWRHZXRWYWx1ZSgpO1xuICAgIGNvbnN0IHdvcmRWYWx1ZSA9IGZpeEJpdHdpc2VSZXN1bHQodmFsdWUgPDwgdGhpcy5zdGFydCk7XG4gICAgdGhpcy5jb250YWluZXIuX3BhY2tlZFNldFZhbHVlKGZpeEJpdHdpc2VSZXN1bHQod29yZCAmIH50aGlzLndvcmRNYXNrKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IHdvcmRWYWx1ZSk7XG4gIH07XG59XG5cbi8qKlxuICogUmVwcmVzZW50IGEgc2luZ2xlIGJpdCB3aXRoaW4gYSB7QGxpbmsgQml0U3RydWN0dXJlfSBhcyBhXG4gKiBKYXZhU2NyaXB0IGJvb2xlYW4uXG4gKlxuICogKipOT1RFKiogVXNlciBjb2RlIHNob3VsZCBub3QgaW52b2tlIHRoaXMgY29uc3RydWN0b3IgZGlyZWN0bHkuXG4gKiBVc2UgdGhlIGNvbnRhaW5lciB7QGxpbmsgQml0U3RydWN0dXJlI2FkZEJvb2xlYW58YWRkQm9vbGVhbn0gaGVscGVyXG4gKiBtZXRob2QuXG4gKlxuICogQHBhcmFtIHtCaXRTdHJ1Y3R1cmV9IGNvbnRhaW5lciAtIGluaXRpYWxpemVyIGZvciB7QGxpbmtcbiAqIEJpdEZpZWxkI2NvbnRhaW5lcnxjb250YWluZXJ9LlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBbcHJvcGVydHldIC0gaW5pdGlhbGl6ZXIgZm9yIHtAbGlua1xuICogTGF5b3V0I3Byb3BlcnR5fHByb3BlcnR5fS5cbiAqXG4gKiBAYXVnbWVudHMge0JpdEZpZWxkfVxuICovXG4vKiBlc2xpbnQtZGlzYWJsZSBuby1leHRlbmQtbmF0aXZlICovXG5jbGFzcyBCb29sZWFuIGV4dGVuZHMgQml0RmllbGQge1xuICBjb25zdHJ1Y3Rvcihjb250YWluZXIsIHByb3BlcnR5KSB7XG4gICAgc3VwZXIoY29udGFpbmVyLCAxLCBwcm9wZXJ0eSk7XG4gIH1cblxuICAvKiogT3ZlcnJpZGUge0BsaW5rIEJpdEZpZWxkI2RlY29kZXxkZWNvZGV9IGZvciB7QGxpbmsgQm9vbGVhbnxCb29sZWFufS5cbiAgICpcbiAgICogQHJldHVybnMge2Jvb2xlYW59ICovXG4gIGRlY29kZShiLCBvZmZzZXQpIHtcbiAgICByZXR1cm4gISFCaXRGaWVsZC5wcm90b3R5cGUuZGVjb2RlLmNhbGwodGhpcywgYiwgb2Zmc2V0KTtcbiAgfVxuXG4gIC8qKiBAb3ZlcnJpZGUgKi9cbiAgZW5jb2RlKHZhbHVlKSB7XG4gICAgaWYgKCdib29sZWFuJyA9PT0gdHlwZW9mIHZhbHVlKSB7XG4gICAgICAvLyBCaXRGaWVsZCByZXF1aXJlcyBpbnRlZ2VyIHZhbHVlc1xuICAgICAgdmFsdWUgPSArdmFsdWU7XG4gICAgfVxuICAgIHJldHVybiBCaXRGaWVsZC5wcm90b3R5cGUuZW5jb2RlLmNhbGwodGhpcywgdmFsdWUpO1xuICB9XG59XG4vKiBlc2xpbnQtZW5hYmxlIG5vLWV4dGVuZC1uYXRpdmUgKi9cblxuLyoqXG4gKiBDb250YWluIGEgZml4ZWQtbGVuZ3RoIGJsb2NrIG9mIGFyYml0cmFyeSBkYXRhLCByZXByZXNlbnRlZCBhcyBhXG4gKiBCdWZmZXIuXG4gKlxuICogKkZhY3RvcnkqOiB7QGxpbmsgbW9kdWxlOkxheW91dC5ibG9ifGJsb2J9XG4gKlxuICogQHBhcmFtIHsoTnVtYmVyfEV4dGVybmFsTGF5b3V0KX0gbGVuZ3RoIC0gaW5pdGlhbGl6ZXMge0BsaW5rXG4gKiBCbG9iI2xlbmd0aHxsZW5ndGh9LlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBbcHJvcGVydHldIC0gaW5pdGlhbGl6ZXIgZm9yIHtAbGlua1xuICogTGF5b3V0I3Byb3BlcnR5fHByb3BlcnR5fS5cbiAqXG4gKiBAYXVnbWVudHMge0xheW91dH1cbiAqL1xuY2xhc3MgQmxvYiBleHRlbmRzIExheW91dCB7XG4gIGNvbnN0cnVjdG9yKGxlbmd0aCwgcHJvcGVydHkpIHtcbiAgICBpZiAoISgoKGxlbmd0aCBpbnN0YW5jZW9mIEV4dGVybmFsTGF5b3V0KSAmJiBsZW5ndGguaXNDb3VudCgpKVxuICAgICAgICAgIHx8IChOdW1iZXIuaXNJbnRlZ2VyKGxlbmd0aCkgJiYgKDAgPD0gbGVuZ3RoKSkpKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdsZW5ndGggbXVzdCBiZSBwb3NpdGl2ZSBpbnRlZ2VyICdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgKyAnb3IgYW4gdW5zaWduZWQgaW50ZWdlciBFeHRlcm5hbExheW91dCcpO1xuICAgIH1cblxuICAgIGxldCBzcGFuID0gLTE7XG4gICAgaWYgKCEobGVuZ3RoIGluc3RhbmNlb2YgRXh0ZXJuYWxMYXlvdXQpKSB7XG4gICAgICBzcGFuID0gbGVuZ3RoO1xuICAgIH1cbiAgICBzdXBlcihzcGFuLCBwcm9wZXJ0eSk7XG5cbiAgICAvKiogVGhlIG51bWJlciBvZiBieXRlcyBpbiB0aGUgYmxvYi5cbiAgICAgKlxuICAgICAqIFRoaXMgbWF5IGJlIGEgbm9uLW5lZ2F0aXZlIGludGVnZXIsIG9yIGFuIGluc3RhbmNlIG9mIHtAbGlua1xuICAgICAqIEV4dGVybmFsTGF5b3V0fSB0aGF0IHNhdGlzZmllcyB7QGxpbmtcbiAgICAgKiBFeHRlcm5hbExheW91dCNpc0NvdW50fGlzQ291bnQoKX0uICovXG4gICAgdGhpcy5sZW5ndGggPSBsZW5ndGg7XG4gIH1cblxuICAvKiogQG92ZXJyaWRlICovXG4gIGdldFNwYW4oYiwgb2Zmc2V0KSB7XG4gICAgbGV0IHNwYW4gPSB0aGlzLnNwYW47XG4gICAgaWYgKDAgPiBzcGFuKSB7XG4gICAgICBzcGFuID0gdGhpcy5sZW5ndGguZGVjb2RlKGIsIG9mZnNldCk7XG4gICAgfVxuICAgIHJldHVybiBzcGFuO1xuICB9XG5cbiAgLyoqIEBvdmVycmlkZSAqL1xuICBkZWNvZGUoYiwgb2Zmc2V0KSB7XG4gICAgaWYgKHVuZGVmaW5lZCA9PT0gb2Zmc2V0KSB7XG4gICAgICBvZmZzZXQgPSAwO1xuICAgIH1cbiAgICBsZXQgc3BhbiA9IHRoaXMuc3BhbjtcbiAgICBpZiAoMCA+IHNwYW4pIHtcbiAgICAgIHNwYW4gPSB0aGlzLmxlbmd0aC5kZWNvZGUoYiwgb2Zmc2V0KTtcbiAgICB9XG4gICAgcmV0dXJuIGIuc2xpY2Uob2Zmc2V0LCBvZmZzZXQgKyBzcGFuKTtcbiAgfVxuXG4gIC8qKiBJbXBsZW1lbnQge0BsaW5rIExheW91dCNlbmNvZGV8ZW5jb2RlfSBmb3Ige0BsaW5rIEJsb2J9LlxuICAgKlxuICAgKiAqKk5PVEUqKiBJZiB7QGxpbmsgTGF5b3V0I2NvdW50fGNvdW50fSBpcyBhbiBpbnN0YW5jZSBvZiB7QGxpbmtcbiAgICogRXh0ZXJuYWxMYXlvdXR9IHRoZW4gdGhlIGxlbmd0aCBvZiBgc3JjYCB3aWxsIGJlIGVuY29kZWQgYXMgdGhlXG4gICAqIGNvdW50IGFmdGVyIGBzcmNgIGlzIGVuY29kZWQuICovXG4gIGVuY29kZShzcmMsIGIsIG9mZnNldCkge1xuICAgIGxldCBzcGFuID0gdGhpcy5sZW5ndGg7XG4gICAgaWYgKHRoaXMubGVuZ3RoIGluc3RhbmNlb2YgRXh0ZXJuYWxMYXlvdXQpIHtcbiAgICAgIHNwYW4gPSBzcmMubGVuZ3RoO1xuICAgIH1cbiAgICBpZiAoIShCdWZmZXIuaXNCdWZmZXIoc3JjKVxuICAgICAgICAgICYmIChzcGFuID09PSBzcmMubGVuZ3RoKSkpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IobmFtZVdpdGhQcm9wZXJ0eSgnQmxvYi5lbmNvZGUnLCB0aGlzKVxuICAgICAgICAgICAgICAgICAgICAgICAgICArICcgcmVxdWlyZXMgKGxlbmd0aCAnICsgc3BhbiArICcpIEJ1ZmZlciBhcyBzcmMnKTtcbiAgICB9XG4gICAgaWYgKChvZmZzZXQgKyBzcGFuKSA+IGIubGVuZ3RoKSB7XG4gICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignZW5jb2Rpbmcgb3ZlcnJ1bnMgQnVmZmVyJyk7XG4gICAgfVxuICAgIGIud3JpdGUoc3JjLnRvU3RyaW5nKCdoZXgnKSwgb2Zmc2V0LCBzcGFuLCAnaGV4Jyk7XG4gICAgaWYgKHRoaXMubGVuZ3RoIGluc3RhbmNlb2YgRXh0ZXJuYWxMYXlvdXQpIHtcbiAgICAgIHRoaXMubGVuZ3RoLmVuY29kZShzcGFuLCBiLCBvZmZzZXQpO1xuICAgIH1cbiAgICByZXR1cm4gc3BhbjtcbiAgfVxufVxuXG4vKipcbiAqIENvbnRhaW4gYSBgTlVMYC10ZXJtaW5hdGVkIFVURjggc3RyaW5nLlxuICpcbiAqICpGYWN0b3J5Kjoge0BsaW5rIG1vZHVsZTpMYXlvdXQuY3N0cnxjc3RyfVxuICpcbiAqICoqTk9URSoqIEFueSBVVEY4IHN0cmluZyB0aGF0IGluY29ycG9yYXRlcyBhIHplcm8tdmFsdWVkIGJ5dGUgd2lsbFxuICogbm90IGJlIGNvcnJlY3RseSBkZWNvZGVkIGJ5IHRoaXMgbGF5b3V0LlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBbcHJvcGVydHldIC0gaW5pdGlhbGl6ZXIgZm9yIHtAbGlua1xuICogTGF5b3V0I3Byb3BlcnR5fHByb3BlcnR5fS5cbiAqXG4gKiBAYXVnbWVudHMge0xheW91dH1cbiAqL1xuY2xhc3MgQ1N0cmluZyBleHRlbmRzIExheW91dCB7XG4gIGNvbnN0cnVjdG9yKHByb3BlcnR5KSB7XG4gICAgc3VwZXIoLTEsIHByb3BlcnR5KTtcbiAgfVxuXG4gIC8qKiBAb3ZlcnJpZGUgKi9cbiAgZ2V0U3BhbihiLCBvZmZzZXQpIHtcbiAgICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihiKSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignYiBtdXN0IGJlIGEgQnVmZmVyJyk7XG4gICAgfVxuICAgIGlmICh1bmRlZmluZWQgPT09IG9mZnNldCkge1xuICAgICAgb2Zmc2V0ID0gMDtcbiAgICB9XG4gICAgbGV0IGlkeCA9IG9mZnNldDtcbiAgICB3aGlsZSAoKGlkeCA8IGIubGVuZ3RoKSAmJiAoMCAhPT0gYltpZHhdKSkge1xuICAgICAgaWR4ICs9IDE7XG4gICAgfVxuICAgIHJldHVybiAxICsgaWR4IC0gb2Zmc2V0O1xuICB9XG5cbiAgLyoqIEBvdmVycmlkZSAqL1xuICBkZWNvZGUoYiwgb2Zmc2V0LCBkZXN0KSB7XG4gICAgaWYgKHVuZGVmaW5lZCA9PT0gb2Zmc2V0KSB7XG4gICAgICBvZmZzZXQgPSAwO1xuICAgIH1cbiAgICBsZXQgc3BhbiA9IHRoaXMuZ2V0U3BhbihiLCBvZmZzZXQpO1xuICAgIHJldHVybiBiLnNsaWNlKG9mZnNldCwgb2Zmc2V0ICsgc3BhbiAtIDEpLnRvU3RyaW5nKCd1dGYtOCcpO1xuICB9XG5cbiAgLyoqIEBvdmVycmlkZSAqL1xuICBlbmNvZGUoc3JjLCBiLCBvZmZzZXQpIHtcbiAgICBpZiAodW5kZWZpbmVkID09PSBvZmZzZXQpIHtcbiAgICAgIG9mZnNldCA9IDA7XG4gICAgfVxuICAgIC8qIE11c3QgZm9yY2UgdGhpcyB0byBhIHN0cmluZywgbGVzdCBpdCBiZSBhIG51bWJlciBhbmQgdGhlXG4gICAgICogXCJ1dGY4LWVuY29kaW5nXCIgYmVsb3cgYWN0dWFsbHkgYWxsb2NhdGUgYSBidWZmZXIgb2YgbGVuZ3RoXG4gICAgICogc3JjICovXG4gICAgaWYgKCdzdHJpbmcnICE9PSB0eXBlb2Ygc3JjKSB7XG4gICAgICBzcmMgPSBzcmMudG9TdHJpbmcoKTtcbiAgICB9XG4gICAgY29uc3Qgc3JjYiA9IG5ldyBCdWZmZXIoc3JjLCAndXRmOCcpO1xuICAgIGNvbnN0IHNwYW4gPSBzcmNiLmxlbmd0aDtcbiAgICBpZiAoKG9mZnNldCArIHNwYW4pID4gYi5sZW5ndGgpIHtcbiAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdlbmNvZGluZyBvdmVycnVucyBCdWZmZXInKTtcbiAgICB9XG4gICAgc3JjYi5jb3B5KGIsIG9mZnNldCk7XG4gICAgYltvZmZzZXQgKyBzcGFuXSA9IDA7XG4gICAgcmV0dXJuIHNwYW4gKyAxO1xuICB9XG59XG5cbi8qKlxuICogQ29udGFpbiBhIFVURjggc3RyaW5nIHdpdGggaW1wbGljaXQgbGVuZ3RoLlxuICpcbiAqICpGYWN0b3J5Kjoge0BsaW5rIG1vZHVsZTpMYXlvdXQudXRmOHx1dGY4fVxuICpcbiAqICoqTk9URSoqIEJlY2F1c2UgdGhlIGxlbmd0aCBpcyBpbXBsaWNpdCBpbiB0aGUgc2l6ZSBvZiB0aGUgYnVmZmVyXG4gKiB0aGlzIGxheW91dCBzaG91bGQgYmUgdXNlZCBvbmx5IGluIGlzb2xhdGlvbiwgb3IgaW4gYSBzaXR1YXRpb25cbiAqIHdoZXJlIHRoZSBsZW5ndGggY2FuIGJlIGV4cHJlc3NlZCBieSBvcGVyYXRpbmcgb24gYSBzbGljZSBvZiB0aGVcbiAqIGNvbnRhaW5pbmcgYnVmZmVyLlxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSBbbWF4U3Bhbl0gLSB0aGUgbWF4aW11bSBsZW5ndGggYWxsb3dlZCBmb3IgZW5jb2RlZFxuICogc3RyaW5nIGNvbnRlbnQuICBJZiBub3QgcHJvdmlkZWQgdGhlcmUgaXMgbm8gYm91bmQgb24gdGhlIGFsbG93ZWRcbiAqIGNvbnRlbnQuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IFtwcm9wZXJ0eV0gLSBpbml0aWFsaXplciBmb3Ige0BsaW5rXG4gKiBMYXlvdXQjcHJvcGVydHl8cHJvcGVydHl9LlxuICpcbiAqIEBhdWdtZW50cyB7TGF5b3V0fVxuICovXG5jbGFzcyBVVEY4IGV4dGVuZHMgTGF5b3V0IHtcbiAgY29uc3RydWN0b3IobWF4U3BhbiwgcHJvcGVydHkpIHtcbiAgICBpZiAoKCdzdHJpbmcnID09PSB0eXBlb2YgbWF4U3BhbilcbiAgICAgICAgJiYgKHVuZGVmaW5lZCA9PT0gcHJvcGVydHkpKSB7XG4gICAgICBwcm9wZXJ0eSA9IG1heFNwYW47XG4gICAgICBtYXhTcGFuID0gdW5kZWZpbmVkO1xuICAgIH1cbiAgICBpZiAodW5kZWZpbmVkID09PSBtYXhTcGFuKSB7XG4gICAgICBtYXhTcGFuID0gLTE7XG4gICAgfSBlbHNlIGlmICghTnVtYmVyLmlzSW50ZWdlcihtYXhTcGFuKSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignbWF4U3BhbiBtdXN0IGJlIGFuIGludGVnZXInKTtcbiAgICB9XG5cbiAgICBzdXBlcigtMSwgcHJvcGVydHkpO1xuXG4gICAgLyoqIFRoZSBtYXhpbXVtIHNwYW4gb2YgdGhlIGxheW91dCBpbiBieXRlcy5cbiAgICAgKlxuICAgICAqIFBvc2l0aXZlIHZhbHVlcyBhcmUgZ2VuZXJhbGx5IGV4cGVjdGVkLiAgWmVybyBpcyBhYm5vcm1hbC5cbiAgICAgKiBBdHRlbXB0cyB0byBlbmNvZGUgb3IgZGVjb2RlIGEgdmFsdWUgdGhhdCBleGNlZWRzIHRoaXMgbGVuZ3RoXG4gICAgICogd2lsbCB0aHJvdyBhIGBSYW5nZUVycm9yYC5cbiAgICAgKlxuICAgICAqIEEgbmVnYXRpdmUgdmFsdWUgaW5kaWNhdGVzIHRoYXQgdGhlcmUgaXMgbm8gYm91bmQgb24gdGhlIGxlbmd0aFxuICAgICAqIG9mIHRoZSBjb250ZW50LiAqL1xuICAgIHRoaXMubWF4U3BhbiA9IG1heFNwYW47XG4gIH1cblxuICAvKiogQG92ZXJyaWRlICovXG4gIGdldFNwYW4oYiwgb2Zmc2V0KSB7XG4gICAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoYikpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2IgbXVzdCBiZSBhIEJ1ZmZlcicpO1xuICAgIH1cbiAgICBpZiAodW5kZWZpbmVkID09PSBvZmZzZXQpIHtcbiAgICAgIG9mZnNldCA9IDA7XG4gICAgfVxuICAgIHJldHVybiBiLmxlbmd0aCAtIG9mZnNldDtcbiAgfVxuXG4gIC8qKiBAb3ZlcnJpZGUgKi9cbiAgZGVjb2RlKGIsIG9mZnNldCwgZGVzdCkge1xuICAgIGlmICh1bmRlZmluZWQgPT09IG9mZnNldCkge1xuICAgICAgb2Zmc2V0ID0gMDtcbiAgICB9XG4gICAgbGV0IHNwYW4gPSB0aGlzLmdldFNwYW4oYiwgb2Zmc2V0KTtcbiAgICBpZiAoKDAgPD0gdGhpcy5tYXhTcGFuKVxuICAgICAgICAmJiAodGhpcy5tYXhTcGFuIDwgc3BhbikpIHtcbiAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCd0ZXh0IGxlbmd0aCBleGNlZWRzIG1heFNwYW4nKTtcbiAgICB9XG4gICAgcmV0dXJuIGIuc2xpY2Uob2Zmc2V0LCBvZmZzZXQgKyBzcGFuKS50b1N0cmluZygndXRmLTgnKTtcbiAgfVxuXG4gIC8qKiBAb3ZlcnJpZGUgKi9cbiAgZW5jb2RlKHNyYywgYiwgb2Zmc2V0KSB7XG4gICAgaWYgKHVuZGVmaW5lZCA9PT0gb2Zmc2V0KSB7XG4gICAgICBvZmZzZXQgPSAwO1xuICAgIH1cbiAgICAvKiBNdXN0IGZvcmNlIHRoaXMgdG8gYSBzdHJpbmcsIGxlc3QgaXQgYmUgYSBudW1iZXIgYW5kIHRoZVxuICAgICAqIFwidXRmOC1lbmNvZGluZ1wiIGJlbG93IGFjdHVhbGx5IGFsbG9jYXRlIGEgYnVmZmVyIG9mIGxlbmd0aFxuICAgICAqIHNyYyAqL1xuICAgIGlmICgnc3RyaW5nJyAhPT0gdHlwZW9mIHNyYykge1xuICAgICAgc3JjID0gc3JjLnRvU3RyaW5nKCk7XG4gICAgfVxuICAgIGNvbnN0IHNyY2IgPSBuZXcgQnVmZmVyKHNyYywgJ3V0ZjgnKTtcbiAgICBjb25zdCBzcGFuID0gc3JjYi5sZW5ndGg7XG4gICAgaWYgKCgwIDw9IHRoaXMubWF4U3BhbilcbiAgICAgICAgJiYgKHRoaXMubWF4U3BhbiA8IHNwYW4pKSB7XG4gICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcigndGV4dCBsZW5ndGggZXhjZWVkcyBtYXhTcGFuJyk7XG4gICAgfVxuICAgIGlmICgob2Zmc2V0ICsgc3BhbikgPiBiLmxlbmd0aCkge1xuICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ2VuY29kaW5nIG92ZXJydW5zIEJ1ZmZlcicpO1xuICAgIH1cbiAgICBzcmNiLmNvcHkoYiwgb2Zmc2V0KTtcbiAgICByZXR1cm4gc3BhbjtcbiAgfVxufVxuXG4vKipcbiAqIENvbnRhaW4gYSBjb25zdGFudCB2YWx1ZS5cbiAqXG4gKiBUaGlzIGxheW91dCBtYXkgYmUgdXNlZCBpbiBjYXNlcyB3aGVyZSBhIEphdmFTY3JpcHQgdmFsdWUgY2FuIGJlXG4gKiBpbmZlcnJlZCB3aXRob3V0IGFuIGV4cHJlc3Npb24gaW4gdGhlIGJpbmFyeSBlbmNvZGluZy4gIEFuIGV4YW1wbGVcbiAqIHdvdWxkIGJlIGEge0BsaW5rIFZhcmlhbnRMYXlvdXR8dmFyaWFudCBsYXlvdXR9IHdoZXJlIHRoZSBjb250ZW50XG4gKiBpcyBpbXBsaWVkIGJ5IHRoZSB1bmlvbiB7QGxpbmsgVW5pb24jZGlzY3JpbWluYXRvcnxkaXNjcmltaW5hdG9yfS5cbiAqXG4gKiBAcGFyYW0ge09iamVjdHxOdW1iZXJ8U3RyaW5nfSB2YWx1ZSAtIGluaXRpYWxpemVyIGZvciB7QGxpbmtcbiAqIENvbnN0YW50I3ZhbHVlfHZhbHVlfS4gIElmIHRoZSB2YWx1ZSBpcyBhbiBvYmplY3QgKG9yIGFycmF5KSBhbmRcbiAqIHRoZSBhcHBsaWNhdGlvbiBpbnRlbmRzIHRoZSBvYmplY3QgdG8gcmVtYWluIHVuY2hhbmdlZCByZWdhcmRsZXNzXG4gKiBvZiB3aGF0IGlzIGRvbmUgdG8gdmFsdWVzIGRlY29kZWQgYnkgdGhpcyBsYXlvdXQsIHRoZSB2YWx1ZSBzaG91bGRcbiAqIGJlIGZyb3plbiBwcmlvciBwYXNzaW5nIGl0IHRvIHRoaXMgY29uc3RydWN0b3IuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IFtwcm9wZXJ0eV0gLSBpbml0aWFsaXplciBmb3Ige0BsaW5rXG4gKiBMYXlvdXQjcHJvcGVydHl8cHJvcGVydHl9LlxuICpcbiAqIEBhdWdtZW50cyB7TGF5b3V0fVxuICovXG5jbGFzcyBDb25zdGFudCBleHRlbmRzIExheW91dCB7XG4gIGNvbnN0cnVjdG9yKHZhbHVlLCBwcm9wZXJ0eSkge1xuICAgIHN1cGVyKDAsIHByb3BlcnR5KTtcblxuICAgIC8qKiBUaGUgdmFsdWUgcHJvZHVjZWQgYnkgdGhpcyBjb25zdGFudCB3aGVuIHRoZSBsYXlvdXQgaXMge0BsaW5rXG4gICAgICogQ29uc3RhbnQjZGVjb2RlfGRlY29kZWR9LlxuICAgICAqXG4gICAgICogQW55IEphdmFTY3JpcHQgdmFsdWUgaW5jbHVkaW5nIGBudWxsYCBhbmQgYHVuZGVmaW5lZGAgaXNcbiAgICAgKiBwZXJtaXR0ZWQuXG4gICAgICpcbiAgICAgKiAqKldBUk5JTkcqKiBJZiBgdmFsdWVgIHBhc3NlZCBpbiB0aGUgY29uc3RydWN0b3Igd2FzIG5vdFxuICAgICAqIGZyb3plbiwgaXQgaXMgcG9zc2libGUgZm9yIHVzZXJzIG9mIGRlY29kZWQgdmFsdWVzIHRvIGNoYW5nZVxuICAgICAqIHRoZSBjb250ZW50IG9mIHRoZSB2YWx1ZS4gKi9cbiAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gIH1cblxuICAvKiogQG92ZXJyaWRlICovXG4gIGRlY29kZShiLCBvZmZzZXQsIGRlc3QpIHtcbiAgICByZXR1cm4gdGhpcy52YWx1ZTtcbiAgfVxuXG4gIC8qKiBAb3ZlcnJpZGUgKi9cbiAgZW5jb2RlKHNyYywgYiwgb2Zmc2V0KSB7XG4gICAgLyogQ29uc3RhbnRzIHRha2Ugbm8gc3BhY2UgKi9cbiAgICByZXR1cm4gMDtcbiAgfVxufVxuXG5leHBvcnRzLkV4dGVybmFsTGF5b3V0ID0gRXh0ZXJuYWxMYXlvdXQ7XG5leHBvcnRzLkdyZWVkeUNvdW50ID0gR3JlZWR5Q291bnQ7XG5leHBvcnRzLk9mZnNldExheW91dCA9IE9mZnNldExheW91dDtcbmV4cG9ydHMuVUludCA9IFVJbnQ7XG5leHBvcnRzLlVJbnRCRSA9IFVJbnRCRTtcbmV4cG9ydHMuSW50ID0gSW50O1xuZXhwb3J0cy5JbnRCRSA9IEludEJFO1xuZXhwb3J0cy5GbG9hdCA9IEZsb2F0O1xuZXhwb3J0cy5GbG9hdEJFID0gRmxvYXRCRTtcbmV4cG9ydHMuRG91YmxlID0gRG91YmxlO1xuZXhwb3J0cy5Eb3VibGVCRSA9IERvdWJsZUJFO1xuZXhwb3J0cy5TZXF1ZW5jZSA9IFNlcXVlbmNlO1xuZXhwb3J0cy5TdHJ1Y3R1cmUgPSBTdHJ1Y3R1cmU7XG5leHBvcnRzLlVuaW9uRGlzY3JpbWluYXRvciA9IFVuaW9uRGlzY3JpbWluYXRvcjtcbmV4cG9ydHMuVW5pb25MYXlvdXREaXNjcmltaW5hdG9yID0gVW5pb25MYXlvdXREaXNjcmltaW5hdG9yO1xuZXhwb3J0cy5VbmlvbiA9IFVuaW9uO1xuZXhwb3J0cy5WYXJpYW50TGF5b3V0ID0gVmFyaWFudExheW91dDtcbmV4cG9ydHMuQml0U3RydWN0dXJlID0gQml0U3RydWN0dXJlO1xuZXhwb3J0cy5CaXRGaWVsZCA9IEJpdEZpZWxkO1xuZXhwb3J0cy5Cb29sZWFuID0gQm9vbGVhbjtcbmV4cG9ydHMuQmxvYiA9IEJsb2I7XG5leHBvcnRzLkNTdHJpbmcgPSBDU3RyaW5nO1xuZXhwb3J0cy5VVEY4ID0gVVRGODtcbmV4cG9ydHMuQ29uc3RhbnQgPSBDb25zdGFudDtcblxuLyoqIEZhY3RvcnkgZm9yIHtAbGluayBHcmVlZHlDb3VudH0uICovXG5leHBvcnRzLmdyZWVkeSA9ICgoZWxlbWVudFNwYW4sIHByb3BlcnR5KSA9PiBuZXcgR3JlZWR5Q291bnQoZWxlbWVudFNwYW4sIHByb3BlcnR5KSk7XG5cbi8qKiBGYWN0b3J5IGZvciB7QGxpbmsgT2Zmc2V0TGF5b3V0fS4gKi9cbmV4cG9ydHMub2Zmc2V0ID0gKChsYXlvdXQsIG9mZnNldCwgcHJvcGVydHkpID0+IG5ldyBPZmZzZXRMYXlvdXQobGF5b3V0LCBvZmZzZXQsIHByb3BlcnR5KSk7XG5cbi8qKiBGYWN0b3J5IGZvciB7QGxpbmsgVUludHx1bnNpZ25lZCBpbnQgbGF5b3V0c30gc3Bhbm5pbmcgb25lXG4gKiBieXRlLiAqL1xuZXhwb3J0cy51OCA9IChwcm9wZXJ0eSA9PiBuZXcgVUludCgxLCBwcm9wZXJ0eSkpO1xuXG4vKiogRmFjdG9yeSBmb3Ige0BsaW5rIFVJbnR8bGl0dGxlLWVuZGlhbiB1bnNpZ25lZCBpbnQgbGF5b3V0c31cbiAqIHNwYW5uaW5nIHR3byBieXRlcy4gKi9cbmV4cG9ydHMudTE2ID0gKHByb3BlcnR5ID0+IG5ldyBVSW50KDIsIHByb3BlcnR5KSk7XG5cbi8qKiBGYWN0b3J5IGZvciB7QGxpbmsgVUludHxsaXR0bGUtZW5kaWFuIHVuc2lnbmVkIGludCBsYXlvdXRzfVxuICogc3Bhbm5pbmcgdGhyZWUgYnl0ZXMuICovXG5leHBvcnRzLnUyNCA9IChwcm9wZXJ0eSA9PiBuZXcgVUludCgzLCBwcm9wZXJ0eSkpO1xuXG4vKiogRmFjdG9yeSBmb3Ige0BsaW5rIFVJbnR8bGl0dGxlLWVuZGlhbiB1bnNpZ25lZCBpbnQgbGF5b3V0c31cbiAqIHNwYW5uaW5nIGZvdXIgYnl0ZXMuICovXG5leHBvcnRzLnUzMiA9IChwcm9wZXJ0eSA9PiBuZXcgVUludCg0LCBwcm9wZXJ0eSkpO1xuXG4vKiogRmFjdG9yeSBmb3Ige0BsaW5rIFVJbnR8bGl0dGxlLWVuZGlhbiB1bnNpZ25lZCBpbnQgbGF5b3V0c31cbiAqIHNwYW5uaW5nIGZpdmUgYnl0ZXMuICovXG5leHBvcnRzLnU0MCA9IChwcm9wZXJ0eSA9PiBuZXcgVUludCg1LCBwcm9wZXJ0eSkpO1xuXG4vKiogRmFjdG9yeSBmb3Ige0BsaW5rIFVJbnR8bGl0dGxlLWVuZGlhbiB1bnNpZ25lZCBpbnQgbGF5b3V0c31cbiAqIHNwYW5uaW5nIHNpeCBieXRlcy4gKi9cbmV4cG9ydHMudTQ4ID0gKHByb3BlcnR5ID0+IG5ldyBVSW50KDYsIHByb3BlcnR5KSk7XG5cbi8qKiBGYWN0b3J5IGZvciB7QGxpbmsgTmVhclVJbnQ2NHxsaXR0bGUtZW5kaWFuIHVuc2lnbmVkIGludFxuICogbGF5b3V0c30gaW50ZXJwcmV0ZWQgYXMgTnVtYmVycy4gKi9cbmV4cG9ydHMubnU2NCA9IChwcm9wZXJ0eSA9PiBuZXcgTmVhclVJbnQ2NChwcm9wZXJ0eSkpO1xuXG4vKiogRmFjdG9yeSBmb3Ige0BsaW5rIFVJbnR8YmlnLWVuZGlhbiB1bnNpZ25lZCBpbnQgbGF5b3V0c31cbiAqIHNwYW5uaW5nIHR3byBieXRlcy4gKi9cbmV4cG9ydHMudTE2YmUgPSAocHJvcGVydHkgPT4gbmV3IFVJbnRCRSgyLCBwcm9wZXJ0eSkpO1xuXG4vKiogRmFjdG9yeSBmb3Ige0BsaW5rIFVJbnR8YmlnLWVuZGlhbiB1bnNpZ25lZCBpbnQgbGF5b3V0c31cbiAqIHNwYW5uaW5nIHRocmVlIGJ5dGVzLiAqL1xuZXhwb3J0cy51MjRiZSA9IChwcm9wZXJ0eSA9PiBuZXcgVUludEJFKDMsIHByb3BlcnR5KSk7XG5cbi8qKiBGYWN0b3J5IGZvciB7QGxpbmsgVUludHxiaWctZW5kaWFuIHVuc2lnbmVkIGludCBsYXlvdXRzfVxuICogc3Bhbm5pbmcgZm91ciBieXRlcy4gKi9cbmV4cG9ydHMudTMyYmUgPSAocHJvcGVydHkgPT4gbmV3IFVJbnRCRSg0LCBwcm9wZXJ0eSkpO1xuXG4vKiogRmFjdG9yeSBmb3Ige0BsaW5rIFVJbnR8YmlnLWVuZGlhbiB1bnNpZ25lZCBpbnQgbGF5b3V0c31cbiAqIHNwYW5uaW5nIGZpdmUgYnl0ZXMuICovXG5leHBvcnRzLnU0MGJlID0gKHByb3BlcnR5ID0+IG5ldyBVSW50QkUoNSwgcHJvcGVydHkpKTtcblxuLyoqIEZhY3RvcnkgZm9yIHtAbGluayBVSW50fGJpZy1lbmRpYW4gdW5zaWduZWQgaW50IGxheW91dHN9XG4gKiBzcGFubmluZyBzaXggYnl0ZXMuICovXG5leHBvcnRzLnU0OGJlID0gKHByb3BlcnR5ID0+IG5ldyBVSW50QkUoNiwgcHJvcGVydHkpKTtcblxuLyoqIEZhY3RvcnkgZm9yIHtAbGluayBOZWFyVUludDY0QkV8YmlnLWVuZGlhbiB1bnNpZ25lZCBpbnRcbiAqIGxheW91dHN9IGludGVycHJldGVkIGFzIE51bWJlcnMuICovXG5leHBvcnRzLm51NjRiZSA9IChwcm9wZXJ0eSA9PiBuZXcgTmVhclVJbnQ2NEJFKHByb3BlcnR5KSk7XG5cbi8qKiBGYWN0b3J5IGZvciB7QGxpbmsgSW50fHNpZ25lZCBpbnQgbGF5b3V0c30gc3Bhbm5pbmcgb25lXG4gKiBieXRlLiAqL1xuZXhwb3J0cy5zOCA9IChwcm9wZXJ0eSA9PiBuZXcgSW50KDEsIHByb3BlcnR5KSk7XG5cbi8qKiBGYWN0b3J5IGZvciB7QGxpbmsgSW50fGxpdHRsZS1lbmRpYW4gc2lnbmVkIGludCBsYXlvdXRzfVxuICogc3Bhbm5pbmcgdHdvIGJ5dGVzLiAqL1xuZXhwb3J0cy5zMTYgPSAocHJvcGVydHkgPT4gbmV3IEludCgyLCBwcm9wZXJ0eSkpO1xuXG4vKiogRmFjdG9yeSBmb3Ige0BsaW5rIEludHxsaXR0bGUtZW5kaWFuIHNpZ25lZCBpbnQgbGF5b3V0c31cbiAqIHNwYW5uaW5nIHRocmVlIGJ5dGVzLiAqL1xuZXhwb3J0cy5zMjQgPSAocHJvcGVydHkgPT4gbmV3IEludCgzLCBwcm9wZXJ0eSkpO1xuXG4vKiogRmFjdG9yeSBmb3Ige0BsaW5rIEludHxsaXR0bGUtZW5kaWFuIHNpZ25lZCBpbnQgbGF5b3V0c31cbiAqIHNwYW5uaW5nIGZvdXIgYnl0ZXMuICovXG5leHBvcnRzLnMzMiA9IChwcm9wZXJ0eSA9PiBuZXcgSW50KDQsIHByb3BlcnR5KSk7XG5cbi8qKiBGYWN0b3J5IGZvciB7QGxpbmsgSW50fGxpdHRsZS1lbmRpYW4gc2lnbmVkIGludCBsYXlvdXRzfVxuICogc3Bhbm5pbmcgZml2ZSBieXRlcy4gKi9cbmV4cG9ydHMuczQwID0gKHByb3BlcnR5ID0+IG5ldyBJbnQoNSwgcHJvcGVydHkpKTtcblxuLyoqIEZhY3RvcnkgZm9yIHtAbGluayBJbnR8bGl0dGxlLWVuZGlhbiBzaWduZWQgaW50IGxheW91dHN9XG4gKiBzcGFubmluZyBzaXggYnl0ZXMuICovXG5leHBvcnRzLnM0OCA9IChwcm9wZXJ0eSA9PiBuZXcgSW50KDYsIHByb3BlcnR5KSk7XG5cbi8qKiBGYWN0b3J5IGZvciB7QGxpbmsgTmVhckludDY0fGxpdHRsZS1lbmRpYW4gc2lnbmVkIGludCBsYXlvdXRzfVxuICogaW50ZXJwcmV0ZWQgYXMgTnVtYmVycy4gKi9cbmV4cG9ydHMubnM2NCA9IChwcm9wZXJ0eSA9PiBuZXcgTmVhckludDY0KHByb3BlcnR5KSk7XG5cbi8qKiBGYWN0b3J5IGZvciB7QGxpbmsgSW50fGJpZy1lbmRpYW4gc2lnbmVkIGludCBsYXlvdXRzfVxuICogc3Bhbm5pbmcgdHdvIGJ5dGVzLiAqL1xuZXhwb3J0cy5zMTZiZSA9IChwcm9wZXJ0eSA9PiBuZXcgSW50QkUoMiwgcHJvcGVydHkpKTtcblxuLyoqIEZhY3RvcnkgZm9yIHtAbGluayBJbnR8YmlnLWVuZGlhbiBzaWduZWQgaW50IGxheW91dHN9XG4gKiBzcGFubmluZyB0aHJlZSBieXRlcy4gKi9cbmV4cG9ydHMuczI0YmUgPSAocHJvcGVydHkgPT4gbmV3IEludEJFKDMsIHByb3BlcnR5KSk7XG5cbi8qKiBGYWN0b3J5IGZvciB7QGxpbmsgSW50fGJpZy1lbmRpYW4gc2lnbmVkIGludCBsYXlvdXRzfVxuICogc3Bhbm5pbmcgZm91ciBieXRlcy4gKi9cbmV4cG9ydHMuczMyYmUgPSAocHJvcGVydHkgPT4gbmV3IEludEJFKDQsIHByb3BlcnR5KSk7XG5cbi8qKiBGYWN0b3J5IGZvciB7QGxpbmsgSW50fGJpZy1lbmRpYW4gc2lnbmVkIGludCBsYXlvdXRzfVxuICogc3Bhbm5pbmcgZml2ZSBieXRlcy4gKi9cbmV4cG9ydHMuczQwYmUgPSAocHJvcGVydHkgPT4gbmV3IEludEJFKDUsIHByb3BlcnR5KSk7XG5cbi8qKiBGYWN0b3J5IGZvciB7QGxpbmsgSW50fGJpZy1lbmRpYW4gc2lnbmVkIGludCBsYXlvdXRzfVxuICogc3Bhbm5pbmcgc2l4IGJ5dGVzLiAqL1xuZXhwb3J0cy5zNDhiZSA9IChwcm9wZXJ0eSA9PiBuZXcgSW50QkUoNiwgcHJvcGVydHkpKTtcblxuLyoqIEZhY3RvcnkgZm9yIHtAbGluayBOZWFySW50NjRCRXxiaWctZW5kaWFuIHNpZ25lZCBpbnQgbGF5b3V0c31cbiAqIGludGVycHJldGVkIGFzIE51bWJlcnMuICovXG5leHBvcnRzLm5zNjRiZSA9IChwcm9wZXJ0eSA9PiBuZXcgTmVhckludDY0QkUocHJvcGVydHkpKTtcblxuLyoqIEZhY3RvcnkgZm9yIHtAbGluayBGbG9hdHxsaXR0bGUtZW5kaWFuIDMyLWJpdCBmbG9hdGluZyBwb2ludH0gdmFsdWVzLiAqL1xuZXhwb3J0cy5mMzIgPSAocHJvcGVydHkgPT4gbmV3IEZsb2F0KHByb3BlcnR5KSk7XG5cbi8qKiBGYWN0b3J5IGZvciB7QGxpbmsgRmxvYXRCRXxiaWctZW5kaWFuIDMyLWJpdCBmbG9hdGluZyBwb2ludH0gdmFsdWVzLiAqL1xuZXhwb3J0cy5mMzJiZSA9IChwcm9wZXJ0eSA9PiBuZXcgRmxvYXRCRShwcm9wZXJ0eSkpO1xuXG4vKiogRmFjdG9yeSBmb3Ige0BsaW5rIERvdWJsZXxsaXR0bGUtZW5kaWFuIDY0LWJpdCBmbG9hdGluZyBwb2ludH0gdmFsdWVzLiAqL1xuZXhwb3J0cy5mNjQgPSAocHJvcGVydHkgPT4gbmV3IERvdWJsZShwcm9wZXJ0eSkpO1xuXG4vKiogRmFjdG9yeSBmb3Ige0BsaW5rIERvdWJsZUJFfGJpZy1lbmRpYW4gNjQtYml0IGZsb2F0aW5nIHBvaW50fSB2YWx1ZXMuICovXG5leHBvcnRzLmY2NGJlID0gKHByb3BlcnR5ID0+IG5ldyBEb3VibGVCRShwcm9wZXJ0eSkpO1xuXG4vKiogRmFjdG9yeSBmb3Ige0BsaW5rIFN0cnVjdHVyZX0gdmFsdWVzLiAqL1xuZXhwb3J0cy5zdHJ1Y3QgPSAoKGZpZWxkcywgcHJvcGVydHksIGRlY29kZVByZWZpeGVzKSA9PiBuZXcgU3RydWN0dXJlKGZpZWxkcywgcHJvcGVydHksIGRlY29kZVByZWZpeGVzKSk7XG5cbi8qKiBGYWN0b3J5IGZvciB7QGxpbmsgQml0U3RydWN0dXJlfSB2YWx1ZXMuICovXG5leHBvcnRzLmJpdHMgPSAoKHdvcmQsIG1zYiwgcHJvcGVydHkpID0+IG5ldyBCaXRTdHJ1Y3R1cmUod29yZCwgbXNiLCBwcm9wZXJ0eSkpO1xuXG4vKiogRmFjdG9yeSBmb3Ige0BsaW5rIFNlcXVlbmNlfSB2YWx1ZXMuICovXG5leHBvcnRzLnNlcSA9ICgoZWxlbWVudExheW91dCwgY291bnQsIHByb3BlcnR5KSA9PiBuZXcgU2VxdWVuY2UoZWxlbWVudExheW91dCwgY291bnQsIHByb3BlcnR5KSk7XG5cbi8qKiBGYWN0b3J5IGZvciB7QGxpbmsgVW5pb259IHZhbHVlcy4gKi9cbmV4cG9ydHMudW5pb24gPSAoKGRpc2NyLCBkZWZhdWx0TGF5b3V0LCBwcm9wZXJ0eSkgPT4gbmV3IFVuaW9uKGRpc2NyLCBkZWZhdWx0TGF5b3V0LCBwcm9wZXJ0eSkpO1xuXG4vKiogRmFjdG9yeSBmb3Ige0BsaW5rIFVuaW9uTGF5b3V0RGlzY3JpbWluYXRvcn0gdmFsdWVzLiAqL1xuZXhwb3J0cy51bmlvbkxheW91dERpc2NyaW1pbmF0b3IgPSAoKGxheW91dCwgcHJvcGVydHkpID0+IG5ldyBVbmlvbkxheW91dERpc2NyaW1pbmF0b3IobGF5b3V0LCBwcm9wZXJ0eSkpO1xuXG4vKiogRmFjdG9yeSBmb3Ige0BsaW5rIEJsb2J9IHZhbHVlcy4gKi9cbmV4cG9ydHMuYmxvYiA9ICgobGVuZ3RoLCBwcm9wZXJ0eSkgPT4gbmV3IEJsb2IobGVuZ3RoLCBwcm9wZXJ0eSkpO1xuXG4vKiogRmFjdG9yeSBmb3Ige0BsaW5rIENTdHJpbmd9IHZhbHVlcy4gKi9cbmV4cG9ydHMuY3N0ciA9IChwcm9wZXJ0eSA9PiBuZXcgQ1N0cmluZyhwcm9wZXJ0eSkpO1xuXG4vKiogRmFjdG9yeSBmb3Ige0BsaW5rIFVURjh9IHZhbHVlcy4gKi9cbmV4cG9ydHMudXRmOCA9ICgobWF4U3BhbiwgcHJvcGVydHkpID0+IG5ldyBVVEY4KG1heFNwYW4sIHByb3BlcnR5KSk7XG5cbi8qKiBGYWN0b3J5IGZvciB7QGxpbmsgQ29uc3RhbnR9IHZhbHVlcy4gKi9cbmV4cG9ydHMuY29uc3QgPSAoKHZhbHVlLCBwcm9wZXJ0eSkgPT4gbmV3IENvbnN0YW50KHZhbHVlLCBwcm9wZXJ0eSkpO1xuIl0sIm5hbWVzIjpbIkxheW91dCIsImNvbnN0cnVjdG9yIiwic3BhbiIsInByb3BlcnR5IiwiTnVtYmVyIiwiaXNJbnRlZ2VyIiwiVHlwZUVycm9yIiwibWFrZURlc3RpbmF0aW9uT2JqZWN0IiwiZGVjb2RlIiwiYiIsIm9mZnNldCIsIkVycm9yIiwiZW5jb2RlIiwic3JjIiwiZ2V0U3BhbiIsIlJhbmdlRXJyb3IiLCJyZXBsaWNhdGUiLCJydiIsIk9iamVjdCIsImNyZWF0ZSIsInByb3RvdHlwZSIsImFzc2lnbiIsImZyb21BcnJheSIsInZhbHVlcyIsInVuZGVmaW5lZCIsImV4cG9ydHMiLCJuYW1lV2l0aFByb3BlcnR5IiwibmFtZSIsImxvIiwiYmluZENvbnN0cnVjdG9yTGF5b3V0IiwiQ2xhc3MiLCJsYXlvdXQiLCJoYXNPd25Qcm9wZXJ0eSIsImxheW91dF8iLCJib3VuZENvbnN0cnVjdG9yXyIsImRlZmluZVByb3BlcnR5IiwidmFsdWUiLCJ3cml0YWJsZSIsIkV4dGVybmFsTGF5b3V0IiwiaXNDb3VudCIsIkdyZWVkeUNvdW50IiwiZWxlbWVudFNwYW4iLCJyZW0iLCJsZW5ndGgiLCJNYXRoIiwiZmxvb3IiLCJPZmZzZXRMYXlvdXQiLCJVSW50IiwiVUludEJFIiwicmVhZFVJbnRMRSIsIndyaXRlVUludExFIiwicmVhZFVJbnRCRSIsIndyaXRlVUludEJFIiwiSW50IiwicmVhZEludExFIiwid3JpdGVJbnRMRSIsIkludEJFIiwicmVhZEludEJFIiwid3JpdGVJbnRCRSIsIlYyRTMyIiwicG93IiwiZGl2bW9kSW50NjQiLCJoaTMyIiwibG8zMiIsInJvdW5kZWRJbnQ2NCIsIk5lYXJVSW50NjQiLCJyZWFkVUludDMyTEUiLCJzcGxpdCIsIndyaXRlVUludDMyTEUiLCJOZWFyVUludDY0QkUiLCJyZWFkVUludDMyQkUiLCJ3cml0ZVVJbnQzMkJFIiwiTmVhckludDY0IiwicmVhZEludDMyTEUiLCJ3cml0ZUludDMyTEUiLCJOZWFySW50NjRCRSIsInJlYWRJbnQzMkJFIiwid3JpdGVJbnQzMkJFIiwiRmxvYXQiLCJyZWFkRmxvYXRMRSIsIndyaXRlRmxvYXRMRSIsIkZsb2F0QkUiLCJyZWFkRmxvYXRCRSIsIndyaXRlRmxvYXRCRSIsIkRvdWJsZSIsInJlYWREb3VibGVMRSIsIndyaXRlRG91YmxlTEUiLCJEb3VibGVCRSIsInJlYWREb3VibGVCRSIsIndyaXRlRG91YmxlQkUiLCJTZXF1ZW5jZSIsImVsZW1lbnRMYXlvdXQiLCJjb3VudCIsImlkeCIsImkiLCJwdXNoIiwiZWxvIiwicmVkdWNlIiwidiIsIlN0cnVjdHVyZSIsImZpZWxkcyIsImRlY29kZVByZWZpeGVzIiwiQXJyYXkiLCJpc0FycmF5IiwiYWNjIiwiZmQiLCJlIiwiZnNwIiwiZGVzdCIsImZpcnN0T2Zmc2V0IiwibGFzdE9mZnNldCIsImxhc3RXcm90ZSIsImZ2Iiwic2hpZnQiLCJsYXlvdXRGb3IiLCJvZmZzZXRPZiIsIlVuaW9uRGlzY3JpbWluYXRvciIsIlVuaW9uTGF5b3V0RGlzY3JpbWluYXRvciIsIlVuaW9uIiwiZGlzY3IiLCJkZWZhdWx0TGF5b3V0IiwidXB2IiwiZGlzY3JpbWluYXRvciIsInVzZXNQcmVmaXhEaXNjcmltaW5hdG9yIiwicmVnaXN0cnkiLCJib3VuZEdldFNvdXJjZVZhcmlhbnQiLCJkZWZhdWx0R2V0U291cmNlVmFyaWFudCIsImJpbmQiLCJnZXRTb3VyY2VWYXJpYW50IiwiY29uZmlnR2V0U291cmNlVmFyaWFudCIsImdzdiIsInZsbyIsImdldFZhcmlhbnQiLCJ0YWciLCJkbG8iLCJjbG8iLCJjb250ZW50T2Zmc2V0IiwiYWRkVmFyaWFudCIsInZhcmlhbnQiLCJWYXJpYW50TGF5b3V0IiwidmIiLCJCdWZmZXIiLCJpc0J1ZmZlciIsInVuaW9uIiwiZml4Qml0d2lzZVJlc3VsdCIsIkJpdFN0cnVjdHVyZSIsIndvcmQiLCJtc2IiLCJfcGFja2VkU2V0VmFsdWUiLCJfcGFja2VkR2V0VmFsdWUiLCJhZGRGaWVsZCIsImJpdHMiLCJiZiIsIkJpdEZpZWxkIiwiYWRkQm9vbGVhbiIsIkJvb2xlYW4iLCJmaWVsZEZvciIsImNvbnRhaW5lciIsInRvdGFsQml0cyIsInVzZWRCaXRzIiwic3VtIiwidmFsdWVNYXNrIiwic3RhcnQiLCJ3b3JkTWFzayIsIndvcmRWYWx1ZSIsImNhbGwiLCJCbG9iIiwic2xpY2UiLCJ3cml0ZSIsInRvU3RyaW5nIiwiQ1N0cmluZyIsInNyY2IiLCJjb3B5IiwiVVRGOCIsIm1heFNwYW4iLCJDb25zdGFudCIsImdyZWVkeSIsInU4IiwidTE2IiwidTI0IiwidTMyIiwidTQwIiwidTQ4IiwibnU2NCIsInUxNmJlIiwidTI0YmUiLCJ1MzJiZSIsInU0MGJlIiwidTQ4YmUiLCJudTY0YmUiLCJzOCIsInMxNiIsInMyNCIsInMzMiIsInM0MCIsInM0OCIsIm5zNjQiLCJzMTZiZSIsInMyNGJlIiwiczMyYmUiLCJzNDBiZSIsInM0OGJlIiwibnM2NGJlIiwiZjMyIiwiZjMyYmUiLCJmNjQiLCJmNjRiZSIsInN0cnVjdCIsInNlcSIsInVuaW9uTGF5b3V0RGlzY3JpbWluYXRvciIsImJsb2IiLCJjc3RyIiwidXRmOCIsImNvbnN0Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/../anchor/node_modules/buffer-layout/lib/Layout.js\n");

/***/ }),

/***/ "(ssr)/../node_modules/buffer-layout/lib/Layout.js":
/*!***************************************************!*\
  !*** ../node_modules/buffer-layout/lib/Layout.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("/* The MIT License (MIT)\n *\n * Copyright 2015-2018 Peter A. Bigot\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n */ /**\n * Support for translating between Buffer instances and JavaScript\n * native types.\n *\n * {@link module:Layout~Layout|Layout} is the basis of a class\n * hierarchy that associates property names with sequences of encoded\n * bytes.\n *\n * Layouts are supported for these scalar (numeric) types:\n * * {@link module:Layout~UInt|Unsigned integers in little-endian\n *   format} with {@link module:Layout.u8|8-bit}, {@link\n *   module:Layout.u16|16-bit}, {@link module:Layout.u24|24-bit},\n *   {@link module:Layout.u32|32-bit}, {@link\n *   module:Layout.u40|40-bit}, and {@link module:Layout.u48|48-bit}\n *   representation ranges;\n * * {@link module:Layout~UIntBE|Unsigned integers in big-endian\n *   format} with {@link module:Layout.u16be|16-bit}, {@link\n *   module:Layout.u24be|24-bit}, {@link module:Layout.u32be|32-bit},\n *   {@link module:Layout.u40be|40-bit}, and {@link\n *   module:Layout.u48be|48-bit} representation ranges;\n * * {@link module:Layout~Int|Signed integers in little-endian\n *   format} with {@link module:Layout.s8|8-bit}, {@link\n *   module:Layout.s16|16-bit}, {@link module:Layout.s24|24-bit},\n *   {@link module:Layout.s32|32-bit}, {@link\n *   module:Layout.s40|40-bit}, and {@link module:Layout.s48|48-bit}\n *   representation ranges;\n * * {@link module:Layout~IntBE|Signed integers in big-endian format}\n *   with {@link module:Layout.s16be|16-bit}, {@link\n *   module:Layout.s24be|24-bit}, {@link module:Layout.s32be|32-bit},\n *   {@link module:Layout.s40be|40-bit}, and {@link\n *   module:Layout.s48be|48-bit} representation ranges;\n * * 64-bit integral values that decode to an exact (if magnitude is\n *   less than 2^53) or nearby integral Number in {@link\n *   module:Layout.nu64|unsigned little-endian}, {@link\n *   module:Layout.nu64be|unsigned big-endian}, {@link\n *   module:Layout.ns64|signed little-endian}, and {@link\n *   module:Layout.ns64be|unsigned big-endian} encodings;\n * * 32-bit floating point values with {@link\n *   module:Layout.f32|little-endian} and {@link\n *   module:Layout.f32be|big-endian} representations;\n * * 64-bit floating point values with {@link\n *   module:Layout.f64|little-endian} and {@link\n *   module:Layout.f64be|big-endian} representations;\n * * {@link module:Layout.const|Constants} that take no space in the\n *   encoded expression.\n *\n * and for these aggregate types:\n * * {@link module:Layout.seq|Sequence}s of instances of a {@link\n *   module:Layout~Layout|Layout}, with JavaScript representation as\n *   an Array and constant or data-dependent {@link\n *   module:Layout~Sequence#count|length};\n * * {@link module:Layout.struct|Structure}s that aggregate a\n *   heterogeneous sequence of {@link module:Layout~Layout|Layout}\n *   instances, with JavaScript representation as an Object;\n * * {@link module:Layout.union|Union}s that support multiple {@link\n *   module:Layout~VariantLayout|variant layouts} over a fixed\n *   (padded) or variable (not padded) span of bytes, using an\n *   unsigned integer at the start of the data or a separate {@link\n *   module:Layout.unionLayoutDiscriminator|layout element} to\n *   determine which layout to use when interpreting the buffer\n *   contents;\n * * {@link module:Layout.bits|BitStructure}s that contain a sequence\n *   of individual {@link\n *   module:Layout~BitStructure#addField|BitField}s packed into an 8,\n *   16, 24, or 32-bit unsigned integer starting at the least- or\n *   most-significant bit;\n * * {@link module:Layout.cstr|C strings} of varying length;\n * * {@link module:Layout.blob|Blobs} of fixed- or variable-{@link\n *   module:Layout~Blob#length|length} raw data.\n *\n * All {@link module:Layout~Layout|Layout} instances are immutable\n * after construction, to prevent internal state from becoming\n * inconsistent.\n *\n * @local Layout\n * @local ExternalLayout\n * @local GreedyCount\n * @local OffsetLayout\n * @local UInt\n * @local UIntBE\n * @local Int\n * @local IntBE\n * @local NearUInt64\n * @local NearUInt64BE\n * @local NearInt64\n * @local NearInt64BE\n * @local Float\n * @local FloatBE\n * @local Double\n * @local DoubleBE\n * @local Sequence\n * @local Structure\n * @local UnionDiscriminator\n * @local UnionLayoutDiscriminator\n * @local Union\n * @local VariantLayout\n * @local BitStructure\n * @local BitField\n * @local Boolean\n * @local Blob\n * @local CString\n * @local Constant\n * @local bindConstructorLayout\n * @module Layout\n * @license MIT\n * @author Peter A. Bigot\n * @see {@link https://github.com/pabigot/buffer-layout|buffer-layout on GitHub}\n */ \n/**\n * Base class for layout objects.\n *\n * **NOTE** This is an abstract base class; you can create instances\n * if it amuses you, but they won't support the {@link\n * Layout#encode|encode} or {@link Layout#decode|decode} functions.\n *\n * @param {Number} span - Initializer for {@link Layout#span|span}.  The\n * parameter must be an integer; a negative value signifies that the\n * span is {@link Layout#getSpan|value-specific}.\n *\n * @param {string} [property] - Initializer for {@link\n * Layout#property|property}.\n *\n * @abstract\n */ class Layout {\n    constructor(span, property){\n        if (!Number.isInteger(span)) {\n            throw new TypeError(\"span must be an integer\");\n        }\n        /** The span of the layout in bytes.\n     *\n     * Positive values are generally expected.\n     *\n     * Zero will only appear in {@link Constant}s and in {@link\n     * Sequence}s where the {@link Sequence#count|count} is zero.\n     *\n     * A negative value indicates that the span is value-specific, and\n     * must be obtained using {@link Layout#getSpan|getSpan}. */ this.span = span;\n        /** The property name used when this layout is represented in an\n     * Object.\n     *\n     * Used only for layouts that {@link Layout#decode|decode} to Object\n     * instances.  If left undefined the span of the unnamed layout will\n     * be treated as padding: it will not be mutated by {@link\n     * Layout#encode|encode} nor represented as a property in the\n     * decoded Object. */ this.property = property;\n    }\n    /** Function to create an Object into which decoded properties will\n   * be written.\n   *\n   * Used only for layouts that {@link Layout#decode|decode} to Object\n   * instances, which means:\n   * * {@link Structure}\n   * * {@link Union}\n   * * {@link VariantLayout}\n   * * {@link BitStructure}\n   *\n   * If left undefined the JavaScript representation of these layouts\n   * will be Object instances.\n   *\n   * See {@link bindConstructorLayout}.\n   */ makeDestinationObject() {\n        return {};\n    }\n    /**\n   * Decode from a Buffer into an JavaScript value.\n   *\n   * @param {Buffer} b - the buffer from which encoded data is read.\n   *\n   * @param {Number} [offset] - the offset at which the encoded data\n   * starts.  If absent a zero offset is inferred.\n   *\n   * @returns {(Number|Array|Object)} - the value of the decoded data.\n   *\n   * @abstract\n   */ decode(b, offset) {\n        throw new Error(\"Layout is abstract\");\n    }\n    /**\n   * Encode a JavaScript value into a Buffer.\n   *\n   * @param {(Number|Array|Object)} src - the value to be encoded into\n   * the buffer.  The type accepted depends on the (sub-)type of {@link\n   * Layout}.\n   *\n   * @param {Buffer} b - the buffer into which encoded data will be\n   * written.\n   *\n   * @param {Number} [offset] - the offset at which the encoded data\n   * starts.  If absent a zero offset is inferred.\n   *\n   * @returns {Number} - the number of bytes encoded, including the\n   * space skipped for internal padding, but excluding data such as\n   * {@link Sequence#count|lengths} when stored {@link\n   * ExternalLayout|externally}.  This is the adjustment to `offset`\n   * producing the offset where data for the next layout would be\n   * written.\n   *\n   * @abstract\n   */ encode(src, b, offset) {\n        throw new Error(\"Layout is abstract\");\n    }\n    /**\n   * Calculate the span of a specific instance of a layout.\n   *\n   * @param {Buffer} b - the buffer that contains an encoded instance.\n   *\n   * @param {Number} [offset] - the offset at which the encoded instance\n   * starts.  If absent a zero offset is inferred.\n   *\n   * @return {Number} - the number of bytes covered by the layout\n   * instance.  If this method is not overridden in a subclass the\n   * definition-time constant {@link Layout#span|span} will be\n   * returned.\n   *\n   * @throws {RangeError} - if the length of the value cannot be\n   * determined.\n   */ getSpan(b, offset) {\n        if (0 > this.span) {\n            throw new RangeError(\"indeterminate span\");\n        }\n        return this.span;\n    }\n    /**\n   * Replicate the layout using a new property.\n   *\n   * This function must be used to get a structurally-equivalent layout\n   * with a different name since all {@link Layout} instances are\n   * immutable.\n   *\n   * **NOTE** This is a shallow copy.  All fields except {@link\n   * Layout#property|property} are strictly equal to the origin layout.\n   *\n   * @param {String} property - the value for {@link\n   * Layout#property|property} in the replica.\n   *\n   * @returns {Layout} - the copy with {@link Layout#property|property}\n   * set to `property`.\n   */ replicate(property) {\n        const rv = Object.create(this.constructor.prototype);\n        Object.assign(rv, this);\n        rv.property = property;\n        return rv;\n    }\n    /**\n   * Create an object from layout properties and an array of values.\n   *\n   * **NOTE** This function returns `undefined` if invoked on a layout\n   * that does not return its value as an Object.  Objects are\n   * returned for things that are a {@link Structure}, which includes\n   * {@link VariantLayout|variant layouts} if they are structures, and\n   * excludes {@link Union}s.  If you want this feature for a union\n   * you must use {@link Union.getVariant|getVariant} to select the\n   * desired layout.\n   *\n   * @param {Array} values - an array of values that correspond to the\n   * default order for properties.  As with {@link Layout#decode|decode}\n   * layout elements that have no property name are skipped when\n   * iterating over the array values.  Only the top-level properties are\n   * assigned; arguments are not assigned to properties of contained\n   * layouts.  Any unused values are ignored.\n   *\n   * @return {(Object|undefined)}\n   */ fromArray(values) {\n        return undefined;\n    }\n}\nexports.Layout = Layout;\n/* Provide text that carries a name (such as for a function that will\n * be throwing an error) annotated with the property of a given layout\n * (such as one for which the value was unacceptable).\n *\n * @ignore */ function nameWithProperty(name, lo) {\n    if (lo.property) {\n        return name + \"[\" + lo.property + \"]\";\n    }\n    return name;\n}\nexports.nameWithProperty = nameWithProperty;\n/**\n * Augment a class so that instances can be encoded/decoded using a\n * given layout.\n *\n * Calling this function couples `Class` with `layout` in several ways:\n *\n * * `Class.layout_` becomes a static member property equal to `layout`;\n * * `layout.boundConstructor_` becomes a static member property equal\n *    to `Class`;\n * * The {@link Layout#makeDestinationObject|makeDestinationObject()}\n *   property of `layout` is set to a function that returns a `new\n *   Class()`;\n * * `Class.decode(b, offset)` becomes a static member function that\n *   delegates to {@link Layout#decode|layout.decode}.  The\n *   synthesized function may be captured and extended.\n * * `Class.prototype.encode(b, offset)` provides an instance member\n *   function that delegates to {@link Layout#encode|layout.encode}\n *   with `src` set to `this`.  The synthesized function may be\n *   captured and extended, but when the extension is invoked `this`\n *   must be explicitly bound to the instance.\n *\n * @param {class} Class - a JavaScript class with a nullary\n * constructor.\n *\n * @param {Layout} layout - the {@link Layout} instance used to encode\n * instances of `Class`.\n */ function bindConstructorLayout(Class, layout) {\n    if (\"function\" !== typeof Class) {\n        throw new TypeError(\"Class must be constructor\");\n    }\n    if (Class.hasOwnProperty(\"layout_\")) {\n        throw new Error(\"Class is already bound to a layout\");\n    }\n    if (!(layout && layout instanceof Layout)) {\n        throw new TypeError(\"layout must be a Layout\");\n    }\n    if (layout.hasOwnProperty(\"boundConstructor_\")) {\n        throw new Error(\"layout is already bound to a constructor\");\n    }\n    Class.layout_ = layout;\n    layout.boundConstructor_ = Class;\n    layout.makeDestinationObject = ()=>new Class();\n    Object.defineProperty(Class.prototype, \"encode\", {\n        value: function(b, offset) {\n            return layout.encode(this, b, offset);\n        },\n        writable: true\n    });\n    Object.defineProperty(Class, \"decode\", {\n        value: function(b, offset) {\n            return layout.decode(b, offset);\n        },\n        writable: true\n    });\n}\nexports.bindConstructorLayout = bindConstructorLayout;\n/**\n * An object that behaves like a layout but does not consume space\n * within its containing layout.\n *\n * This is primarily used to obtain metadata about a member, such as a\n * {@link OffsetLayout} that can provide data about a {@link\n * Layout#getSpan|value-specific span}.\n *\n * **NOTE** This is an abstract base class; you can create instances\n * if it amuses you, but they won't support {@link\n * ExternalLayout#isCount|isCount} or other {@link Layout} functions.\n *\n * @param {Number} span - initializer for {@link Layout#span|span}.\n * The parameter can range from 1 through 6.\n *\n * @param {string} [property] - initializer for {@link\n * Layout#property|property}.\n *\n * @abstract\n * @augments {Layout}\n */ class ExternalLayout extends Layout {\n    /**\n   * Return `true` iff the external layout decodes to an unsigned\n   * integer layout.\n   *\n   * In that case it can be used as the source of {@link\n   * Sequence#count|Sequence counts}, {@link Blob#length|Blob lengths},\n   * or as {@link UnionLayoutDiscriminator#layout|external union\n   * discriminators}.\n   *\n   * @abstract\n   */ isCount() {\n        throw new Error(\"ExternalLayout is abstract\");\n    }\n}\n/**\n * An {@link ExternalLayout} that determines its {@link\n * Layout#decode|value} based on offset into and length of the buffer\n * on which it is invoked.\n *\n * *Factory*: {@link module:Layout.greedy|greedy}\n *\n * @param {Number} [elementSpan] - initializer for {@link\n * GreedyCount#elementSpan|elementSpan}.\n *\n * @param {string} [property] - initializer for {@link\n * Layout#property|property}.\n *\n * @augments {ExternalLayout}\n */ class GreedyCount extends ExternalLayout {\n    constructor(elementSpan, property){\n        if (undefined === elementSpan) {\n            elementSpan = 1;\n        }\n        if (!Number.isInteger(elementSpan) || 0 >= elementSpan) {\n            throw new TypeError(\"elementSpan must be a (positive) integer\");\n        }\n        super(-1, property);\n        /** The layout for individual elements of the sequence.  The value\n     * must be a positive integer.  If not provided, the value will be\n     * 1. */ this.elementSpan = elementSpan;\n    }\n    /** @override */ isCount() {\n        return true;\n    }\n    /** @override */ decode(b, offset) {\n        if (undefined === offset) {\n            offset = 0;\n        }\n        const rem = b.length - offset;\n        return Math.floor(rem / this.elementSpan);\n    }\n    /** @override */ encode(src, b, offset) {\n        return 0;\n    }\n}\n/**\n * An {@link ExternalLayout} that supports accessing a {@link Layout}\n * at a fixed offset from the start of another Layout.  The offset may\n * be before, within, or after the base layout.\n *\n * *Factory*: {@link module:Layout.offset|offset}\n *\n * @param {Layout} layout - initializer for {@link\n * OffsetLayout#layout|layout}, modulo `property`.\n *\n * @param {Number} [offset] - Initializes {@link\n * OffsetLayout#offset|offset}.  Defaults to zero.\n *\n * @param {string} [property] - Optional new property name for a\n * {@link Layout#replicate| replica} of `layout` to be used as {@link\n * OffsetLayout#layout|layout}.  If not provided the `layout` is used\n * unchanged.\n *\n * @augments {Layout}\n */ class OffsetLayout extends ExternalLayout {\n    constructor(layout, offset, property){\n        if (!(layout instanceof Layout)) {\n            throw new TypeError(\"layout must be a Layout\");\n        }\n        if (undefined === offset) {\n            offset = 0;\n        } else if (!Number.isInteger(offset)) {\n            throw new TypeError(\"offset must be integer or undefined\");\n        }\n        super(layout.span, property || layout.property);\n        /** The subordinated layout. */ this.layout = layout;\n        /** The location of {@link OffsetLayout#layout} relative to the\n     * start of another layout.\n     *\n     * The value may be positive or negative, but an error will thrown\n     * if at the point of use it goes outside the span of the Buffer\n     * being accessed.  */ this.offset = offset;\n    }\n    /** @override */ isCount() {\n        return this.layout instanceof UInt || this.layout instanceof UIntBE;\n    }\n    /** @override */ decode(b, offset) {\n        if (undefined === offset) {\n            offset = 0;\n        }\n        return this.layout.decode(b, offset + this.offset);\n    }\n    /** @override */ encode(src, b, offset) {\n        if (undefined === offset) {\n            offset = 0;\n        }\n        return this.layout.encode(src, b, offset + this.offset);\n    }\n}\n/**\n * Represent an unsigned integer in little-endian format.\n *\n * *Factory*: {@link module:Layout.u8|u8}, {@link\n *  module:Layout.u16|u16}, {@link module:Layout.u24|u24}, {@link\n *  module:Layout.u32|u32}, {@link module:Layout.u40|u40}, {@link\n *  module:Layout.u48|u48}\n *\n * @param {Number} span - initializer for {@link Layout#span|span}.\n * The parameter can range from 1 through 6.\n *\n * @param {string} [property] - initializer for {@link\n * Layout#property|property}.\n *\n * @augments {Layout}\n */ class UInt extends Layout {\n    constructor(span, property){\n        super(span, property);\n        if (6 < this.span) {\n            throw new RangeError(\"span must not exceed 6 bytes\");\n        }\n    }\n    /** @override */ decode(b, offset) {\n        if (undefined === offset) {\n            offset = 0;\n        }\n        return b.readUIntLE(offset, this.span);\n    }\n    /** @override */ encode(src, b, offset) {\n        if (undefined === offset) {\n            offset = 0;\n        }\n        b.writeUIntLE(src, offset, this.span);\n        return this.span;\n    }\n}\n/**\n * Represent an unsigned integer in big-endian format.\n *\n * *Factory*: {@link module:Layout.u8be|u8be}, {@link\n * module:Layout.u16be|u16be}, {@link module:Layout.u24be|u24be},\n * {@link module:Layout.u32be|u32be}, {@link\n * module:Layout.u40be|u40be}, {@link module:Layout.u48be|u48be}\n *\n * @param {Number} span - initializer for {@link Layout#span|span}.\n * The parameter can range from 1 through 6.\n *\n * @param {string} [property] - initializer for {@link\n * Layout#property|property}.\n *\n * @augments {Layout}\n */ class UIntBE extends Layout {\n    constructor(span, property){\n        super(span, property);\n        if (6 < this.span) {\n            throw new RangeError(\"span must not exceed 6 bytes\");\n        }\n    }\n    /** @override */ decode(b, offset) {\n        if (undefined === offset) {\n            offset = 0;\n        }\n        return b.readUIntBE(offset, this.span);\n    }\n    /** @override */ encode(src, b, offset) {\n        if (undefined === offset) {\n            offset = 0;\n        }\n        b.writeUIntBE(src, offset, this.span);\n        return this.span;\n    }\n}\n/**\n * Represent a signed integer in little-endian format.\n *\n * *Factory*: {@link module:Layout.s8|s8}, {@link\n *  module:Layout.s16|s16}, {@link module:Layout.s24|s24}, {@link\n *  module:Layout.s32|s32}, {@link module:Layout.s40|s40}, {@link\n *  module:Layout.s48|s48}\n *\n * @param {Number} span - initializer for {@link Layout#span|span}.\n * The parameter can range from 1 through 6.\n *\n * @param {string} [property] - initializer for {@link\n * Layout#property|property}.\n *\n * @augments {Layout}\n */ class Int extends Layout {\n    constructor(span, property){\n        super(span, property);\n        if (6 < this.span) {\n            throw new RangeError(\"span must not exceed 6 bytes\");\n        }\n    }\n    /** @override */ decode(b, offset) {\n        if (undefined === offset) {\n            offset = 0;\n        }\n        return b.readIntLE(offset, this.span);\n    }\n    /** @override */ encode(src, b, offset) {\n        if (undefined === offset) {\n            offset = 0;\n        }\n        b.writeIntLE(src, offset, this.span);\n        return this.span;\n    }\n}\n/**\n * Represent a signed integer in big-endian format.\n *\n * *Factory*: {@link module:Layout.s8be|s8be}, {@link\n * module:Layout.s16be|s16be}, {@link module:Layout.s24be|s24be},\n * {@link module:Layout.s32be|s32be}, {@link\n * module:Layout.s40be|s40be}, {@link module:Layout.s48be|s48be}\n *\n * @param {Number} span - initializer for {@link Layout#span|span}.\n * The parameter can range from 1 through 6.\n *\n * @param {string} [property] - initializer for {@link\n * Layout#property|property}.\n *\n * @augments {Layout}\n */ class IntBE extends Layout {\n    constructor(span, property){\n        super(span, property);\n        if (6 < this.span) {\n            throw new RangeError(\"span must not exceed 6 bytes\");\n        }\n    }\n    /** @override */ decode(b, offset) {\n        if (undefined === offset) {\n            offset = 0;\n        }\n        return b.readIntBE(offset, this.span);\n    }\n    /** @override */ encode(src, b, offset) {\n        if (undefined === offset) {\n            offset = 0;\n        }\n        b.writeIntBE(src, offset, this.span);\n        return this.span;\n    }\n}\nconst V2E32 = Math.pow(2, 32);\n/* True modulus high and low 32-bit words, where low word is always\n * non-negative. */ function divmodInt64(src) {\n    const hi32 = Math.floor(src / V2E32);\n    const lo32 = src - hi32 * V2E32;\n    return {\n        hi32,\n        lo32\n    };\n}\n/* Reconstruct Number from quotient and non-negative remainder */ function roundedInt64(hi32, lo32) {\n    return hi32 * V2E32 + lo32;\n}\n/**\n * Represent an unsigned 64-bit integer in little-endian format when\n * encoded and as a near integral JavaScript Number when decoded.\n *\n * *Factory*: {@link module:Layout.nu64|nu64}\n *\n * **NOTE** Values with magnitude greater than 2^52 may not decode to\n * the exact value of the encoded representation.\n *\n * @augments {Layout}\n */ class NearUInt64 extends Layout {\n    constructor(property){\n        super(8, property);\n    }\n    /** @override */ decode(b, offset) {\n        if (undefined === offset) {\n            offset = 0;\n        }\n        const lo32 = b.readUInt32LE(offset);\n        const hi32 = b.readUInt32LE(offset + 4);\n        return roundedInt64(hi32, lo32);\n    }\n    /** @override */ encode(src, b, offset) {\n        if (undefined === offset) {\n            offset = 0;\n        }\n        const split = divmodInt64(src);\n        b.writeUInt32LE(split.lo32, offset);\n        b.writeUInt32LE(split.hi32, offset + 4);\n        return 8;\n    }\n}\n/**\n * Represent an unsigned 64-bit integer in big-endian format when\n * encoded and as a near integral JavaScript Number when decoded.\n *\n * *Factory*: {@link module:Layout.nu64be|nu64be}\n *\n * **NOTE** Values with magnitude greater than 2^52 may not decode to\n * the exact value of the encoded representation.\n *\n * @augments {Layout}\n */ class NearUInt64BE extends Layout {\n    constructor(property){\n        super(8, property);\n    }\n    /** @override */ decode(b, offset) {\n        if (undefined === offset) {\n            offset = 0;\n        }\n        const hi32 = b.readUInt32BE(offset);\n        const lo32 = b.readUInt32BE(offset + 4);\n        return roundedInt64(hi32, lo32);\n    }\n    /** @override */ encode(src, b, offset) {\n        if (undefined === offset) {\n            offset = 0;\n        }\n        const split = divmodInt64(src);\n        b.writeUInt32BE(split.hi32, offset);\n        b.writeUInt32BE(split.lo32, offset + 4);\n        return 8;\n    }\n}\n/**\n * Represent a signed 64-bit integer in little-endian format when\n * encoded and as a near integral JavaScript Number when decoded.\n *\n * *Factory*: {@link module:Layout.ns64|ns64}\n *\n * **NOTE** Values with magnitude greater than 2^52 may not decode to\n * the exact value of the encoded representation.\n *\n * @augments {Layout}\n */ class NearInt64 extends Layout {\n    constructor(property){\n        super(8, property);\n    }\n    /** @override */ decode(b, offset) {\n        if (undefined === offset) {\n            offset = 0;\n        }\n        const lo32 = b.readUInt32LE(offset);\n        const hi32 = b.readInt32LE(offset + 4);\n        return roundedInt64(hi32, lo32);\n    }\n    /** @override */ encode(src, b, offset) {\n        if (undefined === offset) {\n            offset = 0;\n        }\n        const split = divmodInt64(src);\n        b.writeUInt32LE(split.lo32, offset);\n        b.writeInt32LE(split.hi32, offset + 4);\n        return 8;\n    }\n}\n/**\n * Represent a signed 64-bit integer in big-endian format when\n * encoded and as a near integral JavaScript Number when decoded.\n *\n * *Factory*: {@link module:Layout.ns64be|ns64be}\n *\n * **NOTE** Values with magnitude greater than 2^52 may not decode to\n * the exact value of the encoded representation.\n *\n * @augments {Layout}\n */ class NearInt64BE extends Layout {\n    constructor(property){\n        super(8, property);\n    }\n    /** @override */ decode(b, offset) {\n        if (undefined === offset) {\n            offset = 0;\n        }\n        const hi32 = b.readInt32BE(offset);\n        const lo32 = b.readUInt32BE(offset + 4);\n        return roundedInt64(hi32, lo32);\n    }\n    /** @override */ encode(src, b, offset) {\n        if (undefined === offset) {\n            offset = 0;\n        }\n        const split = divmodInt64(src);\n        b.writeInt32BE(split.hi32, offset);\n        b.writeUInt32BE(split.lo32, offset + 4);\n        return 8;\n    }\n}\n/**\n * Represent a 32-bit floating point number in little-endian format.\n *\n * *Factory*: {@link module:Layout.f32|f32}\n *\n * @param {string} [property] - initializer for {@link\n * Layout#property|property}.\n *\n * @augments {Layout}\n */ class Float extends Layout {\n    constructor(property){\n        super(4, property);\n    }\n    /** @override */ decode(b, offset) {\n        if (undefined === offset) {\n            offset = 0;\n        }\n        return b.readFloatLE(offset);\n    }\n    /** @override */ encode(src, b, offset) {\n        if (undefined === offset) {\n            offset = 0;\n        }\n        b.writeFloatLE(src, offset);\n        return 4;\n    }\n}\n/**\n * Represent a 32-bit floating point number in big-endian format.\n *\n * *Factory*: {@link module:Layout.f32be|f32be}\n *\n * @param {string} [property] - initializer for {@link\n * Layout#property|property}.\n *\n * @augments {Layout}\n */ class FloatBE extends Layout {\n    constructor(property){\n        super(4, property);\n    }\n    /** @override */ decode(b, offset) {\n        if (undefined === offset) {\n            offset = 0;\n        }\n        return b.readFloatBE(offset);\n    }\n    /** @override */ encode(src, b, offset) {\n        if (undefined === offset) {\n            offset = 0;\n        }\n        b.writeFloatBE(src, offset);\n        return 4;\n    }\n}\n/**\n * Represent a 64-bit floating point number in little-endian format.\n *\n * *Factory*: {@link module:Layout.f64|f64}\n *\n * @param {string} [property] - initializer for {@link\n * Layout#property|property}.\n *\n * @augments {Layout}\n */ class Double extends Layout {\n    constructor(property){\n        super(8, property);\n    }\n    /** @override */ decode(b, offset) {\n        if (undefined === offset) {\n            offset = 0;\n        }\n        return b.readDoubleLE(offset);\n    }\n    /** @override */ encode(src, b, offset) {\n        if (undefined === offset) {\n            offset = 0;\n        }\n        b.writeDoubleLE(src, offset);\n        return 8;\n    }\n}\n/**\n * Represent a 64-bit floating point number in big-endian format.\n *\n * *Factory*: {@link module:Layout.f64be|f64be}\n *\n * @param {string} [property] - initializer for {@link\n * Layout#property|property}.\n *\n * @augments {Layout}\n */ class DoubleBE extends Layout {\n    constructor(property){\n        super(8, property);\n    }\n    /** @override */ decode(b, offset) {\n        if (undefined === offset) {\n            offset = 0;\n        }\n        return b.readDoubleBE(offset);\n    }\n    /** @override */ encode(src, b, offset) {\n        if (undefined === offset) {\n            offset = 0;\n        }\n        b.writeDoubleBE(src, offset);\n        return 8;\n    }\n}\n/**\n * Represent a contiguous sequence of a specific layout as an Array.\n *\n * *Factory*: {@link module:Layout.seq|seq}\n *\n * @param {Layout} elementLayout - initializer for {@link\n * Sequence#elementLayout|elementLayout}.\n *\n * @param {(Number|ExternalLayout)} count - initializer for {@link\n * Sequence#count|count}.  The parameter must be either a positive\n * integer or an instance of {@link ExternalLayout}.\n *\n * @param {string} [property] - initializer for {@link\n * Layout#property|property}.\n *\n * @augments {Layout}\n */ class Sequence extends Layout {\n    constructor(elementLayout, count, property){\n        if (!(elementLayout instanceof Layout)) {\n            throw new TypeError(\"elementLayout must be a Layout\");\n        }\n        if (!(count instanceof ExternalLayout && count.isCount() || Number.isInteger(count) && 0 <= count)) {\n            throw new TypeError(\"count must be non-negative integer \" + \"or an unsigned integer ExternalLayout\");\n        }\n        let span = -1;\n        if (!(count instanceof ExternalLayout) && 0 < elementLayout.span) {\n            span = count * elementLayout.span;\n        }\n        super(span, property);\n        /** The layout for individual elements of the sequence. */ this.elementLayout = elementLayout;\n        /** The number of elements in the sequence.\n     *\n     * This will be either a non-negative integer or an instance of\n     * {@link ExternalLayout} for which {@link\n     * ExternalLayout#isCount|isCount()} is `true`. */ this.count = count;\n    }\n    /** @override */ getSpan(b, offset) {\n        if (0 <= this.span) {\n            return this.span;\n        }\n        if (undefined === offset) {\n            offset = 0;\n        }\n        let span = 0;\n        let count = this.count;\n        if (count instanceof ExternalLayout) {\n            count = count.decode(b, offset);\n        }\n        if (0 < this.elementLayout.span) {\n            span = count * this.elementLayout.span;\n        } else {\n            let idx = 0;\n            while(idx < count){\n                span += this.elementLayout.getSpan(b, offset + span);\n                ++idx;\n            }\n        }\n        return span;\n    }\n    /** @override */ decode(b, offset) {\n        if (undefined === offset) {\n            offset = 0;\n        }\n        const rv = [];\n        let i = 0;\n        let count = this.count;\n        if (count instanceof ExternalLayout) {\n            count = count.decode(b, offset);\n        }\n        while(i < count){\n            rv.push(this.elementLayout.decode(b, offset));\n            offset += this.elementLayout.getSpan(b, offset);\n            i += 1;\n        }\n        return rv;\n    }\n    /** Implement {@link Layout#encode|encode} for {@link Sequence}.\n   *\n   * **NOTE** If `src` is shorter than {@link Sequence#count|count} then\n   * the unused space in the buffer is left unchanged.  If `src` is\n   * longer than {@link Sequence#count|count} the unneeded elements are\n   * ignored.\n   *\n   * **NOTE** If {@link Layout#count|count} is an instance of {@link\n   * ExternalLayout} then the length of `src` will be encoded as the\n   * count after `src` is encoded. */ encode(src, b, offset) {\n        if (undefined === offset) {\n            offset = 0;\n        }\n        const elo = this.elementLayout;\n        const span = src.reduce((span, v)=>{\n            return span + elo.encode(v, b, offset + span);\n        }, 0);\n        if (this.count instanceof ExternalLayout) {\n            this.count.encode(src.length, b, offset);\n        }\n        return span;\n    }\n}\n/**\n * Represent a contiguous sequence of arbitrary layout elements as an\n * Object.\n *\n * *Factory*: {@link module:Layout.struct|struct}\n *\n * **NOTE** The {@link Layout#span|span} of the structure is variable\n * if any layout in {@link Structure#fields|fields} has a variable\n * span.  When {@link Layout#encode|encoding} we must have a value for\n * all variable-length fields, or we wouldn't be able to figure out\n * how much space to use for storage.  We can only identify the value\n * for a field when it has a {@link Layout#property|property}.  As\n * such, although a structure may contain both unnamed fields and\n * variable-length fields, it cannot contain an unnamed\n * variable-length field.\n *\n * @param {Layout[]} fields - initializer for {@link\n * Structure#fields|fields}.  An error is raised if this contains a\n * variable-length field for which a {@link Layout#property|property}\n * is not defined.\n *\n * @param {string} [property] - initializer for {@link\n * Layout#property|property}.\n *\n * @param {Boolean} [decodePrefixes] - initializer for {@link\n * Structure#decodePrefixes|property}.\n *\n * @throws {Error} - if `fields` contains an unnamed variable-length\n * layout.\n *\n * @augments {Layout}\n */ class Structure extends Layout {\n    constructor(fields, property, decodePrefixes){\n        if (!(Array.isArray(fields) && fields.reduce((acc, v)=>acc && v instanceof Layout, true))) {\n            throw new TypeError(\"fields must be array of Layout instances\");\n        }\n        if (\"boolean\" === typeof property && undefined === decodePrefixes) {\n            decodePrefixes = property;\n            property = undefined;\n        }\n        /* Verify absence of unnamed variable-length fields. */ for (const fd of fields){\n            if (0 > fd.span && undefined === fd.property) {\n                throw new Error(\"fields cannot contain unnamed variable-length layout\");\n            }\n        }\n        let span = -1;\n        try {\n            span = fields.reduce((span, fd)=>span + fd.getSpan(), 0);\n        } catch (e) {}\n        super(span, property);\n        /** The sequence of {@link Layout} values that comprise the\n     * structure.\n     *\n     * The individual elements need not be the same type, and may be\n     * either scalar or aggregate layouts.  If a member layout leaves\n     * its {@link Layout#property|property} undefined the\n     * corresponding region of the buffer associated with the element\n     * will not be mutated.\n     *\n     * @type {Layout[]} */ this.fields = fields;\n        /** Control behavior of {@link Layout#decode|decode()} given short\n     * buffers.\n     *\n     * In some situations a structure many be extended with additional\n     * fields over time, with older installations providing only a\n     * prefix of the full structure.  If this property is `true`\n     * decoding will accept those buffers and leave subsequent fields\n     * undefined, as long as the buffer ends at a field boundary.\n     * Defaults to `false`. */ this.decodePrefixes = !!decodePrefixes;\n    }\n    /** @override */ getSpan(b, offset) {\n        if (0 <= this.span) {\n            return this.span;\n        }\n        if (undefined === offset) {\n            offset = 0;\n        }\n        let span = 0;\n        try {\n            span = this.fields.reduce((span, fd)=>{\n                const fsp = fd.getSpan(b, offset);\n                offset += fsp;\n                return span + fsp;\n            }, 0);\n        } catch (e) {\n            throw new RangeError(\"indeterminate span\");\n        }\n        return span;\n    }\n    /** @override */ decode(b, offset) {\n        if (undefined === offset) {\n            offset = 0;\n        }\n        const dest = this.makeDestinationObject();\n        for (const fd of this.fields){\n            if (undefined !== fd.property) {\n                dest[fd.property] = fd.decode(b, offset);\n            }\n            offset += fd.getSpan(b, offset);\n            if (this.decodePrefixes && b.length === offset) {\n                break;\n            }\n        }\n        return dest;\n    }\n    /** Implement {@link Layout#encode|encode} for {@link Structure}.\n   *\n   * If `src` is missing a property for a member with a defined {@link\n   * Layout#property|property} the corresponding region of the buffer is\n   * left unmodified. */ encode(src, b, offset) {\n        if (undefined === offset) {\n            offset = 0;\n        }\n        const firstOffset = offset;\n        let lastOffset = 0;\n        let lastWrote = 0;\n        for (const fd of this.fields){\n            let span = fd.span;\n            lastWrote = 0 < span ? span : 0;\n            if (undefined !== fd.property) {\n                const fv = src[fd.property];\n                if (undefined !== fv) {\n                    lastWrote = fd.encode(fv, b, offset);\n                    if (0 > span) {\n                        /* Read the as-encoded span, which is not necessarily the\n             * same as what we wrote. */ span = fd.getSpan(b, offset);\n                    }\n                }\n            }\n            lastOffset = offset;\n            offset += span;\n        }\n        /* Use (lastOffset + lastWrote) instead of offset because the last\n     * item may have had a dynamic length and we don't want to include\n     * the padding between it and the end of the space reserved for\n     * it. */ return lastOffset + lastWrote - firstOffset;\n    }\n    /** @override */ fromArray(values) {\n        const dest = this.makeDestinationObject();\n        for (const fd of this.fields){\n            if (undefined !== fd.property && 0 < values.length) {\n                dest[fd.property] = values.shift();\n            }\n        }\n        return dest;\n    }\n    /**\n   * Get access to the layout of a given property.\n   *\n   * @param {String} property - the structure member of interest.\n   *\n   * @return {Layout} - the layout associated with `property`, or\n   * undefined if there is no such property.\n   */ layoutFor(property) {\n        if (\"string\" !== typeof property) {\n            throw new TypeError(\"property must be string\");\n        }\n        for (const fd of this.fields){\n            if (fd.property === property) {\n                return fd;\n            }\n        }\n    }\n    /**\n   * Get the offset of a structure member.\n   *\n   * @param {String} property - the structure member of interest.\n   *\n   * @return {Number} - the offset in bytes to the start of `property`\n   * within the structure, or undefined if `property` is not a field\n   * within the structure.  If the property is a member but follows a\n   * variable-length structure member a negative number will be\n   * returned.\n   */ offsetOf(property) {\n        if (\"string\" !== typeof property) {\n            throw new TypeError(\"property must be string\");\n        }\n        let offset = 0;\n        for (const fd of this.fields){\n            if (fd.property === property) {\n                return offset;\n            }\n            if (0 > fd.span) {\n                offset = -1;\n            } else if (0 <= offset) {\n                offset += fd.span;\n            }\n        }\n    }\n}\n/**\n * An object that can provide a {@link\n * Union#discriminator|discriminator} API for {@link Union}.\n *\n * **NOTE** This is an abstract base class; you can create instances\n * if it amuses you, but they won't support the {@link\n * UnionDiscriminator#encode|encode} or {@link\n * UnionDiscriminator#decode|decode} functions.\n *\n * @param {string} [property] - Default for {@link\n * UnionDiscriminator#property|property}.\n *\n * @abstract\n */ class UnionDiscriminator {\n    constructor(property){\n        /** The {@link Layout#property|property} to be used when the\n     * discriminator is referenced in isolation (generally when {@link\n     * Union#decode|Union decode} cannot delegate to a specific\n     * variant). */ this.property = property;\n    }\n    /** Analog to {@link Layout#decode|Layout decode} for union discriminators.\n   *\n   * The implementation of this method need not reference the buffer if\n   * variant information is available through other means. */ decode() {\n        throw new Error(\"UnionDiscriminator is abstract\");\n    }\n    /** Analog to {@link Layout#decode|Layout encode} for union discriminators.\n   *\n   * The implementation of this method need not store the value if\n   * variant information is maintained through other means. */ encode() {\n        throw new Error(\"UnionDiscriminator is abstract\");\n    }\n}\n/**\n * An object that can provide a {@link\n * UnionDiscriminator|discriminator API} for {@link Union} using an\n * unsigned integral {@link Layout} instance located either inside or\n * outside the union.\n *\n * @param {ExternalLayout} layout - initializes {@link\n * UnionLayoutDiscriminator#layout|layout}.  Must satisfy {@link\n * ExternalLayout#isCount|isCount()}.\n *\n * @param {string} [property] - Default for {@link\n * UnionDiscriminator#property|property}, superseding the property\n * from `layout`, but defaulting to `variant` if neither `property`\n * nor layout provide a property name.\n *\n * @augments {UnionDiscriminator}\n */ class UnionLayoutDiscriminator extends UnionDiscriminator {\n    constructor(layout, property){\n        if (!(layout instanceof ExternalLayout && layout.isCount())) {\n            throw new TypeError(\"layout must be an unsigned integer ExternalLayout\");\n        }\n        super(property || layout.property || \"variant\");\n        /** The {@link ExternalLayout} used to access the discriminator\n     * value. */ this.layout = layout;\n    }\n    /** Delegate decoding to {@link UnionLayoutDiscriminator#layout|layout}. */ decode(b, offset) {\n        return this.layout.decode(b, offset);\n    }\n    /** Delegate encoding to {@link UnionLayoutDiscriminator#layout|layout}. */ encode(src, b, offset) {\n        return this.layout.encode(src, b, offset);\n    }\n}\n/**\n * Represent any number of span-compatible layouts.\n *\n * *Factory*: {@link module:Layout.union|union}\n *\n * If the union has a {@link Union#defaultLayout|default layout} that\n * layout must have a non-negative {@link Layout#span|span}.  The span\n * of a fixed-span union includes its {@link\n * Union#discriminator|discriminator} if the variant is a {@link\n * Union#usesPrefixDiscriminator|prefix of the union}, plus the span\n * of its {@link Union#defaultLayout|default layout}.\n *\n * If the union does not have a default layout then the encoded span\n * of the union depends on the encoded span of its variant (which may\n * be fixed or variable).\n *\n * {@link VariantLayout#layout|Variant layout}s are added through\n * {@link Union#addVariant|addVariant}.  If the union has a default\n * layout, the span of the {@link VariantLayout#layout|layout\n * contained by the variant} must not exceed the span of the {@link\n * Union#defaultLayout|default layout} (minus the span of a {@link\n * Union#usesPrefixDiscriminator|prefix disriminator}, if used).  The\n * span of the variant will equal the span of the union itself.\n *\n * The variant for a buffer can only be identified from the {@link\n * Union#discriminator|discriminator} {@link\n * UnionDiscriminator#property|property} (in the case of the {@link\n * Union#defaultLayout|default layout}), or by using {@link\n * Union#getVariant|getVariant} and examining the resulting {@link\n * VariantLayout} instance.\n *\n * A variant compatible with a JavaScript object can be identified\n * using {@link Union#getSourceVariant|getSourceVariant}.\n *\n * @param {(UnionDiscriminator|ExternalLayout|Layout)} discr - How to\n * identify the layout used to interpret the union contents.  The\n * parameter must be an instance of {@link UnionDiscriminator}, an\n * {@link ExternalLayout} that satisfies {@link\n * ExternalLayout#isCount|isCount()}, or {@link UInt} (or {@link\n * UIntBE}).  When a non-external layout element is passed the layout\n * appears at the start of the union.  In all cases the (synthesized)\n * {@link UnionDiscriminator} instance is recorded as {@link\n * Union#discriminator|discriminator}.\n *\n * @param {(Layout|null)} defaultLayout - initializer for {@link\n * Union#defaultLayout|defaultLayout}.  If absent defaults to `null`.\n * If `null` there is no default layout: the union has data-dependent\n * length and attempts to decode or encode unrecognized variants will\n * throw an exception.  A {@link Layout} instance must have a\n * non-negative {@link Layout#span|span}, and if it lacks a {@link\n * Layout#property|property} the {@link\n * Union#defaultLayout|defaultLayout} will be a {@link\n * Layout#replicate|replica} with property `content`.\n *\n * @param {string} [property] - initializer for {@link\n * Layout#property|property}.\n *\n * @augments {Layout}\n */ class Union extends Layout {\n    constructor(discr, defaultLayout, property){\n        const upv = discr instanceof UInt || discr instanceof UIntBE;\n        if (upv) {\n            discr = new UnionLayoutDiscriminator(new OffsetLayout(discr));\n        } else if (discr instanceof ExternalLayout && discr.isCount()) {\n            discr = new UnionLayoutDiscriminator(discr);\n        } else if (!(discr instanceof UnionDiscriminator)) {\n            throw new TypeError(\"discr must be a UnionDiscriminator \" + \"or an unsigned integer layout\");\n        }\n        if (undefined === defaultLayout) {\n            defaultLayout = null;\n        }\n        if (!(null === defaultLayout || defaultLayout instanceof Layout)) {\n            throw new TypeError(\"defaultLayout must be null or a Layout\");\n        }\n        if (null !== defaultLayout) {\n            if (0 > defaultLayout.span) {\n                throw new Error(\"defaultLayout must have constant span\");\n            }\n            if (undefined === defaultLayout.property) {\n                defaultLayout = defaultLayout.replicate(\"content\");\n            }\n        }\n        /* The union span can be estimated only if there's a default\n     * layout.  The union spans its default layout, plus any prefix\n     * variant layout.  By construction both layouts, if present, have\n     * non-negative span. */ let span = -1;\n        if (defaultLayout) {\n            span = defaultLayout.span;\n            if (0 <= span && upv) {\n                span += discr.layout.span;\n            }\n        }\n        super(span, property);\n        /** The interface for the discriminator value in isolation.\n     *\n     * This a {@link UnionDiscriminator} either passed to the\n     * constructor or synthesized from the `discr` constructor\n     * argument.  {@link\n     * Union#usesPrefixDiscriminator|usesPrefixDiscriminator} will be\n     * `true` iff the `discr` parameter was a non-offset {@link\n     * Layout} instance. */ this.discriminator = discr;\n        /** `true` if the {@link Union#discriminator|discriminator} is the\n     * first field in the union.\n     *\n     * If `false` the discriminator is obtained from somewhere\n     * else. */ this.usesPrefixDiscriminator = upv;\n        /** The layout for non-discriminator content when the value of the\n     * discriminator is not recognized.\n     *\n     * This is the value passed to the constructor.  It is\n     * structurally equivalent to the second component of {@link\n     * Union#layout|layout} but may have a different property\n     * name. */ this.defaultLayout = defaultLayout;\n        /** A registry of allowed variants.\n     *\n     * The keys are unsigned integers which should be compatible with\n     * {@link Union.discriminator|discriminator}.  The property value\n     * is the corresponding {@link VariantLayout} instances assigned\n     * to this union by {@link Union#addVariant|addVariant}.\n     *\n     * **NOTE** The registry remains mutable so that variants can be\n     * {@link Union#addVariant|added} at any time.  Users should not\n     * manipulate the content of this property. */ this.registry = {};\n        /* Private variable used when invoking getSourceVariant */ let boundGetSourceVariant = this.defaultGetSourceVariant.bind(this);\n        /** Function to infer the variant selected by a source object.\n     *\n     * Defaults to {@link\n     * Union#defaultGetSourceVariant|defaultGetSourceVariant} but may\n     * be overridden using {@link\n     * Union#configGetSourceVariant|configGetSourceVariant}.\n     *\n     * @param {Object} src - as with {@link\n     * Union#defaultGetSourceVariant|defaultGetSourceVariant}.\n     *\n     * @returns {(undefined|VariantLayout)} The default variant\n     * (`undefined`) or first registered variant that uses a property\n     * available in `src`. */ this.getSourceVariant = function(src) {\n            return boundGetSourceVariant(src);\n        };\n        /** Function to override the implementation of {@link\n     * Union#getSourceVariant|getSourceVariant}.\n     *\n     * Use this if the desired variant cannot be identified using the\n     * algorithm of {@link\n     * Union#defaultGetSourceVariant|defaultGetSourceVariant}.\n     *\n     * **NOTE** The provided function will be invoked bound to this\n     * Union instance, providing local access to {@link\n     * Union#registry|registry}.\n     *\n     * @param {Function} gsv - a function that follows the API of\n     * {@link Union#defaultGetSourceVariant|defaultGetSourceVariant}. */ this.configGetSourceVariant = function(gsv) {\n            boundGetSourceVariant = gsv.bind(this);\n        };\n    }\n    /** @override */ getSpan(b, offset) {\n        if (0 <= this.span) {\n            return this.span;\n        }\n        if (undefined === offset) {\n            offset = 0;\n        }\n        /* Default layouts always have non-negative span, so we don't have\n     * one and we have to recognize the variant which will in turn\n     * determine the span. */ const vlo = this.getVariant(b, offset);\n        if (!vlo) {\n            throw new Error(\"unable to determine span for unrecognized variant\");\n        }\n        return vlo.getSpan(b, offset);\n    }\n    /**\n   * Method to infer a registered Union variant compatible with `src`.\n   *\n   * The first satisified rule in the following sequence defines the\n   * return value:\n   * * If `src` has properties matching the Union discriminator and\n   *   the default layout, `undefined` is returned regardless of the\n   *   value of the discriminator property (this ensures the default\n   *   layout will be used);\n   * * If `src` has a property matching the Union discriminator, the\n   *   value of the discriminator identifies a registered variant, and\n   *   either (a) the variant has no layout, or (b) `src` has the\n   *   variant's property, then the variant is returned (because the\n   *   source satisfies the constraints of the variant it identifies);\n   * * If `src` does not have a property matching the Union\n   *   discriminator, but does have a property matching a registered\n   *   variant, then the variant is returned (because the source\n   *   matches a variant without an explicit conflict);\n   * * An error is thrown (because we either can't identify a variant,\n   *   or we were explicitly told the variant but can't satisfy it).\n   *\n   * @param {Object} src - an object presumed to be compatible with\n   * the content of the Union.\n   *\n   * @return {(undefined|VariantLayout)} - as described above.\n   *\n   * @throws {Error} - if `src` cannot be associated with a default or\n   * registered variant.\n   */ defaultGetSourceVariant(src) {\n        if (src.hasOwnProperty(this.discriminator.property)) {\n            if (this.defaultLayout && src.hasOwnProperty(this.defaultLayout.property)) {\n                return undefined;\n            }\n            const vlo = this.registry[src[this.discriminator.property]];\n            if (vlo && (!vlo.layout || src.hasOwnProperty(vlo.property))) {\n                return vlo;\n            }\n        } else {\n            for(const tag in this.registry){\n                const vlo = this.registry[tag];\n                if (src.hasOwnProperty(vlo.property)) {\n                    return vlo;\n                }\n            }\n        }\n        throw new Error(\"unable to infer src variant\");\n    }\n    /** Implement {@link Layout#decode|decode} for {@link Union}.\n   *\n   * If the variant is {@link Union#addVariant|registered} the return\n   * value is an instance of that variant, with no explicit\n   * discriminator.  Otherwise the {@link Union#defaultLayout|default\n   * layout} is used to decode the content. */ decode(b, offset) {\n        if (undefined === offset) {\n            offset = 0;\n        }\n        let dest;\n        const dlo = this.discriminator;\n        const discr = dlo.decode(b, offset);\n        let clo = this.registry[discr];\n        if (undefined === clo) {\n            let contentOffset = 0;\n            clo = this.defaultLayout;\n            if (this.usesPrefixDiscriminator) {\n                contentOffset = dlo.layout.span;\n            }\n            dest = this.makeDestinationObject();\n            dest[dlo.property] = discr;\n            dest[clo.property] = this.defaultLayout.decode(b, offset + contentOffset);\n        } else {\n            dest = clo.decode(b, offset);\n        }\n        return dest;\n    }\n    /** Implement {@link Layout#encode|encode} for {@link Union}.\n   *\n   * This API assumes the `src` object is consistent with the union's\n   * {@link Union#defaultLayout|default layout}.  To encode variants\n   * use the appropriate variant-specific {@link VariantLayout#encode}\n   * method. */ encode(src, b, offset) {\n        if (undefined === offset) {\n            offset = 0;\n        }\n        const vlo = this.getSourceVariant(src);\n        if (undefined === vlo) {\n            const dlo = this.discriminator;\n            const clo = this.defaultLayout;\n            let contentOffset = 0;\n            if (this.usesPrefixDiscriminator) {\n                contentOffset = dlo.layout.span;\n            }\n            dlo.encode(src[dlo.property], b, offset);\n            return contentOffset + clo.encode(src[clo.property], b, offset + contentOffset);\n        }\n        return vlo.encode(src, b, offset);\n    }\n    /** Register a new variant structure within a union.  The newly\n   * created variant is returned.\n   *\n   * @param {Number} variant - initializer for {@link\n   * VariantLayout#variant|variant}.\n   *\n   * @param {Layout} layout - initializer for {@link\n   * VariantLayout#layout|layout}.\n   *\n   * @param {String} property - initializer for {@link\n   * Layout#property|property}.\n   *\n   * @return {VariantLayout} */ addVariant(variant, layout, property) {\n        const rv = new VariantLayout(this, variant, layout, property);\n        this.registry[variant] = rv;\n        return rv;\n    }\n    /**\n   * Get the layout associated with a registered variant.\n   *\n   * If `vb` does not produce a registered variant the function returns\n   * `undefined`.\n   *\n   * @param {(Number|Buffer)} vb - either the variant number, or a\n   * buffer from which the discriminator is to be read.\n   *\n   * @param {Number} offset - offset into `vb` for the start of the\n   * union.  Used only when `vb` is an instance of {Buffer}.\n   *\n   * @return {({VariantLayout}|undefined)}\n   */ getVariant(vb, offset) {\n        let variant = vb;\n        if (Buffer.isBuffer(vb)) {\n            if (undefined === offset) {\n                offset = 0;\n            }\n            variant = this.discriminator.decode(vb, offset);\n        }\n        return this.registry[variant];\n    }\n}\n/**\n * Represent a specific variant within a containing union.\n *\n * **NOTE** The {@link Layout#span|span} of the variant may include\n * the span of the {@link Union#discriminator|discriminator} used to\n * identify it, but values read and written using the variant strictly\n * conform to the content of {@link VariantLayout#layout|layout}.\n *\n * **NOTE** User code should not invoke this constructor directly.  Use\n * the union {@link Union#addVariant|addVariant} helper method.\n *\n * @param {Union} union - initializer for {@link\n * VariantLayout#union|union}.\n *\n * @param {Number} variant - initializer for {@link\n * VariantLayout#variant|variant}.\n *\n * @param {Layout} [layout] - initializer for {@link\n * VariantLayout#layout|layout}.  If absent the variant carries no\n * data.\n *\n * @param {String} [property] - initializer for {@link\n * Layout#property|property}.  Unlike many other layouts, variant\n * layouts normally include a property name so they can be identified\n * within their containing {@link Union}.  The property identifier may\n * be absent only if `layout` is is absent.\n *\n * @augments {Layout}\n */ class VariantLayout extends Layout {\n    constructor(union, variant, layout, property){\n        if (!(union instanceof Union)) {\n            throw new TypeError(\"union must be a Union\");\n        }\n        if (!Number.isInteger(variant) || 0 > variant) {\n            throw new TypeError(\"variant must be a (non-negative) integer\");\n        }\n        if (\"string\" === typeof layout && undefined === property) {\n            property = layout;\n            layout = null;\n        }\n        if (layout) {\n            if (!(layout instanceof Layout)) {\n                throw new TypeError(\"layout must be a Layout\");\n            }\n            if (null !== union.defaultLayout && 0 <= layout.span && layout.span > union.defaultLayout.span) {\n                throw new Error(\"variant span exceeds span of containing union\");\n            }\n            if (\"string\" !== typeof property) {\n                throw new TypeError(\"variant must have a String property\");\n            }\n        }\n        let span = union.span;\n        if (0 > union.span) {\n            span = layout ? layout.span : 0;\n            if (0 <= span && union.usesPrefixDiscriminator) {\n                span += union.discriminator.layout.span;\n            }\n        }\n        super(span, property);\n        /** The {@link Union} to which this variant belongs. */ this.union = union;\n        /** The unsigned integral value identifying this variant within\n     * the {@link Union#discriminator|discriminator} of the containing\n     * union. */ this.variant = variant;\n        /** The {@link Layout} to be used when reading/writing the\n     * non-discriminator part of the {@link\n     * VariantLayout#union|union}.  If `null` the variant carries no\n     * data. */ this.layout = layout || null;\n    }\n    /** @override */ getSpan(b, offset) {\n        if (0 <= this.span) {\n            /* Will be equal to the containing union span if that is not\n       * variable. */ return this.span;\n        }\n        if (undefined === offset) {\n            offset = 0;\n        }\n        let contentOffset = 0;\n        if (this.union.usesPrefixDiscriminator) {\n            contentOffset = this.union.discriminator.layout.span;\n        }\n        /* Span is defined solely by the variant (and prefix discriminator) */ return contentOffset + this.layout.getSpan(b, offset + contentOffset);\n    }\n    /** @override */ decode(b, offset) {\n        const dest = this.makeDestinationObject();\n        if (undefined === offset) {\n            offset = 0;\n        }\n        if (this !== this.union.getVariant(b, offset)) {\n            throw new Error(\"variant mismatch\");\n        }\n        let contentOffset = 0;\n        if (this.union.usesPrefixDiscriminator) {\n            contentOffset = this.union.discriminator.layout.span;\n        }\n        if (this.layout) {\n            dest[this.property] = this.layout.decode(b, offset + contentOffset);\n        } else if (this.property) {\n            dest[this.property] = true;\n        } else if (this.union.usesPrefixDiscriminator) {\n            dest[this.union.discriminator.property] = this.variant;\n        }\n        return dest;\n    }\n    /** @override */ encode(src, b, offset) {\n        if (undefined === offset) {\n            offset = 0;\n        }\n        let contentOffset = 0;\n        if (this.union.usesPrefixDiscriminator) {\n            contentOffset = this.union.discriminator.layout.span;\n        }\n        if (this.layout && !src.hasOwnProperty(this.property)) {\n            throw new TypeError(\"variant lacks property \" + this.property);\n        }\n        this.union.discriminator.encode(this.variant, b, offset);\n        let span = contentOffset;\n        if (this.layout) {\n            this.layout.encode(src[this.property], b, offset + contentOffset);\n            span += this.layout.getSpan(b, offset + contentOffset);\n            if (0 <= this.union.span && span > this.union.span) {\n                throw new Error(\"encoded variant overruns containing union\");\n            }\n        }\n        return span;\n    }\n    /** Delegate {@link Layout#fromArray|fromArray} to {@link\n   * VariantLayout#layout|layout}. */ fromArray(values) {\n        if (this.layout) {\n            return this.layout.fromArray(values);\n        }\n    }\n}\n/** JavaScript chose to define bitwise operations as operating on\n * signed 32-bit values in 2's complement form, meaning any integer\n * with bit 31 set is going to look negative.  For right shifts that's\n * not a problem, because `>>>` is a logical shift, but for every\n * other bitwise operator we have to compensate for possible negative\n * results. */ function fixBitwiseResult(v) {\n    if (0 > v) {\n        v += 0x100000000;\n    }\n    return v;\n}\n/**\n * Contain a sequence of bit fields as an unsigned integer.\n *\n * *Factory*: {@link module:Layout.bits|bits}\n *\n * This is a container element; within it there are {@link BitField}\n * instances that provide the extracted properties.  The container\n * simply defines the aggregate representation and its bit ordering.\n * The representation is an object containing properties with numeric\n * or {@link Boolean} values.\n *\n * {@link BitField}s are added with the {@link\n * BitStructure#addField|addField} and {@link\n * BitStructure#addBoolean|addBoolean} methods.\n\n * @param {Layout} word - initializer for {@link\n * BitStructure#word|word}.  The parameter must be an instance of\n * {@link UInt} (or {@link UIntBE}) that is no more than 4 bytes wide.\n *\n * @param {bool} [msb] - `true` if the bit numbering starts at the\n * most significant bit of the containing word; `false` (default) if\n * it starts at the least significant bit of the containing word.  If\n * the parameter at this position is a string and `property` is\n * `undefined` the value of this argument will instead be used as the\n * value of `property`.\n *\n * @param {string} [property] - initializer for {@link\n * Layout#property|property}.\n *\n * @augments {Layout}\n */ class BitStructure extends Layout {\n    constructor(word, msb, property){\n        if (!(word instanceof UInt || word instanceof UIntBE)) {\n            throw new TypeError(\"word must be a UInt or UIntBE layout\");\n        }\n        if (\"string\" === typeof msb && undefined === property) {\n            property = msb;\n            msb = undefined;\n        }\n        if (4 < word.span) {\n            throw new RangeError(\"word cannot exceed 32 bits\");\n        }\n        super(word.span, property);\n        /** The layout used for the packed value.  {@link BitField}\n     * instances are packed sequentially depending on {@link\n     * BitStructure#msb|msb}. */ this.word = word;\n        /** Whether the bit sequences are packed starting at the most\n     * significant bit growing down (`true`), or the least significant\n     * bit growing up (`false`).\n     *\n     * **NOTE** Regardless of this value, the least significant bit of\n     * any {@link BitField} value is the least significant bit of the\n     * corresponding section of the packed value. */ this.msb = !!msb;\n        /** The sequence of {@link BitField} layouts that comprise the\n     * packed structure.\n     *\n     * **NOTE** The array remains mutable to allow fields to be {@link\n     * BitStructure#addField|added} after construction.  Users should\n     * not manipulate the content of this property.*/ this.fields = [];\n        /* Storage for the value.  Capture a variable instead of using an\n     * instance property because we don't want anything to change the\n     * value without going through the mutator. */ let value = 0;\n        this._packedSetValue = function(v) {\n            value = fixBitwiseResult(v);\n            return this;\n        };\n        this._packedGetValue = function() {\n            return value;\n        };\n    }\n    /** @override */ decode(b, offset) {\n        const dest = this.makeDestinationObject();\n        if (undefined === offset) {\n            offset = 0;\n        }\n        const value = this.word.decode(b, offset);\n        this._packedSetValue(value);\n        for (const fd of this.fields){\n            if (undefined !== fd.property) {\n                dest[fd.property] = fd.decode(value);\n            }\n        }\n        return dest;\n    }\n    /** Implement {@link Layout#encode|encode} for {@link BitStructure}.\n   *\n   * If `src` is missing a property for a member with a defined {@link\n   * Layout#property|property} the corresponding region of the packed\n   * value is left unmodified.  Unused bits are also left unmodified. */ encode(src, b, offset) {\n        if (undefined === offset) {\n            offset = 0;\n        }\n        const value = this.word.decode(b, offset);\n        this._packedSetValue(value);\n        for (const fd of this.fields){\n            if (undefined !== fd.property) {\n                const fv = src[fd.property];\n                if (undefined !== fv) {\n                    fd.encode(fv);\n                }\n            }\n        }\n        return this.word.encode(this._packedGetValue(), b, offset);\n    }\n    /** Register a new bitfield with a containing bit structure.  The\n   * resulting bitfield is returned.\n   *\n   * @param {Number} bits - initializer for {@link BitField#bits|bits}.\n   *\n   * @param {string} property - initializer for {@link\n   * Layout#property|property}.\n   *\n   * @return {BitField} */ addField(bits, property) {\n        const bf = new BitField(this, bits, property);\n        this.fields.push(bf);\n        return bf;\n    }\n    /** As with {@link BitStructure#addField|addField} for single-bit\n   * fields with `boolean` value representation.\n   *\n   * @param {string} property - initializer for {@link\n   * Layout#property|property}.\n   *\n   * @return {Boolean} */ addBoolean(property) {\n        // This is my Boolean, not the Javascript one.\n        // eslint-disable-next-line no-new-wrappers\n        const bf = new Boolean(this, property);\n        this.fields.push(bf);\n        return bf;\n    }\n    /**\n   * Get access to the bit field for a given property.\n   *\n   * @param {String} property - the bit field of interest.\n   *\n   * @return {BitField} - the field associated with `property`, or\n   * undefined if there is no such property.\n   */ fieldFor(property) {\n        if (\"string\" !== typeof property) {\n            throw new TypeError(\"property must be string\");\n        }\n        for (const fd of this.fields){\n            if (fd.property === property) {\n                return fd;\n            }\n        }\n    }\n}\n/**\n * Represent a sequence of bits within a {@link BitStructure}.\n *\n * All bit field values are represented as unsigned integers.\n *\n * **NOTE** User code should not invoke this constructor directly.\n * Use the container {@link BitStructure#addField|addField} helper\n * method.\n *\n * **NOTE** BitField instances are not instances of {@link Layout}\n * since {@link Layout#span|span} measures 8-bit units.\n *\n * @param {BitStructure} container - initializer for {@link\n * BitField#container|container}.\n *\n * @param {Number} bits - initializer for {@link BitField#bits|bits}.\n *\n * @param {string} [property] - initializer for {@link\n * Layout#property|property}.\n */ class BitField {\n    constructor(container, bits, property){\n        if (!(container instanceof BitStructure)) {\n            throw new TypeError(\"container must be a BitStructure\");\n        }\n        if (!Number.isInteger(bits) || 0 >= bits) {\n            throw new TypeError(\"bits must be positive integer\");\n        }\n        const totalBits = 8 * container.span;\n        const usedBits = container.fields.reduce((sum, fd)=>sum + fd.bits, 0);\n        if (bits + usedBits > totalBits) {\n            throw new Error(\"bits too long for span remainder (\" + (totalBits - usedBits) + \" of \" + totalBits + \" remain)\");\n        }\n        /** The {@link BitStructure} instance to which this bit field\n     * belongs. */ this.container = container;\n        /** The span of this value in bits. */ this.bits = bits;\n        /** A mask of {@link BitField#bits|bits} bits isolating value bits\n     * that fit within the field.\n     *\n     * That is, it masks a value that has not yet been shifted into\n     * position within its containing packed integer. */ this.valueMask = (1 << bits) - 1;\n        if (32 === bits) {\n            this.valueMask = 0xFFFFFFFF;\n        }\n        /** The offset of the value within the containing packed unsigned\n     * integer.  The least significant bit of the packed value is at\n     * offset zero, regardless of bit ordering used. */ this.start = usedBits;\n        if (this.container.msb) {\n            this.start = totalBits - usedBits - bits;\n        }\n        /** A mask of {@link BitField#bits|bits} isolating the field value\n     * within the containing packed unsigned integer. */ this.wordMask = fixBitwiseResult(this.valueMask << this.start);\n        /** The property name used when this bitfield is represented in an\n     * Object.\n     *\n     * Intended to be functionally equivalent to {@link\n     * Layout#property}.\n     *\n     * If left undefined the corresponding span of bits will be\n     * treated as padding: it will not be mutated by {@link\n     * Layout#encode|encode} nor represented as a property in the\n     * decoded Object. */ this.property = property;\n    }\n    /** Store a value into the corresponding subsequence of the containing\n   * bit field. */ decode() {\n        const word = this.container._packedGetValue();\n        const wordValue = fixBitwiseResult(word & this.wordMask);\n        const value = wordValue >>> this.start;\n        return value;\n    }\n    /** Store a value into the corresponding subsequence of the containing\n   * bit field.\n   *\n   * **NOTE** This is not a specialization of {@link\n   * Layout#encode|Layout.encode} and there is no return value. */ encode(value) {\n        if (!Number.isInteger(value) || value !== fixBitwiseResult(value & this.valueMask)) {\n            throw new TypeError(nameWithProperty(\"BitField.encode\", this) + \" value must be integer not exceeding \" + this.valueMask);\n        }\n        const word = this.container._packedGetValue();\n        const wordValue = fixBitwiseResult(value << this.start);\n        this.container._packedSetValue(fixBitwiseResult(word & ~this.wordMask) | wordValue);\n    }\n}\n/**\n * Represent a single bit within a {@link BitStructure} as a\n * JavaScript boolean.\n *\n * **NOTE** User code should not invoke this constructor directly.\n * Use the container {@link BitStructure#addBoolean|addBoolean} helper\n * method.\n *\n * @param {BitStructure} container - initializer for {@link\n * BitField#container|container}.\n *\n * @param {string} [property] - initializer for {@link\n * Layout#property|property}.\n *\n * @augments {BitField}\n */ /* eslint-disable no-extend-native */ class Boolean extends BitField {\n    constructor(container, property){\n        super(container, 1, property);\n    }\n    /** Override {@link BitField#decode|decode} for {@link Boolean|Boolean}.\n   *\n   * @returns {boolean} */ decode(b, offset) {\n        return !!BitField.prototype.decode.call(this, b, offset);\n    }\n    /** @override */ encode(value) {\n        if (\"boolean\" === typeof value) {\n            // BitField requires integer values\n            value = +value;\n        }\n        return BitField.prototype.encode.call(this, value);\n    }\n}\n/* eslint-enable no-extend-native */ /**\n * Contain a fixed-length block of arbitrary data, represented as a\n * Buffer.\n *\n * *Factory*: {@link module:Layout.blob|blob}\n *\n * @param {(Number|ExternalLayout)} length - initializes {@link\n * Blob#length|length}.\n *\n * @param {String} [property] - initializer for {@link\n * Layout#property|property}.\n *\n * @augments {Layout}\n */ class Blob extends Layout {\n    constructor(length, property){\n        if (!(length instanceof ExternalLayout && length.isCount() || Number.isInteger(length) && 0 <= length)) {\n            throw new TypeError(\"length must be positive integer \" + \"or an unsigned integer ExternalLayout\");\n        }\n        let span = -1;\n        if (!(length instanceof ExternalLayout)) {\n            span = length;\n        }\n        super(span, property);\n        /** The number of bytes in the blob.\n     *\n     * This may be a non-negative integer, or an instance of {@link\n     * ExternalLayout} that satisfies {@link\n     * ExternalLayout#isCount|isCount()}. */ this.length = length;\n    }\n    /** @override */ getSpan(b, offset) {\n        let span = this.span;\n        if (0 > span) {\n            span = this.length.decode(b, offset);\n        }\n        return span;\n    }\n    /** @override */ decode(b, offset) {\n        if (undefined === offset) {\n            offset = 0;\n        }\n        let span = this.span;\n        if (0 > span) {\n            span = this.length.decode(b, offset);\n        }\n        return b.slice(offset, offset + span);\n    }\n    /** Implement {@link Layout#encode|encode} for {@link Blob}.\n   *\n   * **NOTE** If {@link Layout#count|count} is an instance of {@link\n   * ExternalLayout} then the length of `src` will be encoded as the\n   * count after `src` is encoded. */ encode(src, b, offset) {\n        let span = this.length;\n        if (this.length instanceof ExternalLayout) {\n            span = src.length;\n        }\n        if (!(Buffer.isBuffer(src) && span === src.length)) {\n            throw new TypeError(nameWithProperty(\"Blob.encode\", this) + \" requires (length \" + span + \") Buffer as src\");\n        }\n        if (offset + span > b.length) {\n            throw new RangeError(\"encoding overruns Buffer\");\n        }\n        b.write(src.toString(\"hex\"), offset, span, \"hex\");\n        if (this.length instanceof ExternalLayout) {\n            this.length.encode(span, b, offset);\n        }\n        return span;\n    }\n}\n/**\n * Contain a `NUL`-terminated UTF8 string.\n *\n * *Factory*: {@link module:Layout.cstr|cstr}\n *\n * **NOTE** Any UTF8 string that incorporates a zero-valued byte will\n * not be correctly decoded by this layout.\n *\n * @param {String} [property] - initializer for {@link\n * Layout#property|property}.\n *\n * @augments {Layout}\n */ class CString extends Layout {\n    constructor(property){\n        super(-1, property);\n    }\n    /** @override */ getSpan(b, offset) {\n        if (!Buffer.isBuffer(b)) {\n            throw new TypeError(\"b must be a Buffer\");\n        }\n        if (undefined === offset) {\n            offset = 0;\n        }\n        let idx = offset;\n        while(idx < b.length && 0 !== b[idx]){\n            idx += 1;\n        }\n        return 1 + idx - offset;\n    }\n    /** @override */ decode(b, offset, dest) {\n        if (undefined === offset) {\n            offset = 0;\n        }\n        let span = this.getSpan(b, offset);\n        return b.slice(offset, offset + span - 1).toString(\"utf-8\");\n    }\n    /** @override */ encode(src, b, offset) {\n        if (undefined === offset) {\n            offset = 0;\n        }\n        /* Must force this to a string, lest it be a number and the\n     * \"utf8-encoding\" below actually allocate a buffer of length\n     * src */ if (\"string\" !== typeof src) {\n            src = src.toString();\n        }\n        const srcb = new Buffer(src, \"utf8\");\n        const span = srcb.length;\n        if (offset + span > b.length) {\n            throw new RangeError(\"encoding overruns Buffer\");\n        }\n        srcb.copy(b, offset);\n        b[offset + span] = 0;\n        return span + 1;\n    }\n}\n/**\n * Contain a UTF8 string with implicit length.\n *\n * *Factory*: {@link module:Layout.utf8|utf8}\n *\n * **NOTE** Because the length is implicit in the size of the buffer\n * this layout should be used only in isolation, or in a situation\n * where the length can be expressed by operating on a slice of the\n * containing buffer.\n *\n * @param {Number} [maxSpan] - the maximum length allowed for encoded\n * string content.  If not provided there is no bound on the allowed\n * content.\n *\n * @param {String} [property] - initializer for {@link\n * Layout#property|property}.\n *\n * @augments {Layout}\n */ class UTF8 extends Layout {\n    constructor(maxSpan, property){\n        if (\"string\" === typeof maxSpan && undefined === property) {\n            property = maxSpan;\n            maxSpan = undefined;\n        }\n        if (undefined === maxSpan) {\n            maxSpan = -1;\n        } else if (!Number.isInteger(maxSpan)) {\n            throw new TypeError(\"maxSpan must be an integer\");\n        }\n        super(-1, property);\n        /** The maximum span of the layout in bytes.\n     *\n     * Positive values are generally expected.  Zero is abnormal.\n     * Attempts to encode or decode a value that exceeds this length\n     * will throw a `RangeError`.\n     *\n     * A negative value indicates that there is no bound on the length\n     * of the content. */ this.maxSpan = maxSpan;\n    }\n    /** @override */ getSpan(b, offset) {\n        if (!Buffer.isBuffer(b)) {\n            throw new TypeError(\"b must be a Buffer\");\n        }\n        if (undefined === offset) {\n            offset = 0;\n        }\n        return b.length - offset;\n    }\n    /** @override */ decode(b, offset, dest) {\n        if (undefined === offset) {\n            offset = 0;\n        }\n        let span = this.getSpan(b, offset);\n        if (0 <= this.maxSpan && this.maxSpan < span) {\n            throw new RangeError(\"text length exceeds maxSpan\");\n        }\n        return b.slice(offset, offset + span).toString(\"utf-8\");\n    }\n    /** @override */ encode(src, b, offset) {\n        if (undefined === offset) {\n            offset = 0;\n        }\n        /* Must force this to a string, lest it be a number and the\n     * \"utf8-encoding\" below actually allocate a buffer of length\n     * src */ if (\"string\" !== typeof src) {\n            src = src.toString();\n        }\n        const srcb = new Buffer(src, \"utf8\");\n        const span = srcb.length;\n        if (0 <= this.maxSpan && this.maxSpan < span) {\n            throw new RangeError(\"text length exceeds maxSpan\");\n        }\n        if (offset + span > b.length) {\n            throw new RangeError(\"encoding overruns Buffer\");\n        }\n        srcb.copy(b, offset);\n        return span;\n    }\n}\n/**\n * Contain a constant value.\n *\n * This layout may be used in cases where a JavaScript value can be\n * inferred without an expression in the binary encoding.  An example\n * would be a {@link VariantLayout|variant layout} where the content\n * is implied by the union {@link Union#discriminator|discriminator}.\n *\n * @param {Object|Number|String} value - initializer for {@link\n * Constant#value|value}.  If the value is an object (or array) and\n * the application intends the object to remain unchanged regardless\n * of what is done to values decoded by this layout, the value should\n * be frozen prior passing it to this constructor.\n *\n * @param {String} [property] - initializer for {@link\n * Layout#property|property}.\n *\n * @augments {Layout}\n */ class Constant extends Layout {\n    constructor(value, property){\n        super(0, property);\n        /** The value produced by this constant when the layout is {@link\n     * Constant#decode|decoded}.\n     *\n     * Any JavaScript value including `null` and `undefined` is\n     * permitted.\n     *\n     * **WARNING** If `value` passed in the constructor was not\n     * frozen, it is possible for users of decoded values to change\n     * the content of the value. */ this.value = value;\n    }\n    /** @override */ decode(b, offset, dest) {\n        return this.value;\n    }\n    /** @override */ encode(src, b, offset) {\n        /* Constants take no space */ return 0;\n    }\n}\nexports.ExternalLayout = ExternalLayout;\nexports.GreedyCount = GreedyCount;\nexports.OffsetLayout = OffsetLayout;\nexports.UInt = UInt;\nexports.UIntBE = UIntBE;\nexports.Int = Int;\nexports.IntBE = IntBE;\nexports.Float = Float;\nexports.FloatBE = FloatBE;\nexports.Double = Double;\nexports.DoubleBE = DoubleBE;\nexports.Sequence = Sequence;\nexports.Structure = Structure;\nexports.UnionDiscriminator = UnionDiscriminator;\nexports.UnionLayoutDiscriminator = UnionLayoutDiscriminator;\nexports.Union = Union;\nexports.VariantLayout = VariantLayout;\nexports.BitStructure = BitStructure;\nexports.BitField = BitField;\nexports.Boolean = Boolean;\nexports.Blob = Blob;\nexports.CString = CString;\nexports.UTF8 = UTF8;\nexports.Constant = Constant;\n/** Factory for {@link GreedyCount}. */ exports.greedy = (elementSpan, property)=>new GreedyCount(elementSpan, property);\n/** Factory for {@link OffsetLayout}. */ exports.offset = (layout, offset, property)=>new OffsetLayout(layout, offset, property);\n/** Factory for {@link UInt|unsigned int layouts} spanning one\n * byte. */ exports.u8 = (property)=>new UInt(1, property);\n/** Factory for {@link UInt|little-endian unsigned int layouts}\n * spanning two bytes. */ exports.u16 = (property)=>new UInt(2, property);\n/** Factory for {@link UInt|little-endian unsigned int layouts}\n * spanning three bytes. */ exports.u24 = (property)=>new UInt(3, property);\n/** Factory for {@link UInt|little-endian unsigned int layouts}\n * spanning four bytes. */ exports.u32 = (property)=>new UInt(4, property);\n/** Factory for {@link UInt|little-endian unsigned int layouts}\n * spanning five bytes. */ exports.u40 = (property)=>new UInt(5, property);\n/** Factory for {@link UInt|little-endian unsigned int layouts}\n * spanning six bytes. */ exports.u48 = (property)=>new UInt(6, property);\n/** Factory for {@link NearUInt64|little-endian unsigned int\n * layouts} interpreted as Numbers. */ exports.nu64 = (property)=>new NearUInt64(property);\n/** Factory for {@link UInt|big-endian unsigned int layouts}\n * spanning two bytes. */ exports.u16be = (property)=>new UIntBE(2, property);\n/** Factory for {@link UInt|big-endian unsigned int layouts}\n * spanning three bytes. */ exports.u24be = (property)=>new UIntBE(3, property);\n/** Factory for {@link UInt|big-endian unsigned int layouts}\n * spanning four bytes. */ exports.u32be = (property)=>new UIntBE(4, property);\n/** Factory for {@link UInt|big-endian unsigned int layouts}\n * spanning five bytes. */ exports.u40be = (property)=>new UIntBE(5, property);\n/** Factory for {@link UInt|big-endian unsigned int layouts}\n * spanning six bytes. */ exports.u48be = (property)=>new UIntBE(6, property);\n/** Factory for {@link NearUInt64BE|big-endian unsigned int\n * layouts} interpreted as Numbers. */ exports.nu64be = (property)=>new NearUInt64BE(property);\n/** Factory for {@link Int|signed int layouts} spanning one\n * byte. */ exports.s8 = (property)=>new Int(1, property);\n/** Factory for {@link Int|little-endian signed int layouts}\n * spanning two bytes. */ exports.s16 = (property)=>new Int(2, property);\n/** Factory for {@link Int|little-endian signed int layouts}\n * spanning three bytes. */ exports.s24 = (property)=>new Int(3, property);\n/** Factory for {@link Int|little-endian signed int layouts}\n * spanning four bytes. */ exports.s32 = (property)=>new Int(4, property);\n/** Factory for {@link Int|little-endian signed int layouts}\n * spanning five bytes. */ exports.s40 = (property)=>new Int(5, property);\n/** Factory for {@link Int|little-endian signed int layouts}\n * spanning six bytes. */ exports.s48 = (property)=>new Int(6, property);\n/** Factory for {@link NearInt64|little-endian signed int layouts}\n * interpreted as Numbers. */ exports.ns64 = (property)=>new NearInt64(property);\n/** Factory for {@link Int|big-endian signed int layouts}\n * spanning two bytes. */ exports.s16be = (property)=>new IntBE(2, property);\n/** Factory for {@link Int|big-endian signed int layouts}\n * spanning three bytes. */ exports.s24be = (property)=>new IntBE(3, property);\n/** Factory for {@link Int|big-endian signed int layouts}\n * spanning four bytes. */ exports.s32be = (property)=>new IntBE(4, property);\n/** Factory for {@link Int|big-endian signed int layouts}\n * spanning five bytes. */ exports.s40be = (property)=>new IntBE(5, property);\n/** Factory for {@link Int|big-endian signed int layouts}\n * spanning six bytes. */ exports.s48be = (property)=>new IntBE(6, property);\n/** Factory for {@link NearInt64BE|big-endian signed int layouts}\n * interpreted as Numbers. */ exports.ns64be = (property)=>new NearInt64BE(property);\n/** Factory for {@link Float|little-endian 32-bit floating point} values. */ exports.f32 = (property)=>new Float(property);\n/** Factory for {@link FloatBE|big-endian 32-bit floating point} values. */ exports.f32be = (property)=>new FloatBE(property);\n/** Factory for {@link Double|little-endian 64-bit floating point} values. */ exports.f64 = (property)=>new Double(property);\n/** Factory for {@link DoubleBE|big-endian 64-bit floating point} values. */ exports.f64be = (property)=>new DoubleBE(property);\n/** Factory for {@link Structure} values. */ exports.struct = (fields, property, decodePrefixes)=>new Structure(fields, property, decodePrefixes);\n/** Factory for {@link BitStructure} values. */ exports.bits = (word, msb, property)=>new BitStructure(word, msb, property);\n/** Factory for {@link Sequence} values. */ exports.seq = (elementLayout, count, property)=>new Sequence(elementLayout, count, property);\n/** Factory for {@link Union} values. */ exports.union = (discr, defaultLayout, property)=>new Union(discr, defaultLayout, property);\n/** Factory for {@link UnionLayoutDiscriminator} values. */ exports.unionLayoutDiscriminator = (layout, property)=>new UnionLayoutDiscriminator(layout, property);\n/** Factory for {@link Blob} values. */ exports.blob = (length, property)=>new Blob(length, property);\n/** Factory for {@link CString} values. */ exports.cstr = (property)=>new CString(property);\n/** Factory for {@link UTF8} values. */ exports.utf8 = (maxSpan, property)=>new UTF8(maxSpan, property);\n/** Factory for {@link Constant} values. */ exports[\"const\"] = (value, property)=>new Constant(value, property);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL2J1ZmZlci1sYXlvdXQvbGliL0xheW91dC5qcyIsIm1hcHBpbmdzIjoiQUFBQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0NBcUJDLEdBRUQ7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0NBMkdDLEdBRUQ7QUFFQTs7Ozs7Ozs7Ozs7Ozs7O0NBZUMsR0FDRCxNQUFNQTtJQUNKQyxZQUFZQyxJQUFJLEVBQUVDLFFBQVEsQ0FBRTtRQUMxQixJQUFJLENBQUNDLE9BQU9DLFNBQVMsQ0FBQ0gsT0FBTztZQUMzQixNQUFNLElBQUlJLFVBQVU7UUFDdEI7UUFFQTs7Ozs7Ozs7OERBUTBELEdBQzFELElBQUksQ0FBQ0osSUFBSSxHQUFHQTtRQUVaOzs7Ozs7O3VCQU9tQixHQUNuQixJQUFJLENBQUNDLFFBQVEsR0FBR0E7SUFDbEI7SUFFQTs7Ozs7Ozs7Ozs7Ozs7R0FjQyxHQUNESSx3QkFBd0I7UUFDdEIsT0FBTyxDQUFDO0lBQ1Y7SUFFQTs7Ozs7Ozs7Ozs7R0FXQyxHQUNEQyxPQUFPQyxDQUFDLEVBQUVDLE1BQU0sRUFBRTtRQUNoQixNQUFNLElBQUlDLE1BQU07SUFDbEI7SUFFQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0dBcUJDLEdBQ0RDLE9BQU9DLEdBQUcsRUFBRUosQ0FBQyxFQUFFQyxNQUFNLEVBQUU7UUFDckIsTUFBTSxJQUFJQyxNQUFNO0lBQ2xCO0lBRUE7Ozs7Ozs7Ozs7Ozs7OztHQWVDLEdBQ0RHLFFBQVFMLENBQUMsRUFBRUMsTUFBTSxFQUFFO1FBQ2pCLElBQUksSUFBSSxJQUFJLENBQUNSLElBQUksRUFBRTtZQUNqQixNQUFNLElBQUlhLFdBQVc7UUFDdkI7UUFDQSxPQUFPLElBQUksQ0FBQ2IsSUFBSTtJQUNsQjtJQUVBOzs7Ozs7Ozs7Ozs7Ozs7R0FlQyxHQUNEYyxVQUFV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ZXJIO0FBRXJGLHlEQUF5RCxHQUN6RHNCLGdDQUFnQyxHQUFJLENBQUNNLFFBQVE1QixXQUFhLElBQUlrSCx5QkFBeUJ0RixRQUFRNUI7QUFFL0YscUNBQXFDLEdBQ3JDc0IsWUFBWSxHQUFJLENBQUNrQixRQUFReEMsV0FBYSxJQUFJbUssS0FBSzNILFFBQVF4QztBQUV2RCx3Q0FBd0MsR0FDeENzQixZQUFZLEdBQUl0QixDQUFBQSxXQUFZLElBQUl1SyxRQUFRdks7QUFFeEMscUNBQXFDLEdBQ3JDc0IsWUFBWSxHQUFJLENBQUNxSixTQUFTM0ssV0FBYSxJQUFJMEssS0FBS0MsU0FBUzNLO0FBRXpELHlDQUF5QyxHQUN6Q3NCLGdCQUFhLEdBQUksQ0FBQ1csT0FBT2pDLFdBQWEsSUFBSTRLLFNBQVMzSSxPQUFPakMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL2J1ZmZlci1sYXlvdXQvbGliL0xheW91dC5qcz85MjJlIl0sInNvdXJjZXNDb250ZW50IjpbIi8qIFRoZSBNSVQgTGljZW5zZSAoTUlUKVxuICpcbiAqIENvcHlyaWdodCAyMDE1LTIwMTggUGV0ZXIgQS4gQmlnb3RcbiAqXG4gKiBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG4gKiBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG4gKiBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG4gKiB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG4gKiBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbiAqIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4gKlxuICogVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cbiAqIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuICpcbiAqIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcbiAqIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuICogRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4gKiBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG4gKiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuICogT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTlxuICogVEhFIFNPRlRXQVJFLlxuICovXG5cbi8qKlxuICogU3VwcG9ydCBmb3IgdHJhbnNsYXRpbmcgYmV0d2VlbiBCdWZmZXIgaW5zdGFuY2VzIGFuZCBKYXZhU2NyaXB0XG4gKiBuYXRpdmUgdHlwZXMuXG4gKlxuICoge0BsaW5rIG1vZHVsZTpMYXlvdXR+TGF5b3V0fExheW91dH0gaXMgdGhlIGJhc2lzIG9mIGEgY2xhc3NcbiAqIGhpZXJhcmNoeSB0aGF0IGFzc29jaWF0ZXMgcHJvcGVydHkgbmFtZXMgd2l0aCBzZXF1ZW5jZXMgb2YgZW5jb2RlZFxuICogYnl0ZXMuXG4gKlxuICogTGF5b3V0cyBhcmUgc3VwcG9ydGVkIGZvciB0aGVzZSBzY2FsYXIgKG51bWVyaWMpIHR5cGVzOlxuICogKiB7QGxpbmsgbW9kdWxlOkxheW91dH5VSW50fFVuc2lnbmVkIGludGVnZXJzIGluIGxpdHRsZS1lbmRpYW5cbiAqICAgZm9ybWF0fSB3aXRoIHtAbGluayBtb2R1bGU6TGF5b3V0LnU4fDgtYml0fSwge0BsaW5rXG4gKiAgIG1vZHVsZTpMYXlvdXQudTE2fDE2LWJpdH0sIHtAbGluayBtb2R1bGU6TGF5b3V0LnUyNHwyNC1iaXR9LFxuICogICB7QGxpbmsgbW9kdWxlOkxheW91dC51MzJ8MzItYml0fSwge0BsaW5rXG4gKiAgIG1vZHVsZTpMYXlvdXQudTQwfDQwLWJpdH0sIGFuZCB7QGxpbmsgbW9kdWxlOkxheW91dC51NDh8NDgtYml0fVxuICogICByZXByZXNlbnRhdGlvbiByYW5nZXM7XG4gKiAqIHtAbGluayBtb2R1bGU6TGF5b3V0flVJbnRCRXxVbnNpZ25lZCBpbnRlZ2VycyBpbiBiaWctZW5kaWFuXG4gKiAgIGZvcm1hdH0gd2l0aCB7QGxpbmsgbW9kdWxlOkxheW91dC51MTZiZXwxNi1iaXR9LCB7QGxpbmtcbiAqICAgbW9kdWxlOkxheW91dC51MjRiZXwyNC1iaXR9LCB7QGxpbmsgbW9kdWxlOkxheW91dC51MzJiZXwzMi1iaXR9LFxuICogICB7QGxpbmsgbW9kdWxlOkxheW91dC51NDBiZXw0MC1iaXR9LCBhbmQge0BsaW5rXG4gKiAgIG1vZHVsZTpMYXlvdXQudTQ4YmV8NDgtYml0fSByZXByZXNlbnRhdGlvbiByYW5nZXM7XG4gKiAqIHtAbGluayBtb2R1bGU6TGF5b3V0fkludHxTaWduZWQgaW50ZWdlcnMgaW4gbGl0dGxlLWVuZGlhblxuICogICBmb3JtYXR9IHdpdGgge0BsaW5rIG1vZHVsZTpMYXlvdXQuczh8OC1iaXR9LCB7QGxpbmtcbiAqICAgbW9kdWxlOkxheW91dC5zMTZ8MTYtYml0fSwge0BsaW5rIG1vZHVsZTpMYXlvdXQuczI0fDI0LWJpdH0sXG4gKiAgIHtAbGluayBtb2R1bGU6TGF5b3V0LnMzMnwzMi1iaXR9LCB7QGxpbmtcbiAqICAgbW9kdWxlOkxheW91dC5zNDB8NDAtYml0fSwgYW5kIHtAbGluayBtb2R1bGU6TGF5b3V0LnM0OHw0OC1iaXR9XG4gKiAgIHJlcHJlc2VudGF0aW9uIHJhbmdlcztcbiAqICoge0BsaW5rIG1vZHVsZTpMYXlvdXR+SW50QkV8U2lnbmVkIGludGVnZXJzIGluIGJpZy1lbmRpYW4gZm9ybWF0fVxuICogICB3aXRoIHtAbGluayBtb2R1bGU6TGF5b3V0LnMxNmJlfDE2LWJpdH0sIHtAbGlua1xuICogICBtb2R1bGU6TGF5b3V0LnMyNGJlfDI0LWJpdH0sIHtAbGluayBtb2R1bGU6TGF5b3V0LnMzMmJlfDMyLWJpdH0sXG4gKiAgIHtAbGluayBtb2R1bGU6TGF5b3V0LnM0MGJlfDQwLWJpdH0sIGFuZCB7QGxpbmtcbiAqICAgbW9kdWxlOkxheW91dC5zNDhiZXw0OC1iaXR9IHJlcHJlc2VudGF0aW9uIHJhbmdlcztcbiAqICogNjQtYml0IGludGVncmFsIHZhbHVlcyB0aGF0IGRlY29kZSB0byBhbiBleGFjdCAoaWYgbWFnbml0dWRlIGlzXG4gKiAgIGxlc3MgdGhhbiAyXjUzKSBvciBuZWFyYnkgaW50ZWdyYWwgTnVtYmVyIGluIHtAbGlua1xuICogICBtb2R1bGU6TGF5b3V0Lm51NjR8dW5zaWduZWQgbGl0dGxlLWVuZGlhbn0sIHtAbGlua1xuICogICBtb2R1bGU6TGF5b3V0Lm51NjRiZXx1bnNpZ25lZCBiaWctZW5kaWFufSwge0BsaW5rXG4gKiAgIG1vZHVsZTpMYXlvdXQubnM2NHxzaWduZWQgbGl0dGxlLWVuZGlhbn0sIGFuZCB7QGxpbmtcbiAqICAgbW9kdWxlOkxheW91dC5uczY0YmV8dW5zaWduZWQgYmlnLWVuZGlhbn0gZW5jb2RpbmdzO1xuICogKiAzMi1iaXQgZmxvYXRpbmcgcG9pbnQgdmFsdWVzIHdpdGgge0BsaW5rXG4gKiAgIG1vZHVsZTpMYXlvdXQuZjMyfGxpdHRsZS1lbmRpYW59IGFuZCB7QGxpbmtcbiAqICAgbW9kdWxlOkxheW91dC5mMzJiZXxiaWctZW5kaWFufSByZXByZXNlbnRhdGlvbnM7XG4gKiAqIDY0LWJpdCBmbG9hdGluZyBwb2ludCB2YWx1ZXMgd2l0aCB7QGxpbmtcbiAqICAgbW9kdWxlOkxheW91dC5mNjR8bGl0dGxlLWVuZGlhbn0gYW5kIHtAbGlua1xuICogICBtb2R1bGU6TGF5b3V0LmY2NGJlfGJpZy1lbmRpYW59IHJlcHJlc2VudGF0aW9ucztcbiAqICoge0BsaW5rIG1vZHVsZTpMYXlvdXQuY29uc3R8Q29uc3RhbnRzfSB0aGF0IHRha2Ugbm8gc3BhY2UgaW4gdGhlXG4gKiAgIGVuY29kZWQgZXhwcmVzc2lvbi5cbiAqXG4gKiBhbmQgZm9yIHRoZXNlIGFnZ3JlZ2F0ZSB0eXBlczpcbiAqICoge0BsaW5rIG1vZHVsZTpMYXlvdXQuc2VxfFNlcXVlbmNlfXMgb2YgaW5zdGFuY2VzIG9mIGEge0BsaW5rXG4gKiAgIG1vZHVsZTpMYXlvdXR+TGF5b3V0fExheW91dH0sIHdpdGggSmF2YVNjcmlwdCByZXByZXNlbnRhdGlvbiBhc1xuICogICBhbiBBcnJheSBhbmQgY29uc3RhbnQgb3IgZGF0YS1kZXBlbmRlbnQge0BsaW5rXG4gKiAgIG1vZHVsZTpMYXlvdXR+U2VxdWVuY2UjY291bnR8bGVuZ3RofTtcbiAqICoge0BsaW5rIG1vZHVsZTpMYXlvdXQuc3RydWN0fFN0cnVjdHVyZX1zIHRoYXQgYWdncmVnYXRlIGFcbiAqICAgaGV0ZXJvZ2VuZW91cyBzZXF1ZW5jZSBvZiB7QGxpbmsgbW9kdWxlOkxheW91dH5MYXlvdXR8TGF5b3V0fVxuICogICBpbnN0YW5jZXMsIHdpdGggSmF2YVNjcmlwdCByZXByZXNlbnRhdGlvbiBhcyBhbiBPYmplY3Q7XG4gKiAqIHtAbGluayBtb2R1bGU6TGF5b3V0LnVuaW9ufFVuaW9ufXMgdGhhdCBzdXBwb3J0IG11bHRpcGxlIHtAbGlua1xuICogICBtb2R1bGU6TGF5b3V0flZhcmlhbnRMYXlvdXR8dmFyaWFudCBsYXlvdXRzfSBvdmVyIGEgZml4ZWRcbiAqICAgKHBhZGRlZCkgb3IgdmFyaWFibGUgKG5vdCBwYWRkZWQpIHNwYW4gb2YgYnl0ZXMsIHVzaW5nIGFuXG4gKiAgIHVuc2lnbmVkIGludGVnZXIgYXQgdGhlIHN0YXJ0IG9mIHRoZSBkYXRhIG9yIGEgc2VwYXJhdGUge0BsaW5rXG4gKiAgIG1vZHVsZTpMYXlvdXQudW5pb25MYXlvdXREaXNjcmltaW5hdG9yfGxheW91dCBlbGVtZW50fSB0b1xuICogICBkZXRlcm1pbmUgd2hpY2ggbGF5b3V0IHRvIHVzZSB3aGVuIGludGVycHJldGluZyB0aGUgYnVmZmVyXG4gKiAgIGNvbnRlbnRzO1xuICogKiB7QGxpbmsgbW9kdWxlOkxheW91dC5iaXRzfEJpdFN0cnVjdHVyZX1zIHRoYXQgY29udGFpbiBhIHNlcXVlbmNlXG4gKiAgIG9mIGluZGl2aWR1YWwge0BsaW5rXG4gKiAgIG1vZHVsZTpMYXlvdXR+Qml0U3RydWN0dXJlI2FkZEZpZWxkfEJpdEZpZWxkfXMgcGFja2VkIGludG8gYW4gOCxcbiAqICAgMTYsIDI0LCBvciAzMi1iaXQgdW5zaWduZWQgaW50ZWdlciBzdGFydGluZyBhdCB0aGUgbGVhc3QtIG9yXG4gKiAgIG1vc3Qtc2lnbmlmaWNhbnQgYml0O1xuICogKiB7QGxpbmsgbW9kdWxlOkxheW91dC5jc3RyfEMgc3RyaW5nc30gb2YgdmFyeWluZyBsZW5ndGg7XG4gKiAqIHtAbGluayBtb2R1bGU6TGF5b3V0LmJsb2J8QmxvYnN9IG9mIGZpeGVkLSBvciB2YXJpYWJsZS17QGxpbmtcbiAqICAgbW9kdWxlOkxheW91dH5CbG9iI2xlbmd0aHxsZW5ndGh9IHJhdyBkYXRhLlxuICpcbiAqIEFsbCB7QGxpbmsgbW9kdWxlOkxheW91dH5MYXlvdXR8TGF5b3V0fSBpbnN0YW5jZXMgYXJlIGltbXV0YWJsZVxuICogYWZ0ZXIgY29uc3RydWN0aW9uLCB0byBwcmV2ZW50IGludGVybmFsIHN0YXRlIGZyb20gYmVjb21pbmdcbiAqIGluY29uc2lzdGVudC5cbiAqXG4gKiBAbG9jYWwgTGF5b3V0XG4gKiBAbG9jYWwgRXh0ZXJuYWxMYXlvdXRcbiAqIEBsb2NhbCBHcmVlZHlDb3VudFxuICogQGxvY2FsIE9mZnNldExheW91dFxuICogQGxvY2FsIFVJbnRcbiAqIEBsb2NhbCBVSW50QkVcbiAqIEBsb2NhbCBJbnRcbiAqIEBsb2NhbCBJbnRCRVxuICogQGxvY2FsIE5lYXJVSW50NjRcbiAqIEBsb2NhbCBOZWFyVUludDY0QkVcbiAqIEBsb2NhbCBOZWFySW50NjRcbiAqIEBsb2NhbCBOZWFySW50NjRCRVxuICogQGxvY2FsIEZsb2F0XG4gKiBAbG9jYWwgRmxvYXRCRVxuICogQGxvY2FsIERvdWJsZVxuICogQGxvY2FsIERvdWJsZUJFXG4gKiBAbG9jYWwgU2VxdWVuY2VcbiAqIEBsb2NhbCBTdHJ1Y3R1cmVcbiAqIEBsb2NhbCBVbmlvbkRpc2NyaW1pbmF0b3JcbiAqIEBsb2NhbCBVbmlvbkxheW91dERpc2NyaW1pbmF0b3JcbiAqIEBsb2NhbCBVbmlvblxuICogQGxvY2FsIFZhcmlhbnRMYXlvdXRcbiAqIEBsb2NhbCBCaXRTdHJ1Y3R1cmVcbiAqIEBsb2NhbCBCaXRGaWVsZFxuICogQGxvY2FsIEJvb2xlYW5cbiAqIEBsb2NhbCBCbG9iXG4gKiBAbG9jYWwgQ1N0cmluZ1xuICogQGxvY2FsIENvbnN0YW50XG4gKiBAbG9jYWwgYmluZENvbnN0cnVjdG9yTGF5b3V0XG4gKiBAbW9kdWxlIExheW91dFxuICogQGxpY2Vuc2UgTUlUXG4gKiBAYXV0aG9yIFBldGVyIEEuIEJpZ290XG4gKiBAc2VlIHtAbGluayBodHRwczovL2dpdGh1Yi5jb20vcGFiaWdvdC9idWZmZXItbGF5b3V0fGJ1ZmZlci1sYXlvdXQgb24gR2l0SHVifVxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBCYXNlIGNsYXNzIGZvciBsYXlvdXQgb2JqZWN0cy5cbiAqXG4gKiAqKk5PVEUqKiBUaGlzIGlzIGFuIGFic3RyYWN0IGJhc2UgY2xhc3M7IHlvdSBjYW4gY3JlYXRlIGluc3RhbmNlc1xuICogaWYgaXQgYW11c2VzIHlvdSwgYnV0IHRoZXkgd29uJ3Qgc3VwcG9ydCB0aGUge0BsaW5rXG4gKiBMYXlvdXQjZW5jb2RlfGVuY29kZX0gb3Ige0BsaW5rIExheW91dCNkZWNvZGV8ZGVjb2RlfSBmdW5jdGlvbnMuXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IHNwYW4gLSBJbml0aWFsaXplciBmb3Ige0BsaW5rIExheW91dCNzcGFufHNwYW59LiAgVGhlXG4gKiBwYXJhbWV0ZXIgbXVzdCBiZSBhbiBpbnRlZ2VyOyBhIG5lZ2F0aXZlIHZhbHVlIHNpZ25pZmllcyB0aGF0IHRoZVxuICogc3BhbiBpcyB7QGxpbmsgTGF5b3V0I2dldFNwYW58dmFsdWUtc3BlY2lmaWN9LlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBbcHJvcGVydHldIC0gSW5pdGlhbGl6ZXIgZm9yIHtAbGlua1xuICogTGF5b3V0I3Byb3BlcnR5fHByb3BlcnR5fS5cbiAqXG4gKiBAYWJzdHJhY3RcbiAqL1xuY2xhc3MgTGF5b3V0IHtcbiAgY29uc3RydWN0b3Ioc3BhbiwgcHJvcGVydHkpIHtcbiAgICBpZiAoIU51bWJlci5pc0ludGVnZXIoc3BhbikpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ3NwYW4gbXVzdCBiZSBhbiBpbnRlZ2VyJyk7XG4gICAgfVxuXG4gICAgLyoqIFRoZSBzcGFuIG9mIHRoZSBsYXlvdXQgaW4gYnl0ZXMuXG4gICAgICpcbiAgICAgKiBQb3NpdGl2ZSB2YWx1ZXMgYXJlIGdlbmVyYWxseSBleHBlY3RlZC5cbiAgICAgKlxuICAgICAqIFplcm8gd2lsbCBvbmx5IGFwcGVhciBpbiB7QGxpbmsgQ29uc3RhbnR9cyBhbmQgaW4ge0BsaW5rXG4gICAgICogU2VxdWVuY2V9cyB3aGVyZSB0aGUge0BsaW5rIFNlcXVlbmNlI2NvdW50fGNvdW50fSBpcyB6ZXJvLlxuICAgICAqXG4gICAgICogQSBuZWdhdGl2ZSB2YWx1ZSBpbmRpY2F0ZXMgdGhhdCB0aGUgc3BhbiBpcyB2YWx1ZS1zcGVjaWZpYywgYW5kXG4gICAgICogbXVzdCBiZSBvYnRhaW5lZCB1c2luZyB7QGxpbmsgTGF5b3V0I2dldFNwYW58Z2V0U3Bhbn0uICovXG4gICAgdGhpcy5zcGFuID0gc3BhbjtcblxuICAgIC8qKiBUaGUgcHJvcGVydHkgbmFtZSB1c2VkIHdoZW4gdGhpcyBsYXlvdXQgaXMgcmVwcmVzZW50ZWQgaW4gYW5cbiAgICAgKiBPYmplY3QuXG4gICAgICpcbiAgICAgKiBVc2VkIG9ubHkgZm9yIGxheW91dHMgdGhhdCB7QGxpbmsgTGF5b3V0I2RlY29kZXxkZWNvZGV9IHRvIE9iamVjdFxuICAgICAqIGluc3RhbmNlcy4gIElmIGxlZnQgdW5kZWZpbmVkIHRoZSBzcGFuIG9mIHRoZSB1bm5hbWVkIGxheW91dCB3aWxsXG4gICAgICogYmUgdHJlYXRlZCBhcyBwYWRkaW5nOiBpdCB3aWxsIG5vdCBiZSBtdXRhdGVkIGJ5IHtAbGlua1xuICAgICAqIExheW91dCNlbmNvZGV8ZW5jb2RlfSBub3IgcmVwcmVzZW50ZWQgYXMgYSBwcm9wZXJ0eSBpbiB0aGVcbiAgICAgKiBkZWNvZGVkIE9iamVjdC4gKi9cbiAgICB0aGlzLnByb3BlcnR5ID0gcHJvcGVydHk7XG4gIH1cblxuICAvKiogRnVuY3Rpb24gdG8gY3JlYXRlIGFuIE9iamVjdCBpbnRvIHdoaWNoIGRlY29kZWQgcHJvcGVydGllcyB3aWxsXG4gICAqIGJlIHdyaXR0ZW4uXG4gICAqXG4gICAqIFVzZWQgb25seSBmb3IgbGF5b3V0cyB0aGF0IHtAbGluayBMYXlvdXQjZGVjb2RlfGRlY29kZX0gdG8gT2JqZWN0XG4gICAqIGluc3RhbmNlcywgd2hpY2ggbWVhbnM6XG4gICAqICoge0BsaW5rIFN0cnVjdHVyZX1cbiAgICogKiB7QGxpbmsgVW5pb259XG4gICAqICoge0BsaW5rIFZhcmlhbnRMYXlvdXR9XG4gICAqICoge0BsaW5rIEJpdFN0cnVjdHVyZX1cbiAgICpcbiAgICogSWYgbGVmdCB1bmRlZmluZWQgdGhlIEphdmFTY3JpcHQgcmVwcmVzZW50YXRpb24gb2YgdGhlc2UgbGF5b3V0c1xuICAgKiB3aWxsIGJlIE9iamVjdCBpbnN0YW5jZXMuXG4gICAqXG4gICAqIFNlZSB7QGxpbmsgYmluZENvbnN0cnVjdG9yTGF5b3V0fS5cbiAgICovXG4gIG1ha2VEZXN0aW5hdGlvbk9iamVjdCgpIHtcbiAgICByZXR1cm4ge307XG4gIH1cblxuICAvKipcbiAgICogRGVjb2RlIGZyb20gYSBCdWZmZXIgaW50byBhbiBKYXZhU2NyaXB0IHZhbHVlLlxuICAgKlxuICAgKiBAcGFyYW0ge0J1ZmZlcn0gYiAtIHRoZSBidWZmZXIgZnJvbSB3aGljaCBlbmNvZGVkIGRhdGEgaXMgcmVhZC5cbiAgICpcbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtvZmZzZXRdIC0gdGhlIG9mZnNldCBhdCB3aGljaCB0aGUgZW5jb2RlZCBkYXRhXG4gICAqIHN0YXJ0cy4gIElmIGFic2VudCBhIHplcm8gb2Zmc2V0IGlzIGluZmVycmVkLlxuICAgKlxuICAgKiBAcmV0dXJucyB7KE51bWJlcnxBcnJheXxPYmplY3QpfSAtIHRoZSB2YWx1ZSBvZiB0aGUgZGVjb2RlZCBkYXRhLlxuICAgKlxuICAgKiBAYWJzdHJhY3RcbiAgICovXG4gIGRlY29kZShiLCBvZmZzZXQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0xheW91dCBpcyBhYnN0cmFjdCcpO1xuICB9XG5cbiAgLyoqXG4gICAqIEVuY29kZSBhIEphdmFTY3JpcHQgdmFsdWUgaW50byBhIEJ1ZmZlci5cbiAgICpcbiAgICogQHBhcmFtIHsoTnVtYmVyfEFycmF5fE9iamVjdCl9IHNyYyAtIHRoZSB2YWx1ZSB0byBiZSBlbmNvZGVkIGludG9cbiAgICogdGhlIGJ1ZmZlci4gIFRoZSB0eXBlIGFjY2VwdGVkIGRlcGVuZHMgb24gdGhlIChzdWItKXR5cGUgb2Yge0BsaW5rXG4gICAqIExheW91dH0uXG4gICAqXG4gICAqIEBwYXJhbSB7QnVmZmVyfSBiIC0gdGhlIGJ1ZmZlciBpbnRvIHdoaWNoIGVuY29kZWQgZGF0YSB3aWxsIGJlXG4gICAqIHdyaXR0ZW4uXG4gICAqXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbb2Zmc2V0XSAtIHRoZSBvZmZzZXQgYXQgd2hpY2ggdGhlIGVuY29kZWQgZGF0YVxuICAgKiBzdGFydHMuICBJZiBhYnNlbnQgYSB6ZXJvIG9mZnNldCBpcyBpbmZlcnJlZC5cbiAgICpcbiAgICogQHJldHVybnMge051bWJlcn0gLSB0aGUgbnVtYmVyIG9mIGJ5dGVzIGVuY29kZWQsIGluY2x1ZGluZyB0aGVcbiAgICogc3BhY2Ugc2tpcHBlZCBmb3IgaW50ZXJuYWwgcGFkZGluZywgYnV0IGV4Y2x1ZGluZyBkYXRhIHN1Y2ggYXNcbiAgICoge0BsaW5rIFNlcXVlbmNlI2NvdW50fGxlbmd0aHN9IHdoZW4gc3RvcmVkIHtAbGlua1xuICAgKiBFeHRlcm5hbExheW91dHxleHRlcm5hbGx5fS4gIFRoaXMgaXMgdGhlIGFkanVzdG1lbnQgdG8gYG9mZnNldGBcbiAgICogcHJvZHVjaW5nIHRoZSBvZmZzZXQgd2hlcmUgZGF0YSBmb3IgdGhlIG5leHQgbGF5b3V0IHdvdWxkIGJlXG4gICAqIHdyaXR0ZW4uXG4gICAqXG4gICAqIEBhYnN0cmFjdFxuICAgKi9cbiAgZW5jb2RlKHNyYywgYiwgb2Zmc2V0KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdMYXlvdXQgaXMgYWJzdHJhY3QnKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDYWxjdWxhdGUgdGhlIHNwYW4gb2YgYSBzcGVjaWZpYyBpbnN0YW5jZSBvZiBhIGxheW91dC5cbiAgICpcbiAgICogQHBhcmFtIHtCdWZmZXJ9IGIgLSB0aGUgYnVmZmVyIHRoYXQgY29udGFpbnMgYW4gZW5jb2RlZCBpbnN0YW5jZS5cbiAgICpcbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtvZmZzZXRdIC0gdGhlIG9mZnNldCBhdCB3aGljaCB0aGUgZW5jb2RlZCBpbnN0YW5jZVxuICAgKiBzdGFydHMuICBJZiBhYnNlbnQgYSB6ZXJvIG9mZnNldCBpcyBpbmZlcnJlZC5cbiAgICpcbiAgICogQHJldHVybiB7TnVtYmVyfSAtIHRoZSBudW1iZXIgb2YgYnl0ZXMgY292ZXJlZCBieSB0aGUgbGF5b3V0XG4gICAqIGluc3RhbmNlLiAgSWYgdGhpcyBtZXRob2QgaXMgbm90IG92ZXJyaWRkZW4gaW4gYSBzdWJjbGFzcyB0aGVcbiAgICogZGVmaW5pdGlvbi10aW1lIGNvbnN0YW50IHtAbGluayBMYXlvdXQjc3BhbnxzcGFufSB3aWxsIGJlXG4gICAqIHJldHVybmVkLlxuICAgKlxuICAgKiBAdGhyb3dzIHtSYW5nZUVycm9yfSAtIGlmIHRoZSBsZW5ndGggb2YgdGhlIHZhbHVlIGNhbm5vdCBiZVxuICAgKiBkZXRlcm1pbmVkLlxuICAgKi9cbiAgZ2V0U3BhbihiLCBvZmZzZXQpIHtcbiAgICBpZiAoMCA+IHRoaXMuc3Bhbikge1xuICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ2luZGV0ZXJtaW5hdGUgc3BhbicpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5zcGFuO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlcGxpY2F0ZSB0aGUgbGF5b3V0IHVzaW5nIGEgbmV3IHByb3BlcnR5LlxuICAgKlxuICAgKiBUaGlzIGZ1bmN0aW9uIG11c3QgYmUgdXNlZCB0byBnZXQgYSBzdHJ1Y3R1cmFsbHktZXF1aXZhbGVudCBsYXlvdXRcbiAgICogd2l0aCBhIGRpZmZlcmVudCBuYW1lIHNpbmNlIGFsbCB7QGxpbmsgTGF5b3V0fSBpbnN0YW5jZXMgYXJlXG4gICAqIGltbXV0YWJsZS5cbiAgICpcbiAgICogKipOT1RFKiogVGhpcyBpcyBhIHNoYWxsb3cgY29weS4gIEFsbCBmaWVsZHMgZXhjZXB0IHtAbGlua1xuICAgKiBMYXlvdXQjcHJvcGVydHl8cHJvcGVydHl9IGFyZSBzdHJpY3RseSBlcXVhbCB0byB0aGUgb3JpZ2luIGxheW91dC5cbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd9IHByb3BlcnR5IC0gdGhlIHZhbHVlIGZvciB7QGxpbmtcbiAgICogTGF5b3V0I3Byb3BlcnR5fHByb3BlcnR5fSBpbiB0aGUgcmVwbGljYS5cbiAgICpcbiAgICogQHJldHVybnMge0xheW91dH0gLSB0aGUgY29weSB3aXRoIHtAbGluayBMYXlvdXQjcHJvcGVydHl8cHJvcGVydHl9XG4gICAqIHNldCB0byBgcHJvcGVydHlgLlxuICAgKi9cbiAgcmVwbGljYXRlKHByb3BlcnR5KSB7XG4gICAgY29uc3QgcnYgPSBPYmplY3QuY3JlYXRlKHRoaXMuY29uc3RydWN0b3IucHJvdG90eXBlKTtcbiAgICBPYmplY3QuYXNzaWduKHJ2LCB0aGlzKTtcbiAgICBydi5wcm9wZXJ0eSA9IHByb3BlcnR5O1xuICAgIHJldHVybiBydjtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGUgYW4gb2JqZWN0IGZyb20gbGF5b3V0IHByb3BlcnRpZXMgYW5kIGFuIGFycmF5IG9mIHZhbHVlcy5cbiAgICpcbiAgICogKipOT1RFKiogVGhpcyBmdW5jdGlvbiByZXR1cm5zIGB1bmRlZmluZWRgIGlmIGludm9rZWQgb24gYSBsYXlvdXRcbiAgICogdGhhdCBkb2VzIG5vdCByZXR1cm4gaXRzIHZhbHVlIGFzIGFuIE9iamVjdC4gIE9iamVjdHMgYXJlXG4gICAqIHJldHVybmVkIGZvciB0aGluZ3MgdGhhdCBhcmUgYSB7QGxpbmsgU3RydWN0dXJlfSwgd2hpY2ggaW5jbHVkZXNcbiAgICoge0BsaW5rIFZhcmlhbnRMYXlvdXR8dmFyaWFudCBsYXlvdXRzfSBpZiB0aGV5IGFyZSBzdHJ1Y3R1cmVzLCBhbmRcbiAgICogZXhjbHVkZXMge0BsaW5rIFVuaW9ufXMuICBJZiB5b3Ugd2FudCB0aGlzIGZlYXR1cmUgZm9yIGEgdW5pb25cbiAgICogeW91IG11c3QgdXNlIHtAbGluayBVbmlvbi5nZXRWYXJpYW50fGdldFZhcmlhbnR9IHRvIHNlbGVjdCB0aGVcbiAgICogZGVzaXJlZCBsYXlvdXQuXG4gICAqXG4gICAqIEBwYXJhbSB7QXJyYXl9IHZhbHVlcyAtIGFuIGFycmF5IG9mIHZhbHVlcyB0aGF0IGNvcnJlc3BvbmQgdG8gdGhlXG4gICAqIGRlZmF1bHQgb3JkZXIgZm9yIHByb3BlcnRpZXMuICBBcyB3aXRoIHtAbGluayBMYXlvdXQjZGVjb2RlfGRlY29kZX1cbiAgICogbGF5b3V0IGVsZW1lbnRzIHRoYXQgaGF2ZSBubyBwcm9wZXJ0eSBuYW1lIGFyZSBza2lwcGVkIHdoZW5cbiAgICogaXRlcmF0aW5nIG92ZXIgdGhlIGFycmF5IHZhbHVlcy4gIE9ubHkgdGhlIHRvcC1sZXZlbCBwcm9wZXJ0aWVzIGFyZVxuICAgKiBhc3NpZ25lZDsgYXJndW1lbnRzIGFyZSBub3QgYXNzaWduZWQgdG8gcHJvcGVydGllcyBvZiBjb250YWluZWRcbiAgICogbGF5b3V0cy4gIEFueSB1bnVzZWQgdmFsdWVzIGFyZSBpZ25vcmVkLlxuICAgKlxuICAgKiBAcmV0dXJuIHsoT2JqZWN0fHVuZGVmaW5lZCl9XG4gICAqL1xuICBmcm9tQXJyYXkodmFsdWVzKSB7XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxufVxuZXhwb3J0cy5MYXlvdXQgPSBMYXlvdXQ7XG5cbi8qIFByb3ZpZGUgdGV4dCB0aGF0IGNhcnJpZXMgYSBuYW1lIChzdWNoIGFzIGZvciBhIGZ1bmN0aW9uIHRoYXQgd2lsbFxuICogYmUgdGhyb3dpbmcgYW4gZXJyb3IpIGFubm90YXRlZCB3aXRoIHRoZSBwcm9wZXJ0eSBvZiBhIGdpdmVuIGxheW91dFxuICogKHN1Y2ggYXMgb25lIGZvciB3aGljaCB0aGUgdmFsdWUgd2FzIHVuYWNjZXB0YWJsZSkuXG4gKlxuICogQGlnbm9yZSAqL1xuZnVuY3Rpb24gbmFtZVdpdGhQcm9wZXJ0eShuYW1lLCBsbykge1xuICBpZiAobG8ucHJvcGVydHkpIHtcbiAgICByZXR1cm4gbmFtZSArICdbJyArIGxvLnByb3BlcnR5ICsgJ10nO1xuICB9XG4gIHJldHVybiBuYW1lO1xufVxuZXhwb3J0cy5uYW1lV2l0aFByb3BlcnR5ID0gbmFtZVdpdGhQcm9wZXJ0eTtcblxuLyoqXG4gKiBBdWdtZW50IGEgY2xhc3Mgc28gdGhhdCBpbnN0YW5jZXMgY2FuIGJlIGVuY29kZWQvZGVjb2RlZCB1c2luZyBhXG4gKiBnaXZlbiBsYXlvdXQuXG4gKlxuICogQ2FsbGluZyB0aGlzIGZ1bmN0aW9uIGNvdXBsZXMgYENsYXNzYCB3aXRoIGBsYXlvdXRgIGluIHNldmVyYWwgd2F5czpcbiAqXG4gKiAqIGBDbGFzcy5sYXlvdXRfYCBiZWNvbWVzIGEgc3RhdGljIG1lbWJlciBwcm9wZXJ0eSBlcXVhbCB0byBgbGF5b3V0YDtcbiAqICogYGxheW91dC5ib3VuZENvbnN0cnVjdG9yX2AgYmVjb21lcyBhIHN0YXRpYyBtZW1iZXIgcHJvcGVydHkgZXF1YWxcbiAqICAgIHRvIGBDbGFzc2A7XG4gKiAqIFRoZSB7QGxpbmsgTGF5b3V0I21ha2VEZXN0aW5hdGlvbk9iamVjdHxtYWtlRGVzdGluYXRpb25PYmplY3QoKX1cbiAqICAgcHJvcGVydHkgb2YgYGxheW91dGAgaXMgc2V0IHRvIGEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIGEgYG5ld1xuICogICBDbGFzcygpYDtcbiAqICogYENsYXNzLmRlY29kZShiLCBvZmZzZXQpYCBiZWNvbWVzIGEgc3RhdGljIG1lbWJlciBmdW5jdGlvbiB0aGF0XG4gKiAgIGRlbGVnYXRlcyB0byB7QGxpbmsgTGF5b3V0I2RlY29kZXxsYXlvdXQuZGVjb2RlfS4gIFRoZVxuICogICBzeW50aGVzaXplZCBmdW5jdGlvbiBtYXkgYmUgY2FwdHVyZWQgYW5kIGV4dGVuZGVkLlxuICogKiBgQ2xhc3MucHJvdG90eXBlLmVuY29kZShiLCBvZmZzZXQpYCBwcm92aWRlcyBhbiBpbnN0YW5jZSBtZW1iZXJcbiAqICAgZnVuY3Rpb24gdGhhdCBkZWxlZ2F0ZXMgdG8ge0BsaW5rIExheW91dCNlbmNvZGV8bGF5b3V0LmVuY29kZX1cbiAqICAgd2l0aCBgc3JjYCBzZXQgdG8gYHRoaXNgLiAgVGhlIHN5bnRoZXNpemVkIGZ1bmN0aW9uIG1heSBiZVxuICogICBjYXB0dXJlZCBhbmQgZXh0ZW5kZWQsIGJ1dCB3aGVuIHRoZSBleHRlbnNpb24gaXMgaW52b2tlZCBgdGhpc2BcbiAqICAgbXVzdCBiZSBleHBsaWNpdGx5IGJvdW5kIHRvIHRoZSBpbnN0YW5jZS5cbiAqXG4gKiBAcGFyYW0ge2NsYXNzfSBDbGFzcyAtIGEgSmF2YVNjcmlwdCBjbGFzcyB3aXRoIGEgbnVsbGFyeVxuICogY29uc3RydWN0b3IuXG4gKlxuICogQHBhcmFtIHtMYXlvdXR9IGxheW91dCAtIHRoZSB7QGxpbmsgTGF5b3V0fSBpbnN0YW5jZSB1c2VkIHRvIGVuY29kZVxuICogaW5zdGFuY2VzIG9mIGBDbGFzc2AuXG4gKi9cbmZ1bmN0aW9uIGJpbmRDb25zdHJ1Y3RvckxheW91dChDbGFzcywgbGF5b3V0KSB7XG4gIGlmICgnZnVuY3Rpb24nICE9PSB0eXBlb2YgQ2xhc3MpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdDbGFzcyBtdXN0IGJlIGNvbnN0cnVjdG9yJyk7XG4gIH1cbiAgaWYgKENsYXNzLmhhc093blByb3BlcnR5KCdsYXlvdXRfJykpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0NsYXNzIGlzIGFscmVhZHkgYm91bmQgdG8gYSBsYXlvdXQnKTtcbiAgfVxuICBpZiAoIShsYXlvdXQgJiYgKGxheW91dCBpbnN0YW5jZW9mIExheW91dCkpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignbGF5b3V0IG11c3QgYmUgYSBMYXlvdXQnKTtcbiAgfVxuICBpZiAobGF5b3V0Lmhhc093blByb3BlcnR5KCdib3VuZENvbnN0cnVjdG9yXycpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdsYXlvdXQgaXMgYWxyZWFkeSBib3VuZCB0byBhIGNvbnN0cnVjdG9yJyk7XG4gIH1cbiAgQ2xhc3MubGF5b3V0XyA9IGxheW91dDtcbiAgbGF5b3V0LmJvdW5kQ29uc3RydWN0b3JfID0gQ2xhc3M7XG4gIGxheW91dC5tYWtlRGVzdGluYXRpb25PYmplY3QgPSAoKCkgPT4gbmV3IENsYXNzKCkpO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQ2xhc3MucHJvdG90eXBlLCAnZW5jb2RlJywge1xuICAgIHZhbHVlOiBmdW5jdGlvbihiLCBvZmZzZXQpIHtcbiAgICAgIHJldHVybiBsYXlvdXQuZW5jb2RlKHRoaXMsIGIsIG9mZnNldCk7XG4gICAgfSxcbiAgICB3cml0YWJsZTogdHJ1ZSxcbiAgfSk7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShDbGFzcywgJ2RlY29kZScsIHtcbiAgICB2YWx1ZTogZnVuY3Rpb24oYiwgb2Zmc2V0KSB7XG4gICAgICByZXR1cm4gbGF5b3V0LmRlY29kZShiLCBvZmZzZXQpO1xuICAgIH0sXG4gICAgd3JpdGFibGU6IHRydWUsXG4gIH0pO1xufVxuZXhwb3J0cy5iaW5kQ29uc3RydWN0b3JMYXlvdXQgPSBiaW5kQ29uc3RydWN0b3JMYXlvdXQ7XG5cbi8qKlxuICogQW4gb2JqZWN0IHRoYXQgYmVoYXZlcyBsaWtlIGEgbGF5b3V0IGJ1dCBkb2VzIG5vdCBjb25zdW1lIHNwYWNlXG4gKiB3aXRoaW4gaXRzIGNvbnRhaW5pbmcgbGF5b3V0LlxuICpcbiAqIFRoaXMgaXMgcHJpbWFyaWx5IHVzZWQgdG8gb2J0YWluIG1ldGFkYXRhIGFib3V0IGEgbWVtYmVyLCBzdWNoIGFzIGFcbiAqIHtAbGluayBPZmZzZXRMYXlvdXR9IHRoYXQgY2FuIHByb3ZpZGUgZGF0YSBhYm91dCBhIHtAbGlua1xuICogTGF5b3V0I2dldFNwYW58dmFsdWUtc3BlY2lmaWMgc3Bhbn0uXG4gKlxuICogKipOT1RFKiogVGhpcyBpcyBhbiBhYnN0cmFjdCBiYXNlIGNsYXNzOyB5b3UgY2FuIGNyZWF0ZSBpbnN0YW5jZXNcbiAqIGlmIGl0IGFtdXNlcyB5b3UsIGJ1dCB0aGV5IHdvbid0IHN1cHBvcnQge0BsaW5rXG4gKiBFeHRlcm5hbExheW91dCNpc0NvdW50fGlzQ291bnR9IG9yIG90aGVyIHtAbGluayBMYXlvdXR9IGZ1bmN0aW9ucy5cbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gc3BhbiAtIGluaXRpYWxpemVyIGZvciB7QGxpbmsgTGF5b3V0I3NwYW58c3Bhbn0uXG4gKiBUaGUgcGFyYW1ldGVyIGNhbiByYW5nZSBmcm9tIDEgdGhyb3VnaCA2LlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBbcHJvcGVydHldIC0gaW5pdGlhbGl6ZXIgZm9yIHtAbGlua1xuICogTGF5b3V0I3Byb3BlcnR5fHByb3BlcnR5fS5cbiAqXG4gKiBAYWJzdHJhY3RcbiAqIEBhdWdtZW50cyB7TGF5b3V0fVxuICovXG5jbGFzcyBFeHRlcm5hbExheW91dCBleHRlbmRzIExheW91dCB7XG4gIC8qKlxuICAgKiBSZXR1cm4gYHRydWVgIGlmZiB0aGUgZXh0ZXJuYWwgbGF5b3V0IGRlY29kZXMgdG8gYW4gdW5zaWduZWRcbiAgICogaW50ZWdlciBsYXlvdXQuXG4gICAqXG4gICAqIEluIHRoYXQgY2FzZSBpdCBjYW4gYmUgdXNlZCBhcyB0aGUgc291cmNlIG9mIHtAbGlua1xuICAgKiBTZXF1ZW5jZSNjb3VudHxTZXF1ZW5jZSBjb3VudHN9LCB7QGxpbmsgQmxvYiNsZW5ndGh8QmxvYiBsZW5ndGhzfSxcbiAgICogb3IgYXMge0BsaW5rIFVuaW9uTGF5b3V0RGlzY3JpbWluYXRvciNsYXlvdXR8ZXh0ZXJuYWwgdW5pb25cbiAgICogZGlzY3JpbWluYXRvcnN9LlxuICAgKlxuICAgKiBAYWJzdHJhY3RcbiAgICovXG4gIGlzQ291bnQoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdFeHRlcm5hbExheW91dCBpcyBhYnN0cmFjdCcpO1xuICB9XG59XG5cbi8qKlxuICogQW4ge0BsaW5rIEV4dGVybmFsTGF5b3V0fSB0aGF0IGRldGVybWluZXMgaXRzIHtAbGlua1xuICogTGF5b3V0I2RlY29kZXx2YWx1ZX0gYmFzZWQgb24gb2Zmc2V0IGludG8gYW5kIGxlbmd0aCBvZiB0aGUgYnVmZmVyXG4gKiBvbiB3aGljaCBpdCBpcyBpbnZva2VkLlxuICpcbiAqICpGYWN0b3J5Kjoge0BsaW5rIG1vZHVsZTpMYXlvdXQuZ3JlZWR5fGdyZWVkeX1cbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gW2VsZW1lbnRTcGFuXSAtIGluaXRpYWxpemVyIGZvciB7QGxpbmtcbiAqIEdyZWVkeUNvdW50I2VsZW1lbnRTcGFufGVsZW1lbnRTcGFufS5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gW3Byb3BlcnR5XSAtIGluaXRpYWxpemVyIGZvciB7QGxpbmtcbiAqIExheW91dCNwcm9wZXJ0eXxwcm9wZXJ0eX0uXG4gKlxuICogQGF1Z21lbnRzIHtFeHRlcm5hbExheW91dH1cbiAqL1xuY2xhc3MgR3JlZWR5Q291bnQgZXh0ZW5kcyBFeHRlcm5hbExheW91dCB7XG4gIGNvbnN0cnVjdG9yKGVsZW1lbnRTcGFuLCBwcm9wZXJ0eSkge1xuICAgIGlmICh1bmRlZmluZWQgPT09IGVsZW1lbnRTcGFuKSB7XG4gICAgICBlbGVtZW50U3BhbiA9IDE7XG4gICAgfVxuICAgIGlmICgoIU51bWJlci5pc0ludGVnZXIoZWxlbWVudFNwYW4pKSB8fCAoMCA+PSBlbGVtZW50U3BhbikpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2VsZW1lbnRTcGFuIG11c3QgYmUgYSAocG9zaXRpdmUpIGludGVnZXInKTtcbiAgICB9XG4gICAgc3VwZXIoLTEsIHByb3BlcnR5KTtcblxuICAgIC8qKiBUaGUgbGF5b3V0IGZvciBpbmRpdmlkdWFsIGVsZW1lbnRzIG9mIHRoZSBzZXF1ZW5jZS4gIFRoZSB2YWx1ZVxuICAgICAqIG11c3QgYmUgYSBwb3NpdGl2ZSBpbnRlZ2VyLiAgSWYgbm90IHByb3ZpZGVkLCB0aGUgdmFsdWUgd2lsbCBiZVxuICAgICAqIDEuICovXG4gICAgdGhpcy5lbGVtZW50U3BhbiA9IGVsZW1lbnRTcGFuO1xuICB9XG5cbiAgLyoqIEBvdmVycmlkZSAqL1xuICBpc0NvdW50KCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgLyoqIEBvdmVycmlkZSAqL1xuICBkZWNvZGUoYiwgb2Zmc2V0KSB7XG4gICAgaWYgKHVuZGVmaW5lZCA9PT0gb2Zmc2V0KSB7XG4gICAgICBvZmZzZXQgPSAwO1xuICAgIH1cbiAgICBjb25zdCByZW0gPSBiLmxlbmd0aCAtIG9mZnNldDtcbiAgICByZXR1cm4gTWF0aC5mbG9vcihyZW0gLyB0aGlzLmVsZW1lbnRTcGFuKTtcbiAgfVxuXG4gIC8qKiBAb3ZlcnJpZGUgKi9cbiAgZW5jb2RlKHNyYywgYiwgb2Zmc2V0KSB7XG4gICAgcmV0dXJuIDA7XG4gIH1cbn1cblxuLyoqXG4gKiBBbiB7QGxpbmsgRXh0ZXJuYWxMYXlvdXR9IHRoYXQgc3VwcG9ydHMgYWNjZXNzaW5nIGEge0BsaW5rIExheW91dH1cbiAqIGF0IGEgZml4ZWQgb2Zmc2V0IGZyb20gdGhlIHN0YXJ0IG9mIGFub3RoZXIgTGF5b3V0LiAgVGhlIG9mZnNldCBtYXlcbiAqIGJlIGJlZm9yZSwgd2l0aGluLCBvciBhZnRlciB0aGUgYmFzZSBsYXlvdXQuXG4gKlxuICogKkZhY3RvcnkqOiB7QGxpbmsgbW9kdWxlOkxheW91dC5vZmZzZXR8b2Zmc2V0fVxuICpcbiAqIEBwYXJhbSB7TGF5b3V0fSBsYXlvdXQgLSBpbml0aWFsaXplciBmb3Ige0BsaW5rXG4gKiBPZmZzZXRMYXlvdXQjbGF5b3V0fGxheW91dH0sIG1vZHVsbyBgcHJvcGVydHlgLlxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSBbb2Zmc2V0XSAtIEluaXRpYWxpemVzIHtAbGlua1xuICogT2Zmc2V0TGF5b3V0I29mZnNldHxvZmZzZXR9LiAgRGVmYXVsdHMgdG8gemVyby5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gW3Byb3BlcnR5XSAtIE9wdGlvbmFsIG5ldyBwcm9wZXJ0eSBuYW1lIGZvciBhXG4gKiB7QGxpbmsgTGF5b3V0I3JlcGxpY2F0ZXwgcmVwbGljYX0gb2YgYGxheW91dGAgdG8gYmUgdXNlZCBhcyB7QGxpbmtcbiAqIE9mZnNldExheW91dCNsYXlvdXR8bGF5b3V0fS4gIElmIG5vdCBwcm92aWRlZCB0aGUgYGxheW91dGAgaXMgdXNlZFxuICogdW5jaGFuZ2VkLlxuICpcbiAqIEBhdWdtZW50cyB7TGF5b3V0fVxuICovXG5jbGFzcyBPZmZzZXRMYXlvdXQgZXh0ZW5kcyBFeHRlcm5hbExheW91dCB7XG4gIGNvbnN0cnVjdG9yKGxheW91dCwgb2Zmc2V0LCBwcm9wZXJ0eSkge1xuICAgIGlmICghKGxheW91dCBpbnN0YW5jZW9mIExheW91dCkpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2xheW91dCBtdXN0IGJlIGEgTGF5b3V0Jyk7XG4gICAgfVxuXG4gICAgaWYgKHVuZGVmaW5lZCA9PT0gb2Zmc2V0KSB7XG4gICAgICBvZmZzZXQgPSAwO1xuICAgIH0gZWxzZSBpZiAoIU51bWJlci5pc0ludGVnZXIob2Zmc2V0KSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignb2Zmc2V0IG11c3QgYmUgaW50ZWdlciBvciB1bmRlZmluZWQnKTtcbiAgICB9XG5cbiAgICBzdXBlcihsYXlvdXQuc3BhbiwgcHJvcGVydHkgfHwgbGF5b3V0LnByb3BlcnR5KTtcblxuICAgIC8qKiBUaGUgc3Vib3JkaW5hdGVkIGxheW91dC4gKi9cbiAgICB0aGlzLmxheW91dCA9IGxheW91dDtcblxuICAgIC8qKiBUaGUgbG9jYXRpb24gb2Yge0BsaW5rIE9mZnNldExheW91dCNsYXlvdXR9IHJlbGF0aXZlIHRvIHRoZVxuICAgICAqIHN0YXJ0IG9mIGFub3RoZXIgbGF5b3V0LlxuICAgICAqXG4gICAgICogVGhlIHZhbHVlIG1heSBiZSBwb3NpdGl2ZSBvciBuZWdhdGl2ZSwgYnV0IGFuIGVycm9yIHdpbGwgdGhyb3duXG4gICAgICogaWYgYXQgdGhlIHBvaW50IG9mIHVzZSBpdCBnb2VzIG91dHNpZGUgdGhlIHNwYW4gb2YgdGhlIEJ1ZmZlclxuICAgICAqIGJlaW5nIGFjY2Vzc2VkLiAgKi9cbiAgICB0aGlzLm9mZnNldCA9IG9mZnNldDtcbiAgfVxuXG4gIC8qKiBAb3ZlcnJpZGUgKi9cbiAgaXNDb3VudCgpIHtcbiAgICByZXR1cm4gKCh0aGlzLmxheW91dCBpbnN0YW5jZW9mIFVJbnQpXG4gICAgICAgICAgICB8fCAodGhpcy5sYXlvdXQgaW5zdGFuY2VvZiBVSW50QkUpKTtcbiAgfVxuXG4gIC8qKiBAb3ZlcnJpZGUgKi9cbiAgZGVjb2RlKGIsIG9mZnNldCkge1xuICAgIGlmICh1bmRlZmluZWQgPT09IG9mZnNldCkge1xuICAgICAgb2Zmc2V0ID0gMDtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMubGF5b3V0LmRlY29kZShiLCBvZmZzZXQgKyB0aGlzLm9mZnNldCk7XG4gIH1cblxuICAvKiogQG92ZXJyaWRlICovXG4gIGVuY29kZShzcmMsIGIsIG9mZnNldCkge1xuICAgIGlmICh1bmRlZmluZWQgPT09IG9mZnNldCkge1xuICAgICAgb2Zmc2V0ID0gMDtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMubGF5b3V0LmVuY29kZShzcmMsIGIsIG9mZnNldCArIHRoaXMub2Zmc2V0KTtcbiAgfVxufVxuXG4vKipcbiAqIFJlcHJlc2VudCBhbiB1bnNpZ25lZCBpbnRlZ2VyIGluIGxpdHRsZS1lbmRpYW4gZm9ybWF0LlxuICpcbiAqICpGYWN0b3J5Kjoge0BsaW5rIG1vZHVsZTpMYXlvdXQudTh8dTh9LCB7QGxpbmtcbiAqICBtb2R1bGU6TGF5b3V0LnUxNnx1MTZ9LCB7QGxpbmsgbW9kdWxlOkxheW91dC51MjR8dTI0fSwge0BsaW5rXG4gKiAgbW9kdWxlOkxheW91dC51MzJ8dTMyfSwge0BsaW5rIG1vZHVsZTpMYXlvdXQudTQwfHU0MH0sIHtAbGlua1xuICogIG1vZHVsZTpMYXlvdXQudTQ4fHU0OH1cbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gc3BhbiAtIGluaXRpYWxpemVyIGZvciB7QGxpbmsgTGF5b3V0I3NwYW58c3Bhbn0uXG4gKiBUaGUgcGFyYW1ldGVyIGNhbiByYW5nZSBmcm9tIDEgdGhyb3VnaCA2LlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBbcHJvcGVydHldIC0gaW5pdGlhbGl6ZXIgZm9yIHtAbGlua1xuICogTGF5b3V0I3Byb3BlcnR5fHByb3BlcnR5fS5cbiAqXG4gKiBAYXVnbWVudHMge0xheW91dH1cbiAqL1xuY2xhc3MgVUludCBleHRlbmRzIExheW91dCB7XG4gIGNvbnN0cnVjdG9yKHNwYW4sIHByb3BlcnR5KSB7XG4gICAgc3VwZXIoc3BhbiwgcHJvcGVydHkpO1xuICAgIGlmICg2IDwgdGhpcy5zcGFuKSB7XG4gICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignc3BhbiBtdXN0IG5vdCBleGNlZWQgNiBieXRlcycpO1xuICAgIH1cbiAgfVxuXG4gIC8qKiBAb3ZlcnJpZGUgKi9cbiAgZGVjb2RlKGIsIG9mZnNldCkge1xuICAgIGlmICh1bmRlZmluZWQgPT09IG9mZnNldCkge1xuICAgICAgb2Zmc2V0ID0gMDtcbiAgICB9XG4gICAgcmV0dXJuIGIucmVhZFVJbnRMRShvZmZzZXQsIHRoaXMuc3Bhbik7XG4gIH1cblxuICAvKiogQG92ZXJyaWRlICovXG4gIGVuY29kZShzcmMsIGIsIG9mZnNldCkge1xuICAgIGlmICh1bmRlZmluZWQgPT09IG9mZnNldCkge1xuICAgICAgb2Zmc2V0ID0gMDtcbiAgICB9XG4gICAgYi53cml0ZVVJbnRMRShzcmMsIG9mZnNldCwgdGhpcy5zcGFuKTtcbiAgICByZXR1cm4gdGhpcy5zcGFuO1xuICB9XG59XG5cbi8qKlxuICogUmVwcmVzZW50IGFuIHVuc2lnbmVkIGludGVnZXIgaW4gYmlnLWVuZGlhbiBmb3JtYXQuXG4gKlxuICogKkZhY3RvcnkqOiB7QGxpbmsgbW9kdWxlOkxheW91dC51OGJlfHU4YmV9LCB7QGxpbmtcbiAqIG1vZHVsZTpMYXlvdXQudTE2YmV8dTE2YmV9LCB7QGxpbmsgbW9kdWxlOkxheW91dC51MjRiZXx1MjRiZX0sXG4gKiB7QGxpbmsgbW9kdWxlOkxheW91dC51MzJiZXx1MzJiZX0sIHtAbGlua1xuICogbW9kdWxlOkxheW91dC51NDBiZXx1NDBiZX0sIHtAbGluayBtb2R1bGU6TGF5b3V0LnU0OGJlfHU0OGJlfVxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSBzcGFuIC0gaW5pdGlhbGl6ZXIgZm9yIHtAbGluayBMYXlvdXQjc3BhbnxzcGFufS5cbiAqIFRoZSBwYXJhbWV0ZXIgY2FuIHJhbmdlIGZyb20gMSB0aHJvdWdoIDYuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IFtwcm9wZXJ0eV0gLSBpbml0aWFsaXplciBmb3Ige0BsaW5rXG4gKiBMYXlvdXQjcHJvcGVydHl8cHJvcGVydHl9LlxuICpcbiAqIEBhdWdtZW50cyB7TGF5b3V0fVxuICovXG5jbGFzcyBVSW50QkUgZXh0ZW5kcyBMYXlvdXQge1xuICBjb25zdHJ1Y3RvcihzcGFuLCBwcm9wZXJ0eSkge1xuICAgIHN1cGVyKCBzcGFuLCBwcm9wZXJ0eSk7XG4gICAgaWYgKDYgPCB0aGlzLnNwYW4pIHtcbiAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdzcGFuIG11c3Qgbm90IGV4Y2VlZCA2IGJ5dGVzJyk7XG4gICAgfVxuICB9XG5cbiAgLyoqIEBvdmVycmlkZSAqL1xuICBkZWNvZGUoYiwgb2Zmc2V0KSB7XG4gICAgaWYgKHVuZGVmaW5lZCA9PT0gb2Zmc2V0KSB7XG4gICAgICBvZmZzZXQgPSAwO1xuICAgIH1cbiAgICByZXR1cm4gYi5yZWFkVUludEJFKG9mZnNldCwgdGhpcy5zcGFuKTtcbiAgfVxuXG4gIC8qKiBAb3ZlcnJpZGUgKi9cbiAgZW5jb2RlKHNyYywgYiwgb2Zmc2V0KSB7XG4gICAgaWYgKHVuZGVmaW5lZCA9PT0gb2Zmc2V0KSB7XG4gICAgICBvZmZzZXQgPSAwO1xuICAgIH1cbiAgICBiLndyaXRlVUludEJFKHNyYywgb2Zmc2V0LCB0aGlzLnNwYW4pO1xuICAgIHJldHVybiB0aGlzLnNwYW47XG4gIH1cbn1cblxuLyoqXG4gKiBSZXByZXNlbnQgYSBzaWduZWQgaW50ZWdlciBpbiBsaXR0bGUtZW5kaWFuIGZvcm1hdC5cbiAqXG4gKiAqRmFjdG9yeSo6IHtAbGluayBtb2R1bGU6TGF5b3V0LnM4fHM4fSwge0BsaW5rXG4gKiAgbW9kdWxlOkxheW91dC5zMTZ8czE2fSwge0BsaW5rIG1vZHVsZTpMYXlvdXQuczI0fHMyNH0sIHtAbGlua1xuICogIG1vZHVsZTpMYXlvdXQuczMyfHMzMn0sIHtAbGluayBtb2R1bGU6TGF5b3V0LnM0MHxzNDB9LCB7QGxpbmtcbiAqICBtb2R1bGU6TGF5b3V0LnM0OHxzNDh9XG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IHNwYW4gLSBpbml0aWFsaXplciBmb3Ige0BsaW5rIExheW91dCNzcGFufHNwYW59LlxuICogVGhlIHBhcmFtZXRlciBjYW4gcmFuZ2UgZnJvbSAxIHRocm91Z2ggNi5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gW3Byb3BlcnR5XSAtIGluaXRpYWxpemVyIGZvciB7QGxpbmtcbiAqIExheW91dCNwcm9wZXJ0eXxwcm9wZXJ0eX0uXG4gKlxuICogQGF1Z21lbnRzIHtMYXlvdXR9XG4gKi9cbmNsYXNzIEludCBleHRlbmRzIExheW91dCB7XG4gIGNvbnN0cnVjdG9yKHNwYW4sIHByb3BlcnR5KSB7XG4gICAgc3VwZXIoc3BhbiwgcHJvcGVydHkpO1xuICAgIGlmICg2IDwgdGhpcy5zcGFuKSB7XG4gICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignc3BhbiBtdXN0IG5vdCBleGNlZWQgNiBieXRlcycpO1xuICAgIH1cbiAgfVxuXG4gIC8qKiBAb3ZlcnJpZGUgKi9cbiAgZGVjb2RlKGIsIG9mZnNldCkge1xuICAgIGlmICh1bmRlZmluZWQgPT09IG9mZnNldCkge1xuICAgICAgb2Zmc2V0ID0gMDtcbiAgICB9XG4gICAgcmV0dXJuIGIucmVhZEludExFKG9mZnNldCwgdGhpcy5zcGFuKTtcbiAgfVxuXG4gIC8qKiBAb3ZlcnJpZGUgKi9cbiAgZW5jb2RlKHNyYywgYiwgb2Zmc2V0KSB7XG4gICAgaWYgKHVuZGVmaW5lZCA9PT0gb2Zmc2V0KSB7XG4gICAgICBvZmZzZXQgPSAwO1xuICAgIH1cbiAgICBiLndyaXRlSW50TEUoc3JjLCBvZmZzZXQsIHRoaXMuc3Bhbik7XG4gICAgcmV0dXJuIHRoaXMuc3BhbjtcbiAgfVxufVxuXG4vKipcbiAqIFJlcHJlc2VudCBhIHNpZ25lZCBpbnRlZ2VyIGluIGJpZy1lbmRpYW4gZm9ybWF0LlxuICpcbiAqICpGYWN0b3J5Kjoge0BsaW5rIG1vZHVsZTpMYXlvdXQuczhiZXxzOGJlfSwge0BsaW5rXG4gKiBtb2R1bGU6TGF5b3V0LnMxNmJlfHMxNmJlfSwge0BsaW5rIG1vZHVsZTpMYXlvdXQuczI0YmV8czI0YmV9LFxuICoge0BsaW5rIG1vZHVsZTpMYXlvdXQuczMyYmV8czMyYmV9LCB7QGxpbmtcbiAqIG1vZHVsZTpMYXlvdXQuczQwYmV8czQwYmV9LCB7QGxpbmsgbW9kdWxlOkxheW91dC5zNDhiZXxzNDhiZX1cbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gc3BhbiAtIGluaXRpYWxpemVyIGZvciB7QGxpbmsgTGF5b3V0I3NwYW58c3Bhbn0uXG4gKiBUaGUgcGFyYW1ldGVyIGNhbiByYW5nZSBmcm9tIDEgdGhyb3VnaCA2LlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBbcHJvcGVydHldIC0gaW5pdGlhbGl6ZXIgZm9yIHtAbGlua1xuICogTGF5b3V0I3Byb3BlcnR5fHByb3BlcnR5fS5cbiAqXG4gKiBAYXVnbWVudHMge0xheW91dH1cbiAqL1xuY2xhc3MgSW50QkUgZXh0ZW5kcyBMYXlvdXQge1xuICBjb25zdHJ1Y3RvcihzcGFuLCBwcm9wZXJ0eSkge1xuICAgIHN1cGVyKHNwYW4sIHByb3BlcnR5KTtcbiAgICBpZiAoNiA8IHRoaXMuc3Bhbikge1xuICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ3NwYW4gbXVzdCBub3QgZXhjZWVkIDYgYnl0ZXMnKTtcbiAgICB9XG4gIH1cblxuICAvKiogQG92ZXJyaWRlICovXG4gIGRlY29kZShiLCBvZmZzZXQpIHtcbiAgICBpZiAodW5kZWZpbmVkID09PSBvZmZzZXQpIHtcbiAgICAgIG9mZnNldCA9IDA7XG4gICAgfVxuICAgIHJldHVybiBiLnJlYWRJbnRCRShvZmZzZXQsIHRoaXMuc3Bhbik7XG4gIH1cblxuICAvKiogQG92ZXJyaWRlICovXG4gIGVuY29kZShzcmMsIGIsIG9mZnNldCkge1xuICAgIGlmICh1bmRlZmluZWQgPT09IG9mZnNldCkge1xuICAgICAgb2Zmc2V0ID0gMDtcbiAgICB9XG4gICAgYi53cml0ZUludEJFKHNyYywgb2Zmc2V0LCB0aGlzLnNwYW4pO1xuICAgIHJldHVybiB0aGlzLnNwYW47XG4gIH1cbn1cblxuY29uc3QgVjJFMzIgPSBNYXRoLnBvdygyLCAzMik7XG5cbi8qIFRydWUgbW9kdWx1cyBoaWdoIGFuZCBsb3cgMzItYml0IHdvcmRzLCB3aGVyZSBsb3cgd29yZCBpcyBhbHdheXNcbiAqIG5vbi1uZWdhdGl2ZS4gKi9cbmZ1bmN0aW9uIGRpdm1vZEludDY0KHNyYykge1xuICBjb25zdCBoaTMyID0gTWF0aC5mbG9vcihzcmMgLyBWMkUzMik7XG4gIGNvbnN0IGxvMzIgPSBzcmMgLSAoaGkzMiAqIFYyRTMyKTtcbiAgcmV0dXJuIHtoaTMyLCBsbzMyfTtcbn1cbi8qIFJlY29uc3RydWN0IE51bWJlciBmcm9tIHF1b3RpZW50IGFuZCBub24tbmVnYXRpdmUgcmVtYWluZGVyICovXG5mdW5jdGlvbiByb3VuZGVkSW50NjQoaGkzMiwgbG8zMikge1xuICByZXR1cm4gaGkzMiAqIFYyRTMyICsgbG8zMjtcbn1cblxuLyoqXG4gKiBSZXByZXNlbnQgYW4gdW5zaWduZWQgNjQtYml0IGludGVnZXIgaW4gbGl0dGxlLWVuZGlhbiBmb3JtYXQgd2hlblxuICogZW5jb2RlZCBhbmQgYXMgYSBuZWFyIGludGVncmFsIEphdmFTY3JpcHQgTnVtYmVyIHdoZW4gZGVjb2RlZC5cbiAqXG4gKiAqRmFjdG9yeSo6IHtAbGluayBtb2R1bGU6TGF5b3V0Lm51NjR8bnU2NH1cbiAqXG4gKiAqKk5PVEUqKiBWYWx1ZXMgd2l0aCBtYWduaXR1ZGUgZ3JlYXRlciB0aGFuIDJeNTIgbWF5IG5vdCBkZWNvZGUgdG9cbiAqIHRoZSBleGFjdCB2YWx1ZSBvZiB0aGUgZW5jb2RlZCByZXByZXNlbnRhdGlvbi5cbiAqXG4gKiBAYXVnbWVudHMge0xheW91dH1cbiAqL1xuY2xhc3MgTmVhclVJbnQ2NCBleHRlbmRzIExheW91dCB7XG4gIGNvbnN0cnVjdG9yKHByb3BlcnR5KSB7XG4gICAgc3VwZXIoOCwgcHJvcGVydHkpO1xuICB9XG5cbiAgLyoqIEBvdmVycmlkZSAqL1xuICBkZWNvZGUoYiwgb2Zmc2V0KSB7XG4gICAgaWYgKHVuZGVmaW5lZCA9PT0gb2Zmc2V0KSB7XG4gICAgICBvZmZzZXQgPSAwO1xuICAgIH1cbiAgICBjb25zdCBsbzMyID0gYi5yZWFkVUludDMyTEUob2Zmc2V0KTtcbiAgICBjb25zdCBoaTMyID0gYi5yZWFkVUludDMyTEUob2Zmc2V0ICsgNCk7XG4gICAgcmV0dXJuIHJvdW5kZWRJbnQ2NChoaTMyLCBsbzMyKTtcbiAgfVxuXG4gIC8qKiBAb3ZlcnJpZGUgKi9cbiAgZW5jb2RlKHNyYywgYiwgb2Zmc2V0KSB7XG4gICAgaWYgKHVuZGVmaW5lZCA9PT0gb2Zmc2V0KSB7XG4gICAgICBvZmZzZXQgPSAwO1xuICAgIH1cbiAgICBjb25zdCBzcGxpdCA9IGRpdm1vZEludDY0KHNyYyk7XG4gICAgYi53cml0ZVVJbnQzMkxFKHNwbGl0LmxvMzIsIG9mZnNldCk7XG4gICAgYi53cml0ZVVJbnQzMkxFKHNwbGl0LmhpMzIsIG9mZnNldCArIDQpO1xuICAgIHJldHVybiA4O1xuICB9XG59XG5cbi8qKlxuICogUmVwcmVzZW50IGFuIHVuc2lnbmVkIDY0LWJpdCBpbnRlZ2VyIGluIGJpZy1lbmRpYW4gZm9ybWF0IHdoZW5cbiAqIGVuY29kZWQgYW5kIGFzIGEgbmVhciBpbnRlZ3JhbCBKYXZhU2NyaXB0IE51bWJlciB3aGVuIGRlY29kZWQuXG4gKlxuICogKkZhY3RvcnkqOiB7QGxpbmsgbW9kdWxlOkxheW91dC5udTY0YmV8bnU2NGJlfVxuICpcbiAqICoqTk9URSoqIFZhbHVlcyB3aXRoIG1hZ25pdHVkZSBncmVhdGVyIHRoYW4gMl41MiBtYXkgbm90IGRlY29kZSB0b1xuICogdGhlIGV4YWN0IHZhbHVlIG9mIHRoZSBlbmNvZGVkIHJlcHJlc2VudGF0aW9uLlxuICpcbiAqIEBhdWdtZW50cyB7TGF5b3V0fVxuICovXG5jbGFzcyBOZWFyVUludDY0QkUgZXh0ZW5kcyBMYXlvdXQge1xuICBjb25zdHJ1Y3Rvcihwcm9wZXJ0eSkge1xuICAgIHN1cGVyKDgsIHByb3BlcnR5KTtcbiAgfVxuXG4gIC8qKiBAb3ZlcnJpZGUgKi9cbiAgZGVjb2RlKGIsIG9mZnNldCkge1xuICAgIGlmICh1bmRlZmluZWQgPT09IG9mZnNldCkge1xuICAgICAgb2Zmc2V0ID0gMDtcbiAgICB9XG4gICAgY29uc3QgaGkzMiA9IGIucmVhZFVJbnQzMkJFKG9mZnNldCk7XG4gICAgY29uc3QgbG8zMiA9IGIucmVhZFVJbnQzMkJFKG9mZnNldCArIDQpO1xuICAgIHJldHVybiByb3VuZGVkSW50NjQoaGkzMiwgbG8zMik7XG4gIH1cblxuICAvKiogQG92ZXJyaWRlICovXG4gIGVuY29kZShzcmMsIGIsIG9mZnNldCkge1xuICAgIGlmICh1bmRlZmluZWQgPT09IG9mZnNldCkge1xuICAgICAgb2Zmc2V0ID0gMDtcbiAgICB9XG4gICAgY29uc3Qgc3BsaXQgPSBkaXZtb2RJbnQ2NChzcmMpO1xuICAgIGIud3JpdGVVSW50MzJCRShzcGxpdC5oaTMyLCBvZmZzZXQpO1xuICAgIGIud3JpdGVVSW50MzJCRShzcGxpdC5sbzMyLCBvZmZzZXQgKyA0KTtcbiAgICByZXR1cm4gODtcbiAgfVxufVxuXG4vKipcbiAqIFJlcHJlc2VudCBhIHNpZ25lZCA2NC1iaXQgaW50ZWdlciBpbiBsaXR0bGUtZW5kaWFuIGZvcm1hdCB3aGVuXG4gKiBlbmNvZGVkIGFuZCBhcyBhIG5lYXIgaW50ZWdyYWwgSmF2YVNjcmlwdCBOdW1iZXIgd2hlbiBkZWNvZGVkLlxuICpcbiAqICpGYWN0b3J5Kjoge0BsaW5rIG1vZHVsZTpMYXlvdXQubnM2NHxuczY0fVxuICpcbiAqICoqTk9URSoqIFZhbHVlcyB3aXRoIG1hZ25pdHVkZSBncmVhdGVyIHRoYW4gMl41MiBtYXkgbm90IGRlY29kZSB0b1xuICogdGhlIGV4YWN0IHZhbHVlIG9mIHRoZSBlbmNvZGVkIHJlcHJlc2VudGF0aW9uLlxuICpcbiAqIEBhdWdtZW50cyB7TGF5b3V0fVxuICovXG5jbGFzcyBOZWFySW50NjQgZXh0ZW5kcyBMYXlvdXQge1xuICBjb25zdHJ1Y3Rvcihwcm9wZXJ0eSkge1xuICAgIHN1cGVyKDgsIHByb3BlcnR5KTtcbiAgfVxuXG4gIC8qKiBAb3ZlcnJpZGUgKi9cbiAgZGVjb2RlKGIsIG9mZnNldCkge1xuICAgIGlmICh1bmRlZmluZWQgPT09IG9mZnNldCkge1xuICAgICAgb2Zmc2V0ID0gMDtcbiAgICB9XG4gICAgY29uc3QgbG8zMiA9IGIucmVhZFVJbnQzMkxFKG9mZnNldCk7XG4gICAgY29uc3QgaGkzMiA9IGIucmVhZEludDMyTEUob2Zmc2V0ICsgNCk7XG4gICAgcmV0dXJuIHJvdW5kZWRJbnQ2NChoaTMyLCBsbzMyKTtcbiAgfVxuXG4gIC8qKiBAb3ZlcnJpZGUgKi9cbiAgZW5jb2RlKHNyYywgYiwgb2Zmc2V0KSB7XG4gICAgaWYgKHVuZGVmaW5lZCA9PT0gb2Zmc2V0KSB7XG4gICAgICBvZmZzZXQgPSAwO1xuICAgIH1cbiAgICBjb25zdCBzcGxpdCA9IGRpdm1vZEludDY0KHNyYyk7XG4gICAgYi53cml0ZVVJbnQzMkxFKHNwbGl0LmxvMzIsIG9mZnNldCk7XG4gICAgYi53cml0ZUludDMyTEUoc3BsaXQuaGkzMiwgb2Zmc2V0ICsgNCk7XG4gICAgcmV0dXJuIDg7XG4gIH1cbn1cblxuLyoqXG4gKiBSZXByZXNlbnQgYSBzaWduZWQgNjQtYml0IGludGVnZXIgaW4gYmlnLWVuZGlhbiBmb3JtYXQgd2hlblxuICogZW5jb2RlZCBhbmQgYXMgYSBuZWFyIGludGVncmFsIEphdmFTY3JpcHQgTnVtYmVyIHdoZW4gZGVjb2RlZC5cbiAqXG4gKiAqRmFjdG9yeSo6IHtAbGluayBtb2R1bGU6TGF5b3V0Lm5zNjRiZXxuczY0YmV9XG4gKlxuICogKipOT1RFKiogVmFsdWVzIHdpdGggbWFnbml0dWRlIGdyZWF0ZXIgdGhhbiAyXjUyIG1heSBub3QgZGVjb2RlIHRvXG4gKiB0aGUgZXhhY3QgdmFsdWUgb2YgdGhlIGVuY29kZWQgcmVwcmVzZW50YXRpb24uXG4gKlxuICogQGF1Z21lbnRzIHtMYXlvdXR9XG4gKi9cbmNsYXNzIE5lYXJJbnQ2NEJFIGV4dGVuZHMgTGF5b3V0IHtcbiAgY29uc3RydWN0b3IocHJvcGVydHkpIHtcbiAgICBzdXBlcig4LCBwcm9wZXJ0eSk7XG4gIH1cblxuICAvKiogQG92ZXJyaWRlICovXG4gIGRlY29kZShiLCBvZmZzZXQpIHtcbiAgICBpZiAodW5kZWZpbmVkID09PSBvZmZzZXQpIHtcbiAgICAgIG9mZnNldCA9IDA7XG4gICAgfVxuICAgIGNvbnN0IGhpMzIgPSBiLnJlYWRJbnQzMkJFKG9mZnNldCk7XG4gICAgY29uc3QgbG8zMiA9IGIucmVhZFVJbnQzMkJFKG9mZnNldCArIDQpO1xuICAgIHJldHVybiByb3VuZGVkSW50NjQoaGkzMiwgbG8zMik7XG4gIH1cblxuICAvKiogQG92ZXJyaWRlICovXG4gIGVuY29kZShzcmMsIGIsIG9mZnNldCkge1xuICAgIGlmICh1bmRlZmluZWQgPT09IG9mZnNldCkge1xuICAgICAgb2Zmc2V0ID0gMDtcbiAgICB9XG4gICAgY29uc3Qgc3BsaXQgPSBkaXZtb2RJbnQ2NChzcmMpO1xuICAgIGIud3JpdGVJbnQzMkJFKHNwbGl0LmhpMzIsIG9mZnNldCk7XG4gICAgYi53cml0ZVVJbnQzMkJFKHNwbGl0LmxvMzIsIG9mZnNldCArIDQpO1xuICAgIHJldHVybiA4O1xuICB9XG59XG5cbi8qKlxuICogUmVwcmVzZW50IGEgMzItYml0IGZsb2F0aW5nIHBvaW50IG51bWJlciBpbiBsaXR0bGUtZW5kaWFuIGZvcm1hdC5cbiAqXG4gKiAqRmFjdG9yeSo6IHtAbGluayBtb2R1bGU6TGF5b3V0LmYzMnxmMzJ9XG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IFtwcm9wZXJ0eV0gLSBpbml0aWFsaXplciBmb3Ige0BsaW5rXG4gKiBMYXlvdXQjcHJvcGVydHl8cHJvcGVydHl9LlxuICpcbiAqIEBhdWdtZW50cyB7TGF5b3V0fVxuICovXG5jbGFzcyBGbG9hdCBleHRlbmRzIExheW91dCB7XG4gIGNvbnN0cnVjdG9yKHByb3BlcnR5KSB7XG4gICAgc3VwZXIoNCwgcHJvcGVydHkpO1xuICB9XG5cbiAgLyoqIEBvdmVycmlkZSAqL1xuICBkZWNvZGUoYiwgb2Zmc2V0KSB7XG4gICAgaWYgKHVuZGVmaW5lZCA9PT0gb2Zmc2V0KSB7XG4gICAgICBvZmZzZXQgPSAwO1xuICAgIH1cbiAgICByZXR1cm4gYi5yZWFkRmxvYXRMRShvZmZzZXQpO1xuICB9XG5cbiAgLyoqIEBvdmVycmlkZSAqL1xuICBlbmNvZGUoc3JjLCBiLCBvZmZzZXQpIHtcbiAgICBpZiAodW5kZWZpbmVkID09PSBvZmZzZXQpIHtcbiAgICAgIG9mZnNldCA9IDA7XG4gICAgfVxuICAgIGIud3JpdGVGbG9hdExFKHNyYywgb2Zmc2V0KTtcbiAgICByZXR1cm4gNDtcbiAgfVxufVxuXG4vKipcbiAqIFJlcHJlc2VudCBhIDMyLWJpdCBmbG9hdGluZyBwb2ludCBudW1iZXIgaW4gYmlnLWVuZGlhbiBmb3JtYXQuXG4gKlxuICogKkZhY3RvcnkqOiB7QGxpbmsgbW9kdWxlOkxheW91dC5mMzJiZXxmMzJiZX1cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gW3Byb3BlcnR5XSAtIGluaXRpYWxpemVyIGZvciB7QGxpbmtcbiAqIExheW91dCNwcm9wZXJ0eXxwcm9wZXJ0eX0uXG4gKlxuICogQGF1Z21lbnRzIHtMYXlvdXR9XG4gKi9cbmNsYXNzIEZsb2F0QkUgZXh0ZW5kcyBMYXlvdXQge1xuICBjb25zdHJ1Y3Rvcihwcm9wZXJ0eSkge1xuICAgIHN1cGVyKDQsIHByb3BlcnR5KTtcbiAgfVxuXG4gIC8qKiBAb3ZlcnJpZGUgKi9cbiAgZGVjb2RlKGIsIG9mZnNldCkge1xuICAgIGlmICh1bmRlZmluZWQgPT09IG9mZnNldCkge1xuICAgICAgb2Zmc2V0ID0gMDtcbiAgICB9XG4gICAgcmV0dXJuIGIucmVhZEZsb2F0QkUob2Zmc2V0KTtcbiAgfVxuXG4gIC8qKiBAb3ZlcnJpZGUgKi9cbiAgZW5jb2RlKHNyYywgYiwgb2Zmc2V0KSB7XG4gICAgaWYgKHVuZGVmaW5lZCA9PT0gb2Zmc2V0KSB7XG4gICAgICBvZmZzZXQgPSAwO1xuICAgIH1cbiAgICBiLndyaXRlRmxvYXRCRShzcmMsIG9mZnNldCk7XG4gICAgcmV0dXJuIDQ7XG4gIH1cbn1cblxuLyoqXG4gKiBSZXByZXNlbnQgYSA2NC1iaXQgZmxvYXRpbmcgcG9pbnQgbnVtYmVyIGluIGxpdHRsZS1lbmRpYW4gZm9ybWF0LlxuICpcbiAqICpGYWN0b3J5Kjoge0BsaW5rIG1vZHVsZTpMYXlvdXQuZjY0fGY2NH1cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gW3Byb3BlcnR5XSAtIGluaXRpYWxpemVyIGZvciB7QGxpbmtcbiAqIExheW91dCNwcm9wZXJ0eXxwcm9wZXJ0eX0uXG4gKlxuICogQGF1Z21lbnRzIHtMYXlvdXR9XG4gKi9cbmNsYXNzIERvdWJsZSBleHRlbmRzIExheW91dCB7XG4gIGNvbnN0cnVjdG9yKHByb3BlcnR5KSB7XG4gICAgc3VwZXIoOCwgcHJvcGVydHkpO1xuICB9XG5cbiAgLyoqIEBvdmVycmlkZSAqL1xuICBkZWNvZGUoYiwgb2Zmc2V0KSB7XG4gICAgaWYgKHVuZGVmaW5lZCA9PT0gb2Zmc2V0KSB7XG4gICAgICBvZmZzZXQgPSAwO1xuICAgIH1cbiAgICByZXR1cm4gYi5yZWFkRG91YmxlTEUob2Zmc2V0KTtcbiAgfVxuXG4gIC8qKiBAb3ZlcnJpZGUgKi9cbiAgZW5jb2RlKHNyYywgYiwgb2Zmc2V0KSB7XG4gICAgaWYgKHVuZGVmaW5lZCA9PT0gb2Zmc2V0KSB7XG4gICAgICBvZmZzZXQgPSAwO1xuICAgIH1cbiAgICBiLndyaXRlRG91YmxlTEUoc3JjLCBvZmZzZXQpO1xuICAgIHJldHVybiA4O1xuICB9XG59XG5cbi8qKlxuICogUmVwcmVzZW50IGEgNjQtYml0IGZsb2F0aW5nIHBvaW50IG51bWJlciBpbiBiaWctZW5kaWFuIGZvcm1hdC5cbiAqXG4gKiAqRmFjdG9yeSo6IHtAbGluayBtb2R1bGU6TGF5b3V0LmY2NGJlfGY2NGJlfVxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBbcHJvcGVydHldIC0gaW5pdGlhbGl6ZXIgZm9yIHtAbGlua1xuICogTGF5b3V0I3Byb3BlcnR5fHByb3BlcnR5fS5cbiAqXG4gKiBAYXVnbWVudHMge0xheW91dH1cbiAqL1xuY2xhc3MgRG91YmxlQkUgZXh0ZW5kcyBMYXlvdXQge1xuICBjb25zdHJ1Y3Rvcihwcm9wZXJ0eSkge1xuICAgIHN1cGVyKDgsIHByb3BlcnR5KTtcbiAgfVxuXG4gIC8qKiBAb3ZlcnJpZGUgKi9cbiAgZGVjb2RlKGIsIG9mZnNldCkge1xuICAgIGlmICh1bmRlZmluZWQgPT09IG9mZnNldCkge1xuICAgICAgb2Zmc2V0ID0gMDtcbiAgICB9XG4gICAgcmV0dXJuIGIucmVhZERvdWJsZUJFKG9mZnNldCk7XG4gIH1cblxuICAvKiogQG92ZXJyaWRlICovXG4gIGVuY29kZShzcmMsIGIsIG9mZnNldCkge1xuICAgIGlmICh1bmRlZmluZWQgPT09IG9mZnNldCkge1xuICAgICAgb2Zmc2V0ID0gMDtcbiAgICB9XG4gICAgYi53cml0ZURvdWJsZUJFKHNyYywgb2Zmc2V0KTtcbiAgICByZXR1cm4gODtcbiAgfVxufVxuXG4vKipcbiAqIFJlcHJlc2VudCBhIGNvbnRpZ3VvdXMgc2VxdWVuY2Ugb2YgYSBzcGVjaWZpYyBsYXlvdXQgYXMgYW4gQXJyYXkuXG4gKlxuICogKkZhY3RvcnkqOiB7QGxpbmsgbW9kdWxlOkxheW91dC5zZXF8c2VxfVxuICpcbiAqIEBwYXJhbSB7TGF5b3V0fSBlbGVtZW50TGF5b3V0IC0gaW5pdGlhbGl6ZXIgZm9yIHtAbGlua1xuICogU2VxdWVuY2UjZWxlbWVudExheW91dHxlbGVtZW50TGF5b3V0fS5cbiAqXG4gKiBAcGFyYW0geyhOdW1iZXJ8RXh0ZXJuYWxMYXlvdXQpfSBjb3VudCAtIGluaXRpYWxpemVyIGZvciB7QGxpbmtcbiAqIFNlcXVlbmNlI2NvdW50fGNvdW50fS4gIFRoZSBwYXJhbWV0ZXIgbXVzdCBiZSBlaXRoZXIgYSBwb3NpdGl2ZVxuICogaW50ZWdlciBvciBhbiBpbnN0YW5jZSBvZiB7QGxpbmsgRXh0ZXJuYWxMYXlvdXR9LlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBbcHJvcGVydHldIC0gaW5pdGlhbGl6ZXIgZm9yIHtAbGlua1xuICogTGF5b3V0I3Byb3BlcnR5fHByb3BlcnR5fS5cbiAqXG4gKiBAYXVnbWVudHMge0xheW91dH1cbiAqL1xuY2xhc3MgU2VxdWVuY2UgZXh0ZW5kcyBMYXlvdXQge1xuICBjb25zdHJ1Y3RvcihlbGVtZW50TGF5b3V0LCBjb3VudCwgcHJvcGVydHkpIHtcbiAgICBpZiAoIShlbGVtZW50TGF5b3V0IGluc3RhbmNlb2YgTGF5b3V0KSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignZWxlbWVudExheW91dCBtdXN0IGJlIGEgTGF5b3V0Jyk7XG4gICAgfVxuICAgIGlmICghKCgoY291bnQgaW5zdGFuY2VvZiBFeHRlcm5hbExheW91dCkgJiYgY291bnQuaXNDb3VudCgpKVxuICAgICAgICAgIHx8IChOdW1iZXIuaXNJbnRlZ2VyKGNvdW50KSAmJiAoMCA8PSBjb3VudCkpKSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignY291bnQgbXVzdCBiZSBub24tbmVnYXRpdmUgaW50ZWdlciAnXG4gICAgICAgICAgICAgICAgICAgICAgICAgICsgJ29yIGFuIHVuc2lnbmVkIGludGVnZXIgRXh0ZXJuYWxMYXlvdXQnKTtcbiAgICB9XG4gICAgbGV0IHNwYW4gPSAtMTtcbiAgICBpZiAoKCEoY291bnQgaW5zdGFuY2VvZiBFeHRlcm5hbExheW91dCkpXG4gICAgICAgICYmICgwIDwgZWxlbWVudExheW91dC5zcGFuKSkge1xuICAgICAgc3BhbiA9IGNvdW50ICogZWxlbWVudExheW91dC5zcGFuO1xuICAgIH1cblxuICAgIHN1cGVyKHNwYW4sIHByb3BlcnR5KTtcblxuICAgIC8qKiBUaGUgbGF5b3V0IGZvciBpbmRpdmlkdWFsIGVsZW1lbnRzIG9mIHRoZSBzZXF1ZW5jZS4gKi9cbiAgICB0aGlzLmVsZW1lbnRMYXlvdXQgPSBlbGVtZW50TGF5b3V0O1xuXG4gICAgLyoqIFRoZSBudW1iZXIgb2YgZWxlbWVudHMgaW4gdGhlIHNlcXVlbmNlLlxuICAgICAqXG4gICAgICogVGhpcyB3aWxsIGJlIGVpdGhlciBhIG5vbi1uZWdhdGl2ZSBpbnRlZ2VyIG9yIGFuIGluc3RhbmNlIG9mXG4gICAgICoge0BsaW5rIEV4dGVybmFsTGF5b3V0fSBmb3Igd2hpY2gge0BsaW5rXG4gICAgICogRXh0ZXJuYWxMYXlvdXQjaXNDb3VudHxpc0NvdW50KCl9IGlzIGB0cnVlYC4gKi9cbiAgICB0aGlzLmNvdW50ID0gY291bnQ7XG4gIH1cblxuICAvKiogQG92ZXJyaWRlICovXG4gIGdldFNwYW4oYiwgb2Zmc2V0KSB7XG4gICAgaWYgKDAgPD0gdGhpcy5zcGFuKSB7XG4gICAgICByZXR1cm4gdGhpcy5zcGFuO1xuICAgIH1cbiAgICBpZiAodW5kZWZpbmVkID09PSBvZmZzZXQpIHtcbiAgICAgIG9mZnNldCA9IDA7XG4gICAgfVxuICAgIGxldCBzcGFuID0gMDtcbiAgICBsZXQgY291bnQgPSB0aGlzLmNvdW50O1xuICAgIGlmIChjb3VudCBpbnN0YW5jZW9mIEV4dGVybmFsTGF5b3V0KSB7XG4gICAgICBjb3VudCA9IGNvdW50LmRlY29kZShiLCBvZmZzZXQpO1xuICAgIH1cbiAgICBpZiAoMCA8IHRoaXMuZWxlbWVudExheW91dC5zcGFuKSB7XG4gICAgICBzcGFuID0gY291bnQgKiB0aGlzLmVsZW1lbnRMYXlvdXQuc3BhbjtcbiAgICB9IGVsc2Uge1xuICAgICAgbGV0IGlkeCA9IDA7XG4gICAgICB3aGlsZSAoaWR4IDwgY291bnQpIHtcbiAgICAgICAgc3BhbiArPSB0aGlzLmVsZW1lbnRMYXlvdXQuZ2V0U3BhbihiLCBvZmZzZXQgKyBzcGFuKTtcbiAgICAgICAgKytpZHg7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBzcGFuO1xuICB9XG5cbiAgLyoqIEBvdmVycmlkZSAqL1xuICBkZWNvZGUoYiwgb2Zmc2V0KSB7XG4gICAgaWYgKHVuZGVmaW5lZCA9PT0gb2Zmc2V0KSB7XG4gICAgICBvZmZzZXQgPSAwO1xuICAgIH1cbiAgICBjb25zdCBydiA9IFtdO1xuICAgIGxldCBpID0gMDtcbiAgICBsZXQgY291bnQgPSB0aGlzLmNvdW50O1xuICAgIGlmIChjb3VudCBpbnN0YW5jZW9mIEV4dGVybmFsTGF5b3V0KSB7XG4gICAgICBjb3VudCA9IGNvdW50LmRlY29kZShiLCBvZmZzZXQpO1xuICAgIH1cbiAgICB3aGlsZSAoaSA8IGNvdW50KSB7XG4gICAgICBydi5wdXNoKHRoaXMuZWxlbWVudExheW91dC5kZWNvZGUoYiwgb2Zmc2V0KSk7XG4gICAgICBvZmZzZXQgKz0gdGhpcy5lbGVtZW50TGF5b3V0LmdldFNwYW4oYiwgb2Zmc2V0KTtcbiAgICAgIGkgKz0gMTtcbiAgICB9XG4gICAgcmV0dXJuIHJ2O1xuICB9XG5cbiAgLyoqIEltcGxlbWVudCB7QGxpbmsgTGF5b3V0I2VuY29kZXxlbmNvZGV9IGZvciB7QGxpbmsgU2VxdWVuY2V9LlxuICAgKlxuICAgKiAqKk5PVEUqKiBJZiBgc3JjYCBpcyBzaG9ydGVyIHRoYW4ge0BsaW5rIFNlcXVlbmNlI2NvdW50fGNvdW50fSB0aGVuXG4gICAqIHRoZSB1bnVzZWQgc3BhY2UgaW4gdGhlIGJ1ZmZlciBpcyBsZWZ0IHVuY2hhbmdlZC4gIElmIGBzcmNgIGlzXG4gICAqIGxvbmdlciB0aGFuIHtAbGluayBTZXF1ZW5jZSNjb3VudHxjb3VudH0gdGhlIHVubmVlZGVkIGVsZW1lbnRzIGFyZVxuICAgKiBpZ25vcmVkLlxuICAgKlxuICAgKiAqKk5PVEUqKiBJZiB7QGxpbmsgTGF5b3V0I2NvdW50fGNvdW50fSBpcyBhbiBpbnN0YW5jZSBvZiB7QGxpbmtcbiAgICogRXh0ZXJuYWxMYXlvdXR9IHRoZW4gdGhlIGxlbmd0aCBvZiBgc3JjYCB3aWxsIGJlIGVuY29kZWQgYXMgdGhlXG4gICAqIGNvdW50IGFmdGVyIGBzcmNgIGlzIGVuY29kZWQuICovXG4gIGVuY29kZShzcmMsIGIsIG9mZnNldCkge1xuICAgIGlmICh1bmRlZmluZWQgPT09IG9mZnNldCkge1xuICAgICAgb2Zmc2V0ID0gMDtcbiAgICB9XG4gICAgY29uc3QgZWxvID0gdGhpcy5lbGVtZW50TGF5b3V0O1xuICAgIGNvbnN0IHNwYW4gPSBzcmMucmVkdWNlKChzcGFuLCB2KSA9PiB7XG4gICAgICByZXR1cm4gc3BhbiArIGVsby5lbmNvZGUodiwgYiwgb2Zmc2V0ICsgc3Bhbik7XG4gICAgfSwgMCk7XG4gICAgaWYgKHRoaXMuY291bnQgaW5zdGFuY2VvZiBFeHRlcm5hbExheW91dCkge1xuICAgICAgdGhpcy5jb3VudC5lbmNvZGUoc3JjLmxlbmd0aCwgYiwgb2Zmc2V0KTtcbiAgICB9XG4gICAgcmV0dXJuIHNwYW47XG4gIH1cbn1cblxuLyoqXG4gKiBSZXByZXNlbnQgYSBjb250aWd1b3VzIHNlcXVlbmNlIG9mIGFyYml0cmFyeSBsYXlvdXQgZWxlbWVudHMgYXMgYW5cbiAqIE9iamVjdC5cbiAqXG4gKiAqRmFjdG9yeSo6IHtAbGluayBtb2R1bGU6TGF5b3V0LnN0cnVjdHxzdHJ1Y3R9XG4gKlxuICogKipOT1RFKiogVGhlIHtAbGluayBMYXlvdXQjc3BhbnxzcGFufSBvZiB0aGUgc3RydWN0dXJlIGlzIHZhcmlhYmxlXG4gKiBpZiBhbnkgbGF5b3V0IGluIHtAbGluayBTdHJ1Y3R1cmUjZmllbGRzfGZpZWxkc30gaGFzIGEgdmFyaWFibGVcbiAqIHNwYW4uICBXaGVuIHtAbGluayBMYXlvdXQjZW5jb2RlfGVuY29kaW5nfSB3ZSBtdXN0IGhhdmUgYSB2YWx1ZSBmb3JcbiAqIGFsbCB2YXJpYWJsZS1sZW5ndGggZmllbGRzLCBvciB3ZSB3b3VsZG4ndCBiZSBhYmxlIHRvIGZpZ3VyZSBvdXRcbiAqIGhvdyBtdWNoIHNwYWNlIHRvIHVzZSBmb3Igc3RvcmFnZS4gIFdlIGNhbiBvbmx5IGlkZW50aWZ5IHRoZSB2YWx1ZVxuICogZm9yIGEgZmllbGQgd2hlbiBpdCBoYXMgYSB7QGxpbmsgTGF5b3V0I3Byb3BlcnR5fHByb3BlcnR5fS4gIEFzXG4gKiBzdWNoLCBhbHRob3VnaCBhIHN0cnVjdHVyZSBtYXkgY29udGFpbiBib3RoIHVubmFtZWQgZmllbGRzIGFuZFxuICogdmFyaWFibGUtbGVuZ3RoIGZpZWxkcywgaXQgY2Fubm90IGNvbnRhaW4gYW4gdW5uYW1lZFxuICogdmFyaWFibGUtbGVuZ3RoIGZpZWxkLlxuICpcbiAqIEBwYXJhbSB7TGF5b3V0W119IGZpZWxkcyAtIGluaXRpYWxpemVyIGZvciB7QGxpbmtcbiAqIFN0cnVjdHVyZSNmaWVsZHN8ZmllbGRzfS4gIEFuIGVycm9yIGlzIHJhaXNlZCBpZiB0aGlzIGNvbnRhaW5zIGFcbiAqIHZhcmlhYmxlLWxlbmd0aCBmaWVsZCBmb3Igd2hpY2ggYSB7QGxpbmsgTGF5b3V0I3Byb3BlcnR5fHByb3BlcnR5fVxuICogaXMgbm90IGRlZmluZWQuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IFtwcm9wZXJ0eV0gLSBpbml0aWFsaXplciBmb3Ige0BsaW5rXG4gKiBMYXlvdXQjcHJvcGVydHl8cHJvcGVydHl9LlxuICpcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW2RlY29kZVByZWZpeGVzXSAtIGluaXRpYWxpemVyIGZvciB7QGxpbmtcbiAqIFN0cnVjdHVyZSNkZWNvZGVQcmVmaXhlc3xwcm9wZXJ0eX0uXG4gKlxuICogQHRocm93cyB7RXJyb3J9IC0gaWYgYGZpZWxkc2AgY29udGFpbnMgYW4gdW5uYW1lZCB2YXJpYWJsZS1sZW5ndGhcbiAqIGxheW91dC5cbiAqXG4gKiBAYXVnbWVudHMge0xheW91dH1cbiAqL1xuY2xhc3MgU3RydWN0dXJlIGV4dGVuZHMgTGF5b3V0IHtcbiAgY29uc3RydWN0b3IoZmllbGRzLCBwcm9wZXJ0eSwgZGVjb2RlUHJlZml4ZXMpIHtcbiAgICBpZiAoIShBcnJheS5pc0FycmF5KGZpZWxkcylcbiAgICAgICAgICAmJiBmaWVsZHMucmVkdWNlKChhY2MsIHYpID0+IGFjYyAmJiAodiBpbnN0YW5jZW9mIExheW91dCksIHRydWUpKSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignZmllbGRzIG11c3QgYmUgYXJyYXkgb2YgTGF5b3V0IGluc3RhbmNlcycpO1xuICAgIH1cbiAgICBpZiAoKCdib29sZWFuJyA9PT0gdHlwZW9mIHByb3BlcnR5KVxuICAgICAgICAmJiAodW5kZWZpbmVkID09PSBkZWNvZGVQcmVmaXhlcykpIHtcbiAgICAgIGRlY29kZVByZWZpeGVzID0gcHJvcGVydHk7XG4gICAgICBwcm9wZXJ0eSA9IHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICAvKiBWZXJpZnkgYWJzZW5jZSBvZiB1bm5hbWVkIHZhcmlhYmxlLWxlbmd0aCBmaWVsZHMuICovXG4gICAgZm9yIChjb25zdCBmZCBvZiBmaWVsZHMpIHtcbiAgICAgIGlmICgoMCA+IGZkLnNwYW4pXG4gICAgICAgICAgJiYgKHVuZGVmaW5lZCA9PT0gZmQucHJvcGVydHkpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignZmllbGRzIGNhbm5vdCBjb250YWluIHVubmFtZWQgdmFyaWFibGUtbGVuZ3RoIGxheW91dCcpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGxldCBzcGFuID0gLTE7XG4gICAgdHJ5IHtcbiAgICAgIHNwYW4gPSBmaWVsZHMucmVkdWNlKChzcGFuLCBmZCkgPT4gc3BhbiArIGZkLmdldFNwYW4oKSwgMCk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgIH1cbiAgICBzdXBlcihzcGFuLCBwcm9wZXJ0eSk7XG5cbiAgICAvKiogVGhlIHNlcXVlbmNlIG9mIHtAbGluayBMYXlvdXR9IHZhbHVlcyB0aGF0IGNvbXByaXNlIHRoZVxuICAgICAqIHN0cnVjdHVyZS5cbiAgICAgKlxuICAgICAqIFRoZSBpbmRpdmlkdWFsIGVsZW1lbnRzIG5lZWQgbm90IGJlIHRoZSBzYW1lIHR5cGUsIGFuZCBtYXkgYmVcbiAgICAgKiBlaXRoZXIgc2NhbGFyIG9yIGFnZ3JlZ2F0ZSBsYXlvdXRzLiAgSWYgYSBtZW1iZXIgbGF5b3V0IGxlYXZlc1xuICAgICAqIGl0cyB7QGxpbmsgTGF5b3V0I3Byb3BlcnR5fHByb3BlcnR5fSB1bmRlZmluZWQgdGhlXG4gICAgICogY29ycmVzcG9uZGluZyByZWdpb24gb2YgdGhlIGJ1ZmZlciBhc3NvY2lhdGVkIHdpdGggdGhlIGVsZW1lbnRcbiAgICAgKiB3aWxsIG5vdCBiZSBtdXRhdGVkLlxuICAgICAqXG4gICAgICogQHR5cGUge0xheW91dFtdfSAqL1xuICAgIHRoaXMuZmllbGRzID0gZmllbGRzO1xuXG4gICAgLyoqIENvbnRyb2wgYmVoYXZpb3Igb2Yge0BsaW5rIExheW91dCNkZWNvZGV8ZGVjb2RlKCl9IGdpdmVuIHNob3J0XG4gICAgICogYnVmZmVycy5cbiAgICAgKlxuICAgICAqIEluIHNvbWUgc2l0dWF0aW9ucyBhIHN0cnVjdHVyZSBtYW55IGJlIGV4dGVuZGVkIHdpdGggYWRkaXRpb25hbFxuICAgICAqIGZpZWxkcyBvdmVyIHRpbWUsIHdpdGggb2xkZXIgaW5zdGFsbGF0aW9ucyBwcm92aWRpbmcgb25seSBhXG4gICAgICogcHJlZml4IG9mIHRoZSBmdWxsIHN0cnVjdHVyZS4gIElmIHRoaXMgcHJvcGVydHkgaXMgYHRydWVgXG4gICAgICogZGVjb2Rpbmcgd2lsbCBhY2NlcHQgdGhvc2UgYnVmZmVycyBhbmQgbGVhdmUgc3Vic2VxdWVudCBmaWVsZHNcbiAgICAgKiB1bmRlZmluZWQsIGFzIGxvbmcgYXMgdGhlIGJ1ZmZlciBlbmRzIGF0IGEgZmllbGQgYm91bmRhcnkuXG4gICAgICogRGVmYXVsdHMgdG8gYGZhbHNlYC4gKi9cbiAgICB0aGlzLmRlY29kZVByZWZpeGVzID0gISFkZWNvZGVQcmVmaXhlcztcbiAgfVxuXG4gIC8qKiBAb3ZlcnJpZGUgKi9cbiAgZ2V0U3BhbihiLCBvZmZzZXQpIHtcbiAgICBpZiAoMCA8PSB0aGlzLnNwYW4pIHtcbiAgICAgIHJldHVybiB0aGlzLnNwYW47XG4gICAgfVxuICAgIGlmICh1bmRlZmluZWQgPT09IG9mZnNldCkge1xuICAgICAgb2Zmc2V0ID0gMDtcbiAgICB9XG4gICAgbGV0IHNwYW4gPSAwO1xuICAgIHRyeSB7XG4gICAgICBzcGFuID0gdGhpcy5maWVsZHMucmVkdWNlKChzcGFuLCBmZCkgPT4ge1xuICAgICAgICBjb25zdCBmc3AgPSBmZC5nZXRTcGFuKGIsIG9mZnNldCk7XG4gICAgICAgIG9mZnNldCArPSBmc3A7XG4gICAgICAgIHJldHVybiBzcGFuICsgZnNwO1xuICAgICAgfSwgMCk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ2luZGV0ZXJtaW5hdGUgc3BhbicpO1xuICAgIH1cbiAgICByZXR1cm4gc3BhbjtcbiAgfVxuXG4gIC8qKiBAb3ZlcnJpZGUgKi9cbiAgZGVjb2RlKGIsIG9mZnNldCkge1xuICAgIGlmICh1bmRlZmluZWQgPT09IG9mZnNldCkge1xuICAgICAgb2Zmc2V0ID0gMDtcbiAgICB9XG4gICAgY29uc3QgZGVzdCA9IHRoaXMubWFrZURlc3RpbmF0aW9uT2JqZWN0KCk7XG4gICAgZm9yIChjb25zdCBmZCBvZiB0aGlzLmZpZWxkcykge1xuICAgICAgaWYgKHVuZGVmaW5lZCAhPT0gZmQucHJvcGVydHkpIHtcbiAgICAgICAgZGVzdFtmZC5wcm9wZXJ0eV0gPSBmZC5kZWNvZGUoYiwgb2Zmc2V0KTtcbiAgICAgIH1cbiAgICAgIG9mZnNldCArPSBmZC5nZXRTcGFuKGIsIG9mZnNldCk7XG4gICAgICBpZiAodGhpcy5kZWNvZGVQcmVmaXhlc1xuICAgICAgICAgICYmIChiLmxlbmd0aCA9PT0gb2Zmc2V0KSkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGRlc3Q7XG4gIH1cblxuICAvKiogSW1wbGVtZW50IHtAbGluayBMYXlvdXQjZW5jb2RlfGVuY29kZX0gZm9yIHtAbGluayBTdHJ1Y3R1cmV9LlxuICAgKlxuICAgKiBJZiBgc3JjYCBpcyBtaXNzaW5nIGEgcHJvcGVydHkgZm9yIGEgbWVtYmVyIHdpdGggYSBkZWZpbmVkIHtAbGlua1xuICAgKiBMYXlvdXQjcHJvcGVydHl8cHJvcGVydHl9IHRoZSBjb3JyZXNwb25kaW5nIHJlZ2lvbiBvZiB0aGUgYnVmZmVyIGlzXG4gICAqIGxlZnQgdW5tb2RpZmllZC4gKi9cbiAgZW5jb2RlKHNyYywgYiwgb2Zmc2V0KSB7XG4gICAgaWYgKHVuZGVmaW5lZCA9PT0gb2Zmc2V0KSB7XG4gICAgICBvZmZzZXQgPSAwO1xuICAgIH1cbiAgICBjb25zdCBmaXJzdE9mZnNldCA9IG9mZnNldDtcbiAgICBsZXQgbGFzdE9mZnNldCA9IDA7XG4gICAgbGV0IGxhc3RXcm90ZSA9IDA7XG4gICAgZm9yIChjb25zdCBmZCBvZiB0aGlzLmZpZWxkcykge1xuICAgICAgbGV0IHNwYW4gPSBmZC5zcGFuO1xuICAgICAgbGFzdFdyb3RlID0gKDAgPCBzcGFuKSA/IHNwYW4gOiAwO1xuICAgICAgaWYgKHVuZGVmaW5lZCAhPT0gZmQucHJvcGVydHkpIHtcbiAgICAgICAgY29uc3QgZnYgPSBzcmNbZmQucHJvcGVydHldO1xuICAgICAgICBpZiAodW5kZWZpbmVkICE9PSBmdikge1xuICAgICAgICAgIGxhc3RXcm90ZSA9IGZkLmVuY29kZShmdiwgYiwgb2Zmc2V0KTtcbiAgICAgICAgICBpZiAoMCA+IHNwYW4pIHtcbiAgICAgICAgICAgIC8qIFJlYWQgdGhlIGFzLWVuY29kZWQgc3Bhbiwgd2hpY2ggaXMgbm90IG5lY2Vzc2FyaWx5IHRoZVxuICAgICAgICAgICAgICogc2FtZSBhcyB3aGF0IHdlIHdyb3RlLiAqL1xuICAgICAgICAgICAgc3BhbiA9IGZkLmdldFNwYW4oYiwgb2Zmc2V0KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGxhc3RPZmZzZXQgPSBvZmZzZXQ7XG4gICAgICBvZmZzZXQgKz0gc3BhbjtcbiAgICB9XG4gICAgLyogVXNlIChsYXN0T2Zmc2V0ICsgbGFzdFdyb3RlKSBpbnN0ZWFkIG9mIG9mZnNldCBiZWNhdXNlIHRoZSBsYXN0XG4gICAgICogaXRlbSBtYXkgaGF2ZSBoYWQgYSBkeW5hbWljIGxlbmd0aCBhbmQgd2UgZG9uJ3Qgd2FudCB0byBpbmNsdWRlXG4gICAgICogdGhlIHBhZGRpbmcgYmV0d2VlbiBpdCBhbmQgdGhlIGVuZCBvZiB0aGUgc3BhY2UgcmVzZXJ2ZWQgZm9yXG4gICAgICogaXQuICovXG4gICAgcmV0dXJuIChsYXN0T2Zmc2V0ICsgbGFzdFdyb3RlKSAtIGZpcnN0T2Zmc2V0O1xuICB9XG5cbiAgLyoqIEBvdmVycmlkZSAqL1xuICBmcm9tQXJyYXkodmFsdWVzKSB7XG4gICAgY29uc3QgZGVzdCA9IHRoaXMubWFrZURlc3RpbmF0aW9uT2JqZWN0KCk7XG4gICAgZm9yIChjb25zdCBmZCBvZiB0aGlzLmZpZWxkcykge1xuICAgICAgaWYgKCh1bmRlZmluZWQgIT09IGZkLnByb3BlcnR5KVxuICAgICAgICAgICYmICgwIDwgdmFsdWVzLmxlbmd0aCkpIHtcbiAgICAgICAgZGVzdFtmZC5wcm9wZXJ0eV0gPSB2YWx1ZXMuc2hpZnQoKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGRlc3Q7XG4gIH1cblxuICAvKipcbiAgICogR2V0IGFjY2VzcyB0byB0aGUgbGF5b3V0IG9mIGEgZ2l2ZW4gcHJvcGVydHkuXG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBwcm9wZXJ0eSAtIHRoZSBzdHJ1Y3R1cmUgbWVtYmVyIG9mIGludGVyZXN0LlxuICAgKlxuICAgKiBAcmV0dXJuIHtMYXlvdXR9IC0gdGhlIGxheW91dCBhc3NvY2lhdGVkIHdpdGggYHByb3BlcnR5YCwgb3JcbiAgICogdW5kZWZpbmVkIGlmIHRoZXJlIGlzIG5vIHN1Y2ggcHJvcGVydHkuXG4gICAqL1xuICBsYXlvdXRGb3IocHJvcGVydHkpIHtcbiAgICBpZiAoJ3N0cmluZycgIT09IHR5cGVvZiBwcm9wZXJ0eSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcigncHJvcGVydHkgbXVzdCBiZSBzdHJpbmcnKTtcbiAgICB9XG4gICAgZm9yIChjb25zdCBmZCBvZiB0aGlzLmZpZWxkcykge1xuICAgICAgaWYgKGZkLnByb3BlcnR5ID09PSBwcm9wZXJ0eSkge1xuICAgICAgICByZXR1cm4gZmQ7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgb2Zmc2V0IG9mIGEgc3RydWN0dXJlIG1lbWJlci5cbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd9IHByb3BlcnR5IC0gdGhlIHN0cnVjdHVyZSBtZW1iZXIgb2YgaW50ZXJlc3QuXG4gICAqXG4gICAqIEByZXR1cm4ge051bWJlcn0gLSB0aGUgb2Zmc2V0IGluIGJ5dGVzIHRvIHRoZSBzdGFydCBvZiBgcHJvcGVydHlgXG4gICAqIHdpdGhpbiB0aGUgc3RydWN0dXJlLCBvciB1bmRlZmluZWQgaWYgYHByb3BlcnR5YCBpcyBub3QgYSBmaWVsZFxuICAgKiB3aXRoaW4gdGhlIHN0cnVjdHVyZS4gIElmIHRoZSBwcm9wZXJ0eSBpcyBhIG1lbWJlciBidXQgZm9sbG93cyBhXG4gICAqIHZhcmlhYmxlLWxlbmd0aCBzdHJ1Y3R1cmUgbWVtYmVyIGEgbmVnYXRpdmUgbnVtYmVyIHdpbGwgYmVcbiAgICogcmV0dXJuZWQuXG4gICAqL1xuICBvZmZzZXRPZihwcm9wZXJ0eSkge1xuICAgIGlmICgnc3RyaW5nJyAhPT0gdHlwZW9mIHByb3BlcnR5KSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdwcm9wZXJ0eSBtdXN0IGJlIHN0cmluZycpO1xuICAgIH1cbiAgICBsZXQgb2Zmc2V0ID0gMDtcbiAgICBmb3IgKGNvbnN0IGZkIG9mIHRoaXMuZmllbGRzKSB7XG4gICAgICBpZiAoZmQucHJvcGVydHkgPT09IHByb3BlcnR5KSB7XG4gICAgICAgIHJldHVybiBvZmZzZXQ7XG4gICAgICB9XG4gICAgICBpZiAoMCA+IGZkLnNwYW4pIHtcbiAgICAgICAgb2Zmc2V0ID0gLTE7XG4gICAgICB9IGVsc2UgaWYgKDAgPD0gb2Zmc2V0KSB7XG4gICAgICAgIG9mZnNldCArPSBmZC5zcGFuO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIEFuIG9iamVjdCB0aGF0IGNhbiBwcm92aWRlIGEge0BsaW5rXG4gKiBVbmlvbiNkaXNjcmltaW5hdG9yfGRpc2NyaW1pbmF0b3J9IEFQSSBmb3Ige0BsaW5rIFVuaW9ufS5cbiAqXG4gKiAqKk5PVEUqKiBUaGlzIGlzIGFuIGFic3RyYWN0IGJhc2UgY2xhc3M7IHlvdSBjYW4gY3JlYXRlIGluc3RhbmNlc1xuICogaWYgaXQgYW11c2VzIHlvdSwgYnV0IHRoZXkgd29uJ3Qgc3VwcG9ydCB0aGUge0BsaW5rXG4gKiBVbmlvbkRpc2NyaW1pbmF0b3IjZW5jb2RlfGVuY29kZX0gb3Ige0BsaW5rXG4gKiBVbmlvbkRpc2NyaW1pbmF0b3IjZGVjb2RlfGRlY29kZX0gZnVuY3Rpb25zLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBbcHJvcGVydHldIC0gRGVmYXVsdCBmb3Ige0BsaW5rXG4gKiBVbmlvbkRpc2NyaW1pbmF0b3IjcHJvcGVydHl8cHJvcGVydHl9LlxuICpcbiAqIEBhYnN0cmFjdFxuICovXG5jbGFzcyBVbmlvbkRpc2NyaW1pbmF0b3Ige1xuICBjb25zdHJ1Y3Rvcihwcm9wZXJ0eSkge1xuICAgIC8qKiBUaGUge0BsaW5rIExheW91dCNwcm9wZXJ0eXxwcm9wZXJ0eX0gdG8gYmUgdXNlZCB3aGVuIHRoZVxuICAgICAqIGRpc2NyaW1pbmF0b3IgaXMgcmVmZXJlbmNlZCBpbiBpc29sYXRpb24gKGdlbmVyYWxseSB3aGVuIHtAbGlua1xuICAgICAqIFVuaW9uI2RlY29kZXxVbmlvbiBkZWNvZGV9IGNhbm5vdCBkZWxlZ2F0ZSB0byBhIHNwZWNpZmljXG4gICAgICogdmFyaWFudCkuICovXG4gICAgdGhpcy5wcm9wZXJ0eSA9IHByb3BlcnR5O1xuICB9XG5cbiAgLyoqIEFuYWxvZyB0byB7QGxpbmsgTGF5b3V0I2RlY29kZXxMYXlvdXQgZGVjb2RlfSBmb3IgdW5pb24gZGlzY3JpbWluYXRvcnMuXG4gICAqXG4gICAqIFRoZSBpbXBsZW1lbnRhdGlvbiBvZiB0aGlzIG1ldGhvZCBuZWVkIG5vdCByZWZlcmVuY2UgdGhlIGJ1ZmZlciBpZlxuICAgKiB2YXJpYW50IGluZm9ybWF0aW9uIGlzIGF2YWlsYWJsZSB0aHJvdWdoIG90aGVyIG1lYW5zLiAqL1xuICBkZWNvZGUoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdVbmlvbkRpc2NyaW1pbmF0b3IgaXMgYWJzdHJhY3QnKTtcbiAgfVxuXG4gIC8qKiBBbmFsb2cgdG8ge0BsaW5rIExheW91dCNkZWNvZGV8TGF5b3V0IGVuY29kZX0gZm9yIHVuaW9uIGRpc2NyaW1pbmF0b3JzLlxuICAgKlxuICAgKiBUaGUgaW1wbGVtZW50YXRpb24gb2YgdGhpcyBtZXRob2QgbmVlZCBub3Qgc3RvcmUgdGhlIHZhbHVlIGlmXG4gICAqIHZhcmlhbnQgaW5mb3JtYXRpb24gaXMgbWFpbnRhaW5lZCB0aHJvdWdoIG90aGVyIG1lYW5zLiAqL1xuICBlbmNvZGUoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdVbmlvbkRpc2NyaW1pbmF0b3IgaXMgYWJzdHJhY3QnKTtcbiAgfVxufVxuXG4vKipcbiAqIEFuIG9iamVjdCB0aGF0IGNhbiBwcm92aWRlIGEge0BsaW5rXG4gKiBVbmlvbkRpc2NyaW1pbmF0b3J8ZGlzY3JpbWluYXRvciBBUEl9IGZvciB7QGxpbmsgVW5pb259IHVzaW5nIGFuXG4gKiB1bnNpZ25lZCBpbnRlZ3JhbCB7QGxpbmsgTGF5b3V0fSBpbnN0YW5jZSBsb2NhdGVkIGVpdGhlciBpbnNpZGUgb3JcbiAqIG91dHNpZGUgdGhlIHVuaW9uLlxuICpcbiAqIEBwYXJhbSB7RXh0ZXJuYWxMYXlvdXR9IGxheW91dCAtIGluaXRpYWxpemVzIHtAbGlua1xuICogVW5pb25MYXlvdXREaXNjcmltaW5hdG9yI2xheW91dHxsYXlvdXR9LiAgTXVzdCBzYXRpc2Z5IHtAbGlua1xuICogRXh0ZXJuYWxMYXlvdXQjaXNDb3VudHxpc0NvdW50KCl9LlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBbcHJvcGVydHldIC0gRGVmYXVsdCBmb3Ige0BsaW5rXG4gKiBVbmlvbkRpc2NyaW1pbmF0b3IjcHJvcGVydHl8cHJvcGVydHl9LCBzdXBlcnNlZGluZyB0aGUgcHJvcGVydHlcbiAqIGZyb20gYGxheW91dGAsIGJ1dCBkZWZhdWx0aW5nIHRvIGB2YXJpYW50YCBpZiBuZWl0aGVyIGBwcm9wZXJ0eWBcbiAqIG5vciBsYXlvdXQgcHJvdmlkZSBhIHByb3BlcnR5IG5hbWUuXG4gKlxuICogQGF1Z21lbnRzIHtVbmlvbkRpc2NyaW1pbmF0b3J9XG4gKi9cbmNsYXNzIFVuaW9uTGF5b3V0RGlzY3JpbWluYXRvciBleHRlbmRzIFVuaW9uRGlzY3JpbWluYXRvciB7XG4gIGNvbnN0cnVjdG9yKGxheW91dCwgcHJvcGVydHkpIHtcbiAgICBpZiAoISgobGF5b3V0IGluc3RhbmNlb2YgRXh0ZXJuYWxMYXlvdXQpXG4gICAgICAgICAgJiYgbGF5b3V0LmlzQ291bnQoKSkpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2xheW91dCBtdXN0IGJlIGFuIHVuc2lnbmVkIGludGVnZXIgRXh0ZXJuYWxMYXlvdXQnKTtcbiAgICB9XG5cbiAgICBzdXBlcihwcm9wZXJ0eSB8fCBsYXlvdXQucHJvcGVydHkgfHwgJ3ZhcmlhbnQnKTtcblxuICAgIC8qKiBUaGUge0BsaW5rIEV4dGVybmFsTGF5b3V0fSB1c2VkIHRvIGFjY2VzcyB0aGUgZGlzY3JpbWluYXRvclxuICAgICAqIHZhbHVlLiAqL1xuICAgIHRoaXMubGF5b3V0ID0gbGF5b3V0O1xuICB9XG5cbiAgLyoqIERlbGVnYXRlIGRlY29kaW5nIHRvIHtAbGluayBVbmlvbkxheW91dERpc2NyaW1pbmF0b3IjbGF5b3V0fGxheW91dH0uICovXG4gIGRlY29kZShiLCBvZmZzZXQpIHtcbiAgICByZXR1cm4gdGhpcy5sYXlvdXQuZGVjb2RlKGIsIG9mZnNldCk7XG4gIH1cblxuICAvKiogRGVsZWdhdGUgZW5jb2RpbmcgdG8ge0BsaW5rIFVuaW9uTGF5b3V0RGlzY3JpbWluYXRvciNsYXlvdXR8bGF5b3V0fS4gKi9cbiAgZW5jb2RlKHNyYywgYiwgb2Zmc2V0KSB7XG4gICAgcmV0dXJuIHRoaXMubGF5b3V0LmVuY29kZShzcmMsIGIsIG9mZnNldCk7XG4gIH1cbn1cblxuLyoqXG4gKiBSZXByZXNlbnQgYW55IG51bWJlciBvZiBzcGFuLWNvbXBhdGlibGUgbGF5b3V0cy5cbiAqXG4gKiAqRmFjdG9yeSo6IHtAbGluayBtb2R1bGU6TGF5b3V0LnVuaW9ufHVuaW9ufVxuICpcbiAqIElmIHRoZSB1bmlvbiBoYXMgYSB7QGxpbmsgVW5pb24jZGVmYXVsdExheW91dHxkZWZhdWx0IGxheW91dH0gdGhhdFxuICogbGF5b3V0IG11c3QgaGF2ZSBhIG5vbi1uZWdhdGl2ZSB7QGxpbmsgTGF5b3V0I3NwYW58c3Bhbn0uICBUaGUgc3BhblxuICogb2YgYSBmaXhlZC1zcGFuIHVuaW9uIGluY2x1ZGVzIGl0cyB7QGxpbmtcbiAqIFVuaW9uI2Rpc2NyaW1pbmF0b3J8ZGlzY3JpbWluYXRvcn0gaWYgdGhlIHZhcmlhbnQgaXMgYSB7QGxpbmtcbiAqIFVuaW9uI3VzZXNQcmVmaXhEaXNjcmltaW5hdG9yfHByZWZpeCBvZiB0aGUgdW5pb259LCBwbHVzIHRoZSBzcGFuXG4gKiBvZiBpdHMge0BsaW5rIFVuaW9uI2RlZmF1bHRMYXlvdXR8ZGVmYXVsdCBsYXlvdXR9LlxuICpcbiAqIElmIHRoZSB1bmlvbiBkb2VzIG5vdCBoYXZlIGEgZGVmYXVsdCBsYXlvdXQgdGhlbiB0aGUgZW5jb2RlZCBzcGFuXG4gKiBvZiB0aGUgdW5pb24gZGVwZW5kcyBvbiB0aGUgZW5jb2RlZCBzcGFuIG9mIGl0cyB2YXJpYW50ICh3aGljaCBtYXlcbiAqIGJlIGZpeGVkIG9yIHZhcmlhYmxlKS5cbiAqXG4gKiB7QGxpbmsgVmFyaWFudExheW91dCNsYXlvdXR8VmFyaWFudCBsYXlvdXR9cyBhcmUgYWRkZWQgdGhyb3VnaFxuICoge0BsaW5rIFVuaW9uI2FkZFZhcmlhbnR8YWRkVmFyaWFudH0uICBJZiB0aGUgdW5pb24gaGFzIGEgZGVmYXVsdFxuICogbGF5b3V0LCB0aGUgc3BhbiBvZiB0aGUge0BsaW5rIFZhcmlhbnRMYXlvdXQjbGF5b3V0fGxheW91dFxuICogY29udGFpbmVkIGJ5IHRoZSB2YXJpYW50fSBtdXN0IG5vdCBleGNlZWQgdGhlIHNwYW4gb2YgdGhlIHtAbGlua1xuICogVW5pb24jZGVmYXVsdExheW91dHxkZWZhdWx0IGxheW91dH0gKG1pbnVzIHRoZSBzcGFuIG9mIGEge0BsaW5rXG4gKiBVbmlvbiN1c2VzUHJlZml4RGlzY3JpbWluYXRvcnxwcmVmaXggZGlzcmltaW5hdG9yfSwgaWYgdXNlZCkuICBUaGVcbiAqIHNwYW4gb2YgdGhlIHZhcmlhbnQgd2lsbCBlcXVhbCB0aGUgc3BhbiBvZiB0aGUgdW5pb24gaXRzZWxmLlxuICpcbiAqIFRoZSB2YXJpYW50IGZvciBhIGJ1ZmZlciBjYW4gb25seSBiZSBpZGVudGlmaWVkIGZyb20gdGhlIHtAbGlua1xuICogVW5pb24jZGlzY3JpbWluYXRvcnxkaXNjcmltaW5hdG9yfSB7QGxpbmtcbiAqIFVuaW9uRGlzY3JpbWluYXRvciNwcm9wZXJ0eXxwcm9wZXJ0eX0gKGluIHRoZSBjYXNlIG9mIHRoZSB7QGxpbmtcbiAqIFVuaW9uI2RlZmF1bHRMYXlvdXR8ZGVmYXVsdCBsYXlvdXR9KSwgb3IgYnkgdXNpbmcge0BsaW5rXG4gKiBVbmlvbiNnZXRWYXJpYW50fGdldFZhcmlhbnR9IGFuZCBleGFtaW5pbmcgdGhlIHJlc3VsdGluZyB7QGxpbmtcbiAqIFZhcmlhbnRMYXlvdXR9IGluc3RhbmNlLlxuICpcbiAqIEEgdmFyaWFudCBjb21wYXRpYmxlIHdpdGggYSBKYXZhU2NyaXB0IG9iamVjdCBjYW4gYmUgaWRlbnRpZmllZFxuICogdXNpbmcge0BsaW5rIFVuaW9uI2dldFNvdXJjZVZhcmlhbnR8Z2V0U291cmNlVmFyaWFudH0uXG4gKlxuICogQHBhcmFtIHsoVW5pb25EaXNjcmltaW5hdG9yfEV4dGVybmFsTGF5b3V0fExheW91dCl9IGRpc2NyIC0gSG93IHRvXG4gKiBpZGVudGlmeSB0aGUgbGF5b3V0IHVzZWQgdG8gaW50ZXJwcmV0IHRoZSB1bmlvbiBjb250ZW50cy4gIFRoZVxuICogcGFyYW1ldGVyIG11c3QgYmUgYW4gaW5zdGFuY2Ugb2Yge0BsaW5rIFVuaW9uRGlzY3JpbWluYXRvcn0sIGFuXG4gKiB7QGxpbmsgRXh0ZXJuYWxMYXlvdXR9IHRoYXQgc2F0aXNmaWVzIHtAbGlua1xuICogRXh0ZXJuYWxMYXlvdXQjaXNDb3VudHxpc0NvdW50KCl9LCBvciB7QGxpbmsgVUludH0gKG9yIHtAbGlua1xuICogVUludEJFfSkuICBXaGVuIGEgbm9uLWV4dGVybmFsIGxheW91dCBlbGVtZW50IGlzIHBhc3NlZCB0aGUgbGF5b3V0XG4gKiBhcHBlYXJzIGF0IHRoZSBzdGFydCBvZiB0aGUgdW5pb24uICBJbiBhbGwgY2FzZXMgdGhlIChzeW50aGVzaXplZClcbiAqIHtAbGluayBVbmlvbkRpc2NyaW1pbmF0b3J9IGluc3RhbmNlIGlzIHJlY29yZGVkIGFzIHtAbGlua1xuICogVW5pb24jZGlzY3JpbWluYXRvcnxkaXNjcmltaW5hdG9yfS5cbiAqXG4gKiBAcGFyYW0geyhMYXlvdXR8bnVsbCl9IGRlZmF1bHRMYXlvdXQgLSBpbml0aWFsaXplciBmb3Ige0BsaW5rXG4gKiBVbmlvbiNkZWZhdWx0TGF5b3V0fGRlZmF1bHRMYXlvdXR9LiAgSWYgYWJzZW50IGRlZmF1bHRzIHRvIGBudWxsYC5cbiAqIElmIGBudWxsYCB0aGVyZSBpcyBubyBkZWZhdWx0IGxheW91dDogdGhlIHVuaW9uIGhhcyBkYXRhLWRlcGVuZGVudFxuICogbGVuZ3RoIGFuZCBhdHRlbXB0cyB0byBkZWNvZGUgb3IgZW5jb2RlIHVucmVjb2duaXplZCB2YXJpYW50cyB3aWxsXG4gKiB0aHJvdyBhbiBleGNlcHRpb24uICBBIHtAbGluayBMYXlvdXR9IGluc3RhbmNlIG11c3QgaGF2ZSBhXG4gKiBub24tbmVnYXRpdmUge0BsaW5rIExheW91dCNzcGFufHNwYW59LCBhbmQgaWYgaXQgbGFja3MgYSB7QGxpbmtcbiAqIExheW91dCNwcm9wZXJ0eXxwcm9wZXJ0eX0gdGhlIHtAbGlua1xuICogVW5pb24jZGVmYXVsdExheW91dHxkZWZhdWx0TGF5b3V0fSB3aWxsIGJlIGEge0BsaW5rXG4gKiBMYXlvdXQjcmVwbGljYXRlfHJlcGxpY2F9IHdpdGggcHJvcGVydHkgYGNvbnRlbnRgLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBbcHJvcGVydHldIC0gaW5pdGlhbGl6ZXIgZm9yIHtAbGlua1xuICogTGF5b3V0I3Byb3BlcnR5fHByb3BlcnR5fS5cbiAqXG4gKiBAYXVnbWVudHMge0xheW91dH1cbiAqL1xuY2xhc3MgVW5pb24gZXh0ZW5kcyBMYXlvdXQge1xuICBjb25zdHJ1Y3RvcihkaXNjciwgZGVmYXVsdExheW91dCwgcHJvcGVydHkpIHtcbiAgICBjb25zdCB1cHYgPSAoKGRpc2NyIGluc3RhbmNlb2YgVUludClcbiAgICAgICAgICAgICAgIHx8IChkaXNjciBpbnN0YW5jZW9mIFVJbnRCRSkpO1xuICAgIGlmICh1cHYpIHtcbiAgICAgIGRpc2NyID0gbmV3IFVuaW9uTGF5b3V0RGlzY3JpbWluYXRvcihuZXcgT2Zmc2V0TGF5b3V0KGRpc2NyKSk7XG4gICAgfSBlbHNlIGlmICgoZGlzY3IgaW5zdGFuY2VvZiBFeHRlcm5hbExheW91dClcbiAgICAgICAgICAgICAgICYmIGRpc2NyLmlzQ291bnQoKSkge1xuICAgICAgZGlzY3IgPSBuZXcgVW5pb25MYXlvdXREaXNjcmltaW5hdG9yKGRpc2NyKTtcbiAgICB9IGVsc2UgaWYgKCEoZGlzY3IgaW5zdGFuY2VvZiBVbmlvbkRpc2NyaW1pbmF0b3IpKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdkaXNjciBtdXN0IGJlIGEgVW5pb25EaXNjcmltaW5hdG9yICdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgKyAnb3IgYW4gdW5zaWduZWQgaW50ZWdlciBsYXlvdXQnKTtcbiAgICB9XG4gICAgaWYgKHVuZGVmaW5lZCA9PT0gZGVmYXVsdExheW91dCkge1xuICAgICAgZGVmYXVsdExheW91dCA9IG51bGw7XG4gICAgfVxuICAgIGlmICghKChudWxsID09PSBkZWZhdWx0TGF5b3V0KVxuICAgICAgICAgIHx8IChkZWZhdWx0TGF5b3V0IGluc3RhbmNlb2YgTGF5b3V0KSkpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2RlZmF1bHRMYXlvdXQgbXVzdCBiZSBudWxsIG9yIGEgTGF5b3V0Jyk7XG4gICAgfVxuICAgIGlmIChudWxsICE9PSBkZWZhdWx0TGF5b3V0KSB7XG4gICAgICBpZiAoMCA+IGRlZmF1bHRMYXlvdXQuc3Bhbikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2RlZmF1bHRMYXlvdXQgbXVzdCBoYXZlIGNvbnN0YW50IHNwYW4nKTtcbiAgICAgIH1cbiAgICAgIGlmICh1bmRlZmluZWQgPT09IGRlZmF1bHRMYXlvdXQucHJvcGVydHkpIHtcbiAgICAgICAgZGVmYXVsdExheW91dCA9IGRlZmF1bHRMYXlvdXQucmVwbGljYXRlKCdjb250ZW50Jyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyogVGhlIHVuaW9uIHNwYW4gY2FuIGJlIGVzdGltYXRlZCBvbmx5IGlmIHRoZXJlJ3MgYSBkZWZhdWx0XG4gICAgICogbGF5b3V0LiAgVGhlIHVuaW9uIHNwYW5zIGl0cyBkZWZhdWx0IGxheW91dCwgcGx1cyBhbnkgcHJlZml4XG4gICAgICogdmFyaWFudCBsYXlvdXQuICBCeSBjb25zdHJ1Y3Rpb24gYm90aCBsYXlvdXRzLCBpZiBwcmVzZW50LCBoYXZlXG4gICAgICogbm9uLW5lZ2F0aXZlIHNwYW4uICovXG4gICAgbGV0IHNwYW4gPSAtMTtcbiAgICBpZiAoZGVmYXVsdExheW91dCkge1xuICAgICAgc3BhbiA9IGRlZmF1bHRMYXlvdXQuc3BhbjtcbiAgICAgIGlmICgoMCA8PSBzcGFuKSAmJiB1cHYpIHtcbiAgICAgICAgc3BhbiArPSBkaXNjci5sYXlvdXQuc3BhbjtcbiAgICAgIH1cbiAgICB9XG4gICAgc3VwZXIoc3BhbiwgcHJvcGVydHkpO1xuXG4gICAgLyoqIFRoZSBpbnRlcmZhY2UgZm9yIHRoZSBkaXNjcmltaW5hdG9yIHZhbHVlIGluIGlzb2xhdGlvbi5cbiAgICAgKlxuICAgICAqIFRoaXMgYSB7QGxpbmsgVW5pb25EaXNjcmltaW5hdG9yfSBlaXRoZXIgcGFzc2VkIHRvIHRoZVxuICAgICAqIGNvbnN0cnVjdG9yIG9yIHN5bnRoZXNpemVkIGZyb20gdGhlIGBkaXNjcmAgY29uc3RydWN0b3JcbiAgICAgKiBhcmd1bWVudC4gIHtAbGlua1xuICAgICAqIFVuaW9uI3VzZXNQcmVmaXhEaXNjcmltaW5hdG9yfHVzZXNQcmVmaXhEaXNjcmltaW5hdG9yfSB3aWxsIGJlXG4gICAgICogYHRydWVgIGlmZiB0aGUgYGRpc2NyYCBwYXJhbWV0ZXIgd2FzIGEgbm9uLW9mZnNldCB7QGxpbmtcbiAgICAgKiBMYXlvdXR9IGluc3RhbmNlLiAqL1xuICAgIHRoaXMuZGlzY3JpbWluYXRvciA9IGRpc2NyO1xuXG4gICAgLyoqIGB0cnVlYCBpZiB0aGUge0BsaW5rIFVuaW9uI2Rpc2NyaW1pbmF0b3J8ZGlzY3JpbWluYXRvcn0gaXMgdGhlXG4gICAgICogZmlyc3QgZmllbGQgaW4gdGhlIHVuaW9uLlxuICAgICAqXG4gICAgICogSWYgYGZhbHNlYCB0aGUgZGlzY3JpbWluYXRvciBpcyBvYnRhaW5lZCBmcm9tIHNvbWV3aGVyZVxuICAgICAqIGVsc2UuICovXG4gICAgdGhpcy51c2VzUHJlZml4RGlzY3JpbWluYXRvciA9IHVwdjtcblxuICAgIC8qKiBUaGUgbGF5b3V0IGZvciBub24tZGlzY3JpbWluYXRvciBjb250ZW50IHdoZW4gdGhlIHZhbHVlIG9mIHRoZVxuICAgICAqIGRpc2NyaW1pbmF0b3IgaXMgbm90IHJlY29nbml6ZWQuXG4gICAgICpcbiAgICAgKiBUaGlzIGlzIHRoZSB2YWx1ZSBwYXNzZWQgdG8gdGhlIGNvbnN0cnVjdG9yLiAgSXQgaXNcbiAgICAgKiBzdHJ1Y3R1cmFsbHkgZXF1aXZhbGVudCB0byB0aGUgc2Vjb25kIGNvbXBvbmVudCBvZiB7QGxpbmtcbiAgICAgKiBVbmlvbiNsYXlvdXR8bGF5b3V0fSBidXQgbWF5IGhhdmUgYSBkaWZmZXJlbnQgcHJvcGVydHlcbiAgICAgKiBuYW1lLiAqL1xuICAgIHRoaXMuZGVmYXVsdExheW91dCA9IGRlZmF1bHRMYXlvdXQ7XG5cbiAgICAvKiogQSByZWdpc3RyeSBvZiBhbGxvd2VkIHZhcmlhbnRzLlxuICAgICAqXG4gICAgICogVGhlIGtleXMgYXJlIHVuc2lnbmVkIGludGVnZXJzIHdoaWNoIHNob3VsZCBiZSBjb21wYXRpYmxlIHdpdGhcbiAgICAgKiB7QGxpbmsgVW5pb24uZGlzY3JpbWluYXRvcnxkaXNjcmltaW5hdG9yfS4gIFRoZSBwcm9wZXJ0eSB2YWx1ZVxuICAgICAqIGlzIHRoZSBjb3JyZXNwb25kaW5nIHtAbGluayBWYXJpYW50TGF5b3V0fSBpbnN0YW5jZXMgYXNzaWduZWRcbiAgICAgKiB0byB0aGlzIHVuaW9uIGJ5IHtAbGluayBVbmlvbiNhZGRWYXJpYW50fGFkZFZhcmlhbnR9LlxuICAgICAqXG4gICAgICogKipOT1RFKiogVGhlIHJlZ2lzdHJ5IHJlbWFpbnMgbXV0YWJsZSBzbyB0aGF0IHZhcmlhbnRzIGNhbiBiZVxuICAgICAqIHtAbGluayBVbmlvbiNhZGRWYXJpYW50fGFkZGVkfSBhdCBhbnkgdGltZS4gIFVzZXJzIHNob3VsZCBub3RcbiAgICAgKiBtYW5pcHVsYXRlIHRoZSBjb250ZW50IG9mIHRoaXMgcHJvcGVydHkuICovXG4gICAgdGhpcy5yZWdpc3RyeSA9IHt9O1xuXG4gICAgLyogUHJpdmF0ZSB2YXJpYWJsZSB1c2VkIHdoZW4gaW52b2tpbmcgZ2V0U291cmNlVmFyaWFudCAqL1xuICAgIGxldCBib3VuZEdldFNvdXJjZVZhcmlhbnQgPSB0aGlzLmRlZmF1bHRHZXRTb3VyY2VWYXJpYW50LmJpbmQodGhpcyk7XG5cbiAgICAvKiogRnVuY3Rpb24gdG8gaW5mZXIgdGhlIHZhcmlhbnQgc2VsZWN0ZWQgYnkgYSBzb3VyY2Ugb2JqZWN0LlxuICAgICAqXG4gICAgICogRGVmYXVsdHMgdG8ge0BsaW5rXG4gICAgICogVW5pb24jZGVmYXVsdEdldFNvdXJjZVZhcmlhbnR8ZGVmYXVsdEdldFNvdXJjZVZhcmlhbnR9IGJ1dCBtYXlcbiAgICAgKiBiZSBvdmVycmlkZGVuIHVzaW5nIHtAbGlua1xuICAgICAqIFVuaW9uI2NvbmZpZ0dldFNvdXJjZVZhcmlhbnR8Y29uZmlnR2V0U291cmNlVmFyaWFudH0uXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gc3JjIC0gYXMgd2l0aCB7QGxpbmtcbiAgICAgKiBVbmlvbiNkZWZhdWx0R2V0U291cmNlVmFyaWFudHxkZWZhdWx0R2V0U291cmNlVmFyaWFudH0uXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7KHVuZGVmaW5lZHxWYXJpYW50TGF5b3V0KX0gVGhlIGRlZmF1bHQgdmFyaWFudFxuICAgICAqIChgdW5kZWZpbmVkYCkgb3IgZmlyc3QgcmVnaXN0ZXJlZCB2YXJpYW50IHRoYXQgdXNlcyBhIHByb3BlcnR5XG4gICAgICogYXZhaWxhYmxlIGluIGBzcmNgLiAqL1xuICAgIHRoaXMuZ2V0U291cmNlVmFyaWFudCA9IGZ1bmN0aW9uKHNyYykge1xuICAgICAgcmV0dXJuIGJvdW5kR2V0U291cmNlVmFyaWFudChzcmMpO1xuICAgIH07XG5cbiAgICAvKiogRnVuY3Rpb24gdG8gb3ZlcnJpZGUgdGhlIGltcGxlbWVudGF0aW9uIG9mIHtAbGlua1xuICAgICAqIFVuaW9uI2dldFNvdXJjZVZhcmlhbnR8Z2V0U291cmNlVmFyaWFudH0uXG4gICAgICpcbiAgICAgKiBVc2UgdGhpcyBpZiB0aGUgZGVzaXJlZCB2YXJpYW50IGNhbm5vdCBiZSBpZGVudGlmaWVkIHVzaW5nIHRoZVxuICAgICAqIGFsZ29yaXRobSBvZiB7QGxpbmtcbiAgICAgKiBVbmlvbiNkZWZhdWx0R2V0U291cmNlVmFyaWFudHxkZWZhdWx0R2V0U291cmNlVmFyaWFudH0uXG4gICAgICpcbiAgICAgKiAqKk5PVEUqKiBUaGUgcHJvdmlkZWQgZnVuY3Rpb24gd2lsbCBiZSBpbnZva2VkIGJvdW5kIHRvIHRoaXNcbiAgICAgKiBVbmlvbiBpbnN0YW5jZSwgcHJvdmlkaW5nIGxvY2FsIGFjY2VzcyB0byB7QGxpbmtcbiAgICAgKiBVbmlvbiNyZWdpc3RyeXxyZWdpc3RyeX0uXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBnc3YgLSBhIGZ1bmN0aW9uIHRoYXQgZm9sbG93cyB0aGUgQVBJIG9mXG4gICAgICoge0BsaW5rIFVuaW9uI2RlZmF1bHRHZXRTb3VyY2VWYXJpYW50fGRlZmF1bHRHZXRTb3VyY2VWYXJpYW50fS4gKi9cbiAgICB0aGlzLmNvbmZpZ0dldFNvdXJjZVZhcmlhbnQgPSBmdW5jdGlvbihnc3YpIHtcbiAgICAgIGJvdW5kR2V0U291cmNlVmFyaWFudCA9IGdzdi5iaW5kKHRoaXMpO1xuICAgIH07XG4gIH1cblxuICAvKiogQG92ZXJyaWRlICovXG4gIGdldFNwYW4oYiwgb2Zmc2V0KSB7XG4gICAgaWYgKDAgPD0gdGhpcy5zcGFuKSB7XG4gICAgICByZXR1cm4gdGhpcy5zcGFuO1xuICAgIH1cbiAgICBpZiAodW5kZWZpbmVkID09PSBvZmZzZXQpIHtcbiAgICAgIG9mZnNldCA9IDA7XG4gICAgfVxuICAgIC8qIERlZmF1bHQgbGF5b3V0cyBhbHdheXMgaGF2ZSBub24tbmVnYXRpdmUgc3Bhbiwgc28gd2UgZG9uJ3QgaGF2ZVxuICAgICAqIG9uZSBhbmQgd2UgaGF2ZSB0byByZWNvZ25pemUgdGhlIHZhcmlhbnQgd2hpY2ggd2lsbCBpbiB0dXJuXG4gICAgICogZGV0ZXJtaW5lIHRoZSBzcGFuLiAqL1xuICAgIGNvbnN0IHZsbyA9IHRoaXMuZ2V0VmFyaWFudChiLCBvZmZzZXQpO1xuICAgIGlmICghdmxvKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ3VuYWJsZSB0byBkZXRlcm1pbmUgc3BhbiBmb3IgdW5yZWNvZ25pemVkIHZhcmlhbnQnKTtcbiAgICB9XG4gICAgcmV0dXJuIHZsby5nZXRTcGFuKGIsIG9mZnNldCk7XG4gIH1cblxuICAvKipcbiAgICogTWV0aG9kIHRvIGluZmVyIGEgcmVnaXN0ZXJlZCBVbmlvbiB2YXJpYW50IGNvbXBhdGlibGUgd2l0aCBgc3JjYC5cbiAgICpcbiAgICogVGhlIGZpcnN0IHNhdGlzaWZpZWQgcnVsZSBpbiB0aGUgZm9sbG93aW5nIHNlcXVlbmNlIGRlZmluZXMgdGhlXG4gICAqIHJldHVybiB2YWx1ZTpcbiAgICogKiBJZiBgc3JjYCBoYXMgcHJvcGVydGllcyBtYXRjaGluZyB0aGUgVW5pb24gZGlzY3JpbWluYXRvciBhbmRcbiAgICogICB0aGUgZGVmYXVsdCBsYXlvdXQsIGB1bmRlZmluZWRgIGlzIHJldHVybmVkIHJlZ2FyZGxlc3Mgb2YgdGhlXG4gICAqICAgdmFsdWUgb2YgdGhlIGRpc2NyaW1pbmF0b3IgcHJvcGVydHkgKHRoaXMgZW5zdXJlcyB0aGUgZGVmYXVsdFxuICAgKiAgIGxheW91dCB3aWxsIGJlIHVzZWQpO1xuICAgKiAqIElmIGBzcmNgIGhhcyBhIHByb3BlcnR5IG1hdGNoaW5nIHRoZSBVbmlvbiBkaXNjcmltaW5hdG9yLCB0aGVcbiAgICogICB2YWx1ZSBvZiB0aGUgZGlzY3JpbWluYXRvciBpZGVudGlmaWVzIGEgcmVnaXN0ZXJlZCB2YXJpYW50LCBhbmRcbiAgICogICBlaXRoZXIgKGEpIHRoZSB2YXJpYW50IGhhcyBubyBsYXlvdXQsIG9yIChiKSBgc3JjYCBoYXMgdGhlXG4gICAqICAgdmFyaWFudCdzIHByb3BlcnR5LCB0aGVuIHRoZSB2YXJpYW50IGlzIHJldHVybmVkIChiZWNhdXNlIHRoZVxuICAgKiAgIHNvdXJjZSBzYXRpc2ZpZXMgdGhlIGNvbnN0cmFpbnRzIG9mIHRoZSB2YXJpYW50IGl0IGlkZW50aWZpZXMpO1xuICAgKiAqIElmIGBzcmNgIGRvZXMgbm90IGhhdmUgYSBwcm9wZXJ0eSBtYXRjaGluZyB0aGUgVW5pb25cbiAgICogICBkaXNjcmltaW5hdG9yLCBidXQgZG9lcyBoYXZlIGEgcHJvcGVydHkgbWF0Y2hpbmcgYSByZWdpc3RlcmVkXG4gICAqICAgdmFyaWFudCwgdGhlbiB0aGUgdmFyaWFudCBpcyByZXR1cm5lZCAoYmVjYXVzZSB0aGUgc291cmNlXG4gICAqICAgbWF0Y2hlcyBhIHZhcmlhbnQgd2l0aG91dCBhbiBleHBsaWNpdCBjb25mbGljdCk7XG4gICAqICogQW4gZXJyb3IgaXMgdGhyb3duIChiZWNhdXNlIHdlIGVpdGhlciBjYW4ndCBpZGVudGlmeSBhIHZhcmlhbnQsXG4gICAqICAgb3Igd2Ugd2VyZSBleHBsaWNpdGx5IHRvbGQgdGhlIHZhcmlhbnQgYnV0IGNhbid0IHNhdGlzZnkgaXQpLlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gc3JjIC0gYW4gb2JqZWN0IHByZXN1bWVkIHRvIGJlIGNvbXBhdGlibGUgd2l0aFxuICAgKiB0aGUgY29udGVudCBvZiB0aGUgVW5pb24uXG4gICAqXG4gICAqIEByZXR1cm4geyh1bmRlZmluZWR8VmFyaWFudExheW91dCl9IC0gYXMgZGVzY3JpYmVkIGFib3ZlLlxuICAgKlxuICAgKiBAdGhyb3dzIHtFcnJvcn0gLSBpZiBgc3JjYCBjYW5ub3QgYmUgYXNzb2NpYXRlZCB3aXRoIGEgZGVmYXVsdCBvclxuICAgKiByZWdpc3RlcmVkIHZhcmlhbnQuXG4gICAqL1xuICBkZWZhdWx0R2V0U291cmNlVmFyaWFudChzcmMpIHtcbiAgICBpZiAoc3JjLmhhc093blByb3BlcnR5KHRoaXMuZGlzY3JpbWluYXRvci5wcm9wZXJ0eSkpIHtcbiAgICAgIGlmICh0aGlzLmRlZmF1bHRMYXlvdXRcbiAgICAgICAgICAmJiBzcmMuaGFzT3duUHJvcGVydHkodGhpcy5kZWZhdWx0TGF5b3V0LnByb3BlcnR5KSkge1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgfVxuICAgICAgY29uc3QgdmxvID0gdGhpcy5yZWdpc3RyeVtzcmNbdGhpcy5kaXNjcmltaW5hdG9yLnByb3BlcnR5XV07XG4gICAgICBpZiAodmxvXG4gICAgICAgICAgJiYgKCghdmxvLmxheW91dClcbiAgICAgICAgICAgICAgfHwgc3JjLmhhc093blByb3BlcnR5KHZsby5wcm9wZXJ0eSkpKSB7XG4gICAgICAgIHJldHVybiB2bG87XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGZvciAoY29uc3QgdGFnIGluIHRoaXMucmVnaXN0cnkpIHtcbiAgICAgICAgY29uc3QgdmxvID0gdGhpcy5yZWdpc3RyeVt0YWddO1xuICAgICAgICBpZiAoc3JjLmhhc093blByb3BlcnR5KHZsby5wcm9wZXJ0eSkpIHtcbiAgICAgICAgICByZXR1cm4gdmxvO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHRocm93IG5ldyBFcnJvcigndW5hYmxlIHRvIGluZmVyIHNyYyB2YXJpYW50Jyk7XG4gIH1cblxuICAvKiogSW1wbGVtZW50IHtAbGluayBMYXlvdXQjZGVjb2RlfGRlY29kZX0gZm9yIHtAbGluayBVbmlvbn0uXG4gICAqXG4gICAqIElmIHRoZSB2YXJpYW50IGlzIHtAbGluayBVbmlvbiNhZGRWYXJpYW50fHJlZ2lzdGVyZWR9IHRoZSByZXR1cm5cbiAgICogdmFsdWUgaXMgYW4gaW5zdGFuY2Ugb2YgdGhhdCB2YXJpYW50LCB3aXRoIG5vIGV4cGxpY2l0XG4gICAqIGRpc2NyaW1pbmF0b3IuICBPdGhlcndpc2UgdGhlIHtAbGluayBVbmlvbiNkZWZhdWx0TGF5b3V0fGRlZmF1bHRcbiAgICogbGF5b3V0fSBpcyB1c2VkIHRvIGRlY29kZSB0aGUgY29udGVudC4gKi9cbiAgZGVjb2RlKGIsIG9mZnNldCkge1xuICAgIGlmICh1bmRlZmluZWQgPT09IG9mZnNldCkge1xuICAgICAgb2Zmc2V0ID0gMDtcbiAgICB9XG4gICAgbGV0IGRlc3Q7XG4gICAgY29uc3QgZGxvID0gdGhpcy5kaXNjcmltaW5hdG9yO1xuICAgIGNvbnN0IGRpc2NyID0gZGxvLmRlY29kZShiLCBvZmZzZXQpO1xuICAgIGxldCBjbG8gPSB0aGlzLnJlZ2lzdHJ5W2Rpc2NyXTtcbiAgICBpZiAodW5kZWZpbmVkID09PSBjbG8pIHtcbiAgICAgIGxldCBjb250ZW50T2Zmc2V0ID0gMDtcbiAgICAgIGNsbyA9IHRoaXMuZGVmYXVsdExheW91dDtcbiAgICAgIGlmICh0aGlzLnVzZXNQcmVmaXhEaXNjcmltaW5hdG9yKSB7XG4gICAgICAgIGNvbnRlbnRPZmZzZXQgPSBkbG8ubGF5b3V0LnNwYW47XG4gICAgICB9XG4gICAgICBkZXN0ID0gdGhpcy5tYWtlRGVzdGluYXRpb25PYmplY3QoKTtcbiAgICAgIGRlc3RbZGxvLnByb3BlcnR5XSA9IGRpc2NyO1xuICAgICAgZGVzdFtjbG8ucHJvcGVydHldID0gdGhpcy5kZWZhdWx0TGF5b3V0LmRlY29kZShiLCBvZmZzZXQgKyBjb250ZW50T2Zmc2V0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgZGVzdCA9IGNsby5kZWNvZGUoYiwgb2Zmc2V0KTtcbiAgICB9XG4gICAgcmV0dXJuIGRlc3Q7XG4gIH1cblxuICAvKiogSW1wbGVtZW50IHtAbGluayBMYXlvdXQjZW5jb2RlfGVuY29kZX0gZm9yIHtAbGluayBVbmlvbn0uXG4gICAqXG4gICAqIFRoaXMgQVBJIGFzc3VtZXMgdGhlIGBzcmNgIG9iamVjdCBpcyBjb25zaXN0ZW50IHdpdGggdGhlIHVuaW9uJ3NcbiAgICoge0BsaW5rIFVuaW9uI2RlZmF1bHRMYXlvdXR8ZGVmYXVsdCBsYXlvdXR9LiAgVG8gZW5jb2RlIHZhcmlhbnRzXG4gICAqIHVzZSB0aGUgYXBwcm9wcmlhdGUgdmFyaWFudC1zcGVjaWZpYyB7QGxpbmsgVmFyaWFudExheW91dCNlbmNvZGV9XG4gICAqIG1ldGhvZC4gKi9cbiAgZW5jb2RlKHNyYywgYiwgb2Zmc2V0KSB7XG4gICAgaWYgKHVuZGVmaW5lZCA9PT0gb2Zmc2V0KSB7XG4gICAgICBvZmZzZXQgPSAwO1xuICAgIH1cbiAgICBjb25zdCB2bG8gPSB0aGlzLmdldFNvdXJjZVZhcmlhbnQoc3JjKTtcbiAgICBpZiAodW5kZWZpbmVkID09PSB2bG8pIHtcbiAgICAgIGNvbnN0IGRsbyA9IHRoaXMuZGlzY3JpbWluYXRvcjtcbiAgICAgIGNvbnN0IGNsbyA9IHRoaXMuZGVmYXVsdExheW91dDtcbiAgICAgIGxldCBjb250ZW50T2Zmc2V0ID0gMDtcbiAgICAgIGlmICh0aGlzLnVzZXNQcmVmaXhEaXNjcmltaW5hdG9yKSB7XG4gICAgICAgIGNvbnRlbnRPZmZzZXQgPSBkbG8ubGF5b3V0LnNwYW47XG4gICAgICB9XG4gICAgICBkbG8uZW5jb2RlKHNyY1tkbG8ucHJvcGVydHldLCBiLCBvZmZzZXQpO1xuICAgICAgcmV0dXJuIGNvbnRlbnRPZmZzZXQgKyBjbG8uZW5jb2RlKHNyY1tjbG8ucHJvcGVydHldLCBiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9mZnNldCArIGNvbnRlbnRPZmZzZXQpO1xuICAgIH1cbiAgICByZXR1cm4gdmxvLmVuY29kZShzcmMsIGIsIG9mZnNldCk7XG4gIH1cblxuICAvKiogUmVnaXN0ZXIgYSBuZXcgdmFyaWFudCBzdHJ1Y3R1cmUgd2l0aGluIGEgdW5pb24uICBUaGUgbmV3bHlcbiAgICogY3JlYXRlZCB2YXJpYW50IGlzIHJldHVybmVkLlxuICAgKlxuICAgKiBAcGFyYW0ge051bWJlcn0gdmFyaWFudCAtIGluaXRpYWxpemVyIGZvciB7QGxpbmtcbiAgICogVmFyaWFudExheW91dCN2YXJpYW50fHZhcmlhbnR9LlxuICAgKlxuICAgKiBAcGFyYW0ge0xheW91dH0gbGF5b3V0IC0gaW5pdGlhbGl6ZXIgZm9yIHtAbGlua1xuICAgKiBWYXJpYW50TGF5b3V0I2xheW91dHxsYXlvdXR9LlxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gcHJvcGVydHkgLSBpbml0aWFsaXplciBmb3Ige0BsaW5rXG4gICAqIExheW91dCNwcm9wZXJ0eXxwcm9wZXJ0eX0uXG4gICAqXG4gICAqIEByZXR1cm4ge1ZhcmlhbnRMYXlvdXR9ICovXG4gIGFkZFZhcmlhbnQodmFyaWFudCwgbGF5b3V0LCBwcm9wZXJ0eSkge1xuICAgIGNvbnN0IHJ2ID0gbmV3IFZhcmlhbnRMYXlvdXQodGhpcywgdmFyaWFudCwgbGF5b3V0LCBwcm9wZXJ0eSk7XG4gICAgdGhpcy5yZWdpc3RyeVt2YXJpYW50XSA9IHJ2O1xuICAgIHJldHVybiBydjtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIGxheW91dCBhc3NvY2lhdGVkIHdpdGggYSByZWdpc3RlcmVkIHZhcmlhbnQuXG4gICAqXG4gICAqIElmIGB2YmAgZG9lcyBub3QgcHJvZHVjZSBhIHJlZ2lzdGVyZWQgdmFyaWFudCB0aGUgZnVuY3Rpb24gcmV0dXJuc1xuICAgKiBgdW5kZWZpbmVkYC5cbiAgICpcbiAgICogQHBhcmFtIHsoTnVtYmVyfEJ1ZmZlcil9IHZiIC0gZWl0aGVyIHRoZSB2YXJpYW50IG51bWJlciwgb3IgYVxuICAgKiBidWZmZXIgZnJvbSB3aGljaCB0aGUgZGlzY3JpbWluYXRvciBpcyB0byBiZSByZWFkLlxuICAgKlxuICAgKiBAcGFyYW0ge051bWJlcn0gb2Zmc2V0IC0gb2Zmc2V0IGludG8gYHZiYCBmb3IgdGhlIHN0YXJ0IG9mIHRoZVxuICAgKiB1bmlvbi4gIFVzZWQgb25seSB3aGVuIGB2YmAgaXMgYW4gaW5zdGFuY2Ugb2Yge0J1ZmZlcn0uXG4gICAqXG4gICAqIEByZXR1cm4geyh7VmFyaWFudExheW91dH18dW5kZWZpbmVkKX1cbiAgICovXG4gIGdldFZhcmlhbnQodmIsIG9mZnNldCkge1xuICAgIGxldCB2YXJpYW50ID0gdmI7XG4gICAgaWYgKEJ1ZmZlci5pc0J1ZmZlcih2YikpIHtcbiAgICAgIGlmICh1bmRlZmluZWQgPT09IG9mZnNldCkge1xuICAgICAgICBvZmZzZXQgPSAwO1xuICAgICAgfVxuICAgICAgdmFyaWFudCA9IHRoaXMuZGlzY3JpbWluYXRvci5kZWNvZGUodmIsIG9mZnNldCk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLnJlZ2lzdHJ5W3ZhcmlhbnRdO1xuICB9XG59XG5cbi8qKlxuICogUmVwcmVzZW50IGEgc3BlY2lmaWMgdmFyaWFudCB3aXRoaW4gYSBjb250YWluaW5nIHVuaW9uLlxuICpcbiAqICoqTk9URSoqIFRoZSB7QGxpbmsgTGF5b3V0I3NwYW58c3Bhbn0gb2YgdGhlIHZhcmlhbnQgbWF5IGluY2x1ZGVcbiAqIHRoZSBzcGFuIG9mIHRoZSB7QGxpbmsgVW5pb24jZGlzY3JpbWluYXRvcnxkaXNjcmltaW5hdG9yfSB1c2VkIHRvXG4gKiBpZGVudGlmeSBpdCwgYnV0IHZhbHVlcyByZWFkIGFuZCB3cml0dGVuIHVzaW5nIHRoZSB2YXJpYW50IHN0cmljdGx5XG4gKiBjb25mb3JtIHRvIHRoZSBjb250ZW50IG9mIHtAbGluayBWYXJpYW50TGF5b3V0I2xheW91dHxsYXlvdXR9LlxuICpcbiAqICoqTk9URSoqIFVzZXIgY29kZSBzaG91bGQgbm90IGludm9rZSB0aGlzIGNvbnN0cnVjdG9yIGRpcmVjdGx5LiAgVXNlXG4gKiB0aGUgdW5pb24ge0BsaW5rIFVuaW9uI2FkZFZhcmlhbnR8YWRkVmFyaWFudH0gaGVscGVyIG1ldGhvZC5cbiAqXG4gKiBAcGFyYW0ge1VuaW9ufSB1bmlvbiAtIGluaXRpYWxpemVyIGZvciB7QGxpbmtcbiAqIFZhcmlhbnRMYXlvdXQjdW5pb258dW5pb259LlxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSB2YXJpYW50IC0gaW5pdGlhbGl6ZXIgZm9yIHtAbGlua1xuICogVmFyaWFudExheW91dCN2YXJpYW50fHZhcmlhbnR9LlxuICpcbiAqIEBwYXJhbSB7TGF5b3V0fSBbbGF5b3V0XSAtIGluaXRpYWxpemVyIGZvciB7QGxpbmtcbiAqIFZhcmlhbnRMYXlvdXQjbGF5b3V0fGxheW91dH0uICBJZiBhYnNlbnQgdGhlIHZhcmlhbnQgY2FycmllcyBub1xuICogZGF0YS5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gW3Byb3BlcnR5XSAtIGluaXRpYWxpemVyIGZvciB7QGxpbmtcbiAqIExheW91dCNwcm9wZXJ0eXxwcm9wZXJ0eX0uICBVbmxpa2UgbWFueSBvdGhlciBsYXlvdXRzLCB2YXJpYW50XG4gKiBsYXlvdXRzIG5vcm1hbGx5IGluY2x1ZGUgYSBwcm9wZXJ0eSBuYW1lIHNvIHRoZXkgY2FuIGJlIGlkZW50aWZpZWRcbiAqIHdpdGhpbiB0aGVpciBjb250YWluaW5nIHtAbGluayBVbmlvbn0uICBUaGUgcHJvcGVydHkgaWRlbnRpZmllciBtYXlcbiAqIGJlIGFic2VudCBvbmx5IGlmIGBsYXlvdXRgIGlzIGlzIGFic2VudC5cbiAqXG4gKiBAYXVnbWVudHMge0xheW91dH1cbiAqL1xuY2xhc3MgVmFyaWFudExheW91dCBleHRlbmRzIExheW91dCB7XG4gIGNvbnN0cnVjdG9yKHVuaW9uLCB2YXJpYW50LCBsYXlvdXQsIHByb3BlcnR5KSB7XG4gICAgaWYgKCEodW5pb24gaW5zdGFuY2VvZiBVbmlvbikpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ3VuaW9uIG11c3QgYmUgYSBVbmlvbicpO1xuICAgIH1cbiAgICBpZiAoKCFOdW1iZXIuaXNJbnRlZ2VyKHZhcmlhbnQpKSB8fCAoMCA+IHZhcmlhbnQpKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCd2YXJpYW50IG11c3QgYmUgYSAobm9uLW5lZ2F0aXZlKSBpbnRlZ2VyJyk7XG4gICAgfVxuICAgIGlmICgoJ3N0cmluZycgPT09IHR5cGVvZiBsYXlvdXQpXG4gICAgICAgICYmICh1bmRlZmluZWQgPT09IHByb3BlcnR5KSkge1xuICAgICAgcHJvcGVydHkgPSBsYXlvdXQ7XG4gICAgICBsYXlvdXQgPSBudWxsO1xuICAgIH1cbiAgICBpZiAobGF5b3V0KSB7XG4gICAgICBpZiAoIShsYXlvdXQgaW5zdGFuY2VvZiBMYXlvdXQpKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2xheW91dCBtdXN0IGJlIGEgTGF5b3V0Jyk7XG4gICAgICB9XG4gICAgICBpZiAoKG51bGwgIT09IHVuaW9uLmRlZmF1bHRMYXlvdXQpXG4gICAgICAgICAgJiYgKDAgPD0gbGF5b3V0LnNwYW4pXG4gICAgICAgICAgJiYgKGxheW91dC5zcGFuID4gdW5pb24uZGVmYXVsdExheW91dC5zcGFuKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3ZhcmlhbnQgc3BhbiBleGNlZWRzIHNwYW4gb2YgY29udGFpbmluZyB1bmlvbicpO1xuICAgICAgfVxuICAgICAgaWYgKCdzdHJpbmcnICE9PSB0eXBlb2YgcHJvcGVydHkpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcigndmFyaWFudCBtdXN0IGhhdmUgYSBTdHJpbmcgcHJvcGVydHknKTtcbiAgICAgIH1cbiAgICB9XG4gICAgbGV0IHNwYW4gPSB1bmlvbi5zcGFuO1xuICAgIGlmICgwID4gdW5pb24uc3Bhbikge1xuICAgICAgc3BhbiA9IGxheW91dCA/IGxheW91dC5zcGFuIDogMDtcbiAgICAgIGlmICgoMCA8PSBzcGFuKSAmJiB1bmlvbi51c2VzUHJlZml4RGlzY3JpbWluYXRvcikge1xuICAgICAgICBzcGFuICs9IHVuaW9uLmRpc2NyaW1pbmF0b3IubGF5b3V0LnNwYW47XG4gICAgICB9XG4gICAgfVxuICAgIHN1cGVyKHNwYW4sIHByb3BlcnR5KTtcblxuICAgIC8qKiBUaGUge0BsaW5rIFVuaW9ufSB0byB3aGljaCB0aGlzIHZhcmlhbnQgYmVsb25ncy4gKi9cbiAgICB0aGlzLnVuaW9uID0gdW5pb247XG5cbiAgICAvKiogVGhlIHVuc2lnbmVkIGludGVncmFsIHZhbHVlIGlkZW50aWZ5aW5nIHRoaXMgdmFyaWFudCB3aXRoaW5cbiAgICAgKiB0aGUge0BsaW5rIFVuaW9uI2Rpc2NyaW1pbmF0b3J8ZGlzY3JpbWluYXRvcn0gb2YgdGhlIGNvbnRhaW5pbmdcbiAgICAgKiB1bmlvbi4gKi9cbiAgICB0aGlzLnZhcmlhbnQgPSB2YXJpYW50O1xuXG4gICAgLyoqIFRoZSB7QGxpbmsgTGF5b3V0fSB0byBiZSB1c2VkIHdoZW4gcmVhZGluZy93cml0aW5nIHRoZVxuICAgICAqIG5vbi1kaXNjcmltaW5hdG9yIHBhcnQgb2YgdGhlIHtAbGlua1xuICAgICAqIFZhcmlhbnRMYXlvdXQjdW5pb258dW5pb259LiAgSWYgYG51bGxgIHRoZSB2YXJpYW50IGNhcnJpZXMgbm9cbiAgICAgKiBkYXRhLiAqL1xuICAgIHRoaXMubGF5b3V0ID0gbGF5b3V0IHx8IG51bGw7XG4gIH1cblxuICAvKiogQG92ZXJyaWRlICovXG4gIGdldFNwYW4oYiwgb2Zmc2V0KSB7XG4gICAgaWYgKDAgPD0gdGhpcy5zcGFuKSB7XG4gICAgICAvKiBXaWxsIGJlIGVxdWFsIHRvIHRoZSBjb250YWluaW5nIHVuaW9uIHNwYW4gaWYgdGhhdCBpcyBub3RcbiAgICAgICAqIHZhcmlhYmxlLiAqL1xuICAgICAgcmV0dXJuIHRoaXMuc3BhbjtcbiAgICB9XG4gICAgaWYgKHVuZGVmaW5lZCA9PT0gb2Zmc2V0KSB7XG4gICAgICBvZmZzZXQgPSAwO1xuICAgIH1cbiAgICBsZXQgY29udGVudE9mZnNldCA9IDA7XG4gICAgaWYgKHRoaXMudW5pb24udXNlc1ByZWZpeERpc2NyaW1pbmF0b3IpIHtcbiAgICAgIGNvbnRlbnRPZmZzZXQgPSB0aGlzLnVuaW9uLmRpc2NyaW1pbmF0b3IubGF5b3V0LnNwYW47XG4gICAgfVxuICAgIC8qIFNwYW4gaXMgZGVmaW5lZCBzb2xlbHkgYnkgdGhlIHZhcmlhbnQgKGFuZCBwcmVmaXggZGlzY3JpbWluYXRvcikgKi9cbiAgICByZXR1cm4gY29udGVudE9mZnNldCArIHRoaXMubGF5b3V0LmdldFNwYW4oYiwgb2Zmc2V0ICsgY29udGVudE9mZnNldCk7XG4gIH1cblxuICAvKiogQG92ZXJyaWRlICovXG4gIGRlY29kZShiLCBvZmZzZXQpIHtcbiAgICBjb25zdCBkZXN0ID0gdGhpcy5tYWtlRGVzdGluYXRpb25PYmplY3QoKTtcbiAgICBpZiAodW5kZWZpbmVkID09PSBvZmZzZXQpIHtcbiAgICAgIG9mZnNldCA9IDA7XG4gICAgfVxuICAgIGlmICh0aGlzICE9PSB0aGlzLnVuaW9uLmdldFZhcmlhbnQoYiwgb2Zmc2V0KSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCd2YXJpYW50IG1pc21hdGNoJyk7XG4gICAgfVxuICAgIGxldCBjb250ZW50T2Zmc2V0ID0gMDtcbiAgICBpZiAodGhpcy51bmlvbi51c2VzUHJlZml4RGlzY3JpbWluYXRvcikge1xuICAgICAgY29udGVudE9mZnNldCA9IHRoaXMudW5pb24uZGlzY3JpbWluYXRvci5sYXlvdXQuc3BhbjtcbiAgICB9XG4gICAgaWYgKHRoaXMubGF5b3V0KSB7XG4gICAgICBkZXN0W3RoaXMucHJvcGVydHldID0gdGhpcy5sYXlvdXQuZGVjb2RlKGIsIG9mZnNldCArIGNvbnRlbnRPZmZzZXQpO1xuICAgIH0gZWxzZSBpZiAodGhpcy5wcm9wZXJ0eSkge1xuICAgICAgZGVzdFt0aGlzLnByb3BlcnR5XSA9IHRydWU7XG4gICAgfSBlbHNlIGlmICh0aGlzLnVuaW9uLnVzZXNQcmVmaXhEaXNjcmltaW5hdG9yKSB7XG4gICAgICBkZXN0W3RoaXMudW5pb24uZGlzY3JpbWluYXRvci5wcm9wZXJ0eV0gPSB0aGlzLnZhcmlhbnQ7XG4gICAgfVxuICAgIHJldHVybiBkZXN0O1xuICB9XG5cbiAgLyoqIEBvdmVycmlkZSAqL1xuICBlbmNvZGUoc3JjLCBiLCBvZmZzZXQpIHtcbiAgICBpZiAodW5kZWZpbmVkID09PSBvZmZzZXQpIHtcbiAgICAgIG9mZnNldCA9IDA7XG4gICAgfVxuICAgIGxldCBjb250ZW50T2Zmc2V0ID0gMDtcbiAgICBpZiAodGhpcy51bmlvbi51c2VzUHJlZml4RGlzY3JpbWluYXRvcikge1xuICAgICAgY29udGVudE9mZnNldCA9IHRoaXMudW5pb24uZGlzY3JpbWluYXRvci5sYXlvdXQuc3BhbjtcbiAgICB9XG4gICAgaWYgKHRoaXMubGF5b3V0XG4gICAgICAgICYmICghc3JjLmhhc093blByb3BlcnR5KHRoaXMucHJvcGVydHkpKSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcigndmFyaWFudCBsYWNrcyBwcm9wZXJ0eSAnICsgdGhpcy5wcm9wZXJ0eSk7XG4gICAgfVxuICAgIHRoaXMudW5pb24uZGlzY3JpbWluYXRvci5lbmNvZGUodGhpcy52YXJpYW50LCBiLCBvZmZzZXQpO1xuICAgIGxldCBzcGFuID0gY29udGVudE9mZnNldDtcbiAgICBpZiAodGhpcy5sYXlvdXQpIHtcbiAgICAgIHRoaXMubGF5b3V0LmVuY29kZShzcmNbdGhpcy5wcm9wZXJ0eV0sIGIsIG9mZnNldCArIGNvbnRlbnRPZmZzZXQpO1xuICAgICAgc3BhbiArPSB0aGlzLmxheW91dC5nZXRTcGFuKGIsIG9mZnNldCArIGNvbnRlbnRPZmZzZXQpO1xuICAgICAgaWYgKCgwIDw9IHRoaXMudW5pb24uc3BhbilcbiAgICAgICAgICAmJiAoc3BhbiA+IHRoaXMudW5pb24uc3BhbikpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdlbmNvZGVkIHZhcmlhbnQgb3ZlcnJ1bnMgY29udGFpbmluZyB1bmlvbicpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gc3BhbjtcbiAgfVxuXG4gIC8qKiBEZWxlZ2F0ZSB7QGxpbmsgTGF5b3V0I2Zyb21BcnJheXxmcm9tQXJyYXl9IHRvIHtAbGlua1xuICAgKiBWYXJpYW50TGF5b3V0I2xheW91dHxsYXlvdXR9LiAqL1xuICBmcm9tQXJyYXkodmFsdWVzKSB7XG4gICAgaWYgKHRoaXMubGF5b3V0KSB7XG4gICAgICByZXR1cm4gdGhpcy5sYXlvdXQuZnJvbUFycmF5KHZhbHVlcyk7XG4gICAgfVxuICB9XG59XG5cbi8qKiBKYXZhU2NyaXB0IGNob3NlIHRvIGRlZmluZSBiaXR3aXNlIG9wZXJhdGlvbnMgYXMgb3BlcmF0aW5nIG9uXG4gKiBzaWduZWQgMzItYml0IHZhbHVlcyBpbiAyJ3MgY29tcGxlbWVudCBmb3JtLCBtZWFuaW5nIGFueSBpbnRlZ2VyXG4gKiB3aXRoIGJpdCAzMSBzZXQgaXMgZ29pbmcgdG8gbG9vayBuZWdhdGl2ZS4gIEZvciByaWdodCBzaGlmdHMgdGhhdCdzXG4gKiBub3QgYSBwcm9ibGVtLCBiZWNhdXNlIGA+Pj5gIGlzIGEgbG9naWNhbCBzaGlmdCwgYnV0IGZvciBldmVyeVxuICogb3RoZXIgYml0d2lzZSBvcGVyYXRvciB3ZSBoYXZlIHRvIGNvbXBlbnNhdGUgZm9yIHBvc3NpYmxlIG5lZ2F0aXZlXG4gKiByZXN1bHRzLiAqL1xuZnVuY3Rpb24gZml4Qml0d2lzZVJlc3VsdCh2KSB7XG4gIGlmICgwID4gdikge1xuICAgIHYgKz0gMHgxMDAwMDAwMDA7XG4gIH1cbiAgcmV0dXJuIHY7XG59XG5cbi8qKlxuICogQ29udGFpbiBhIHNlcXVlbmNlIG9mIGJpdCBmaWVsZHMgYXMgYW4gdW5zaWduZWQgaW50ZWdlci5cbiAqXG4gKiAqRmFjdG9yeSo6IHtAbGluayBtb2R1bGU6TGF5b3V0LmJpdHN8Yml0c31cbiAqXG4gKiBUaGlzIGlzIGEgY29udGFpbmVyIGVsZW1lbnQ7IHdpdGhpbiBpdCB0aGVyZSBhcmUge0BsaW5rIEJpdEZpZWxkfVxuICogaW5zdGFuY2VzIHRoYXQgcHJvdmlkZSB0aGUgZXh0cmFjdGVkIHByb3BlcnRpZXMuICBUaGUgY29udGFpbmVyXG4gKiBzaW1wbHkgZGVmaW5lcyB0aGUgYWdncmVnYXRlIHJlcHJlc2VudGF0aW9uIGFuZCBpdHMgYml0IG9yZGVyaW5nLlxuICogVGhlIHJlcHJlc2VudGF0aW9uIGlzIGFuIG9iamVjdCBjb250YWluaW5nIHByb3BlcnRpZXMgd2l0aCBudW1lcmljXG4gKiBvciB7QGxpbmsgQm9vbGVhbn0gdmFsdWVzLlxuICpcbiAqIHtAbGluayBCaXRGaWVsZH1zIGFyZSBhZGRlZCB3aXRoIHRoZSB7QGxpbmtcbiAqIEJpdFN0cnVjdHVyZSNhZGRGaWVsZHxhZGRGaWVsZH0gYW5kIHtAbGlua1xuICogQml0U3RydWN0dXJlI2FkZEJvb2xlYW58YWRkQm9vbGVhbn0gbWV0aG9kcy5cblxuICogQHBhcmFtIHtMYXlvdXR9IHdvcmQgLSBpbml0aWFsaXplciBmb3Ige0BsaW5rXG4gKiBCaXRTdHJ1Y3R1cmUjd29yZHx3b3JkfS4gIFRoZSBwYXJhbWV0ZXIgbXVzdCBiZSBhbiBpbnN0YW5jZSBvZlxuICoge0BsaW5rIFVJbnR9IChvciB7QGxpbmsgVUludEJFfSkgdGhhdCBpcyBubyBtb3JlIHRoYW4gNCBieXRlcyB3aWRlLlxuICpcbiAqIEBwYXJhbSB7Ym9vbH0gW21zYl0gLSBgdHJ1ZWAgaWYgdGhlIGJpdCBudW1iZXJpbmcgc3RhcnRzIGF0IHRoZVxuICogbW9zdCBzaWduaWZpY2FudCBiaXQgb2YgdGhlIGNvbnRhaW5pbmcgd29yZDsgYGZhbHNlYCAoZGVmYXVsdCkgaWZcbiAqIGl0IHN0YXJ0cyBhdCB0aGUgbGVhc3Qgc2lnbmlmaWNhbnQgYml0IG9mIHRoZSBjb250YWluaW5nIHdvcmQuICBJZlxuICogdGhlIHBhcmFtZXRlciBhdCB0aGlzIHBvc2l0aW9uIGlzIGEgc3RyaW5nIGFuZCBgcHJvcGVydHlgIGlzXG4gKiBgdW5kZWZpbmVkYCB0aGUgdmFsdWUgb2YgdGhpcyBhcmd1bWVudCB3aWxsIGluc3RlYWQgYmUgdXNlZCBhcyB0aGVcbiAqIHZhbHVlIG9mIGBwcm9wZXJ0eWAuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IFtwcm9wZXJ0eV0gLSBpbml0aWFsaXplciBmb3Ige0BsaW5rXG4gKiBMYXlvdXQjcHJvcGVydHl8cHJvcGVydHl9LlxuICpcbiAqIEBhdWdtZW50cyB7TGF5b3V0fVxuICovXG5jbGFzcyBCaXRTdHJ1Y3R1cmUgZXh0ZW5kcyBMYXlvdXQge1xuICBjb25zdHJ1Y3Rvcih3b3JkLCBtc2IsIHByb3BlcnR5KSB7XG4gICAgaWYgKCEoKHdvcmQgaW5zdGFuY2VvZiBVSW50KVxuICAgICAgICAgIHx8ICh3b3JkIGluc3RhbmNlb2YgVUludEJFKSkpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ3dvcmQgbXVzdCBiZSBhIFVJbnQgb3IgVUludEJFIGxheW91dCcpO1xuICAgIH1cbiAgICBpZiAoKCdzdHJpbmcnID09PSB0eXBlb2YgbXNiKVxuICAgICAgICAmJiAodW5kZWZpbmVkID09PSBwcm9wZXJ0eSkpIHtcbiAgICAgIHByb3BlcnR5ID0gbXNiO1xuICAgICAgbXNiID0gdW5kZWZpbmVkO1xuICAgIH1cbiAgICBpZiAoNCA8IHdvcmQuc3Bhbikge1xuICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ3dvcmQgY2Fubm90IGV4Y2VlZCAzMiBiaXRzJyk7XG4gICAgfVxuICAgIHN1cGVyKHdvcmQuc3BhbiwgcHJvcGVydHkpO1xuXG4gICAgLyoqIFRoZSBsYXlvdXQgdXNlZCBmb3IgdGhlIHBhY2tlZCB2YWx1ZS4gIHtAbGluayBCaXRGaWVsZH1cbiAgICAgKiBpbnN0YW5jZXMgYXJlIHBhY2tlZCBzZXF1ZW50aWFsbHkgZGVwZW5kaW5nIG9uIHtAbGlua1xuICAgICAqIEJpdFN0cnVjdHVyZSNtc2J8bXNifS4gKi9cbiAgICB0aGlzLndvcmQgPSB3b3JkO1xuXG4gICAgLyoqIFdoZXRoZXIgdGhlIGJpdCBzZXF1ZW5jZXMgYXJlIHBhY2tlZCBzdGFydGluZyBhdCB0aGUgbW9zdFxuICAgICAqIHNpZ25pZmljYW50IGJpdCBncm93aW5nIGRvd24gKGB0cnVlYCksIG9yIHRoZSBsZWFzdCBzaWduaWZpY2FudFxuICAgICAqIGJpdCBncm93aW5nIHVwIChgZmFsc2VgKS5cbiAgICAgKlxuICAgICAqICoqTk9URSoqIFJlZ2FyZGxlc3Mgb2YgdGhpcyB2YWx1ZSwgdGhlIGxlYXN0IHNpZ25pZmljYW50IGJpdCBvZlxuICAgICAqIGFueSB7QGxpbmsgQml0RmllbGR9IHZhbHVlIGlzIHRoZSBsZWFzdCBzaWduaWZpY2FudCBiaXQgb2YgdGhlXG4gICAgICogY29ycmVzcG9uZGluZyBzZWN0aW9uIG9mIHRoZSBwYWNrZWQgdmFsdWUuICovXG4gICAgdGhpcy5tc2IgPSAhIW1zYjtcblxuICAgIC8qKiBUaGUgc2VxdWVuY2Ugb2Yge0BsaW5rIEJpdEZpZWxkfSBsYXlvdXRzIHRoYXQgY29tcHJpc2UgdGhlXG4gICAgICogcGFja2VkIHN0cnVjdHVyZS5cbiAgICAgKlxuICAgICAqICoqTk9URSoqIFRoZSBhcnJheSByZW1haW5zIG11dGFibGUgdG8gYWxsb3cgZmllbGRzIHRvIGJlIHtAbGlua1xuICAgICAqIEJpdFN0cnVjdHVyZSNhZGRGaWVsZHxhZGRlZH0gYWZ0ZXIgY29uc3RydWN0aW9uLiAgVXNlcnMgc2hvdWxkXG4gICAgICogbm90IG1hbmlwdWxhdGUgdGhlIGNvbnRlbnQgb2YgdGhpcyBwcm9wZXJ0eS4qL1xuICAgIHRoaXMuZmllbGRzID0gW107XG5cbiAgICAvKiBTdG9yYWdlIGZvciB0aGUgdmFsdWUuICBDYXB0dXJlIGEgdmFyaWFibGUgaW5zdGVhZCBvZiB1c2luZyBhblxuICAgICAqIGluc3RhbmNlIHByb3BlcnR5IGJlY2F1c2Ugd2UgZG9uJ3Qgd2FudCBhbnl0aGluZyB0byBjaGFuZ2UgdGhlXG4gICAgICogdmFsdWUgd2l0aG91dCBnb2luZyB0aHJvdWdoIHRoZSBtdXRhdG9yLiAqL1xuICAgIGxldCB2YWx1ZSA9IDA7XG4gICAgdGhpcy5fcGFja2VkU2V0VmFsdWUgPSBmdW5jdGlvbih2KSB7XG4gICAgICB2YWx1ZSA9IGZpeEJpdHdpc2VSZXN1bHQodik7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIHRoaXMuX3BhY2tlZEdldFZhbHVlID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfTtcbiAgfVxuXG4gIC8qKiBAb3ZlcnJpZGUgKi9cbiAgZGVjb2RlKGIsIG9mZnNldCkge1xuICAgIGNvbnN0IGRlc3QgPSB0aGlzLm1ha2VEZXN0aW5hdGlvbk9iamVjdCgpO1xuICAgIGlmICh1bmRlZmluZWQgPT09IG9mZnNldCkge1xuICAgICAgb2Zmc2V0ID0gMDtcbiAgICB9XG4gICAgY29uc3QgdmFsdWUgPSB0aGlzLndvcmQuZGVjb2RlKGIsIG9mZnNldCk7XG4gICAgdGhpcy5fcGFja2VkU2V0VmFsdWUodmFsdWUpO1xuICAgIGZvciAoY29uc3QgZmQgb2YgdGhpcy5maWVsZHMpIHtcbiAgICAgIGlmICh1bmRlZmluZWQgIT09IGZkLnByb3BlcnR5KSB7XG4gICAgICAgIGRlc3RbZmQucHJvcGVydHldID0gZmQuZGVjb2RlKHZhbHVlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGRlc3Q7XG4gIH1cblxuICAvKiogSW1wbGVtZW50IHtAbGluayBMYXlvdXQjZW5jb2RlfGVuY29kZX0gZm9yIHtAbGluayBCaXRTdHJ1Y3R1cmV9LlxuICAgKlxuICAgKiBJZiBgc3JjYCBpcyBtaXNzaW5nIGEgcHJvcGVydHkgZm9yIGEgbWVtYmVyIHdpdGggYSBkZWZpbmVkIHtAbGlua1xuICAgKiBMYXlvdXQjcHJvcGVydHl8cHJvcGVydHl9IHRoZSBjb3JyZXNwb25kaW5nIHJlZ2lvbiBvZiB0aGUgcGFja2VkXG4gICAqIHZhbHVlIGlzIGxlZnQgdW5tb2RpZmllZC4gIFVudXNlZCBiaXRzIGFyZSBhbHNvIGxlZnQgdW5tb2RpZmllZC4gKi9cbiAgZW5jb2RlKHNyYywgYiwgb2Zmc2V0KSB7XG4gICAgaWYgKHVuZGVmaW5lZCA9PT0gb2Zmc2V0KSB7XG4gICAgICBvZmZzZXQgPSAwO1xuICAgIH1cbiAgICBjb25zdCB2YWx1ZSA9IHRoaXMud29yZC5kZWNvZGUoYiwgb2Zmc2V0KTtcbiAgICB0aGlzLl9wYWNrZWRTZXRWYWx1ZSh2YWx1ZSk7XG4gICAgZm9yIChjb25zdCBmZCBvZiB0aGlzLmZpZWxkcykge1xuICAgICAgaWYgKHVuZGVmaW5lZCAhPT0gZmQucHJvcGVydHkpIHtcbiAgICAgICAgY29uc3QgZnYgPSBzcmNbZmQucHJvcGVydHldO1xuICAgICAgICBpZiAodW5kZWZpbmVkICE9PSBmdikge1xuICAgICAgICAgIGZkLmVuY29kZShmdik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRoaXMud29yZC5lbmNvZGUodGhpcy5fcGFja2VkR2V0VmFsdWUoKSwgYiwgb2Zmc2V0KTtcbiAgfVxuXG4gIC8qKiBSZWdpc3RlciBhIG5ldyBiaXRmaWVsZCB3aXRoIGEgY29udGFpbmluZyBiaXQgc3RydWN0dXJlLiAgVGhlXG4gICAqIHJlc3VsdGluZyBiaXRmaWVsZCBpcyByZXR1cm5lZC5cbiAgICpcbiAgICogQHBhcmFtIHtOdW1iZXJ9IGJpdHMgLSBpbml0aWFsaXplciBmb3Ige0BsaW5rIEJpdEZpZWxkI2JpdHN8Yml0c30uXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBwcm9wZXJ0eSAtIGluaXRpYWxpemVyIGZvciB7QGxpbmtcbiAgICogTGF5b3V0I3Byb3BlcnR5fHByb3BlcnR5fS5cbiAgICpcbiAgICogQHJldHVybiB7Qml0RmllbGR9ICovXG4gIGFkZEZpZWxkKGJpdHMsIHByb3BlcnR5KSB7XG4gICAgY29uc3QgYmYgPSBuZXcgQml0RmllbGQodGhpcywgYml0cywgcHJvcGVydHkpO1xuICAgIHRoaXMuZmllbGRzLnB1c2goYmYpO1xuICAgIHJldHVybiBiZjtcbiAgfVxuXG4gIC8qKiBBcyB3aXRoIHtAbGluayBCaXRTdHJ1Y3R1cmUjYWRkRmllbGR8YWRkRmllbGR9IGZvciBzaW5nbGUtYml0XG4gICAqIGZpZWxkcyB3aXRoIGBib29sZWFuYCB2YWx1ZSByZXByZXNlbnRhdGlvbi5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IHByb3BlcnR5IC0gaW5pdGlhbGl6ZXIgZm9yIHtAbGlua1xuICAgKiBMYXlvdXQjcHJvcGVydHl8cHJvcGVydHl9LlxuICAgKlxuICAgKiBAcmV0dXJuIHtCb29sZWFufSAqL1xuICBhZGRCb29sZWFuKHByb3BlcnR5KSB7XG4gICAgLy8gVGhpcyBpcyBteSBCb29sZWFuLCBub3QgdGhlIEphdmFzY3JpcHQgb25lLlxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1uZXctd3JhcHBlcnNcbiAgICBjb25zdCBiZiA9IG5ldyBCb29sZWFuKHRoaXMsIHByb3BlcnR5KTtcbiAgICB0aGlzLmZpZWxkcy5wdXNoKGJmKTtcbiAgICByZXR1cm4gYmY7XG4gIH1cblxuICAvKipcbiAgICogR2V0IGFjY2VzcyB0byB0aGUgYml0IGZpZWxkIGZvciBhIGdpdmVuIHByb3BlcnR5LlxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gcHJvcGVydHkgLSB0aGUgYml0IGZpZWxkIG9mIGludGVyZXN0LlxuICAgKlxuICAgKiBAcmV0dXJuIHtCaXRGaWVsZH0gLSB0aGUgZmllbGQgYXNzb2NpYXRlZCB3aXRoIGBwcm9wZXJ0eWAsIG9yXG4gICAqIHVuZGVmaW5lZCBpZiB0aGVyZSBpcyBubyBzdWNoIHByb3BlcnR5LlxuICAgKi9cbiAgZmllbGRGb3IocHJvcGVydHkpIHtcbiAgICBpZiAoJ3N0cmluZycgIT09IHR5cGVvZiBwcm9wZXJ0eSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcigncHJvcGVydHkgbXVzdCBiZSBzdHJpbmcnKTtcbiAgICB9XG4gICAgZm9yIChjb25zdCBmZCBvZiB0aGlzLmZpZWxkcykge1xuICAgICAgaWYgKGZkLnByb3BlcnR5ID09PSBwcm9wZXJ0eSkge1xuICAgICAgICByZXR1cm4gZmQ7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogUmVwcmVzZW50IGEgc2VxdWVuY2Ugb2YgYml0cyB3aXRoaW4gYSB7QGxpbmsgQml0U3RydWN0dXJlfS5cbiAqXG4gKiBBbGwgYml0IGZpZWxkIHZhbHVlcyBhcmUgcmVwcmVzZW50ZWQgYXMgdW5zaWduZWQgaW50ZWdlcnMuXG4gKlxuICogKipOT1RFKiogVXNlciBjb2RlIHNob3VsZCBub3QgaW52b2tlIHRoaXMgY29uc3RydWN0b3IgZGlyZWN0bHkuXG4gKiBVc2UgdGhlIGNvbnRhaW5lciB7QGxpbmsgQml0U3RydWN0dXJlI2FkZEZpZWxkfGFkZEZpZWxkfSBoZWxwZXJcbiAqIG1ldGhvZC5cbiAqXG4gKiAqKk5PVEUqKiBCaXRGaWVsZCBpbnN0YW5jZXMgYXJlIG5vdCBpbnN0YW5jZXMgb2Yge0BsaW5rIExheW91dH1cbiAqIHNpbmNlIHtAbGluayBMYXlvdXQjc3BhbnxzcGFufSBtZWFzdXJlcyA4LWJpdCB1bml0cy5cbiAqXG4gKiBAcGFyYW0ge0JpdFN0cnVjdHVyZX0gY29udGFpbmVyIC0gaW5pdGlhbGl6ZXIgZm9yIHtAbGlua1xuICogQml0RmllbGQjY29udGFpbmVyfGNvbnRhaW5lcn0uXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IGJpdHMgLSBpbml0aWFsaXplciBmb3Ige0BsaW5rIEJpdEZpZWxkI2JpdHN8Yml0c30uXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IFtwcm9wZXJ0eV0gLSBpbml0aWFsaXplciBmb3Ige0BsaW5rXG4gKiBMYXlvdXQjcHJvcGVydHl8cHJvcGVydHl9LlxuICovXG5jbGFzcyBCaXRGaWVsZCB7XG4gIGNvbnN0cnVjdG9yKGNvbnRhaW5lciwgYml0cywgcHJvcGVydHkpIHtcbiAgICBpZiAoIShjb250YWluZXIgaW5zdGFuY2VvZiBCaXRTdHJ1Y3R1cmUpKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdjb250YWluZXIgbXVzdCBiZSBhIEJpdFN0cnVjdHVyZScpO1xuICAgIH1cbiAgICBpZiAoKCFOdW1iZXIuaXNJbnRlZ2VyKGJpdHMpKSB8fCAoMCA+PSBiaXRzKSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignYml0cyBtdXN0IGJlIHBvc2l0aXZlIGludGVnZXInKTtcbiAgICB9XG4gICAgY29uc3QgdG90YWxCaXRzID0gOCAqIGNvbnRhaW5lci5zcGFuO1xuICAgIGNvbnN0IHVzZWRCaXRzID0gY29udGFpbmVyLmZpZWxkcy5yZWR1Y2UoKHN1bSwgZmQpID0+IHN1bSArIGZkLmJpdHMsIDApO1xuICAgIGlmICgoYml0cyArIHVzZWRCaXRzKSA+IHRvdGFsQml0cykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdiaXRzIHRvbyBsb25nIGZvciBzcGFuIHJlbWFpbmRlciAoJ1xuICAgICAgICAgICAgICAgICAgICAgICsgKHRvdGFsQml0cyAtIHVzZWRCaXRzKSArICcgb2YgJ1xuICAgICAgICAgICAgICAgICAgICAgICsgdG90YWxCaXRzICsgJyByZW1haW4pJyk7XG4gICAgfVxuXG4gICAgLyoqIFRoZSB7QGxpbmsgQml0U3RydWN0dXJlfSBpbnN0YW5jZSB0byB3aGljaCB0aGlzIGJpdCBmaWVsZFxuICAgICAqIGJlbG9uZ3MuICovXG4gICAgdGhpcy5jb250YWluZXIgPSBjb250YWluZXI7XG5cbiAgICAvKiogVGhlIHNwYW4gb2YgdGhpcyB2YWx1ZSBpbiBiaXRzLiAqL1xuICAgIHRoaXMuYml0cyA9IGJpdHM7XG5cbiAgICAvKiogQSBtYXNrIG9mIHtAbGluayBCaXRGaWVsZCNiaXRzfGJpdHN9IGJpdHMgaXNvbGF0aW5nIHZhbHVlIGJpdHNcbiAgICAgKiB0aGF0IGZpdCB3aXRoaW4gdGhlIGZpZWxkLlxuICAgICAqXG4gICAgICogVGhhdCBpcywgaXQgbWFza3MgYSB2YWx1ZSB0aGF0IGhhcyBub3QgeWV0IGJlZW4gc2hpZnRlZCBpbnRvXG4gICAgICogcG9zaXRpb24gd2l0aGluIGl0cyBjb250YWluaW5nIHBhY2tlZCBpbnRlZ2VyLiAqL1xuICAgIHRoaXMudmFsdWVNYXNrID0gKDEgPDwgYml0cykgLSAxO1xuICAgIGlmICgzMiA9PT0gYml0cykgeyAvLyBzaGlmdGVkIHZhbHVlIG91dCBvZiByYW5nZVxuICAgICAgdGhpcy52YWx1ZU1hc2sgPSAweEZGRkZGRkZGO1xuICAgIH1cblxuICAgIC8qKiBUaGUgb2Zmc2V0IG9mIHRoZSB2YWx1ZSB3aXRoaW4gdGhlIGNvbnRhaW5pbmcgcGFja2VkIHVuc2lnbmVkXG4gICAgICogaW50ZWdlci4gIFRoZSBsZWFzdCBzaWduaWZpY2FudCBiaXQgb2YgdGhlIHBhY2tlZCB2YWx1ZSBpcyBhdFxuICAgICAqIG9mZnNldCB6ZXJvLCByZWdhcmRsZXNzIG9mIGJpdCBvcmRlcmluZyB1c2VkLiAqL1xuICAgIHRoaXMuc3RhcnQgPSB1c2VkQml0cztcbiAgICBpZiAodGhpcy5jb250YWluZXIubXNiKSB7XG4gICAgICB0aGlzLnN0YXJ0ID0gdG90YWxCaXRzIC0gdXNlZEJpdHMgLSBiaXRzO1xuICAgIH1cblxuICAgIC8qKiBBIG1hc2sgb2Yge0BsaW5rIEJpdEZpZWxkI2JpdHN8Yml0c30gaXNvbGF0aW5nIHRoZSBmaWVsZCB2YWx1ZVxuICAgICAqIHdpdGhpbiB0aGUgY29udGFpbmluZyBwYWNrZWQgdW5zaWduZWQgaW50ZWdlci4gKi9cbiAgICB0aGlzLndvcmRNYXNrID0gZml4Qml0d2lzZVJlc3VsdCh0aGlzLnZhbHVlTWFzayA8PCB0aGlzLnN0YXJ0KTtcblxuICAgIC8qKiBUaGUgcHJvcGVydHkgbmFtZSB1c2VkIHdoZW4gdGhpcyBiaXRmaWVsZCBpcyByZXByZXNlbnRlZCBpbiBhblxuICAgICAqIE9iamVjdC5cbiAgICAgKlxuICAgICAqIEludGVuZGVkIHRvIGJlIGZ1bmN0aW9uYWxseSBlcXVpdmFsZW50IHRvIHtAbGlua1xuICAgICAqIExheW91dCNwcm9wZXJ0eX0uXG4gICAgICpcbiAgICAgKiBJZiBsZWZ0IHVuZGVmaW5lZCB0aGUgY29ycmVzcG9uZGluZyBzcGFuIG9mIGJpdHMgd2lsbCBiZVxuICAgICAqIHRyZWF0ZWQgYXMgcGFkZGluZzogaXQgd2lsbCBub3QgYmUgbXV0YXRlZCBieSB7QGxpbmtcbiAgICAgKiBMYXlvdXQjZW5jb2RlfGVuY29kZX0gbm9yIHJlcHJlc2VudGVkIGFzIGEgcHJvcGVydHkgaW4gdGhlXG4gICAgICogZGVjb2RlZCBPYmplY3QuICovXG4gICAgdGhpcy5wcm9wZXJ0eSA9IHByb3BlcnR5O1xuICB9XG5cbiAgLyoqIFN0b3JlIGEgdmFsdWUgaW50byB0aGUgY29ycmVzcG9uZGluZyBzdWJzZXF1ZW5jZSBvZiB0aGUgY29udGFpbmluZ1xuICAgKiBiaXQgZmllbGQuICovXG4gIGRlY29kZSgpIHtcbiAgICBjb25zdCB3b3JkID0gdGhpcy5jb250YWluZXIuX3BhY2tlZEdldFZhbHVlKCk7XG4gICAgY29uc3Qgd29yZFZhbHVlID0gZml4Qml0d2lzZVJlc3VsdCh3b3JkICYgdGhpcy53b3JkTWFzayk7XG4gICAgY29uc3QgdmFsdWUgPSB3b3JkVmFsdWUgPj4+IHRoaXMuc3RhcnQ7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG5cbiAgLyoqIFN0b3JlIGEgdmFsdWUgaW50byB0aGUgY29ycmVzcG9uZGluZyBzdWJzZXF1ZW5jZSBvZiB0aGUgY29udGFpbmluZ1xuICAgKiBiaXQgZmllbGQuXG4gICAqXG4gICAqICoqTk9URSoqIFRoaXMgaXMgbm90IGEgc3BlY2lhbGl6YXRpb24gb2Yge0BsaW5rXG4gICAqIExheW91dCNlbmNvZGV8TGF5b3V0LmVuY29kZX0gYW5kIHRoZXJlIGlzIG5vIHJldHVybiB2YWx1ZS4gKi9cbiAgZW5jb2RlKHZhbHVlKSB7XG4gICAgaWYgKCghTnVtYmVyLmlzSW50ZWdlcih2YWx1ZSkpXG4gICAgICAgIHx8ICh2YWx1ZSAhPT0gZml4Qml0d2lzZVJlc3VsdCh2YWx1ZSAmIHRoaXMudmFsdWVNYXNrKSkpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IobmFtZVdpdGhQcm9wZXJ0eSgnQml0RmllbGQuZW5jb2RlJywgdGhpcylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgKyAnIHZhbHVlIG11c3QgYmUgaW50ZWdlciBub3QgZXhjZWVkaW5nICcgKyB0aGlzLnZhbHVlTWFzayk7XG4gICAgfVxuICAgIGNvbnN0IHdvcmQgPSB0aGlzLmNvbnRhaW5lci5fcGFja2VkR2V0VmFsdWUoKTtcbiAgICBjb25zdCB3b3JkVmFsdWUgPSBmaXhCaXR3aXNlUmVzdWx0KHZhbHVlIDw8IHRoaXMuc3RhcnQpO1xuICAgIHRoaXMuY29udGFpbmVyLl9wYWNrZWRTZXRWYWx1ZShmaXhCaXR3aXNlUmVzdWx0KHdvcmQgJiB+dGhpcy53b3JkTWFzaylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCB3b3JkVmFsdWUpO1xuICB9O1xufVxuXG4vKipcbiAqIFJlcHJlc2VudCBhIHNpbmdsZSBiaXQgd2l0aGluIGEge0BsaW5rIEJpdFN0cnVjdHVyZX0gYXMgYVxuICogSmF2YVNjcmlwdCBib29sZWFuLlxuICpcbiAqICoqTk9URSoqIFVzZXIgY29kZSBzaG91bGQgbm90IGludm9rZSB0aGlzIGNvbnN0cnVjdG9yIGRpcmVjdGx5LlxuICogVXNlIHRoZSBjb250YWluZXIge0BsaW5rIEJpdFN0cnVjdHVyZSNhZGRCb29sZWFufGFkZEJvb2xlYW59IGhlbHBlclxuICogbWV0aG9kLlxuICpcbiAqIEBwYXJhbSB7Qml0U3RydWN0dXJlfSBjb250YWluZXIgLSBpbml0aWFsaXplciBmb3Ige0BsaW5rXG4gKiBCaXRGaWVsZCNjb250YWluZXJ8Y29udGFpbmVyfS5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gW3Byb3BlcnR5XSAtIGluaXRpYWxpemVyIGZvciB7QGxpbmtcbiAqIExheW91dCNwcm9wZXJ0eXxwcm9wZXJ0eX0uXG4gKlxuICogQGF1Z21lbnRzIHtCaXRGaWVsZH1cbiAqL1xuLyogZXNsaW50LWRpc2FibGUgbm8tZXh0ZW5kLW5hdGl2ZSAqL1xuY2xhc3MgQm9vbGVhbiBleHRlbmRzIEJpdEZpZWxkIHtcbiAgY29uc3RydWN0b3IoY29udGFpbmVyLCBwcm9wZXJ0eSkge1xuICAgIHN1cGVyKGNvbnRhaW5lciwgMSwgcHJvcGVydHkpO1xuICB9XG5cbiAgLyoqIE92ZXJyaWRlIHtAbGluayBCaXRGaWVsZCNkZWNvZGV8ZGVjb2RlfSBmb3Ige0BsaW5rIEJvb2xlYW58Qm9vbGVhbn0uXG4gICAqXG4gICAqIEByZXR1cm5zIHtib29sZWFufSAqL1xuICBkZWNvZGUoYiwgb2Zmc2V0KSB7XG4gICAgcmV0dXJuICEhQml0RmllbGQucHJvdG90eXBlLmRlY29kZS5jYWxsKHRoaXMsIGIsIG9mZnNldCk7XG4gIH1cblxuICAvKiogQG92ZXJyaWRlICovXG4gIGVuY29kZSh2YWx1ZSkge1xuICAgIGlmICgnYm9vbGVhbicgPT09IHR5cGVvZiB2YWx1ZSkge1xuICAgICAgLy8gQml0RmllbGQgcmVxdWlyZXMgaW50ZWdlciB2YWx1ZXNcbiAgICAgIHZhbHVlID0gK3ZhbHVlO1xuICAgIH1cbiAgICByZXR1cm4gQml0RmllbGQucHJvdG90eXBlLmVuY29kZS5jYWxsKHRoaXMsIHZhbHVlKTtcbiAgfVxufVxuLyogZXNsaW50LWVuYWJsZSBuby1leHRlbmQtbmF0aXZlICovXG5cbi8qKlxuICogQ29udGFpbiBhIGZpeGVkLWxlbmd0aCBibG9jayBvZiBhcmJpdHJhcnkgZGF0YSwgcmVwcmVzZW50ZWQgYXMgYVxuICogQnVmZmVyLlxuICpcbiAqICpGYWN0b3J5Kjoge0BsaW5rIG1vZHVsZTpMYXlvdXQuYmxvYnxibG9ifVxuICpcbiAqIEBwYXJhbSB7KE51bWJlcnxFeHRlcm5hbExheW91dCl9IGxlbmd0aCAtIGluaXRpYWxpemVzIHtAbGlua1xuICogQmxvYiNsZW5ndGh8bGVuZ3RofS5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gW3Byb3BlcnR5XSAtIGluaXRpYWxpemVyIGZvciB7QGxpbmtcbiAqIExheW91dCNwcm9wZXJ0eXxwcm9wZXJ0eX0uXG4gKlxuICogQGF1Z21lbnRzIHtMYXlvdXR9XG4gKi9cbmNsYXNzIEJsb2IgZXh0ZW5kcyBMYXlvdXQge1xuICBjb25zdHJ1Y3RvcihsZW5ndGgsIHByb3BlcnR5KSB7XG4gICAgaWYgKCEoKChsZW5ndGggaW5zdGFuY2VvZiBFeHRlcm5hbExheW91dCkgJiYgbGVuZ3RoLmlzQ291bnQoKSlcbiAgICAgICAgICB8fCAoTnVtYmVyLmlzSW50ZWdlcihsZW5ndGgpICYmICgwIDw9IGxlbmd0aCkpKSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignbGVuZ3RoIG11c3QgYmUgcG9zaXRpdmUgaW50ZWdlciAnXG4gICAgICAgICAgICAgICAgICAgICAgICAgICsgJ29yIGFuIHVuc2lnbmVkIGludGVnZXIgRXh0ZXJuYWxMYXlvdXQnKTtcbiAgICB9XG5cbiAgICBsZXQgc3BhbiA9IC0xO1xuICAgIGlmICghKGxlbmd0aCBpbnN0YW5jZW9mIEV4dGVybmFsTGF5b3V0KSkge1xuICAgICAgc3BhbiA9IGxlbmd0aDtcbiAgICB9XG4gICAgc3VwZXIoc3BhbiwgcHJvcGVydHkpO1xuXG4gICAgLyoqIFRoZSBudW1iZXIgb2YgYnl0ZXMgaW4gdGhlIGJsb2IuXG4gICAgICpcbiAgICAgKiBUaGlzIG1heSBiZSBhIG5vbi1uZWdhdGl2ZSBpbnRlZ2VyLCBvciBhbiBpbnN0YW5jZSBvZiB7QGxpbmtcbiAgICAgKiBFeHRlcm5hbExheW91dH0gdGhhdCBzYXRpc2ZpZXMge0BsaW5rXG4gICAgICogRXh0ZXJuYWxMYXlvdXQjaXNDb3VudHxpc0NvdW50KCl9LiAqL1xuICAgIHRoaXMubGVuZ3RoID0gbGVuZ3RoO1xuICB9XG5cbiAgLyoqIEBvdmVycmlkZSAqL1xuICBnZXRTcGFuKGIsIG9mZnNldCkge1xuICAgIGxldCBzcGFuID0gdGhpcy5zcGFuO1xuICAgIGlmICgwID4gc3Bhbikge1xuICAgICAgc3BhbiA9IHRoaXMubGVuZ3RoLmRlY29kZShiLCBvZmZzZXQpO1xuICAgIH1cbiAgICByZXR1cm4gc3BhbjtcbiAgfVxuXG4gIC8qKiBAb3ZlcnJpZGUgKi9cbiAgZGVjb2RlKGIsIG9mZnNldCkge1xuICAgIGlmICh1bmRlZmluZWQgPT09IG9mZnNldCkge1xuICAgICAgb2Zmc2V0ID0gMDtcbiAgICB9XG4gICAgbGV0IHNwYW4gPSB0aGlzLnNwYW47XG4gICAgaWYgKDAgPiBzcGFuKSB7XG4gICAgICBzcGFuID0gdGhpcy5sZW5ndGguZGVjb2RlKGIsIG9mZnNldCk7XG4gICAgfVxuICAgIHJldHVybiBiLnNsaWNlKG9mZnNldCwgb2Zmc2V0ICsgc3Bhbik7XG4gIH1cblxuICAvKiogSW1wbGVtZW50IHtAbGluayBMYXlvdXQjZW5jb2RlfGVuY29kZX0gZm9yIHtAbGluayBCbG9ifS5cbiAgICpcbiAgICogKipOT1RFKiogSWYge0BsaW5rIExheW91dCNjb3VudHxjb3VudH0gaXMgYW4gaW5zdGFuY2Ugb2Yge0BsaW5rXG4gICAqIEV4dGVybmFsTGF5b3V0fSB0aGVuIHRoZSBsZW5ndGggb2YgYHNyY2Agd2lsbCBiZSBlbmNvZGVkIGFzIHRoZVxuICAgKiBjb3VudCBhZnRlciBgc3JjYCBpcyBlbmNvZGVkLiAqL1xuICBlbmNvZGUoc3JjLCBiLCBvZmZzZXQpIHtcbiAgICBsZXQgc3BhbiA9IHRoaXMubGVuZ3RoO1xuICAgIGlmICh0aGlzLmxlbmd0aCBpbnN0YW5jZW9mIEV4dGVybmFsTGF5b3V0KSB7XG4gICAgICBzcGFuID0gc3JjLmxlbmd0aDtcbiAgICB9XG4gICAgaWYgKCEoQnVmZmVyLmlzQnVmZmVyKHNyYylcbiAgICAgICAgICAmJiAoc3BhbiA9PT0gc3JjLmxlbmd0aCkpKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKG5hbWVXaXRoUHJvcGVydHkoJ0Jsb2IuZW5jb2RlJywgdGhpcylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgKyAnIHJlcXVpcmVzIChsZW5ndGggJyArIHNwYW4gKyAnKSBCdWZmZXIgYXMgc3JjJyk7XG4gICAgfVxuICAgIGlmICgob2Zmc2V0ICsgc3BhbikgPiBiLmxlbmd0aCkge1xuICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ2VuY29kaW5nIG92ZXJydW5zIEJ1ZmZlcicpO1xuICAgIH1cbiAgICBiLndyaXRlKHNyYy50b1N0cmluZygnaGV4JyksIG9mZnNldCwgc3BhbiwgJ2hleCcpO1xuICAgIGlmICh0aGlzLmxlbmd0aCBpbnN0YW5jZW9mIEV4dGVybmFsTGF5b3V0KSB7XG4gICAgICB0aGlzLmxlbmd0aC5lbmNvZGUoc3BhbiwgYiwgb2Zmc2V0KTtcbiAgICB9XG4gICAgcmV0dXJuIHNwYW47XG4gIH1cbn1cblxuLyoqXG4gKiBDb250YWluIGEgYE5VTGAtdGVybWluYXRlZCBVVEY4IHN0cmluZy5cbiAqXG4gKiAqRmFjdG9yeSo6IHtAbGluayBtb2R1bGU6TGF5b3V0LmNzdHJ8Y3N0cn1cbiAqXG4gKiAqKk5PVEUqKiBBbnkgVVRGOCBzdHJpbmcgdGhhdCBpbmNvcnBvcmF0ZXMgYSB6ZXJvLXZhbHVlZCBieXRlIHdpbGxcbiAqIG5vdCBiZSBjb3JyZWN0bHkgZGVjb2RlZCBieSB0aGlzIGxheW91dC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gW3Byb3BlcnR5XSAtIGluaXRpYWxpemVyIGZvciB7QGxpbmtcbiAqIExheW91dCNwcm9wZXJ0eXxwcm9wZXJ0eX0uXG4gKlxuICogQGF1Z21lbnRzIHtMYXlvdXR9XG4gKi9cbmNsYXNzIENTdHJpbmcgZXh0ZW5kcyBMYXlvdXQge1xuICBjb25zdHJ1Y3Rvcihwcm9wZXJ0eSkge1xuICAgIHN1cGVyKC0xLCBwcm9wZXJ0eSk7XG4gIH1cblxuICAvKiogQG92ZXJyaWRlICovXG4gIGdldFNwYW4oYiwgb2Zmc2V0KSB7XG4gICAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoYikpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2IgbXVzdCBiZSBhIEJ1ZmZlcicpO1xuICAgIH1cbiAgICBpZiAodW5kZWZpbmVkID09PSBvZmZzZXQpIHtcbiAgICAgIG9mZnNldCA9IDA7XG4gICAgfVxuICAgIGxldCBpZHggPSBvZmZzZXQ7XG4gICAgd2hpbGUgKChpZHggPCBiLmxlbmd0aCkgJiYgKDAgIT09IGJbaWR4XSkpIHtcbiAgICAgIGlkeCArPSAxO1xuICAgIH1cbiAgICByZXR1cm4gMSArIGlkeCAtIG9mZnNldDtcbiAgfVxuXG4gIC8qKiBAb3ZlcnJpZGUgKi9cbiAgZGVjb2RlKGIsIG9mZnNldCwgZGVzdCkge1xuICAgIGlmICh1bmRlZmluZWQgPT09IG9mZnNldCkge1xuICAgICAgb2Zmc2V0ID0gMDtcbiAgICB9XG4gICAgbGV0IHNwYW4gPSB0aGlzLmdldFNwYW4oYiwgb2Zmc2V0KTtcbiAgICByZXR1cm4gYi5zbGljZShvZmZzZXQsIG9mZnNldCArIHNwYW4gLSAxKS50b1N0cmluZygndXRmLTgnKTtcbiAgfVxuXG4gIC8qKiBAb3ZlcnJpZGUgKi9cbiAgZW5jb2RlKHNyYywgYiwgb2Zmc2V0KSB7XG4gICAgaWYgKHVuZGVmaW5lZCA9PT0gb2Zmc2V0KSB7XG4gICAgICBvZmZzZXQgPSAwO1xuICAgIH1cbiAgICAvKiBNdXN0IGZvcmNlIHRoaXMgdG8gYSBzdHJpbmcsIGxlc3QgaXQgYmUgYSBudW1iZXIgYW5kIHRoZVxuICAgICAqIFwidXRmOC1lbmNvZGluZ1wiIGJlbG93IGFjdHVhbGx5IGFsbG9jYXRlIGEgYnVmZmVyIG9mIGxlbmd0aFxuICAgICAqIHNyYyAqL1xuICAgIGlmICgnc3RyaW5nJyAhPT0gdHlwZW9mIHNyYykge1xuICAgICAgc3JjID0gc3JjLnRvU3RyaW5nKCk7XG4gICAgfVxuICAgIGNvbnN0IHNyY2IgPSBuZXcgQnVmZmVyKHNyYywgJ3V0ZjgnKTtcbiAgICBjb25zdCBzcGFuID0gc3JjYi5sZW5ndGg7XG4gICAgaWYgKChvZmZzZXQgKyBzcGFuKSA+IGIubGVuZ3RoKSB7XG4gICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignZW5jb2Rpbmcgb3ZlcnJ1bnMgQnVmZmVyJyk7XG4gICAgfVxuICAgIHNyY2IuY29weShiLCBvZmZzZXQpO1xuICAgIGJbb2Zmc2V0ICsgc3Bhbl0gPSAwO1xuICAgIHJldHVybiBzcGFuICsgMTtcbiAgfVxufVxuXG4vKipcbiAqIENvbnRhaW4gYSBVVEY4IHN0cmluZyB3aXRoIGltcGxpY2l0IGxlbmd0aC5cbiAqXG4gKiAqRmFjdG9yeSo6IHtAbGluayBtb2R1bGU6TGF5b3V0LnV0Zjh8dXRmOH1cbiAqXG4gKiAqKk5PVEUqKiBCZWNhdXNlIHRoZSBsZW5ndGggaXMgaW1wbGljaXQgaW4gdGhlIHNpemUgb2YgdGhlIGJ1ZmZlclxuICogdGhpcyBsYXlvdXQgc2hvdWxkIGJlIHVzZWQgb25seSBpbiBpc29sYXRpb24sIG9yIGluIGEgc2l0dWF0aW9uXG4gKiB3aGVyZSB0aGUgbGVuZ3RoIGNhbiBiZSBleHByZXNzZWQgYnkgb3BlcmF0aW5nIG9uIGEgc2xpY2Ugb2YgdGhlXG4gKiBjb250YWluaW5nIGJ1ZmZlci5cbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gW21heFNwYW5dIC0gdGhlIG1heGltdW0gbGVuZ3RoIGFsbG93ZWQgZm9yIGVuY29kZWRcbiAqIHN0cmluZyBjb250ZW50LiAgSWYgbm90IHByb3ZpZGVkIHRoZXJlIGlzIG5vIGJvdW5kIG9uIHRoZSBhbGxvd2VkXG4gKiBjb250ZW50LlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBbcHJvcGVydHldIC0gaW5pdGlhbGl6ZXIgZm9yIHtAbGlua1xuICogTGF5b3V0I3Byb3BlcnR5fHByb3BlcnR5fS5cbiAqXG4gKiBAYXVnbWVudHMge0xheW91dH1cbiAqL1xuY2xhc3MgVVRGOCBleHRlbmRzIExheW91dCB7XG4gIGNvbnN0cnVjdG9yKG1heFNwYW4sIHByb3BlcnR5KSB7XG4gICAgaWYgKCgnc3RyaW5nJyA9PT0gdHlwZW9mIG1heFNwYW4pXG4gICAgICAgICYmICh1bmRlZmluZWQgPT09IHByb3BlcnR5KSkge1xuICAgICAgcHJvcGVydHkgPSBtYXhTcGFuO1xuICAgICAgbWF4U3BhbiA9IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgaWYgKHVuZGVmaW5lZCA9PT0gbWF4U3Bhbikge1xuICAgICAgbWF4U3BhbiA9IC0xO1xuICAgIH0gZWxzZSBpZiAoIU51bWJlci5pc0ludGVnZXIobWF4U3BhbikpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ21heFNwYW4gbXVzdCBiZSBhbiBpbnRlZ2VyJyk7XG4gICAgfVxuXG4gICAgc3VwZXIoLTEsIHByb3BlcnR5KTtcblxuICAgIC8qKiBUaGUgbWF4aW11bSBzcGFuIG9mIHRoZSBsYXlvdXQgaW4gYnl0ZXMuXG4gICAgICpcbiAgICAgKiBQb3NpdGl2ZSB2YWx1ZXMgYXJlIGdlbmVyYWxseSBleHBlY3RlZC4gIFplcm8gaXMgYWJub3JtYWwuXG4gICAgICogQXR0ZW1wdHMgdG8gZW5jb2RlIG9yIGRlY29kZSBhIHZhbHVlIHRoYXQgZXhjZWVkcyB0aGlzIGxlbmd0aFxuICAgICAqIHdpbGwgdGhyb3cgYSBgUmFuZ2VFcnJvcmAuXG4gICAgICpcbiAgICAgKiBBIG5lZ2F0aXZlIHZhbHVlIGluZGljYXRlcyB0aGF0IHRoZXJlIGlzIG5vIGJvdW5kIG9uIHRoZSBsZW5ndGhcbiAgICAgKiBvZiB0aGUgY29udGVudC4gKi9cbiAgICB0aGlzLm1heFNwYW4gPSBtYXhTcGFuO1xuICB9XG5cbiAgLyoqIEBvdmVycmlkZSAqL1xuICBnZXRTcGFuKGIsIG9mZnNldCkge1xuICAgIGlmICghQnVmZmVyLmlzQnVmZmVyKGIpKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdiIG11c3QgYmUgYSBCdWZmZXInKTtcbiAgICB9XG4gICAgaWYgKHVuZGVmaW5lZCA9PT0gb2Zmc2V0KSB7XG4gICAgICBvZmZzZXQgPSAwO1xuICAgIH1cbiAgICByZXR1cm4gYi5sZW5ndGggLSBvZmZzZXQ7XG4gIH1cblxuICAvKiogQG92ZXJyaWRlICovXG4gIGRlY29kZShiLCBvZmZzZXQsIGRlc3QpIHtcbiAgICBpZiAodW5kZWZpbmVkID09PSBvZmZzZXQpIHtcbiAgICAgIG9mZnNldCA9IDA7XG4gICAgfVxuICAgIGxldCBzcGFuID0gdGhpcy5nZXRTcGFuKGIsIG9mZnNldCk7XG4gICAgaWYgKCgwIDw9IHRoaXMubWF4U3BhbilcbiAgICAgICAgJiYgKHRoaXMubWF4U3BhbiA8IHNwYW4pKSB7XG4gICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcigndGV4dCBsZW5ndGggZXhjZWVkcyBtYXhTcGFuJyk7XG4gICAgfVxuICAgIHJldHVybiBiLnNsaWNlKG9mZnNldCwgb2Zmc2V0ICsgc3BhbikudG9TdHJpbmcoJ3V0Zi04Jyk7XG4gIH1cblxuICAvKiogQG92ZXJyaWRlICovXG4gIGVuY29kZShzcmMsIGIsIG9mZnNldCkge1xuICAgIGlmICh1bmRlZmluZWQgPT09IG9mZnNldCkge1xuICAgICAgb2Zmc2V0ID0gMDtcbiAgICB9XG4gICAgLyogTXVzdCBmb3JjZSB0aGlzIHRvIGEgc3RyaW5nLCBsZXN0IGl0IGJlIGEgbnVtYmVyIGFuZCB0aGVcbiAgICAgKiBcInV0ZjgtZW5jb2RpbmdcIiBiZWxvdyBhY3R1YWxseSBhbGxvY2F0ZSBhIGJ1ZmZlciBvZiBsZW5ndGhcbiAgICAgKiBzcmMgKi9cbiAgICBpZiAoJ3N0cmluZycgIT09IHR5cGVvZiBzcmMpIHtcbiAgICAgIHNyYyA9IHNyYy50b1N0cmluZygpO1xuICAgIH1cbiAgICBjb25zdCBzcmNiID0gbmV3IEJ1ZmZlcihzcmMsICd1dGY4Jyk7XG4gICAgY29uc3Qgc3BhbiA9IHNyY2IubGVuZ3RoO1xuICAgIGlmICgoMCA8PSB0aGlzLm1heFNwYW4pXG4gICAgICAgICYmICh0aGlzLm1heFNwYW4gPCBzcGFuKSkge1xuICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ3RleHQgbGVuZ3RoIGV4Y2VlZHMgbWF4U3BhbicpO1xuICAgIH1cbiAgICBpZiAoKG9mZnNldCArIHNwYW4pID4gYi5sZW5ndGgpIHtcbiAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdlbmNvZGluZyBvdmVycnVucyBCdWZmZXInKTtcbiAgICB9XG4gICAgc3JjYi5jb3B5KGIsIG9mZnNldCk7XG4gICAgcmV0dXJuIHNwYW47XG4gIH1cbn1cblxuLyoqXG4gKiBDb250YWluIGEgY29uc3RhbnQgdmFsdWUuXG4gKlxuICogVGhpcyBsYXlvdXQgbWF5IGJlIHVzZWQgaW4gY2FzZXMgd2hlcmUgYSBKYXZhU2NyaXB0IHZhbHVlIGNhbiBiZVxuICogaW5mZXJyZWQgd2l0aG91dCBhbiBleHByZXNzaW9uIGluIHRoZSBiaW5hcnkgZW5jb2RpbmcuICBBbiBleGFtcGxlXG4gKiB3b3VsZCBiZSBhIHtAbGluayBWYXJpYW50TGF5b3V0fHZhcmlhbnQgbGF5b3V0fSB3aGVyZSB0aGUgY29udGVudFxuICogaXMgaW1wbGllZCBieSB0aGUgdW5pb24ge0BsaW5rIFVuaW9uI2Rpc2NyaW1pbmF0b3J8ZGlzY3JpbWluYXRvcn0uXG4gKlxuICogQHBhcmFtIHtPYmplY3R8TnVtYmVyfFN0cmluZ30gdmFsdWUgLSBpbml0aWFsaXplciBmb3Ige0BsaW5rXG4gKiBDb25zdGFudCN2YWx1ZXx2YWx1ZX0uICBJZiB0aGUgdmFsdWUgaXMgYW4gb2JqZWN0IChvciBhcnJheSkgYW5kXG4gKiB0aGUgYXBwbGljYXRpb24gaW50ZW5kcyB0aGUgb2JqZWN0IHRvIHJlbWFpbiB1bmNoYW5nZWQgcmVnYXJkbGVzc1xuICogb2Ygd2hhdCBpcyBkb25lIHRvIHZhbHVlcyBkZWNvZGVkIGJ5IHRoaXMgbGF5b3V0LCB0aGUgdmFsdWUgc2hvdWxkXG4gKiBiZSBmcm96ZW4gcHJpb3IgcGFzc2luZyBpdCB0byB0aGlzIGNvbnN0cnVjdG9yLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBbcHJvcGVydHldIC0gaW5pdGlhbGl6ZXIgZm9yIHtAbGlua1xuICogTGF5b3V0I3Byb3BlcnR5fHByb3BlcnR5fS5cbiAqXG4gKiBAYXVnbWVudHMge0xheW91dH1cbiAqL1xuY2xhc3MgQ29uc3RhbnQgZXh0ZW5kcyBMYXlvdXQge1xuICBjb25zdHJ1Y3Rvcih2YWx1ZSwgcHJvcGVydHkpIHtcbiAgICBzdXBlcigwLCBwcm9wZXJ0eSk7XG5cbiAgICAvKiogVGhlIHZhbHVlIHByb2R1Y2VkIGJ5IHRoaXMgY29uc3RhbnQgd2hlbiB0aGUgbGF5b3V0IGlzIHtAbGlua1xuICAgICAqIENvbnN0YW50I2RlY29kZXxkZWNvZGVkfS5cbiAgICAgKlxuICAgICAqIEFueSBKYXZhU2NyaXB0IHZhbHVlIGluY2x1ZGluZyBgbnVsbGAgYW5kIGB1bmRlZmluZWRgIGlzXG4gICAgICogcGVybWl0dGVkLlxuICAgICAqXG4gICAgICogKipXQVJOSU5HKiogSWYgYHZhbHVlYCBwYXNzZWQgaW4gdGhlIGNvbnN0cnVjdG9yIHdhcyBub3RcbiAgICAgKiBmcm96ZW4sIGl0IGlzIHBvc3NpYmxlIGZvciB1c2VycyBvZiBkZWNvZGVkIHZhbHVlcyB0byBjaGFuZ2VcbiAgICAgKiB0aGUgY29udGVudCBvZiB0aGUgdmFsdWUuICovXG4gICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICB9XG5cbiAgLyoqIEBvdmVycmlkZSAqL1xuICBkZWNvZGUoYiwgb2Zmc2V0LCBkZXN0KSB7XG4gICAgcmV0dXJuIHRoaXMudmFsdWU7XG4gIH1cblxuICAvKiogQG92ZXJyaWRlICovXG4gIGVuY29kZShzcmMsIGIsIG9mZnNldCkge1xuICAgIC8qIENvbnN0YW50cyB0YWtlIG5vIHNwYWNlICovXG4gICAgcmV0dXJuIDA7XG4gIH1cbn1cblxuZXhwb3J0cy5FeHRlcm5hbExheW91dCA9IEV4dGVybmFsTGF5b3V0O1xuZXhwb3J0cy5HcmVlZHlDb3VudCA9IEdyZWVkeUNvdW50O1xuZXhwb3J0cy5PZmZzZXRMYXlvdXQgPSBPZmZzZXRMYXlvdXQ7XG5leHBvcnRzLlVJbnQgPSBVSW50O1xuZXhwb3J0cy5VSW50QkUgPSBVSW50QkU7XG5leHBvcnRzLkludCA9IEludDtcbmV4cG9ydHMuSW50QkUgPSBJbnRCRTtcbmV4cG9ydHMuRmxvYXQgPSBGbG9hdDtcbmV4cG9ydHMuRmxvYXRCRSA9IEZsb2F0QkU7XG5leHBvcnRzLkRvdWJsZSA9IERvdWJsZTtcbmV4cG9ydHMuRG91YmxlQkUgPSBEb3VibGVCRTtcbmV4cG9ydHMuU2VxdWVuY2UgPSBTZXF1ZW5jZTtcbmV4cG9ydHMuU3RydWN0dXJlID0gU3RydWN0dXJlO1xuZXhwb3J0cy5VbmlvbkRpc2NyaW1pbmF0b3IgPSBVbmlvbkRpc2NyaW1pbmF0b3I7XG5leHBvcnRzLlVuaW9uTGF5b3V0RGlzY3JpbWluYXRvciA9IFVuaW9uTGF5b3V0RGlzY3JpbWluYXRvcjtcbmV4cG9ydHMuVW5pb24gPSBVbmlvbjtcbmV4cG9ydHMuVmFyaWFudExheW91dCA9IFZhcmlhbnRMYXlvdXQ7XG5leHBvcnRzLkJpdFN0cnVjdHVyZSA9IEJpdFN0cnVjdHVyZTtcbmV4cG9ydHMuQml0RmllbGQgPSBCaXRGaWVsZDtcbmV4cG9ydHMuQm9vbGVhbiA9IEJvb2xlYW47XG5leHBvcnRzLkJsb2IgPSBCbG9iO1xuZXhwb3J0cy5DU3RyaW5nID0gQ1N0cmluZztcbmV4cG9ydHMuVVRGOCA9IFVURjg7XG5leHBvcnRzLkNvbnN0YW50ID0gQ29uc3RhbnQ7XG5cbi8qKiBGYWN0b3J5IGZvciB7QGxpbmsgR3JlZWR5Q291bnR9LiAqL1xuZXhwb3J0cy5ncmVlZHkgPSAoKGVsZW1lbnRTcGFuLCBwcm9wZXJ0eSkgPT4gbmV3IEdyZWVkeUNvdW50KGVsZW1lbnRTcGFuLCBwcm9wZXJ0eSkpO1xuXG4vKiogRmFjdG9yeSBmb3Ige0BsaW5rIE9mZnNldExheW91dH0uICovXG5leHBvcnRzLm9mZnNldCA9ICgobGF5b3V0LCBvZmZzZXQsIHByb3BlcnR5KSA9PiBuZXcgT2Zmc2V0TGF5b3V0KGxheW91dCwgb2Zmc2V0LCBwcm9wZXJ0eSkpO1xuXG4vKiogRmFjdG9yeSBmb3Ige0BsaW5rIFVJbnR8dW5zaWduZWQgaW50IGxheW91dHN9IHNwYW5uaW5nIG9uZVxuICogYnl0ZS4gKi9cbmV4cG9ydHMudTggPSAocHJvcGVydHkgPT4gbmV3IFVJbnQoMSwgcHJvcGVydHkpKTtcblxuLyoqIEZhY3RvcnkgZm9yIHtAbGluayBVSW50fGxpdHRsZS1lbmRpYW4gdW5zaWduZWQgaW50IGxheW91dHN9XG4gKiBzcGFubmluZyB0d28gYnl0ZXMuICovXG5leHBvcnRzLnUxNiA9IChwcm9wZXJ0eSA9PiBuZXcgVUludCgyLCBwcm9wZXJ0eSkpO1xuXG4vKiogRmFjdG9yeSBmb3Ige0BsaW5rIFVJbnR8bGl0dGxlLWVuZGlhbiB1bnNpZ25lZCBpbnQgbGF5b3V0c31cbiAqIHNwYW5uaW5nIHRocmVlIGJ5dGVzLiAqL1xuZXhwb3J0cy51MjQgPSAocHJvcGVydHkgPT4gbmV3IFVJbnQoMywgcHJvcGVydHkpKTtcblxuLyoqIEZhY3RvcnkgZm9yIHtAbGluayBVSW50fGxpdHRsZS1lbmRpYW4gdW5zaWduZWQgaW50IGxheW91dHN9XG4gKiBzcGFubmluZyBmb3VyIGJ5dGVzLiAqL1xuZXhwb3J0cy51MzIgPSAocHJvcGVydHkgPT4gbmV3IFVJbnQoNCwgcHJvcGVydHkpKTtcblxuLyoqIEZhY3RvcnkgZm9yIHtAbGluayBVSW50fGxpdHRsZS1lbmRpYW4gdW5zaWduZWQgaW50IGxheW91dHN9XG4gKiBzcGFubmluZyBmaXZlIGJ5dGVzLiAqL1xuZXhwb3J0cy51NDAgPSAocHJvcGVydHkgPT4gbmV3IFVJbnQoNSwgcHJvcGVydHkpKTtcblxuLyoqIEZhY3RvcnkgZm9yIHtAbGluayBVSW50fGxpdHRsZS1lbmRpYW4gdW5zaWduZWQgaW50IGxheW91dHN9XG4gKiBzcGFubmluZyBzaXggYnl0ZXMuICovXG5leHBvcnRzLnU0OCA9IChwcm9wZXJ0eSA9PiBuZXcgVUludCg2LCBwcm9wZXJ0eSkpO1xuXG4vKiogRmFjdG9yeSBmb3Ige0BsaW5rIE5lYXJVSW50NjR8bGl0dGxlLWVuZGlhbiB1bnNpZ25lZCBpbnRcbiAqIGxheW91dHN9IGludGVycHJldGVkIGFzIE51bWJlcnMuICovXG5leHBvcnRzLm51NjQgPSAocHJvcGVydHkgPT4gbmV3IE5lYXJVSW50NjQocHJvcGVydHkpKTtcblxuLyoqIEZhY3RvcnkgZm9yIHtAbGluayBVSW50fGJpZy1lbmRpYW4gdW5zaWduZWQgaW50IGxheW91dHN9XG4gKiBzcGFubmluZyB0d28gYnl0ZXMuICovXG5leHBvcnRzLnUxNmJlID0gKHByb3BlcnR5ID0+IG5ldyBVSW50QkUoMiwgcHJvcGVydHkpKTtcblxuLyoqIEZhY3RvcnkgZm9yIHtAbGluayBVSW50fGJpZy1lbmRpYW4gdW5zaWduZWQgaW50IGxheW91dHN9XG4gKiBzcGFubmluZyB0aHJlZSBieXRlcy4gKi9cbmV4cG9ydHMudTI0YmUgPSAocHJvcGVydHkgPT4gbmV3IFVJbnRCRSgzLCBwcm9wZXJ0eSkpO1xuXG4vKiogRmFjdG9yeSBmb3Ige0BsaW5rIFVJbnR8YmlnLWVuZGlhbiB1bnNpZ25lZCBpbnQgbGF5b3V0c31cbiAqIHNwYW5uaW5nIGZvdXIgYnl0ZXMuICovXG5leHBvcnRzLnUzMmJlID0gKHByb3BlcnR5ID0+IG5ldyBVSW50QkUoNCwgcHJvcGVydHkpKTtcblxuLyoqIEZhY3RvcnkgZm9yIHtAbGluayBVSW50fGJpZy1lbmRpYW4gdW5zaWduZWQgaW50IGxheW91dHN9XG4gKiBzcGFubmluZyBmaXZlIGJ5dGVzLiAqL1xuZXhwb3J0cy51NDBiZSA9IChwcm9wZXJ0eSA9PiBuZXcgVUludEJFKDUsIHByb3BlcnR5KSk7XG5cbi8qKiBGYWN0b3J5IGZvciB7QGxpbmsgVUludHxiaWctZW5kaWFuIHVuc2lnbmVkIGludCBsYXlvdXRzfVxuICogc3Bhbm5pbmcgc2l4IGJ5dGVzLiAqL1xuZXhwb3J0cy51NDhiZSA9IChwcm9wZXJ0eSA9PiBuZXcgVUludEJFKDYsIHByb3BlcnR5KSk7XG5cbi8qKiBGYWN0b3J5IGZvciB7QGxpbmsgTmVhclVJbnQ2NEJFfGJpZy1lbmRpYW4gdW5zaWduZWQgaW50XG4gKiBsYXlvdXRzfSBpbnRlcnByZXRlZCBhcyBOdW1iZXJzLiAqL1xuZXhwb3J0cy5udTY0YmUgPSAocHJvcGVydHkgPT4gbmV3IE5lYXJVSW50NjRCRShwcm9wZXJ0eSkpO1xuXG4vKiogRmFjdG9yeSBmb3Ige0BsaW5rIEludHxzaWduZWQgaW50IGxheW91dHN9IHNwYW5uaW5nIG9uZVxuICogYnl0ZS4gKi9cbmV4cG9ydHMuczggPSAocHJvcGVydHkgPT4gbmV3IEludCgxLCBwcm9wZXJ0eSkpO1xuXG4vKiogRmFjdG9yeSBmb3Ige0BsaW5rIEludHxsaXR0bGUtZW5kaWFuIHNpZ25lZCBpbnQgbGF5b3V0c31cbiAqIHNwYW5uaW5nIHR3byBieXRlcy4gKi9cbmV4cG9ydHMuczE2ID0gKHByb3BlcnR5ID0+IG5ldyBJbnQoMiwgcHJvcGVydHkpKTtcblxuLyoqIEZhY3RvcnkgZm9yIHtAbGluayBJbnR8bGl0dGxlLWVuZGlhbiBzaWduZWQgaW50IGxheW91dHN9XG4gKiBzcGFubmluZyB0aHJlZSBieXRlcy4gKi9cbmV4cG9ydHMuczI0ID0gKHByb3BlcnR5ID0+IG5ldyBJbnQoMywgcHJvcGVydHkpKTtcblxuLyoqIEZhY3RvcnkgZm9yIHtAbGluayBJbnR8bGl0dGxlLWVuZGlhbiBzaWduZWQgaW50IGxheW91dHN9XG4gKiBzcGFubmluZyBmb3VyIGJ5dGVzLiAqL1xuZXhwb3J0cy5zMzIgPSAocHJvcGVydHkgPT4gbmV3IEludCg0LCBwcm9wZXJ0eSkpO1xuXG4vKiogRmFjdG9yeSBmb3Ige0BsaW5rIEludHxsaXR0bGUtZW5kaWFuIHNpZ25lZCBpbnQgbGF5b3V0c31cbiAqIHNwYW5uaW5nIGZpdmUgYnl0ZXMuICovXG5leHBvcnRzLnM0MCA9IChwcm9wZXJ0eSA9PiBuZXcgSW50KDUsIHByb3BlcnR5KSk7XG5cbi8qKiBGYWN0b3J5IGZvciB7QGxpbmsgSW50fGxpdHRsZS1lbmRpYW4gc2lnbmVkIGludCBsYXlvdXRzfVxuICogc3Bhbm5pbmcgc2l4IGJ5dGVzLiAqL1xuZXhwb3J0cy5zNDggPSAocHJvcGVydHkgPT4gbmV3IEludCg2LCBwcm9wZXJ0eSkpO1xuXG4vKiogRmFjdG9yeSBmb3Ige0BsaW5rIE5lYXJJbnQ2NHxsaXR0bGUtZW5kaWFuIHNpZ25lZCBpbnQgbGF5b3V0c31cbiAqIGludGVycHJldGVkIGFzIE51bWJlcnMuICovXG5leHBvcnRzLm5zNjQgPSAocHJvcGVydHkgPT4gbmV3IE5lYXJJbnQ2NChwcm9wZXJ0eSkpO1xuXG4vKiogRmFjdG9yeSBmb3Ige0BsaW5rIEludHxiaWctZW5kaWFuIHNpZ25lZCBpbnQgbGF5b3V0c31cbiAqIHNwYW5uaW5nIHR3byBieXRlcy4gKi9cbmV4cG9ydHMuczE2YmUgPSAocHJvcGVydHkgPT4gbmV3IEludEJFKDIsIHByb3BlcnR5KSk7XG5cbi8qKiBGYWN0b3J5IGZvciB7QGxpbmsgSW50fGJpZy1lbmRpYW4gc2lnbmVkIGludCBsYXlvdXRzfVxuICogc3Bhbm5pbmcgdGhyZWUgYnl0ZXMuICovXG5leHBvcnRzLnMyNGJlID0gKHByb3BlcnR5ID0+IG5ldyBJbnRCRSgzLCBwcm9wZXJ0eSkpO1xuXG4vKiogRmFjdG9yeSBmb3Ige0BsaW5rIEludHxiaWctZW5kaWFuIHNpZ25lZCBpbnQgbGF5b3V0c31cbiAqIHNwYW5uaW5nIGZvdXIgYnl0ZXMuICovXG5leHBvcnRzLnMzMmJlID0gKHByb3BlcnR5ID0+IG5ldyBJbnRCRSg0LCBwcm9wZXJ0eSkpO1xuXG4vKiogRmFjdG9yeSBmb3Ige0BsaW5rIEludHxiaWctZW5kaWFuIHNpZ25lZCBpbnQgbGF5b3V0c31cbiAqIHNwYW5uaW5nIGZpdmUgYnl0ZXMuICovXG5leHBvcnRzLnM0MGJlID0gKHByb3BlcnR5ID0+IG5ldyBJbnRCRSg1LCBwcm9wZXJ0eSkpO1xuXG4vKiogRmFjdG9yeSBmb3Ige0BsaW5rIEludHxiaWctZW5kaWFuIHNpZ25lZCBpbnQgbGF5b3V0c31cbiAqIHNwYW5uaW5nIHNpeCBieXRlcy4gKi9cbmV4cG9ydHMuczQ4YmUgPSAocHJvcGVydHkgPT4gbmV3IEludEJFKDYsIHByb3BlcnR5KSk7XG5cbi8qKiBGYWN0b3J5IGZvciB7QGxpbmsgTmVhckludDY0QkV8YmlnLWVuZGlhbiBzaWduZWQgaW50IGxheW91dHN9XG4gKiBpbnRlcnByZXRlZCBhcyBOdW1iZXJzLiAqL1xuZXhwb3J0cy5uczY0YmUgPSAocHJvcGVydHkgPT4gbmV3IE5lYXJJbnQ2NEJFKHByb3BlcnR5KSk7XG5cbi8qKiBGYWN0b3J5IGZvciB7QGxpbmsgRmxvYXR8bGl0dGxlLWVuZGlhbiAzMi1iaXQgZmxvYXRpbmcgcG9pbnR9IHZhbHVlcy4gKi9cbmV4cG9ydHMuZjMyID0gKHByb3BlcnR5ID0+IG5ldyBGbG9hdChwcm9wZXJ0eSkpO1xuXG4vKiogRmFjdG9yeSBmb3Ige0BsaW5rIEZsb2F0QkV8YmlnLWVuZGlhbiAzMi1iaXQgZmxvYXRpbmcgcG9pbnR9IHZhbHVlcy4gKi9cbmV4cG9ydHMuZjMyYmUgPSAocHJvcGVydHkgPT4gbmV3IEZsb2F0QkUocHJvcGVydHkpKTtcblxuLyoqIEZhY3RvcnkgZm9yIHtAbGluayBEb3VibGV8bGl0dGxlLWVuZGlhbiA2NC1iaXQgZmxvYXRpbmcgcG9pbnR9IHZhbHVlcy4gKi9cbmV4cG9ydHMuZjY0ID0gKHByb3BlcnR5ID0+IG5ldyBEb3VibGUocHJvcGVydHkpKTtcblxuLyoqIEZhY3RvcnkgZm9yIHtAbGluayBEb3VibGVCRXxiaWctZW5kaWFuIDY0LWJpdCBmbG9hdGluZyBwb2ludH0gdmFsdWVzLiAqL1xuZXhwb3J0cy5mNjRiZSA9IChwcm9wZXJ0eSA9PiBuZXcgRG91YmxlQkUocHJvcGVydHkpKTtcblxuLyoqIEZhY3RvcnkgZm9yIHtAbGluayBTdHJ1Y3R1cmV9IHZhbHVlcy4gKi9cbmV4cG9ydHMuc3RydWN0ID0gKChmaWVsZHMsIHByb3BlcnR5LCBkZWNvZGVQcmVmaXhlcykgPT4gbmV3IFN0cnVjdHVyZShmaWVsZHMsIHByb3BlcnR5LCBkZWNvZGVQcmVmaXhlcykpO1xuXG4vKiogRmFjdG9yeSBmb3Ige0BsaW5rIEJpdFN0cnVjdHVyZX0gdmFsdWVzLiAqL1xuZXhwb3J0cy5iaXRzID0gKCh3b3JkLCBtc2IsIHByb3BlcnR5KSA9PiBuZXcgQml0U3RydWN0dXJlKHdvcmQsIG1zYiwgcHJvcGVydHkpKTtcblxuLyoqIEZhY3RvcnkgZm9yIHtAbGluayBTZXF1ZW5jZX0gdmFsdWVzLiAqL1xuZXhwb3J0cy5zZXEgPSAoKGVsZW1lbnRMYXlvdXQsIGNvdW50LCBwcm9wZXJ0eSkgPT4gbmV3IFNlcXVlbmNlKGVsZW1lbnRMYXlvdXQsIGNvdW50LCBwcm9wZXJ0eSkpO1xuXG4vKiogRmFjdG9yeSBmb3Ige0BsaW5rIFVuaW9ufSB2YWx1ZXMuICovXG5leHBvcnRzLnVuaW9uID0gKChkaXNjciwgZGVmYXVsdExheW91dCwgcHJvcGVydHkpID0+IG5ldyBVbmlvbihkaXNjciwgZGVmYXVsdExheW91dCwgcHJvcGVydHkpKTtcblxuLyoqIEZhY3RvcnkgZm9yIHtAbGluayBVbmlvbkxheW91dERpc2NyaW1pbmF0b3J9IHZhbHVlcy4gKi9cbmV4cG9ydHMudW5pb25MYXlvdXREaXNjcmltaW5hdG9yID0gKChsYXlvdXQsIHByb3BlcnR5KSA9PiBuZXcgVW5pb25MYXlvdXREaXNjcmltaW5hdG9yKGxheW91dCwgcHJvcGVydHkpKTtcblxuLyoqIEZhY3RvcnkgZm9yIHtAbGluayBCbG9ifSB2YWx1ZXMuICovXG5leHBvcnRzLmJsb2IgPSAoKGxlbmd0aCwgcHJvcGVydHkpID0+IG5ldyBCbG9iKGxlbmd0aCwgcHJvcGVydHkpKTtcblxuLyoqIEZhY3RvcnkgZm9yIHtAbGluayBDU3RyaW5nfSB2YWx1ZXMuICovXG5leHBvcnRzLmNzdHIgPSAocHJvcGVydHkgPT4gbmV3IENTdHJpbmcocHJvcGVydHkpKTtcblxuLyoqIEZhY3RvcnkgZm9yIHtAbGluayBVVEY4fSB2YWx1ZXMuICovXG5leHBvcnRzLnV0ZjggPSAoKG1heFNwYW4sIHByb3BlcnR5KSA9PiBuZXcgVVRGOChtYXhTcGFuLCBwcm9wZXJ0eSkpO1xuXG4vKiogRmFjdG9yeSBmb3Ige0BsaW5rIENvbnN0YW50fSB2YWx1ZXMuICovXG5leHBvcnRzLmNvbnN0ID0gKCh2YWx1ZSwgcHJvcGVydHkpID0+IG5ldyBDb25zdGFudCh2YWx1ZSwgcHJvcGVydHkpKTtcbiJdLCJuYW1lcyI6WyJMYXlvdXQiLCJjb25zdHJ1Y3RvciIsInNwYW4iLCJwcm9wZXJ0eSIsIk51bWJlciIsImlzSW50ZWdlciIsIlR5cGVFcnJvciIsIm1ha2VEZXN0aW5hdGlvbk9iamVjdCIsImRlY29kZSIsImIiLCJvZmZzZXQiLCJFcnJvciIsImVuY29kZSIsInNyYyIsImdldFNwYW4iLCJSYW5nZUVycm9yIiwicmVwbGljYXRlIiwicnYiLCJPYmplY3QiLCJjcmVhdGUiLCJwcm90b3R5cGUiLCJhc3NpZ24iLCJmcm9tQXJyYXkiLCJ2YWx1ZXMiLCJ1bmRlZmluZWQiLCJleHBvcnRzIiwibmFtZVdpdGhQcm9wZXJ0eSIsIm5hbWUiLCJsbyIsImJpbmRDb25zdHJ1Y3RvckxheW91dCIsIkNsYXNzIiwibGF5b3V0IiwiaGFzT3duUHJvcGVydHkiLCJsYXlvdXRfIiwiYm91bmRDb25zdHJ1Y3Rvcl8iLCJkZWZpbmVQcm9wZXJ0eSIsInZhbHVlIiwid3JpdGFibGUiLCJFeHRlcm5hbExheW91dCIsImlzQ291bnQiLCJHcmVlZHlDb3VudCIsImVsZW1lbnRTcGFuIiwicmVtIiwibGVuZ3RoIiwiTWF0aCIsImZsb29yIiwiT2Zmc2V0TGF5b3V0IiwiVUludCIsIlVJbnRCRSIsInJlYWRVSW50TEUiLCJ3cml0ZVVJbnRMRSIsInJlYWRVSW50QkUiLCJ3cml0ZVVJbnRCRSIsIkludCIsInJlYWRJbnRMRSIsIndyaXRlSW50TEUiLCJJbnRCRSIsInJlYWRJbnRCRSIsIndyaXRlSW50QkUiLCJWMkUzMiIsInBvdyIsImRpdm1vZEludDY0IiwiaGkzMiIsImxvMzIiLCJyb3VuZGVkSW50NjQiLCJOZWFyVUludDY0IiwicmVhZFVJbnQzMkxFIiwic3BsaXQiLCJ3cml0ZVVJbnQzMkxFIiwiTmVhclVJbnQ2NEJFIiwicmVhZFVJbnQzMkJFIiwid3JpdGVVSW50MzJCRSIsIk5lYXJJbnQ2NCIsInJlYWRJbnQzMkxFIiwid3JpdGVJbnQzMkxFIiwiTmVhckludDY0QkUiLCJyZWFkSW50MzJCRSIsIndyaXRlSW50MzJCRSIsIkZsb2F0IiwicmVhZEZsb2F0TEUiLCJ3cml0ZUZsb2F0TEUiLCJGbG9hdEJFIiwicmVhZEZsb2F0QkUiLCJ3cml0ZUZsb2F0QkUiLCJEb3VibGUiLCJyZWFkRG91YmxlTEUiLCJ3cml0ZURvdWJsZUxFIiwiRG91YmxlQkUiLCJyZWFkRG91YmxlQkUiLCJ3cml0ZURvdWJsZUJFIiwiU2VxdWVuY2UiLCJlbGVtZW50TGF5b3V0IiwiY291bnQiLCJpZHgiLCJpIiwicHVzaCIsImVsbyIsInJlZHVjZSIsInYiLCJTdHJ1Y3R1cmUiLCJmaWVsZHMiLCJkZWNvZGVQcmVmaXhlcyIsIkFycmF5IiwiaXNBcnJheSIsImFjYyIsImZkIiwiZSIsImZzcCIsImRlc3QiLCJmaXJzdE9mZnNldCIsImxhc3RPZmZzZXQiLCJsYXN0V3JvdGUiLCJmdiIsInNoaWZ0IiwibGF5b3V0Rm9yIiwib2Zmc2V0T2YiLCJVbmlvbkRpc2NyaW1pbmF0b3IiLCJVbmlvbkxheW91dERpc2NyaW1pbmF0b3IiLCJVbmlvbiIsImRpc2NyIiwiZGVmYXVsdExheW91dCIsInVwdiIsImRpc2NyaW1pbmF0b3IiLCJ1c2VzUHJlZml4RGlzY3JpbWluYXRvciIsInJlZ2lzdHJ5IiwiYm91bmRHZXRTb3VyY2VWYXJpYW50IiwiZGVmYXVsdEdldFNvdXJjZVZhcmlhbnQiLCJiaW5kIiwiZ2V0U291cmNlVmFyaWFudCIsImNvbmZpZ0dldFNvdXJjZVZhcmlhbnQiLCJnc3YiLCJ2bG8iLCJnZXRWYXJpYW50IiwidGFnIiwiZGxvIiwiY2xvIiwiY29udGVudE9mZnNldCIsImFkZFZhcmlhbnQiLCJ2YXJpYW50IiwiVmFyaWFudExheW91dCIsInZiIiwiQnVmZmVyIiwiaXNCdWZmZXIiLCJ1bmlvbiIsImZpeEJpdHdpc2VSZXN1bHQiLCJCaXRTdHJ1Y3R1cmUiLCJ3b3JkIiwibXNiIiwiX3BhY2tlZFNldFZhbHVlIiwiX3BhY2tlZEdldFZhbHVlIiwiYWRkRmllbGQiLCJiaXRzIiwiYmYiLCJCaXRGaWVsZCIsImFkZEJvb2xlYW4iLCJCb29sZWFuIiwiZmllbGRGb3IiLCJjb250YWluZXIiLCJ0b3RhbEJpdHMiLCJ1c2VkQml0cyIsInN1bSIsInZhbHVlTWFzayIsInN0YXJ0Iiwid29yZE1hc2siLCJ3b3JkVmFsdWUiLCJjYWxsIiwiQmxvYiIsInNsaWNlIiwid3JpdGUiLCJ0b1N0cmluZyIsIkNTdHJpbmciLCJzcmNiIiwiY29weSIsIlVURjgiLCJtYXhTcGFuIiwiQ29uc3RhbnQiLCJncmVlZHkiLCJ1OCIsInUxNiIsInUyNCIsInUzMiIsInU0MCIsInU0OCIsIm51NjQiLCJ1MTZiZSIsInUyNGJlIiwidTMyYmUiLCJ1NDBiZSIsInU0OGJlIiwibnU2NGJlIiwiczgiLCJzMTYiLCJzMjQiLCJzMzIiLCJzNDAiLCJzNDgiLCJuczY0IiwiczE2YmUiLCJzMjRiZSIsInMzMmJlIiwiczQwYmUiLCJzNDhiZSIsIm5zNjRiZSIsImYzMiIsImYzMmJlIiwiZjY0IiwiZjY0YmUiLCJzdHJ1Y3QiLCJzZXEiLCJ1bmlvbkxheW91dERpc2NyaW1pbmF0b3IiLCJibG9iIiwiY3N0ciIsInV0ZjgiLCJjb25zdCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/buffer-layout/lib/Layout.js\n");

/***/ })

};
;