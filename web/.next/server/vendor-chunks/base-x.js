"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/base-x";
exports.ids = ["vendor-chunks/base-x"];
exports.modules = {

/***/ "(ssr)/../anchor/node_modules/base-x/src/index.js":
/*!**************************************************!*\
  !*** ../anchor/node_modules/base-x/src/index.js ***!
  \**************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n// base-x encoding / decoding\n// Copyright (c) 2018 base-x contributors\n// Copyright (c) 2014-2018 The Bitcoin Core developers (base58.cpp)\n// Distributed under the MIT software license, see the accompanying\n// file LICENSE or http://www.opensource.org/licenses/mit-license.php.\n// @ts-ignore\nvar _Buffer = (__webpack_require__(/*! safe-buffer */ \"(ssr)/../anchor/node_modules/safe-buffer/index.js\").Buffer);\nfunction base(ALPHABET) {\n    if (ALPHABET.length >= 255) {\n        throw new TypeError(\"Alphabet too long\");\n    }\n    var BASE_MAP = new Uint8Array(256);\n    for(var j = 0; j < BASE_MAP.length; j++){\n        BASE_MAP[j] = 255;\n    }\n    for(var i = 0; i < ALPHABET.length; i++){\n        var x = ALPHABET.charAt(i);\n        var xc = x.charCodeAt(0);\n        if (BASE_MAP[xc] !== 255) {\n            throw new TypeError(x + \" is ambiguous\");\n        }\n        BASE_MAP[xc] = i;\n    }\n    var BASE = ALPHABET.length;\n    var LEADER = ALPHABET.charAt(0);\n    var FACTOR = Math.log(BASE) / Math.log(256) // log(BASE) / log(256), rounded up\n    ;\n    var iFACTOR = Math.log(256) / Math.log(BASE) // log(256) / log(BASE), rounded up\n    ;\n    function encode(source) {\n        if (Array.isArray(source) || source instanceof Uint8Array) {\n            source = _Buffer.from(source);\n        }\n        if (!_Buffer.isBuffer(source)) {\n            throw new TypeError(\"Expected Buffer\");\n        }\n        if (source.length === 0) {\n            return \"\";\n        }\n        // Skip & count leading zeroes.\n        var zeroes = 0;\n        var length = 0;\n        var pbegin = 0;\n        var pend = source.length;\n        while(pbegin !== pend && source[pbegin] === 0){\n            pbegin++;\n            zeroes++;\n        }\n        // Allocate enough space in big-endian base58 representation.\n        var size = (pend - pbegin) * iFACTOR + 1 >>> 0;\n        var b58 = new Uint8Array(size);\n        // Process the bytes.\n        while(pbegin !== pend){\n            var carry = source[pbegin];\n            // Apply \"b58 = b58 * 256 + ch\".\n            var i = 0;\n            for(var it1 = size - 1; (carry !== 0 || i < length) && it1 !== -1; it1--, i++){\n                carry += 256 * b58[it1] >>> 0;\n                b58[it1] = carry % BASE >>> 0;\n                carry = carry / BASE >>> 0;\n            }\n            if (carry !== 0) {\n                throw new Error(\"Non-zero carry\");\n            }\n            length = i;\n            pbegin++;\n        }\n        // Skip leading zeroes in base58 result.\n        var it2 = size - length;\n        while(it2 !== size && b58[it2] === 0){\n            it2++;\n        }\n        // Translate the result into a string.\n        var str = LEADER.repeat(zeroes);\n        for(; it2 < size; ++it2){\n            str += ALPHABET.charAt(b58[it2]);\n        }\n        return str;\n    }\n    function decodeUnsafe(source) {\n        if (typeof source !== \"string\") {\n            throw new TypeError(\"Expected String\");\n        }\n        if (source.length === 0) {\n            return _Buffer.alloc(0);\n        }\n        var psz = 0;\n        // Skip and count leading '1's.\n        var zeroes = 0;\n        var length = 0;\n        while(source[psz] === LEADER){\n            zeroes++;\n            psz++;\n        }\n        // Allocate enough space in big-endian base256 representation.\n        var size = (source.length - psz) * FACTOR + 1 >>> 0 // log(58) / log(256), rounded up.\n        ;\n        var b256 = new Uint8Array(size);\n        // Process the characters.\n        while(psz < source.length){\n            // Decode character\n            var carry = BASE_MAP[source.charCodeAt(psz)];\n            // Invalid character\n            if (carry === 255) {\n                return;\n            }\n            var i = 0;\n            for(var it3 = size - 1; (carry !== 0 || i < length) && it3 !== -1; it3--, i++){\n                carry += BASE * b256[it3] >>> 0;\n                b256[it3] = carry % 256 >>> 0;\n                carry = carry / 256 >>> 0;\n            }\n            if (carry !== 0) {\n                throw new Error(\"Non-zero carry\");\n            }\n            length = i;\n            psz++;\n        }\n        // Skip leading zeroes in b256.\n        var it4 = size - length;\n        while(it4 !== size && b256[it4] === 0){\n            it4++;\n        }\n        var vch = _Buffer.allocUnsafe(zeroes + (size - it4));\n        vch.fill(0x00, 0, zeroes);\n        var j = zeroes;\n        while(it4 !== size){\n            vch[j++] = b256[it4++];\n        }\n        return vch;\n    }\n    function decode(string) {\n        var buffer = decodeUnsafe(string);\n        if (buffer) {\n            return buffer;\n        }\n        throw new Error(\"Non-base\" + BASE + \" character\");\n    }\n    return {\n        encode: encode,\n        decodeUnsafe: decodeUnsafe,\n        decode: decode\n    };\n}\nmodule.exports = base;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vYW5jaG9yL25vZGVfbW9kdWxlcy9iYXNlLXgvc3JjL2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0EsNkJBQTZCO0FBQzdCLHlDQUF5QztBQUN6QyxtRUFBbUU7QUFDbkUsbUVBQW1FO0FBQ25FLHNFQUFzRTtBQUN0RSxhQUFhO0FBQ2IsSUFBSUEsVUFBVUMsb0dBQTZCO0FBQzNDLFNBQVNFLEtBQU1DLFFBQVE7SUFDckIsSUFBSUEsU0FBU0MsTUFBTSxJQUFJLEtBQUs7UUFBRSxNQUFNLElBQUlDLFVBQVU7SUFBcUI7SUFDdkUsSUFBSUMsV0FBVyxJQUFJQyxXQUFXO0lBQzlCLElBQUssSUFBSUMsSUFBSSxHQUFHQSxJQUFJRixTQUFTRixNQUFNLEVBQUVJLElBQUs7UUFDeENGLFFBQVEsQ0FBQ0UsRUFBRSxHQUFHO0lBQ2hCO0lBQ0EsSUFBSyxJQUFJQyxJQUFJLEdBQUdBLElBQUlOLFNBQVNDLE1BQU0sRUFBRUssSUFBSztRQUN4QyxJQUFJQyxJQUFJUCxTQUFTUSxNQUFNLENBQUNGO1FBQ3hCLElBQUlHLEtBQUtGLEVBQUVHLFVBQVUsQ0FBQztRQUN0QixJQUFJUCxRQUFRLENBQUNNLEdBQUcsS0FBSyxLQUFLO1lBQUUsTUFBTSxJQUFJUCxVQUFVSyxJQUFJO1FBQWlCO1FBQ3JFSixRQUFRLENBQUNNLEdBQUcsR0FBR0g7SUFDakI7SUFDQSxJQUFJSyxPQUFPWCxTQUFTQyxNQUFNO0lBQzFCLElBQUlXLFNBQVNaLFNBQVNRLE1BQU0sQ0FBQztJQUM3QixJQUFJSyxTQUFTQyxLQUFLQyxHQUFHLENBQUNKLFFBQVFHLEtBQUtDLEdBQUcsQ0FBQyxLQUFLLG1DQUFtQzs7SUFDL0UsSUFBSUMsVUFBVUYsS0FBS0MsR0FBRyxDQUFDLE9BQU9ELEtBQUtDLEdBQUcsQ0FBQ0osTUFBTSxtQ0FBbUM7O0lBQ2hGLFNBQVNNLE9BQVFDLE1BQU07UUFDckIsSUFBSUMsTUFBTUMsT0FBTyxDQUFDRixXQUFXQSxrQkFBa0JkLFlBQVk7WUFBRWMsU0FB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LFFBQVMsUUFBUztZQUM1QjtZQUNBLElBQUlBLFVBQVUsR0FBRztnQkFBRSxNQUFNLElBQUlFLE1BQU07WUFBa0I7WUFDckQ3QixTQUFTSztZQUNUOEI7UUFDRjtRQUNJLCtCQUErQjtRQUNuQyxJQUFJRyxNQUFNYixPQUFPekI7UUFDakIsTUFBT3NDLFFBQVFiLFFBQVFXLElBQUksQ0FBQ0UsSUFBSSxLQUFLLEVBQUc7WUFDdENBO1FBQ0Y7UUFDQSxJQUFJQyxNQUFNNUMsUUFBUTZDLFdBQVcsQ0FBQ2xCLFNBQVVHLENBQUFBLE9BQU9hLEdBQUU7UUFDakRDLElBQUlFLElBQUksQ0FBQyxNQUFNLEdBQUduQjtRQUNsQixJQUFJbEIsSUFBSWtCO1FBQ1IsTUFBT2dCLFFBQVFiLEtBQU07WUFDbkJjLEdBQUcsQ0FBQ25DLElBQUksR0FBR2dDLElBQUksQ0FBQ0UsTUFBTTtRQUN4QjtRQUNBLE9BQU9DO0lBQ1Q7SUFDQSxTQUFTRyxPQUFRQyxNQUFNO1FBQ3JCLElBQUlDLFNBQVNYLGFBQWFVO1FBQzFCLElBQUlDLFFBQVE7WUFBRSxPQUFPQTtRQUFPO1FBQzVCLE1BQU0sSUFBSWYsTUFBTSxhQUFhbkIsT0FBTztJQUN0QztJQUNBLE9BQU87UUFDTE0sUUFBUUE7UUFDUmlCLGNBQWNBO1FBQ2RTLFFBQVFBO0lBQ1Y7QUFDRjtBQUNBRyxPQUFPQyxPQUFPLEdBQUdoRCIsInNvdXJjZXMiOlsid2VicGFjazovLy8uLi9hbmNob3Ivbm9kZV9tb2R1bGVzL2Jhc2UteC9zcmMvaW5kZXguanM/N2E3ZiJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCdcbi8vIGJhc2UteCBlbmNvZGluZyAvIGRlY29kaW5nXG4vLyBDb3B5cmlnaHQgKGMpIDIwMTggYmFzZS14IGNvbnRyaWJ1dG9yc1xuLy8gQ29weXJpZ2h0IChjKSAyMDE0LTIwMTggVGhlIEJpdGNvaW4gQ29yZSBkZXZlbG9wZXJzIChiYXNlNTguY3BwKVxuLy8gRGlzdHJpYnV0ZWQgdW5kZXIgdGhlIE1JVCBzb2Z0d2FyZSBsaWNlbnNlLCBzZWUgdGhlIGFjY29tcGFueWluZ1xuLy8gZmlsZSBMSUNFTlNFIG9yIGh0dHA6Ly93d3cub3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvbWl0LWxpY2Vuc2UucGhwLlxuLy8gQHRzLWlnbm9yZVxudmFyIF9CdWZmZXIgPSByZXF1aXJlKCdzYWZlLWJ1ZmZlcicpLkJ1ZmZlclxuZnVuY3Rpb24gYmFzZSAoQUxQSEFCRVQpIHtcbiAgaWYgKEFMUEhBQkVULmxlbmd0aCA+PSAyNTUpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcignQWxwaGFiZXQgdG9vIGxvbmcnKSB9XG4gIHZhciBCQVNFX01BUCA9IG5ldyBVaW50OEFycmF5KDI1NilcbiAgZm9yICh2YXIgaiA9IDA7IGogPCBCQVNFX01BUC5sZW5ndGg7IGorKykge1xuICAgIEJBU0VfTUFQW2pdID0gMjU1XG4gIH1cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBBTFBIQUJFVC5sZW5ndGg7IGkrKykge1xuICAgIHZhciB4ID0gQUxQSEFCRVQuY2hhckF0KGkpXG4gICAgdmFyIHhjID0geC5jaGFyQ29kZUF0KDApXG4gICAgaWYgKEJBU0VfTUFQW3hjXSAhPT0gMjU1KSB7IHRocm93IG5ldyBUeXBlRXJyb3IoeCArICcgaXMgYW1iaWd1b3VzJykgfVxuICAgIEJBU0VfTUFQW3hjXSA9IGlcbiAgfVxuICB2YXIgQkFTRSA9IEFMUEhBQkVULmxlbmd0aFxuICB2YXIgTEVBREVSID0gQUxQSEFCRVQuY2hhckF0KDApXG4gIHZhciBGQUNUT1IgPSBNYXRoLmxvZyhCQVNFKSAvIE1hdGgubG9nKDI1NikgLy8gbG9nKEJBU0UpIC8gbG9nKDI1NiksIHJvdW5kZWQgdXBcbiAgdmFyIGlGQUNUT1IgPSBNYXRoLmxvZygyNTYpIC8gTWF0aC5sb2coQkFTRSkgLy8gbG9nKDI1NikgLyBsb2coQkFTRSksIHJvdW5kZWQgdXBcbiAgZnVuY3Rpb24gZW5jb2RlIChzb3VyY2UpIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShzb3VyY2UpIHx8IHNvdXJjZSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpIHsgc291cmNlID0gX0J1ZmZlci5mcm9tKHNvdXJjZSkgfVxuICAgIGlmICghX0J1ZmZlci5pc0J1ZmZlcihzb3VyY2UpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoJ0V4cGVjdGVkIEJ1ZmZlcicpIH1cbiAgICBpZiAoc291cmNlLmxlbmd0aCA9PT0gMCkgeyByZXR1cm4gJycgfVxuICAgICAgICAvLyBTa2lwICYgY291bnQgbGVhZGluZyB6ZXJvZXMuXG4gICAgdmFyIHplcm9lcyA9IDBcbiAgICB2YXIgbGVuZ3RoID0gMFxuICAgIHZhciBwYmVnaW4gPSAwXG4gICAgdmFyIHBlbmQgPSBzb3VyY2UubGVuZ3RoXG4gICAgd2hpbGUgKHBiZWdpbiAhPT0gcGVuZCAmJiBzb3VyY2VbcGJlZ2luXSA9PT0gMCkge1xuICAgICAgcGJlZ2luKytcbiAgICAgIHplcm9lcysrXG4gICAgfVxuICAgICAgICAvLyBBbGxvY2F0ZSBlbm91Z2ggc3BhY2UgaW4gYmlnLWVuZGlhbiBiYXNlNTggcmVwcmVzZW50YXRpb24uXG4gICAgdmFyIHNpemUgPSAoKHBlbmQgLSBwYmVnaW4pICogaUZBQ1RPUiArIDEpID4+PiAwXG4gICAgdmFyIGI1OCA9IG5ldyBVaW50OEFycmF5KHNpemUpXG4gICAgICAgIC8vIFByb2Nlc3MgdGhlIGJ5dGVzLlxuICAgIHdoaWxlIChwYmVnaW4gIT09IHBlbmQpIHtcbiAgICAgIHZhciBjYXJyeSA9IHNvdXJjZVtwYmVnaW5dXG4gICAgICAgICAgICAvLyBBcHBseSBcImI1OCA9IGI1OCAqIDI1NiArIGNoXCIuXG4gICAgICB2YXIgaSA9IDBcbiAgICAgIGZvciAodmFyIGl0MSA9IHNpemUgLSAxOyAoY2FycnkgIT09IDAgfHwgaSA8IGxlbmd0aCkgJiYgKGl0MSAhPT0gLTEpOyBpdDEtLSwgaSsrKSB7XG4gICAgICAgIGNhcnJ5ICs9ICgyNTYgKiBiNThbaXQxXSkgPj4+IDBcbiAgICAgICAgYjU4W2l0MV0gPSAoY2FycnkgJSBCQVNFKSA+Pj4gMFxuICAgICAgICBjYXJyeSA9IChjYXJyeSAvIEJBU0UpID4+PiAwXG4gICAgICB9XG4gICAgICBpZiAoY2FycnkgIT09IDApIHsgdGhyb3cgbmV3IEVycm9yKCdOb24temVybyBjYXJyeScpIH1cbiAgICAgIGxlbmd0aCA9IGlcbiAgICAgIHBiZWdpbisrXG4gICAgfVxuICAgICAgICAvLyBTa2lwIGxlYWRpbmcgemVyb2VzIGluIGJhc2U1OCByZXN1bHQuXG4gICAgdmFyIGl0MiA9IHNpemUgLSBsZW5ndGhcbiAgICB3aGlsZSAoaXQyICE9PSBzaXplICYmIGI1OFtpdDJdID09PSAwKSB7XG4gICAgICBpdDIrK1xuICAgIH1cbiAgICAgICAgLy8gVHJhbnNsYXRlIHRoZSByZXN1bHQgaW50byBhIHN0cmluZy5cbiAgICB2YXIgc3RyID0gTEVBREVSLnJlcGVhdCh6ZXJvZXMpXG4gICAgZm9yICg7IGl0MiA8IHNpemU7ICsraXQyKSB7IHN0ciArPSBBTFBIQUJFVC5jaGFyQXQoYjU4W2l0Ml0pIH1cbiAgICByZXR1cm4gc3RyXG4gIH1cbiAgZnVuY3Rpb24gZGVjb2RlVW5zYWZlIChzb3VyY2UpIHtcbiAgICBpZiAodHlwZW9mIHNvdXJjZSAhPT0gJ3N0cmluZycpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcignRXhwZWN0ZWQgU3RyaW5nJykgfVxuICAgIGlmIChzb3VyY2UubGVuZ3RoID09PSAwKSB7IHJldHVybiBfQnVmZmVyLmFsbG9jKDApIH1cbiAgICB2YXIgcHN6ID0gMFxuICAgICAgICAvLyBTa2lwIGFuZCBjb3VudCBsZWFkaW5nICcxJ3MuXG4gICAgdmFyIHplcm9lcyA9IDBcbiAgICB2YXIgbGVuZ3RoID0gMFxuICAgIHdoaWxlIChzb3VyY2VbcHN6XSA9PT0gTEVBREVSKSB7XG4gICAgICB6ZXJvZXMrK1xuICAgICAgcHN6KytcbiAgICB9XG4gICAgICAgIC8vIEFsbG9jYXRlIGVub3VnaCBzcGFjZSBpbiBiaWctZW5kaWFuIGJhc2UyNTYgcmVwcmVzZW50YXRpb24uXG4gICAgdmFyIHNpemUgPSAoKChzb3VyY2UubGVuZ3RoIC0gcHN6KSAqIEZBQ1RPUikgKyAxKSA+Pj4gMCAvLyBsb2coNTgpIC8gbG9nKDI1NiksIHJvdW5kZWQgdXAuXG4gICAgdmFyIGIyNTYgPSBuZXcgVWludDhBcnJheShzaXplKVxuICAgICAgICAvLyBQcm9jZXNzIHRoZSBjaGFyYWN0ZXJzLlxuICAgIHdoaWxlIChwc3ogPCBzb3VyY2UubGVuZ3RoKSB7XG4gICAgICAgICAgICAvLyBEZWNvZGUgY2hhcmFjdGVyXG4gICAgICB2YXIgY2FycnkgPSBCQVNFX01BUFtzb3VyY2UuY2hhckNvZGVBdChwc3opXVxuICAgICAgICAgICAgLy8gSW52YWxpZCBjaGFyYWN0ZXJcbiAgICAgIGlmIChjYXJyeSA9PT0gMjU1KSB7IHJldHVybiB9XG4gICAgICB2YXIgaSA9IDBcbiAgICAgIGZvciAodmFyIGl0MyA9IHNpemUgLSAxOyAoY2FycnkgIT09IDAgfHwgaSA8IGxlbmd0aCkgJiYgKGl0MyAhPT0gLTEpOyBpdDMtLSwgaSsrKSB7XG4gICAgICAgIGNhcnJ5ICs9IChCQVNFICogYjI1NltpdDNdKSA+Pj4gMFxuICAgICAgICBiMjU2W2l0M10gPSAoY2FycnkgJSAyNTYpID4+PiAwXG4gICAgICAgIGNhcnJ5ID0gKGNhcnJ5IC8gMjU2KSA+Pj4gMFxuICAgICAgfVxuICAgICAgaWYgKGNhcnJ5ICE9PSAwKSB7IHRocm93IG5ldyBFcnJvcignTm9uLXplcm8gY2FycnknKSB9XG4gICAgICBsZW5ndGggPSBpXG4gICAgICBwc3orK1xuICAgIH1cbiAgICAgICAgLy8gU2tpcCBsZWFkaW5nIHplcm9lcyBpbiBiMjU2LlxuICAgIHZhciBpdDQgPSBzaXplIC0gbGVuZ3RoXG4gICAgd2hpbGUgKGl0NCAhPT0gc2l6ZSAmJiBiMjU2W2l0NF0gPT09IDApIHtcbiAgICAgIGl0NCsrXG4gICAgfVxuICAgIHZhciB2Y2ggPSBfQnVmZmVyLmFsbG9jVW5zYWZlKHplcm9lcyArIChzaXplIC0gaXQ0KSlcbiAgICB2Y2guZmlsbCgweDAwLCAwLCB6ZXJvZXMpXG4gICAgdmFyIGogPSB6ZXJvZXNcbiAgICB3aGlsZSAoaXQ0ICE9PSBzaXplKSB7XG4gICAgICB2Y2hbaisrXSA9IGIyNTZbaXQ0KytdXG4gICAgfVxuICAgIHJldHVybiB2Y2hcbiAgfVxuICBmdW5jdGlvbiBkZWNvZGUgKHN0cmluZykge1xuICAgIHZhciBidWZmZXIgPSBkZWNvZGVVbnNhZmUoc3RyaW5nKVxuICAgIGlmIChidWZmZXIpIHsgcmV0dXJuIGJ1ZmZlciB9XG4gICAgdGhyb3cgbmV3IEVycm9yKCdOb24tYmFzZScgKyBCQVNFICsgJyBjaGFyYWN0ZXInKVxuICB9XG4gIHJldHVybiB7XG4gICAgZW5jb2RlOiBlbmNvZGUsXG4gICAgZGVjb2RlVW5zYWZlOiBkZWNvZGVVbnNhZmUsXG4gICAgZGVjb2RlOiBkZWNvZGVcbiAgfVxufVxubW9kdWxlLmV4cG9ydHMgPSBiYXNlXG4iXSwibmFtZXMiOlsiX0J1ZmZlciIsInJlcXVpcmUiLCJCdWZmZXIiLCJiYXNlIiwiQUxQSEFCRVQiLCJsZW5ndGgiLCJUeXBlRXJyb3IiLCJCQVNFX01BUCIsIlVpbnQ4QXJyYXkiLCJqIiwiaSIsIngiLCJjaGFyQXQiLCJ4YyIsImNoYXJDb2RlQXQiLCJCQVNFIiwiTEVBREVSIiwiRkFDVE9SIiwiTWF0aCIsImxvZyIsImlGQUNUT1IiLCJlbmNvZGUiLCJzb3VyY2UiLCJBcnJheSIsImlzQXJyYXkiLCJmcm9tIiwiaXNCdWZmZXIiLCJ6ZXJvZXMiLCJwYmVnaW4iLCJwZW5kIiwic2l6ZSIsImI1OCIsImNhcnJ5IiwiaXQxIiwiRXJyb3IiLCJpdDIiLCJzdHIiLCJyZXBlYXQiLCJkZWNvZGVVbnNhZmUiLCJhbGxvYyIsInBzeiIsImIyNTYiLCJpdDMiLCJpdDQiLCJ2Y2giLCJhbGxvY1Vuc2FmZSIsImZpbGwiLCJkZWNvZGUiLCJzdHJpbmciLCJidWZmZXIiLCJtb2R1bGUiLCJleHBvcnRzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/../anchor/node_modules/base-x/src/index.js\n");

/***/ }),

/***/ "(ssr)/../node_modules/base-x/src/index.js":
/*!*******************************************!*\
  !*** ../node_modules/base-x/src/index.js ***!
  \*******************************************/
/***/ ((module) => {

eval("\n// base-x encoding / decoding\n// Copyright (c) 2018 base-x contributors\n// Copyright (c) 2014-2018 The Bitcoin Core developers (base58.cpp)\n// Distributed under the MIT software license, see the accompanying\n// file LICENSE or http://www.opensource.org/licenses/mit-license.php.\nfunction base(ALPHABET) {\n    if (ALPHABET.length >= 255) {\n        throw new TypeError(\"Alphabet too long\");\n    }\n    var BASE_MAP = new Uint8Array(256);\n    for(var j = 0; j < BASE_MAP.length; j++){\n        BASE_MAP[j] = 255;\n    }\n    for(var i = 0; i < ALPHABET.length; i++){\n        var x = ALPHABET.charAt(i);\n        var xc = x.charCodeAt(0);\n        if (BASE_MAP[xc] !== 255) {\n            throw new TypeError(x + \" is ambiguous\");\n        }\n        BASE_MAP[xc] = i;\n    }\n    var BASE = ALPHABET.length;\n    var LEADER = ALPHABET.charAt(0);\n    var FACTOR = Math.log(BASE) / Math.log(256) // log(BASE) / log(256), rounded up\n    ;\n    var iFACTOR = Math.log(256) / Math.log(BASE) // log(256) / log(BASE), rounded up\n    ;\n    function encode(source) {\n        if (source instanceof Uint8Array) {} else if (ArrayBuffer.isView(source)) {\n            source = new Uint8Array(source.buffer, source.byteOffset, source.byteLength);\n        } else if (Array.isArray(source)) {\n            source = Uint8Array.from(source);\n        }\n        if (!(source instanceof Uint8Array)) {\n            throw new TypeError(\"Expected Uint8Array\");\n        }\n        if (source.length === 0) {\n            return \"\";\n        }\n        // Skip & count leading zeroes.\n        var zeroes = 0;\n        var length = 0;\n        var pbegin = 0;\n        var pend = source.length;\n        while(pbegin !== pend && source[pbegin] === 0){\n            pbegin++;\n            zeroes++;\n        }\n        // Allocate enough space in big-endian base58 representation.\n        var size = (pend - pbegin) * iFACTOR + 1 >>> 0;\n        var b58 = new Uint8Array(size);\n        // Process the bytes.\n        while(pbegin !== pend){\n            var carry = source[pbegin];\n            // Apply \"b58 = b58 * 256 + ch\".\n            var i = 0;\n            for(var it1 = size - 1; (carry !== 0 || i < length) && it1 !== -1; it1--, i++){\n                carry += 256 * b58[it1] >>> 0;\n                b58[it1] = carry % BASE >>> 0;\n                carry = carry / BASE >>> 0;\n            }\n            if (carry !== 0) {\n                throw new Error(\"Non-zero carry\");\n            }\n            length = i;\n            pbegin++;\n        }\n        // Skip leading zeroes in base58 result.\n        var it2 = size - length;\n        while(it2 !== size && b58[it2] === 0){\n            it2++;\n        }\n        // Translate the result into a string.\n        var str = LEADER.repeat(zeroes);\n        for(; it2 < size; ++it2){\n            str += ALPHABET.charAt(b58[it2]);\n        }\n        return str;\n    }\n    function decodeUnsafe(source) {\n        if (typeof source !== \"string\") {\n            throw new TypeError(\"Expected String\");\n        }\n        if (source.length === 0) {\n            return new Uint8Array();\n        }\n        var psz = 0;\n        // Skip and count leading '1's.\n        var zeroes = 0;\n        var length = 0;\n        while(source[psz] === LEADER){\n            zeroes++;\n            psz++;\n        }\n        // Allocate enough space in big-endian base256 representation.\n        var size = (source.length - psz) * FACTOR + 1 >>> 0 // log(58) / log(256), rounded up.\n        ;\n        var b256 = new Uint8Array(size);\n        // Process the characters.\n        while(source[psz]){\n            // Decode character\n            var carry = BASE_MAP[source.charCodeAt(psz)];\n            // Invalid character\n            if (carry === 255) {\n                return;\n            }\n            var i = 0;\n            for(var it3 = size - 1; (carry !== 0 || i < length) && it3 !== -1; it3--, i++){\n                carry += BASE * b256[it3] >>> 0;\n                b256[it3] = carry % 256 >>> 0;\n                carry = carry / 256 >>> 0;\n            }\n            if (carry !== 0) {\n                throw new Error(\"Non-zero carry\");\n            }\n            length = i;\n            psz++;\n        }\n        // Skip leading zeroes in b256.\n        var it4 = size - length;\n        while(it4 !== size && b256[it4] === 0){\n            it4++;\n        }\n        var vch = new Uint8Array(zeroes + (size - it4));\n        var j = zeroes;\n        while(it4 !== size){\n            vch[j++] = b256[it4++];\n        }\n        return vch;\n    }\n    function decode(string) {\n        var buffer = decodeUnsafe(string);\n        if (buffer) {\n            return buffer;\n        }\n        throw new Error(\"Non-base\" + BASE + \" character\");\n    }\n    return {\n        encode: encode,\n        decodeUnsafe: decodeUnsafe,\n        decode: decode\n    };\n}\nmodule.exports = base;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL2Jhc2UteC9zcmMvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQSw2QkFBNkI7QUFDN0IseUNBQXlDO0FBQ3pDLG1FQUFtRTtBQUNuRSxtRUFBbUU7QUFDbkUsc0VBQXNFO0FBQ3RFLFNBQVNBLEtBQU1DLFFBQVE7SUFDckIsSUFBSUEsU0FBU0MsTUFBTSxJQUFJLEtBQUs7UUFBRSxNQUFNLElBQUlDLFVBQVU7SUFBcUI7SUFDdkUsSUFBSUMsV0FBVyxJQUFJQyxXQUFXO0lBQzlCLElBQUssSUFBSUMsSUFBSSxHQUFHQSxJQUFJRixTQUFTRixNQUFNLEVBQUVJLElBQUs7UUFDeENGLFFBQVEsQ0FBQ0UsRUFBRSxHQUFHO0lBQ2hCO0lBQ0EsSUFBSyxJQUFJQyxJQUFJLEdBQUdBLElBQUlOLFNBQVNDLE1BQU0sRUFBRUssSUFBSztRQUN4QyxJQUFJQyxJQUFJUCxTQUFTUSxNQUFNLENBQUNGO1FBQ3hCLElBQUlHLEtBQUtGLEVBQUVHLFVBQVUsQ0FBQztRQUN0QixJQUFJUCxRQUFRLENBQUNNLEdBQUcsS0FBSyxLQUFLO1lBQUUsTUFBTSxJQUFJUCxVQUFVSyxJQUFJO1FBQWlCO1FBQ3JFSixRQUFRLENBQUNNLEdBQUcsR0FBR0g7SUFDakI7SUFDQSxJQUFJSyxPQUFPWCxTQUFTQyxNQUFNO0lBQzFCLElBQUlXLFNBQVNaLFNBQVNRLE1BQU0sQ0FBQztJQUM3QixJQUFJSyxTQUFTQyxLQUFLQyxHQUFHLENBQUNKLFFBQVFHLEtBQUtDLEdBQUcsQ0FBQyxLQUFLLG1DQUFtQzs7SUFDL0UsSUFBSUMsVUFBVUYsS0FBS0MsR0FBRyxDQUFDLE9BQU9ELEtBQUtDLEdBQUcsQ0FBQ0osTUFBTSxtQ0FBbUM7O0lBQ2hGLFNBQVNNLE9BQVFDLE1BQU07UUFDckIsSUFBSUEsa0JBQWtCZCxZQUFZLENBQ2xDLE9BQU8sSUFBSWUsWUFBWUMsTUFBTSxDQUFDRixTQUFTO1lBQ3JDQSxTQUFTLElBQUlkLFdBQVdjLE9BQU9HLE1BQU0s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QUFDQyxJQUFJLEtBQU07Z0JBQ2hDRCxJQUFJLENBQUNDLElBQUksR0FBRyxRQUFTLFFBQVM7Z0JBQzlCVCxRQUFRLFFBQVMsUUFBUztZQUM1QjtZQUNBLElBQUlBLFVBQVUsR0FBRztnQkFBRSxNQUFNLElBQUlFLE1BQU07WUFBa0I7WUFDckRqQyxTQUFTSztZQUNUaUM7UUFDRjtRQUNJLCtCQUErQjtRQUNuQyxJQUFJRyxNQUFNWixPQUFPN0I7UUFDakIsTUFBT3lDLFFBQVFaLFFBQVFVLElBQUksQ0FBQ0UsSUFBSSxLQUFLLEVBQUc7WUFDdENBO1FBQ0Y7UUFDQSxJQUFJQyxNQUFNLElBQUl2QyxXQUFXdUIsU0FBVUcsQ0FBQUEsT0FBT1ksR0FBRTtRQUM1QyxJQUFJckMsSUFBSXNCO1FBQ1IsTUFBT2UsUUFBUVosS0FBTTtZQUNuQmEsR0FBRyxDQUFDdEMsSUFBSSxHQUFHbUMsSUFBSSxDQUFDRSxNQUFNO1FBQ3hCO1FBQ0EsT0FBT0M7SUFDVDtJQUNBLFNBQVNDLE9BQVFDLE1BQU07UUFDckIsSUFBSXhCLFNBQVNpQixhQUFhTztRQUMxQixJQUFJeEIsUUFBUTtZQUFFLE9BQU9BO1FBQU87UUFDNUIsTUFBTSxJQUFJYSxNQUFNLGFBQWF2QixPQUFPO0lBQ3RDO0lBQ0EsT0FBTztRQUNMTSxRQUFRQTtRQUNScUIsY0FBY0E7UUFDZE0sUUFBUUE7SUFDVjtBQUNGO0FBQ0FFLE9BQU9DLE9BQU8sR0FBR2hEIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9iYXNlLXgvc3JjL2luZGV4LmpzP2U4MDIiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnXG4vLyBiYXNlLXggZW5jb2RpbmcgLyBkZWNvZGluZ1xuLy8gQ29weXJpZ2h0IChjKSAyMDE4IGJhc2UteCBjb250cmlidXRvcnNcbi8vIENvcHlyaWdodCAoYykgMjAxNC0yMDE4IFRoZSBCaXRjb2luIENvcmUgZGV2ZWxvcGVycyAoYmFzZTU4LmNwcClcbi8vIERpc3RyaWJ1dGVkIHVuZGVyIHRoZSBNSVQgc29mdHdhcmUgbGljZW5zZSwgc2VlIHRoZSBhY2NvbXBhbnlpbmdcbi8vIGZpbGUgTElDRU5TRSBvciBodHRwOi8vd3d3Lm9wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL21pdC1saWNlbnNlLnBocC5cbmZ1bmN0aW9uIGJhc2UgKEFMUEhBQkVUKSB7XG4gIGlmIChBTFBIQUJFVC5sZW5ndGggPj0gMjU1KSB7IHRocm93IG5ldyBUeXBlRXJyb3IoJ0FscGhhYmV0IHRvbyBsb25nJykgfVxuICB2YXIgQkFTRV9NQVAgPSBuZXcgVWludDhBcnJheSgyNTYpXG4gIGZvciAodmFyIGogPSAwOyBqIDwgQkFTRV9NQVAubGVuZ3RoOyBqKyspIHtcbiAgICBCQVNFX01BUFtqXSA9IDI1NVxuICB9XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgQUxQSEFCRVQubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgeCA9IEFMUEhBQkVULmNoYXJBdChpKVxuICAgIHZhciB4YyA9IHguY2hhckNvZGVBdCgwKVxuICAgIGlmIChCQVNFX01BUFt4Y10gIT09IDI1NSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKHggKyAnIGlzIGFtYmlndW91cycpIH1cbiAgICBCQVNFX01BUFt4Y10gPSBpXG4gIH1cbiAgdmFyIEJBU0UgPSBBTFBIQUJFVC5sZW5ndGhcbiAgdmFyIExFQURFUiA9IEFMUEhBQkVULmNoYXJBdCgwKVxuICB2YXIgRkFDVE9SID0gTWF0aC5sb2coQkFTRSkgLyBNYXRoLmxvZygyNTYpIC8vIGxvZyhCQVNFKSAvIGxvZygyNTYpLCByb3VuZGVkIHVwXG4gIHZhciBpRkFDVE9SID0gTWF0aC5sb2coMjU2KSAvIE1hdGgubG9nKEJBU0UpIC8vIGxvZygyNTYpIC8gbG9nKEJBU0UpLCByb3VuZGVkIHVwXG4gIGZ1bmN0aW9uIGVuY29kZSAoc291cmNlKSB7XG4gICAgaWYgKHNvdXJjZSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpIHtcbiAgICB9IGVsc2UgaWYgKEFycmF5QnVmZmVyLmlzVmlldyhzb3VyY2UpKSB7XG4gICAgICBzb3VyY2UgPSBuZXcgVWludDhBcnJheShzb3VyY2UuYnVmZmVyLCBzb3VyY2UuYnl0ZU9mZnNldCwgc291cmNlLmJ5dGVMZW5ndGgpXG4gICAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KHNvdXJjZSkpIHtcbiAgICAgIHNvdXJjZSA9IFVpbnQ4QXJyYXkuZnJvbShzb3VyY2UpXG4gICAgfVxuICAgIGlmICghKHNvdXJjZSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoJ0V4cGVjdGVkIFVpbnQ4QXJyYXknKSB9XG4gICAgaWYgKHNvdXJjZS5sZW5ndGggPT09IDApIHsgcmV0dXJuICcnIH1cbiAgICAgICAgLy8gU2tpcCAmIGNvdW50IGxlYWRpbmcgemVyb2VzLlxuICAgIHZhciB6ZXJvZXMgPSAwXG4gICAgdmFyIGxlbmd0aCA9IDBcbiAgICB2YXIgcGJlZ2luID0gMFxuICAgIHZhciBwZW5kID0gc291cmNlLmxlbmd0aFxuICAgIHdoaWxlIChwYmVnaW4gIT09IHBlbmQgJiYgc291cmNlW3BiZWdpbl0gPT09IDApIHtcbiAgICAgIHBiZWdpbisrXG4gICAgICB6ZXJvZXMrK1xuICAgIH1cbiAgICAgICAgLy8gQWxsb2NhdGUgZW5vdWdoIHNwYWNlIGluIGJpZy1lbmRpYW4gYmFzZTU4IHJlcHJlc2VudGF0aW9uLlxuICAgIHZhciBzaXplID0gKChwZW5kIC0gcGJlZ2luKSAqIGlGQUNUT1IgKyAxKSA+Pj4gMFxuICAgIHZhciBiNTggPSBuZXcgVWludDhBcnJheShzaXplKVxuICAgICAgICAvLyBQcm9jZXNzIHRoZSBieXRlcy5cbiAgICB3aGlsZSAocGJlZ2luICE9PSBwZW5kKSB7XG4gICAgICB2YXIgY2FycnkgPSBzb3VyY2VbcGJlZ2luXVxuICAgICAgICAgICAgLy8gQXBwbHkgXCJiNTggPSBiNTggKiAyNTYgKyBjaFwiLlxuICAgICAgdmFyIGkgPSAwXG4gICAgICBmb3IgKHZhciBpdDEgPSBzaXplIC0gMTsgKGNhcnJ5ICE9PSAwIHx8IGkgPCBsZW5ndGgpICYmIChpdDEgIT09IC0xKTsgaXQxLS0sIGkrKykge1xuICAgICAgICBjYXJyeSArPSAoMjU2ICogYjU4W2l0MV0pID4+PiAwXG4gICAgICAgIGI1OFtpdDFdID0gKGNhcnJ5ICUgQkFTRSkgPj4+IDBcbiAgICAgICAgY2FycnkgPSAoY2FycnkgLyBCQVNFKSA+Pj4gMFxuICAgICAgfVxuICAgICAgaWYgKGNhcnJ5ICE9PSAwKSB7IHRocm93IG5ldyBFcnJvcignTm9uLXplcm8gY2FycnknKSB9XG4gICAgICBsZW5ndGggPSBpXG4gICAgICBwYmVnaW4rK1xuICAgIH1cbiAgICAgICAgLy8gU2tpcCBsZWFkaW5nIHplcm9lcyBpbiBiYXNlNTggcmVzdWx0LlxuICAgIHZhciBpdDIgPSBzaXplIC0gbGVuZ3RoXG4gICAgd2hpbGUgKGl0MiAhPT0gc2l6ZSAmJiBiNThbaXQyXSA9PT0gMCkge1xuICAgICAgaXQyKytcbiAgICB9XG4gICAgICAgIC8vIFRyYW5zbGF0ZSB0aGUgcmVzdWx0IGludG8gYSBzdHJpbmcuXG4gICAgdmFyIHN0ciA9IExFQURFUi5yZXBlYXQoemVyb2VzKVxuICAgIGZvciAoOyBpdDIgPCBzaXplOyArK2l0MikgeyBzdHIgKz0gQUxQSEFCRVQuY2hhckF0KGI1OFtpdDJdKSB9XG4gICAgcmV0dXJuIHN0clxuICB9XG4gIGZ1bmN0aW9uIGRlY29kZVVuc2FmZSAoc291cmNlKSB7XG4gICAgaWYgKHR5cGVvZiBzb3VyY2UgIT09ICdzdHJpbmcnKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoJ0V4cGVjdGVkIFN0cmluZycpIH1cbiAgICBpZiAoc291cmNlLmxlbmd0aCA9PT0gMCkgeyByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoKSB9XG4gICAgdmFyIHBzeiA9IDBcbiAgICAgICAgLy8gU2tpcCBhbmQgY291bnQgbGVhZGluZyAnMSdzLlxuICAgIHZhciB6ZXJvZXMgPSAwXG4gICAgdmFyIGxlbmd0aCA9IDBcbiAgICB3aGlsZSAoc291cmNlW3Bzel0gPT09IExFQURFUikge1xuICAgICAgemVyb2VzKytcbiAgICAgIHBzeisrXG4gICAgfVxuICAgICAgICAvLyBBbGxvY2F0ZSBlbm91Z2ggc3BhY2UgaW4gYmlnLWVuZGlhbiBiYXNlMjU2IHJlcHJlc2VudGF0aW9uLlxuICAgIHZhciBzaXplID0gKCgoc291cmNlLmxlbmd0aCAtIHBzeikgKiBGQUNUT1IpICsgMSkgPj4+IDAgLy8gbG9nKDU4KSAvIGxvZygyNTYpLCByb3VuZGVkIHVwLlxuICAgIHZhciBiMjU2ID0gbmV3IFVpbnQ4QXJyYXkoc2l6ZSlcbiAgICAgICAgLy8gUHJvY2VzcyB0aGUgY2hhcmFjdGVycy5cbiAgICB3aGlsZSAoc291cmNlW3Bzel0pIHtcbiAgICAgICAgICAgIC8vIERlY29kZSBjaGFyYWN0ZXJcbiAgICAgIHZhciBjYXJyeSA9IEJBU0VfTUFQW3NvdXJjZS5jaGFyQ29kZUF0KHBzeildXG4gICAgICAgICAgICAvLyBJbnZhbGlkIGNoYXJhY3RlclxuICAgICAgaWYgKGNhcnJ5ID09PSAyNTUpIHsgcmV0dXJuIH1cbiAgICAgIHZhciBpID0gMFxuICAgICAgZm9yICh2YXIgaXQzID0gc2l6ZSAtIDE7IChjYXJyeSAhPT0gMCB8fCBpIDwgbGVuZ3RoKSAmJiAoaXQzICE9PSAtMSk7IGl0My0tLCBpKyspIHtcbiAgICAgICAgY2FycnkgKz0gKEJBU0UgKiBiMjU2W2l0M10pID4+PiAwXG4gICAgICAgIGIyNTZbaXQzXSA9IChjYXJyeSAlIDI1NikgPj4+IDBcbiAgICAgICAgY2FycnkgPSAoY2FycnkgLyAyNTYpID4+PiAwXG4gICAgICB9XG4gICAgICBpZiAoY2FycnkgIT09IDApIHsgdGhyb3cgbmV3IEVycm9yKCdOb24temVybyBjYXJyeScpIH1cbiAgICAgIGxlbmd0aCA9IGlcbiAgICAgIHBzeisrXG4gICAgfVxuICAgICAgICAvLyBTa2lwIGxlYWRpbmcgemVyb2VzIGluIGIyNTYuXG4gICAgdmFyIGl0NCA9IHNpemUgLSBsZW5ndGhcbiAgICB3aGlsZSAoaXQ0ICE9PSBzaXplICYmIGIyNTZbaXQ0XSA9PT0gMCkge1xuICAgICAgaXQ0KytcbiAgICB9XG4gICAgdmFyIHZjaCA9IG5ldyBVaW50OEFycmF5KHplcm9lcyArIChzaXplIC0gaXQ0KSlcbiAgICB2YXIgaiA9IHplcm9lc1xuICAgIHdoaWxlIChpdDQgIT09IHNpemUpIHtcbiAgICAgIHZjaFtqKytdID0gYjI1NltpdDQrK11cbiAgICB9XG4gICAgcmV0dXJuIHZjaFxuICB9XG4gIGZ1bmN0aW9uIGRlY29kZSAoc3RyaW5nKSB7XG4gICAgdmFyIGJ1ZmZlciA9IGRlY29kZVVuc2FmZShzdHJpbmcpXG4gICAgaWYgKGJ1ZmZlcikgeyByZXR1cm4gYnVmZmVyIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoJ05vbi1iYXNlJyArIEJBU0UgKyAnIGNoYXJhY3RlcicpXG4gIH1cbiAgcmV0dXJuIHtcbiAgICBlbmNvZGU6IGVuY29kZSxcbiAgICBkZWNvZGVVbnNhZmU6IGRlY29kZVVuc2FmZSxcbiAgICBkZWNvZGU6IGRlY29kZVxuICB9XG59XG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VcbiJdLCJuYW1lcyI6WyJiYXNlIiwiQUxQSEFCRVQiLCJsZW5ndGgiLCJUeXBlRXJyb3IiLCJCQVNFX01BUCIsIlVpbnQ4QXJyYXkiLCJqIiwiaSIsIngiLCJjaGFyQXQiLCJ4YyIsImNoYXJDb2RlQXQiLCJCQVNFIiwiTEVBREVSIiwiRkFDVE9SIiwiTWF0aCIsImxvZyIsImlGQUNUT1IiLCJlbmNvZGUiLCJzb3VyY2UiLCJBcnJheUJ1ZmZlciIsImlzVmlldyIsImJ1ZmZlciIsImJ5dGVPZmZzZXQiLCJieXRlTGVuZ3RoIiwiQXJyYXkiLCJpc0FycmF5IiwiZnJvbSIsInplcm9lcyIsInBiZWdpbiIsInBlbmQiLCJzaXplIiwiYjU4IiwiY2FycnkiLCJpdDEiLCJFcnJvciIsIml0MiIsInN0ciIsInJlcGVhdCIsImRlY29kZVVuc2FmZSIsInBzeiIsImIyNTYiLCJpdDMiLCJpdDQiLCJ2Y2giLCJkZWNvZGUiLCJzdHJpbmciLCJtb2R1bGUiLCJleHBvcnRzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/base-x/src/index.js\n");

/***/ })

};
;